__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Tablib documentation build configuration file, created by
# sphinx-quickstart on Tue Oct  5 15:25:21 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
import tablib
# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Tablib'
copyright = u'2011. A <a href="http://kennethreitz.com/pages/open-projects.html">Kenneth Reitz</a> Project'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = tablib.__version__
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
# add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'flask_theme_support.FlaskyStyle'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    'index':    ['sidebarintro.html', 'sourcelink.html', 'searchbox.html'],
    '**':       ['sidebarlogo.html', 'localtoc.html', 'relations.html',
                 'sourcelink.html', 'searchbox.html']
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
html_show_sphinx = False

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Tablibdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Tablib.tex', u'Tablib Documentation',
   u'Kenneth Reitz', 'manual'),
]

latex_use_modindex = False

latex_elements = {
    'fontpkg':      r'\usepackage{mathpazo}',
    'papersize':    'a4paper',
    'pointsize':    '12pt',
    'preamble':     r'\usepackage{krstyle}'
}
latex_use_parts = True

latex_additional_files = ['krstyle.sty']



# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'tablib', u'Tablib Documentation',
     [u'Kenneth Reitz'], 1)
]

sys.path.append(os.path.abspath('_themes'))
html_theme_path = ['_themes']
html_theme = 'kr'
########NEW FILE########
__FILENAME__ = flask_theme_support
# flasky extensions.  flasky pygments style based on tango style
from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace, Punctuation, Other, Literal


class FlaskyStyle(Style):
    background_color = "#f8f8f8"
    default_style = ""

    styles = {
        # No corresponding class for the following:
        #Text:                     "", # class:  ''
        Whitespace:                "underline #f8f8f8",      # class: 'w'
        Error:                     "#a40000 border:#ef2929", # class: 'err'
        Other:                     "#000000",                # class 'x'

        Comment:                   "italic #8f5902", # class: 'c'
        Comment.Preproc:           "noitalic",       # class: 'cp'

        Keyword:                   "bold #004461",   # class: 'k'
        Keyword.Constant:          "bold #004461",   # class: 'kc'
        Keyword.Declaration:       "bold #004461",   # class: 'kd'
        Keyword.Namespace:         "bold #004461",   # class: 'kn'
        Keyword.Pseudo:            "bold #004461",   # class: 'kp'
        Keyword.Reserved:          "bold #004461",   # class: 'kr'
        Keyword.Type:              "bold #004461",   # class: 'kt'

        Operator:                  "#582800",   # class: 'o'
        Operator.Word:             "bold #004461",   # class: 'ow' - like keywords

        Punctuation:               "bold #000000",   # class: 'p'

        # because special names such as Name.Class, Name.Function, etc.
        # are not recognized as such later in the parsing, we choose them
        # to look the same as ordinary variables.
        Name:                      "#000000",        # class: 'n'
        Name.Attribute:            "#c4a000",        # class: 'na' - to be revised
        Name.Builtin:              "#004461",        # class: 'nb'
        Name.Builtin.Pseudo:       "#3465a4",        # class: 'bp'
        Name.Class:                "#000000",        # class: 'nc' - to be revised
        Name.Constant:             "#000000",        # class: 'no' - to be revised
        Name.Decorator:            "#888",           # class: 'nd' - to be revised
        Name.Entity:               "#ce5c00",        # class: 'ni'
        Name.Exception:            "bold #cc0000",   # class: 'ne'
        Name.Function:             "#000000",        # class: 'nf'
        Name.Property:             "#000000",        # class: 'py'
        Name.Label:                "#f57900",        # class: 'nl'
        Name.Namespace:            "#000000",        # class: 'nn' - to be revised
        Name.Other:                "#000000",        # class: 'nx'
        Name.Tag:                  "bold #004461",   # class: 'nt' - like a keyword
        Name.Variable:             "#000000",        # class: 'nv' - to be revised
        Name.Variable.Class:       "#000000",        # class: 'vc' - to be revised
        Name.Variable.Global:      "#000000",        # class: 'vg' - to be revised
        Name.Variable.Instance:    "#000000",        # class: 'vi' - to be revised

        Number:                    "#990000",        # class: 'm'

        Literal:                   "#000000",        # class: 'l'
        Literal.Date:              "#000000",        # class: 'ld'

        String:                    "#4e9a06",        # class: 's'
        String.Backtick:           "#4e9a06",        # class: 'sb'
        String.Char:               "#4e9a06",        # class: 'sc'
        String.Doc:                "italic #8f5902", # class: 'sd' - like a comment
        String.Double:             "#4e9a06",        # class: 's2'
        String.Escape:             "#4e9a06",        # class: 'se'
        String.Heredoc:            "#4e9a06",        # class: 'sh'
        String.Interpol:           "#4e9a06",        # class: 'si'
        String.Other:              "#4e9a06",        # class: 'sx'
        String.Regex:              "#4e9a06",        # class: 'sr'
        String.Single:             "#4e9a06",        # class: 's1'
        String.Symbol:             "#4e9a06",        # class: 'ss'

        Generic:                   "#000000",        # class: 'g'
        Generic.Deleted:           "#a40000",        # class: 'gd'
        Generic.Emph:              "italic #000000", # class: 'ge'
        Generic.Error:             "#ef2929",        # class: 'gr'
        Generic.Heading:           "bold #000080",   # class: 'gh'
        Generic.Inserted:          "#00A000",        # class: 'gi'
        Generic.Output:            "#888",           # class: 'go'
        Generic.Prompt:            "#745334",        # class: 'gp'
        Generic.Strong:            "bold #000000",   # class: 'gs'
        Generic.Subheading:        "bold #800080",   # class: 'gu'
        Generic.Traceback:         "bold #a40000",   # class: 'gt'
    }

########NEW FILE########
__FILENAME__ = compat
# -*- coding: utf-8 -*-

"""
tablib.compat
~~~~~~~~~~~~~

Tablib compatiblity module.

"""

import sys

is_py3 = (sys.version_info[0] > 2)



try:
    from collections import OrderedDict
except ImportError:
    from tablib.packages.ordereddict import OrderedDict


if is_py3:
    from io import BytesIO
    import tablib.packages.xlwt3 as xlwt
    import tablib.packages.xlrd3 as xlrd
    from tablib.packages.xlrd3.biffh import XLRDError
    from tablib.packages import markup3 as markup
    from tablib.packages import openpyxl3 as openpyxl
    from tablib.packages.odf3 import opendocument, style, text, table

    import csv
    from io import StringIO
    # py3 mappings

    unicode = str
    bytes = bytes
    basestring = str

else:
    from cStringIO import StringIO as BytesIO
    from cStringIO import StringIO
    import tablib.packages.xlwt as xlwt
    import tablib.packages.xlrd as xlrd
    from tablib.packages.xlrd.biffh import XLRDError
    from tablib.packages import markup
    from itertools import ifilter
    from tablib.packages import openpyxl
    from tablib.packages.odf import opendocument, style, text, table

    from tablib.packages import unicodecsv as csv

    unicode = unicode

########NEW FILE########
__FILENAME__ = core
# -*- coding: utf-8 -*-
"""
    tablib.core
    ~~~~~~~~~~~

    This module implements the central Tablib objects.

    :copyright: (c) 2014 by Kenneth Reitz.
    :license: MIT, see LICENSE for more details.
"""

from copy import copy
from operator import itemgetter

from tablib import formats

from tablib.compat import OrderedDict, unicode


__title__ = 'tablib'
__version__ = '0.10.0'
__build__ = 0x001000
__author__ = 'Kenneth Reitz'
__license__ = 'MIT'
__copyright__ = 'Copyright 2014 Kenneth Reitz'
__docformat__ = 'restructuredtext'


class Row(object):
    """Internal Row object. Mainly used for filtering."""

    __slots__ = ['_row', 'tags']

    def __init__(self, row=list(), tags=list()):
        self._row = list(row)
        self.tags = list(tags)

    def __iter__(self):
        return (col for col in self._row)

    def __len__(self):
        return len(self._row)

    def __repr__(self):
        return repr(self._row)

    def __getslice__(self, i, j):
        return self._row[i,j]

    def __getitem__(self, i):
        return self._row[i]

    def __setitem__(self, i, value):
        self._row[i] = value

    def __delitem__(self, i):
        del self._row[i]

    def __getstate__(self):

        slots = dict()

        for slot in self.__slots__:
            attribute = getattr(self, slot)
            slots[slot] = attribute

        return slots

    def __setstate__(self, state):
        for (k, v) in list(state.items()): setattr(self, k, v)

    def rpush(self, value):
        self.insert(0, value)

    def lpush(self, value):
        self.insert(len(value), value)

    def append(self, value):
        self.rpush(value)

    def insert(self, index, value):
        self._row.insert(index, value)

    def __contains__(self, item):
        return (item in self._row)

    @property
    def tuple(self):
        """Tuple representation of :class:`Row`."""
        return tuple(self._row)

    @property
    def list(self):
        """List representation of :class:`Row`."""
        return list(self._row)

    def has_tag(self, tag):
        """Returns true if current row contains tag."""

        if tag == None:
            return False
        elif isinstance(tag, str):
            return (tag in self.tags)
        else:
            return bool(len(set(tag) & set(self.tags)))




class Dataset(object):
    """The :class:`Dataset` object is the heart of Tablib. It provides all core
    functionality.

    Usually you create a :class:`Dataset` instance in your main module, and append
    rows as you collect data. ::

        data = tablib.Dataset()
        data.headers = ('name', 'age')

        for (name, age) in some_collector():
            data.append((name, age))


    Setting columns is similar. The column data length must equal the
    current height of the data and headers must be set ::

        data = tablib.Dataset()
        data.headers = ('first_name', 'last_name')

        data.append(('John', 'Adams'))
        data.append(('George', 'Washington'))

        data.append_col((90, 67), header='age')


    You can also set rows and headers upon instantiation. This is useful if
    dealing with dozens or hundreds of :class:`Dataset` objects. ::

        headers = ('first_name', 'last_name')
        data = [('John', 'Adams'), ('George', 'Washington')]

        data = tablib.Dataset(*data, headers=headers)

    :param \*args: (optional) list of rows to populate Dataset
    :param headers: (optional) list strings for Dataset header row


    .. admonition:: Format Attributes Definition

     If you look at the code, the various output/import formats are not
     defined within the :class:`Dataset` object. To add support for a new format, see
     :ref:`Adding New Formats <newformats>`.

    """

    def __init__(self, *args, **kwargs):
        self._data = list(Row(arg) for arg in args)
        self.__headers = None

        # ('title', index) tuples
        self._separators = []

        # (column, callback) tuples
        self._formatters = []

        try:
            self.headers = kwargs['headers']
        except KeyError:
            self.headers = None

        try:
            self.title = kwargs['title']
        except KeyError:
            self.title = None

        self._register_formats()


    def __len__(self):
        return self.height


    def __getitem__(self, key):
        if isinstance(key, str) or isinstance(key, unicode):
            if key in self.headers:
                pos = self.headers.index(key) # get 'key' index from each data
                return [row[pos] for row in self._data]
            else:
                raise KeyError
        else:
            _results = self._data[key]
            if isinstance(_results, Row):
                return _results.tuple
            else:
                return [result.tuple for result in _results]

    def __setitem__(self, key, value):
        self._validate(value)
        self._data[key] = Row(value)


    def __delitem__(self, key):
        if isinstance(key, str) or isinstance(key, unicode):

            if key in self.headers:

                pos = self.headers.index(key)
                del self.headers[pos]

                for i, row in enumerate(self._data):

                    del row[pos]
                    self._data[i] = row
            else:
                raise KeyError
        else:
            del self._data[key]


    def __repr__(self):
        try:
            return '<%s dataset>' % (self.title.lower())
        except AttributeError:
            return '<dataset object>'

    def __unicode__(self):
        result = [self.__headers]

        result.extend(list(map(unicode, row)) for row in self._data)

        # here, we calculate max width for each column
        lens = (list(map(len, row)) for row in result)
        field_lens = list(map(max, zip(*lens)))

        # delimiter between header and data
        result.insert(1, ['-' * length for length in field_lens])

        format_string = '|'.join('{%s:%s}' % item for item in enumerate(field_lens))

        return '\n'.join(format_string.format(*row) for row in result)

    def __str__(self):
        return self.__unicode__()


    # ---------
    # Internals
    # ---------

    @classmethod
    def _register_formats(cls):
        """Adds format properties."""
        for fmt in formats.available:
            try:
                try:
                    setattr(cls, fmt.title, property(fmt.export_set, fmt.import_set))
                except AttributeError:
                    setattr(cls, fmt.title, property(fmt.export_set))

            except AttributeError:
                pass


    def _validate(self, row=None, col=None, safety=False):
        """Assures size of every row in dataset is of proper proportions."""
        if row:
            is_valid = (len(row) == self.width) if self.width else True
        elif col:
            if len(col) < 1:
                is_valid = True
            else:
                is_valid = (len(col) == self.height) if self.height else True
        else:
            is_valid = all((len(x) == self.width for x in self._data))

        if is_valid:
            return True
        else:
            if not safety:
                raise InvalidDimensions
            return False


    def _package(self, dicts=True, ordered=True):
        """Packages Dataset into lists of dictionaries for transmission."""
        # TODO: Dicts default to false?

        _data = list(self._data)

        if ordered:
            dict_pack = OrderedDict
        else:
            dict_pack = dict

        # Execute formatters
        if self._formatters:
            for row_i, row in enumerate(_data):
                for col, callback in self._formatters:
                    try:
                        if col is None:
                            for j, c in enumerate(row):
                                _data[row_i][j] = callback(c)
                        else:
                            _data[row_i][col] = callback(row[col])
                    except IndexError:
                        raise InvalidDatasetIndex


        if self.headers:
            if dicts:
                data = [dict_pack(list(zip(self.headers, data_row))) for data_row in _data]
            else:
                data = [list(self.headers)] + list(_data)
        else:
            data = [list(row) for row in _data]

        return data



    def _get_headers(self):
        """An *optional* list of strings to be used for header rows and attribute names.

        This must be set manually. The given list length must equal :class:`Dataset.width`.

        """
        return self.__headers


    def _set_headers(self, collection):
        """Validating headers setter."""
        self._validate(collection)
        if collection:
            try:
                self.__headers = list(collection)
            except TypeError:
                raise TypeError
        else:
            self.__headers = None

    headers = property(_get_headers, _set_headers)


    def _get_dict(self):
        """A native Python representation of the :class:`Dataset` object. If headers have
        been set, a list of Python dictionaries will be returned. If no headers have been set,
        a list of tuples (rows) will be returned instead.

        A dataset object can also be imported by setting the `Dataset.dict` attribute: ::

            data = tablib.Dataset()
            data.json = '[{"last_name": "Adams","age": 90,"first_name": "John"}]'

        """
        return self._package()


    def _set_dict(self, pickle):
        """A native Python representation of the Dataset object. If headers have been
        set, a list of Python dictionaries will be returned. If no headers have been
        set, a list of tuples (rows) will be returned instead.

        A dataset object can also be imported by setting the :class:`Dataset.dict` attribute. ::

            data = tablib.Dataset()
            data.dict = [{'age': 90, 'first_name': 'Kenneth', 'last_name': 'Reitz'}]

        """

        if not len(pickle):
            return

        # if list of rows
        if isinstance(pickle[0], list):
            self.wipe()
            for row in pickle:
                self.append(Row(row))

        # if list of objects
        elif isinstance(pickle[0], dict):
            self.wipe()
            self.headers = list(pickle[0].keys())
            for row in pickle:
                self.append(Row(list(row.values())))
        else:
            raise UnsupportedFormat

    dict = property(_get_dict, _set_dict)


    def _clean_col(self, col):
        """Prepares the given column for insert/append."""

        col = list(col)

        if self.headers:
            header = [col.pop(0)]
        else:
            header = []

        if len(col) == 1 and hasattr(col[0], '__call__'):

            col = list(map(col[0], self._data))
        col = tuple(header + col)

        return col


    @property
    def height(self):
        """The number of rows currently in the :class:`Dataset`.
           Cannot be directly modified.
        """
        return len(self._data)


    @property
    def width(self):
        """The number of columns currently in the :class:`Dataset`.
           Cannot be directly modified.
        """

        try:
            return len(self._data[0])
        except IndexError:
            try:
                return len(self.headers)
            except TypeError:
                return 0


    # -------
    # Formats
    # -------


    @property
    def xls():
        """A Legacy Excel Spreadsheet representation of the :class:`Dataset` object, with :ref:`separators`. Cannot be set.

        .. note::

            XLS files are limited to a maximum of 65,000 rows. Use :class:`Dataset.xlsx` to avoid this limitation.

         .. admonition:: Binary Warning

             :class:`Dataset.xls` contains binary data, so make sure to write in binary mode::

                with open('output.xls', 'wb') as f:
                    f.write(data.xls)
        """
        pass

    @property
    def xlsx():
        """An Excel '07+ Spreadsheet representation of the :class:`Dataset` object, with :ref:`separators`. Cannot be set.

         .. admonition:: Binary Warning

             :class:`Dataset.xlsx` contains binary data, so make sure to write in binary mode::

                with open('output.xlsx', 'wb') as f:
                    f.write(data.xlsx)
        """
        pass

    @property
    def ods():
        """An OpenDocument Spreadsheet representation of the :class:`Dataset` object, with :ref:`separators`. Cannot be set.

         .. admonition:: Binary Warning

             :class:`Dataset.ods` contains binary data, so make sure to write in binary mode::

                with open('output.ods', 'wb') as f:
                    f.write(data.ods)
        """
        pass

    @property
    def csv():
        """A CSV representation of the :class:`Dataset` object. The top row will contain
        headers, if they have been set. Otherwise, the top row will contain
        the first row of the dataset.

        A dataset object can also be imported by setting the :class:`Dataset.csv` attribute. ::

            data = tablib.Dataset()
            data.csv = 'age, first_name, last_name\\n90, John, Adams'

        Import assumes (for now) that headers exist.

        .. admonition:: Binary Warning

             :class:`Dataset.csv` uses \\r\\n line endings by default, so make
             sure to write in binary mode::

                 with open('output.csv', 'wb') as f:
                     f.write(data.csv)

             If you do not do this, and you export the file on Windows, your
             CSV file will open in Excel with a blank line between each row.
        """
        pass


    @property
    def tsv():
        """A TSV representation of the :class:`Dataset` object. The top row will contain
        headers, if they have been set. Otherwise, the top row will contain
        the first row of the dataset.

        A dataset object can also be imported by setting the :class:`Dataset.tsv` attribute. ::

            data = tablib.Dataset()
            data.tsv = 'age\tfirst_name\tlast_name\\n90\tJohn\tAdams'

        Import assumes (for now) that headers exist.
        """
        pass

    @property
    def yaml():
        """A YAML representation of the :class:`Dataset` object. If headers have been
        set, a YAML list of objects will be returned. If no headers have
        been set, a YAML list of lists (rows) will be returned instead.

        A dataset object can also be imported by setting the :class:`Dataset.yaml` attribute: ::

            data = tablib.Dataset()
            data.yaml = '- {age: 90, first_name: John, last_name: Adams}'

        Import assumes (for now) that headers exist.
        """
        pass


    @property
    def json():
        """A JSON representation of the :class:`Dataset` object. If headers have been
        set, a JSON list of objects will be returned. If no headers have
        been set, a JSON list of lists (rows) will be returned instead.

        A dataset object can also be imported by setting the :class:`Dataset.json` attribute: ::

            data = tablib.Dataset()
            data.json = '[{age: 90, first_name: "John", liast_name: "Adams"}]'

        Import assumes (for now) that headers exist.
        """
        pass

    @property
    def html():
        """A HTML table representation of the :class:`Dataset` object. If
        headers have been set, they will be used as table headers.

        ..notice:: This method can be used for export only.
        """
        pass


    # ----
    # Rows
    # ----

    def insert(self, index, row, tags=list()):
        """Inserts a row to the :class:`Dataset` at the given index.

        Rows inserted must be the correct size (height or width).

        The default behaviour is to insert the given row to the :class:`Dataset`
        object at the given index.
       """

        self._validate(row)
        self._data.insert(index, Row(row, tags=tags))


    def rpush(self, row, tags=list()):
        """Adds a row to the end of the :class:`Dataset`.
        See :class:`Dataset.insert` for additional documentation.
        """

        self.insert(self.height, row=row, tags=tags)


    def lpush(self, row, tags=list()):
        """Adds a row to the top of the :class:`Dataset`.
        See :class:`Dataset.insert` for additional documentation.
        """

        self.insert(0, row=row, tags=tags)


    def append(self, row, tags=list()):
        """Adds a row to the :class:`Dataset`.
        See :class:`Dataset.insert` for additional documentation.
        """

        self.rpush(row, tags)

    def extend(self, rows, tags=list()):
        """Adds a list of rows to the :class:`Dataset` using
        :class:`Dataset.append`
        """

        for row in rows:
            self.append(row, tags)


    def lpop(self):
        """Removes and returns the first row of the :class:`Dataset`."""

        cache = self[0]
        del self[0]

        return cache


    def rpop(self):
        """Removes and returns the last row of the :class:`Dataset`."""

        cache = self[-1]
        del self[-1]

        return cache


    def pop(self):
        """Removes and returns the last row of the :class:`Dataset`."""

        return self.rpop()


    # -------
    # Columns
    # -------

    def insert_col(self, index, col=None, header=None):
        """Inserts a column to the :class:`Dataset` at the given index.

        Columns inserted must be the correct height.

        You can also insert a column of a single callable object, which will
        add a new column with the return values of the callable each as an
        item in the column. ::

            data.append_col(col=random.randint)

        If inserting a column, and :class:`Dataset.headers` is set, the
        header attribute must be set, and will be considered the header for
        that row.

        See :ref:`dyncols` for an in-depth example.

        .. versionchanged:: 0.9.0
           If inserting a column, and :class:`Dataset.headers` is set, the
           header attribute must be set, and will be considered the header for
           that row.

        .. versionadded:: 0.9.0
           If inserting a row, you can add :ref:`tags <tags>` to the row you are inserting.
           This gives you the ability to :class:`filter <Dataset.filter>` your
           :class:`Dataset` later.

        """

        if col is None:
            col = []

        # Callable Columns...
        if hasattr(col, '__call__'):
            col = list(map(col, self._data))

        col = self._clean_col(col)
        self._validate(col=col)

        if self.headers:
            # pop the first item off, add to headers
            if not header:
                raise HeadersNeeded()

            # corner case - if header is set without data
            elif header and self.height == 0 and len(col):
                raise InvalidDimensions

            self.headers.insert(index, header)


        if self.height and self.width:

            for i, row in enumerate(self._data):

                row.insert(index, col[i])
                self._data[i] = row
        else:
            self._data = [Row([row]) for row in col]



    def rpush_col(self, col, header=None):
        """Adds a column to the end of the :class:`Dataset`.
        See :class:`Dataset.insert` for additional documentation.
        """

        self.insert_col(self.width, col, header=header)


    def lpush_col(self, col, header=None):
        """Adds a column to the top of the :class:`Dataset`.
        See :class:`Dataset.insert` for additional documentation.
        """

        self.insert_col(0, col, header=header)


    def insert_separator(self, index, text='-'):
        """Adds a separator to :class:`Dataset` at given index."""

        sep = (index, text)
        self._separators.append(sep)


    def append_separator(self, text='-'):
        """Adds a :ref:`separator <separators>` to the :class:`Dataset`."""

        # change offsets if headers are or aren't defined
        if not self.headers:
            index = self.height if self.height else 0
        else:
            index = (self.height + 1) if self.height else 1

        self.insert_separator(index, text)


    def append_col(self, col, header=None):
        """Adds a column to the :class:`Dataset`.
        See :class:`Dataset.insert_col` for additional documentation.
        """

        self.rpush_col(col, header)


    def get_col(self, index):
        """Returns the column from the :class:`Dataset` at the given index."""

        return [row[index] for row in self._data]


    # ----
    # Misc
    # ----

    def add_formatter(self, col, handler):
        """Adds a :ref:`formatter` to the :class:`Dataset`.

        .. versionadded:: 0.9.5
           :param col: column to. Accepts index int or header str.
           :param handler: reference to callback function to execute
           against each cell value.
        """

        if isinstance(col, str):
            if col in self.headers:
                col = self.headers.index(col) # get 'key' index from each data
            else:
                raise KeyError

        if not col > self.width:
            self._formatters.append((col, handler))
        else:
            raise InvalidDatasetIndex

        return True


    def filter(self, tag):
        """Returns a new instance of the :class:`Dataset`, excluding any rows
        that do not contain the given :ref:`tags <tags>`.
        """
        _dset = copy(self)
        _dset._data = [row for row in _dset._data if row.has_tag(tag)]

        return _dset


    def sort(self, col, reverse=False):
        """Sort a :class:`Dataset` by a specific column, given string (for
        header) or integer (for column index). The order can be reversed by
        setting ``reverse`` to ``True``.

        Returns a new :class:`Dataset` instance where columns have been
        sorted.
        """

        if isinstance(col, str) or isinstance(col, unicode):

            if not self.headers:
                raise HeadersNeeded

            _sorted = sorted(self.dict, key=itemgetter(col), reverse=reverse)
            _dset = Dataset(headers=self.headers, title=self.title)

            for item in _sorted:
                row = [item[key] for key in self.headers]
                _dset.append(row=row)

        else:
            if self.headers:
                col = self.headers[col]

            _sorted = sorted(self.dict, key=itemgetter(col), reverse=reverse)
            _dset = Dataset(headers=self.headers, title=self.title)

            for item in _sorted:
                if self.headers:
                    row = [item[key] for key in self.headers]
                else:
                    row = item
                _dset.append(row=row)


        return _dset


    def transpose(self):
        """Transpose a :class:`Dataset`, turning rows into columns and vice
        versa, returning a new ``Dataset`` instance. The first row of the
        original instance becomes the new header row."""

        # Don't transpose if there is no data
        if not self:
            return

        _dset = Dataset()
        # The first element of the headers stays in the headers,
        # it is our "hinge" on which we rotate the data
        new_headers = [self.headers[0]] + self[self.headers[0]]

        _dset.headers = new_headers
        for column in self.headers:

            if column == self.headers[0]:
                # It's in the headers, so skip it
                continue

            # Adding the column name as now they're a regular column
            row_data = [column] + self[column]
            row_data = Row(row_data)
            _dset.append(row=row_data)

        return _dset


    def stack(self, other):
        """Stack two :class:`Dataset` instances together by
        joining at the row level, and return new combined
        ``Dataset`` instance."""

        if not isinstance(other, Dataset):
            return

        if self.width != other.width:
            raise InvalidDimensions

        # Copy the source data
        _dset = copy(self)

        rows_to_stack = [row for row in _dset._data]
        other_rows = [row for row in other._data]

        rows_to_stack.extend(other_rows)
        _dset._data = rows_to_stack

        return _dset


    def stack_cols(self, other):
        """Stack two :class:`Dataset` instances together by
        joining at the column level, and return a new
        combined ``Dataset`` instance. If either ``Dataset``
        has headers set, than the other must as well."""

        if not isinstance(other, Dataset):
            return

        if self.headers or other.headers:
            if not self.headers or not other.headers:
                raise HeadersNeeded

        if self.height != other.height:
            raise InvalidDimensions

        try:
            new_headers = self.headers + other.headers
        except TypeError:
            new_headers = None

        _dset = Dataset()

        for column in self.headers:
            _dset.append_col(col=self[column])

        for column in other.headers:
            _dset.append_col(col=other[column])

        _dset.headers = new_headers

        return _dset


    def wipe(self):
        """Removes all content and headers from the :class:`Dataset` object."""
        self._data = list()
        self.__headers = None



class Databook(object):
    """A book of :class:`Dataset` objects.
    """

    def __init__(self, sets=None):

        if sets is None:
            self._datasets = list()
        else:
            self._datasets = sets

        self._register_formats()

    def __repr__(self):
        try:
            return '<%s databook>' % (self.title.lower())
        except AttributeError:
            return '<databook object>'


    def wipe(self):
        """Removes all :class:`Dataset` objects from the :class:`Databook`."""
        self._datasets = []


    @classmethod
    def _register_formats(cls):
        """Adds format properties."""
        for fmt in formats.available:
            try:
                try:
                    setattr(cls, fmt.title, property(fmt.export_book, fmt.import_book))
                except AttributeError:
                    setattr(cls, fmt.title, property(fmt.export_book))

            except AttributeError:
                pass

    def sheets(self):
        return self._datasets

    def add_sheet(self, dataset):
        """Adds given :class:`Dataset` to the :class:`Databook`."""
        if isinstance(dataset, Dataset):
            self._datasets.append(dataset)
        else:
            raise InvalidDatasetType


    def _package(self, ordered=True):
        """Packages :class:`Databook` for delivery."""
        collector = []

        if ordered:
            dict_pack = OrderedDict
        else:
            dict_pack = dict

        for dset in self._datasets:
            collector.append(dict_pack(
                title = dset.title,
                data = dset._package(ordered=ordered)
            ))
        return collector


    @property
    def size(self):
        """The number of the :class:`Dataset` objects within :class:`Databook`."""
        return len(self._datasets)


def detect(stream):
    """Return (format, stream) of given stream."""
    for fmt in formats.available:
        try:
            if fmt.detect(stream):
                return (fmt, stream)
        except AttributeError:
            pass
    return (None, stream)


def import_set(stream):
    """Return dataset of given stream."""
    (format, stream) = detect(stream)

    try:
        data = Dataset()
        format.import_set(data, stream)
        return data

    except AttributeError:
        return None


def import_book(stream):
    """Return dataset of given stream."""
    (format, stream) = detect(stream)

    try:
        databook = Databook()
        format.import_book(databook, stream)
        return databook

    except AttributeError:
        return None


class InvalidDatasetType(Exception):
    "Only Datasets can be added to a DataBook"


class InvalidDimensions(Exception):
    "Invalid size"

class InvalidDatasetIndex(Exception):
    "Outside of Dataset size"

class HeadersNeeded(Exception):
    "Header parameter must be given when appending a column in this Dataset."

class UnsupportedFormat(NotImplementedError):
    "Format is not supported"

########NEW FILE########
__FILENAME__ = _csv
# -*- coding: utf-8 -*-

""" Tablib - CSV Support.
"""

from tablib.compat import is_py3, csv, StringIO


title = 'csv'
extensions = ('csv',)


DEFAULT_ENCODING = 'utf-8'



def export_set(dataset):
    """Returns CSV representation of Dataset."""
    stream = StringIO()

    if is_py3:
        _csv = csv.writer(stream)
    else:
        _csv = csv.writer(stream, encoding=DEFAULT_ENCODING)

    for row in dataset._package(dicts=False):
        _csv.writerow(row)

    return stream.getvalue()


def import_set(dset, in_stream, headers=True):
    """Returns dataset from CSV stream."""

    dset.wipe()

    if is_py3:
        rows = csv.reader(StringIO(in_stream))
    else:
        rows = csv.reader(StringIO(in_stream), encoding=DEFAULT_ENCODING)
    for i, row in enumerate(rows):

        if (i == 0) and (headers):
            dset.headers = row
        else:
            dset.append(row)


def detect(stream):
    """Returns True if given stream is valid CSV."""
    try:
        csv.Sniffer().sniff(stream, delimiters=',')
        return True
    except (csv.Error, TypeError):
        return False

########NEW FILE########
__FILENAME__ = _html
# -*- coding: utf-8 -*-

""" Tablib - HTML export support.
"""

import sys

if sys.version_info[0] > 2:
    from io import BytesIO as StringIO
    from tablib.packages import markup3 as markup
else:
    from cStringIO import StringIO
    from tablib.packages import markup

import tablib
from tablib.compat import unicode
import codecs

BOOK_ENDINGS = 'h3'

title = 'html'
extensions = ('html', )


def export_set(dataset):
	"""HTML representation of a Dataset."""

	stream = StringIO()

	page = markup.page()
	page.table.open()

	if dataset.headers is not None:
		new_header = [item if item is not None else '' for item in dataset.headers] 

		page.thead.open()
		headers = markup.oneliner.th(new_header)
		page.tr(headers)
		page.thead.close()

	for row in dataset:
		new_row = [item if item is not None else '' for item in row] 

		html_row = markup.oneliner.td(new_row)
		page.tr(html_row)

	page.table.close()

    # Allow unicode characters in output
	wrapper = codecs.getwriter("utf8")(stream)
	wrapper.writelines(unicode(page))

	return stream.getvalue().decode('utf-8')


def export_book(databook):
	"""HTML representation of a Databook."""

	stream = StringIO()

	for i, dset in enumerate(databook._datasets):
		title = (dset.title if dset.title else 'Set %s' % (i))
		stream.write('<%s>%s</%s>\n' % (BOOK_ENDINGS, title, BOOK_ENDINGS))
		stream.write(dset.html)
		stream.write('\n')

	return stream.getvalue()

########NEW FILE########
__FILENAME__ = _json
# -*- coding: utf-8 -*-

""" Tablib - JSON Support
"""

import tablib

import sys
from tablib.packages import omnijson as json


title = 'json'
extensions = ('json', 'jsn')


def export_set(dataset):
    """Returns JSON representation of Dataset."""
    return json.dumps(dataset.dict)


def export_book(databook):
    """Returns JSON representation of Databook."""
    return json.dumps(databook._package())


def import_set(dset, in_stream):
    """Returns dataset from JSON stream."""

    dset.wipe()
    dset.dict = json.loads(in_stream)


def import_book(dbook, in_stream):
    """Returns databook from JSON stream."""

    dbook.wipe()
    for sheet in json.loads(in_stream):
        data = tablib.Dataset()
        data.title = sheet['title']
        data.dict = sheet['data']
        dbook.add_sheet(data)


def detect(stream):
    """Returns True if given stream is valid JSON."""
    try:
        json.loads(stream)
        return True
    except ValueError:
        return False

########NEW FILE########
__FILENAME__ = _ods
# -*- coding: utf-8 -*-

""" Tablib - ODF Support.
"""

import sys


if sys.version_info[0] > 2:
    from io import BytesIO
else:
    from cStringIO import StringIO as BytesIO

from tablib.compat import opendocument, style, table, text, unicode

title = 'ods'
extensions = ('ods',)

bold = style.Style(name="bold", family="paragraph")
bold.addElement(style.TextProperties(fontweight="bold", fontweightasian="bold", fontweightcomplex="bold"))

def export_set(dataset):
    """Returns ODF representation of Dataset."""

    wb = opendocument.OpenDocumentSpreadsheet()
    wb.automaticstyles.addElement(bold)

    ws = table.Table(name=dataset.title if dataset.title else 'Tablib Dataset')
    wb.spreadsheet.addElement(ws)
    dset_sheet(dataset, ws)

    stream = BytesIO()
    wb.save(stream)
    return stream.getvalue()


def export_book(databook):
    """Returns ODF representation of DataBook."""

    wb = opendocument.OpenDocumentSpreadsheet()
    wb.automaticstyles.addElement(bold)

    for i, dset in enumerate(databook._datasets):
        ws = table.Table(name=dset.title if dset.title else 'Sheet%s' % (i))
        wb.spreadsheet.addElement(ws)
        dset_sheet(dset, ws)


    stream = BytesIO()
    wb.save(stream)
    return stream.getvalue()


def dset_sheet(dataset, ws):
    """Completes given worksheet from given Dataset."""
    _package = dataset._package(dicts=False)

    for i, sep in enumerate(dataset._separators):
        _offset = i
        _package.insert((sep[0] + _offset), (sep[1],))

    for i, row in enumerate(_package):
        row_number = i + 1
        odf_row = table.TableRow(stylename=bold, defaultcellstylename='bold')
        for j, col in enumerate(row):
            try:
                col = unicode(col, errors='ignore')
            except TypeError:
                ## col is already unicode
                pass
            ws.addElement(table.TableColumn())

            # bold headers
            if (row_number == 1) and dataset.headers:
                odf_row.setAttribute('stylename', bold)
                ws.addElement(odf_row)
                cell = table.TableCell()
                p = text.P()
                p.addElement(text.Span(text=col, stylename=bold))
                cell.addElement(p)
                odf_row.addElement(cell)

            # wrap the rest
            else:
                try:
                    if '\n' in col:
                        ws.addElement(odf_row)
                        cell = table.TableCell()
                        cell.addElement(text.P(text=col))
                        odf_row.addElement(cell)
                    else:
                        ws.addElement(odf_row)
                        cell = table.TableCell()
                        cell.addElement(text.P(text=col))
                        odf_row.addElement(cell)
                except TypeError:
                    ws.addElement(odf_row)
                    cell = table.TableCell()
                    cell.addElement(text.P(text=col))
                    odf_row.addElement(cell)
########NEW FILE########
__FILENAME__ = _tsv
# -*- coding: utf-8 -*-

""" Tablib - TSV (Tab Separated Values) Support.
"""

from tablib.compat import is_py3, csv, StringIO



title = 'tsv'
extensions = ('tsv',)

DEFAULT_ENCODING = 'utf-8'

def export_set(dataset):
    """Returns a TSV representation of Dataset."""

    stream = StringIO()

    if is_py3:
        _tsv = csv.writer(stream, delimiter='\t')
    else:
        _tsv = csv.writer(stream, encoding=DEFAULT_ENCODING, delimiter='\t')

    for row in dataset._package(dicts=False):
        _tsv.writerow(row)

    return stream.getvalue()


def import_set(dset, in_stream, headers=True):
    """Returns dataset from TSV stream."""

    dset.wipe()

    if is_py3:
        rows = csv.reader(in_stream.splitlines(), delimiter='\t')
    else:
        rows = csv.reader(in_stream.splitlines(), delimiter='\t',
                          encoding=DEFAULT_ENCODING)

    for i, row in enumerate(rows):
        # Skip empty rows
        if not row:
            continue

        if (i == 0) and (headers):
            dset.headers = row
        else:
            dset.append(row)


def detect(stream):
    """Returns True if given stream is valid TSV."""
    try:
        csv.Sniffer().sniff(stream, delimiters='\t')
        return True
    except (csv.Error, TypeError):
        return False

########NEW FILE########
__FILENAME__ = _xls
# -*- coding: utf-8 -*-

""" Tablib - XLS Support.
"""

import sys

from tablib.compat import BytesIO, xlwt, xlrd, XLRDError
import tablib

title = 'xls'
extensions = ('xls',)

# special styles
wrap = xlwt.easyxf("alignment: wrap on")
bold = xlwt.easyxf("font: bold on")


def detect(stream):
    """Returns True if given stream is a readable excel file."""
    try:
        xlrd.open_workbook(file_contents=stream)
        return True
    except (TypeError, XLRDError):
        pass 
    try:
        xlrd.open_workbook(file_contents=stream.read())
        return True
    except (AttributeError, XLRDError):
        pass
    try:
        xlrd.open_workbook(filename=stream)
        return True
    except:
        return False


def export_set(dataset):
    """Returns XLS representation of Dataset."""

    wb = xlwt.Workbook(encoding='utf8')
    ws = wb.add_sheet(dataset.title if dataset.title else 'Tablib Dataset')

    dset_sheet(dataset, ws)

    stream = BytesIO()
    wb.save(stream)
    return stream.getvalue()


def export_book(databook):
    """Returns XLS representation of DataBook."""

    wb = xlwt.Workbook(encoding='utf8')

    for i, dset in enumerate(databook._datasets):
        ws = wb.add_sheet(dset.title if dset.title else 'Sheet%s' % (i))

        dset_sheet(dset, ws)


    stream = BytesIO()
    wb.save(stream)
    return stream.getvalue()


def import_set(dset, in_stream, headers=True):
    """Returns databook from XLS stream."""

    dset.wipe()

    xls_book = xlrd.open_workbook(file_contents=in_stream)
    sheet = xls_book.sheet_by_index(0)

    dset.title = sheet.name

    for i in xrange(sheet.nrows):
        if (i == 0) and (headers):
            dset.headers = sheet.row_values(0)
        else:
            dset.append(sheet.row_values(i))

def import_book(dbook, in_stream, headers=True):
    """Returns databook from XLS stream."""

    dbook.wipe()

    xls_book = xlrd.open_workbook(file_contents=in_stream)

    for sheet in xls_book.sheets():
        data = tablib.Dataset()
        data.title = sheet.name

        for i in xrange(sheet.nrows):
            if (i == 0) and (headers):
                data.headers = sheet.row_values(0)
            else:
                data.append(sheet.row_values(i))

        dbook.add_sheet(data)


def dset_sheet(dataset, ws):
    """Completes given worksheet from given Dataset."""
    _package = dataset._package(dicts=False)

    for i, sep in enumerate(dataset._separators):
        _offset = i
        _package.insert((sep[0] + _offset), (sep[1],))

    for i, row in enumerate(_package):
        for j, col in enumerate(row):

            # bold headers
            if (i == 0) and dataset.headers:
                ws.write(i, j, col, bold)

                # frozen header row
                ws.panes_frozen = True
                ws.horz_split_pos = 1


            # bold separators
            elif len(row) < dataset.width:
                ws.write(i, j, col, bold)

            # wrap the rest
            else:
                try:
                    if '\n' in col:
                        ws.write(i, j, col, wrap)
                    else:
                        ws.write(i, j, col)
                except TypeError:
                    ws.write(i, j, col)

########NEW FILE########
__FILENAME__ = _xlsx
# -*- coding: utf-8 -*-

""" Tablib - XLSX Support.
"""

import sys


if sys.version_info[0] > 2:
    from io import BytesIO
else:
    from cStringIO import StringIO as BytesIO

from tablib.compat import openpyxl
import tablib

Workbook = openpyxl.workbook.Workbook
ExcelWriter = openpyxl.writer.excel.ExcelWriter
get_column_letter = openpyxl.cell.get_column_letter

from tablib.compat import unicode


title = 'xlsx'
extensions = ('xlsx',)


def detect(stream):
    """Returns True if given stream is a readable excel file."""
    try:
        openpyxl.reader.excel.load_workbook(stream)
        return True
    except openpyxl.shared.exc.InvalidFileException:
        pass

def export_set(dataset):
    """Returns XLSX representation of Dataset."""

    wb = Workbook()
    ws = wb.worksheets[0]
    ws.title = dataset.title if dataset.title else 'Tablib Dataset'

    dset_sheet(dataset, ws)

    stream = BytesIO()
    wb.save(stream)
    return stream.getvalue()


def export_book(databook):
    """Returns XLSX representation of DataBook."""

    wb = Workbook()
    wb.worksheets = []
    for i, dset in enumerate(databook._datasets):
        ws = wb.create_sheet()
        ws.title = dset.title if dset.title else 'Sheet%s' % (i)

        dset_sheet(dset, ws)


    stream = BytesIO()
    wb.save(stream)
    return stream.getvalue()


def import_set(dset, in_stream, headers=True):
    """Returns databook from XLS stream."""

    dset.wipe()

    xls_book = openpyxl.reader.excel.load_workbook(in_stream)
    sheet = xls_book.get_active_sheet()

    dset.title = sheet.title

    for i, row in enumerate(sheet.rows):
        row_vals = [c.value for c in row]
        if (i == 0) and (headers):
            dset.headers = row_vals
        else:
            dset.append(row_vals)


def import_book(dbook, in_stream, headers=True):
    """Returns databook from XLS stream."""

    dbook.wipe()

    xls_book = openpyxl.reader.excel.load_workbook(in_stream)

    for sheet in xls_book.worksheets:
        data = tablib.Dataset()
        data.title = sheet.title

        for i, row in enumerate(sheet.rows):
            row_vals = [c.value for c in row]
            if (i == 0) and (headers):
                data.headers = row_vals
            else:
                data.append(row_vals)

        dbook.add_sheet(data)


def dset_sheet(dataset, ws):
    """Completes given worksheet from given Dataset."""
    _package = dataset._package(dicts=False)

    for i, sep in enumerate(dataset._separators):
        _offset = i
        _package.insert((sep[0] + _offset), (sep[1],))

    for i, row in enumerate(_package):
        row_number = i + 1
        for j, col in enumerate(row):
            col_idx = get_column_letter(j + 1)
            # We want to freeze the column after the last column
            frzn_col_idx = get_column_letter(j + 2)

            # bold headers
            if (row_number == 1) and dataset.headers:
                # ws.cell('%s%s'%(col_idx, row_number)).value = unicode(
                    # '%s' % col, errors='ignore')
                ws.cell('%s%s'%(col_idx, row_number)).value = unicode(col)
                style = ws.get_style('%s%s' % (col_idx, row_number))
                style.font.bold = True
                ws.freeze_panes = '%s%s' % (frzn_col_idx, row_number)


            # bold separators
            elif len(row) < dataset.width:
                ws.cell('%s%s'%(col_idx, row_number)).value = unicode(
                    '%s' % col, errors='ignore')
                style = ws.get_style('%s%s' % (col_idx, row_number))
                style.font.bold = True

            # wrap the rest
            else:
                try:
                    if '\n' in col:
                        ws.cell('%s%s'%(col_idx, row_number)).value = unicode(
                            '%s' % col, errors='ignore')
                        style = ws.get_style('%s%s' % (col_idx, row_number))
                        style.alignment.wrap_text
                    else:
                        ws.cell('%s%s'%(col_idx, row_number)).value = unicode(
                            '%s' % col, errors='ignore')
                except TypeError:
                    ws.cell('%s%s'%(col_idx, row_number)).value = unicode(col)



########NEW FILE########
__FILENAME__ = _yaml
# -*- coding: utf-8 -*-

""" Tablib - YAML Support.
"""

import sys

try:
    import yaml
except ImportError:
    if sys.version_info[0] > 2:
        import tablib.packages.yaml3 as yaml
    else:
        import tablib.packages.yaml as yaml


import tablib



title = 'yaml'
extensions = ('yaml', 'yml')



def export_set(dataset):
    """Returns YAML representation of Dataset."""

    return yaml.safe_dump(dataset._package(ordered=False))


def export_book(databook):
    """Returns YAML representation of Databook."""
    return yaml.safe_dump(databook._package(ordered=False))


def import_set(dset, in_stream):
    """Returns dataset from YAML stream."""

    dset.wipe()
    dset.dict = yaml.safe_load(in_stream)


def import_book(dbook, in_stream):
    """Returns databook from YAML stream."""

    dbook.wipe()

    for sheet in yaml.load(in_stream):
        data = tablib.Dataset()
        data.title = sheet['title']
        data.dict = sheet['data']
        dbook.add_sheet(data)

def detect(stream):
    """Returns True if given stream is valid YAML."""
    try:
        _yaml = yaml.safe_load(stream)
        if isinstance(_yaml, (list, tuple, dict)):
            return True
        else:
            return False
    except (yaml.parser.ParserError, yaml.reader.ReaderError,
            yaml.scanner.ScannerError):
        return False

########NEW FILE########
__FILENAME__ = markup
# This code is in the public domain, it comes
# with absolutely no warranty and you can do
# absolutely whatever you want with it.

__date__ = '17 May 2007'
__version__ = '1.7'
__doc__= """
This is markup.py - a Python module that attempts to
make it easier to generate HTML/XML from a Python program
in an intuitive, lightweight, customizable and pythonic way.

The code is in the public domain.

Version: %s as of %s.

Documentation and further info is at http://markup.sourceforge.net/

Please send bug reports, feature requests, enhancement
ideas or questions to nogradi at gmail dot com.

Installation: drop markup.py somewhere into your Python path.
""" % ( __version__, __date__ )

import string

class element:
    """This class handles the addition of a new element."""

    def __init__( self, tag, case='lower', parent=None ):
        self.parent = parent

        if case == 'lower':
            self.tag = tag.lower( )
        else:
            self.tag = tag.upper( )
    
    def __call__( self, *args, **kwargs ):
        if len( args ) > 1:
            raise ArgumentError( self.tag )

        # if class_ was defined in parent it should be added to every element
        if self.parent is not None and self.parent.class_ is not None:
            if 'class_' not in kwargs:
                kwargs['class_'] = self.parent.class_
            
        if self.parent is None and len( args ) == 1:
            x = [ self.render( self.tag, False, myarg, mydict ) for myarg, mydict in _argsdicts( args, kwargs ) ]
            return '\n'.join( x )
        elif self.parent is None and len( args ) == 0:
            x = [ self.render( self.tag, True, myarg, mydict ) for myarg, mydict in _argsdicts( args, kwargs ) ]
            return '\n'.join( x )
            
        if self.tag in self.parent.twotags:
            for myarg, mydict in _argsdicts( args, kwargs ):
                self.render( self.tag, False, myarg, mydict )
        elif self.tag in self.parent.onetags:
            if len( args ) == 0:
                for myarg, mydict in _argsdicts( args, kwargs ):
                    self.render( self.tag, True, myarg, mydict )    # here myarg is always None, because len( args ) = 0
            else:
                raise ClosingError( self.tag )
        elif self.parent.mode == 'strict_html' and self.tag in self.parent.deptags:
            raise DeprecationError( self.tag )
        else:
            raise InvalidElementError( self.tag, self.parent.mode )
    
    def render( self, tag, single, between, kwargs ):
        """Append the actual tags to content."""

        out = u"<%s" % tag
        for key, value in kwargs.iteritems( ):
            if value is not None:               # when value is None that means stuff like <... checked>
                key = key.strip('_')            # strip this so class_ will mean class, etc.
                if key == 'http_equiv':         # special cases, maybe change _ to - overall?
                    key = 'http-equiv'
                elif key == 'accept_charset':
                    key = 'accept-charset'
                out = u"%s %s=\"%s\"" % ( out, key, escape( value ) )
            else:
                out = u"%s %s" % ( out, key )
        if between is not None:
            out = u"%s>%s</%s>" % ( out, between, tag )
        else:
            if single:
                out = u"%s />" % out
            else:
                out = u"%s>" % out
        if self.parent is not None:
            self.parent.content.append( out )
        else:
            return out
    
    def close( self ):
        """Append a closing tag unless element has only opening tag."""

        if self.tag in self.parent.twotags:
            self.parent.content.append( "</%s>" % self.tag )
        elif self.tag in self.parent.onetags:
            raise ClosingError( self.tag )
        elif self.parent.mode == 'strict_html' and self.tag in self.parent.deptags:
            raise DeprecationError( self.tag )

    def open( self, **kwargs ):
        """Append an opening tag."""

        if self.tag in self.parent.twotags or self.tag in self.parent.onetags:
            self.render( self.tag, False, None, kwargs )
        elif self.mode == 'strict_html' and self.tag in self.parent.deptags:
            raise DeprecationError( self.tag )

class page:
    """This is our main class representing a document. Elements are added
    as attributes of an instance of this class."""

    def __init__( self, mode='strict_html', case='lower', onetags=None, twotags=None, separator='\n', class_=None ):
        """Stuff that effects the whole document.

        mode -- 'strict_html'   for HTML 4.01 (default)
                'html'          alias for 'strict_html'
                'loose_html'    to allow some deprecated elements
                'xml'           to allow arbitrary elements

        case -- 'lower'         element names will be printed in lower case (default)
                'upper'         they will be printed in upper case

        onetags --              list or tuple of valid elements with opening tags only
        twotags --              list or tuple of valid elements with both opening and closing tags
                                these two keyword arguments may be used to select
                                the set of valid elements in 'xml' mode
                                invalid elements will raise appropriate exceptions
        
        separator --            string to place between added elements, defaults to newline
        
        class_ --               a class that will be added to every element if defined"""
        
        valid_onetags = [ "AREA", "BASE", "BR", "COL", "FRAME", "HR", "IMG", "INPUT", "LINK", "META", "PARAM" ]
        valid_twotags = [ "A", "ABBR", "ACRONYM", "ADDRESS", "B", "BDO", "BIG", "BLOCKQUOTE", "BODY", "BUTTON",
                "CAPTION", "CITE", "CODE", "COLGROUP", "DD", "DEL", "DFN", "DIV", "DL", "DT", "EM", "FIELDSET",
                "FORM", "FRAMESET", "H1", "H2", "H3", "H4", "H5", "H6", "HEAD", "HTML", "I", "IFRAME", "INS",
                "KBD", "LABEL", "LEGEND", "LI", "MAP", "NOFRAMES", "NOSCRIPT", "OBJECT", "OL", "OPTGROUP",
                "OPTION", "P", "PRE", "Q", "SAMP", "SCRIPT", "SELECT", "SMALL", "SPAN", "STRONG", "STYLE",
                "SUB", "SUP", "TABLE", "TBODY", "TD", "TEXTAREA", "TFOOT", "TH", "THEAD", "TITLE", "TR",
                "TT", "UL", "VAR" ]
        deprecated_onetags = [ "BASEFONT", "ISINDEX" ]
        deprecated_twotags = [ "APPLET", "CENTER", "DIR", "FONT", "MENU", "S", "STRIKE", "U" ]

        self.header = [ ]
        self.content = [ ]
        self.footer = [ ]
        self.case = case
        self.separator = separator

        # init( ) sets it to True so we know that </body></html> has to be printed at the end
        self._full = False
        self.class_= class_

        if mode == 'strict_html' or mode == 'html':
            self.onetags = valid_onetags
            self.onetags += map( string.lower, self.onetags )
            self.twotags = valid_twotags
            self.twotags += map( string.lower, self.twotags )
            self.deptags = deprecated_onetags + deprecated_twotags
            self.deptags += map( string.lower, self.deptags )
            self.mode = 'strict_html'
        elif mode == 'loose_html':
            self.onetags = valid_onetags + deprecated_onetags 
            self.onetags += map( string.lower, self.onetags )
            self.twotags = valid_twotags + deprecated_twotags
            self.twotags += map( string.lower, self.twotags )
            self.mode = mode
        elif mode == 'xml':
            if onetags and twotags:
                self.onetags = onetags
                self.twotags = twotags
            elif ( onetags and not twotags ) or ( twotags and not onetags ):
                raise CustomizationError( )
            else:
                self.onetags = russell( )
                self.twotags = russell( )
            self.mode = mode
        else:
            raise ModeError( mode )

    def __getattr__( self, attr ):
        if attr.startswith("__") and attr.endswith("__"):
            raise AttributeError, attr
        return element( attr, case=self.case, parent=self )

    def __str__( self ):
        
        if self._full and ( self.mode == 'strict_html' or self.mode == 'loose_html' ):
            end = [ '</body>', '</html>' ]
        else:
            end = [ ]
        
        return self.separator.join( self.header + self.content + self.footer + end )

    def __call__( self, escape=False ):
        """Return the document as a string.

        escape --   False   print normally
                    True    replace < and > by &lt; and &gt;
                            the default escape sequences in most browsers"""

        if escape:
            return _escape( self.__str__( ) )
        else:
            return self.__str__( )

    def add( self, text ):
        """This is an alias to addcontent."""
        self.addcontent( text )

    def addfooter( self, text ):
        """Add some text to the bottom of the document"""
        self.footer.append( text )

    def addheader( self, text ):
        """Add some text to the top of the document"""
        self.header.append( text )

    def addcontent( self, text ):
        """Add some text to the main part of the document"""
        self.content.append( text )


    def init( self, lang='en', css=None, metainfo=None, title=None, header=None,
              footer=None, charset=None, encoding=None, doctype=None, bodyattrs=None, script=None ):
        """This method is used for complete documents with appropriate
        doctype, encoding, title, etc information. For an HTML/XML snippet
        omit this method.

        lang --     language, usually a two character string, will appear
                    as <html lang='en'> in html mode (ignored in xml mode)
        
        css --      Cascading Style Sheet filename as a string or a list of
                    strings for multiple css files (ignored in xml mode)

        metainfo -- a dictionary in the form { 'name':'content' } to be inserted
                    into meta element(s) as <meta name='name' content='content'>
                    (ignored in xml mode)

        bodyattrs --a dictionary in the form { 'key':'value', ... } which will be added
                    as attributes of the <body> element as <body key='value' ... >
                    (ignored in xml mode)

        script --   dictionary containing src:type pairs, <script type='text/type' src=src></script>

        title --    the title of the document as a string to be inserted into
                    a title element as <title>my title</title> (ignored in xml mode)

        header --   some text to be inserted right after the <body> element
                    (ignored in xml mode)

        footer --   some text to be inserted right before the </body> element
                    (ignored in xml mode)

        charset --  a string defining the character set, will be inserted into a
                    <meta http-equiv='Content-Type' content='text/html; charset=myset'>
                    element (ignored in xml mode)

        encoding -- a string defining the encoding, will be put into to first line of
                    the document as <?xml version='1.0' encoding='myencoding' ?> in
                    xml mode (ignored in html mode)

        doctype --  the document type string, defaults to
                    <!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN'>
                    in html mode (ignored in xml mode)"""

        self._full = True

        if self.mode == 'strict_html' or self.mode == 'loose_html':
            if doctype is None:
                doctype = "<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN'>"
            self.header.append( doctype )
            self.html( lang=lang )
            self.head( )
            if charset is not None:
                self.meta( http_equiv='Content-Type', content="text/html; charset=%s" % charset )
            if metainfo is not None:
                self.metainfo( metainfo )
            if css is not None:
                self.css( css )
            if title is not None:
                self.title( title )
            if script is not None:
                self.scripts( script )
            self.head.close()
            if bodyattrs is not None:
                self.body( **bodyattrs )
            else:
                self.body( )
            if header is not None:
                self.content.append( header )
            if footer is not None:
                self.footer.append( footer )

        elif self.mode == 'xml':
            if doctype is None:
                if encoding is not None:
                    doctype = "<?xml version='1.0' encoding='%s' ?>" % encoding
                else:
                    doctype = "<?xml version='1.0' ?>"
            self.header.append( doctype )

    def css( self, filelist ):
        """This convenience function is only useful for html.
        It adds css stylesheet(s) to the document via the <link> element."""
      
        if isinstance( filelist, basestring ):
            self.link( href=filelist, rel='stylesheet', type='text/css', media='all' )
        else:
            for file in filelist:
                self.link( href=file, rel='stylesheet', type='text/css', media='all' )

    def metainfo( self, mydict ):
        """This convenience function is only useful for html.
        It adds meta information via the <meta> element, the argument is
        a dictionary of the form { 'name':'content' }."""

        if isinstance( mydict, dict ):
            for name, content in mydict.iteritems( ):
                self.meta( name=name, content=content )
        else:
            raise TypeError, "Metainfo should be called with a dictionary argument of name:content pairs."

    def scripts( self, mydict ):
        """Only useful in html, mydict is dictionary of src:type pairs will
        be rendered as <script type='text/type' src=src></script>"""

        if isinstance( mydict, dict ):
            for src, type in mydict.iteritems( ):
                self.script( '', src=src, type='text/%s' % type )
        else:
            raise TypeError, "Script should be given a dictionary of src:type pairs."


class _oneliner:
    """An instance of oneliner returns a string corresponding to one element.
    This class can be used to write 'oneliners' that return a string
    immediately so there is no need to instantiate the page class."""
    
    def __init__( self, case='lower' ):
        self.case = case
    
    def __getattr__( self, attr ):
        if attr.startswith("__") and attr.endswith("__"):
            raise AttributeError, attr
        return element( attr, case=self.case, parent=None )

oneliner = _oneliner( case='lower' )
upper_oneliner = _oneliner( case='upper' )

def _argsdicts( args, mydict ):
    """A utility generator that pads argument list and dictionary values, will only be called with len( args ) = 0, 1."""
    
    if len( args ) == 0:
        args = None, 
    elif len( args ) == 1:
        args = _totuple( args[0] )
    else:
        raise Exception, "We should have never gotten here."

    mykeys = mydict.keys( )
    myvalues = map( _totuple, mydict.values( ) )

    maxlength = max( map( len, [ args ] + myvalues ) )

    for i in xrange( maxlength ):
        thisdict = { }
        for key, value in zip( mykeys, myvalues ):
            try:
                thisdict[ key ] = value[i]
            except IndexError:
                thisdict[ key ] = value[-1]
        try:
            thisarg = args[i]
        except IndexError:
            thisarg = args[-1]

        yield thisarg, thisdict

def _totuple( x ):
    """Utility stuff to convert string, int, float, None or anything to a usable tuple."""

    if isinstance( x, basestring ):
        out = x,
    elif isinstance( x, ( int, float ) ):
        out = str( x ),
    elif x is None:
        out = None,
    else:
        out = tuple( x )

    return out

def escape( text, newline=False ):
    """Escape special html characters."""

    if isinstance( text, basestring ):
        if '&' in text:
            text = text.replace( '&', '&amp;' )
        if '>' in text:
            text = text.replace( '>', '&gt;' )
        if '<' in text:
            text = text.replace( '<', '&lt;' )
        if '\"' in text:
            text = text.replace( '\"', '&quot;' )
        if '\'' in text:
            text = text.replace( '\'', '&quot;' )
        if newline:
            if '\n' in text:
                text = text.replace( '\n', '<br>' )

    return text

_escape = escape

def unescape( text ):
    """Inverse of escape."""
    
    if isinstance( text, basestring ):
        if '&amp;' in text:
            text = text.replace( '&amp;', '&' )
        if '&gt;' in text:
            text = text.replace( '&gt;', '>' )
        if '&lt;' in text:
            text = text.replace( '&lt;', '<' )
        if '&quot;' in text:
            text = text.replace( '&quot;', '\"' )

    return text

class dummy:
    """A dummy class for attaching attributes."""
    pass

doctype = dummy( )
doctype.frameset = "<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Frameset//EN' 'http://www.w3.org/TR/html4/frameset.dtd'>"
doctype.strict = "<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01//EN' 'http://www.w3.org/TR/html4/strict.dtd'>"
doctype.loose = "<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN' 'http://www.w3.org/TR/html4/loose.dtd'>"

class russell:
    """A dummy class that contains anything."""

    def __contains__( self, item ):
        return True


class MarkupError( Exception ):
    """All our exceptions subclass this."""
    def __str__( self ):
        return self.message

class ClosingError( MarkupError ):
    def __init__( self, tag ):
        self.message = "The element '%s' does not accept non-keyword arguments (has no closing tag)." % tag

class OpeningError( MarkupError ):
    def __init__( self, tag ):
        self.message = "The element '%s' can not be opened." % tag

class ArgumentError( MarkupError ):
    def __init__( self, tag ):
        self.message = "The element '%s' was called with more than one non-keyword argument." % tag

class InvalidElementError( MarkupError ):
    def __init__( self, tag, mode ):
        self.message = "The element '%s' is not valid for your mode '%s'." % ( tag, mode )

class DeprecationError( MarkupError ):
    def __init__( self, tag ):
        self.message = "The element '%s' is deprecated, instantiate markup.page with mode='loose_html' to allow it." % tag

class ModeError( MarkupError ):
    def __init__( self, mode ):
        self.message = "Mode '%s' is invalid, possible values: strict_html, loose_html, xml." % mode

class CustomizationError( MarkupError ):
    def __init__( self ):
        self.message = "If you customize the allowed elements, you must define both types 'onetags' and 'twotags'."

if __name__ == '__main__':
    print __doc__

########NEW FILE########
__FILENAME__ = markup3
# This code is in the public domain, it comes
# with absolutely no warranty and you can do
# absolutely whatever you want with it.

__date__ = '17 May 2007'
__version__ = '1.7'
__doc__= """
This is markup.py - a Python module that attempts to
make it easier to generate HTML/XML from a Python program
in an intuitive, lightweight, customizable and pythonic way.

The code is in the public domain.

Version: %s as of %s.

Documentation and further info is at http://markup.sourceforge.net/

Please send bug reports, feature requests, enhancement
ideas or questions to nogradi at gmail dot com.

Installation: drop markup.py somewhere into your Python path.
""" % ( __version__, __date__ )

import string

class element:
    """This class handles the addition of a new element."""

    def __init__( self, tag, case='lower', parent=None ):
        self.parent = parent

        if case == 'lower':
            self.tag = tag.lower( )
        else:
            self.tag = tag.upper( )
    
    def __call__( self, *args, **kwargs ):
        if len( args ) > 1:
            raise ArgumentError( self.tag )

        # if class_ was defined in parent it should be added to every element
        if self.parent is not None and self.parent.class_ is not None:
            if 'class_' not in kwargs:
                kwargs['class_'] = self.parent.class_
            
        if self.parent is None and len( args ) == 1:
            x = [ self.render( self.tag, False, myarg, mydict ) for myarg, mydict in _argsdicts( args, kwargs ) ]
            return '\n'.join( x )
        elif self.parent is None and len( args ) == 0:
            x = [ self.render( self.tag, True, myarg, mydict ) for myarg, mydict in _argsdicts( args, kwargs ) ]
            return '\n'.join( x )
            
        if self.tag in self.parent.twotags:
            for myarg, mydict in _argsdicts( args, kwargs ):
                self.render( self.tag, False, myarg, mydict )
        elif self.tag in self.parent.onetags:
            if len( args ) == 0:
                for myarg, mydict in _argsdicts( args, kwargs ):
                    self.render( self.tag, True, myarg, mydict )    # here myarg is always None, because len( args ) = 0
            else:
                raise ClosingError( self.tag )
        elif self.parent.mode == 'strict_html' and self.tag in self.parent.deptags:
            raise DeprecationError( self.tag )
        else:
            raise InvalidElementError( self.tag, self.parent.mode )
    
    def render( self, tag, single, between, kwargs ):
        """Append the actual tags to content."""

        out = "<%s" % tag
        for key, value in kwargs.items( ):
            if value is not None:               # when value is None that means stuff like <... checked>
                key = key.strip('_')            # strip this so class_ will mean class, etc.
                if key == 'http_equiv':         # special cases, maybe change _ to - overall?
                    key = 'http-equiv'
                elif key == 'accept_charset':
                    key = 'accept-charset'
                out = "%s %s=\"%s\"" % ( out, key, escape( value ) )
            else:
                out = "%s %s" % ( out, key )
        if between is not None:
            out = "%s>%s</%s>" % ( out, between, tag )
        else:
            if single:
                out = "%s />" % out
            else:
                out = "%s>" % out
        if self.parent is not None:
            self.parent.content.append( out )
        else:
            return out
    
    def close( self ):
        """Append a closing tag unless element has only opening tag."""

        if self.tag in self.parent.twotags:
            self.parent.content.append( "</%s>" % self.tag )
        elif self.tag in self.parent.onetags:
            raise ClosingError( self.tag )
        elif self.parent.mode == 'strict_html' and self.tag in self.parent.deptags:
            raise DeprecationError( self.tag )

    def open( self, **kwargs ):
        """Append an opening tag."""

        if self.tag in self.parent.twotags or self.tag in self.parent.onetags:
            self.render( self.tag, False, None, kwargs )
        elif self.mode == 'strict_html' and self.tag in self.parent.deptags:
            raise DeprecationError( self.tag )

class page:
    """This is our main class representing a document. Elements are added
    as attributes of an instance of this class."""

    def __init__( self, mode='strict_html', case='lower', onetags=None, twotags=None, separator='\n', class_=None ):
        """Stuff that effects the whole document.

        mode -- 'strict_html'   for HTML 4.01 (default)
                'html'          alias for 'strict_html'
                'loose_html'    to allow some deprecated elements
                'xml'           to allow arbitrary elements

        case -- 'lower'         element names will be printed in lower case (default)
                'upper'         they will be printed in upper case

        onetags --              list or tuple of valid elements with opening tags only
        twotags --              list or tuple of valid elements with both opening and closing tags
                                these two keyword arguments may be used to select
                                the set of valid elements in 'xml' mode
                                invalid elements will raise appropriate exceptions
        
        separator --            string to place between added elements, defaults to newline
        
        class_ --               a class that will be added to every element if defined"""
        
        valid_onetags = [ "AREA", "BASE", "BR", "COL", "FRAME", "HR", "IMG", "INPUT", "LINK", "META", "PARAM" ]
        valid_twotags = [ "A", "ABBR", "ACRONYM", "ADDRESS", "B", "BDO", "BIG", "BLOCKQUOTE", "BODY", "BUTTON",
                "CAPTION", "CITE", "CODE", "COLGROUP", "DD", "DEL", "DFN", "DIV", "DL", "DT", "EM", "FIELDSET",
                "FORM", "FRAMESET", "H1", "H2", "H3", "H4", "H5", "H6", "HEAD", "HTML", "I", "IFRAME", "INS",
                "KBD", "LABEL", "LEGEND", "LI", "MAP", "NOFRAMES", "NOSCRIPT", "OBJECT", "OL", "OPTGROUP",
                "OPTION", "P", "PRE", "Q", "SAMP", "SCRIPT", "SELECT", "SMALL", "SPAN", "STRONG", "STYLE",
                "SUB", "SUP", "TABLE", "TBODY", "TD", "TEXTAREA", "TFOOT", "TH", "THEAD", "TITLE", "TR",
                "TT", "UL", "VAR" ]
        deprecated_onetags = [ "BASEFONT", "ISINDEX" ]
        deprecated_twotags = [ "APPLET", "CENTER", "DIR", "FONT", "MENU", "S", "STRIKE", "U" ]

        self.header = [ ]
        self.content = [ ]
        self.footer = [ ]
        self.case = case
        self.separator = separator

        # init( ) sets it to True so we know that </body></html> has to be printed at the end
        self._full = False
        self.class_= class_

        if mode == 'strict_html' or mode == 'html':
            self.onetags = valid_onetags
            self.onetags += list(map( str.lower, self.onetags ))
            self.twotags = valid_twotags
            self.twotags += list(map( str.lower, self.twotags ))
            self.deptags = deprecated_onetags + deprecated_twotags
            self.deptags += list(map( str.lower, self.deptags ))
            self.mode = 'strict_html'
        elif mode == 'loose_html':
            self.onetags = valid_onetags + deprecated_onetags 
            self.onetags += list(map( str.lower, self.onetags ))
            self.twotags = valid_twotags + deprecated_twotags
            self.twotags += list(map( str.lower, self.twotags ))
            self.mode = mode
        elif mode == 'xml':
            if onetags and twotags:
                self.onetags = onetags
                self.twotags = twotags
            elif ( onetags and not twotags ) or ( twotags and not onetags ):
                raise CustomizationError( )
            else:
                self.onetags = russell( )
                self.twotags = russell( )
            self.mode = mode
        else:
            raise ModeError( mode )

    def __getattr__( self, attr ):
        if attr.startswith("__") and attr.endswith("__"):
            raise AttributeError(attr)
        return element( attr, case=self.case, parent=self )

    def __str__( self ):
        
        if self._full and ( self.mode == 'strict_html' or self.mode == 'loose_html' ):
            end = [ '</body>', '</html>' ]
        else:
            end = [ ]
        
        return self.separator.join( self.header + self.content + self.footer + end )

    def __call__( self, escape=False ):
        """Return the document as a string.

        escape --   False   print normally
                    True    replace < and > by &lt; and &gt;
                            the default escape sequences in most browsers"""

        if escape:
            return _escape( self.__str__( ) )
        else:
            return self.__str__( )

    def add( self, text ):
        """This is an alias to addcontent."""
        self.addcontent( text )

    def addfooter( self, text ):
        """Add some text to the bottom of the document"""
        self.footer.append( text )

    def addheader( self, text ):
        """Add some text to the top of the document"""
        self.header.append( text )

    def addcontent( self, text ):
        """Add some text to the main part of the document"""
        self.content.append( text )


    def init( self, lang='en', css=None, metainfo=None, title=None, header=None,
              footer=None, charset=None, encoding=None, doctype=None, bodyattrs=None, script=None ):
        """This method is used for complete documents with appropriate
        doctype, encoding, title, etc information. For an HTML/XML snippet
        omit this method.

        lang --     language, usually a two character string, will appear
                    as <html lang='en'> in html mode (ignored in xml mode)
        
        css --      Cascading Style Sheet filename as a string or a list of
                    strings for multiple css files (ignored in xml mode)

        metainfo -- a dictionary in the form { 'name':'content' } to be inserted
                    into meta element(s) as <meta name='name' content='content'>
                    (ignored in xml mode)

        bodyattrs --a dictionary in the form { 'key':'value', ... } which will be added
                    as attributes of the <body> element as <body key='value' ... >
                    (ignored in xml mode)

        script --   dictionary containing src:type pairs, <script type='text/type' src=src></script>

        title --    the title of the document as a string to be inserted into
                    a title element as <title>my title</title> (ignored in xml mode)

        header --   some text to be inserted right after the <body> element
                    (ignored in xml mode)

        footer --   some text to be inserted right before the </body> element
                    (ignored in xml mode)

        charset --  a string defining the character set, will be inserted into a
                    <meta http-equiv='Content-Type' content='text/html; charset=myset'>
                    element (ignored in xml mode)

        encoding -- a string defining the encoding, will be put into to first line of
                    the document as <?xml version='1.0' encoding='myencoding' ?> in
                    xml mode (ignored in html mode)

        doctype --  the document type string, defaults to
                    <!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN'>
                    in html mode (ignored in xml mode)"""

        self._full = True

        if self.mode == 'strict_html' or self.mode == 'loose_html':
            if doctype is None:
                doctype = "<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN'>"
            self.header.append( doctype )
            self.html( lang=lang )
            self.head( )
            if charset is not None:
                self.meta( http_equiv='Content-Type', content="text/html; charset=%s" % charset )
            if metainfo is not None:
                self.metainfo( metainfo )
            if css is not None:
                self.css( css )
            if title is not None:
                self.title( title )
            if script is not None:
                self.scripts( script )
            self.head.close()
            if bodyattrs is not None:
                self.body( **bodyattrs )
            else:
                self.body( )
            if header is not None:
                self.content.append( header )
            if footer is not None:
                self.footer.append( footer )

        elif self.mode == 'xml':
            if doctype is None:
                if encoding is not None:
                    doctype = "<?xml version='1.0' encoding='%s' ?>" % encoding
                else:
                    doctype = "<?xml version='1.0' ?>"
            self.header.append( doctype )

    def css( self, filelist ):
        """This convenience function is only useful for html.
        It adds css stylesheet(s) to the document via the <link> element."""
      
        if isinstance( filelist, str ):
            self.link( href=filelist, rel='stylesheet', type='text/css', media='all' )
        else:
            for file in filelist:
                self.link( href=file, rel='stylesheet', type='text/css', media='all' )

    def metainfo( self, mydict ):
        """This convenience function is only useful for html.
        It adds meta information via the <meta> element, the argument is
        a dictionary of the form { 'name':'content' }."""

        if isinstance( mydict, dict ):
            for name, content in mydict.items( ):
                self.meta( name=name, content=content )
        else:
            raise TypeError("Metainfo should be called with a dictionary argument of name:content pairs.")

    def scripts( self, mydict ):
        """Only useful in html, mydict is dictionary of src:type pairs will
        be rendered as <script type='text/type' src=src></script>"""

        if isinstance( mydict, dict ):
            for src, type in mydict.items( ):
                self.script( '', src=src, type='text/%s' % type )
        else:
            raise TypeError("Script should be given a dictionary of src:type pairs.")


class _oneliner:
    """An instance of oneliner returns a string corresponding to one element.
    This class can be used to write 'oneliners' that return a string
    immediately so there is no need to instantiate the page class."""
    
    def __init__( self, case='lower' ):
        self.case = case
    
    def __getattr__( self, attr ):
        if attr.startswith("__") and attr.endswith("__"):
            raise AttributeError(attr)
        return element( attr, case=self.case, parent=None )

oneliner = _oneliner( case='lower' )
upper_oneliner = _oneliner( case='upper' )

def _argsdicts( args, mydict ):
    """A utility generator that pads argument list and dictionary values, will only be called with len( args ) = 0, 1."""
    
    if len( args ) == 0:
        args = None, 
    elif len( args ) == 1:
        args = _totuple( args[0] )
    else:
        raise Exception("We should have never gotten here.")

    mykeys = list(mydict.keys( ))
    myvalues = list(map( _totuple, list(mydict.values( )) ))

    maxlength = max( list(map( len, [ args ] + myvalues )) )

    for i in range( maxlength ):
        thisdict = { }
        for key, value in zip( mykeys, myvalues ):
            try:
                thisdict[ key ] = value[i]
            except IndexError:
                thisdict[ key ] = value[-1]
        try:
            thisarg = args[i]
        except IndexError:
            thisarg = args[-1]

        yield thisarg, thisdict

def _totuple( x ):
    """Utility stuff to convert string, int, float, None or anything to a usable tuple."""

    if isinstance( x, str ):
        out = x,
    elif isinstance( x, ( int, float ) ):
        out = str( x ),
    elif x is None:
        out = None,
    else:
        out = tuple( x )

    return out

def escape( text, newline=False ):
    """Escape special html characters."""

    if isinstance( text, str ):
        if '&' in text:
            text = text.replace( '&', '&amp;' )
        if '>' in text:
            text = text.replace( '>', '&gt;' )
        if '<' in text:
            text = text.replace( '<', '&lt;' )
        if '\"' in text:
            text = text.replace( '\"', '&quot;' )
        if '\'' in text:
            text = text.replace( '\'', '&quot;' )
        if newline:
            if '\n' in text:
                text = text.replace( '\n', '<br>' )

    return text

_escape = escape

def unescape( text ):
    """Inverse of escape."""
    
    if isinstance( text, str ):
        if '&amp;' in text:
            text = text.replace( '&amp;', '&' )
        if '&gt;' in text:
            text = text.replace( '&gt;', '>' )
        if '&lt;' in text:
            text = text.replace( '&lt;', '<' )
        if '&quot;' in text:
            text = text.replace( '&quot;', '\"' )

    return text

class dummy:
    """A dummy class for attaching attributes."""
    pass

doctype = dummy( )
doctype.frameset = "<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Frameset//EN' 'http://www.w3.org/TR/html4/frameset.dtd'>"
doctype.strict = "<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01//EN' 'http://www.w3.org/TR/html4/strict.dtd'>"
doctype.loose = "<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN' 'http://www.w3.org/TR/html4/loose.dtd'>"

class russell:
    """A dummy class that contains anything."""

    def __contains__( self, item ):
        return True


class MarkupError( Exception ):
    """All our exceptions subclass this."""
    def __str__( self ):
        return self.message

class ClosingError( MarkupError ):
    def __init__( self, tag ):
        self.message = "The element '%s' does not accept non-keyword arguments (has no closing tag)." % tag

class OpeningError( MarkupError ):
    def __init__( self, tag ):
        self.message = "The element '%s' can not be opened." % tag

class ArgumentError( MarkupError ):
    def __init__( self, tag ):
        self.message = "The element '%s' was called with more than one non-keyword argument." % tag

class InvalidElementError( MarkupError ):
    def __init__( self, tag, mode ):
        self.message = "The element '%s' is not valid for your mode '%s'." % ( tag, mode )

class DeprecationError( MarkupError ):
    def __init__( self, tag ):
        self.message = "The element '%s' is deprecated, instantiate markup.page with mode='loose_html' to allow it." % tag

class ModeError( MarkupError ):
    def __init__( self, mode ):
        self.message = "Mode '%s' is invalid, possible values: strict_html, loose_html, xml." % mode

class CustomizationError( MarkupError ):
    def __init__( self ):
        self.message = "If you customize the allowed elements, you must define both types 'onetags' and 'twotags'."

if __name__ == '__main__':
    print(__doc__)

########NEW FILE########
__FILENAME__ = anim
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import ANIMNS
from element import Element


# Autogenerated
def Animate(**args):
    return Element(qname = (ANIMNS,'animate'), **args)

def Animatecolor(**args):
    return Element(qname = (ANIMNS,'animateColor'), **args)

def Animatemotion(**args):
    return Element(qname = (ANIMNS,'animateMotion'), **args)

def Animatetransform(**args):
    return Element(qname = (ANIMNS,'animateTransform'), **args)

def Audio(**args):
    return Element(qname = (ANIMNS,'audio'), **args)

def Command(**args):
    return Element(qname = (ANIMNS,'command'), **args)

def Iterate(**args):
    return Element(qname = (ANIMNS,'iterate'), **args)

def Par(**args):
    return Element(qname = (ANIMNS,'par'), **args)

def Param(**args):
    return Element(qname = (ANIMNS,'param'), **args)

def Seq(**args):
    return Element(qname = (ANIMNS,'seq'), **args)

def Set(**args):
    return Element(qname = (ANIMNS,'set'), **args)

def Transitionfilter(**args):
    return Element(qname = (ANIMNS,'transitionFilter'), **args)


########NEW FILE########
__FILENAME__ = attrconverters
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2010 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#
from namespaces import *
import re, types

pattern_color =  re.compile(r'#[0-9a-fA-F]{6}')
pattern_vector3D = re.compile(r'\([ ]*-?([0-9]+(\.[0-9]*)?|\.[0-9]+)([ ]+-?([0-9]+(\.[0-9]*)?|\.[0-9]+)){2}[ ]*\)')

def make_NCName(arg):
    for c in (':',' '):
        arg = arg.replace(c,"_%x_" % ord(c))
    return arg

def cnv_anyURI(attribute, arg, element):
    return unicode(arg)

def cnv_boolean(attribute, arg, element):
    if arg.lower() in ("false","no"):
        return "false"
    if arg:
        return "true"
    return "false"

# Potentially accept color values
def cnv_color(attribute, arg, element):
    """ A RGB color in conformance with 5.9.11 of [XSL], that is a RGB color in notation #rrggbb, where
        rr, gg and bb are 8-bit hexadecimal digits.
    """
    return str(arg)

def cnv_configtype(attribute, arg, element):
    if str(arg) not in ("boolean", "short", "int", "long",
    "double", "string", "datetime", "base64Binary"):
        raise ValueError, "'%s' not allowed" % str(arg)
    return str(arg)

def cnv_data_source_has_labels(attribute, arg, element):
    if str(arg) not in ("none","row","column","both"):
        raise ValueError, "'%s' not allowed" % str(arg)
    return str(arg)

# Understand different date formats
def cnv_date(attribute, arg, element):
    """ A dateOrDateTime value is either an [xmlschema-2] date value or an [xmlschema-2] dateTime
        value.
    """
    return str(arg)

def cnv_dateTime(attribute, arg, element):
    """ A dateOrDateTime value is either an [xmlschema-2] date value or an [xmlschema-2] dateTime
        value.
    """
    return str(arg)

def cnv_double(attribute, arg, element):
    return str(arg)

def cnv_duration(attribute, arg, element):
    return str(arg)

def cnv_family(attribute, arg, element):
    """ A style family """
    if str(arg) not in ("text", "paragraph", "section", "ruby", "table", "table-column", "table-row", "table-cell",
      "graphic", "presentation", "drawing-page", "chart"):
        raise ValueError, "'%s' not allowed" % str(arg)
    return str(arg)

def __save_prefix(attribute, arg, element):
    prefix = arg.split(':',1)[0]
    if prefix == arg:
        return unicode(arg)
    namespace = element.get_knownns(prefix)
    if namespace is None:
        #raise ValueError, "'%s' is an unknown prefix" % str(prefix)
        return unicode(arg)
    p = element.get_nsprefix(namespace)
    return unicode(arg)

def cnv_formula(attribute, arg, element):
    """ A string containing a formula. Formulas do not have a predefined syntax, but the string should
        begin with a namespace prefix, followed by a : (COLON, U+003A) separator, followed by the text
        of the formula. The namespace bound to the prefix determines the syntax and semantics of the
        formula.
    """
    return __save_prefix(attribute, arg, element)

def cnv_ID(attribute, arg, element):
    return str(arg)

def cnv_IDREF(attribute, arg, element):
    return str(arg)

def cnv_integer(attribute, arg, element):
    return str(arg)

def cnv_legend_position(attribute, arg, element):
    if str(arg) not in ("start", "end", "top", "bottom", "top-start", "bottom-start", "top-end", "bottom-end"):
        raise ValueError, "'%s' not allowed" % str(arg)
    return str(arg)

pattern_length = re.compile(r'-?([0-9]+(\.[0-9]*)?|\.[0-9]+)((cm)|(mm)|(in)|(pt)|(pc)|(px))')

def cnv_length(attribute, arg, element):
    """ A (positive or negative) physical length, consisting of magnitude and unit, in conformance with the
        Units of Measure defined in 5.9.13 of [XSL].
    """
    global pattern_length
    if not pattern_length.match(arg):
        raise ValueError, "'%s' is not a valid length" % arg
    return arg

def cnv_lengthorpercent(attribute, arg, element):
    failed = False
    try: return cnv_length(attribute, arg, element)
    except: failed = True
    try: return cnv_percent(attribute, arg, element)
    except: failed = True
    if failed:
        raise ValueError, "'%s' is not a valid length or percent" % arg
    return arg

def cnv_metavaluetype(attribute, arg, element):
    if str(arg) not in ("float", "date", "time", "boolean", "string"):
        raise ValueError, "'%s' not allowed" % str(arg)
    return str(arg)

def cnv_major_minor(attribute, arg, element):
    if arg not in ('major','minor'):
        raise ValueError, "'%s' is not either 'minor' or 'major'" % arg

pattern_namespacedToken = re.compile(r'[0-9a-zA-Z_]+:[0-9a-zA-Z._\-]+')

def cnv_namespacedToken(attribute, arg, element):
    global pattern_namespacedToken

    if not pattern_namespacedToken.match(arg):
        raise ValueError, "'%s' is not a valid namespaced token" % arg
    return __save_prefix(attribute, arg, element)

def cnv_NCName(attribute, arg, element):
    """ NCName is defined in http://www.w3.org/TR/REC-xml-names/#NT-NCName
        Essentially an XML name minus ':'
    """
    if type(arg) in types.StringTypes:
        return make_NCName(arg)
    else:
        return arg.getAttrNS(STYLENS, 'name')

# This function takes either an instance of a style (preferred)
# or a text string naming the style. If it is a text string, then it must
# already have been converted to an NCName
# The text-string argument is mainly for when we build a structure from XML
def cnv_StyleNameRef(attribute, arg, element):
    try:
        return arg.getAttrNS(STYLENS, 'name')
    except:
        return arg

# This function takes either an instance of a style (preferred)
# or a text string naming the style. If it is a text string, then it must
# already have been converted to an NCName
# The text-string argument is mainly for when we build a structure from XML
def cnv_DrawNameRef(attribute, arg, element):
    try:
        return arg.getAttrNS(DRAWNS, 'name')
    except:
        return arg

# Must accept list of Style objects
def cnv_NCNames(attribute, arg, element):
    return ' '.join(arg)

def cnv_nonNegativeInteger(attribute, arg, element):
    return str(arg)

pattern_percent = re.compile(r'-?([0-9]+(\.[0-9]*)?|\.[0-9]+)%')

def cnv_percent(attribute, arg, element):
    global pattern_percent
    if not pattern_percent.match(arg):
        raise ValueError, "'%s' is not a valid length" % arg
    return arg

# Real one doesn't allow floating point values
pattern_points = re.compile(r'-?[0-9]+,-?[0-9]+([ ]+-?[0-9]+,-?[0-9]+)*')
#pattern_points = re.compile(r'-?[0-9.]+,-?[0-9.]+([ ]+-?[0-9.]+,-?[0-9.]+)*')
def cnv_points(attribute, arg, element):
    global pattern_points
    if type(arg) in types.StringTypes:
        if not pattern_points.match(arg):
            raise ValueError, "x,y are separated by a comma and the points are separated by white spaces"
        return arg
    else:
        try:
            strarg = ' '.join([ "%d,%d" % p for p in arg])
        except:
            raise ValueError, "Points must be string or [(0,0),(1,1)] - not %s" % arg
        return strarg

def cnv_positiveInteger(attribute, arg, element):
    return str(arg)

def cnv_string(attribute, arg, element):
    return unicode(arg)

def cnv_textnoteclass(attribute, arg, element):
    if str(arg) not in ("footnote", "endnote"):
        raise ValueError, "'%s' not allowed" % str(arg)
    return str(arg)

# Understand different time formats
def cnv_time(attribute, arg, element):
    return str(arg)

def cnv_token(attribute, arg, element):
    return str(arg)

pattern_viewbox = re.compile(r'-?[0-9]+([ ]+-?[0-9]+){3}$')

def cnv_viewbox(attribute, arg, element):
    global pattern_viewbox
    if not pattern_viewbox.match(arg):
        raise ValueError, "viewBox must be four integers separated by whitespaces"
    return arg

def cnv_xlinkshow(attribute, arg, element):
    if str(arg) not in ("new", "replace", "embed"):
        raise ValueError, "'%s' not allowed" % str(arg)
    return str(arg)


attrconverters = {
	((ANIMNS,u'audio-level'), None): cnv_double,
	((ANIMNS,u'color-interpolation'), None): cnv_string,
	((ANIMNS,u'color-interpolation-direction'), None): cnv_string,
	((ANIMNS,u'command'), None): cnv_string,
	((ANIMNS,u'formula'), None): cnv_string,
	((ANIMNS,u'id'), None): cnv_ID,
	((ANIMNS,u'iterate-interval'), None): cnv_duration,
	((ANIMNS,u'iterate-type'), None): cnv_string,
	((ANIMNS,u'name'), None): cnv_string,
	((ANIMNS,u'sub-item'), None): cnv_string,
	((ANIMNS,u'value'), None): cnv_string,
#	((DBNS,u'type'), None): cnv_namespacedToken,
	((CHARTNS,u'attached-axis'), None): cnv_string,
	((CHARTNS,u'class'), (CHARTNS,u'grid')): cnv_major_minor,
	((CHARTNS,u'class'), None): cnv_namespacedToken,
	((CHARTNS,u'column-mapping'), None): cnv_string,
	((CHARTNS,u'connect-bars'), None): cnv_boolean,
	((CHARTNS,u'data-label-number'), None): cnv_string,
	((CHARTNS,u'data-label-symbol'), None): cnv_boolean,
	((CHARTNS,u'data-label-text'), None): cnv_boolean,
	((CHARTNS,u'data-source-has-labels'), None): cnv_data_source_has_labels,
	((CHARTNS,u'deep'), None): cnv_boolean,
	((CHARTNS,u'dimension'), None): cnv_string,
	((CHARTNS,u'display-label'), None): cnv_boolean,
	((CHARTNS,u'error-category'), None): cnv_string,
	((CHARTNS,u'error-lower-indicator'), None): cnv_boolean,
	((CHARTNS,u'error-lower-limit'), None): cnv_string,
	((CHARTNS,u'error-margin'), None): cnv_string,
	((CHARTNS,u'error-percentage'), None): cnv_string,
	((CHARTNS,u'error-upper-indicator'), None): cnv_boolean,
	((CHARTNS,u'error-upper-limit'), None): cnv_string,
	((CHARTNS,u'gap-width'), None): cnv_string,
	((CHARTNS,u'interpolation'), None): cnv_string,
	((CHARTNS,u'interval-major'), None): cnv_string,
	((CHARTNS,u'interval-minor-divisor'), None): cnv_string,
	((CHARTNS,u'japanese-candle-stick'), None): cnv_boolean,
	((CHARTNS,u'label-arrangement'), None): cnv_string,
	((CHARTNS,u'label-cell-address'), None): cnv_string,
	((CHARTNS,u'legend-align'), None): cnv_string,
	((CHARTNS,u'legend-position'), None): cnv_legend_position,
	((CHARTNS,u'lines'), None): cnv_boolean,
	((CHARTNS,u'link-data-style-to-source'), None): cnv_boolean,
	((CHARTNS,u'logarithmic'), None): cnv_boolean,
	((CHARTNS,u'maximum'), None): cnv_string,
	((CHARTNS,u'mean-value'), None): cnv_boolean,
	((CHARTNS,u'minimum'), None): cnv_string,
	((CHARTNS,u'name'), None): cnv_string,
	((CHARTNS,u'origin'), None): cnv_string,
	((CHARTNS,u'overlap'), None): cnv_string,
	((CHARTNS,u'percentage'), None): cnv_boolean,
	((CHARTNS,u'pie-offset'), None): cnv_string,
	((CHARTNS,u'regression-type'), None): cnv_string,
	((CHARTNS,u'repeated'), None): cnv_nonNegativeInteger,
	((CHARTNS,u'row-mapping'), None): cnv_string,
	((CHARTNS,u'scale-text'), None): cnv_boolean,
	((CHARTNS,u'series-source'), None): cnv_string,
	((CHARTNS,u'solid-type'), None): cnv_string,
	((CHARTNS,u'spline-order'), None): cnv_string,
	((CHARTNS,u'spline-resolution'), None): cnv_string,
	((CHARTNS,u'stacked'), None): cnv_boolean,
	((CHARTNS,u'style-name'), None): cnv_StyleNameRef,
	((CHARTNS,u'symbol-height'), None): cnv_string,
	((CHARTNS,u'symbol-name'), None): cnv_string,
	((CHARTNS,u'symbol-type'), None): cnv_string,
	((CHARTNS,u'symbol-width'), None): cnv_string,
	((CHARTNS,u'text-overlap'), None): cnv_boolean,
	((CHARTNS,u'three-dimensional'), None): cnv_boolean,
	((CHARTNS,u'tick-marks-major-inner'), None): cnv_boolean,
	((CHARTNS,u'tick-marks-major-outer'), None): cnv_boolean,
	((CHARTNS,u'tick-marks-minor-inner'), None): cnv_boolean,
	((CHARTNS,u'tick-marks-minor-outer'), None): cnv_boolean,
	((CHARTNS,u'values-cell-range-address'), None): cnv_string,
	((CHARTNS,u'vertical'), None): cnv_boolean,
	((CHARTNS,u'visible'), None): cnv_boolean,
	((CONFIGNS,u'name'), None): cnv_formula,
	((CONFIGNS,u'type'), None): cnv_configtype,
	((DR3DNS,u'ambient-color'), None): cnv_string,
	((DR3DNS,u'back-scale'), None): cnv_string,
	((DR3DNS,u'backface-culling'), None): cnv_string,
	((DR3DNS,u'center'), None): cnv_string,
	((DR3DNS,u'close-back'), None): cnv_boolean,
	((DR3DNS,u'close-front'), None): cnv_boolean,
	((DR3DNS,u'depth'), None): cnv_length,
	((DR3DNS,u'diffuse-color'), None): cnv_string,
	((DR3DNS,u'direction'), None): cnv_string,
	((DR3DNS,u'distance'), None): cnv_length,
	((DR3DNS,u'edge-rounding'), None): cnv_string,
	((DR3DNS,u'edge-rounding-mode'), None): cnv_string,
	((DR3DNS,u'emissive-color'), None): cnv_string,
	((DR3DNS,u'enabled'), None): cnv_boolean,
	((DR3DNS,u'end-angle'), None): cnv_string,
	((DR3DNS,u'focal-length'), None): cnv_length,
	((DR3DNS,u'horizontal-segments'), None): cnv_string,
	((DR3DNS,u'lighting-mode'), None): cnv_boolean,
	((DR3DNS,u'max-edge'), None): cnv_string,
	((DR3DNS,u'min-edge'), None): cnv_string,
	((DR3DNS,u'normals-direction'), None): cnv_string,
	((DR3DNS,u'normals-kind'), None): cnv_string,
	((DR3DNS,u'projection'), None): cnv_string,
	((DR3DNS,u'shade-mode'), None): cnv_string,
	((DR3DNS,u'shadow'), None): cnv_string,
	((DR3DNS,u'shadow-slant'), None): cnv_nonNegativeInteger,
	((DR3DNS,u'shininess'), None): cnv_string,
	((DR3DNS,u'size'), None): cnv_string,
	((DR3DNS,u'specular'), None): cnv_boolean,
	((DR3DNS,u'specular-color'), None): cnv_string,
	((DR3DNS,u'texture-filter'), None): cnv_string,
	((DR3DNS,u'texture-generation-mode-x'), None): cnv_string,
	((DR3DNS,u'texture-generation-mode-y'), None): cnv_string,
	((DR3DNS,u'texture-kind'), None): cnv_string,
	((DR3DNS,u'texture-mode'), None): cnv_string,
	((DR3DNS,u'transform'), None): cnv_string,
	((DR3DNS,u'vertical-segments'), None): cnv_string,
	((DR3DNS,u'vpn'), None): cnv_string,
	((DR3DNS,u'vrp'), None): cnv_string,
	((DR3DNS,u'vup'), None): cnv_string,
	((DRAWNS,u'align'), None): cnv_string,
	((DRAWNS,u'angle'), None): cnv_integer,
	((DRAWNS,u'archive'), None): cnv_string,
	((DRAWNS,u'auto-grow-height'), None): cnv_boolean,
	((DRAWNS,u'auto-grow-width'), None): cnv_boolean,
	((DRAWNS,u'background-size'), None): cnv_string,
	((DRAWNS,u'blue'), None): cnv_string,
	((DRAWNS,u'border'), None): cnv_string,
	((DRAWNS,u'caption-angle'), None): cnv_string,
	((DRAWNS,u'caption-angle-type'), None): cnv_string,
	((DRAWNS,u'caption-escape'), None): cnv_string,
	((DRAWNS,u'caption-escape-direction'), None): cnv_string,
	((DRAWNS,u'caption-fit-line-length'), None): cnv_boolean,
	((DRAWNS,u'caption-gap'), None): cnv_string,
	((DRAWNS,u'caption-line-length'), None): cnv_length,
	((DRAWNS,u'caption-point-x'), None): cnv_string,
	((DRAWNS,u'caption-point-y'), None): cnv_string,
	((DRAWNS,u'caption-id'), None): cnv_IDREF,
	((DRAWNS,u'caption-type'), None): cnv_string,
	((DRAWNS,u'chain-next-name'), None): cnv_string,
	((DRAWNS,u'class-id'), None): cnv_string,
	((DRAWNS,u'class-names'), None): cnv_NCNames,
	((DRAWNS,u'code'), None): cnv_string,
	((DRAWNS,u'color'), None): cnv_string,
	((DRAWNS,u'color-inversion'), None): cnv_boolean,
	((DRAWNS,u'color-mode'), None): cnv_string,
	((DRAWNS,u'concave'), None): cnv_string,
	((DRAWNS,u'concentric-gradient-fill-allowed'), None): cnv_boolean,
	((DRAWNS,u'contrast'), None): cnv_string,
	((DRAWNS,u'control'), None): cnv_IDREF,
	((DRAWNS,u'copy-of'), None): cnv_string,
	((DRAWNS,u'corner-radius'), None): cnv_length,
	((DRAWNS,u'corners'), None): cnv_positiveInteger,
	((DRAWNS,u'cx'), None): cnv_string,
	((DRAWNS,u'cy'), None): cnv_string,
	((DRAWNS,u'data'), None): cnv_string,
	((DRAWNS,u'decimal-places'), None): cnv_string,
	((DRAWNS,u'display'), None): cnv_string,
	((DRAWNS,u'display-name'), None): cnv_string,
	((DRAWNS,u'distance'), None): cnv_lengthorpercent,
	((DRAWNS,u'dots1'), None): cnv_integer,
	((DRAWNS,u'dots1-length'), None): cnv_lengthorpercent,
	((DRAWNS,u'dots2'), None): cnv_integer,
	((DRAWNS,u'dots2-length'), None): cnv_lengthorpercent,
	((DRAWNS,u'end-angle'), None): cnv_double,
	((DRAWNS,u'end'), None): cnv_string,
	((DRAWNS,u'end-color'), None): cnv_string,
	((DRAWNS,u'end-glue-point'), None): cnv_nonNegativeInteger,
	((DRAWNS,u'end-guide'), None): cnv_length,
	((DRAWNS,u'end-intensity'), None): cnv_string,
	((DRAWNS,u'end-line-spacing-horizontal'), None): cnv_string,
	((DRAWNS,u'end-line-spacing-vertical'), None): cnv_string,
	((DRAWNS,u'end-shape'), None): cnv_IDREF,
	((DRAWNS,u'engine'), None): cnv_namespacedToken,
	((DRAWNS,u'enhanced-path'), None): cnv_string,
	((DRAWNS,u'escape-direction'), None): cnv_string,
	((DRAWNS,u'extrusion-allowed'), None): cnv_boolean,
	((DRAWNS,u'extrusion-brightness'), None): cnv_string,
	((DRAWNS,u'extrusion'), None): cnv_boolean,
	((DRAWNS,u'extrusion-color'), None): cnv_boolean,
	((DRAWNS,u'extrusion-depth'), None): cnv_double,
	((DRAWNS,u'extrusion-diffusion'), None): cnv_string,
	((DRAWNS,u'extrusion-first-light-direction'), None): cnv_string,
	((DRAWNS,u'extrusion-first-light-harsh'), None): cnv_boolean,
	((DRAWNS,u'extrusion-first-light-level'), None): cnv_string,
	((DRAWNS,u'extrusion-light-face'), None): cnv_boolean,
	((DRAWNS,u'extrusion-metal'), None): cnv_boolean,
	((DRAWNS,u'extrusion-number-of-line-segments'), None): cnv_integer,
	((DRAWNS,u'extrusion-origin'), None): cnv_double,
	((DRAWNS,u'extrusion-rotation-angle'), None): cnv_double,
	((DRAWNS,u'extrusion-rotation-center'), None): cnv_string,
	((DRAWNS,u'extrusion-second-light-direction'), None): cnv_string,
	((DRAWNS,u'extrusion-second-light-harsh'), None): cnv_boolean,
	((DRAWNS,u'extrusion-second-light-level'), None): cnv_string,
	((DRAWNS,u'extrusion-shininess'), None): cnv_string,
	((DRAWNS,u'extrusion-skew'), None): cnv_double,
	((DRAWNS,u'extrusion-specularity'), None): cnv_string,
	((DRAWNS,u'extrusion-viewpoint'), None): cnv_string,
	((DRAWNS,u'fill'), None): cnv_string,
	((DRAWNS,u'fill-color'), None): cnv_string,
	((DRAWNS,u'fill-gradient-name'), None): cnv_string,
	((DRAWNS,u'fill-hatch-name'), None): cnv_string,
	((DRAWNS,u'fill-hatch-solid'), None): cnv_boolean,
	((DRAWNS,u'fill-image-height'), None): cnv_lengthorpercent,
	((DRAWNS,u'fill-image-name'), None): cnv_DrawNameRef,
	((DRAWNS,u'fill-image-ref-point'), None): cnv_string,
	((DRAWNS,u'fill-image-ref-point-x'), None): cnv_string,
	((DRAWNS,u'fill-image-ref-point-y'), None): cnv_string,
	((DRAWNS,u'fill-image-width'), None): cnv_lengthorpercent,
	((DRAWNS,u'filter-name'), None): cnv_string,
	((DRAWNS,u'fit-to-contour'), None): cnv_boolean,
	((DRAWNS,u'fit-to-size'), None): cnv_boolean,
	((DRAWNS,u'formula'), None): cnv_string,
	((DRAWNS,u'frame-display-border'), None): cnv_boolean,
	((DRAWNS,u'frame-display-scrollbar'), None): cnv_boolean,
	((DRAWNS,u'frame-margin-horizontal'), None): cnv_string,
	((DRAWNS,u'frame-margin-vertical'), None): cnv_string,
	((DRAWNS,u'frame-name'), None): cnv_string,
	((DRAWNS,u'gamma'), None): cnv_string,
	((DRAWNS,u'glue-point-leaving-directions'), None): cnv_string,
	((DRAWNS,u'glue-point-type'), None): cnv_string,
	((DRAWNS,u'glue-points'), None): cnv_string,
	((DRAWNS,u'gradient-step-count'), None): cnv_string,
	((DRAWNS,u'green'), None): cnv_string,
	((DRAWNS,u'guide-distance'), None): cnv_string,
	((DRAWNS,u'guide-overhang'), None): cnv_length,
	((DRAWNS,u'handle-mirror-horizontal'), None): cnv_boolean,
	((DRAWNS,u'handle-mirror-vertical'), None): cnv_boolean,
	((DRAWNS,u'handle-polar'), None): cnv_string,
	((DRAWNS,u'handle-position'), None): cnv_string,
	((DRAWNS,u'handle-radius-range-maximum'), None): cnv_string,
	((DRAWNS,u'handle-radius-range-minimum'), None): cnv_string,
	((DRAWNS,u'handle-range-x-maximum'), None): cnv_string,
	((DRAWNS,u'handle-range-x-minimum'), None): cnv_string,
	((DRAWNS,u'handle-range-y-maximum'), None): cnv_string,
	((DRAWNS,u'handle-range-y-minimum'), None): cnv_string,
	((DRAWNS,u'handle-switched'), None): cnv_boolean,
#	((DRAWNS,u'id'), None): cnv_ID,
#	((DRAWNS,u'id'), None): cnv_nonNegativeInteger,   # ?? line 6581 in RNG
	((DRAWNS,u'id'), None): cnv_string,
	((DRAWNS,u'image-opacity'), None): cnv_string,
	((DRAWNS,u'kind'), None): cnv_string,
	((DRAWNS,u'layer'), None): cnv_string,
	((DRAWNS,u'line-distance'), None): cnv_string,
	((DRAWNS,u'line-skew'), None): cnv_string,
	((DRAWNS,u'luminance'), None): cnv_string,
	((DRAWNS,u'marker-end-center'), None): cnv_boolean,
	((DRAWNS,u'marker-end'), None): cnv_string,
	((DRAWNS,u'marker-end-width'), None): cnv_length,
	((DRAWNS,u'marker-start-center'), None): cnv_boolean,
	((DRAWNS,u'marker-start'), None): cnv_string,
	((DRAWNS,u'marker-start-width'), None): cnv_length,
	((DRAWNS,u'master-page-name'), None): cnv_StyleNameRef,
	((DRAWNS,u'may-script'), None): cnv_boolean,
	((DRAWNS,u'measure-align'), None): cnv_string,
	((DRAWNS,u'measure-vertical-align'), None): cnv_string,
	((DRAWNS,u'mime-type'), None): cnv_string,
	((DRAWNS,u'mirror-horizontal'), None): cnv_boolean,
	((DRAWNS,u'mirror-vertical'), None): cnv_boolean,
	((DRAWNS,u'modifiers'), None): cnv_string,
	((DRAWNS,u'name'), None): cnv_NCName,
#	((DRAWNS,u'name'), None): cnv_string,
	((DRAWNS,u'nav-order'), None): cnv_IDREF,
	((DRAWNS,u'nohref'), None): cnv_string,
	((DRAWNS,u'notify-on-update-of-ranges'), None): cnv_string,
	((DRAWNS,u'object'), None): cnv_string,
	((DRAWNS,u'ole-draw-aspect'), None): cnv_string,
	((DRAWNS,u'opacity'), None): cnv_string,
	((DRAWNS,u'opacity-name'), None): cnv_string,
	((DRAWNS,u'page-number'), None): cnv_positiveInteger,
	((DRAWNS,u'parallel'), None): cnv_boolean,
	((DRAWNS,u'path-stretchpoint-x'), None): cnv_double,
	((DRAWNS,u'path-stretchpoint-y'), None): cnv_double,
	((DRAWNS,u'placing'), None): cnv_string,
	((DRAWNS,u'points'), None): cnv_points,
	((DRAWNS,u'protected'), None): cnv_boolean,
	((DRAWNS,u'recreate-on-edit'), None): cnv_boolean,
	((DRAWNS,u'red'), None): cnv_string,
	((DRAWNS,u'rotation'), None): cnv_integer,
	((DRAWNS,u'secondary-fill-color'), None): cnv_string,
	((DRAWNS,u'shadow'), None): cnv_string,
	((DRAWNS,u'shadow-color'), None): cnv_string,
	((DRAWNS,u'shadow-offset-x'), None): cnv_length,
	((DRAWNS,u'shadow-offset-y'), None): cnv_length,
	((DRAWNS,u'shadow-opacity'), None): cnv_string,
	((DRAWNS,u'shape-id'), None): cnv_IDREF,
	((DRAWNS,u'sharpness'), None): cnv_string,
	((DRAWNS,u'show-unit'), None): cnv_boolean,
	((DRAWNS,u'start-angle'), None): cnv_double,
	((DRAWNS,u'start'), None): cnv_string,
	((DRAWNS,u'start-color'), None): cnv_string,
	((DRAWNS,u'start-glue-point'), None): cnv_nonNegativeInteger,
	((DRAWNS,u'start-guide'), None): cnv_length,
	((DRAWNS,u'start-intensity'), None): cnv_string,
	((DRAWNS,u'start-line-spacing-horizontal'), None): cnv_string,
	((DRAWNS,u'start-line-spacing-vertical'), None): cnv_string,
	((DRAWNS,u'start-shape'), None): cnv_IDREF,
	((DRAWNS,u'stroke'), None): cnv_string,
	((DRAWNS,u'stroke-dash'), None): cnv_string,
	((DRAWNS,u'stroke-dash-names'), None): cnv_string,
	((DRAWNS,u'stroke-linejoin'), None): cnv_string,
	((DRAWNS,u'style'), None): cnv_string,
	((DRAWNS,u'style-name'), None): cnv_StyleNameRef,
	((DRAWNS,u'symbol-color'), None): cnv_string,
	((DRAWNS,u'text-areas'), None): cnv_string,
	((DRAWNS,u'text-path-allowed'), None): cnv_boolean,
	((DRAWNS,u'text-path'), None): cnv_boolean,
	((DRAWNS,u'text-path-mode'), None): cnv_string,
	((DRAWNS,u'text-path-same-letter-heights'), None): cnv_boolean,
	((DRAWNS,u'text-path-scale'), None): cnv_string,
	((DRAWNS,u'text-rotate-angle'), None): cnv_double,
	((DRAWNS,u'text-style-name'), None): cnv_StyleNameRef,
	((DRAWNS,u'textarea-horizontal-align'), None): cnv_string,
	((DRAWNS,u'textarea-vertical-align'), None): cnv_string,
	((DRAWNS,u'tile-repeat-offset'), None): cnv_string,
	((DRAWNS,u'transform'), None): cnv_string,
	((DRAWNS,u'type'), None): cnv_string,
	((DRAWNS,u'unit'), None): cnv_string,
	((DRAWNS,u'value'), None): cnv_string,
	((DRAWNS,u'visible-area-height'), None): cnv_string,
	((DRAWNS,u'visible-area-left'), None): cnv_string,
	((DRAWNS,u'visible-area-top'), None): cnv_string,
	((DRAWNS,u'visible-area-width'), None): cnv_string,
	((DRAWNS,u'wrap-influence-on-position'), None): cnv_string,
	((DRAWNS,u'z-index'), None): cnv_nonNegativeInteger,
	((FONS,u'background-color'), None): cnv_string,
	((FONS,u'border-bottom'), None): cnv_string,
	((FONS,u'border'), None): cnv_string,
	((FONS,u'border-left'), None): cnv_string,
	((FONS,u'border-right'), None): cnv_string,
	((FONS,u'border-top'), None): cnv_string,
	((FONS,u'break-after'), None): cnv_string,
	((FONS,u'break-before'), None): cnv_string,
	((FONS,u'clip'), None): cnv_string,
	((FONS,u'color'), None): cnv_string,
	((FONS,u'column-count'), None): cnv_positiveInteger,
	((FONS,u'column-gap'), None): cnv_length,
	((FONS,u'country'), None): cnv_token,
	((FONS,u'end-indent'), None): cnv_length,
	((FONS,u'font-family'), None): cnv_string,
	((FONS,u'font-size'), None): cnv_string,
	((FONS,u'font-style'), None): cnv_string,
	((FONS,u'font-variant'), None): cnv_string,
	((FONS,u'font-weight'), None): cnv_string,
	((FONS,u'height'), None): cnv_string,
	((FONS,u'hyphenate'), None): cnv_boolean,
	((FONS,u'hyphenation-keep'), None): cnv_string,
	((FONS,u'hyphenation-ladder-count'), None): cnv_string,
	((FONS,u'hyphenation-push-char-count'), None): cnv_string,
	((FONS,u'hyphenation-remain-char-count'), None): cnv_string,
	((FONS,u'keep-together'), None): cnv_string,
	((FONS,u'keep-with-next'), None): cnv_string,
	((FONS,u'language'), None): cnv_token,
	((FONS,u'letter-spacing'), None): cnv_string,
	((FONS,u'line-height'), None): cnv_string,
	((FONS,u'margin-bottom'), None): cnv_string,
	((FONS,u'margin'), None): cnv_string,
	((FONS,u'margin-left'), None): cnv_string,
	((FONS,u'margin-right'), None): cnv_string,
	((FONS,u'margin-top'), None): cnv_string,
	((FONS,u'max-height'), None): cnv_string,
	((FONS,u'max-width'), None): cnv_string,
	((FONS,u'min-height'), None): cnv_length,
	((FONS,u'min-width'), None): cnv_string,
	((FONS,u'orphans'), None): cnv_string,
	((FONS,u'padding-bottom'), None): cnv_string,
	((FONS,u'padding'), None): cnv_string,
	((FONS,u'padding-left'), None): cnv_string,
	((FONS,u'padding-right'), None): cnv_string,
	((FONS,u'padding-top'), None): cnv_string,
	((FONS,u'page-height'), None): cnv_length,
	((FONS,u'page-width'), None): cnv_length,
	((FONS,u'space-after'), None): cnv_length,
	((FONS,u'space-before'), None): cnv_length,
	((FONS,u'start-indent'), None): cnv_length,
	((FONS,u'text-align'), None): cnv_string,
	((FONS,u'text-align-last'), None): cnv_string,
	((FONS,u'text-indent'), None): cnv_string,
	((FONS,u'text-shadow'), None): cnv_string,
	((FONS,u'text-transform'), None): cnv_string,
	((FONS,u'widows'), None): cnv_string,
	((FONS,u'width'), None): cnv_string,
	((FONS,u'wrap-option'), None): cnv_string,
	((FORMNS,u'allow-deletes'), None): cnv_boolean,
	((FORMNS,u'allow-inserts'), None): cnv_boolean,
	((FORMNS,u'allow-updates'), None): cnv_boolean,
	((FORMNS,u'apply-design-mode'), None): cnv_boolean,
	((FORMNS,u'apply-filter'), None): cnv_boolean,
	((FORMNS,u'auto-complete'), None): cnv_boolean,
	((FORMNS,u'automatic-focus'), None): cnv_boolean,
	((FORMNS,u'bound-column'), None): cnv_string,
	((FORMNS,u'button-type'), None): cnv_string,
	((FORMNS,u'command'), None): cnv_string,
	((FORMNS,u'command-type'), None): cnv_string,
	((FORMNS,u'control-implementation'), None): cnv_namespacedToken,
	((FORMNS,u'convert-empty-to-null'), None): cnv_boolean,
	((FORMNS,u'current-selected'), None): cnv_boolean,
	((FORMNS,u'current-state'), None): cnv_string,
#	((FORMNS,u'current-value'), None): cnv_date,
#	((FORMNS,u'current-value'), None): cnv_double,
	((FORMNS,u'current-value'), None): cnv_string,
#	((FORMNS,u'current-value'), None): cnv_time,
	((FORMNS,u'data-field'), None): cnv_string,
	((FORMNS,u'datasource'), None): cnv_string,
	((FORMNS,u'default-button'), None): cnv_boolean,
	((FORMNS,u'delay-for-repeat'), None): cnv_duration,
	((FORMNS,u'detail-fields'), None): cnv_string,
	((FORMNS,u'disabled'), None): cnv_boolean,
	((FORMNS,u'dropdown'), None): cnv_boolean,
	((FORMNS,u'echo-char'), None): cnv_string,
	((FORMNS,u'enctype'), None): cnv_string,
	((FORMNS,u'escape-processing'), None): cnv_boolean,
	((FORMNS,u'filter'), None): cnv_string,
	((FORMNS,u'focus-on-click'), None): cnv_boolean,
	((FORMNS,u'for'), None): cnv_string,
	((FORMNS,u'id'), None): cnv_ID,
	((FORMNS,u'ignore-result'), None): cnv_boolean,
	((FORMNS,u'image-align'), None): cnv_string,
	((FORMNS,u'image-data'), None): cnv_anyURI,
	((FORMNS,u'image-position'), None): cnv_string,
	((FORMNS,u'is-tristate'), None): cnv_boolean,
	((FORMNS,u'label'), None): cnv_string,
	((FORMNS,u'list-source'), None): cnv_string,
	((FORMNS,u'list-source-type'), None): cnv_string,
	((FORMNS,u'master-fields'), None): cnv_string,
	((FORMNS,u'max-length'), None): cnv_nonNegativeInteger,
#	((FORMNS,u'max-value'), None): cnv_date,
#	((FORMNS,u'max-value'), None): cnv_double,
	((FORMNS,u'max-value'), None): cnv_string,
#	((FORMNS,u'max-value'), None): cnv_time,
	((FORMNS,u'method'), None): cnv_string,
#	((FORMNS,u'min-value'), None): cnv_date,
#	((FORMNS,u'min-value'), None): cnv_double,
	((FORMNS,u'min-value'), None): cnv_string,
#	((FORMNS,u'min-value'), None): cnv_time,
	((FORMNS,u'multi-line'), None): cnv_boolean,
	((FORMNS,u'multiple'), None): cnv_boolean,
	((FORMNS,u'name'), None): cnv_string,
	((FORMNS,u'navigation-mode'), None): cnv_string,
	((FORMNS,u'order'), None): cnv_string,
	((FORMNS,u'orientation'), None): cnv_string,
	((FORMNS,u'page-step-size'), None): cnv_positiveInteger,
	((FORMNS,u'printable'), None): cnv_boolean,
	((FORMNS,u'property-name'), None): cnv_string,
	((FORMNS,u'readonly'), None): cnv_boolean,
	((FORMNS,u'selected'), None): cnv_boolean,
	((FORMNS,u'size'), None): cnv_nonNegativeInteger,
	((FORMNS,u'state'), None): cnv_string,
	((FORMNS,u'step-size'), None): cnv_positiveInteger,
	((FORMNS,u'tab-cycle'), None): cnv_string,
	((FORMNS,u'tab-index'), None): cnv_nonNegativeInteger,
	((FORMNS,u'tab-stop'), None): cnv_boolean,
	((FORMNS,u'text-style-name'), None): cnv_StyleNameRef,
	((FORMNS,u'title'), None): cnv_string,
	((FORMNS,u'toggle'), None): cnv_boolean,
	((FORMNS,u'validation'), None): cnv_boolean,
#	((FORMNS,u'value'), None): cnv_date,
#	((FORMNS,u'value'), None): cnv_double,
	((FORMNS,u'value'), None): cnv_string,
#	((FORMNS,u'value'), None): cnv_time,
	((FORMNS,u'visual-effect'), None): cnv_string,
	((FORMNS,u'xforms-list-source'), None): cnv_string,
	((FORMNS,u'xforms-submission'), None): cnv_string,
	((MANIFESTNS,'algorithm-name'), None): cnv_string,
	((MANIFESTNS,'checksum'), None): cnv_string,
	((MANIFESTNS,'checksum-type'), None): cnv_string,
	((MANIFESTNS,'full-path'), None): cnv_string,
	((MANIFESTNS,'initialisation-vector'), None): cnv_string,
	((MANIFESTNS,'iteration-count'), None): cnv_nonNegativeInteger,
	((MANIFESTNS,'key-derivation-name'), None): cnv_string,
	((MANIFESTNS,'media-type'), None): cnv_string,
	((MANIFESTNS,'salt'), None): cnv_string,
	((MANIFESTNS,'size'), None): cnv_nonNegativeInteger,
	((METANS,u'cell-count'), None): cnv_nonNegativeInteger,
	((METANS,u'character-count'), None): cnv_nonNegativeInteger,
	((METANS,u'date'), None): cnv_dateTime,
	((METANS,u'delay'), None): cnv_duration,
	((METANS,u'draw-count'), None): cnv_nonNegativeInteger,
	((METANS,u'frame-count'), None): cnv_nonNegativeInteger,
	((METANS,u'image-count'), None): cnv_nonNegativeInteger,
	((METANS,u'name'), None): cnv_string,
	((METANS,u'non-whitespace-character-count'), None): cnv_nonNegativeInteger,
	((METANS,u'object-count'), None): cnv_nonNegativeInteger,
	((METANS,u'ole-object-count'), None): cnv_nonNegativeInteger,
	((METANS,u'page-count'), None): cnv_nonNegativeInteger,
	((METANS,u'paragraph-count'), None): cnv_nonNegativeInteger,
	((METANS,u'row-count'), None): cnv_nonNegativeInteger,
	((METANS,u'sentence-count'), None): cnv_nonNegativeInteger,
	((METANS,u'syllable-count'), None): cnv_nonNegativeInteger,
	((METANS,u'table-count'), None): cnv_nonNegativeInteger,
	((METANS,u'value-type'), None): cnv_metavaluetype,
	((METANS,u'word-count'), None): cnv_nonNegativeInteger,
	((NUMBERNS,u'automatic-order'), None): cnv_boolean,
	((NUMBERNS,u'calendar'), None): cnv_string,
	((NUMBERNS,u'country'), None): cnv_token,
	((NUMBERNS,u'decimal-places'), None): cnv_integer,
	((NUMBERNS,u'decimal-replacement'), None): cnv_string,
	((NUMBERNS,u'denominator-value'), None): cnv_integer,
	((NUMBERNS,u'display-factor'), None): cnv_double,
	((NUMBERNS,u'format-source'), None): cnv_string,
	((NUMBERNS,u'grouping'), None): cnv_boolean,
	((NUMBERNS,u'language'), None): cnv_token,
	((NUMBERNS,u'min-denominator-digits'), None): cnv_integer,
	((NUMBERNS,u'min-exponent-digits'), None): cnv_integer,
	((NUMBERNS,u'min-integer-digits'), None): cnv_integer,
	((NUMBERNS,u'min-numerator-digits'), None): cnv_integer,
	((NUMBERNS,u'position'), None): cnv_integer,
	((NUMBERNS,u'possessive-form'), None): cnv_boolean,
	((NUMBERNS,u'style'), None): cnv_string,
	((NUMBERNS,u'textual'), None): cnv_boolean,
	((NUMBERNS,u'title'), None): cnv_string,
	((NUMBERNS,u'transliteration-country'), None): cnv_token,
	((NUMBERNS,u'transliteration-format'), None): cnv_string,
	((NUMBERNS,u'transliteration-language'), None): cnv_token,
	((NUMBERNS,u'transliteration-style'), None): cnv_string,
	((NUMBERNS,u'truncate-on-overflow'), None): cnv_boolean,
	((OFFICENS,u'automatic-update'), None): cnv_boolean,
	((OFFICENS,u'boolean-value'), None): cnv_boolean,
	((OFFICENS,u'conversion-mode'), None): cnv_string,
	((OFFICENS,u'currency'), None): cnv_string,
	((OFFICENS,u'date-value'), None): cnv_dateTime,
	((OFFICENS,u'dde-application'), None): cnv_string,
	((OFFICENS,u'dde-item'), None): cnv_string,
	((OFFICENS,u'dde-topic'), None): cnv_string,
	((OFFICENS,u'display'), None): cnv_boolean,
	((OFFICENS,u'mimetype'), None): cnv_string,
	((OFFICENS,u'name'), None): cnv_string,
	((OFFICENS,u'process-content'), None): cnv_boolean,
	((OFFICENS,u'server-map'), None): cnv_boolean,
	((OFFICENS,u'string-value'), None): cnv_string,
	((OFFICENS,u'target-frame'), None): cnv_string,
	((OFFICENS,u'target-frame-name'), None): cnv_string,
	((OFFICENS,u'time-value'), None): cnv_duration,
	((OFFICENS,u'title'), None): cnv_string,
	((OFFICENS,u'value'), None): cnv_double,
	((OFFICENS,u'value-type'), None): cnv_string,
	((OFFICENS,u'version'), None): cnv_string,
	((PRESENTATIONNS,u'action'), None): cnv_string,
	((PRESENTATIONNS,u'animations'), None): cnv_string,
	((PRESENTATIONNS,u'background-objects-visible'), None): cnv_boolean,
	((PRESENTATIONNS,u'background-visible'), None): cnv_boolean,
	((PRESENTATIONNS,u'class'), None): cnv_string,
	((PRESENTATIONNS,u'class-names'), None): cnv_NCNames,
	((PRESENTATIONNS,u'delay'), None): cnv_duration,
	((PRESENTATIONNS,u'direction'), None): cnv_string,
	((PRESENTATIONNS,u'display-date-time'), None): cnv_boolean,
	((PRESENTATIONNS,u'display-footer'), None): cnv_boolean,
	((PRESENTATIONNS,u'display-header'), None): cnv_boolean,
	((PRESENTATIONNS,u'display-page-number'), None): cnv_boolean,
	((PRESENTATIONNS,u'duration'), None): cnv_string,
	((PRESENTATIONNS,u'effect'), None): cnv_string,
	((PRESENTATIONNS,u'endless'), None): cnv_boolean,
	((PRESENTATIONNS,u'force-manual'), None): cnv_boolean,
	((PRESENTATIONNS,u'full-screen'), None): cnv_boolean,
	((PRESENTATIONNS,u'group-id'), None): cnv_string,
	((PRESENTATIONNS,u'master-element'), None): cnv_IDREF,
	((PRESENTATIONNS,u'mouse-as-pen'), None): cnv_boolean,
	((PRESENTATIONNS,u'mouse-visible'), None): cnv_boolean,
	((PRESENTATIONNS,u'name'), None): cnv_string,
	((PRESENTATIONNS,u'node-type'), None): cnv_string,
	((PRESENTATIONNS,u'object'), None): cnv_string,
	((PRESENTATIONNS,u'pages'), None): cnv_string,
	((PRESENTATIONNS,u'path-id'), None): cnv_string,
	((PRESENTATIONNS,u'pause'), None): cnv_duration,
	((PRESENTATIONNS,u'placeholder'), None): cnv_boolean,
	((PRESENTATIONNS,u'play-full'), None): cnv_boolean,
	((PRESENTATIONNS,u'presentation-page-layout-name'), None): cnv_StyleNameRef,
	((PRESENTATIONNS,u'preset-class'), None): cnv_string,
	((PRESENTATIONNS,u'preset-id'), None): cnv_string,
	((PRESENTATIONNS,u'preset-sub-type'), None): cnv_string,
	((PRESENTATIONNS,u'show'), None): cnv_string,
	((PRESENTATIONNS,u'show-end-of-presentation-slide'), None): cnv_boolean,
	((PRESENTATIONNS,u'show-logo'), None): cnv_boolean,
	((PRESENTATIONNS,u'source'), None): cnv_string,
	((PRESENTATIONNS,u'speed'), None): cnv_string,
	((PRESENTATIONNS,u'start-page'), None): cnv_string,
	((PRESENTATIONNS,u'start-scale'), None): cnv_string,
	((PRESENTATIONNS,u'start-with-navigator'), None): cnv_boolean,
	((PRESENTATIONNS,u'stay-on-top'), None): cnv_boolean,
	((PRESENTATIONNS,u'style-name'), None): cnv_StyleNameRef,
	((PRESENTATIONNS,u'transition-on-click'), None): cnv_string,
	((PRESENTATIONNS,u'transition-speed'), None): cnv_string,
	((PRESENTATIONNS,u'transition-style'), None): cnv_string,
	((PRESENTATIONNS,u'transition-type'), None): cnv_string,
	((PRESENTATIONNS,u'use-date-time-name'), None): cnv_string,
	((PRESENTATIONNS,u'use-footer-name'), None): cnv_string,
	((PRESENTATIONNS,u'use-header-name'), None): cnv_string,
	((PRESENTATIONNS,u'user-transformed'), None): cnv_boolean,
	((PRESENTATIONNS,u'verb'), None): cnv_nonNegativeInteger,
	((PRESENTATIONNS,u'visibility'), None): cnv_string,
	((SCRIPTNS,u'event-name'), None): cnv_formula,
	((SCRIPTNS,u'language'), None): cnv_formula,
	((SCRIPTNS,u'macro-name'), None): cnv_string,
	((SMILNS,u'accelerate'), None): cnv_double,
	((SMILNS,u'accumulate'), None): cnv_string,
	((SMILNS,u'additive'), None): cnv_string,
	((SMILNS,u'attributeName'), None): cnv_string,
	((SMILNS,u'autoReverse'), None): cnv_boolean,
	((SMILNS,u'begin'), None): cnv_string,
	((SMILNS,u'by'), None): cnv_string,
	((SMILNS,u'calcMode'), None): cnv_string,
	((SMILNS,u'decelerate'), None): cnv_double,
	((SMILNS,u'direction'), None): cnv_string,
	((SMILNS,u'dur'), None): cnv_string,
	((SMILNS,u'end'), None): cnv_string,
	((SMILNS,u'endsync'), None): cnv_string,
	((SMILNS,u'fadeColor'), None): cnv_string,
	((SMILNS,u'fill'), None): cnv_string,
	((SMILNS,u'fillDefault'), None): cnv_string,
	((SMILNS,u'from'), None): cnv_string,
	((SMILNS,u'keySplines'), None): cnv_string,
	((SMILNS,u'keyTimes'), None): cnv_string,
	((SMILNS,u'mode'), None): cnv_string,
	((SMILNS,u'repeatCount'), None): cnv_nonNegativeInteger,
	((SMILNS,u'repeatDur'), None): cnv_string,
	((SMILNS,u'restart'), None): cnv_string,
	((SMILNS,u'restartDefault'), None): cnv_string,
	((SMILNS,u'subtype'), None): cnv_string,
	((SMILNS,u'targetElement'), None): cnv_IDREF,
	((SMILNS,u'to'), None): cnv_string,
	((SMILNS,u'type'), None): cnv_string,
	((SMILNS,u'values'), None): cnv_string,
	((STYLENS,u'adjustment'), None): cnv_string,
	((STYLENS,u'apply-style-name'), None): cnv_StyleNameRef,
	((STYLENS,u'auto-text-indent'), None): cnv_boolean,
	((STYLENS,u'auto-update'), None): cnv_boolean,
	((STYLENS,u'background-transparency'), None): cnv_string,
	((STYLENS,u'base-cell-address'), None): cnv_string,
	((STYLENS,u'border-line-width-bottom'), None): cnv_string,
	((STYLENS,u'border-line-width'), None): cnv_string,
	((STYLENS,u'border-line-width-left'), None): cnv_string,
	((STYLENS,u'border-line-width-right'), None): cnv_string,
	((STYLENS,u'border-line-width-top'), None): cnv_string,
	((STYLENS,u'cell-protect'), None): cnv_string,
	((STYLENS,u'char'), None): cnv_string,
	((STYLENS,u'class'), None): cnv_string,
	((STYLENS,u'color'), None): cnv_string,
	((STYLENS,u'column-width'), None): cnv_string,
	((STYLENS,u'condition'), None): cnv_string,
	((STYLENS,u'country-asian'), None): cnv_string,
	((STYLENS,u'country-complex'), None): cnv_string,
	((STYLENS,u'data-style-name'), None): cnv_StyleNameRef,
	((STYLENS,u'decimal-places'), None): cnv_string,
	((STYLENS,u'default-outline-level'), None): cnv_positiveInteger,
	((STYLENS,u'diagonal-bl-tr'), None): cnv_string,
	((STYLENS,u'diagonal-bl-tr-widths'), None): cnv_string,
	((STYLENS,u'diagonal-tl-br'), None): cnv_string,
	((STYLENS,u'diagonal-tl-br-widths'), None): cnv_string,
	((STYLENS,u'direction'), None): cnv_string,
	((STYLENS,u'display'), None): cnv_boolean,
	((STYLENS,u'display-name'), None): cnv_string,
	((STYLENS,u'distance-after-sep'), None): cnv_length,
	((STYLENS,u'distance-before-sep'), None): cnv_length,
	((STYLENS,u'distance'), None): cnv_length,
	((STYLENS,u'dynamic-spacing'), None): cnv_boolean,
	((STYLENS,u'editable'), None): cnv_boolean,
	((STYLENS,u'family'), None): cnv_family,
	((STYLENS,u'filter-name'), None): cnv_string,
	((STYLENS,u'first-page-number'), None): cnv_string,
	((STYLENS,u'flow-with-text'), None): cnv_boolean,
	((STYLENS,u'font-adornments'), None): cnv_string,
	((STYLENS,u'font-charset'), None): cnv_string,
	((STYLENS,u'font-charset-asian'), None): cnv_string,
	((STYLENS,u'font-charset-complex'), None): cnv_string,
	((STYLENS,u'font-family-asian'), None): cnv_string,
	((STYLENS,u'font-family-complex'), None): cnv_string,
	((STYLENS,u'font-family-generic-asian'), None): cnv_string,
	((STYLENS,u'font-family-generic'), None): cnv_string,
	((STYLENS,u'font-family-generic-complex'), None): cnv_string,
	((STYLENS,u'font-independent-line-spacing'), None): cnv_boolean,
	((STYLENS,u'font-name-asian'), None): cnv_string,
	((STYLENS,u'font-name'), None): cnv_string,
	((STYLENS,u'font-name-complex'), None): cnv_string,
	((STYLENS,u'font-pitch-asian'), None): cnv_string,
	((STYLENS,u'font-pitch'), None): cnv_string,
	((STYLENS,u'font-pitch-complex'), None): cnv_string,
	((STYLENS,u'font-relief'), None): cnv_string,
	((STYLENS,u'font-size-asian'), None): cnv_string,
	((STYLENS,u'font-size-complex'), None): cnv_string,
	((STYLENS,u'font-size-rel-asian'), None): cnv_length,
	((STYLENS,u'font-size-rel'), None): cnv_length,
	((STYLENS,u'font-size-rel-complex'), None): cnv_length,
	((STYLENS,u'font-style-asian'), None): cnv_string,
	((STYLENS,u'font-style-complex'), None): cnv_string,
	((STYLENS,u'font-style-name-asian'), None): cnv_string,
	((STYLENS,u'font-style-name'), None): cnv_string,
	((STYLENS,u'font-style-name-complex'), None): cnv_string,
	((STYLENS,u'font-weight-asian'), None): cnv_string,
	((STYLENS,u'font-weight-complex'), None): cnv_string,
	((STYLENS,u'footnote-max-height'), None): cnv_length,
	((STYLENS,u'glyph-orientation-vertical'), None): cnv_string,
	((STYLENS,u'height'), None): cnv_string,
	((STYLENS,u'horizontal-pos'), None): cnv_string,
	((STYLENS,u'horizontal-rel'), None): cnv_string,
	((STYLENS,u'justify-single-word'), None): cnv_boolean,
	((STYLENS,u'language-asian'), None): cnv_string,
	((STYLENS,u'language-complex'), None): cnv_string,
	((STYLENS,u'layout-grid-base-height'), None): cnv_length,
	((STYLENS,u'layout-grid-color'), None): cnv_string,
	((STYLENS,u'layout-grid-display'), None): cnv_boolean,
	((STYLENS,u'layout-grid-lines'), None): cnv_string,
	((STYLENS,u'layout-grid-mode'), None): cnv_string,
	((STYLENS,u'layout-grid-print'), None): cnv_boolean,
	((STYLENS,u'layout-grid-ruby-below'), None): cnv_boolean,
	((STYLENS,u'layout-grid-ruby-height'), None): cnv_length,
	((STYLENS,u'leader-char'), None): cnv_string,
	((STYLENS,u'leader-color'), None): cnv_string,
	((STYLENS,u'leader-style'), None): cnv_string,
	((STYLENS,u'leader-text'), None): cnv_string,
	((STYLENS,u'leader-text-style'), None): cnv_StyleNameRef,
	((STYLENS,u'leader-type'), None): cnv_string,
	((STYLENS,u'leader-width'), None): cnv_string,
	((STYLENS,u'legend-expansion-aspect-ratio'), None): cnv_double,
	((STYLENS,u'legend-expansion'), None): cnv_string,
	((STYLENS,u'length'), None): cnv_positiveInteger,
	((STYLENS,u'letter-kerning'), None): cnv_boolean,
	((STYLENS,u'line-break'), None): cnv_string,
	((STYLENS,u'line-height-at-least'), None): cnv_string,
	((STYLENS,u'line-spacing'), None): cnv_length,
	((STYLENS,u'line-style'), None): cnv_string,
	((STYLENS,u'lines'), None): cnv_positiveInteger,
	((STYLENS,u'list-style-name'), None): cnv_StyleNameRef,
	((STYLENS,u'master-page-name'), None): cnv_StyleNameRef,
	((STYLENS,u'may-break-between-rows'), None): cnv_boolean,
	((STYLENS,u'min-row-height'), None): cnv_string,
	((STYLENS,u'mirror'), None): cnv_string,
	((STYLENS,u'name'), None): cnv_NCName,
 	((STYLENS,u'name'), (STYLENS,u'font-face')): cnv_string,
	((STYLENS,u'next-style-name'), None): cnv_StyleNameRef,
	((STYLENS,u'num-format'), None): cnv_string,
	((STYLENS,u'num-letter-sync'), None): cnv_boolean,
	((STYLENS,u'num-prefix'), None): cnv_string,
	((STYLENS,u'num-suffix'), None): cnv_string,
	((STYLENS,u'number-wrapped-paragraphs'), None): cnv_string,
	((STYLENS,u'overflow-behavior'), None): cnv_string,
	((STYLENS,u'page-layout-name'), None): cnv_StyleNameRef,
	((STYLENS,u'page-number'), None): cnv_string,
	((STYLENS,u'page-usage'), None): cnv_string,
	((STYLENS,u'paper-tray-name'), None): cnv_string,
	((STYLENS,u'parent-style-name'), None): cnv_StyleNameRef,
	((STYLENS,u'position'), (STYLENS,u'tab-stop')): cnv_length,
	((STYLENS,u'position'), None): cnv_string,
	((STYLENS,u'print'), None): cnv_string,
	((STYLENS,u'print-content'), None): cnv_boolean,
	((STYLENS,u'print-orientation'), None): cnv_string,
	((STYLENS,u'print-page-order'), None): cnv_string,
	((STYLENS,u'protect'), None): cnv_boolean,
	((STYLENS,u'punctuation-wrap'), None): cnv_string,
	((STYLENS,u'register-true'), None): cnv_boolean,
	((STYLENS,u'register-truth-ref-style-name'), None): cnv_string,
	((STYLENS,u'rel-column-width'), None): cnv_string,
	((STYLENS,u'rel-height'), None): cnv_string,
	((STYLENS,u'rel-width'), None): cnv_string,
	((STYLENS,u'repeat'), None): cnv_string,
	((STYLENS,u'repeat-content'), None): cnv_boolean,
	((STYLENS,u'rotation-align'), None): cnv_string,
	((STYLENS,u'rotation-angle'), None): cnv_string,
	((STYLENS,u'row-height'), None): cnv_string,
	((STYLENS,u'ruby-align'), None): cnv_string,
	((STYLENS,u'ruby-position'), None): cnv_string,
	((STYLENS,u'run-through'), None): cnv_string,
	((STYLENS,u'scale-to'), None): cnv_string,
	((STYLENS,u'scale-to-pages'), None): cnv_string,
	((STYLENS,u'script-type'), None): cnv_string,
	((STYLENS,u'shadow'), None): cnv_string,
	((STYLENS,u'shrink-to-fit'), None): cnv_boolean,
	((STYLENS,u'snap-to-layout-grid'), None): cnv_boolean,
	((STYLENS,u'style'), None): cnv_string,
	((STYLENS,u'style-name'), None): cnv_StyleNameRef,
	((STYLENS,u'tab-stop-distance'), None): cnv_string,
	((STYLENS,u'table-centering'), None): cnv_string,
	((STYLENS,u'text-align-source'), None): cnv_string,
	((STYLENS,u'text-autospace'), None): cnv_string,
	((STYLENS,u'text-blinking'), None): cnv_boolean,
	((STYLENS,u'text-combine'), None): cnv_string,
	((STYLENS,u'text-combine-end-char'), None): cnv_string,
	((STYLENS,u'text-combine-start-char'), None): cnv_string,
	((STYLENS,u'text-emphasize'), None): cnv_string,
	((STYLENS,u'text-line-through-color'), None): cnv_string,
	((STYLENS,u'text-line-through-mode'), None): cnv_string,
	((STYLENS,u'text-line-through-style'), None): cnv_string,
	((STYLENS,u'text-line-through-text'), None): cnv_string,
	((STYLENS,u'text-line-through-text-style'), None): cnv_string,
	((STYLENS,u'text-line-through-type'), None): cnv_string,
	((STYLENS,u'text-line-through-width'), None): cnv_string,
	((STYLENS,u'text-outline'), None): cnv_boolean,
	((STYLENS,u'text-position'), None): cnv_string,
	((STYLENS,u'text-rotation-angle'), None): cnv_string,
	((STYLENS,u'text-rotation-scale'), None): cnv_string,
	((STYLENS,u'text-scale'), None): cnv_string,
	((STYLENS,u'text-underline-color'), None): cnv_string,
	((STYLENS,u'text-underline-mode'), None): cnv_string,
	((STYLENS,u'text-underline-style'), None): cnv_string,
	((STYLENS,u'text-underline-type'), None): cnv_string,
	((STYLENS,u'text-underline-width'), None): cnv_string,
	((STYLENS,u'type'), None): cnv_string,
	((STYLENS,u'use-optimal-column-width'), None): cnv_boolean,
	((STYLENS,u'use-optimal-row-height'), None): cnv_boolean,
	((STYLENS,u'use-window-font-color'), None): cnv_boolean,
	((STYLENS,u'vertical-align'), None): cnv_string,
	((STYLENS,u'vertical-pos'), None): cnv_string,
	((STYLENS,u'vertical-rel'), None): cnv_string,
	((STYLENS,u'volatile'), None): cnv_boolean,
	((STYLENS,u'width'), None): cnv_string,
	((STYLENS,u'wrap'), None): cnv_string,
	((STYLENS,u'wrap-contour'), None): cnv_boolean,
	((STYLENS,u'wrap-contour-mode'), None): cnv_string,
	((STYLENS,u'wrap-dynamic-threshold'), None): cnv_length,
	((STYLENS,u'writing-mode-automatic'), None): cnv_boolean,
	((STYLENS,u'writing-mode'), None): cnv_string,
	((SVGNS,u'accent-height'), None): cnv_integer,
	((SVGNS,u'alphabetic'), None): cnv_integer,
	((SVGNS,u'ascent'), None): cnv_integer,
	((SVGNS,u'bbox'), None): cnv_string,
	((SVGNS,u'cap-height'), None): cnv_integer,
	((SVGNS,u'cx'), None): cnv_string,
	((SVGNS,u'cy'), None): cnv_string,
	((SVGNS,u'd'), None): cnv_string,
	((SVGNS,u'descent'), None): cnv_integer,
	((SVGNS,u'fill-rule'), None): cnv_string,
	((SVGNS,u'font-family'), None): cnv_string,
	((SVGNS,u'font-size'), None): cnv_string,
	((SVGNS,u'font-stretch'), None): cnv_string,
	((SVGNS,u'font-style'), None): cnv_string,
	((SVGNS,u'font-variant'), None): cnv_string,
	((SVGNS,u'font-weight'), None): cnv_string,
	((SVGNS,u'fx'), None): cnv_string,
	((SVGNS,u'fy'), None): cnv_string,
	((SVGNS,u'gradientTransform'), None): cnv_string,
	((SVGNS,u'gradientUnits'), None): cnv_string,
	((SVGNS,u'hanging'), None): cnv_integer,
	((SVGNS,u'height'), None): cnv_length,
	((SVGNS,u'ideographic'), None): cnv_integer,
	((SVGNS,u'mathematical'), None): cnv_integer,
	((SVGNS,u'name'), None): cnv_string,
	((SVGNS,u'offset'), None): cnv_string,
	((SVGNS,u'origin'), None): cnv_string,
	((SVGNS,u'overline-position'), None): cnv_integer,
	((SVGNS,u'overline-thickness'), None): cnv_integer,
	((SVGNS,u'panose-1'), None): cnv_string,
	((SVGNS,u'path'), None): cnv_string,
	((SVGNS,u'r'), None): cnv_length,
	((SVGNS,u'rx'), None): cnv_length,
	((SVGNS,u'ry'), None): cnv_length,
	((SVGNS,u'slope'), None): cnv_integer,
	((SVGNS,u'spreadMethod'), None): cnv_string,
	((SVGNS,u'stemh'), None): cnv_integer,
	((SVGNS,u'stemv'), None): cnv_integer,
	((SVGNS,u'stop-color'), None): cnv_string,
	((SVGNS,u'stop-opacity'), None): cnv_double,
	((SVGNS,u'strikethrough-position'), None): cnv_integer,
	((SVGNS,u'strikethrough-thickness'), None): cnv_integer,
	((SVGNS,u'string'), None): cnv_string,
	((SVGNS,u'stroke-color'), None): cnv_string,
	((SVGNS,u'stroke-opacity'), None): cnv_string,
	((SVGNS,u'stroke-width'), None): cnv_length,
	((SVGNS,u'type'), None): cnv_string,
	((SVGNS,u'underline-position'), None): cnv_integer,
	((SVGNS,u'underline-thickness'), None): cnv_integer,
	((SVGNS,u'unicode-range'), None): cnv_string,
	((SVGNS,u'units-per-em'), None): cnv_integer,
	((SVGNS,u'v-alphabetic'), None): cnv_integer,
	((SVGNS,u'v-hanging'), None): cnv_integer,
	((SVGNS,u'v-ideographic'), None): cnv_integer,
	((SVGNS,u'v-mathematical'), None): cnv_integer,
	((SVGNS,u'viewBox'), None): cnv_viewbox,
	((SVGNS,u'width'), None): cnv_length,
	((SVGNS,u'widths'), None): cnv_string,
	((SVGNS,u'x'), None): cnv_length,
	((SVGNS,u'x-height'), None): cnv_integer,
	((SVGNS,u'x1'), None): cnv_lengthorpercent,
	((SVGNS,u'x2'), None): cnv_lengthorpercent,
	((SVGNS,u'y'), None): cnv_length,
	((SVGNS,u'y1'), None): cnv_lengthorpercent,
	((SVGNS,u'y2'), None): cnv_lengthorpercent,
	((TABLENS,u'acceptance-state'), None): cnv_string,
	((TABLENS,u'add-empty-lines'), None): cnv_boolean,
	((TABLENS,u'algorithm'), None): cnv_formula,
	((TABLENS,u'align'), None): cnv_string,
	((TABLENS,u'allow-empty-cell'), None): cnv_boolean,
	((TABLENS,u'application-data'), None): cnv_string,
	((TABLENS,u'automatic-find-labels'), None): cnv_boolean,
	((TABLENS,u'base-cell-address'), None): cnv_string,
	((TABLENS,u'bind-styles-to-content'), None): cnv_boolean,
	((TABLENS,u'border-color'), None): cnv_string,
	((TABLENS,u'border-model'), None): cnv_string,
	((TABLENS,u'buttons'), None): cnv_string,
	((TABLENS,u'buttons'), None): cnv_string,
	((TABLENS,u'case-sensitive'), None): cnv_boolean,
	((TABLENS,u'case-sensitive'), None): cnv_string,
	((TABLENS,u'cell-address'), None): cnv_string,
	((TABLENS,u'cell-range-address'), None): cnv_string,
	((TABLENS,u'cell-range-address'), None): cnv_string,
	((TABLENS,u'cell-range'), None): cnv_string,
	((TABLENS,u'column'), None): cnv_integer,
	((TABLENS,u'comment'), None): cnv_string,
	((TABLENS,u'condition'), None): cnv_formula,
	((TABLENS,u'condition-source'), None): cnv_string,
	((TABLENS,u'condition-source-range-address'), None): cnv_string,
	((TABLENS,u'contains-error'), None): cnv_boolean,
	((TABLENS,u'contains-header'), None): cnv_boolean,
	((TABLENS,u'content-validation-name'), None): cnv_string,
	((TABLENS,u'copy-back'), None): cnv_boolean,
	((TABLENS,u'copy-formulas'), None): cnv_boolean,
	((TABLENS,u'copy-styles'), None): cnv_boolean,
	((TABLENS,u'count'), None): cnv_positiveInteger,
	((TABLENS,u'country'), None): cnv_token,
	((TABLENS,u'data-cell-range-address'), None): cnv_string,
	((TABLENS,u'data-field'), None): cnv_string,
	((TABLENS,u'data-type'), None): cnv_string,
	((TABLENS,u'database-name'), None): cnv_string,
	((TABLENS,u'database-table-name'), None): cnv_string,
	((TABLENS,u'date-end'), None): cnv_string,
	((TABLENS,u'date-start'), None): cnv_string,
	((TABLENS,u'date-value'), None): cnv_date,
	((TABLENS,u'default-cell-style-name'), None): cnv_StyleNameRef,
	((TABLENS,u'direction'), None): cnv_string,
	((TABLENS,u'display-border'), None): cnv_boolean,
	((TABLENS,u'display'), None): cnv_boolean,
	((TABLENS,u'display-duplicates'), None): cnv_boolean,
	((TABLENS,u'display-filter-buttons'), None): cnv_boolean,
	((TABLENS,u'display-list'), None): cnv_string,
	((TABLENS,u'display-member-mode'), None): cnv_string,
	((TABLENS,u'drill-down-on-double-click'), None): cnv_boolean,
	((TABLENS,u'enabled'), None): cnv_boolean,
	((TABLENS,u'end-cell-address'), None): cnv_string,
	((TABLENS,u'end'), None): cnv_string,
	((TABLENS,u'end-column'), None): cnv_integer,
	((TABLENS,u'end-position'), None): cnv_integer,
	((TABLENS,u'end-row'), None): cnv_integer,
	((TABLENS,u'end-table'), None): cnv_integer,
	((TABLENS,u'end-x'), None): cnv_length,
	((TABLENS,u'end-y'), None): cnv_length,
	((TABLENS,u'execute'), None): cnv_boolean,
	((TABLENS,u'expression'), None): cnv_formula,
	((TABLENS,u'field-name'), None): cnv_string,
	((TABLENS,u'field-number'), None): cnv_nonNegativeInteger,
	((TABLENS,u'field-number'), None): cnv_string,
	((TABLENS,u'filter-name'), None): cnv_string,
	((TABLENS,u'filter-options'), None): cnv_string,
	((TABLENS,u'formula'), None): cnv_formula,
	((TABLENS,u'function'), None): cnv_string,
	((TABLENS,u'function'), None): cnv_string,
	((TABLENS,u'grand-total'), None): cnv_string,
	((TABLENS,u'group-by-field-number'), None): cnv_nonNegativeInteger,
	((TABLENS,u'grouped-by'), None): cnv_string,
	((TABLENS,u'has-persistent-data'), None): cnv_boolean,
	((TABLENS,u'id'), None): cnv_string,
	((TABLENS,u'identify-categories'), None): cnv_boolean,
	((TABLENS,u'ignore-empty-rows'), None): cnv_boolean,
	((TABLENS,u'index'), None): cnv_nonNegativeInteger,
	((TABLENS,u'is-active'), None): cnv_boolean,
	((TABLENS,u'is-data-layout-field'), None): cnv_string,
	((TABLENS,u'is-selection'), None): cnv_boolean,
	((TABLENS,u'is-sub-table'), None): cnv_boolean,
	((TABLENS,u'label-cell-range-address'), None): cnv_string,
	((TABLENS,u'language'), None): cnv_token,
	((TABLENS,u'language'), None): cnv_token,
	((TABLENS,u'last-column-spanned'), None): cnv_positiveInteger,
	((TABLENS,u'last-row-spanned'), None): cnv_positiveInteger,
	((TABLENS,u'layout-mode'), None): cnv_string,
	((TABLENS,u'link-to-source-data'), None): cnv_boolean,
	((TABLENS,u'marked-invalid'), None): cnv_boolean,
	((TABLENS,u'matrix-covered'), None): cnv_boolean,
	((TABLENS,u'maximum-difference'), None): cnv_double,
	((TABLENS,u'member-count'), None): cnv_nonNegativeInteger,
	((TABLENS,u'member-name'), None): cnv_string,
	((TABLENS,u'member-type'), None): cnv_string,
	((TABLENS,u'message-type'), None): cnv_string,
	((TABLENS,u'mode'), None): cnv_string,
	((TABLENS,u'multi-deletion-spanned'), None): cnv_integer,
	((TABLENS,u'name'), None): cnv_string,
	((TABLENS,u'name'), None): cnv_string,
	((TABLENS,u'null-year'), None): cnv_positiveInteger,
	((TABLENS,u'number-columns-repeated'), None): cnv_positiveInteger,
	((TABLENS,u'number-columns-spanned'), None): cnv_positiveInteger,
	((TABLENS,u'number-matrix-columns-spanned'), None): cnv_positiveInteger,
	((TABLENS,u'number-matrix-rows-spanned'), None): cnv_positiveInteger,
	((TABLENS,u'number-rows-repeated'), None): cnv_positiveInteger,
	((TABLENS,u'number-rows-spanned'), None): cnv_positiveInteger,
	((TABLENS,u'object-name'), None): cnv_string,
	((TABLENS,u'on-update-keep-size'), None): cnv_boolean,
	((TABLENS,u'on-update-keep-styles'), None): cnv_boolean,
	((TABLENS,u'operator'), None): cnv_string,
	((TABLENS,u'operator'), None): cnv_string,
	((TABLENS,u'order'), None): cnv_string,
	((TABLENS,u'orientation'), None): cnv_string,
	((TABLENS,u'orientation'), None): cnv_string,
	((TABLENS,u'page-breaks-on-group-change'), None): cnv_boolean,
	((TABLENS,u'parse-sql-statement'), None): cnv_boolean,
	((TABLENS,u'password'), None): cnv_string,
	((TABLENS,u'position'), None): cnv_integer,
	((TABLENS,u'precision-as-shown'), None): cnv_boolean,
	((TABLENS,u'print'), None): cnv_boolean,
	((TABLENS,u'print-ranges'), None): cnv_string,
	((TABLENS,u'protect'), None): cnv_boolean,
	((TABLENS,u'protected'), None): cnv_boolean,
	((TABLENS,u'protection-key'), None): cnv_string,
	((TABLENS,u'query-name'), None): cnv_string,
	((TABLENS,u'range-usable-as'), None): cnv_string,
	((TABLENS,u'refresh-delay'), None): cnv_boolean,
	((TABLENS,u'refresh-delay'), None): cnv_duration,
	((TABLENS,u'rejecting-change-id'), None): cnv_string,
	((TABLENS,u'row'), None): cnv_integer,
	((TABLENS,u'scenario-ranges'), None): cnv_string,
	((TABLENS,u'search-criteria-must-apply-to-whole-cell'), None): cnv_boolean,
	((TABLENS,u'selected-page'), None): cnv_string,
	((TABLENS,u'show-details'), None): cnv_boolean,
	((TABLENS,u'show-empty'), None): cnv_boolean,
	((TABLENS,u'show-empty'), None): cnv_string,
	((TABLENS,u'show-filter-button'), None): cnv_boolean,
	((TABLENS,u'sort-mode'), None): cnv_string,
	((TABLENS,u'source-cell-range-addresses'), None): cnv_string,
	((TABLENS,u'source-cell-range-addresses'), None): cnv_string,
	((TABLENS,u'source-field-name'), None): cnv_string,
	((TABLENS,u'source-field-name'), None): cnv_string,
	((TABLENS,u'source-name'), None): cnv_string,
	((TABLENS,u'sql-statement'), None): cnv_string,
	((TABLENS,u'start'), None): cnv_string,
	((TABLENS,u'start-column'), None): cnv_integer,
	((TABLENS,u'start-position'), None): cnv_integer,
	((TABLENS,u'start-row'), None): cnv_integer,
	((TABLENS,u'start-table'), None): cnv_integer,
	((TABLENS,u'status'), None): cnv_string,
	((TABLENS,u'step'), None): cnv_double,
	((TABLENS,u'steps'), None): cnv_positiveInteger,
	((TABLENS,u'structure-protected'), None): cnv_boolean,
	((TABLENS,u'style-name'), None): cnv_StyleNameRef,
	((TABLENS,u'table-background'), None): cnv_boolean,
	((TABLENS,u'table'), None): cnv_integer,
	((TABLENS,u'table-name'), None): cnv_string,
	((TABLENS,u'target-cell-address'), None): cnv_string,
	((TABLENS,u'target-cell-address'), None): cnv_string,
	((TABLENS,u'target-range-address'), None): cnv_string,
	((TABLENS,u'target-range-address'), None): cnv_string,
	((TABLENS,u'title'), None): cnv_string,
	((TABLENS,u'track-changes'), None): cnv_boolean,
	((TABLENS,u'type'), None): cnv_string,
	((TABLENS,u'use-labels'), None): cnv_string,
	((TABLENS,u'use-regular-expressions'), None): cnv_boolean,
	((TABLENS,u'used-hierarchy'), None): cnv_integer,
	((TABLENS,u'user-name'), None): cnv_string,
	((TABLENS,u'value'), None): cnv_string,
	((TABLENS,u'value'), None): cnv_string,
	((TABLENS,u'value-type'), None): cnv_string,
	((TABLENS,u'visibility'), None): cnv_string,
	((TEXTNS,u'active'), None): cnv_boolean,
	((TEXTNS,u'address'), None): cnv_string,
	((TEXTNS,u'alphabetical-separators'), None): cnv_boolean,
	((TEXTNS,u'anchor-page-number'), None): cnv_positiveInteger,
	((TEXTNS,u'anchor-type'), None): cnv_string,
	((TEXTNS,u'animation'), None): cnv_string,
	((TEXTNS,u'animation-delay'), None): cnv_string,
	((TEXTNS,u'animation-direction'), None): cnv_string,
	((TEXTNS,u'animation-repeat'), None): cnv_string,
	((TEXTNS,u'animation-start-inside'), None): cnv_boolean,
	((TEXTNS,u'animation-steps'), None): cnv_length,
	((TEXTNS,u'animation-stop-inside'), None): cnv_boolean,
	((TEXTNS,u'annote'), None): cnv_string,
	((TEXTNS,u'author'), None): cnv_string,
	((TEXTNS,u'bibliography-data-field'), None): cnv_string,
	((TEXTNS,u'bibliography-type'), None): cnv_string,
	((TEXTNS,u'booktitle'), None): cnv_string,
	((TEXTNS,u'bullet-char'), None): cnv_string,
	((TEXTNS,u'bullet-relative-size'), None): cnv_string,
	((TEXTNS,u'c'), None): cnv_nonNegativeInteger,
	((TEXTNS,u'capitalize-entries'), None): cnv_boolean,
	((TEXTNS,u'caption-sequence-format'), None): cnv_string,
	((TEXTNS,u'caption-sequence-name'), None): cnv_string,
	((TEXTNS,u'change-id'), None): cnv_IDREF,
	((TEXTNS,u'chapter'), None): cnv_string,
	((TEXTNS,u'citation-body-style-name'), None): cnv_StyleNameRef,
	((TEXTNS,u'citation-style-name'), None): cnv_StyleNameRef,
	((TEXTNS,u'class-names'), None): cnv_NCNames,
	((TEXTNS,u'column-name'), None): cnv_string,
	((TEXTNS,u'combine-entries'), None): cnv_boolean,
	((TEXTNS,u'combine-entries-with-dash'), None): cnv_boolean,
	((TEXTNS,u'combine-entries-with-pp'), None): cnv_boolean,
	((TEXTNS,u'comma-separated'), None): cnv_boolean,
	((TEXTNS,u'cond-style-name'), None): cnv_StyleNameRef,
	((TEXTNS,u'condition'), None): cnv_formula,
	((TEXTNS,u'connection-name'), None): cnv_string,
	((TEXTNS,u'consecutive-numbering'), None): cnv_boolean,
	((TEXTNS,u'continue-numbering'), None): cnv_boolean,
	((TEXTNS,u'copy-outline-levels'), None): cnv_boolean,
	((TEXTNS,u'count-empty-lines'), None): cnv_boolean,
	((TEXTNS,u'count-in-text-boxes'), None): cnv_boolean,
	((TEXTNS,u'current-value'), None): cnv_boolean,
	((TEXTNS,u'custom1'), None): cnv_string,
	((TEXTNS,u'custom2'), None): cnv_string,
	((TEXTNS,u'custom3'), None): cnv_string,
	((TEXTNS,u'custom4'), None): cnv_string,
	((TEXTNS,u'custom5'), None): cnv_string,
	((TEXTNS,u'database-name'), None): cnv_string,
	((TEXTNS,u'date-adjust'), None): cnv_duration,
	((TEXTNS,u'date-value'), None): cnv_date,
#	((TEXTNS,u'date-value'), None): cnv_dateTime,
	((TEXTNS,u'default-style-name'), None): cnv_StyleNameRef,
	((TEXTNS,u'description'), None): cnv_string,
	((TEXTNS,u'display'), None): cnv_string,
	((TEXTNS,u'display-levels'), None): cnv_positiveInteger,
	((TEXTNS,u'display-outline-level'), None): cnv_nonNegativeInteger,
	((TEXTNS,u'dont-balance-text-columns'), None): cnv_boolean,
	((TEXTNS,u'duration'), None): cnv_duration,
	((TEXTNS,u'edition'), None): cnv_string,
	((TEXTNS,u'editor'), None): cnv_string,
	((TEXTNS,u'filter-name'), None): cnv_string,
	((TEXTNS,u'first-row-end-column'), None): cnv_string,
	((TEXTNS,u'first-row-start-column'), None): cnv_string,
	((TEXTNS,u'fixed'), None): cnv_boolean,
	((TEXTNS,u'footnotes-position'), None): cnv_string,
	((TEXTNS,u'formula'), None): cnv_formula,
	((TEXTNS,u'global'), None): cnv_boolean,
	((TEXTNS,u'howpublished'), None): cnv_string,
	((TEXTNS,u'id'), None): cnv_ID,
#	((TEXTNS,u'id'), None): cnv_string,
	((TEXTNS,u'identifier'), None): cnv_string,
	((TEXTNS,u'ignore-case'), None): cnv_boolean,
	((TEXTNS,u'increment'), None): cnv_nonNegativeInteger,
	((TEXTNS,u'index-name'), None): cnv_string,
	((TEXTNS,u'index-scope'), None): cnv_string,
	((TEXTNS,u'institution'), None): cnv_string,
	((TEXTNS,u'is-hidden'), None): cnv_boolean,
	((TEXTNS,u'is-list-header'), None): cnv_boolean,
	((TEXTNS,u'isbn'), None): cnv_string,
	((TEXTNS,u'issn'), None): cnv_string,
	((TEXTNS,u'issn'), None): cnv_string,
	((TEXTNS,u'journal'), None): cnv_string,
	((TEXTNS,u'key'), None): cnv_string,
	((TEXTNS,u'key1'), None): cnv_string,
	((TEXTNS,u'key1-phonetic'), None): cnv_string,
	((TEXTNS,u'key2'), None): cnv_string,
	((TEXTNS,u'key2-phonetic'), None): cnv_string,
	((TEXTNS,u'kind'), None): cnv_string,
	((TEXTNS,u'label'), None): cnv_string,
	((TEXTNS,u'last-row-end-column'), None): cnv_string,
	((TEXTNS,u'last-row-start-column'), None): cnv_string,
	((TEXTNS,u'level'), None): cnv_positiveInteger,
	((TEXTNS,u'line-break'), None): cnv_boolean,
	((TEXTNS,u'line-number'), None): cnv_string,
	((TEXTNS,u'main-entry'), None): cnv_boolean,
	((TEXTNS,u'main-entry-style-name'), None): cnv_StyleNameRef,
	((TEXTNS,u'master-page-name'), None): cnv_StyleNameRef,
	((TEXTNS,u'min-label-distance'), None): cnv_string,
	((TEXTNS,u'min-label-width'), None): cnv_string,
	((TEXTNS,u'month'), None): cnv_string,
	((TEXTNS,u'name'), None): cnv_string,
	((TEXTNS,u'note-class'), None): cnv_textnoteclass,
	((TEXTNS,u'note'), None): cnv_string,
	((TEXTNS,u'number'), None): cnv_string,
	((TEXTNS,u'number-lines'), None): cnv_boolean,
	((TEXTNS,u'number-position'), None): cnv_string,
	((TEXTNS,u'numbered-entries'), None): cnv_boolean,
	((TEXTNS,u'offset'), None): cnv_string,
	((TEXTNS,u'organizations'), None): cnv_string,
	((TEXTNS,u'outline-level'), None): cnv_string,
	((TEXTNS,u'page-adjust'), None): cnv_integer,
	((TEXTNS,u'pages'), None): cnv_string,
	((TEXTNS,u'paragraph-style-name'), None): cnv_StyleNameRef,
	((TEXTNS,u'placeholder-type'), None): cnv_string,
	((TEXTNS,u'prefix'), None): cnv_string,
	((TEXTNS,u'protected'), None): cnv_boolean,
	((TEXTNS,u'protection-key'), None): cnv_string,
	((TEXTNS,u'publisher'), None): cnv_string,
	((TEXTNS,u'ref-name'), None): cnv_string,
	((TEXTNS,u'reference-format'), None): cnv_string,
	((TEXTNS,u'relative-tab-stop-position'), None): cnv_boolean,
	((TEXTNS,u'report-type'), None): cnv_string,
	((TEXTNS,u'restart-numbering'), None): cnv_boolean,
	((TEXTNS,u'restart-on-page'), None): cnv_boolean,
	((TEXTNS,u'row-number'), None): cnv_nonNegativeInteger,
	((TEXTNS,u'school'), None): cnv_string,
	((TEXTNS,u'section-name'), None): cnv_string,
	((TEXTNS,u'select-page'), None): cnv_string,
	((TEXTNS,u'separation-character'), None): cnv_string,
	((TEXTNS,u'series'), None): cnv_string,
	((TEXTNS,u'sort-algorithm'), None): cnv_string,
	((TEXTNS,u'sort-ascending'), None): cnv_boolean,
	((TEXTNS,u'sort-by-position'), None): cnv_boolean,
	((TEXTNS,u'space-before'), None): cnv_string,
	((TEXTNS,u'start-numbering-at'), None): cnv_string,
	((TEXTNS,u'start-value'), None): cnv_nonNegativeInteger,
	((TEXTNS,u'start-value'), None): cnv_positiveInteger,
	((TEXTNS,u'string-value'), None): cnv_string,
	((TEXTNS,u'string-value-if-false'), None): cnv_string,
	((TEXTNS,u'string-value-if-true'), None): cnv_string,
	((TEXTNS,u'string-value-phonetic'), None): cnv_string,
	((TEXTNS,u'style-name'), None): cnv_StyleNameRef,
	((TEXTNS,u'suffix'), None): cnv_string,
	((TEXTNS,u'tab-ref'), None): cnv_nonNegativeInteger,
	((TEXTNS,u'table-name'), None): cnv_string,
	((TEXTNS,u'table-type'), None): cnv_string,
	((TEXTNS,u'time-adjust'), None): cnv_duration,
	((TEXTNS,u'time-value'), None): cnv_dateTime,
	((TEXTNS,u'time-value'), None): cnv_time,
	((TEXTNS,u'title'), None): cnv_string,
	((TEXTNS,u'track-changes'), None): cnv_boolean,
	((TEXTNS,u'url'), None): cnv_string,
	((TEXTNS,u'use-caption'), None): cnv_boolean,
	((TEXTNS,u'use-chart-objects'), None): cnv_boolean,
	((TEXTNS,u'use-draw-objects'), None): cnv_boolean,
	((TEXTNS,u'use-floating-frames'), None): cnv_boolean,
	((TEXTNS,u'use-graphics'), None): cnv_boolean,
	((TEXTNS,u'use-index-marks'), None): cnv_boolean,
	((TEXTNS,u'use-index-source-styles'), None): cnv_boolean,
	((TEXTNS,u'use-keys-as-entries'), None): cnv_boolean,
	((TEXTNS,u'use-math-objects'), None): cnv_boolean,
	((TEXTNS,u'use-objects'), None): cnv_boolean,
	((TEXTNS,u'use-other-objects'), None): cnv_boolean,
	((TEXTNS,u'use-outline-level'), None): cnv_boolean,
	((TEXTNS,u'use-soft-page-breaks'), None): cnv_boolean,
	((TEXTNS,u'use-spreadsheet-objects'), None): cnv_boolean,
	((TEXTNS,u'use-tables'), None): cnv_boolean,
	((TEXTNS,u'value'), None): cnv_nonNegativeInteger,
	((TEXTNS,u'visited-style-name'), None): cnv_StyleNameRef,
	((TEXTNS,u'volume'), None): cnv_string,
	((TEXTNS,u'year'), None): cnv_string,
	((XFORMSNS,u'bind'), None): cnv_string,
	((XLINKNS,u'actuate'), None): cnv_string,
	((XLINKNS,u'href'), None): cnv_anyURI,
	((XLINKNS,u'show'), None): cnv_xlinkshow,
	((XLINKNS,u'title'), None): cnv_string,
	((XLINKNS,u'type'), None): cnv_string,
}

class AttrConverters:
    def convert(self, attribute, value, element):
        """ Based on the element, figures out how to check/convert the attribute value
            All values are converted to string
        """
        conversion = attrconverters.get((attribute, element.qname), None)
        if conversion is not None:
            return conversion(attribute, value, element)
        else:
            conversion = attrconverters.get((attribute, None), None)
            if conversion is not None:
                return conversion(attribute, value, element)
        return unicode(value)


########NEW FILE########
__FILENAME__ = chart
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import CHARTNS
from element import Element

# Autogenerated
def Axis(**args):
    return Element(qname = (CHARTNS,'axis'), **args)

def Categories(**args):
    return Element(qname = (CHARTNS,'categories'), **args)

def Chart(**args):
    return Element(qname = (CHARTNS,'chart'), **args)

def DataPoint(**args):
    return Element(qname = (CHARTNS,'data-point'), **args)

def Domain(**args):
    return Element(qname = (CHARTNS,'domain'), **args)

def ErrorIndicator(**args):
    return Element(qname = (CHARTNS,'error-indicator'), **args)

def Floor(**args):
    return Element(qname = (CHARTNS,'floor'), **args)

def Footer(**args):
    return Element(qname = (CHARTNS,'footer'), **args)

def Grid(**args):
    return Element(qname = (CHARTNS,'grid'), **args)

def Legend(**args):
    return Element(qname = (CHARTNS,'legend'), **args)

def MeanValue(**args):
    return Element(qname = (CHARTNS,'mean-value'), **args)

def PlotArea(**args):
    return Element(qname = (CHARTNS,'plot-area'), **args)

def RegressionCurve(**args):
    return Element(qname = (CHARTNS,'regression-curve'), **args)

def Series(**args):
    return Element(qname = (CHARTNS,'series'), **args)

def StockGainMarker(**args):
    return Element(qname = (CHARTNS,'stock-gain-marker'), **args)

def StockLossMarker(**args):
    return Element(qname = (CHARTNS,'stock-loss-marker'), **args)

def StockRangeLine(**args):
    return Element(qname = (CHARTNS,'stock-range-line'), **args)

def Subtitle(**args):
    return Element(qname = (CHARTNS,'subtitle'), **args)

def SymbolImage(**args):
    return Element(qname = (CHARTNS,'symbol-image'), **args)

def Title(**args):
    return Element(qname = (CHARTNS,'title'), **args)

def Wall(**args):
    return Element(qname = (CHARTNS,'wall'), **args)


########NEW FILE########
__FILENAME__ = config
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import CONFIGNS
from element import Element

# Autogenerated
def ConfigItem(**args):
    return Element(qname = (CONFIGNS, 'config-item'), **args)

def ConfigItemMapEntry(**args):
    return Element(qname = (CONFIGNS,'config-item-map-entry'), **args)

def ConfigItemMapIndexed(**args):
    return Element(qname = (CONFIGNS,'config-item-map-indexed'), **args)

def ConfigItemMapNamed(**args):
    return Element(qname = (CONFIGNS,'config-item-map-named'), **args)

def ConfigItemSet(**args):
    return Element(qname = (CONFIGNS, 'config-item-set'), **args)


########NEW FILE########
__FILENAME__ = dc
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import DCNS
from element import Element

# Autogenerated
def Creator(**args):
    return Element(qname = (DCNS,'creator'), **args)

def Date(**args):
    return Element(qname = (DCNS,'date'), **args)

def Description(**args):
    return Element(qname = (DCNS,'description'), **args)

def Language(**args):
    return Element(qname = (DCNS,'language'), **args)

def Subject(**args):
    return Element(qname = (DCNS,'subject'), **args)

def Title(**args):
    return Element(qname = (DCNS,'title'), **args)

# The following complete the Dublin Core elements, but there is no
# guarantee a compliant implementation of OpenDocument will preserve
# these elements

#def Contributor(**args):
#    return Element(qname = (DCNS,'contributor'), **args)

#def Coverage(**args):
#    return Element(qname = (DCNS,'coverage'), **args)

#def Format(**args):
#    return Element(qname = (DCNS,'format'), **args)

#def Identifier(**args):
#    return Element(qname = (DCNS,'identifier'), **args)

#def Publisher(**args):
#    return Element(qname = (DCNS,'publisher'), **args)

#def Relation(**args):
#    return Element(qname = (DCNS,'relation'), **args)

#def Rights(**args):
#    return Element(qname = (DCNS,'rights'), **args)

#def Source(**args):
#    return Element(qname = (DCNS,'source'), **args)

#def Type(**args):
#    return Element(qname = (DCNS,'type'), **args)

########NEW FILE########
__FILENAME__ = dr3d
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import DR3DNS
from element import Element
from draw import StyleRefElement

# Autogenerated
def Cube(**args):
    return StyleRefElement(qname = (DR3DNS,'cube'), **args)

def Extrude(**args):
    return StyleRefElement(qname = (DR3DNS,'extrude'), **args)

def Light(Element):
    return StyleRefElement(qname = (DR3DNS,'light'), **args)

def Rotate(**args):
    return StyleRefElement(qname = (DR3DNS,'rotate'), **args)

def Scene(**args):
    return StyleRefElement(qname = (DR3DNS,'scene'), **args)

def Sphere(**args):
    return StyleRefElement(qname = (DR3DNS,'sphere'), **args)


########NEW FILE########
__FILENAME__ = draw
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import DRAWNS, STYLENS, PRESENTATIONNS
from element import Element

def StyleRefElement(stylename=None, classnames=None, **args):
    qattrs = {}
    if stylename is not None:
        f = stylename.getAttrNS(STYLENS, 'family')
        if f == 'graphic':
            qattrs[(DRAWNS,u'style-name')]= stylename
        elif f == 'presentation':
            qattrs[(PRESENTATIONNS,u'style-name')]= stylename
        else:
            raise ValueError, "Style's family must be either 'graphic' or 'presentation'"
    if classnames is not None:
        f = classnames[0].getAttrNS(STYLENS, 'family')
        if f == 'graphic':
            qattrs[(DRAWNS,u'class-names')]= classnames
        elif f == 'presentation':
            qattrs[(PRESENTATIONNS,u'class-names')]= classnames
        else:
            raise ValueError, "Style's family must be either 'graphic' or 'presentation'"
    return Element(qattributes=qattrs, **args)

def DrawElement(name=None, **args):
    e = Element(name=name, **args)
    if not args.has_key('displayname'):
        e.setAttrNS(DRAWNS,'display-name', name)
    return e

# Autogenerated
def A(**args):
    return Element(qname = (DRAWNS,'a'), **args)

def Applet(**args):
    return Element(qname = (DRAWNS,'applet'), **args)

def AreaCircle(**args):
    return Element(qname = (DRAWNS,'area-circle'), **args)

def AreaPolygon(**args):
    return Element(qname = (DRAWNS,'area-polygon'), **args)

def AreaRectangle(**args):
    return Element(qname = (DRAWNS,'area-rectangle'), **args)

def Caption(**args):
    return StyleRefElement(qname = (DRAWNS,'caption'), **args)

def Circle(**args):
    return StyleRefElement(qname = (DRAWNS,'circle'), **args)

def Connector(**args):
    return StyleRefElement(qname = (DRAWNS,'connector'), **args)

def ContourPath(**args):
    return Element(qname = (DRAWNS,'contour-path'), **args)

def ContourPolygon(**args):
    return Element(qname = (DRAWNS,'contour-polygon'), **args)

def Control(**args):
    return StyleRefElement(qname = (DRAWNS,'control'), **args)

def CustomShape(**args):
    return StyleRefElement(qname = (DRAWNS,'custom-shape'), **args)

def Ellipse(**args):
    return StyleRefElement(qname = (DRAWNS,'ellipse'), **args)

def EnhancedGeometry(**args):
    return Element(qname = (DRAWNS,'enhanced-geometry'), **args)

def Equation(**args):
    return Element(qname = (DRAWNS,'equation'), **args)

def FillImage(**args):
    return DrawElement(qname = (DRAWNS,'fill-image'), **args)

def FloatingFrame(**args):
    return Element(qname = (DRAWNS,'floating-frame'), **args)

def Frame(**args):
    return StyleRefElement(qname = (DRAWNS,'frame'), **args)

def G(**args):
    return StyleRefElement(qname = (DRAWNS,'g'), **args)

def GluePoint(**args):
    return Element(qname = (DRAWNS,'glue-point'), **args)

def Gradient(**args):
    return DrawElement(qname = (DRAWNS,'gradient'), **args)

def Handle(**args):
    return Element(qname = (DRAWNS,'handle'), **args)

def Hatch(**args):
    return DrawElement(qname = (DRAWNS,'hatch'), **args)

def Image(**args):
    return Element(qname = (DRAWNS,'image'), **args)

def ImageMap(**args):
    return Element(qname = (DRAWNS,'image-map'), **args)

def Layer(**args):
    return Element(qname = (DRAWNS,'layer'), **args)

def LayerSet(**args):
    return Element(qname = (DRAWNS,'layer-set'), **args)

def Line(**args):
    return StyleRefElement(qname = (DRAWNS,'line'), **args)

def Marker(**args):
    return DrawElement(qname = (DRAWNS,'marker'), **args)

def Measure(**args):
    return StyleRefElement(qname = (DRAWNS,'measure'), **args)

def Object(**args):
    return Element(qname = (DRAWNS,'object'), **args)

def ObjectOle(**args):
    return Element(qname = (DRAWNS,'object-ole'), **args)

def Opacity(**args):
    return DrawElement(qname = (DRAWNS,'opacity'), **args)

def Page(**args):
    return Element(qname = (DRAWNS,'page'), **args)

def PageThumbnail(**args):
    return StyleRefElement(qname = (DRAWNS,'page-thumbnail'), **args)

def Param(**args):
    return Element(qname = (DRAWNS,'param'), **args)

def Path(**args):
    return StyleRefElement(qname = (DRAWNS,'path'), **args)

def Plugin(**args):
    return Element(qname = (DRAWNS,'plugin'), **args)

def Polygon(**args):
    return StyleRefElement(qname = (DRAWNS,'polygon'), **args)

def Polyline(**args):
    return StyleRefElement(qname = (DRAWNS,'polyline'), **args)

def Rect(**args):
    return StyleRefElement(qname = (DRAWNS,'rect'), **args)

def RegularPolygon(**args):
    return StyleRefElement(qname = (DRAWNS,'regular-polygon'), **args)

def StrokeDash(**args):
    return DrawElement(qname = (DRAWNS,'stroke-dash'), **args)

def TextBox(**args):
    return Element(qname = (DRAWNS,'text-box'), **args)


########NEW FILE########
__FILENAME__ = easyliststyle
# -*- coding: utf-8 -*-
#   Create a <text:list-style> element from a text string.
#   Copyright (C) 2008 J. David Eisenberg
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program; if not, write to the Free Software Foundation, Inc.,
#   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Contributor(s):
#

import re
from style import Style, TextProperties, ListLevelProperties
from text import ListStyle,ListLevelStyleNumber,ListLevelStyleBullet

"""
Create a <text:list-style> element from a string or array.

List styles require a lot of code to create one level at a time.
These routines take a string and delimiter, or a list of
strings, and creates a <text:list-style> element for you.
Each item in the string (or array) represents a list level
 * style for levels 1-10.</p>
 *
 * <p>If an item contains <code>1</code>, <code>I</code>,
 * <code>i</code>, <code>A</code>, or <code>a</code>, then it is presumed
 * to be a numbering style; otherwise it is a bulleted style.</p>
"""

_MAX_LIST_LEVEL = 10
SHOW_ALL_LEVELS = True
SHOW_ONE_LEVEL = False

def styleFromString(name, specifiers, delim, spacing, showAllLevels):
    specArray = specifiers.split(delim)
    return styleFromList( name, specArray, spacing, showAllLevels )

def styleFromList( styleName, specArray, spacing, showAllLevels):
    bullet = ""
    numPrefix = ""
    numSuffix = ""
    numberFormat = ""
    cssLengthNum = 0
    cssLengthUnits = ""
    numbered = False
    displayLevels = 0
    listStyle = ListStyle(name=styleName)
    numFormatPattern = re.compile("([1IiAa])")
    cssLengthPattern = re.compile("([^a-z]+)\\s*([a-z]+)?")
    m = cssLengthPattern.search( spacing )
    if (m != None):
        cssLengthNum = float(m.group(1))
        if (m.lastindex == 2):
            cssLengthUnits = m.group(2)
    i = 0
    while i < len(specArray):
        specification = specArray[i]
        m = numFormatPattern.search(specification)
        if (m != None):
            numberFormat = m.group(1)
            numPrefix = specification[0:m.start(1)]
            numSuffix = specification[m.end(1):]
            bullet = ""
            numbered = True
            if (showAllLevels):
                displayLevels = i + 1
            else:
                displayLevels = 1
        else:    # it's a bullet style
            bullet = specification
            numPrefix = ""
            numSuffix = ""
            numberFormat = ""
            displayLevels = 1
            numbered = False
        if (numbered):
            lls = ListLevelStyleNumber(level=(i+1))
            if (numPrefix != ''):
                lls.setAttribute('numprefix', numPrefix)
            if (numSuffix != ''):
                lls.setAttribute('numsuffix', numSuffix)
            lls.setAttribute('displaylevels', displayLevels)
        else:
            lls = ListLevelStyleBullet(level=(i+1),bulletchar=bullet[0])
        llp = ListLevelProperties()
        llp.setAttribute('spacebefore', str(cssLengthNum * (i+1)) + cssLengthUnits)
        llp.setAttribute('minlabelwidth', str(cssLengthNum) + cssLengthUnits)
        lls.addElement( llp )
        listStyle.addElement(lls)
        i += 1
    return listStyle

# vim: set expandtab sw=4 :

########NEW FILE########
__FILENAME__ = element
#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2007-2010 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

# Note: This script has copied a lot of text from xml.dom.minidom.
# Whatever license applies to that file also applies to this file.
#
import xml.dom
from xml.dom.minicompat import *
from namespaces import nsdict
import grammar
from attrconverters import AttrConverters

# The following code is pasted form xml.sax.saxutils
# Tt makes it possible to run the code without the xml sax package installed
# To make it possible to have <rubbish> in your text elements, it is necessary to escape the texts
def _escape(data, entities={}):
    """ Escape &, <, and > in a string of data.

        You can escape other strings of data by passing a dictionary as
        the optional entities parameter.  The keys and values must all be
        strings; each key will be replaced with its corresponding value.
    """
    data = data.replace("&", "&amp;")
    data = data.replace("<", "&lt;")
    data = data.replace(">", "&gt;")
    for chars, entity in entities.items():
        data = data.replace(chars, entity)
    return data

def _quoteattr(data, entities={}):
    """ Escape and quote an attribute value.

        Escape &, <, and > in a string of data, then quote it for use as
        an attribute value.  The \" character will be escaped as well, if
        necessary.

        You can escape other strings of data by passing a dictionary as
        the optional entities parameter.  The keys and values must all be
        strings; each key will be replaced with its corresponding value.
    """
    entities['\n']='&#10;'
    entities['\r']='&#12;'
    data = _escape(data, entities)
    if '"' in data:
        if "'" in data:
            data = '"%s"' % data.replace('"', "&quot;")
        else:
            data = "'%s'" % data
    else:
        data = '"%s"' % data
    return data

def _nssplit(qualifiedName):
    """ Split a qualified name into namespace part and local part.  """
    fields = qualifiedName.split(':', 1)
    if len(fields) == 2:
        return fields
    else:
        return (None, fields[0])

def _nsassign(namespace):
    return nsdict.setdefault(namespace,"ns" + str(len(nsdict)))

# Exceptions
class IllegalChild(StandardError):
    """ Complains if you add an element to a parent where it is not allowed """
class IllegalText(StandardError):
    """ Complains if you add text or cdata to an element where it is not allowed """

class Node(xml.dom.Node):
    """ super class for more specific nodes """
    parentNode = None
    nextSibling = None
    previousSibling = None

    def hasChildNodes(self):
        """ Tells whether this element has any children; text nodes,
            subelements, whatever.
        """
        if self.childNodes:
            return True
        else:
            return False

    def _get_childNodes(self):
        return self.childNodes

    def _get_firstChild(self):
        if self.childNodes:
            return self.childNodes[0]

    def _get_lastChild(self):
        if self.childNodes:
            return self.childNodes[-1]

    def insertBefore(self, newChild, refChild):
        """ Inserts the node newChild before the existing child node refChild.
            If refChild is null, insert newChild at the end of the list of children.
        """
        if newChild.nodeType not in self._child_node_types:
            raise IllegalChild, "%s cannot be child of %s" % (newChild.tagName, self.tagName)
        if newChild.parentNode is not None:
            newChild.parentNode.removeChild(newChild)
        if refChild is None:
            self.appendChild(newChild)
        else:
            try:
                index = self.childNodes.index(refChild)
            except ValueError:
                raise xml.dom.NotFoundErr()
            self.childNodes.insert(index, newChild)
            newChild.nextSibling = refChild
            refChild.previousSibling = newChild
            if index:
                node = self.childNodes[index-1]
                node.nextSibling = newChild
                newChild.previousSibling = node
            else:
                newChild.previousSibling = None
            newChild.parentNode = self
        return newChild

    def appendChild(self, newChild):
        """ Adds the node newChild to the end of the list of children of this node.
            If the newChild is already in the tree, it is first removed.
        """
        if newChild.nodeType == self.DOCUMENT_FRAGMENT_NODE:
            for c in tuple(newChild.childNodes):
                self.appendChild(c)
            ### The DOM does not clearly specify what to return in this case
            return newChild
        if newChild.nodeType not in self._child_node_types:
            raise IllegalChild, "<%s> is not allowed in %s" % ( newChild.tagName, self.tagName)
        if newChild.parentNode is not None:
            newChild.parentNode.removeChild(newChild)
        _append_child(self, newChild)
        newChild.nextSibling = None
        return newChild

    def removeChild(self, oldChild):
        """ Removes the child node indicated by oldChild from the list of children, and returns it.
        """
        #FIXME: update ownerDocument.element_dict or find other solution
        try:
            self.childNodes.remove(oldChild)
        except ValueError:
            raise xml.dom.NotFoundErr()
        if oldChild.nextSibling is not None:
            oldChild.nextSibling.previousSibling = oldChild.previousSibling
        if oldChild.previousSibling is not None:
            oldChild.previousSibling.nextSibling = oldChild.nextSibling
        oldChild.nextSibling = oldChild.previousSibling = None
        if self.ownerDocument:
            self.ownerDocument.clear_caches()
        oldChild.parentNode = None
        return oldChild

    def __str__(self):
        val = []
        for c in self.childNodes:
            val.append(str(c))
        return ''.join(val)

    def __unicode__(self):
        val = []
        for c in self.childNodes:
            val.append(unicode(c))
        return u''.join(val)

defproperty(Node, "firstChild", doc="First child node, or None.")
defproperty(Node, "lastChild",  doc="Last child node, or None.")

def _append_child(self, node):
    # fast path with less checks; usable by DOM builders if careful
    childNodes = self.childNodes
    if childNodes:
        last = childNodes[-1]
        node.__dict__["previousSibling"] = last
        last.__dict__["nextSibling"] = node
    childNodes.append(node)
    node.__dict__["parentNode"] = self

class Childless:
    """ Mixin that makes childless-ness easy to implement and avoids
        the complexity of the Node methods that deal with children.
    """

    attributes = None
    childNodes = EmptyNodeList()
    firstChild = None
    lastChild = None

    def _get_firstChild(self):
        return None

    def _get_lastChild(self):
        return None

    def appendChild(self, node):
        """ Raises an error """
        raise xml.dom.HierarchyRequestErr(
            self.tagName + " nodes cannot have children")

    def hasChildNodes(self):
        return False

    def insertBefore(self, newChild, refChild):
        """ Raises an error """
        raise xml.dom.HierarchyRequestErr(
            self.tagName + " nodes do not have children")

    def removeChild(self, oldChild):
        """ Raises an error """
        raise xml.dom.NotFoundErr(
            self.tagName + " nodes do not have children")

    def replaceChild(self, newChild, oldChild):
        """ Raises an error """
        raise xml.dom.HierarchyRequestErr(
            self.tagName + " nodes do not have children")

class Text(Childless, Node):
    nodeType = Node.TEXT_NODE
    tagName = "Text"

    def __init__(self, data):
        self.data = data

    def __str__(self):
        return self.data.encode()

    def __unicode__(self):
        return self.data

    def toXml(self,level,f):
        """ Write XML in UTF-8 """
        if self.data:
            f.write(_escape(unicode(self.data).encode('utf-8')))
    
class CDATASection(Childless, Text):
    nodeType = Node.CDATA_SECTION_NODE

    def toXml(self,level,f):
        """ Generate XML output of the node. If the text contains "]]>", then
            escape it by going out of CDATA mode (]]>), then write the string
            and then go into CDATA mode again. (<![CDATA[)
        """
        if self.data:
            f.write('<![CDATA[%s]]>' % self.data.replace(']]>',']]>]]><![CDATA['))

class Element(Node):
    """ Creates a arbitrary element and is intended to be subclassed not used on its own.
        This element is the base of every element it defines a class which resembles
        a xml-element. The main advantage of this kind of implementation is that you don't
        have to create a toXML method for every different object. Every element
        consists of an attribute, optional subelements, optional text and optional cdata.
    """

    nodeType = Node.ELEMENT_NODE
    namespaces = {}  # Due to shallow copy this is a static variable

    _child_node_types = (Node.ELEMENT_NODE,
                         Node.PROCESSING_INSTRUCTION_NODE,
                         Node.COMMENT_NODE,
                         Node.TEXT_NODE,
                         Node.CDATA_SECTION_NODE,
                         Node.ENTITY_REFERENCE_NODE)
    
    def __init__(self, attributes=None, text=None, cdata=None, qname=None, qattributes=None, check_grammar=True, **args):
        if qname is not None:
            self.qname = qname
        assert(hasattr(self, 'qname'))
        self.ownerDocument = None
        self.childNodes=[]
        self.allowed_children = grammar.allowed_children.get(self.qname)
        prefix = self.get_nsprefix(self.qname[0])
        self.tagName = prefix + ":" + self.qname[1]
        if text is not None:
            self.addText(text)
        if cdata is not None:
            self.addCDATA(cdata)

        allowed_attrs = self.allowed_attributes()
        if allowed_attrs is not None:
            allowed_args = [ a[1].lower().replace('-','') for a in allowed_attrs]
        self.attributes={}
        # Load the attributes from the 'attributes' argument
        if attributes:
            for attr, value in attributes.items():
                self.setAttribute(attr, value)
        # Load the qualified attributes
        if qattributes:
            for attr, value in qattributes.items():
                self.setAttrNS(attr[0], attr[1], value)
        if allowed_attrs is not None:
            # Load the attributes from the 'args' argument
            for arg in args.keys():
                self.setAttribute(arg, args[arg])
        else:
            for arg in args.keys():  # If any attribute is allowed
                self.attributes[arg]=args[arg]
        if not check_grammar:
            return
        # Test that all mandatory attributes have been added.
        required = grammar.required_attributes.get(self.qname)
        if required:
            for r in required:
                if self.getAttrNS(r[0],r[1]) is None:
                    raise AttributeError, "Required attribute missing: %s in <%s>" % (r[1].lower().replace('-',''), self.tagName)

    def get_knownns(self, prefix):
        """ Odfpy maintains a list of known namespaces. In some cases a prefix is used, and
            we need to know which namespace it resolves to.
        """
        global nsdict
        for ns,p in nsdict.items():
            if p == prefix: return ns
        return None
        
    def get_nsprefix(self, namespace):
        """ Odfpy maintains a list of known namespaces. In some cases we have a namespace URL,
            and needs to look up or assign the prefix for it.
        """
        if namespace is None: namespace = ""
        prefix = _nsassign(namespace)
        if not self.namespaces.has_key(namespace):
            self.namespaces[namespace] = prefix
        return prefix

    def allowed_attributes(self):
        return grammar.allowed_attributes.get(self.qname)

    def _setOwnerDoc(self, element):
        element.ownerDocument = self.ownerDocument
        for child in element.childNodes:
            self._setOwnerDoc(child)
        
    def addElement(self, element, check_grammar=True):
        """ adds an element to an Element

            Element.addElement(Element)
        """
        if check_grammar and self.allowed_children is not None:
            if element.qname not in self.allowed_children:
                raise IllegalChild, "<%s> is not allowed in <%s>" % ( element.tagName, self.tagName)
        self.appendChild(element)
        self._setOwnerDoc(element)
        if self.ownerDocument:
            self.ownerDocument.rebuild_caches(element)

    def addText(self, text, check_grammar=True):
        """ Adds text to an element
            Setting check_grammar=False turns off grammar checking
        """
        if check_grammar and self.qname not in grammar.allows_text:
            raise IllegalText, "The <%s> element does not allow text" % self.tagName
        else:
            if text != '':
                self.appendChild(Text(text))

    def addCDATA(self, cdata, check_grammar=True):
        """ Adds CDATA to an element
            Setting check_grammar=False turns off grammar checking
        """
        if check_grammar and self.qname not in grammar.allows_text:
            raise IllegalText, "The <%s> element does not allow text" % self.tagName
        else:
            self.appendChild(CDATASection(cdata))

    def removeAttribute(self, attr, check_grammar=True):
        """ Removes an attribute by name. """
        allowed_attrs = self.allowed_attributes()
        if allowed_attrs is None:
            if type(attr) == type(()):
                prefix, localname = attr
                self.removeAttrNS(prefix, localname)
            else:
                raise AttributeError, "Unable to add simple attribute - use (namespace, localpart)"
        else:
            # Construct a list of allowed arguments
            allowed_args = [ a[1].lower().replace('-','') for a in allowed_attrs]
            if check_grammar and attr not in allowed_args:
                raise AttributeError, "Attribute %s is not allowed in <%s>" % ( attr, self.tagName)
            i = allowed_args.index(attr)
            self.removeAttrNS(allowed_attrs[i][0], allowed_attrs[i][1])

    def setAttribute(self, attr, value, check_grammar=True):
        """ Add an attribute to the element
            This is sort of a convenience method. All attributes in ODF have
            namespaces. The library knows what attributes are legal and then allows
            the user to provide the attribute as a keyword argument and the
            library will add the correct namespace.
            Must overwrite, If attribute already exists.
        """
        allowed_attrs = self.allowed_attributes()
        if allowed_attrs is None:
            if type(attr) == type(()):
                prefix, localname = attr
                self.setAttrNS(prefix, localname, value)
            else:
                raise AttributeError, "Unable to add simple attribute - use (namespace, localpart)"
        else:
            # Construct a list of allowed arguments
            allowed_args = [ a[1].lower().replace('-','') for a in allowed_attrs]
            if check_grammar and attr not in allowed_args:
                raise AttributeError, "Attribute %s is not allowed in <%s>" % ( attr, self.tagName)
            i = allowed_args.index(attr)
            self.setAttrNS(allowed_attrs[i][0], allowed_attrs[i][1], value)

    def setAttrNS(self, namespace, localpart, value):
        """ Add an attribute to the element
            In case you need to add an attribute the library doesn't know about
            then you must provide the full qualified name
            It will not check that the attribute is legal according to the schema.
            Must overwrite, If attribute already exists.
        """
        allowed_attrs = self.allowed_attributes()
        prefix = self.get_nsprefix(namespace)
#       if allowed_attrs and (namespace, localpart) not in allowed_attrs:
#           raise AttributeError, "Attribute %s:%s is not allowed in element <%s>" % ( prefix, localpart, self.tagName)
        c = AttrConverters()
        self.attributes[(namespace, localpart)] = c.convert((namespace, localpart), value, self)

    def getAttrNS(self, namespace, localpart):
        prefix = self.get_nsprefix(namespace)
        return self.attributes.get((namespace, localpart))

    def removeAttrNS(self, namespace, localpart):
        del self.attributes[(namespace, localpart)]

    def getAttribute(self, attr):
        """ Get an attribute value. The method knows which namespace the attribute is in
        """
        allowed_attrs = self.allowed_attributes()
        if allowed_attrs is None:
            if type(attr) == type(()):
                prefix, localname = attr
                return self.getAttrNS(prefix, localname)
            else:
                raise AttributeError, "Unable to get simple attribute - use (namespace, localpart)"
        else:
            # Construct a list of allowed arguments
            allowed_args = [ a[1].lower().replace('-','') for a in allowed_attrs]
            i = allowed_args.index(attr)
            return self.getAttrNS(allowed_attrs[i][0], allowed_attrs[i][1])

    def write_open_tag(self, level, f):
        f.write('<'+self.tagName)
        if level == 0:
            for namespace, prefix in self.namespaces.items():
                f.write(' xmlns:' + prefix + '="'+ _escape(str(namespace))+'"')
        for qname in self.attributes.keys():
            prefix = self.get_nsprefix(qname[0])
            f.write(' '+_escape(str(prefix+':'+qname[1]))+'='+_quoteattr(unicode(self.attributes[qname]).encode('utf-8')))
        f.write('>')

    def write_close_tag(self, level, f):
        f.write('</'+self.tagName+'>')

    def toXml(self, level, f):
        """ Generate XML stream out of the tree structure """
        f.write('<'+self.tagName)
        if level == 0:
            for namespace, prefix in self.namespaces.items():
                f.write(' xmlns:' + prefix + '="'+ _escape(str(namespace))+'"')
        for qname in self.attributes.keys():
            prefix = self.get_nsprefix(qname[0])
            f.write(' '+_escape(str(prefix+':'+qname[1]))+'='+_quoteattr(unicode(self.attributes[qname]).encode('utf-8')))
        if self.childNodes:
            f.write('>')
            for element in self.childNodes:
                element.toXml(level+1,f)
            f.write('</'+self.tagName+'>')
        else:
            f.write('/>')

    def _getElementsByObj(self, obj, accumulator):
        if self.qname == obj.qname:
            accumulator.append(self)
        for e in self.childNodes:
            if e.nodeType == Node.ELEMENT_NODE:
                accumulator = e._getElementsByObj(obj, accumulator)
        return accumulator

    def getElementsByType(self, element):
        """ Gets elements based on the type, which is function from text.py, draw.py etc. """
        obj = element(check_grammar=False)
        return self._getElementsByObj(obj,[])

    def isInstanceOf(self, element):
        """ This is a check to see if the object is an instance of a type """
        obj = element(check_grammar=False)
        return self.qname == obj.qname



########NEW FILE########
__FILENAME__ = elementtypes
#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2008 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import *

# Inline element don't cause a box
# They are analogous to the HTML elements SPAN, B, I etc.
inline_elements = (
    (TEXTNS,u'a'),
    (TEXTNS,u'author-initials'),
    (TEXTNS,u'author-name'),
    (TEXTNS,u'bibliography-mark'),
    (TEXTNS,u'bookmark-ref'),
    (TEXTNS,u'chapter'),
    (TEXTNS,u'character-count'),
    (TEXTNS,u'conditional-text'),
    (TEXTNS,u'creation-date'),
    (TEXTNS,u'creation-time'),
    (TEXTNS,u'creator'),
    (TEXTNS,u'database-display'),
    (TEXTNS,u'database-name'),
    (TEXTNS,u'database-next'),
    (TEXTNS,u'database-row-number'),
    (TEXTNS,u'database-row-select'),
    (TEXTNS,u'date'),
    (TEXTNS,u'dde-connection'),
    (TEXTNS,u'description'),
    (TEXTNS,u'editing-cycles'),
    (TEXTNS,u'editing-duration'),
    (TEXTNS,u'execute-macro'),
    (TEXTNS,u'expression'),
    (TEXTNS,u'file-name'),
    (TEXTNS,u'hidden-paragraph'),
    (TEXTNS,u'hidden-text'),
    (TEXTNS,u'image-count'),
    (TEXTNS,u'initial-creator'),
    (TEXTNS,u'keywords'),
    (TEXTNS,u'measure'),
    (TEXTNS,u'modification-date'),
    (TEXTNS,u'modification-time'),
    (TEXTNS,u'note-ref'),
    (TEXTNS,u'object-count'),
    (TEXTNS,u'page-continuation'),
    (TEXTNS,u'page-count'),
    (TEXTNS,u'page-number'),
    (TEXTNS,u'page-variable-get'),
    (TEXTNS,u'page-variable-set'),
    (TEXTNS,u'paragraph-count'),
    (TEXTNS,u'placeholder'),
    (TEXTNS,u'print-date'),
    (TEXTNS,u'printed-by'),
    (TEXTNS,u'print-time'),
    (TEXTNS,u'reference-ref'),
    (TEXTNS,u'ruby'),
    (TEXTNS,u'ruby-base'),
    (TEXTNS,u'ruby-text'),
    (TEXTNS,u'script'),
    (TEXTNS,u'sender-city'),
    (TEXTNS,u'sender-company'),
    (TEXTNS,u'sender-country'),
    (TEXTNS,u'sender-email'),
    (TEXTNS,u'sender-fax'),
    (TEXTNS,u'sender-firstname'),
    (TEXTNS,u'sender-initials'),
    (TEXTNS,u'sender-lastname'),
    (TEXTNS,u'sender-phone-private'),
    (TEXTNS,u'sender-phone-work'),
    (TEXTNS,u'sender-position'),
    (TEXTNS,u'sender-postal-code'),
    (TEXTNS,u'sender-state-or-province'),
    (TEXTNS,u'sender-street'),
    (TEXTNS,u'sender-title'),
    (TEXTNS,u'sequence'),
    (TEXTNS,u'sequence-ref'),
    (TEXTNS,u'sheet-name'),
    (TEXTNS,u'span'),
    (TEXTNS,u'subject'),
    (TEXTNS,u'table-count'),
    (TEXTNS,u'table-formula'),
    (TEXTNS,u'template-name'),
    (TEXTNS,u'text-input'),
    (TEXTNS,u'time'),
    (TEXTNS,u'title'),
    (TEXTNS,u'user-defined'),
    (TEXTNS,u'user-field-get'),
    (TEXTNS,u'user-field-input'),
    (TEXTNS,u'variable-get'),
    (TEXTNS,u'variable-input'),
    (TEXTNS,u'variable-set'),
    (TEXTNS,u'word-count'),
)


# It is almost impossible to determine what elements are block elements.
# There are so many that don't fit the form
block_elements = (
    (TEXTNS,u'h'),
    (TEXTNS,u'p'),
    (TEXTNS,u'list'),
    (TEXTNS,u'list-item'),
    (TEXTNS,u'section'),
)

declarative_elements = (
    (OFFICENS,u'font-face-decls'),
    (PRESENTATIONNS,u'date-time-decl'),
    (PRESENTATIONNS,u'footer-decl'),
    (PRESENTATIONNS,u'header-decl'),
    (TABLENS,u'table-template'),
    (TEXTNS,u'alphabetical-index-entry-template'),
    (TEXTNS,u'alphabetical-index-source'),
    (TEXTNS,u'bibliography-entry-template'),
    (TEXTNS,u'bibliography-source'),
    (TEXTNS,u'dde-connection-decls'),
    (TEXTNS,u'illustration-index-entry-template'),
    (TEXTNS,u'illustration-index-source'),
    (TEXTNS,u'index-source-styles'),
    (TEXTNS,u'index-title-template'),
    (TEXTNS,u'note-continuation-notice-backward'),
    (TEXTNS,u'note-continuation-notice-forward'),
    (TEXTNS,u'notes-configuration'),
    (TEXTNS,u'object-index-entry-template'),
    (TEXTNS,u'object-index-source'),
    (TEXTNS,u'sequence-decls'),
    (TEXTNS,u'table-index-entry-template'),
    (TEXTNS,u'table-index-source'),
    (TEXTNS,u'table-of-content-entry-template'),
    (TEXTNS,u'table-of-content-source'),
    (TEXTNS,u'user-field-decls'),
    (TEXTNS,u'user-index-entry-template'),
    (TEXTNS,u'user-index-source'),
    (TEXTNS,u'variable-decls'),
)

empty_elements = (
    (ANIMNS,u'animate'),
    (ANIMNS,u'animateColor'),
    (ANIMNS,u'animateMotion'),
    (ANIMNS,u'animateTransform'),
    (ANIMNS,u'audio'),
    (ANIMNS,u'param'),
    (ANIMNS,u'set'),
    (ANIMNS,u'transitionFilter'),
    (CHARTNS,u'categories'),
    (CHARTNS,u'data-point'),
    (CHARTNS,u'domain'),
    (CHARTNS,u'error-indicator'),
    (CHARTNS,u'floor'),
    (CHARTNS,u'grid'),
    (CHARTNS,u'legend'),
    (CHARTNS,u'mean-value'),
    (CHARTNS,u'regression-curve'),
    (CHARTNS,u'stock-gain-marker'),
    (CHARTNS,u'stock-loss-marker'),
    (CHARTNS,u'stock-range-line'),
    (CHARTNS,u'symbol-image'),
    (CHARTNS,u'wall'),
    (DR3DNS,u'cube'),
    (DR3DNS,u'extrude'),
    (DR3DNS,u'light'),
    (DR3DNS,u'rotate'),
    (DR3DNS,u'sphere'),
    (DRAWNS,u'contour-path'),
    (DRAWNS,u'contour-polygon'),
    (DRAWNS,u'equation'),
    (DRAWNS,u'fill-image'),
    (DRAWNS,u'floating-frame'),
    (DRAWNS,u'glue-point'),
    (DRAWNS,u'gradient'),
    (DRAWNS,u'handle'),
    (DRAWNS,u'hatch'),
    (DRAWNS,u'layer'),
    (DRAWNS,u'marker'),
    (DRAWNS,u'opacity'),
    (DRAWNS,u'page-thumbnail'),
    (DRAWNS,u'param'),
    (DRAWNS,u'stroke-dash'),
    (FORMNS,u'connection-resource'),
    (FORMNS,u'list-value'),
    (FORMNS,u'property'),
    (MANIFESTNS,u'algorithm'),
    (MANIFESTNS,u'key-derivation'),
    (METANS,u'auto-reload'),
    (METANS,u'document-statistic'),
    (METANS,u'hyperlink-behaviour'),
    (METANS,u'template'),
    (NUMBERNS,u'am-pm'),
    (NUMBERNS,u'boolean'),
    (NUMBERNS,u'day'),
    (NUMBERNS,u'day-of-week'),
    (NUMBERNS,u'era'),
    (NUMBERNS,u'fraction'),
    (NUMBERNS,u'hours'),
    (NUMBERNS,u'minutes'),
    (NUMBERNS,u'month'),
    (NUMBERNS,u'quarter'),
    (NUMBERNS,u'scientific-number'),
    (NUMBERNS,u'seconds'),
    (NUMBERNS,u'text-content'),
    (NUMBERNS,u'week-of-year'),
    (NUMBERNS,u'year'),
    (OFFICENS,u'dde-source'),
    (PRESENTATIONNS,u'date-time'),
    (PRESENTATIONNS,u'footer'),
    (PRESENTATIONNS,u'header'),
    (PRESENTATIONNS,u'placeholder'),
    (PRESENTATIONNS,u'play'),
    (PRESENTATIONNS,u'show'),
    (PRESENTATIONNS,u'sound'),
    (SCRIPTNS,u'event-listener'),
    (STYLENS,u'column'),
    (STYLENS,u'column-sep'),
    (STYLENS,u'drop-cap'),
    (STYLENS,u'footnote-sep'),
    (STYLENS,u'list-level-properties'),
    (STYLENS,u'map'),
    (STYLENS,u'ruby-properties'),
    (STYLENS,u'table-column-properties'),
    (STYLENS,u'tab-stop'),
    (STYLENS,u'text-properties'),
    (SVGNS,u'definition-src'),
    (SVGNS,u'font-face-format'),
    (SVGNS,u'font-face-name'),
    (SVGNS,u'stop'),
    (TABLENS,u'body'),
    (TABLENS,u'cell-address'),
    (TABLENS,u'cell-range-source'),
    (TABLENS,u'change-deletion'),
    (TABLENS,u'consolidation'),
    (TABLENS,u'database-source-query'),
    (TABLENS,u'database-source-sql'),
    (TABLENS,u'database-source-table'),
    (TABLENS,u'data-pilot-display-info'),
    (TABLENS,u'data-pilot-field-reference'),
    (TABLENS,u'data-pilot-group-member'),
    (TABLENS,u'data-pilot-layout-info'),
    (TABLENS,u'data-pilot-member'),
    (TABLENS,u'data-pilot-sort-info'),
    (TABLENS,u'data-pilot-subtotal'),
    (TABLENS,u'dependency'),
    (TABLENS,u'error-macro'),
    (TABLENS,u'even-columns'),
    (TABLENS,u'even-rows'),
    (TABLENS,u'filter-condition'),
    (TABLENS,u'first-column'),
    (TABLENS,u'first-row'),
    (TABLENS,u'highlighted-range'),
    (TABLENS,u'insertion-cut-off'),
    (TABLENS,u'iteration'),
    (TABLENS,u'label-range'),
    (TABLENS,u'last-column'),
    (TABLENS,u'last-row'),
    (TABLENS,u'movement-cut-off'),
    (TABLENS,u'named-expression'),
    (TABLENS,u'named-range'),
    (TABLENS,u'null-date'),
    (TABLENS,u'odd-columns'),
    (TABLENS,u'odd-rows'),
    (TABLENS,u'operation'),
    (TABLENS,u'scenario'),
    (TABLENS,u'sort-by'),
    (TABLENS,u'sort-groups'),
    (TABLENS,u'source-range-address'),
    (TABLENS,u'source-service'),
    (TABLENS,u'subtotal-field'),
    (TABLENS,u'table-column'),
    (TABLENS,u'table-source'),
    (TABLENS,u'target-range-address'),
    (TEXTNS,u'alphabetical-index-auto-mark-file'),
    (TEXTNS,u'alphabetical-index-mark'),
    (TEXTNS,u'alphabetical-index-mark-end'),
    (TEXTNS,u'alphabetical-index-mark-start'),
    (TEXTNS,u'bookmark'),
    (TEXTNS,u'bookmark-end'),
    (TEXTNS,u'bookmark-start'),
    (TEXTNS,u'change'),
    (TEXTNS,u'change-end'),
    (TEXTNS,u'change-start'),
    (TEXTNS,u'dde-connection-decl'),
    (TEXTNS,u'index-entry-bibliography'),
    (TEXTNS,u'index-entry-chapter'),
    (TEXTNS,u'index-entry-link-end'),
    (TEXTNS,u'index-entry-link-start'),
    (TEXTNS,u'index-entry-page-number'),
    (TEXTNS,u'index-entry-tab-stop'),
    (TEXTNS,u'index-entry-text'),
    (TEXTNS,u'index-source-style'),
    (TEXTNS,u'line-break'),
    (TEXTNS,u'page'),
    (TEXTNS,u'reference-mark'),
    (TEXTNS,u'reference-mark-end'),
    (TEXTNS,u'reference-mark-start'),
    (TEXTNS,u's'),
    (TEXTNS,u'section-source'),
    (TEXTNS,u'sequence-decl'),
    (TEXTNS,u'soft-page-break'),
    (TEXTNS,u'sort-key'),
    (TEXTNS,u'tab'),
    (TEXTNS,u'toc-mark'),
    (TEXTNS,u'toc-mark-end'),
    (TEXTNS,u'toc-mark-start'),
    (TEXTNS,u'user-field-decl'),
    (TEXTNS,u'user-index-mark'),
    (TEXTNS,u'user-index-mark-end'),
    (TEXTNS,u'user-index-mark-start'),
    (TEXTNS,u'variable-decl')
)

########NEW FILE########
__FILENAME__ = form
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import FORMNS
from element import Element


# Autogenerated
def Button(**args):
    return Element(qname = (FORMNS,'button'), **args)

def Checkbox(**args):
    return Element(qname = (FORMNS,'checkbox'), **args)

def Column(**args):
    return Element(qname = (FORMNS,'column'), **args)

def Combobox(**args):
    return Element(qname = (FORMNS,'combobox'), **args)

def ConnectionResource(**args):
    return Element(qname = (FORMNS,'connection-resource'), **args)

def Date(**args):
    return Element(qname = (FORMNS,'date'), **args)

def File(**args):
    return Element(qname = (FORMNS,'file'), **args)

def FixedText(**args):
    return Element(qname = (FORMNS,'fixed-text'), **args)

def Form(**args):
    return Element(qname = (FORMNS,'form'), **args)

def FormattedText(**args):
    return Element(qname = (FORMNS,'formatted-text'), **args)

def Frame(**args):
    return Element(qname = (FORMNS,'frame'), **args)

def GenericControl(**args):
    return Element(qname = (FORMNS,'generic-control'), **args)

def Grid(**args):
    return Element(qname = (FORMNS,'grid'), **args)

def Hidden(**args):
    return Element(qname = (FORMNS,'hidden'), **args)

def Image(**args):
    return Element(qname = (FORMNS,'image'), **args)

def ImageFrame(**args):
    return Element(qname = (FORMNS,'image-frame'), **args)

def Item(**args):
    return Element(qname = (FORMNS,'item'), **args)

def ListProperty(**args):
    return Element(qname = (FORMNS,'list-property'), **args)

def ListValue(**args):
    return Element(qname = (FORMNS,'list-value'), **args)

def Listbox(**args):
    return Element(qname = (FORMNS,'listbox'), **args)

def Number(**args):
    return Element(qname = (FORMNS,'number'), **args)

def Option(**args):
    return Element(qname = (FORMNS,'option'), **args)

def Password(**args):
    return Element(qname = (FORMNS,'password'), **args)

def Properties(**args):
    return Element(qname = (FORMNS,'properties'), **args)

def Property(**args):
    return Element(qname = (FORMNS,'property'), **args)

def Radio(**args):
    return Element(qname = (FORMNS,'radio'), **args)

def Text(**args):
    return Element(qname = (FORMNS,'text'), **args)

def Textarea(**args):
    return Element(qname = (FORMNS,'textarea'), **args)

def Time(**args):
    return Element(qname = (FORMNS,'time'), **args)

def ValueRange(**args):
    return Element(qname = (FORMNS,'value-range'), **args)


########NEW FILE########
__FILENAME__ = grammar
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2010 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

__doc__=""" In principle the OpenDocument schema converted to python structures.
Currently it contains the legal child elements of a given element.
To be used for validation check in the API
"""

from namespaces import *

# The following code is generated from the RelaxNG schema with this notice:

#   OASIS OpenDocument v1.1
#   OASIS Standard, 1 Feb 2007
#   Relax-NG Schema

#   $Id$

#    2002-2007 OASIS Open
#    1999-2007 Sun Microsystems, Inc.

#   This document and translations of it may be copied and furnished
#   to others, and derivative works that comment on or otherwise explain
#   it or assist in its implementation may be prepared, copied,
#   published and distributed, in whole or in part, without restriction
#   of any kind, provided that the above copyright notice and this
#   paragraph are included on all such copies and derivative works.
#   However, this document itself does not be modified in any way, such
#   as by removing the copyright notice or references to OASIS, except
#   as needed for the purpose of developing OASIS specifications, in
#   which case the procedures for copyrights defined in the OASIS
#   Intellectual Property Rights document must be followed, or as
#   required to translate it into languages other than English.
#

allowed_children = {
	(DCNS,u'creator') : (
	),
	(DCNS,u'date') : (
	),
	(DCNS,u'description') : (
	),
	(DCNS,u'language') : (
	),
	(DCNS,u'subject') : (
	),
	(DCNS,u'title') : (
	),
# Completes Dublin Core start
#	(DCNS,'contributor') : (
#	),
#	(DCNS,'coverage') : (
#	),
#	(DCNS,'format') : (
#	),
#	(DCNS,'identifier') : (
#	),
#	(DCNS,'publisher') : (
#	),
#	(DCNS,'relation') : (
#	),
#	(DCNS,'rights') : (
#	),
#	(DCNS,'source') : (
#	),
#	(DCNS,'type') : (
#	),
# Completes Dublin Core end
	(MATHNS,u'math') : None,

	(XFORMSNS,u'model') : None,

	(ANIMNS,u'animate') : (
	),
	(ANIMNS,u'animateColor') : (
	),
	(ANIMNS,u'animateMotion') : (
	),
	(ANIMNS,u'animateTransform') : (
	),
	(ANIMNS,u'audio') : (
	),
	(ANIMNS,u'command') : (
		(ANIMNS,u'param'),
	),
# allowed_children
	(ANIMNS,u'iterate') : (
		(ANIMNS,u'animate'),
		(ANIMNS,u'animateColor'),
		(ANIMNS,u'animateMotion'),
		(ANIMNS,u'animateTransform'),
		(ANIMNS,u'audio'),
		(ANIMNS,u'command'),
		(ANIMNS,u'iterate'),
		(ANIMNS,u'par'),
		(ANIMNS,u'seq'),
		(ANIMNS,u'set'),
		(ANIMNS,u'transitionFilter'),
	),
	(ANIMNS,u'par') : (
		(ANIMNS,u'animate'),
		(ANIMNS,u'animateColor'),
		(ANIMNS,u'animateMotion'),
		(ANIMNS,u'animateTransform'),
		(ANIMNS,u'audio'),
		(ANIMNS,u'command'),
		(ANIMNS,u'iterate'),
		(ANIMNS,u'par'),
		(ANIMNS,u'seq'),
		(ANIMNS,u'set'),
		(ANIMNS,u'transitionFilter'),
	),
# allowed_children
	(ANIMNS,u'param') : (
	),
	(ANIMNS,u'seq') : (
		(ANIMNS,u'animate'),
		(ANIMNS,u'animateColor'),
		(ANIMNS,u'animateMotion'),
		(ANIMNS,u'animateTransform'),
		(ANIMNS,u'audio'),
		(ANIMNS,u'command'),
		(ANIMNS,u'iterate'),
		(ANIMNS,u'par'),
		(ANIMNS,u'seq'),
		(ANIMNS,u'set'),
		(ANIMNS,u'transitionFilter'),
	),
	(ANIMNS,u'set') : (
	),
	(ANIMNS,u'transitionFilter') : (
	),
	(CHARTNS,u'axis') : (
		(CHARTNS,u'categories'),
		(CHARTNS,u'grid'),
		(CHARTNS,u'title'),
	),
# allowed_children
	(CHARTNS,u'categories') : (
	),
	(CHARTNS,u'chart') : (
		(CHARTNS,u'footer'),
		(CHARTNS,u'legend'),
		(CHARTNS,u'plot-area'),
		(CHARTNS,u'subtitle'),
		(CHARTNS,u'title'),
		(TABLENS,u'table'),
	),
	(CHARTNS,u'data-point') : (
	),
	(CHARTNS,u'domain') : (
	),
	(CHARTNS,u'error-indicator') : (
	),
	(CHARTNS,u'floor') : (
	),
	(CHARTNS,u'footer') : (
		(TEXTNS,u'p'),
	),
	(CHARTNS,u'grid') : (
	),
	(CHARTNS,u'legend') : (
	),
# allowed_children
	(CHARTNS,u'mean-value') : (
	),
	(CHARTNS,u'plot-area') : (
		(CHARTNS,u'axis'),
		(CHARTNS,u'floor'),
		(CHARTNS,u'series'),
		(CHARTNS,u'stock-gain-marker'),
		(CHARTNS,u'stock-loss-marker'),
		(CHARTNS,u'stock-range-line'),
		(CHARTNS,u'wall'),
		(DR3DNS,u'light'),
	),
	(CHARTNS,u'regression-curve') : (
	),
	(CHARTNS,u'series') : (
		(CHARTNS,u'data-point'),
		(CHARTNS,u'domain'),
		(CHARTNS,u'error-indicator'),
		(CHARTNS,u'mean-value'),
		(CHARTNS,u'regression-curve'),
	),
	(CHARTNS,u'stock-gain-marker') : (
	),
	(CHARTNS,u'stock-loss-marker') : (
	),
# allowed_children
	(CHARTNS,u'stock-range-line') : (
	),
	(CHARTNS,u'subtitle') : (
		(TEXTNS,u'p'),
	),
	(CHARTNS,u'symbol-image') : (
	),
	(CHARTNS,u'title') : (
		(TEXTNS,u'p'),
	),
	(CHARTNS,u'wall') : (
	),
	(CONFIGNS,u'config-item') : (
	),
	(CONFIGNS,u'config-item-map-entry') : (
		(CONFIGNS,u'config-item'),
		(CONFIGNS,u'config-item-map-indexed'),
		(CONFIGNS,u'config-item-map-named'),
		(CONFIGNS,u'config-item-set'),
	),
	(CONFIGNS,u'config-item-map-indexed') : (
		(CONFIGNS,u'config-item-map-entry'),
	),
	(CONFIGNS,u'config-item-map-named') : (
		(CONFIGNS,u'config-item-map-entry'),
	),
# allowed_children
	(CONFIGNS,u'config-item-set') : (
		(CONFIGNS,u'config-item'),
		(CONFIGNS,u'config-item-map-indexed'),
		(CONFIGNS,u'config-item-map-named'),
		(CONFIGNS,u'config-item-set'),
	),
	(MANIFESTNS,u'algorithm') : (
	),
	(MANIFESTNS,u'encryption-data') : (
		(MANIFESTNS,u'algorithm'),
		(MANIFESTNS,u'key-derivation'),
	),
	(MANIFESTNS,u'file-entry') : (
		(MANIFESTNS,u'encryption-data'),
	),
	(MANIFESTNS,u'key-derivation') : (
	),
	(MANIFESTNS,u'manifest') : (
		(MANIFESTNS,u'file-entry'),
	),
	(NUMBERNS,u'am-pm') : (
	),
	(NUMBERNS,u'boolean') : (
	),
# allowed_children
	(NUMBERNS,u'boolean-style') : (
		(NUMBERNS,u'boolean'),
		(NUMBERNS,u'text'),
		(STYLENS,u'map'),
		(STYLENS,u'text-properties'),
	),
	(NUMBERNS,u'currency-style') : (
		(NUMBERNS,u'currency-symbol'),
		(NUMBERNS,u'number'),
		(NUMBERNS,u'text'),
		(STYLENS,u'map'),
		(STYLENS,u'text-properties'),
	),
	(NUMBERNS,u'currency-symbol') : (
	),
	(NUMBERNS,u'date-style') : (
		(NUMBERNS,u'am-pm'),
		(NUMBERNS,u'day'),
		(NUMBERNS,u'day-of-week'),
		(NUMBERNS,u'era'),
		(NUMBERNS,u'hours'),
		(NUMBERNS,u'minutes'),
		(NUMBERNS,u'month'),
		(NUMBERNS,u'quarter'),
		(NUMBERNS,u'seconds'),
		(NUMBERNS,u'text'),
		(NUMBERNS,u'week-of-year'),
		(NUMBERNS,u'year'),
		(STYLENS,u'map'),
		(STYLENS,u'text-properties'),
	),
# allowed_children
	(NUMBERNS,u'day') : (
	),
	(NUMBERNS,u'day-of-week') : (
	),
	(NUMBERNS,u'embedded-text') : (
	),
	(NUMBERNS,u'era') : (
	),
	(NUMBERNS,u'fraction') : (
	),
	(NUMBERNS,u'hours') : (
	),
	(NUMBERNS,u'minutes') : (
	),
	(NUMBERNS,u'month') : (
	),
	(NUMBERNS,u'number') : (
		(NUMBERNS,u'embedded-text'),
	),
	(NUMBERNS,u'number-style') : (
		(NUMBERNS,u'fraction'),
		(NUMBERNS,u'number'),
		(NUMBERNS,u'scientific-number'),
		(NUMBERNS,u'text'),
		(STYLENS,u'map'),
		(STYLENS,u'text-properties'),
	),
# allowed_children
	(NUMBERNS,u'percentage-style') : (
		(NUMBERNS,u'number'),
		(NUMBERNS,u'text'),
		(STYLENS,u'map'),
		(STYLENS,u'text-properties'),
	),
	(NUMBERNS,u'quarter') : (
	),
	(NUMBERNS,u'scientific-number') : (
	),
	(NUMBERNS,u'seconds') : (
	),
	(NUMBERNS,u'text') : (
	),
	(NUMBERNS,u'text-content') : (
	),
	(NUMBERNS,u'text-style') : (
		(NUMBERNS,u'text'),
		(NUMBERNS,u'text-content'),
		(STYLENS,u'map'),
		(STYLENS,u'text-properties'),
	),
# allowed_children
	(NUMBERNS,u'time-style') : (
		(NUMBERNS,u'am-pm'),
		(NUMBERNS,u'hours'),
		(NUMBERNS,u'minutes'),
		(NUMBERNS,u'seconds'),
		(NUMBERNS,u'text'),
		(STYLENS,u'map'),
		(STYLENS,u'text-properties'),
	),
# allowed_children
	(NUMBERNS,u'week-of-year') : (
	),
	(NUMBERNS,u'year') : (
	),
	(DR3DNS,u'cube') : (
	),
	(DR3DNS,u'extrude') : (
	),
	(DR3DNS,u'light') : (
	),
	(DR3DNS,u'rotate') : (
	),
	(DR3DNS,u'scene') : (
		(DR3DNS,u'cube'),
		(DR3DNS,u'extrude'),
		(DR3DNS,u'light'),
		(DR3DNS,u'rotate'),
		(DR3DNS,u'scene'),
		(DR3DNS,u'sphere'),
		(SVGNS,u'title'),
		(SVGNS,u'desc'),
	),
	(DR3DNS,u'sphere') : (
	),
	(DRAWNS,u'a') : (
		(DRAWNS,u'frame'),
	),
# allowed_children
	(DRAWNS,u'applet') : (
		(DRAWNS,u'param'),
	),
	(DRAWNS,u'area-circle') : (
		(OFFICENS,u'event-listeners'),
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
	),
	(DRAWNS,u'area-polygon') : (
		(OFFICENS,u'event-listeners'),
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
	),
	(DRAWNS,u'area-rectangle') : (
		(OFFICENS,u'event-listeners'),
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
	),
	(DRAWNS,u'caption') : (
		(DRAWNS,u'glue-point'),
		(OFFICENS,u'event-listeners'),
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
		(TEXTNS,u'list'),
		(TEXTNS,u'p'),
	),
	(DRAWNS,u'circle') : (
		(DRAWNS,u'glue-point'),
		(OFFICENS,u'event-listeners'),
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
		(TEXTNS,u'list'),
		(TEXTNS,u'p'),
	),
# allowed_children
	(DRAWNS,u'connector') : (
		(DRAWNS,u'glue-point'),
		(OFFICENS,u'event-listeners'),
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
		(TEXTNS,u'list'),
		(TEXTNS,u'p'),
	),
	(DRAWNS,u'contour-path') : (
	),
	(DRAWNS,u'contour-polygon') : (
	),
	(DRAWNS,u'control') : (
		(DRAWNS,u'glue-point'),
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
	),
	(DRAWNS,u'custom-shape') : (
		(DRAWNS,u'enhanced-geometry'),
		(DRAWNS,u'glue-point'),
		(OFFICENS,u'event-listeners'),
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
		(TEXTNS,u'list'),
		(TEXTNS,u'p'),
	),
# allowed_children
	(DRAWNS,u'ellipse') : (
		(DRAWNS,u'glue-point'),
		(OFFICENS,u'event-listeners'),
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
		(TEXTNS,u'list'),
		(TEXTNS,u'p'),
	),
	(DRAWNS,u'enhanced-geometry') : (
		(DRAWNS,u'equation'),
		(DRAWNS,u'handle'),
	),
	(DRAWNS,u'equation') : (
	),
# allowed_children
	(DRAWNS,u'fill-image') : (
	),
	(DRAWNS,u'floating-frame') : (
	),
	(DRAWNS,u'frame') : (
		(DRAWNS,u'applet'),
		(DRAWNS,u'contour-path'),
		(DRAWNS,u'contour-polygon'),
		(DRAWNS,u'floating-frame'),
		(DRAWNS,u'glue-point'),
		(DRAWNS,u'image'),
		(DRAWNS,u'image-map'),
		(DRAWNS,u'object'),
		(DRAWNS,u'object-ole'),
		(DRAWNS,u'plugin'),
		(DRAWNS,u'text-box'),
		(OFFICENS,u'event-listeners'),
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
	),
# allowed_children
	(DRAWNS,u'g') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'glue-point'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
		(OFFICENS,u'event-listeners'),
	),
	(DRAWNS,u'glue-point') : (
	),
	(DRAWNS,u'gradient') : (
	),
	(DRAWNS,u'handle') : (
	),
	(DRAWNS,u'hatch') : (
	),
# allowed_children
	(DRAWNS,u'image') : (
		(OFFICENS,u'binary-data'),
		(TEXTNS,u'list'),
		(TEXTNS,u'p'),
	),
	(DRAWNS,u'image-map') : (
		(DRAWNS,u'area-circle'),
		(DRAWNS,u'area-polygon'),
		(DRAWNS,u'area-rectangle'),
	),
	(DRAWNS,u'layer') : (
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
	),
	(DRAWNS,u'layer-set') : (
		(DRAWNS,u'layer'),
	),
	(DRAWNS,u'line') : (
		(DRAWNS,u'glue-point'),
		(OFFICENS,u'event-listeners'),
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
		(TEXTNS,u'list'),
		(TEXTNS,u'p'),
	),
	(DRAWNS,u'marker') : (
	),
	(DRAWNS,u'measure') : (
		(DRAWNS,u'glue-point'),
		(OFFICENS,u'event-listeners'),
		(TEXTNS,u'list'),
		(TEXTNS,u'p'),
		(SVGNS,u'title'),
		(SVGNS,u'desc'),
	),
	(DRAWNS,u'object') : (
		(MATHNS,u'math'),
		(OFFICENS,u'document'),
	),
# allowed_children
	(DRAWNS,u'object-ole') : (
		(OFFICENS,u'binary-data'),
	),
	(DRAWNS,u'opacity') : (
	),
	(DRAWNS,u'page') : (
		(ANIMNS,u'animate'),
		(ANIMNS,u'animateColor'),
		(ANIMNS,u'animateMotion'),
		(ANIMNS,u'animateTransform'),
		(ANIMNS,u'audio'),
		(ANIMNS,u'command'),
		(ANIMNS,u'iterate'),
		(ANIMNS,u'par'),
		(ANIMNS,u'seq'),
		(ANIMNS,u'set'),
		(ANIMNS,u'transitionFilter'),
		(DR3DNS,u'scene'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(OFFICENS,u'forms'),
		(PRESENTATIONNS,u'animations'),
		(PRESENTATIONNS,u'notes'),
	),
# allowed_children
	(DRAWNS,u'page-thumbnail') : (
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
	),
	(DRAWNS,u'param') : (
	),
	(DRAWNS,u'path') : (
		(DRAWNS,u'glue-point'),
		(OFFICENS,u'event-listeners'),
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
		(TEXTNS,u'list'),
		(TEXTNS,u'p'),
	),
	(DRAWNS,u'plugin') : (
		(DRAWNS,u'param'),
	),
	(DRAWNS,u'polygon') : (
		(DRAWNS,u'glue-point'),
		(OFFICENS,u'event-listeners'),
		(SVGNS,u'title'),
		(SVGNS,u'desc'),
		(TEXTNS,u'list'),
		(TEXTNS,u'p'),
	),
	(DRAWNS,u'polyline') : (
		(DRAWNS,u'glue-point'),
		(OFFICENS,u'event-listeners'),
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
		(TEXTNS,u'list'),
		(TEXTNS,u'p'),
	),
# allowed_children
	(DRAWNS,u'rect') : (
		(DRAWNS,u'glue-point'),
		(OFFICENS,u'event-listeners'),
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
		(TEXTNS,u'list'),
		(TEXTNS,u'p'),
	),
	(DRAWNS,u'regular-polygon') : (
		(DRAWNS,u'glue-point'),
		(OFFICENS,u'event-listeners'),
		(SVGNS,u'desc'),
		(SVGNS,u'title'),
		(TEXTNS,u'list'),
		(TEXTNS,u'p'),
	),
	(DRAWNS,u'stroke-dash') : (
	),
	(DRAWNS,u'text-box') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'a'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(TABLENS,u'table'),
		(TEXTNS,u'alphabetical-index'),
		(TEXTNS,u'bibliography'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'h'),
		(TEXTNS,u'illustration-index'),
		(TEXTNS,u'list'),
		(TEXTNS,u'numbered-paragraph'),
		(TEXTNS,u'object-index'),
		(TEXTNS,u'p'),
		(TEXTNS,u'section'),
		(TEXTNS,u'soft-page-break'),
		(TEXTNS,u'table-index'),
		(TEXTNS,u'table-of-content'),
		(TEXTNS,u'user-index'),
	),
# allowed_children
	(FORMNS,u'button') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'checkbox') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'column') : (
		(FORMNS,u'checkbox'),
		(FORMNS,u'combobox'),
		(FORMNS,u'date'),
		(FORMNS,u'formatted-text'),
		(FORMNS,u'listbox'),
		(FORMNS,u'number'),
		(FORMNS,u'text'),
		(FORMNS,u'textarea'),
	),
	(FORMNS,u'combobox') : (
		(FORMNS,u'item'),
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'connection-resource') : (
	),
	(FORMNS,u'date') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'file') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'fixed-text') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
# allowed_children
	(FORMNS,u'form') : (
		(FORMNS,u'button'),
		(FORMNS,u'checkbox'),
		(FORMNS,u'combobox'),
		(FORMNS,u'connection-resource'),
		(FORMNS,u'date'),
		(FORMNS,u'file'),
		(FORMNS,u'fixed-text'),
		(FORMNS,u'form'),
		(FORMNS,u'formatted-text'),
		(FORMNS,u'frame'),
		(FORMNS,u'generic-control'),
		(FORMNS,u'grid'),
		(FORMNS,u'hidden'),
		(FORMNS,u'image'),
		(FORMNS,u'image-frame'),
		(FORMNS,u'listbox'),
		(FORMNS,u'number'),
		(FORMNS,u'password'),
		(FORMNS,u'properties'),
		(FORMNS,u'radio'),
		(FORMNS,u'text'),
		(FORMNS,u'textarea'),
		(FORMNS,u'time'),
		(FORMNS,u'value-range'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'formatted-text') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'frame') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'generic-control') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'grid') : (
		(FORMNS,u'column'),
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'hidden') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'image') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
# allowed_children
	(FORMNS,u'image-frame') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'item') : (
	),
	(FORMNS,u'list-property') : (
		(FORMNS,u'list-value'),
		(FORMNS,u'list-value'),
		(FORMNS,u'list-value'),
		(FORMNS,u'list-value'),
		(FORMNS,u'list-value'),
		(FORMNS,u'list-value'),
		(FORMNS,u'list-value'),
	),
	(FORMNS,u'list-value') : (
	),
	(FORMNS,u'listbox') : (
		(FORMNS,u'option'),
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'number') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'option') : (
	),
	(FORMNS,u'password') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'properties') : (
		(FORMNS,u'list-property'),
		(FORMNS,u'property'),
	),
	(FORMNS,u'property') : (
	),
	(FORMNS,u'radio') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'text') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'textarea') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
		(TEXTNS,u'p'),
	),
	(FORMNS,u'time') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(FORMNS,u'value-range') : (
		(FORMNS,u'properties'),
		(OFFICENS,u'event-listeners'),
	),
	(METANS,u'auto-reload') : (
	),
	(METANS,u'creation-date') : (
	),
	(METANS,u'date-string') : (
	),
	(METANS,u'document-statistic') : (
	),
	(METANS,u'editing-cycles') : (
	),
	(METANS,u'editing-duration') : (
	),
	(METANS,u'generator') : (
	),
	(METANS,u'hyperlink-behaviour') : (
	),
	(METANS,u'initial-creator') : (
	),
	(METANS,u'keyword') : (
	),
	(METANS,u'print-date') : (
	),
	(METANS,u'printed-by') : (
	),
	(METANS,u'template') : (
	),
	(METANS,u'user-defined') : (
	),
# allowed_children
	(OFFICENS,u'annotation') : (
		(DCNS,u'creator'),
		(DCNS,u'date'),
		(METANS,u'date-string'),
		(TEXTNS,u'list'),
		(TEXTNS,u'p'),
	),
	(OFFICENS,u'automatic-styles') : (
		(NUMBERNS,u'boolean-style'),
		(NUMBERNS,u'currency-style'),
		(NUMBERNS,u'date-style'),
		(NUMBERNS,u'number-style'),
		(NUMBERNS,u'percentage-style'),
		(NUMBERNS,u'text-style'),
		(NUMBERNS,u'time-style'),
		(STYLENS,u'page-layout'),
		(STYLENS,u'style'),
		(TEXTNS,u'list-style'),
	),
	(OFFICENS,u'binary-data') : (
	),
	(OFFICENS,u'body') : (
		(OFFICENS,u'chart'),
		(OFFICENS,u'drawing'),
		(OFFICENS,u'image'),
		(OFFICENS,u'presentation'),
		(OFFICENS,u'spreadsheet'),
		(OFFICENS,u'text'),
	),
	(OFFICENS,u'change-info') : (
		(DCNS,u'creator'),
		(DCNS,u'date'),
		(TEXTNS,u'p'),
	),
	(OFFICENS,u'chart') : (
		(CHARTNS,u'chart'),
		(TABLENS,u'calculation-settings'),
		(TABLENS,u'consolidation'),
		(TABLENS,u'content-validations'),
		(TABLENS,u'data-pilot-tables'),
		(TABLENS,u'database-ranges'),
		(TABLENS,u'dde-links'),
		(TABLENS,u'label-ranges'),
		(TABLENS,u'named-expressions'),
		(TEXTNS,u'alphabetical-index-auto-mark-file'),
		(TEXTNS,u'dde-connection-decls'),
		(TEXTNS,u'sequence-decls'),
		(TEXTNS,u'user-field-decls'),
		(TEXTNS,u'variable-decls'),
	),
	(OFFICENS,u'dde-source') : (
	),
	(OFFICENS,u'document') : (
		(OFFICENS,u'automatic-styles'),
		(OFFICENS,u'body'),
		(OFFICENS,u'font-face-decls'),
		(OFFICENS,u'master-styles'),
		(OFFICENS,u'meta'),
		(OFFICENS,u'scripts'),
		(OFFICENS,u'settings'),
		(OFFICENS,u'styles'),
	),
	(OFFICENS,u'document-content') : (
		(OFFICENS,u'automatic-styles'),
		(OFFICENS,u'body'),
		(OFFICENS,u'font-face-decls'),
		(OFFICENS,u'scripts'),
	),
	(OFFICENS,u'document-meta') : (
		(OFFICENS,u'meta'),
	),
	(OFFICENS,u'document-settings') : (
		(OFFICENS,u'settings'),
	),
	(OFFICENS,u'document-styles') : (
		(OFFICENS,u'automatic-styles'),
		(OFFICENS,u'font-face-decls'),
		(OFFICENS,u'master-styles'),
		(OFFICENS,u'styles'),
	),
	(OFFICENS,u'drawing') : (
		(DRAWNS,u'page'),
		(TABLENS,u'calculation-settings'),
		(TABLENS,u'consolidation'),
		(TABLENS,u'content-validations'),
		(TABLENS,u'data-pilot-tables'),
		(TABLENS,u'database-ranges'),
		(TABLENS,u'dde-links'),
		(TABLENS,u'label-ranges'),
		(TABLENS,u'named-expressions'),
		(TEXTNS,u'alphabetical-index-auto-mark-file'),
		(TEXTNS,u'dde-connection-decls'),
		(TEXTNS,u'sequence-decls'),
		(TEXTNS,u'user-field-decls'),
		(TEXTNS,u'variable-decls'),
	),
	(OFFICENS,u'event-listeners') : (
		(PRESENTATIONNS,u'event-listener'),
		(SCRIPTNS,u'event-listener'),
	),
	(OFFICENS,u'font-face-decls') : (
		(STYLENS,u'font-face'),
	),
# allowed_children
	(OFFICENS,u'forms') : (
		(XFORMSNS,u'model'),
		(FORMNS,u'form'),
	),
	(OFFICENS,u'image') : (
		(DRAWNS,u'frame'),
	),
	(OFFICENS,u'master-styles') : (
		(DRAWNS,u'layer-set'),
		(STYLENS,u'handout-master'),
		(STYLENS,u'master-page'),
		(TABLENS,u'table-template'),
	),
	(OFFICENS,u'meta') : (
		(DCNS,u'creator'),
		(DCNS,u'date'),
		(DCNS,u'description'),
		(DCNS,u'language'),
		(DCNS,u'subject'),
		(DCNS,u'title'),
# Completes Dublin Core start
#		(DCNS,'contributor'),
#		(DCNS,'coverage'),
#		(DCNS,'format'),
#		(DCNS,'identifier'),
#		(DCNS,'publisher'),
#		(DCNS,'relation'),
#		(DCNS,'rights'),
#		(DCNS,'source'),
#		(DCNS,'type'),
# Completes Dublin Core end
		(METANS,u'auto-reload'),
		(METANS,u'creation-date'),
		(METANS,u'document-statistic'),
		(METANS,u'editing-cycles'),
		(METANS,u'editing-duration'),
		(METANS,u'generator'),
		(METANS,u'hyperlink-behaviour'),
		(METANS,u'initial-creator'),
		(METANS,u'keyword'),
		(METANS,u'print-date'),
		(METANS,u'printed-by'),
		(METANS,u'template'),
		(METANS,u'user-defined'),
	),
	(OFFICENS,u'presentation') : (
		(DRAWNS,u'page'),
		(PRESENTATIONNS,u'date-time-decl'),
		(PRESENTATIONNS,u'footer-decl'),
		(PRESENTATIONNS,u'header-decl'),
		(PRESENTATIONNS,u'settings'),
		(TABLENS,u'calculation-settings'),
		(TABLENS,u'consolidation'),
		(TABLENS,u'content-validations'),
		(TABLENS,u'data-pilot-tables'),
		(TABLENS,u'database-ranges'),
		(TABLENS,u'dde-links'),
		(TABLENS,u'label-ranges'),
		(TABLENS,u'named-expressions'),
		(TEXTNS,u'alphabetical-index-auto-mark-file'),
		(TEXTNS,u'dde-connection-decls'),
		(TEXTNS,u'sequence-decls'),
		(TEXTNS,u'user-field-decls'),
		(TEXTNS,u'variable-decls'),
	),
# allowed_children
	(OFFICENS,u'script') : None,

	(OFFICENS,u'scripts') : (
		(OFFICENS,u'event-listeners'),
		(OFFICENS,u'script'),
	),
	(OFFICENS,u'settings') : (
		(CONFIGNS,u'config-item-set'),
	),
	(OFFICENS,u'spreadsheet') : (
		(TABLENS,u'calculation-settings'),
		(TABLENS,u'consolidation'),
		(TABLENS,u'content-validations'),
		(TABLENS,u'data-pilot-tables'),
		(TABLENS,u'database-ranges'),
		(TABLENS,u'dde-links'),
		(TABLENS,u'label-ranges'),
		(TABLENS,u'named-expressions'),
		(TABLENS,u'table'),
		(TABLENS,u'tracked-changes'),
		(TEXTNS,u'alphabetical-index-auto-mark-file'),
		(TEXTNS,u'dde-connection-decls'),
		(TEXTNS,u'sequence-decls'),
		(TEXTNS,u'user-field-decls'),
		(TEXTNS,u'variable-decls'),
	),
	(OFFICENS,u'styles') : (
		(NUMBERNS,u'boolean-style'),
		(NUMBERNS,u'currency-style'),
		(NUMBERNS,u'date-style'),
		(NUMBERNS,u'number-style'),
		(NUMBERNS,u'percentage-style'),
		(NUMBERNS,u'text-style'),
		(NUMBERNS,u'time-style'),
		(DRAWNS,u'fill-image'),
		(DRAWNS,u'gradient'),
		(DRAWNS,u'hatch'),
		(DRAWNS,u'marker'),
		(DRAWNS,u'opacity'),
		(DRAWNS,u'stroke-dash'),
		(STYLENS,u'default-style'),
		(STYLENS,u'presentation-page-layout'),
		(STYLENS,u'style'),
		(SVGNS,u'linearGradient'),
		(SVGNS,u'radialGradient'),
		(TEXTNS,u'bibliography-configuration'),
		(TEXTNS,u'linenumbering-configuration'),
		(TEXTNS,u'list-style'),
		(TEXTNS,u'notes-configuration'),
		(TEXTNS,u'outline-style'),
	),
	(OFFICENS,u'text') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'a'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(OFFICENS,u'forms'),
		(TABLENS,u'calculation-settings'),
		(TABLENS,u'consolidation'),
		(TABLENS,u'content-validations'),
		(TABLENS,u'data-pilot-tables'),
		(TABLENS,u'database-ranges'),
		(TABLENS,u'dde-links'),
		(TABLENS,u'label-ranges'),
		(TABLENS,u'named-expressions'),
		(TABLENS,u'table'),
		(TEXTNS,u'alphabetical-index'),
		(TEXTNS,u'alphabetical-index-auto-mark-file'),
		(TEXTNS,u'bibliography'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'dde-connection-decls'),
		(TEXTNS,u'h'),
		(TEXTNS,u'illustration-index'),
		(TEXTNS,u'list'),
		(TEXTNS,u'numbered-paragraph'),
		(TEXTNS,u'object-index'),
		(TEXTNS,u'p'),
		(TEXTNS,u'page-sequence'),
		(TEXTNS,u'section'),
		(TEXTNS,u'sequence-decls'),
		(TEXTNS,u'soft-page-break'),
		(TEXTNS,u'table-index'),
		(TEXTNS,u'table-of-content'),
		(TEXTNS,u'tracked-changes'),
		(TEXTNS,u'user-field-decls'),
		(TEXTNS,u'user-index'),
		(TEXTNS,u'variable-decls'),
	),
	(PRESENTATIONNS,u'animation-group') : (
		(PRESENTATIONNS,u'dim'),
		(PRESENTATIONNS,u'hide-shape'),
		(PRESENTATIONNS,u'hide-text'),
		(PRESENTATIONNS,u'play'),
		(PRESENTATIONNS,u'show-shape'),
		(PRESENTATIONNS,u'show-text'),
	),
	(PRESENTATIONNS,u'animations') : (
		(PRESENTATIONNS,u'animation-group'),
		(PRESENTATIONNS,u'dim'),
		(PRESENTATIONNS,u'hide-shape'),
		(PRESENTATIONNS,u'hide-text'),
		(PRESENTATIONNS,u'play'),
		(PRESENTATIONNS,u'show-shape'),
		(PRESENTATIONNS,u'show-text'),
	),
	(PRESENTATIONNS,u'date-time') : (
	),
	(PRESENTATIONNS,u'date-time-decl') : (
	),
	(PRESENTATIONNS,u'dim') : (
		(PRESENTATIONNS,u'sound'),
	),
	(PRESENTATIONNS,u'event-listener') : (
		(PRESENTATIONNS,u'sound'),
	),
	(PRESENTATIONNS,u'footer') : (
	),
	(PRESENTATIONNS,u'footer-decl') : (
	),
	(PRESENTATIONNS,u'header') : (
	),
	(PRESENTATIONNS,u'header-decl') : (
	),
	(PRESENTATIONNS,u'hide-shape') : (
		(PRESENTATIONNS,u'sound'),
	),
	(PRESENTATIONNS,u'hide-text') : (
		(PRESENTATIONNS,u'sound'),
	),
# allowed_children
	(PRESENTATIONNS,u'notes') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(OFFICENS,u'forms'),
	),
	(PRESENTATIONNS,u'placeholder') : (
	),
	(PRESENTATIONNS,u'play') : (
	),
	(PRESENTATIONNS,u'settings') : (
		(PRESENTATIONNS,u'show'),
	),
	(PRESENTATIONNS,u'show') : (
	),
	(PRESENTATIONNS,u'show-shape') : (
		(PRESENTATIONNS,u'sound'),
	),
	(PRESENTATIONNS,u'show-text') : (
		(PRESENTATIONNS,u'sound'),
	),
	(PRESENTATIONNS,u'sound') : (
	),
	(SCRIPTNS,u'event-listener') : (
	),
	(STYLENS,u'background-image') : (
		(OFFICENS,u'binary-data'),
	),
	(STYLENS,u'chart-properties') : (
		(CHARTNS,u'symbol-image'),
	),
	(STYLENS,u'column') : (
	),
	(STYLENS,u'column-sep') : (
	),
	(STYLENS,u'columns') : (
		(STYLENS,u'column'),
		(STYLENS,u'column-sep'),
	),
	(STYLENS,u'default-style') : (
		(STYLENS,u'chart-properties'),
		(STYLENS,u'drawing-page-properties'),
		(STYLENS,u'graphic-properties'),
		(STYLENS,u'paragraph-properties'),
		(STYLENS,u'ruby-properties'),
		(STYLENS,u'section-properties'),
		(STYLENS,u'table-cell-properties'),
		(STYLENS,u'table-column-properties'),
		(STYLENS,u'table-properties'),
		(STYLENS,u'table-row-properties'),
		(STYLENS,u'text-properties'),
	),
	(STYLENS,u'drawing-page-properties') : (
		(PRESENTATIONNS,u'sound'),
	),
	(STYLENS,u'drop-cap') : (
	),
	(STYLENS,u'font-face') : (
		(SVGNS,u'definition-src'),
		(SVGNS,u'font-face-src'),
	),
	(STYLENS,u'footer') : (
		(STYLENS,u'region-center'),
		(STYLENS,u'region-left'),
		(STYLENS,u'region-right'),
		(TABLENS,u'table'),
		(TEXTNS,u'alphabetical-index'),
		(TEXTNS,u'alphabetical-index-auto-mark-file'),
		(TEXTNS,u'bibliography'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'dde-connection-decls'),
		(TEXTNS,u'h'),
		(TEXTNS,u'illustration-index'),
		(TEXTNS,u'index-title'),
		(TEXTNS,u'list'),
		(TEXTNS,u'object-index'),
		(TEXTNS,u'p'),
		(TEXTNS,u'section'),
		(TEXTNS,u'sequence-decls'),
		(TEXTNS,u'table-index'),
		(TEXTNS,u'table-of-content'),
		(TEXTNS,u'tracked-changes'),
		(TEXTNS,u'user-field-decls'),
		(TEXTNS,u'user-index'),
		(TEXTNS,u'variable-decls'),
	),
# allowed_children
	(STYLENS,u'footer-left') : (
		(STYLENS,u'region-center'),
		(STYLENS,u'region-left'),
		(STYLENS,u'region-right'),
		(TABLENS,u'table'),
		(TEXTNS,u'alphabetical-index'),
		(TEXTNS,u'alphabetical-index-auto-mark-file'),
		(TEXTNS,u'bibliography'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'dde-connection-decls'),
		(TEXTNS,u'h'),
		(TEXTNS,u'illustration-index'),
		(TEXTNS,u'index-title'),
		(TEXTNS,u'list'),
		(TEXTNS,u'object-index'),
		(TEXTNS,u'p'),
		(TEXTNS,u'section'),
		(TEXTNS,u'sequence-decls'),
		(TEXTNS,u'table-index'),
		(TEXTNS,u'table-of-content'),
		(TEXTNS,u'tracked-changes'),
		(TEXTNS,u'user-field-decls'),
		(TEXTNS,u'user-index'),
		(TEXTNS,u'variable-decls'),
	),
	(STYLENS,u'footer-style') : (
		(STYLENS,u'header-footer-properties'),
	),
	(STYLENS,u'footnote-sep') : (
	),
	(STYLENS,u'graphic-properties') : (
		(STYLENS,u'background-image'),
		(STYLENS,u'columns'),
		(TEXTNS,u'list-style'),
	),
# allowed_children
	(STYLENS,u'handout-master') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
	),
	(STYLENS,u'header') : (
		(STYLENS,u'region-center'),
		(STYLENS,u'region-left'),
		(STYLENS,u'region-right'),
		(TABLENS,u'table'),
		(TEXTNS,u'alphabetical-index'),
		(TEXTNS,u'alphabetical-index-auto-mark-file'),
		(TEXTNS,u'bibliography'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'dde-connection-decls'),
		(TEXTNS,u'h'),
		(TEXTNS,u'illustration-index'),
		(TEXTNS,u'index-title'),
		(TEXTNS,u'list'),
		(TEXTNS,u'object-index'),
		(TEXTNS,u'p'),
		(TEXTNS,u'section'),
		(TEXTNS,u'sequence-decls'),
		(TEXTNS,u'table-index'),
		(TEXTNS,u'table-of-content'),
		(TEXTNS,u'tracked-changes'),
		(TEXTNS,u'user-field-decls'),
		(TEXTNS,u'user-index'),
		(TEXTNS,u'variable-decls'),
	),
# allowed_children
	(STYLENS,u'header-footer-properties') : (
		(STYLENS,u'background-image'),
	),
	(STYLENS,u'header-left') : (
		(STYLENS,u'region-center'),
		(STYLENS,u'region-left'),
		(STYLENS,u'region-right'),
		(TABLENS,u'table'),
		(TEXTNS,u'alphabetical-index'),
		(TEXTNS,u'alphabetical-index-auto-mark-file'),
		(TEXTNS,u'bibliography'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'dde-connection-decls'),
		(TEXTNS,u'h'),
		(TEXTNS,u'illustration-index'),
		(TEXTNS,u'index-title'),
		(TEXTNS,u'list'),
		(TEXTNS,u'object-index'),
		(TEXTNS,u'p'),
		(TEXTNS,u'section'),
		(TEXTNS,u'sequence-decls'),
		(TEXTNS,u'table-index'),
		(TEXTNS,u'table-of-content'),
		(TEXTNS,u'tracked-changes'),
		(TEXTNS,u'user-field-decls'),
		(TEXTNS,u'user-index'),
		(TEXTNS,u'variable-decls'),
	),
	(STYLENS,u'header-style') : (
		(STYLENS,u'header-footer-properties'),
	),
	(STYLENS,u'list-level-properties') : (
	),
	(STYLENS,u'map') : (
	),
	(STYLENS,u'master-page') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(OFFICENS,u'forms'),
		(PRESENTATIONNS,u'notes'),
		(STYLENS,u'footer'),
		(STYLENS,u'footer-left'),
		(STYLENS,u'header'),
		(STYLENS,u'header-left'),
		(STYLENS,u'style'),
	),
	(STYLENS,u'page-layout') : (
		(STYLENS,u'footer-style'),
		(STYLENS,u'header-style'),
		(STYLENS,u'page-layout-properties'),
	),
	(STYLENS,u'page-layout-properties') : (
		(STYLENS,u'background-image'),
		(STYLENS,u'columns'),
		(STYLENS,u'footnote-sep'),
	),
# allowed_children
	(STYLENS,u'paragraph-properties') : (
		(STYLENS,u'background-image'),
		(STYLENS,u'drop-cap'),
		(STYLENS,u'tab-stops'),
	),
	(STYLENS,u'presentation-page-layout') : (
		(PRESENTATIONNS,u'placeholder'),
	),
	(STYLENS,u'region-center') : (
		(TEXTNS,u'p'),
	),
	(STYLENS,u'region-left') : (
		(TEXTNS,u'p'),
	),
	(STYLENS,u'region-right') : (
		(TEXTNS,u'p'),
	),
	(STYLENS,u'ruby-properties') : (
	),
	(STYLENS,u'section-properties') : (
		(STYLENS,u'background-image'),
		(STYLENS,u'columns'),
		(TEXTNS,u'notes-configuration'),
	),
	(STYLENS,u'style') : (
		(STYLENS,u'chart-properties'),
		(STYLENS,u'drawing-page-properties'),
		(STYLENS,u'graphic-properties'),
		(STYLENS,u'map'),
		(STYLENS,u'paragraph-properties'),
		(STYLENS,u'ruby-properties'),
		(STYLENS,u'section-properties'),
		(STYLENS,u'table-cell-properties'),
		(STYLENS,u'table-column-properties'),
		(STYLENS,u'table-properties'),
		(STYLENS,u'table-row-properties'),
		(STYLENS,u'text-properties'),
	),
	(STYLENS,u'tab-stop') : (
	),
	(STYLENS,u'tab-stops') : (
		(STYLENS,u'tab-stop'),
	),
# allowed_children
	(STYLENS,u'table-cell-properties') : (
		(STYLENS,u'background-image'),
	),
	(STYLENS,u'table-column-properties') : (
	),
	(STYLENS,u'table-properties') : (
		(STYLENS,u'background-image'),
	),
	(STYLENS,u'table-row-properties') : (
		(STYLENS,u'background-image'),
	),
	(STYLENS,u'text-properties') : (
	),
	(SVGNS,u'definition-src') : (
	),
	(SVGNS,u'desc') : (
	),
	(SVGNS,u'font-face-format') : (
	),
	(SVGNS,u'font-face-name') : (
	),
	(SVGNS,u'font-face-src') : (
		(SVGNS,u'font-face-name'),
		(SVGNS,u'font-face-uri'),
	),
	(SVGNS,u'font-face-uri') : (
		(SVGNS,u'font-face-format'),
	),
	(SVGNS,u'linearGradient') : (
		(SVGNS,u'stop'),
	),
	(SVGNS,u'radialGradient') : (
		(SVGNS,u'stop'),
	),
	(SVGNS,u'stop') : (
	),
	(SVGNS,u'title') : (
	),
	(TABLENS,u'body') : (
	),
	(TABLENS,u'calculation-settings') : (
		(TABLENS,u'iteration'),
		(TABLENS,u'null-date'),
	),
# allowed_children
	(TABLENS,u'cell-address') : (
	),
	(TABLENS,u'cell-content-change') : (
		(OFFICENS,u'change-info'),
		(TABLENS,u'cell-address'),
		(TABLENS,u'deletions'),
		(TABLENS,u'dependencies'),
		(TABLENS,u'previous'),
	),
	(TABLENS,u'cell-content-deletion') : (
		(TABLENS,u'cell-address'),
		(TABLENS,u'change-track-table-cell'),
	),
	(TABLENS,u'cell-range-source') : (
	),
	(TABLENS,u'change-deletion') : (
	),
	(TABLENS,u'change-track-table-cell') : (
		(TEXTNS,u'p'),
	),
	(TABLENS,u'consolidation') : (
	),
	(TABLENS,u'content-validation') : (
		(OFFICENS,u'event-listeners'),
		(TABLENS,u'error-macro'),
		(TABLENS,u'error-message'),
		(TABLENS,u'help-message'),
	),
# allowed_children
	(TABLENS,u'content-validations') : (
		(TABLENS,u'content-validation'),
	),
	(TABLENS,u'covered-table-cell') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'a'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(OFFICENS,u'annotation'),
		(TABLENS,u'cell-range-source'),
		(TABLENS,u'detective'),
		(TABLENS,u'table'),
		(TEXTNS,u'alphabetical-index'),
		(TEXTNS,u'bibliography'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'h'),
		(TEXTNS,u'illustration-index'),
		(TEXTNS,u'list'),
		(TEXTNS,u'numbered-paragraph'),
		(TEXTNS,u'object-index'),
		(TEXTNS,u'p'),
		(TEXTNS,u'section'),
		(TEXTNS,u'soft-page-break'),
		(TEXTNS,u'table-index'),
		(TEXTNS,u'table-of-content'),
		(TEXTNS,u'user-index'),
	),
# allowed_children
	(TABLENS,u'cut-offs') : (
		(TABLENS,u'insertion-cut-off'),
		(TABLENS,u'movement-cut-off'),
	),
	(TABLENS,u'data-pilot-display-info') : (
	),
	(TABLENS,u'data-pilot-field') : (
		(TABLENS,u'data-pilot-field-reference'),
		(TABLENS,u'data-pilot-groups'),
		(TABLENS,u'data-pilot-level'),
	),
	(TABLENS,u'data-pilot-field-reference') : (
	),
	(TABLENS,u'data-pilot-group') : (
		(TABLENS,u'data-pilot-group-member'),
	),
	(TABLENS,u'data-pilot-group-member') : (
	),
	(TABLENS,u'data-pilot-groups') : (
		(TABLENS,u'data-pilot-group'),
	),
	(TABLENS,u'data-pilot-layout-info') : (
	),
	(TABLENS,u'data-pilot-level') : (
		(TABLENS,u'data-pilot-display-info'),
		(TABLENS,u'data-pilot-layout-info'),
		(TABLENS,u'data-pilot-members'),
		(TABLENS,u'data-pilot-sort-info'),
		(TABLENS,u'data-pilot-subtotals'),
	),
	(TABLENS,u'data-pilot-member') : (
	),
	(TABLENS,u'data-pilot-members') : (
		(TABLENS,u'data-pilot-member'),
	),
	(TABLENS,u'data-pilot-sort-info') : (
	),
	(TABLENS,u'data-pilot-subtotal') : (
	),
	(TABLENS,u'data-pilot-subtotals') : (
		(TABLENS,u'data-pilot-subtotal'),
	),
# allowed_children
	(TABLENS,u'data-pilot-table') : (
		(TABLENS,u'data-pilot-field'),
		(TABLENS,u'database-source-query'),
		(TABLENS,u'database-source-sql'),
		(TABLENS,u'database-source-table'),
		(TABLENS,u'source-cell-range'),
		(TABLENS,u'source-service'),
	),
	(TABLENS,u'data-pilot-tables') : (
		(TABLENS,u'data-pilot-table'),
	),
	(TABLENS,u'database-range') : (
		(TABLENS,u'database-source-query'),
		(TABLENS,u'database-source-sql'),
		(TABLENS,u'database-source-table'),
		(TABLENS,u'filter'),
		(TABLENS,u'sort'),
		(TABLENS,u'subtotal-rules'),
	),
	(TABLENS,u'database-ranges') : (
		(TABLENS,u'database-range'),
	),
	(TABLENS,u'database-source-query') : (
	),
	(TABLENS,u'database-source-sql') : (
	),
	(TABLENS,u'database-source-table') : (
	),
# allowed_children
	(TABLENS,u'dde-link') : (
		(OFFICENS,u'dde-source'),
		(TABLENS,u'table'),
	),
	(TABLENS,u'dde-links') : (
		(TABLENS,u'dde-link'),
	),
	(TABLENS,u'deletion') : (
		(OFFICENS,u'change-info'),
		(TABLENS,u'cut-offs'),
		(TABLENS,u'deletions'),
		(TABLENS,u'dependencies'),
	),
	(TABLENS,u'deletions') : (
		(TABLENS,u'cell-content-deletion'),
		(TABLENS,u'change-deletion'),
	),
	(TABLENS,u'dependencies') : (
		(TABLENS,u'dependency'),
	),
	(TABLENS,u'dependency') : (
	),
	(TABLENS,u'detective') : (
		(TABLENS,u'highlighted-range'),
		(TABLENS,u'operation'),
	),
# allowed_children
	(TABLENS,u'error-macro') : (
	),
	(TABLENS,u'error-message') : (
		(TEXTNS,u'p'),
	),
	(TABLENS,u'even-columns') : (
	),
	(TABLENS,u'even-rows') : (
	),
	(TABLENS,u'filter') : (
		(TABLENS,u'filter-and'),
		(TABLENS,u'filter-condition'),
		(TABLENS,u'filter-or'),
	),
	(TABLENS,u'filter-and') : (
		(TABLENS,u'filter-condition'),
		(TABLENS,u'filter-or'),
	),
	(TABLENS,u'filter-condition') : (
	),
	(TABLENS,u'filter-or') : (
		(TABLENS,u'filter-and'),
		(TABLENS,u'filter-condition'),
	),
# allowed_children
	(TABLENS,u'first-column') : (
	),
	(TABLENS,u'first-row') : (
	),
	(TABLENS,u'help-message') : (
		(TEXTNS,u'p'),
	),
	(TABLENS,u'highlighted-range') : (
	),
	(TABLENS,u'insertion') : (
		(OFFICENS,u'change-info'),
		(TABLENS,u'deletions'),
		(TABLENS,u'dependencies'),
	),
	(TABLENS,u'insertion-cut-off') : (
	),
	(TABLENS,u'iteration') : (
	),
	(TABLENS,u'label-range') : (
	),
	(TABLENS,u'label-ranges') : (
		(TABLENS,u'label-range'),
	),
	(TABLENS,u'last-column') : (
	),
	(TABLENS,u'last-row') : (
	),
	(TABLENS,u'movement') : (
		(OFFICENS,u'change-info'),
		(TABLENS,u'deletions'),
		(TABLENS,u'dependencies'),
		(TABLENS,u'source-range-address'),
		(TABLENS,u'target-range-address'),
	),
	(TABLENS,u'movement-cut-off') : (
	),
	(TABLENS,u'named-expression') : (
	),
	(TABLENS,u'named-expressions') : (
		(TABLENS,u'named-expression'),
		(TABLENS,u'named-range'),
	),
# allowed_children
	(TABLENS,u'named-range') : (
	),
	(TABLENS,u'null-date') : (
	),
	(TABLENS,u'odd-columns') : (
	),
	(TABLENS,u'odd-rows') : (
	),
	(TABLENS,u'operation') : (
	),
	(TABLENS,u'previous') : (
		(TABLENS,u'change-track-table-cell'),
	),
	(TABLENS,u'scenario') : (
	),
	(TABLENS,u'shapes') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
	),
# allowed_children
	(TABLENS,u'sort') : (
		(TABLENS,u'sort-by'),
	),
	(TABLENS,u'sort-by') : (
	),
	(TABLENS,u'sort-groups') : (
	),
	(TABLENS,u'source-cell-range') : (
		(TABLENS,u'filter'),
	),
	(TABLENS,u'source-range-address') : (
	),
	(TABLENS,u'source-service') : (
	),
	(TABLENS,u'subtotal-field') : (
	),
	(TABLENS,u'subtotal-rule') : (
		(TABLENS,u'subtotal-field'),
	),
	(TABLENS,u'subtotal-rules') : (
		(TABLENS,u'sort-groups'),
		(TABLENS,u'subtotal-rule'),
	),
# allowed_children
	(TABLENS,u'table') : (
		(OFFICENS,u'dde-source'),
		(OFFICENS,u'forms'),
		(TEXTNS,u'soft-page-break'),
		(TABLENS,u'scenario'),
		(TABLENS,u'shapes'),
		(TABLENS,u'table-column'),
		(TABLENS,u'table-column-group'),
		(TABLENS,u'table-columns'),
		(TABLENS,u'table-header-columns'),
		(TABLENS,u'table-header-rows'),
		(TABLENS,u'table-row'),
		(TABLENS,u'table-row-group'),
		(TABLENS,u'table-rows'),
		(TABLENS,u'table-source'),
	),
	(TABLENS,u'table-cell') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'a'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(OFFICENS,u'annotation'),
		(TABLENS,u'cell-range-source'),
		(TABLENS,u'detective'),
		(TABLENS,u'table'),
		(TEXTNS,u'alphabetical-index'),
		(TEXTNS,u'bibliography'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'h'),
		(TEXTNS,u'illustration-index'),
		(TEXTNS,u'list'),
		(TEXTNS,u'numbered-paragraph'),
		(TEXTNS,u'object-index'),
		(TEXTNS,u'p'),
		(TEXTNS,u'section'),
		(TEXTNS,u'soft-page-break'),
		(TEXTNS,u'table-index'),
		(TEXTNS,u'table-of-content'),
		(TEXTNS,u'user-index'),
	),
# allowed_children
	(TABLENS,u'table-column') : (
	),
	(TABLENS,u'table-column-group') : (
		(TABLENS,u'table-column'),
		(TABLENS,u'table-column-group'),
		(TABLENS,u'table-columns'),
		(TABLENS,u'table-header-columns'),
	),
	(TABLENS,u'table-columns') : (
		(TABLENS,u'table-column'),
	),
	(TABLENS,u'table-header-columns') : (
		(TABLENS,u'table-column'),
	),
	(TABLENS,u'table-header-rows') : (
		(TABLENS,u'table-row'),
		(TEXTNS,u'soft-page-break'),
	),
	(TABLENS,u'table-row') : (
		(TABLENS,u'covered-table-cell'),
		(TABLENS,u'table-cell'),
	),
	(TABLENS,u'table-row-group') : (
		(TABLENS,u'table-header-rows'),
		(TABLENS,u'table-row'),
		(TABLENS,u'table-row-group'),
		(TABLENS,u'table-rows'),
		(TEXTNS,u'soft-page-break'),
	),
	(TABLENS,u'table-rows') : (
		(TABLENS,u'table-row'),
		(TEXTNS,u'soft-page-break'),
	),
# allowed_children
	(TABLENS,u'table-source') : (
	),
	(TABLENS,u'table-template') : (
		(TABLENS,u'body'),
		(TABLENS,u'even-columns'),
		(TABLENS,u'even-rows'),
		(TABLENS,u'first-column'),
		(TABLENS,u'first-row'),
		(TABLENS,u'last-column'),
		(TABLENS,u'last-row'),
		(TABLENS,u'odd-columns'),
		(TABLENS,u'odd-rows'),
	),
	(TABLENS,u'target-range-address') : (
	),
	(TABLENS,u'tracked-changes') : (
		(TABLENS,u'cell-content-change'),
		(TABLENS,u'deletion'),
		(TABLENS,u'insertion'),
		(TABLENS,u'movement'),
	),
# allowed_children
	(TEXTNS,u'a') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'a'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(OFFICENS,u'annotation'),
		(OFFICENS,u'event-listeners'),
		(PRESENTATIONNS,u'date-time'),
		(PRESENTATIONNS,u'footer'),
		(PRESENTATIONNS,u'header'),
		(TEXTNS,u'a'),
		(TEXTNS,u'alphabetical-index-mark'),
		(TEXTNS,u'alphabetical-index-mark-end'),
		(TEXTNS,u'alphabetical-index-mark-start'),
		(TEXTNS,u'author-initials'),
		(TEXTNS,u'author-name'),
		(TEXTNS,u'bibliography-mark'),
		(TEXTNS,u'bookmark'),
		(TEXTNS,u'bookmark-end'),
		(TEXTNS,u'bookmark-ref'),
		(TEXTNS,u'bookmark-start'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'chapter'),
		(TEXTNS,u'conditional-text'),
		(TEXTNS,u'creation-date'),
		(TEXTNS,u'creation-time'),
		(TEXTNS,u'creator'),
		(TEXTNS,u'database-display'),
		(TEXTNS,u'database-name'),
		(TEXTNS,u'database-next'),
		(TEXTNS,u'database-row-number'),
		(TEXTNS,u'database-row-select'),
		(TEXTNS,u'date'),
		(TEXTNS,u'dde-connection'),
		(TEXTNS,u'description'),
		(TEXTNS,u'editing-cycles'),
		(TEXTNS,u'editing-duration'),
		(TEXTNS,u'execute-macro'),
		(TEXTNS,u'expression'),
		(TEXTNS,u'file-name'),
		(TEXTNS,u'hidden-paragraph'),
		(TEXTNS,u'hidden-text'),
		(TEXTNS,u'initial-creator'),
		(TEXTNS,u'keywords'),
		(TEXTNS,u'line-break'),
		(TEXTNS,u'measure'),
		(TEXTNS,u'modification-date'),
		(TEXTNS,u'modification-time'),
		(TEXTNS,u'note'),
		(TEXTNS,u'note-ref'),
		(TEXTNS,u'page-count'),
		(TEXTNS,u'paragraph-count'),
		(TEXTNS,u'word-count'),
		(TEXTNS,u'character-count'),
		(TEXTNS,u'table-count'),
		(TEXTNS,u'image-count'),
		(TEXTNS,u'object-count'),
		(TEXTNS,u'page-continuation'),
		(TEXTNS,u'page-number'),
		(TEXTNS,u'page-variable-get'),
		(TEXTNS,u'page-variable-set'),
		(TEXTNS,u'placeholder'),
		(TEXTNS,u'print-date'),
		(TEXTNS,u'print-time'),
		(TEXTNS,u'printed-by'),
		(TEXTNS,u'reference-mark'),
		(TEXTNS,u'reference-mark-end'),
		(TEXTNS,u'reference-mark-start'),
		(TEXTNS,u'reference-ref'),
		(TEXTNS,u'ruby'),
		(TEXTNS,u's'),
		(TEXTNS,u'script'),
		(TEXTNS,u'sender-city'),
		(TEXTNS,u'sender-company'),
		(TEXTNS,u'sender-country'),
		(TEXTNS,u'sender-email'),
		(TEXTNS,u'sender-fax'),
		(TEXTNS,u'sender-firstname'),
		(TEXTNS,u'sender-initials'),
		(TEXTNS,u'sender-lastname'),
		(TEXTNS,u'sender-phone-private'),
		(TEXTNS,u'sender-phone-work'),
		(TEXTNS,u'sender-position'),
		(TEXTNS,u'sender-postal-code'),
		(TEXTNS,u'sender-state-or-province'),
		(TEXTNS,u'sender-street'),
		(TEXTNS,u'sender-title'),
		(TEXTNS,u'sequence'),
		(TEXTNS,u'sequence-ref'),
		(TEXTNS,u'sheet-name'),
		(TEXTNS,u'soft-page-break'),
		(TEXTNS,u'span'),
		(TEXTNS,u'subject'),
		(TEXTNS,u'tab'),
		(TEXTNS,u'table-formula'),
		(TEXTNS,u'template-name'),
		(TEXTNS,u'text-input'),
		(TEXTNS,u'time'),
		(TEXTNS,u'title'),
		(TEXTNS,u'toc-mark'),
		(TEXTNS,u'toc-mark-end'),
		(TEXTNS,u'toc-mark-start'),
		(TEXTNS,u'user-defined'),
		(TEXTNS,u'user-field-get'),
		(TEXTNS,u'user-field-input'),
		(TEXTNS,u'user-index-mark'),
		(TEXTNS,u'user-index-mark-end'),
		(TEXTNS,u'user-index-mark-start'),
		(TEXTNS,u'variable-get'),
		(TEXTNS,u'variable-input'),
		(TEXTNS,u'variable-set'),
	),
# allowed_children
	(TEXTNS,u'alphabetical-index') : (
		(TEXTNS,u'alphabetical-index-source'),
		(TEXTNS,u'index-body'),
	),
	(TEXTNS,u'alphabetical-index-auto-mark-file') : (
	),
	(TEXTNS,u'alphabetical-index-entry-template') : (
		(TEXTNS,u'index-entry-chapter'),
		(TEXTNS,u'index-entry-page-number'),
		(TEXTNS,u'index-entry-span'),
		(TEXTNS,u'index-entry-tab-stop'),
		(TEXTNS,u'index-entry-text'),
	),
	(TEXTNS,u'alphabetical-index-mark') : (
	),
	(TEXTNS,u'alphabetical-index-mark-end') : (
	),
	(TEXTNS,u'alphabetical-index-mark-start') : (
	),
	(TEXTNS,u'alphabetical-index-source') : (
		(TEXTNS,u'alphabetical-index-entry-template'),
		(TEXTNS,u'index-title-template'),
	),
	(TEXTNS,u'author-initials') : (
	),
	(TEXTNS,u'author-name') : (
	),
	(TEXTNS,u'bibliography') : (
		(TEXTNS,u'bibliography-source'),
		(TEXTNS,u'index-body'),
	),
	(TEXTNS,u'bibliography-configuration') : (
		(TEXTNS,u'sort-key'),
	),
	(TEXTNS,u'bibliography-entry-template') : (
		(TEXTNS,u'index-entry-bibliography'),
		(TEXTNS,u'index-entry-span'),
		(TEXTNS,u'index-entry-tab-stop'),
	),
# allowed_children
	(TEXTNS,u'bibliography-mark') : (
	),
	(TEXTNS,u'bibliography-source') : (
		(TEXTNS,u'bibliography-entry-template'),
		(TEXTNS,u'index-title-template'),
	),
	(TEXTNS,u'bookmark') : (
	),
	(TEXTNS,u'bookmark-end') : (
	),
	(TEXTNS,u'bookmark-ref') : (
	),
	(TEXTNS,u'bookmark-start') : (
	),
	(TEXTNS,u'change') : (
	),
	(TEXTNS,u'change-end') : (
	),
	(TEXTNS,u'change-start') : (
	),
	(TEXTNS,u'changed-region') : (
		(TEXTNS,u'deletion'),
		(TEXTNS,u'format-change'),
		(TEXTNS,u'insertion'),
	),
	(TEXTNS,u'chapter') : (
	),
	(TEXTNS,u'character-count') : (
	),
	(TEXTNS,u'conditional-text') : (
	),
	(TEXTNS,u'creation-date') : (
	),
	(TEXTNS,u'creation-time') : (
	),
	(TEXTNS,u'creator') : (
	),
	(TEXTNS,u'database-display') : (
		(FORMNS,u'connection-resource'),
	),
	(TEXTNS,u'database-name') : (
		(FORMNS,u'connection-resource'),
	),
	(TEXTNS,u'database-next') : (
		(FORMNS,u'connection-resource'),
	),
	(TEXTNS,u'database-row-number') : (
		(FORMNS,u'connection-resource'),
	),
	(TEXTNS,u'database-row-select') : (
		(FORMNS,u'connection-resource'),
	),
	(TEXTNS,u'date') : (
	),
	(TEXTNS,u'dde-connection') : (
	),
	(TEXTNS,u'dde-connection-decl') : (
	),
	(TEXTNS,u'dde-connection-decls') : (
		(TEXTNS,u'dde-connection-decl'),
	),
# allowed_children
	(TEXTNS,u'deletion') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'a'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(OFFICENS,u'change-info'),
		(TABLENS,u'table'),
		(TEXTNS,u'alphabetical-index'),
		(TEXTNS,u'bibliography'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'h'),
		(TEXTNS,u'illustration-index'),
		(TEXTNS,u'list'),
		(TEXTNS,u'numbered-paragraph'),
		(TEXTNS,u'object-index'),
		(TEXTNS,u'p'),
		(TEXTNS,u'section'),
		(TEXTNS,u'soft-page-break'),
		(TEXTNS,u'table-index'),
		(TEXTNS,u'table-of-content'),
		(TEXTNS,u'user-index'),
	),
	(TEXTNS,u'description') : (
	),
	(TEXTNS,u'editing-cycles') : (
	),
	(TEXTNS,u'editing-duration') : (
	),
	(TEXTNS,u'execute-macro') : (
		(OFFICENS,u'event-listeners'),
	),
	(TEXTNS,u'expression') : (
	),
	(TEXTNS,u'file-name') : (
	),
	(TEXTNS,u'format-change') : (
		(OFFICENS,u'change-info'),
	),
# allowed_children
	(TEXTNS,u'h') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'a'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(OFFICENS,u'annotation'),
		(PRESENTATIONNS,u'date-time'),
		(PRESENTATIONNS,u'footer'),
		(PRESENTATIONNS,u'header'),
		(TEXTNS,u'a'),
		(TEXTNS,u'alphabetical-index-mark'),
		(TEXTNS,u'alphabetical-index-mark-end'),
		(TEXTNS,u'alphabetical-index-mark-start'),
		(TEXTNS,u'author-initials'),
		(TEXTNS,u'author-name'),
		(TEXTNS,u'bibliography-mark'),
		(TEXTNS,u'bookmark'),
		(TEXTNS,u'bookmark-end'),
		(TEXTNS,u'bookmark-ref'),
		(TEXTNS,u'bookmark-start'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'chapter'),
		(TEXTNS,u'conditional-text'),
		(TEXTNS,u'creation-date'),
		(TEXTNS,u'creation-time'),
		(TEXTNS,u'creator'),
		(TEXTNS,u'database-display'),
		(TEXTNS,u'database-name'),
		(TEXTNS,u'database-next'),
		(TEXTNS,u'database-row-number'),
		(TEXTNS,u'database-row-select'),
		(TEXTNS,u'date'),
		(TEXTNS,u'dde-connection'),
		(TEXTNS,u'description'),
		(TEXTNS,u'editing-cycles'),
		(TEXTNS,u'editing-duration'),
		(TEXTNS,u'execute-macro'),
		(TEXTNS,u'expression'),
		(TEXTNS,u'file-name'),
		(TEXTNS,u'hidden-paragraph'),
		(TEXTNS,u'hidden-text'),
		(TEXTNS,u'initial-creator'),
		(TEXTNS,u'keywords'),
		(TEXTNS,u'line-break'),
		(TEXTNS,u'measure'),
		(TEXTNS,u'modification-date'),
		(TEXTNS,u'modification-time'),
		(TEXTNS,u'note'),
		(TEXTNS,u'note-ref'),
		(TEXTNS,u'number'),
		(TEXTNS,u'page-count'),
		(TEXTNS,u'paragraph-count'),
		(TEXTNS,u'word-count'),
		(TEXTNS,u'character-count'),
		(TEXTNS,u'table-count'),
		(TEXTNS,u'image-count'),
		(TEXTNS,u'object-count'),
		(TEXTNS,u'page-continuation'),
		(TEXTNS,u'page-number'),
		(TEXTNS,u'page-variable-get'),
		(TEXTNS,u'page-variable-set'),
		(TEXTNS,u'placeholder'),
		(TEXTNS,u'print-date'),
		(TEXTNS,u'print-time'),
		(TEXTNS,u'printed-by'),
		(TEXTNS,u'reference-mark'),
		(TEXTNS,u'reference-mark-end'),
		(TEXTNS,u'reference-mark-start'),
		(TEXTNS,u'reference-ref'),
		(TEXTNS,u'ruby'),
		(TEXTNS,u's'),
		(TEXTNS,u'script'),
		(TEXTNS,u'sender-city'),
		(TEXTNS,u'sender-company'),
		(TEXTNS,u'sender-country'),
		(TEXTNS,u'sender-email'),
		(TEXTNS,u'sender-fax'),
		(TEXTNS,u'sender-firstname'),
		(TEXTNS,u'sender-initials'),
		(TEXTNS,u'sender-lastname'),
		(TEXTNS,u'sender-phone-private'),
		(TEXTNS,u'sender-phone-work'),
		(TEXTNS,u'sender-position'),
		(TEXTNS,u'sender-postal-code'),
		(TEXTNS,u'sender-state-or-province'),
		(TEXTNS,u'sender-street'),
		(TEXTNS,u'sender-title'),
		(TEXTNS,u'sequence'),
		(TEXTNS,u'sequence-ref'),
		(TEXTNS,u'sheet-name'),
		(TEXTNS,u'soft-page-break'),
		(TEXTNS,u'span'),
		(TEXTNS,u'subject'),
		(TEXTNS,u'tab'),
		(TEXTNS,u'table-formula'),
		(TEXTNS,u'template-name'),
		(TEXTNS,u'text-input'),
		(TEXTNS,u'time'),
		(TEXTNS,u'title'),
		(TEXTNS,u'toc-mark'),
		(TEXTNS,u'toc-mark-end'),
		(TEXTNS,u'toc-mark-start'),
		(TEXTNS,u'user-defined'),
		(TEXTNS,u'user-field-get'),
		(TEXTNS,u'user-field-input'),
		(TEXTNS,u'user-index-mark'),
		(TEXTNS,u'user-index-mark-end'),
		(TEXTNS,u'user-index-mark-start'),
		(TEXTNS,u'variable-get'),
		(TEXTNS,u'variable-input'),
		(TEXTNS,u'variable-set'),
	),
# allowed_children
	(TEXTNS,u'hidden-paragraph') : (
	),
	(TEXTNS,u'hidden-text') : (
	),
	(TEXTNS,u'illustration-index') : (
		(TEXTNS,u'illustration-index-source'),
		(TEXTNS,u'index-body'),
	),
	(TEXTNS,u'illustration-index-entry-template') : (
		(TEXTNS,u'index-entry-page-number'),
		(TEXTNS,u'index-entry-span'),
		(TEXTNS,u'index-entry-tab-stop'),
		(TEXTNS,u'index-entry-text'),
	),
	(TEXTNS,u'illustration-index-source') : (
		(TEXTNS,u'illustration-index-entry-template'),
		(TEXTNS,u'index-title-template'),
	),
	(TEXTNS,u'image-count') : (
	),
# allowed_children
	(TEXTNS,u'index-body') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'a'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(TABLENS,u'table'),
		(TEXTNS,u'alphabetical-index'),
		(TEXTNS,u'bibliography'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'h'),
		(TEXTNS,u'illustration-index'),
		(TEXTNS,u'index-title'),
		(TEXTNS,u'list'),
		(TEXTNS,u'numbered-paragraph'),
		(TEXTNS,u'object-index'),
		(TEXTNS,u'p'),
		(TEXTNS,u'section'),
		(TEXTNS,u'soft-page-break'),
		(TEXTNS,u'table-index'),
		(TEXTNS,u'table-of-content'),
		(TEXTNS,u'user-index'),
	),
	(TEXTNS,u'index-entry-bibliography') : (
	),
	(TEXTNS,u'index-entry-chapter') : (
	),
	(TEXTNS,u'index-entry-link-end') : (
	),
	(TEXTNS,u'index-entry-link-start') : (
	),
	(TEXTNS,u'index-entry-page-number') : (
	),
	(TEXTNS,u'index-entry-span') : (
	),
	(TEXTNS,u'index-entry-tab-stop') : (
	),
	(TEXTNS,u'index-entry-text') : (
	),
	(TEXTNS,u'index-source-style') : (
	),
	(TEXTNS,u'index-source-styles') : (
		(TEXTNS,u'index-source-style'),
	),
# allowed_children
	(TEXTNS,u'index-title') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'a'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(TABLENS,u'table'),
		(TEXTNS,u'alphabetical-index'),
		(TEXTNS,u'bibliography'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'h'),
		(TEXTNS,u'illustration-index'),
		(TEXTNS,u'index-title'),
		(TEXTNS,u'list'),
		(TEXTNS,u'numbered-paragraph'),
		(TEXTNS,u'object-index'),
		(TEXTNS,u'p'),
		(TEXTNS,u'section'),
		(TEXTNS,u'soft-page-break'),
		(TEXTNS,u'table-index'),
		(TEXTNS,u'table-of-content'),
		(TEXTNS,u'user-index'),
	),
	(TEXTNS,u'index-title-template') : (
	),
	(TEXTNS,u'initial-creator') : (
	),
	(TEXTNS,u'insertion') : (
		(OFFICENS,u'change-info'),
	),
	(TEXTNS,u'keywords') : (
	),
	(TEXTNS,u'line-break') : (
	),
	(TEXTNS,u'linenumbering-configuration') : (
		(TEXTNS,u'linenumbering-separator'),
	),
	(TEXTNS,u'linenumbering-separator') : (
	),
	(TEXTNS,u'list') : (
		(TEXTNS,u'list-header'),
		(TEXTNS,u'list-item'),
	),
	(TEXTNS,u'list-header') : (
		(TEXTNS,u'h'),
		(TEXTNS,u'list'),
		(TEXTNS,u'number'),
		(TEXTNS,u'p'),
		(TEXTNS,u'soft-page-break'),
	),
	(TEXTNS,u'list-item') : (
		(TEXTNS,u'h'),
		(TEXTNS,u'list'),
		(TEXTNS,u'number'),
		(TEXTNS,u'p'),
		(TEXTNS,u'soft-page-break'),
	),
	(TEXTNS,u'list-level-style-bullet') : (
		(STYLENS,u'list-level-properties'),
		(STYLENS,u'text-properties'),
	),
	(TEXTNS,u'list-level-style-image') : (
		(OFFICENS,u'binary-data'),
		(STYLENS,u'list-level-properties'),
	),
	(TEXTNS,u'list-level-style-number') : (
		(STYLENS,u'list-level-properties'),
		(STYLENS,u'text-properties'),
	),
	(TEXTNS,u'list-style') : (
		(TEXTNS,u'list-level-style-bullet'),
		(TEXTNS,u'list-level-style-image'),
		(TEXTNS,u'list-level-style-number'),
	),
	(TEXTNS,u'measure') : (
	),
	(TEXTNS,u'modification-date') : (
	),
	(TEXTNS,u'modification-time') : (
	),
	(TEXTNS,u'note') : (
		(TEXTNS,u'note-body'),
		(TEXTNS,u'note-citation'),
	),
# allowed_children
	(TEXTNS,u'note-body') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'a'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(TABLENS,u'table'),
		(TEXTNS,u'alphabetical-index'),
		(TEXTNS,u'bibliography'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'h'),
		(TEXTNS,u'illustration-index'),
		(TEXTNS,u'list'),
		(TEXTNS,u'numbered-paragraph'),
		(TEXTNS,u'object-index'),
		(TEXTNS,u'p'),
		(TEXTNS,u'section'),
		(TEXTNS,u'soft-page-break'),
		(TEXTNS,u'table-index'),
		(TEXTNS,u'table-of-content'),
		(TEXTNS,u'user-index'),
	),
	(TEXTNS,u'note-citation') : (
	),
	(TEXTNS,u'note-continuation-notice-backward') : (
	),
	(TEXTNS,u'note-continuation-notice-forward') : (
	),
	(TEXTNS,u'note-ref') : (
	),
	(TEXTNS,u'notes-configuration') : (
		(TEXTNS,u'note-continuation-notice-backward'),
		(TEXTNS,u'note-continuation-notice-forward'),
	),
	(TEXTNS,u'number') : (
	),
	(TEXTNS,u'numbered-paragraph') : (
		(TEXTNS,u'h'),
		(TEXTNS,u'number'),
		(TEXTNS,u'p'),
	),
	(TEXTNS,u'object-count') : (
	),
	(TEXTNS,u'object-index') : (
		(TEXTNS,u'index-body'),
		(TEXTNS,u'object-index-source'),
	),
	(TEXTNS,u'object-index-entry-template') : (
		(TEXTNS,u'index-entry-page-number'),
		(TEXTNS,u'index-entry-span'),
		(TEXTNS,u'index-entry-tab-stop'),
		(TEXTNS,u'index-entry-text'),
	),
	(TEXTNS,u'object-index-source') : (
		(TEXTNS,u'index-title-template'),
		(TEXTNS,u'object-index-entry-template'),
	),
	(TEXTNS,u'outline-level-style') : (
		(STYLENS,u'list-level-properties'),
		(STYLENS,u'text-properties'),
	),
	(TEXTNS,u'outline-style') : (
		(TEXTNS,u'outline-level-style'),
	),
# allowed_children
	(TEXTNS,u'p') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'a'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(OFFICENS,u'annotation'),
		(PRESENTATIONNS,u'date-time'),
		(PRESENTATIONNS,u'footer'),
		(PRESENTATIONNS,u'header'),
		(TEXTNS,u'a'),
		(TEXTNS,u'alphabetical-index-mark'),
		(TEXTNS,u'alphabetical-index-mark-end'),
		(TEXTNS,u'alphabetical-index-mark-start'),
		(TEXTNS,u'author-initials'),
		(TEXTNS,u'author-name'),
		(TEXTNS,u'bibliography-mark'),
		(TEXTNS,u'bookmark'),
		(TEXTNS,u'bookmark-end'),
		(TEXTNS,u'bookmark-ref'),
		(TEXTNS,u'bookmark-start'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'chapter'),
		(TEXTNS,u'character-count'),
		(TEXTNS,u'conditional-text'),
		(TEXTNS,u'creation-date'),
		(TEXTNS,u'creation-time'),
		(TEXTNS,u'creator'),
		(TEXTNS,u'database-display'),
		(TEXTNS,u'database-name'),
		(TEXTNS,u'database-next'),
		(TEXTNS,u'database-row-number'),
		(TEXTNS,u'database-row-select'),
		(TEXTNS,u'date'),
		(TEXTNS,u'dde-connection'),
		(TEXTNS,u'description'),
		(TEXTNS,u'editing-cycles'),
		(TEXTNS,u'editing-duration'),
		(TEXTNS,u'execute-macro'),
		(TEXTNS,u'expression'),
		(TEXTNS,u'file-name'),
		(TEXTNS,u'hidden-paragraph'),
		(TEXTNS,u'hidden-text'),
		(TEXTNS,u'image-count'),
		(TEXTNS,u'initial-creator'),
		(TEXTNS,u'keywords'),
		(TEXTNS,u'line-break'),
		(TEXTNS,u'measure'),
		(TEXTNS,u'modification-date'),
		(TEXTNS,u'modification-time'),
		(TEXTNS,u'note'),
		(TEXTNS,u'note-ref'),
		(TEXTNS,u'object-count'),
		(TEXTNS,u'page-continuation'),
		(TEXTNS,u'page-count'),
		(TEXTNS,u'page-number'),
		(TEXTNS,u'page-variable-get'),
		(TEXTNS,u'page-variable-set'),
		(TEXTNS,u'paragraph-count'),
		(TEXTNS,u'placeholder'),
		(TEXTNS,u'print-date'),
		(TEXTNS,u'printed-by'),
		(TEXTNS,u'print-time'),
		(TEXTNS,u'reference-mark'),
		(TEXTNS,u'reference-mark-end'),
		(TEXTNS,u'reference-mark-start'),
		(TEXTNS,u'reference-ref'),
		(TEXTNS,u'ruby'),
		(TEXTNS,u's'),
		(TEXTNS,u'script'),
		(TEXTNS,u'sender-city'),
		(TEXTNS,u'sender-company'),
		(TEXTNS,u'sender-country'),
		(TEXTNS,u'sender-email'),
		(TEXTNS,u'sender-fax'),
		(TEXTNS,u'sender-firstname'),
		(TEXTNS,u'sender-initials'),
		(TEXTNS,u'sender-lastname'),
		(TEXTNS,u'sender-phone-private'),
		(TEXTNS,u'sender-phone-work'),
		(TEXTNS,u'sender-position'),
		(TEXTNS,u'sender-postal-code'),
		(TEXTNS,u'sender-state-or-province'),
		(TEXTNS,u'sender-street'),
		(TEXTNS,u'sender-title'),
		(TEXTNS,u'sequence'),
		(TEXTNS,u'sequence-ref'),
		(TEXTNS,u'sheet-name'),
		(TEXTNS,u'soft-page-break'),
		(TEXTNS,u'span'),
		(TEXTNS,u'subject'),
		(TEXTNS,u'tab'),
		(TEXTNS,u'table-count'),
		(TEXTNS,u'table-formula'),
		(TEXTNS,u'template-name'),
		(TEXTNS,u'text-input'),
		(TEXTNS,u'time'),
		(TEXTNS,u'title'),
		(TEXTNS,u'toc-mark'),
		(TEXTNS,u'toc-mark-end'),
		(TEXTNS,u'toc-mark-start'),
		(TEXTNS,u'user-defined'),
		(TEXTNS,u'user-field-get'),
		(TEXTNS,u'user-field-input'),
		(TEXTNS,u'user-index-mark'),
		(TEXTNS,u'user-index-mark-end'),
		(TEXTNS,u'user-index-mark-start'),
		(TEXTNS,u'variable-get'),
		(TEXTNS,u'variable-input'),
		(TEXTNS,u'variable-set'),
		(TEXTNS,u'word-count'),
	),
	(TEXTNS,u'page') : (
	),
	(TEXTNS,u'page-count') : (
	),
	(TEXTNS,u'page-continuation') : (
	),
	(TEXTNS,u'page-number') : (
	),
	(TEXTNS,u'page-sequence') : (
		(TEXTNS,u'page'),
	),
	(TEXTNS,u'page-variable-get') : (
	),
	(TEXTNS,u'page-variable-set') : (
	),
	(TEXTNS,u'paragraph-count') : (
	),
	(TEXTNS,u'placeholder') : (
	),
	(TEXTNS,u'print-date') : (
	),
	(TEXTNS,u'print-time') : (
	),
	(TEXTNS,u'printed-by') : (
	),
	(TEXTNS,u'reference-mark') : (
	),
	(TEXTNS,u'reference-mark-end') : (
	),
# allowed_children
	(TEXTNS,u'reference-mark-start') : (
	),
	(TEXTNS,u'reference-ref') : (
	),
	(TEXTNS,u'ruby') : (
		(TEXTNS,u'ruby-base'),
		(TEXTNS,u'ruby-text'),
	),
	(TEXTNS,u'ruby-base') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'a'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(OFFICENS,u'annotation'),
		(PRESENTATIONNS,u'date-time'),
		(PRESENTATIONNS,u'footer'),
		(PRESENTATIONNS,u'header'),
		(TEXTNS,u'a'),
		(TEXTNS,u'alphabetical-index-mark'),
		(TEXTNS,u'alphabetical-index-mark-end'),
		(TEXTNS,u'alphabetical-index-mark-start'),
		(TEXTNS,u'author-initials'),
		(TEXTNS,u'author-name'),
		(TEXTNS,u'bibliography-mark'),
		(TEXTNS,u'bookmark'),
		(TEXTNS,u'bookmark-end'),
		(TEXTNS,u'bookmark-ref'),
		(TEXTNS,u'bookmark-start'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'chapter'),
		(TEXTNS,u'conditional-text'),
		(TEXTNS,u'creation-date'),
		(TEXTNS,u'creation-time'),
		(TEXTNS,u'creator'),
		(TEXTNS,u'database-display'),
		(TEXTNS,u'database-name'),
		(TEXTNS,u'database-next'),
		(TEXTNS,u'database-row-number'),
		(TEXTNS,u'database-row-select'),
		(TEXTNS,u'date'),
		(TEXTNS,u'dde-connection'),
		(TEXTNS,u'description'),
		(TEXTNS,u'editing-cycles'),
		(TEXTNS,u'editing-duration'),
		(TEXTNS,u'execute-macro'),
		(TEXTNS,u'expression'),
		(TEXTNS,u'file-name'),
		(TEXTNS,u'hidden-paragraph'),
		(TEXTNS,u'hidden-text'),
		(TEXTNS,u'initial-creator'),
		(TEXTNS,u'keywords'),
		(TEXTNS,u'line-break'),
		(TEXTNS,u'measure'),
		(TEXTNS,u'modification-date'),
		(TEXTNS,u'modification-time'),
		(TEXTNS,u'note'),
		(TEXTNS,u'note-ref'),
		(TEXTNS,u'page-count'),
		(TEXTNS,u'paragraph-count'),
		(TEXTNS,u'word-count'),
		(TEXTNS,u'character-count'),
		(TEXTNS,u'table-count'),
		(TEXTNS,u'image-count'),
		(TEXTNS,u'object-count'),
		(TEXTNS,u'page-continuation'),
		(TEXTNS,u'page-number'),
		(TEXTNS,u'page-variable-get'),
		(TEXTNS,u'page-variable-set'),
		(TEXTNS,u'placeholder'),
		(TEXTNS,u'print-date'),
		(TEXTNS,u'print-time'),
		(TEXTNS,u'printed-by'),
		(TEXTNS,u'reference-mark'),
		(TEXTNS,u'reference-mark-end'),
		(TEXTNS,u'reference-mark-start'),
		(TEXTNS,u'reference-ref'),
		(TEXTNS,u'ruby'),
		(TEXTNS,u's'),
		(TEXTNS,u'script'),
		(TEXTNS,u'sender-city'),
		(TEXTNS,u'sender-company'),
		(TEXTNS,u'sender-country'),
		(TEXTNS,u'sender-email'),
		(TEXTNS,u'sender-fax'),
		(TEXTNS,u'sender-firstname'),
		(TEXTNS,u'sender-initials'),
		(TEXTNS,u'sender-lastname'),
		(TEXTNS,u'sender-phone-private'),
		(TEXTNS,u'sender-phone-work'),
		(TEXTNS,u'sender-position'),
		(TEXTNS,u'sender-postal-code'),
		(TEXTNS,u'sender-state-or-province'),
		(TEXTNS,u'sender-street'),
		(TEXTNS,u'sender-title'),
		(TEXTNS,u'sequence'),
		(TEXTNS,u'sequence-ref'),
		(TEXTNS,u'sheet-name'),
		(TEXTNS,u'soft-page-break'),
		(TEXTNS,u'span'),
		(TEXTNS,u'subject'),
		(TEXTNS,u'tab'),
		(TEXTNS,u'table-formula'),
		(TEXTNS,u'template-name'),
		(TEXTNS,u'text-input'),
		(TEXTNS,u'time'),
		(TEXTNS,u'title'),
		(TEXTNS,u'toc-mark'),
		(TEXTNS,u'toc-mark-end'),
		(TEXTNS,u'toc-mark-start'),
		(TEXTNS,u'user-defined'),
		(TEXTNS,u'user-field-get'),
		(TEXTNS,u'user-field-input'),
		(TEXTNS,u'user-index-mark'),
		(TEXTNS,u'user-index-mark-end'),
		(TEXTNS,u'user-index-mark-start'),
		(TEXTNS,u'variable-get'),
		(TEXTNS,u'variable-input'),
		(TEXTNS,u'variable-set'),
	),
# allowed_children
	(TEXTNS,u'ruby-text') : (
	),
	(TEXTNS,u's') : (
	),
	(TEXTNS,u'script') : (
	),
	(TEXTNS,u'section') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'a'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(OFFICENS,u'dde-source'),
		(TABLENS,u'table'),
		(TEXTNS,u'alphabetical-index'),
		(TEXTNS,u'bibliography'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'h'),
		(TEXTNS,u'illustration-index'),
		(TEXTNS,u'list'),
		(TEXTNS,u'numbered-paragraph'),
		(TEXTNS,u'object-index'),
		(TEXTNS,u'p'),
		(TEXTNS,u'section'),
		(TEXTNS,u'section-source'),
		(TEXTNS,u'soft-page-break'),
		(TEXTNS,u'table-index'),
		(TEXTNS,u'table-of-content'),
		(TEXTNS,u'user-index'),
	),
	(TEXTNS,u'section-source') : (
	),
	(TEXTNS,u'sender-city') : (
	),
	(TEXTNS,u'sender-company') : (
	),
	(TEXTNS,u'sender-country') : (
	),
# allowed_children
	(TEXTNS,u'sender-email') : (
	),
	(TEXTNS,u'sender-fax') : (
	),
	(TEXTNS,u'sender-firstname') : (
	),
	(TEXTNS,u'sender-initials') : (
	),
	(TEXTNS,u'sender-lastname') : (
	),
	(TEXTNS,u'sender-phone-private') : (
	),
	(TEXTNS,u'sender-phone-work') : (
	),
	(TEXTNS,u'sender-position') : (
	),
	(TEXTNS,u'sender-postal-code') : (
	),
	(TEXTNS,u'sender-state-or-province') : (
	),
	(TEXTNS,u'sender-street') : (
	),
	(TEXTNS,u'sender-title') : (
	),
	(TEXTNS,u'sequence') : (
	),
	(TEXTNS,u'sequence-decl') : (
	),
	(TEXTNS,u'sequence-decls') : (
		(TEXTNS,u'sequence-decl'),
	),
	(TEXTNS,u'sequence-ref') : (
	),
	(TEXTNS,u'sheet-name') : (
	),
	(TEXTNS,u'soft-page-break') : (
	),
	(TEXTNS,u'sort-key') : (
	),
# allowed_children
	(TEXTNS,u'span') : (
		(DR3DNS,u'scene'),
		(DRAWNS,u'a'),
		(DRAWNS,u'caption'),
		(DRAWNS,u'circle'),
		(DRAWNS,u'connector'),
		(DRAWNS,u'control'),
		(DRAWNS,u'custom-shape'),
		(DRAWNS,u'ellipse'),
		(DRAWNS,u'frame'),
		(DRAWNS,u'g'),
		(DRAWNS,u'line'),
		(DRAWNS,u'measure'),
		(DRAWNS,u'page-thumbnail'),
		(DRAWNS,u'path'),
		(DRAWNS,u'polygon'),
		(DRAWNS,u'polyline'),
		(DRAWNS,u'rect'),
		(DRAWNS,u'regular-polygon'),
		(OFFICENS,u'annotation'),
		(PRESENTATIONNS,u'date-time'),
		(PRESENTATIONNS,u'footer'),
		(PRESENTATIONNS,u'header'),
		(TEXTNS,u'a'),
		(TEXTNS,u'alphabetical-index-mark'),
		(TEXTNS,u'alphabetical-index-mark-end'),
		(TEXTNS,u'alphabetical-index-mark-start'),
		(TEXTNS,u'author-initials'),
		(TEXTNS,u'author-name'),
		(TEXTNS,u'bibliography-mark'),
		(TEXTNS,u'bookmark'),
		(TEXTNS,u'bookmark-end'),
		(TEXTNS,u'bookmark-ref'),
		(TEXTNS,u'bookmark-start'),
		(TEXTNS,u'change'),
		(TEXTNS,u'change-end'),
		(TEXTNS,u'change-start'),
		(TEXTNS,u'chapter'),
		(TEXTNS,u'conditional-text'),
		(TEXTNS,u'creation-date'),
		(TEXTNS,u'creation-time'),
		(TEXTNS,u'creator'),
		(TEXTNS,u'database-display'),
		(TEXTNS,u'database-name'),
		(TEXTNS,u'database-next'),
		(TEXTNS,u'database-row-number'),
		(TEXTNS,u'database-row-select'),
		(TEXTNS,u'date'),
		(TEXTNS,u'dde-connection'),
		(TEXTNS,u'description'),
		(TEXTNS,u'editing-cycles'),
		(TEXTNS,u'editing-duration'),
		(TEXTNS,u'execute-macro'),
		(TEXTNS,u'expression'),
		(TEXTNS,u'file-name'),
		(TEXTNS,u'hidden-paragraph'),
		(TEXTNS,u'hidden-text'),
		(TEXTNS,u'initial-creator'),
		(TEXTNS,u'keywords'),
		(TEXTNS,u'line-break'),
		(TEXTNS,u'measure'),
		(TEXTNS,u'modification-date'),
		(TEXTNS,u'modification-time'),
		(TEXTNS,u'note'),
		(TEXTNS,u'note-ref'),
		(TEXTNS,u'page-count'),
		(TEXTNS,u'paragraph-count'),
		(TEXTNS,u'word-count'),
		(TEXTNS,u'character-count'),
		(TEXTNS,u'table-count'),
		(TEXTNS,u'image-count'),
		(TEXTNS,u'object-count'),
		(TEXTNS,u'page-continuation'),
		(TEXTNS,u'page-number'),
		(TEXTNS,u'page-variable-get'),
		(TEXTNS,u'page-variable-set'),
		(TEXTNS,u'placeholder'),
		(TEXTNS,u'print-date'),
		(TEXTNS,u'print-time'),
		(TEXTNS,u'printed-by'),
		(TEXTNS,u'reference-mark'),
		(TEXTNS,u'reference-mark-end'),
		(TEXTNS,u'reference-mark-start'),
		(TEXTNS,u'reference-ref'),
		(TEXTNS,u'ruby'),
		(TEXTNS,u's'),
		(TEXTNS,u'script'),
		(TEXTNS,u'sender-city'),
		(TEXTNS,u'sender-company'),
		(TEXTNS,u'sender-country'),
		(TEXTNS,u'sender-email'),
		(TEXTNS,u'sender-fax'),
		(TEXTNS,u'sender-firstname'),
		(TEXTNS,u'sender-initials'),
		(TEXTNS,u'sender-lastname'),
		(TEXTNS,u'sender-phone-private'),
		(TEXTNS,u'sender-phone-work'),
		(TEXTNS,u'sender-position'),
		(TEXTNS,u'sender-postal-code'),
		(TEXTNS,u'sender-state-or-province'),
		(TEXTNS,u'sender-street'),
		(TEXTNS,u'sender-title'),
		(TEXTNS,u'sequence'),
		(TEXTNS,u'sequence-ref'),
		(TEXTNS,u'sheet-name'),
		(TEXTNS,u'soft-page-break'),
		(TEXTNS,u'span'),
		(TEXTNS,u'subject'),
		(TEXTNS,u'tab'),
		(TEXTNS,u'table-formula'),
		(TEXTNS,u'template-name'),
		(TEXTNS,u'text-input'),
		(TEXTNS,u'time'),
		(TEXTNS,u'title'),
		(TEXTNS,u'toc-mark'),
		(TEXTNS,u'toc-mark-end'),
		(TEXTNS,u'toc-mark-start'),
		(TEXTNS,u'user-defined'),
		(TEXTNS,u'user-field-get'),
		(TEXTNS,u'user-field-input'),
		(TEXTNS,u'user-index-mark'),
		(TEXTNS,u'user-index-mark-end'),
		(TEXTNS,u'user-index-mark-start'),
		(TEXTNS,u'variable-get'),
		(TEXTNS,u'variable-input'),
		(TEXTNS,u'variable-set'),
	),
# allowed_children
	(TEXTNS,u'subject') : (
	),
	(TEXTNS,u'tab') : (
	),
	(TEXTNS,u'table-count') : (
	),
	(TEXTNS,u'table-formula') : (
	),
	(TEXTNS,u'table-index') : (
		(TEXTNS,u'index-body'),
		(TEXTNS,u'table-index-source'),
	),
	(TEXTNS,u'table-index-entry-template') : (
		(TEXTNS,u'index-entry-page-number'),
		(TEXTNS,u'index-entry-span'),
		(TEXTNS,u'index-entry-tab-stop'),
		(TEXTNS,u'index-entry-text'),
	),
	(TEXTNS,u'table-index-source') : (
		(TEXTNS,u'index-title-template'),
		(TEXTNS,u'table-index-entry-template'),
	),
	(TEXTNS,u'table-of-content') : (
		(TEXTNS,u'index-body'),
		(TEXTNS,u'table-of-content-source'),
	),
	(TEXTNS,u'table-of-content-entry-template') : (
		(TEXTNS,u'index-entry-chapter'),
		(TEXTNS,u'index-entry-link-end'),
		(TEXTNS,u'index-entry-link-start'),
		(TEXTNS,u'index-entry-page-number'),
		(TEXTNS,u'index-entry-span'),
		(TEXTNS,u'index-entry-tab-stop'),
		(TEXTNS,u'index-entry-text'),
	),
	(TEXTNS,u'table-of-content-source') : (
		(TEXTNS,u'index-source-styles'),
		(TEXTNS,u'index-title-template'),
		(TEXTNS,u'table-of-content-entry-template'),
	),
	(TEXTNS,u'template-name') : (
	),
	(TEXTNS,u'text-input') : (
	),
	(TEXTNS,u'time') : (
	),
	(TEXTNS,u'title') : (
	),
	(TEXTNS,u'toc-mark') : (
	),
	(TEXTNS,u'toc-mark-end') : (
	),
	(TEXTNS,u'toc-mark-start') : (
	),
# allowed_children
	(TEXTNS,u'tracked-changes') : (
		(TEXTNS,u'changed-region'),
	),
	(TEXTNS,u'user-defined') : (
	),
	(TEXTNS,u'user-field-decl') : (
	),
	(TEXTNS,u'user-field-decls') : (
		(TEXTNS,u'user-field-decl'),
	),
	(TEXTNS,u'user-field-get') : (
	),
	(TEXTNS,u'user-field-input') : (
	),
	(TEXTNS,u'user-index') : (
		(TEXTNS,u'index-body'),
		(TEXTNS,u'user-index-source'),
	),
	(TEXTNS,u'user-index-entry-template') : (
		(TEXTNS,u'index-entry-chapter'),
		(TEXTNS,u'index-entry-page-number'),
		(TEXTNS,u'index-entry-span'),
		(TEXTNS,u'index-entry-tab-stop'),
		(TEXTNS,u'index-entry-text'),
	),
# allowed_children
	(TEXTNS,u'user-index-mark') : (
	),
	(TEXTNS,u'user-index-mark-end') : (
	),
	(TEXTNS,u'user-index-mark-start') : (
	),
	(TEXTNS,u'user-index-source') : (
		(TEXTNS,u'index-source-styles'),
		(TEXTNS,u'index-title-template'),
		(TEXTNS,u'user-index-entry-template'),
	),
	(TEXTNS,u'variable-decl') : (
	),
	(TEXTNS,u'variable-decls') : (
		(TEXTNS,u'variable-decl'),
	),
	(TEXTNS,u'variable-get') : (
	),
	(TEXTNS,u'variable-input') : (
	),
	(TEXTNS,u'variable-set') : (
	),
	(TEXTNS,u'word-count') : (
	),
}

#
# List of elements that allows text nodes
#
allows_text = (
	(CONFIGNS,u'config-item'),
	(DCNS,u'creator'),
	(DCNS,u'date'),
	(DCNS,u'description'),
	(DCNS,u'language'),
	(DCNS,u'subject'),
	(DCNS,u'title'),
# Completes Dublin Core start
#	(DCNS,'contributor'),
#	(DCNS,'coverage'),
#	(DCNS,'format'),
#	(DCNS,'identifier'),
#	(DCNS,'publisher'),
#	(DCNS,'relation'),
#	(DCNS,'rights'),
#	(DCNS,'source'),
#	(DCNS,'type'),
# Completes Dublin Core end
	(FORMNS,u'item'),
	(FORMNS,u'option'),
	(MATHNS,u'math'),
	(METANS,u'creation-date'),
	(METANS,u'date-string'),
	(METANS,u'editing-cycles'),
	(METANS,u'editing-duration'),
# allows_text
	(METANS,u'generator'),
	(METANS,u'initial-creator'),
	(METANS,u'keyword'),
	(METANS,u'print-date'),
	(METANS,u'printed-by'),
	(METANS,u'user-defined'),
	(NUMBERNS,u'currency-symbol'),
	(NUMBERNS,u'embedded-text'),
	(NUMBERNS,u'text'),
	(OFFICENS,u'binary-data'),
	(OFFICENS,u'script'),
	(PRESENTATIONNS,u'date-time-decl'),
	(PRESENTATIONNS,u'footer-decl'),
	(PRESENTATIONNS,u'header-decl'),
	(SVGNS,u'desc'),
	(SVGNS,u'title'),
	(TEXTNS,u'a'),
	(TEXTNS,u'author-initials'),
	(TEXTNS,u'author-name'),
	(TEXTNS,u'bibliography-mark'),
	(TEXTNS,u'bookmark-ref'),
	(TEXTNS,u'chapter'),
	(TEXTNS,u'character-count'),
	(TEXTNS,u'conditional-text'),
	(TEXTNS,u'creation-date'),
	(TEXTNS,u'creation-time'),
	(TEXTNS,u'creator'),
	(TEXTNS,u'database-display'),
	(TEXTNS,u'database-name'),
	(TEXTNS,u'database-row-number'),
	(TEXTNS,u'date'),
	(TEXTNS,u'dde-connection'),
	(TEXTNS,u'description'),
	(TEXTNS,u'editing-cycles'),
	(TEXTNS,u'editing-duration'),
	(TEXTNS,u'execute-macro'),
	(TEXTNS,u'expression'),
	(TEXTNS,u'file-name'),
	(TEXTNS,u'h'),
	(TEXTNS,u'hidden-paragraph'),
	(TEXTNS,u'hidden-text'),
	(TEXTNS,u'image-count'),
# allowed_children
	(TEXTNS,u'index-entry-span'),
	(TEXTNS,u'index-title-template'),
	(TEXTNS,u'initial-creator'),
	(TEXTNS,u'keywords'),
	(TEXTNS,u'linenumbering-separator'),
	(TEXTNS,u'measure'),
	(TEXTNS,u'modification-date'),
	(TEXTNS,u'modification-time'),
	(TEXTNS,u'note-citation'),
	(TEXTNS,u'note-continuation-notice-backward'),
	(TEXTNS,u'note-continuation-notice-forward'),
	(TEXTNS,u'note-ref'),
	(TEXTNS,u'number'),
	(TEXTNS,u'object-count'),
	(TEXTNS,u'p'),
	(TEXTNS,u'page-continuation'),
	(TEXTNS,u'page-count'),
	(TEXTNS,u'page-number'),
	(TEXTNS,u'page-variable-get'),
	(TEXTNS,u'page-variable-set'),
	(TEXTNS,u'paragraph-count'),
	(TEXTNS,u'placeholder'),
	(TEXTNS,u'print-date'),
	(TEXTNS,u'print-time'),
	(TEXTNS,u'printed-by'),
	(TEXTNS,u'reference-ref'),
	(TEXTNS,u'ruby-base'),
	(TEXTNS,u'ruby-text'),
	(TEXTNS,u'script'),
	(TEXTNS,u'sender-city'),
	(TEXTNS,u'sender-company'),
	(TEXTNS,u'sender-country'),
	(TEXTNS,u'sender-email'),
	(TEXTNS,u'sender-fax'),
	(TEXTNS,u'sender-firstname'),
	(TEXTNS,u'sender-initials'),
	(TEXTNS,u'sender-lastname'),
	(TEXTNS,u'sender-phone-private'),
	(TEXTNS,u'sender-phone-work'),
	(TEXTNS,u'sender-position'),
	(TEXTNS,u'sender-postal-code'),
	(TEXTNS,u'sender-state-or-province'),
	(TEXTNS,u'sender-street'),
	(TEXTNS,u'sender-title'),
	(TEXTNS,u'sequence'),
	(TEXTNS,u'sequence-ref'),
	(TEXTNS,u'sheet-name'),
# allowed_children
	(TEXTNS,u'span'),
	(TEXTNS,u'subject'),
	(TEXTNS,u'table-count'),
	(TEXTNS,u'table-formula'),
	(TEXTNS,u'template-name'),
	(TEXTNS,u'text-input'),
	(TEXTNS,u'time'),
	(TEXTNS,u'title'),
	(TEXTNS,u'user-defined'),
	(TEXTNS,u'user-field-get'),
	(TEXTNS,u'user-field-input'),
	(TEXTNS,u'variable-get'),
	(TEXTNS,u'variable-input'),
	(TEXTNS,u'variable-set'),
	(TEXTNS,u'word-count'),
)

# Only the elements with at least one required attribute is listed

required_attributes = {
	(ANIMNS,u'animate'): (
		(SMILNS,u'attributeName'),
	),
	(ANIMNS,u'animateColor'): (
		(SMILNS,u'attributeName'),
	),
	(ANIMNS,u'animateMotion'): (
		(SMILNS,u'attributeName'),
	),
	(ANIMNS,u'animateTransform'): (
		(SVGNS,u'type'),
		(SMILNS,u'attributeName'),
	),
	(ANIMNS,u'command'): (
		(ANIMNS,u'command'),
	),
	(ANIMNS,u'param'): (
		(ANIMNS,u'name'),
		(ANIMNS,u'value'),
	),
	(ANIMNS,u'set'): (
		(SMILNS,u'attributeName'),
	),
# required_attributes
	(ANIMNS,u'transitionFilter'): (
		(SMILNS,u'type'),
	),
	(CHARTNS,u'axis'): (
		(CHARTNS,u'dimension'),
	),
	(CHARTNS,u'chart'): (
		(CHARTNS,u'class'),
	),
	(CHARTNS,u'symbol-image'): (
		(XLINKNS,u'href'),
	),
	(CONFIGNS,u'config-item'): (
		(CONFIGNS,u'type'),
		(CONFIGNS,u'name'),
	),
	(CONFIGNS,u'config-item-map-indexed'): (
		(CONFIGNS,u'name'),
	),
	(CONFIGNS,u'config-item-map-named'): (
		(CONFIGNS,u'name'),
	),
	(CONFIGNS,u'config-item-set'): (
		(CONFIGNS,u'name'),
	),
# required_attributes
	(NUMBERNS,u'boolean-style'): (
		(STYLENS,u'name'),
	),
	(NUMBERNS,u'currency-style'): (
		(STYLENS,u'name'),
	),
	(NUMBERNS,u'date-style'): (
		(STYLENS,u'name'),
	),
	(NUMBERNS,u'embedded-text'): (
		(NUMBERNS,u'position'),
	),
	(NUMBERNS,u'number-style'): (
		(STYLENS,u'name'),
	),
	(NUMBERNS,u'percentage-style'): (
		(STYLENS,u'name'),
	),
	(NUMBERNS,u'text-style'): (
		(STYLENS,u'name'),
	),
	(NUMBERNS,u'time-style'): (
		(STYLENS,u'name'),
	),
	(DR3DNS,u'extrude'): (
		(SVGNS,u'd'),
		(SVGNS,u'viewBox'),
	),
	(DR3DNS,u'light'): (
		(DR3DNS,u'direction'),
	),
	(DR3DNS,u'rotate'): (
		(SVGNS,u'viewBox'),
		(SVGNS,u'd'),
	),
# required_attributes
	(DRAWNS,u'a'): (
		(XLINKNS,u'href'),
	),
	(DRAWNS,u'area-circle'): (
		(SVGNS,u'cy'),
		(SVGNS,u'cx'),
		(SVGNS,u'r'),
	),
	(DRAWNS,u'area-polygon'): (
		(SVGNS,u'height'),
		(SVGNS,u'width'),
		(DRAWNS,u'points'),
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(SVGNS,u'viewBox'),
	),
	(DRAWNS,u'area-rectangle'): (
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(SVGNS,u'height'),
		(SVGNS,u'width'),
	),
	(DRAWNS,u'contour-path'): (
		(DRAWNS,u'recreate-on-edit'),
		(SVGNS,u'viewBox'),
		(SVGNS,u'd'),
	),
	(DRAWNS,u'contour-polygon'): (
		(DRAWNS,u'points'),
		(DRAWNS,u'recreate-on-edit'),
		(SVGNS,u'viewBox'),
	),
	(DRAWNS,u'control'): (
		(DRAWNS,u'control'),
	),
	(DRAWNS,u'fill-image'): (
		(XLINKNS,u'href'),
		(DRAWNS,u'name'),
	),
	(DRAWNS,u'floating-frame'): (
		(XLINKNS,u'href'),
	),
	(DRAWNS,u'glue-point'): (
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(DRAWNS,u'id'),
		(DRAWNS,u'escape-direction'),
	),
# required_attributes
	(DRAWNS,u'gradient'): (
		(DRAWNS,u'style'),
	),
	(DRAWNS,u'handle'): (
		(DRAWNS,u'handle-position'),
	),
	(DRAWNS,u'hatch'): (
		(DRAWNS,u'style'),
		(DRAWNS,u'name'),
	),
	(DRAWNS,u'layer'): (
		(DRAWNS,u'name'),
	),
	(DRAWNS,u'line'): (
		(SVGNS,u'y1'),
		(SVGNS,u'x2'),
		(SVGNS,u'x1'),
		(SVGNS,u'y2'),
	),
	(DRAWNS,u'marker'): (
		(SVGNS,u'd'),
		(DRAWNS,u'name'),
		(SVGNS,u'viewBox'),
	),
	(DRAWNS,u'measure'): (
		(SVGNS,u'y1'),
		(SVGNS,u'x2'),
		(SVGNS,u'x1'),
		(SVGNS,u'y2'),
	),
	(DRAWNS,u'opacity'): (
		(DRAWNS,u'style'),
	),
	(DRAWNS,u'page'): (
		(DRAWNS,u'master-page-name'),
	),
	(DRAWNS,u'path'): (
		(SVGNS,u'd'),
		(SVGNS,u'viewBox'),
	),
	(DRAWNS,u'plugin'): (
		(XLINKNS,u'href'),
	),
	(DRAWNS,u'polygon'): (
		(DRAWNS,u'points'),
		(SVGNS,u'viewBox'),
	),
# required_attributes
	(DRAWNS,u'polyline'): (
		(DRAWNS,u'points'),
		(SVGNS,u'viewBox'),
	),
	(DRAWNS,u'regular-polygon'): (
		(DRAWNS,u'corners'),
	),
	(DRAWNS,u'stroke-dash'): (
		(DRAWNS,u'name'),
	),
	(FORMNS,u'button'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'checkbox'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'combobox'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'connection-resource'): (
		(XLINKNS,u'href'),
	),
	(FORMNS,u'date'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'file'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'fixed-text'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'formatted-text'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'frame'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'generic-control'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'grid'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'hidden'): (
		(FORMNS,u'id'),
	),
# required_attributes
	(FORMNS,u'image'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'image-frame'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'list-property'): (
		(FORMNS,u'property-name'),
	),
	(FORMNS,u'list-value'): (
		(OFFICENS,u'string-value'),
	),
	(FORMNS,u'listbox'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'number'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'password'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'property'): (
		(FORMNS,u'property-name'),
	),
	(FORMNS,u'radio'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'text'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'textarea'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'time'): (
		(FORMNS,u'id'),
	),
	(FORMNS,u'value-range'): (
		(FORMNS,u'id'),
	),
	(MANIFESTNS,u'algorithm') : (
		(MANIFESTNS,u'algorithm-name'),
		(MANIFESTNS,u'initialisation-vector'),
	),
	(MANIFESTNS,u'encryption-data') : (
		(MANIFESTNS,u'checksum-type'),
		(MANIFESTNS,u'checksum'),
	),
	(MANIFESTNS,u'file-entry') : (
		(MANIFESTNS,u'full-path'),
		(MANIFESTNS,u'media-type'),
	),
	(MANIFESTNS,u'key-derivation') : (
		(MANIFESTNS,u'key-derivation-name'),
		(MANIFESTNS,u'salt'),
		(MANIFESTNS,u'iteration-count'),
	),
# required_attributes
	(METANS,u'template'): (
		(XLINKNS,u'href'),
	),
	(METANS,u'user-defined'): (
		(METANS,u'name'),
	),
	(OFFICENS,u'dde-source'): (
		(OFFICENS,u'dde-topic'),
		(OFFICENS,u'dde-application'),
		(OFFICENS,u'dde-item'),
	),
	(OFFICENS,u'document'): (
		(OFFICENS,u'mimetype'),
	),
	(OFFICENS,u'script'): (
		(SCRIPTNS,u'language'),
	),
	(PRESENTATIONNS,u'date-time-decl'): (
		(PRESENTATIONNS,u'source'),
		(PRESENTATIONNS,u'name'),
	),
	(PRESENTATIONNS,u'dim'): (
		(DRAWNS,u'color'),
		(DRAWNS,u'shape-id'),
	),
# required_attributes
	(PRESENTATIONNS,u'event-listener'): (
		(PRESENTATIONNS,u'action'),
		(SCRIPTNS,u'event-name'),
	),
	(PRESENTATIONNS,u'footer-decl'): (
		(PRESENTATIONNS,u'name'),
	),
	(PRESENTATIONNS,u'header-decl'): (
		(PRESENTATIONNS,u'name'),
	),
	(PRESENTATIONNS,u'hide-shape'): (
		(DRAWNS,u'shape-id'),
	),
	(PRESENTATIONNS,u'hide-text'): (
		(DRAWNS,u'shape-id'),
	),
	(PRESENTATIONNS,u'placeholder'): (
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(SVGNS,u'height'),
		(PRESENTATIONNS,u'object'),
		(SVGNS,u'width'),
	),
	(PRESENTATIONNS,u'play'): (
		(DRAWNS,u'shape-id'),
	),
	(PRESENTATIONNS,u'show'): (
		(PRESENTATIONNS,u'name'),
		(PRESENTATIONNS,u'pages'),
	),
	(PRESENTATIONNS,u'show-shape'): (
		(DRAWNS,u'shape-id'),
	),
	(PRESENTATIONNS,u'show-text'): (
		(DRAWNS,u'shape-id'),
	),
	(PRESENTATIONNS,u'sound'): (
		(XLINKNS,u'href'),
	),
	(SCRIPTNS,u'event-listener'): (
		(SCRIPTNS,u'language'),
		(SCRIPTNS,u'event-name'),
	),
	(STYLENS,u'column'): (
		(STYLENS,u'rel-width'),
	),
# required_attributes
	(STYLENS,u'column-sep'): (
		(STYLENS,u'width'),
	),
	(STYLENS,u'columns'): (
		(FONS,u'column-count'),
	),
	(STYLENS,u'font-face'): (
		(STYLENS,u'name'),
	),
	(STYLENS,u'handout-master'): (
		(STYLENS,u'page-layout-name'),
	),
	(STYLENS,u'map'): (
		(STYLENS,u'apply-style-name'),
		(STYLENS,u'condition'),
	),
	(STYLENS,u'master-page'): (
		(STYLENS,u'page-layout-name'),
		(STYLENS,u'name'),
	),
	(STYLENS,u'page-layout'): (
		(STYLENS,u'name'),
	),
	(STYLENS,u'presentation-page-layout'): (
		(STYLENS,u'name'),
	),
	(STYLENS,u'style'): (
		(STYLENS,u'name'),
	),
	(STYLENS,u'tab-stop'): (
		(STYLENS,u'position'),
	),
	(SVGNS,u'definition-src'): (
		(XLINKNS,u'href'),
	),
	(SVGNS,u'font-face-uri'): (
		(XLINKNS,u'href'),
	),
	(SVGNS,u'linearGradient'): (
		(DRAWNS,u'name'),
	),
	(SVGNS,u'radialGradient'): (
		(DRAWNS,u'name'),
	),
	(SVGNS,u'stop'): (
		(SVGNS,u'offset'),
	),
# required_attributes
	(TABLENS,u'body'): (
		(TEXTNS,u'style-name'),
	),
	(TABLENS,u'cell-address'): (
		(TABLENS,u'column'),
		(TABLENS,u'table'),
		(TABLENS,u'row'),
	),
	(TABLENS,u'cell-content-change'): (
		(TABLENS,u'id'),
	),
	(TABLENS,u'cell-range-source'): (
		(TABLENS,u'last-row-spanned'),
		(TABLENS,u'last-column-spanned'),
		(XLINKNS,u'href'),
		(TABLENS,u'name'),
	),
	(TABLENS,u'consolidation'): (
		(TABLENS,u'function'),
		(TABLENS,u'source-cell-range-addresses'),
		(TABLENS,u'target-cell-address'),
	),
	(TABLENS,u'content-validation'): (
		(TABLENS,u'name'),
	),
	(TABLENS,u'data-pilot-display-info'): (
		(TABLENS,u'member-count'),
		(TABLENS,u'data-field'),
		(TABLENS,u'enabled'),
		(TABLENS,u'display-member-mode'),
	),
# required_attributes
	(TABLENS,u'data-pilot-field'): (
		(TABLENS,u'source-field-name'),
	),
	(TABLENS,u'data-pilot-field-reference'): (
		(TABLENS,u'field-name'),
		(TABLENS,u'type'),
	),
	(TABLENS,u'data-pilot-group'): (
		(TABLENS,u'name'),
	),
	(TABLENS,u'data-pilot-group-member'): (
		(TABLENS,u'name'),
	),
	(TABLENS,u'data-pilot-groups'): (
		(TABLENS,u'source-field-name'),
		(TABLENS,u'step'),
		(TABLENS,u'grouped-by'),
	),
	(TABLENS,u'data-pilot-layout-info'): (
		(TABLENS,u'add-empty-lines'),
		(TABLENS,u'layout-mode'),
	),
	(TABLENS,u'data-pilot-member'): (
		(TABLENS,u'name'),
	),
	(TABLENS,u'data-pilot-sort-info'): (
		(TABLENS,u'order'),
	),
	(TABLENS,u'data-pilot-subtotal'): (
		(TABLENS,u'function'),
	),
	(TABLENS,u'data-pilot-table'): (
		(TABLENS,u'target-range-address'),
		(TABLENS,u'name'),
	),
	(TABLENS,u'database-range'): (
		(TABLENS,u'target-range-address'),
	),
# required_attributes
	(TABLENS,u'database-source-query'): (
		(TABLENS,u'query-name'),
		(TABLENS,u'database-name'),
	),
	(TABLENS,u'database-source-sql'): (
		(TABLENS,u'database-name'),
		(TABLENS,u'sql-statement'),
	),
	(TABLENS,u'database-source-table'): (
		(TABLENS,u'database-table-name'),
		(TABLENS,u'database-name'),
	),
	(TABLENS,u'deletion'): (
		(TABLENS,u'position'),
		(TABLENS,u'type'),
		(TABLENS,u'id'),
	),
	(TABLENS,u'dependency'): (
		(TABLENS,u'id'),
	),
	(TABLENS,u'even-columns'): (
		(TEXTNS,u'style-name'),
	),
	(TABLENS,u'even-rows'): (
		(TEXTNS,u'style-name'),
	),
	(TABLENS,u'filter-condition'): (
		(TABLENS,u'operator'),
		(TABLENS,u'field-number'),
		(TABLENS,u'value'),
	),
	(TABLENS,u'first-column'): (
		(TEXTNS,u'style-name'),
	),
	(TABLENS,u'first-row'): (
		(TEXTNS,u'style-name'),
	),
	(TABLENS,u'insertion'): (
		(TABLENS,u'position'),
		(TABLENS,u'type'),
		(TABLENS,u'id'),
	),
	(TABLENS,u'insertion-cut-off'): (
		(TABLENS,u'position'),
		(TABLENS,u'id'),
	),
# required_attributes
	(TABLENS,u'label-range'): (
		(TABLENS,u'label-cell-range-address'),
		(TABLENS,u'data-cell-range-address'),
		(TABLENS,u'orientation'),
	),
	(TABLENS,u'last-column'): (
		(TEXTNS,u'style-name'),
	),
	(TABLENS,u'last-row'): (
		(TEXTNS,u'style-name'),
	),
	(TABLENS,u'movement'): (
		(TABLENS,u'id'),
	),
	(TABLENS,u'named-expression'): (
		(TABLENS,u'expression'),
		(TABLENS,u'name'),
	),
	(TABLENS,u'named-range'): (
		(TABLENS,u'name'),
		(TABLENS,u'cell-range-address'),
	),
	(TABLENS,u'odd-columns'): (
		(TEXTNS,u'style-name'),
	),
	(TABLENS,u'odd-rows'): (
		(TEXTNS,u'style-name'),
	),
	(TABLENS,u'operation'): (
		(TABLENS,u'index'),
		(TABLENS,u'name'),
	),
# required_attributes
	(TABLENS,u'scenario'): (
		(TABLENS,u'is-active'),
		(TABLENS,u'scenario-ranges'),
	),
	(TABLENS,u'sort-by'): (
		(TABLENS,u'field-number'),
	),
	(TABLENS,u'source-cell-range'): (
		(TABLENS,u'cell-range-address'),
	),
	(TABLENS,u'source-service'): (
		(TABLENS,u'source-name'),
		(TABLENS,u'object-name'),
		(TABLENS,u'name'),
	),
	(TABLENS,u'subtotal-field'): (
		(TABLENS,u'function'),
		(TABLENS,u'field-number'),
	),
	(TABLENS,u'subtotal-rule'): (
		(TABLENS,u'group-by-field-number'),
	),
	(TABLENS,u'table-source'): (
		(XLINKNS,u'href'),
	),
	(TABLENS,u'table-template'): (
		(TEXTNS,u'last-row-end-column'),
		(TEXTNS,u'first-row-end-column'),
		(TEXTNS,u'name'),
		(TEXTNS,u'last-row-start-column'),
		(TEXTNS,u'first-row-start-column'),
	),
	(TEXTNS,u'a'): (
		(XLINKNS,u'href'),
	),
# required_attributes
	(TEXTNS,u'alphabetical-index'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'alphabetical-index-auto-mark-file'): (
		(XLINKNS,u'href'),
	),
	(TEXTNS,u'alphabetical-index-entry-template'): (
		(TEXTNS,u'style-name'),
		(TEXTNS,u'outline-level'),
	),
	(TEXTNS,u'alphabetical-index-mark'): (
		(TEXTNS,u'string-value'),
	),
	(TEXTNS,u'alphabetical-index-mark-end'): (
		(TEXTNS,u'id'),
	),
	(TEXTNS,u'alphabetical-index-mark-start'): (
		(TEXTNS,u'id'),
	),
	(TEXTNS,u'bibliography'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'bibliography-entry-template'): (
		(TEXTNS,u'style-name'),
		(TEXTNS,u'bibliography-type'),
	),
	(TEXTNS,u'bibliography-mark'): (
		(TEXTNS,u'bibliography-type'),
	),
	(TEXTNS,u'bookmark'): (
		(TEXTNS,u'name'),
	),
# required_attributes
	(TEXTNS,u'bookmark-end'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'bookmark-start'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'change'): (
		(TEXTNS,u'change-id'),
	),
	(TEXTNS,u'change-end'): (
		(TEXTNS,u'change-id'),
	),
	(TEXTNS,u'change-start'): (
		(TEXTNS,u'change-id'),
	),
	(TEXTNS,u'changed-region'): (
		(TEXTNS,u'id'),
	),
	(TEXTNS,u'chapter'): (
		(TEXTNS,u'display'),
		(TEXTNS,u'outline-level'),
	),
	(TEXTNS,u'conditional-text'): (
		(TEXTNS,u'string-value-if-true'),
		(TEXTNS,u'string-value-if-false'),
		(TEXTNS,u'condition'),
	),
	(TEXTNS,u'database-display'): (
		(TEXTNS,u'column-name'),
		(TEXTNS,u'table-name'),
	),
	(TEXTNS,u'database-name'): (
		(TEXTNS,u'table-name'),
	),
	(TEXTNS,u'database-next'): (
		(TEXTNS,u'table-name'),
	),
	(TEXTNS,u'database-row-number'): (
		(TEXTNS,u'table-name'),
	),
	(TEXTNS,u'database-row-select'): (
		(TEXTNS,u'table-name'),
	),
	(TEXTNS,u'dde-connection'): (
		(TEXTNS,u'connection-name'),
	),
# required_attributes
	(TEXTNS,u'dde-connection-decl'): (
		(OFFICENS,u'dde-topic'),
		(OFFICENS,u'dde-application'),
		(OFFICENS,u'name'),
		(OFFICENS,u'dde-item'),
	),
	(TEXTNS,u'h'): (
		(TEXTNS,u'outline-level'),
	),
	(TEXTNS,u'hidden-paragraph'): (
		(TEXTNS,u'condition'),
	),
	(TEXTNS,u'hidden-text'): (
		(TEXTNS,u'string-value'),
		(TEXTNS,u'condition'),
	),
	(TEXTNS,u'illustration-index'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'illustration-index-entry-template'): (
		(TEXTNS,u'style-name'),
	),
	(TEXTNS,u'index-entry-bibliography'): (
		(TEXTNS,u'bibliography-data-field'),
	),
	(TEXTNS,u'index-source-style'): (
		(TEXTNS,u'style-name'),
	),
	(TEXTNS,u'index-source-styles'): (
		(TEXTNS,u'outline-level'),
	),
	(TEXTNS,u'index-title'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'list-level-style-bullet'): (
		(TEXTNS,u'bullet-char'),
		(TEXTNS,u'level'),
	),
	(TEXTNS,u'list-level-style-image'): (
		(TEXTNS,u'level'),
	),
	(TEXTNS,u'list-level-style-number'): (
		(TEXTNS,u'level'),
	),
	(TEXTNS,u'list-style'): (
		(STYLENS,u'name'),
	),
# required_attributes
	(TEXTNS,u'measure'): (
		(TEXTNS,u'kind'),
	),
	(TEXTNS,u'note'): (
		(TEXTNS,u'note-class'),
	),
	(TEXTNS,u'note-ref'): (
		(TEXTNS,u'note-class'),
	),
	(TEXTNS,u'notes-configuration'): (
		(TEXTNS,u'note-class'),
	),
	(TEXTNS,u'object-index'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'object-index-entry-template'): (
		(TEXTNS,u'style-name'),
	),
	(TEXTNS,u'outline-level-style'): (
		(TEXTNS,u'level'),
	),
	(TEXTNS,u'page'): (
		(TEXTNS,u'master-page-name'),
	),
	(TEXTNS,u'page-continuation'): (
		(TEXTNS,u'select-page'),
	),
	(TEXTNS,u'placeholder'): (
		(TEXTNS,u'placeholder-type'),
	),
	(TEXTNS,u'reference-mark'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'reference-mark-end'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'reference-mark-start'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'section'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'sequence'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'sequence-decl'): (
		(TEXTNS,u'display-outline-level'),
		(TEXTNS,u'name'),
	),
# required_attributes
	(TEXTNS,u'sort-key'): (
		(TEXTNS,u'key'),
	),
	(TEXTNS,u'table-index'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'table-index-entry-template'): (
		(TEXTNS,u'style-name'),
	),
	(TEXTNS,u'table-of-content'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'table-of-content-entry-template'): (
		(TEXTNS,u'style-name'),
		(TEXTNS,u'outline-level'),
	),
	(TEXTNS,u'toc-mark'): (
		(TEXTNS,u'string-value'),
	),
	(TEXTNS,u'toc-mark-end'): (
		(TEXTNS,u'id'),
	),
	(TEXTNS,u'toc-mark-start'): (
		(TEXTNS,u'id'),
	),
	(TEXTNS,u'user-defined'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'user-field-decl'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'user-field-get'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'user-field-input'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'user-index'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'user-index-entry-template'): (
		(TEXTNS,u'style-name'),
		(TEXTNS,u'outline-level'),
	),
# required_attributes
	(TEXTNS,u'user-index-mark'): (
		(TEXTNS,u'index-name'),
		(TEXTNS,u'string-value'),
	),
	(TEXTNS,u'user-index-mark-end'): (
		(TEXTNS,u'id'),
	),
	(TEXTNS,u'user-index-mark-start'): (
		(TEXTNS,u'index-name'),
		(TEXTNS,u'id'),
	),
	(TEXTNS,u'user-index-source'): (
		(TEXTNS,u'index-name'),
	),
	(TEXTNS,u'variable-decl'): (
		(TEXTNS,u'name'),
		(OFFICENS,u'value-type'),
	),
	(TEXTNS,u'variable-get'): (
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'variable-input'): (
		(TEXTNS,u'name'),
		(OFFICENS,u'value-type'),
	),
	(TEXTNS,u'variable-set'): (
		(TEXTNS,u'name'),
	),
}

# Empty list means the element has no allowed attributes
# None means anything goes

allowed_attributes = {
	(DCNS,u'creator'):(
	),
	(DCNS,u'date'):(
	),
	(DCNS,u'description'):(
	),
	(DCNS,u'language'):(
	),
	(DCNS,u'subject'):(
	),
	(DCNS,u'title'):(
	),
# Completes Dublin Core start
#	(DCNS,'contributor') : (
#	),
#	(DCNS,'coverage') : (
#	),
#	(DCNS,'format') : (
#	),
#	(DCNS,'identifier') : (
#	),
#	(DCNS,'publisher') : (
#	),
#	(DCNS,'relation') : (
#	),
#	(DCNS,'rights') : (
#	),
#	(DCNS,'source') : (
#	),
#	(DCNS,'type') : (
#	),
# Completes Dublin Core end
	(MATHNS,u'math'): None,
	(XFORMSNS,u'model'): None,
# allowed_attributes
	(ANIMNS,u'animate'):(
		(ANIMNS,u'formula'),
		(ANIMNS,u'sub-item'),
		(SMILNS,u'accelerate'),
		(SMILNS,u'accumulate'),
		(SMILNS,u'additive'),
		(SMILNS,u'attributeName'),
		(SMILNS,u'autoReverse'),
		(SMILNS,u'begin'),
		(SMILNS,u'by'),
		(SMILNS,u'calcMode'),
		(SMILNS,u'decelerate'),
		(SMILNS,u'dur'),
		(SMILNS,u'end'),
		(SMILNS,u'fill'),
		(SMILNS,u'fillDefault'),
		(SMILNS,u'from'),
		(SMILNS,u'keySplines'),
		(SMILNS,u'keyTimes'),
		(SMILNS,u'repeatCount'),
		(SMILNS,u'repeatDur'),
		(SMILNS,u'restart'),
		(SMILNS,u'restartDefault'),
		(SMILNS,u'targetElement'),
		(SMILNS,u'to'),
		(SMILNS,u'values'),
	),
# allowed_attributes
	(ANIMNS,u'animateColor'):(
		(ANIMNS,u'color-interpolation'),
		(ANIMNS,u'color-interpolation-direction'),
		(ANIMNS,u'formula'),
		(ANIMNS,u'sub-item'),
		(SMILNS,u'accelerate'),
		(SMILNS,u'accumulate'),
		(SMILNS,u'additive'),
		(SMILNS,u'attributeName'),
		(SMILNS,u'autoReverse'),
		(SMILNS,u'begin'),
		(SMILNS,u'by'),
		(SMILNS,u'calcMode'),
		(SMILNS,u'decelerate'),
		(SMILNS,u'dur'),
		(SMILNS,u'end'),
		(SMILNS,u'fill'),
		(SMILNS,u'fillDefault'),
		(SMILNS,u'from'),
		(SMILNS,u'keySplines'),
		(SMILNS,u'keyTimes'),
		(SMILNS,u'repeatCount'),
		(SMILNS,u'repeatDur'),
		(SMILNS,u'restart'),
		(SMILNS,u'restartDefault'),
		(SMILNS,u'targetElement'),
		(SMILNS,u'to'),
		(SMILNS,u'values'),
	),
# allowed_attributes
	(ANIMNS,u'animateMotion'):(
		(ANIMNS,u'formula'),
		(ANIMNS,u'sub-item'),
		(SMILNS,u'accelerate'),
		(SMILNS,u'accumulate'),
		(SMILNS,u'additive'),
		(SMILNS,u'attributeName'),
		(SMILNS,u'autoReverse'),
		(SMILNS,u'begin'),
		(SMILNS,u'by'),
		(SMILNS,u'calcMode'),
		(SMILNS,u'decelerate'),
		(SMILNS,u'dur'),
		(SMILNS,u'end'),
		(SMILNS,u'fill'),
		(SMILNS,u'fillDefault'),
		(SMILNS,u'from'),
		(SMILNS,u'keySplines'),
		(SMILNS,u'keyTimes'),
		(SMILNS,u'repeatCount'),
		(SMILNS,u'repeatDur'),
		(SMILNS,u'restart'),
		(SMILNS,u'restartDefault'),
		(SMILNS,u'targetElement'),
		(SMILNS,u'to'),
		(SMILNS,u'values'),
		(SVGNS,u'origin'),
		(SVGNS,u'path'),
	),
# allowed_attributes
	(ANIMNS,u'animateTransform'):(
		(ANIMNS,u'formula'),
		(ANIMNS,u'sub-item'),
		(SMILNS,u'accelerate'),
		(SMILNS,u'accumulate'),
		(SMILNS,u'additive'),
		(SMILNS,u'attributeName'),
		(SMILNS,u'autoReverse'),
		(SMILNS,u'begin'),
		(SMILNS,u'by'),
		(SMILNS,u'decelerate'),
		(SMILNS,u'dur'),
		(SMILNS,u'end'),
		(SMILNS,u'fill'),
		(SMILNS,u'fillDefault'),
		(SMILNS,u'from'),
		(SMILNS,u'repeatCount'),
		(SMILNS,u'repeatDur'),
		(SMILNS,u'restart'),
		(SMILNS,u'restartDefault'),
		(SMILNS,u'targetElement'),
		(SMILNS,u'to'),
		(SMILNS,u'values'),
		(SVGNS,u'type'),
	),
# allowed_attributes
	(ANIMNS,u'audio'):(
		(ANIMNS,u'audio-level'),
		(ANIMNS,u'id'),
		(PRESENTATIONNS,u'group-id'),
		(PRESENTATIONNS,u'master-element'),
		(PRESENTATIONNS,u'node-type'),
		(PRESENTATIONNS,u'preset-class'),
		(PRESENTATIONNS,u'preset-id'),
		(PRESENTATIONNS,u'preset-sub-type'),
		(SMILNS,u'begin'),
		(SMILNS,u'dur'),
		(SMILNS,u'end'),
		(SMILNS,u'repeatCount'),
		(SMILNS,u'repeatDur'),
		(XLINKNS,u'href'),
	),
	(ANIMNS,u'command'):(
		(PRESENTATIONNS,u'node-type'),
		(SMILNS,u'begin'),
		(SMILNS,u'end'),
		(PRESENTATIONNS,u'group-id'),
		(PRESENTATIONNS,u'preset-class'),
		(PRESENTATIONNS,u'preset-id'),
		(ANIMNS,u'sub-item'),
		(ANIMNS,u'command'),
		(PRESENTATIONNS,u'preset-sub-type'),
		(SMILNS,u'targetElement'),
		(ANIMNS,u'id'),
		(PRESENTATIONNS,u'master-element'),
	),
# allowed_attributes
	(ANIMNS,u'iterate'):(
		(ANIMNS,u'id'),
		(ANIMNS,u'iterate-interval'),
		(ANIMNS,u'iterate-type'),
		(ANIMNS,u'sub-item'),
		(PRESENTATIONNS,u'group-id'),
		(PRESENTATIONNS,u'master-element'),
		(PRESENTATIONNS,u'node-type'),
		(PRESENTATIONNS,u'preset-class'),
		(PRESENTATIONNS,u'preset-id'),
		(PRESENTATIONNS,u'preset-sub-type'),
		(SMILNS,u'accelerate'),
		(SMILNS,u'autoReverse'),
		(SMILNS,u'begin'),
		(SMILNS,u'decelerate'),
		(SMILNS,u'dur'),
		(SMILNS,u'end'),
		(SMILNS,u'endsync'),
		(SMILNS,u'fill'),
		(SMILNS,u'fillDefault'),
		(SMILNS,u'repeatCount'),
		(SMILNS,u'repeatDur'),
		(SMILNS,u'restart'),
		(SMILNS,u'restartDefault'),
		(SMILNS,u'targetElement'),
	),
	(ANIMNS,u'par'):(
		(PRESENTATIONNS,u'node-type'),
		(SMILNS,u'decelerate'),
		(SMILNS,u'begin'),
		(SMILNS,u'end'),
		(PRESENTATIONNS,u'group-id'),
		(SMILNS,u'accelerate'),
		(SMILNS,u'repeatDur'),
		(SMILNS,u'repeatCount'),
		(SMILNS,u'autoReverse'),
		(PRESENTATIONNS,u'preset-class'),
		(SMILNS,u'fillDefault'),
		(PRESENTATIONNS,u'preset-id'),
		(PRESENTATIONNS,u'preset-sub-type'),
		(SMILNS,u'restartDefault'),
		(SMILNS,u'endsync'),
		(SMILNS,u'dur'),
		(SMILNS,u'fill'),
		(ANIMNS,u'id'),
		(SMILNS,u'restart'),
		(PRESENTATIONNS,u'master-element'),
	),
# allowed_attributes
	(ANIMNS,u'param'):(
		(ANIMNS,u'name'),
		(ANIMNS,u'value'),
	),
	(ANIMNS,u'seq'):(
		(ANIMNS,u'id'),
		(PRESENTATIONNS,u'group-id'),
		(PRESENTATIONNS,u'master-element'),
		(PRESENTATIONNS,u'node-type'),
		(PRESENTATIONNS,u'preset-class'),
		(PRESENTATIONNS,u'preset-id'),
		(PRESENTATIONNS,u'preset-sub-type'),
		(SMILNS,u'accelerate'),
		(SMILNS,u'autoReverse'),
		(SMILNS,u'begin'),
		(SMILNS,u'decelerate'),
		(SMILNS,u'dur'),
		(SMILNS,u'end'),
		(SMILNS,u'endsync'),
		(SMILNS,u'fill'),
		(SMILNS,u'fillDefault'),
		(SMILNS,u'repeatCount'),
		(SMILNS,u'repeatDur'),
		(SMILNS,u'restart'),
		(SMILNS,u'restartDefault'),
	),
	(ANIMNS,u'set'):(
		(ANIMNS,u'sub-item'),
		(SMILNS,u'accelerate'),
		(SMILNS,u'accumulate'),
		(SMILNS,u'autoReverse'),
		(SMILNS,u'additive'),
		(SMILNS,u'attributeName'),
		(SMILNS,u'begin'),
		(SMILNS,u'decelerate'),
		(SMILNS,u'dur'),
		(SMILNS,u'end'),
		(SMILNS,u'fill'),
		(SMILNS,u'fillDefault'),
		(SMILNS,u'repeatCount'),
		(SMILNS,u'repeatDur'),
		(SMILNS,u'restart'),
		(SMILNS,u'restartDefault'),
		(SMILNS,u'targetElement'),
		(SMILNS,u'to'),

	),
# allowed_attributes
	(ANIMNS,u'transitionFilter'):(
		(ANIMNS,u'formula'),
		(ANIMNS,u'sub-item'),
		(SMILNS,u'accelerate'),
		(SMILNS,u'accumulate'),
		(SMILNS,u'additive'),
		(SMILNS,u'autoReverse'),
		(SMILNS,u'begin'),
		(SMILNS,u'by'),
		(SMILNS,u'calcMode'),
		(SMILNS,u'decelerate'),
		(SMILNS,u'direction'),
		(SMILNS,u'dur'),
		(SMILNS,u'end'),
		(SMILNS,u'fadeColor'),
		(SMILNS,u'fill'),
		(SMILNS,u'fillDefault'),
		(SMILNS,u'from'),
		(SMILNS,u'mode'),
		(SMILNS,u'repeatCount'),
		(SMILNS,u'repeatDur'),
		(SMILNS,u'restart'),
		(SMILNS,u'restartDefault'),
		(SMILNS,u'subtype'),
		(SMILNS,u'targetElement'),
		(SMILNS,u'to'),
		(SMILNS,u'type'),
		(SMILNS,u'values'),

	),
# allowed_attributes
	(CHARTNS,u'axis'):(
		(CHARTNS,u'style-name'),
		(CHARTNS,u'dimension'),
		(CHARTNS,u'name'),
	),
	(CHARTNS,u'categories'):(
		(TABLENS,u'cell-range-address'),
	),
	(CHARTNS,u'chart'):(
		(CHARTNS,u'column-mapping'),
		(CHARTNS,u'row-mapping'),
		(SVGNS,u'height'),
		(SVGNS,u'width'),
		(CHARTNS,u'style-name'),
		(CHARTNS,u'class'),
	),
	(CHARTNS,u'data-point'):(
		(CHARTNS,u'repeated'),
		(CHARTNS,u'style-name'),
	),
	(CHARTNS,u'domain'):(
		(TABLENS,u'cell-range-address'),
	),
	(CHARTNS,u'error-indicator'):(
		(CHARTNS,u'style-name'),
	),
	(CHARTNS,u'floor'):(
		(SVGNS,u'width'),
		(CHARTNS,u'style-name'),
	),
# allowed_attributes
	(CHARTNS,u'footer'):(
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(TABLENS,u'cell-range'),
		(CHARTNS,u'style-name'),
	),
	(CHARTNS,u'grid'):(
		(CHARTNS,u'style-name'),
		(CHARTNS,u'class'),
	),
	(CHARTNS,u'legend'):(
		(CHARTNS,u'legend-align'),
		(STYLENS,u'legend-expansion-aspect-ratio'),
		(STYLENS,u'legend-expansion'),
		(CHARTNS,u'legend-position'),
		(CHARTNS,u'style-name'),
		(SVGNS,u'y'),
		(SVGNS,u'x'),
	),
	(CHARTNS,u'mean-value'):(
		(CHARTNS,u'style-name'),
	),
	(CHARTNS,u'plot-area'):(
		(DR3DNS,u'ambient-color'),
		(DR3DNS,u'distance'),
		(DR3DNS,u'vrp'),
		(DR3DNS,u'focal-length'),
		(CHARTNS,u'data-source-has-labels'),
		(DR3DNS,u'lighting-mode'),
		(DR3DNS,u'shade-mode'),
		(DR3DNS,u'transform'),
		(DR3DNS,u'shadow-slant'),
		(SVGNS,u'height'),
		(SVGNS,u'width'),
		(CHARTNS,u'style-name'),
		(DR3DNS,u'vup'),
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(DR3DNS,u'vpn'),
		(TABLENS,u'cell-range-address'),
		(DR3DNS,u'projection'),
	),
	(CHARTNS,u'regression-curve'):(
		(CHARTNS,u'style-name'),
	),
	(CHARTNS,u'series'):(
		(CHARTNS,u'style-name'),
		(CHARTNS,u'attached-axis'),
		(CHARTNS,u'values-cell-range-address'),
		(CHARTNS,u'label-cell-address'),
		(CHARTNS,u'class'),
	),
	(CHARTNS,u'stock-gain-marker'):(
		(CHARTNS,u'style-name'),
	),
# allowed_attributes
	(CHARTNS,u'stock-loss-marker'):(
		(CHARTNS,u'style-name'),
	),
	(CHARTNS,u'stock-range-line'):(
		(CHARTNS,u'style-name'),
	),
	(CHARTNS,u'subtitle'):(
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(TABLENS,u'cell-range'),
		(CHARTNS,u'style-name'),
	),
	(CHARTNS,u'symbol-image'):(
		(XLINKNS,u'href'),
	),
	(CHARTNS,u'title'):(
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(TABLENS,u'cell-range'),
		(CHARTNS,u'style-name'),
	),
	(CHARTNS,u'wall'):(
		(SVGNS,u'width'),
		(CHARTNS,u'style-name'),
	),
	(CONFIGNS,u'config-item'):(
		(CONFIGNS,u'type'),
		(CONFIGNS,u'name'),
	),
	(CONFIGNS,u'config-item-map-entry'):(
		(CONFIGNS,u'name'),
	),
	(CONFIGNS,u'config-item-map-indexed'):(
		(CONFIGNS,u'name'),
	),
	(CONFIGNS,u'config-item-map-named'):(
		(CONFIGNS,u'name'),
	),
	(CONFIGNS,u'config-item-set'):(
		(CONFIGNS,u'name'),
	),
# allowed_attributes
	(NUMBERNS,u'am-pm'):(
	),
	(NUMBERNS,u'boolean'):(
	),
	(NUMBERNS,u'boolean-style'):(
		(NUMBERNS,u'transliteration-language'),
		(STYLENS,u'name'),
		(STYLENS,u'display-name'),
		(NUMBERNS,u'language'),
		(NUMBERNS,u'title'),
		(NUMBERNS,u'country'),
		(NUMBERNS,u'transliteration-format'),
		(NUMBERNS,u'transliteration-style'),
		(STYLENS,u'volatile'),
		(NUMBERNS,u'transliteration-country'),
	),
	(NUMBERNS,u'currency-style'):(
		(NUMBERNS,u'transliteration-language'),
		(STYLENS,u'name'),
		(STYLENS,u'display-name'),
		(NUMBERNS,u'language'),
		(NUMBERNS,u'title'),
		(NUMBERNS,u'country'),
		(NUMBERNS,u'transliteration-format'),
		(NUMBERNS,u'transliteration-style'),
		(STYLENS,u'volatile'),
		(NUMBERNS,u'transliteration-country'),
		(NUMBERNS,u'automatic-order'),
	),
	(NUMBERNS,u'currency-symbol'):(
		(NUMBERNS,u'country'),
		(NUMBERNS,u'language'),
	),
# allowed_attributes
	(NUMBERNS,u'date-style'):(
		(NUMBERNS,u'transliteration-language'),
		(STYLENS,u'name'),
		(STYLENS,u'display-name'),
		(NUMBERNS,u'language'),
		(NUMBERNS,u'title'),
		(NUMBERNS,u'country'),
		(NUMBERNS,u'transliteration-format'),
		(NUMBERNS,u'transliteration-style'),
		(NUMBERNS,u'format-source'),
		(STYLENS,u'volatile'),
		(NUMBERNS,u'transliteration-country'),
		(NUMBERNS,u'automatic-order'),
	),
	(NUMBERNS,u'day'):(
		(NUMBERNS,u'style'),
		(NUMBERNS,u'calendar'),
	),
	(NUMBERNS,u'day-of-week'):(
		(NUMBERNS,u'style'),
		(NUMBERNS,u'calendar'),
	),
	(NUMBERNS,u'embedded-text'):(
		(NUMBERNS,u'position'),
	),
	(NUMBERNS,u'era'):(
		(NUMBERNS,u'style'),
		(NUMBERNS,u'calendar'),
	),
	(NUMBERNS,u'fraction'):(
		(NUMBERNS,u'grouping'),
		(NUMBERNS,u'min-denominator-digits'),
		(NUMBERNS,u'min-numerator-digits'),
		(NUMBERNS,u'min-integer-digits'),
		(NUMBERNS,u'denominator-value'),
	),
	(NUMBERNS,u'hours'):(
		(NUMBERNS,u'style'),
	),
# allowed_attributes
	(NUMBERNS,u'minutes'):(
		(NUMBERNS,u'style'),
	),
	(NUMBERNS,u'month'):(
		(NUMBERNS,u'style'),
		(NUMBERNS,u'calendar'),
		(NUMBERNS,u'possessive-form'),
		(NUMBERNS,u'textual'),
	),
	(NUMBERNS,u'number'):(
		(NUMBERNS,u'display-factor'),
		(NUMBERNS,u'decimal-places'),
		(NUMBERNS,u'decimal-replacement'),
		(NUMBERNS,u'min-integer-digits'),
		(NUMBERNS,u'grouping'),
	),
	(NUMBERNS,u'number-style'):(
		(NUMBERNS,u'transliteration-language'),
		(STYLENS,u'name'),
		(STYLENS,u'display-name'),
		(NUMBERNS,u'language'),
		(NUMBERNS,u'title'),
		(NUMBERNS,u'country'),
		(NUMBERNS,u'transliteration-format'),
		(NUMBERNS,u'transliteration-style'),
		(STYLENS,u'volatile'),
		(NUMBERNS,u'transliteration-country'),
	),
# allowed_attributes
	(NUMBERNS,u'percentage-style'):(
		(NUMBERNS,u'transliteration-language'),
		(STYLENS,u'name'),
		(STYLENS,u'display-name'),
		(NUMBERNS,u'language'),
		(NUMBERNS,u'title'),
		(NUMBERNS,u'country'),
		(NUMBERNS,u'transliteration-format'),
		(NUMBERNS,u'transliteration-style'),
		(STYLENS,u'volatile'),
		(NUMBERNS,u'transliteration-country'),
	),
	(NUMBERNS,u'quarter'):(
		(NUMBERNS,u'style'),
		(NUMBERNS,u'calendar'),
	),
	(NUMBERNS,u'scientific-number'):(
		(NUMBERNS,u'min-exponent-digits'),
		(NUMBERNS,u'decimal-places'),
		(NUMBERNS,u'min-integer-digits'),
		(NUMBERNS,u'grouping'),
	),
	(NUMBERNS,u'seconds'):(
		(NUMBERNS,u'style'),
		(NUMBERNS,u'decimal-places'),
	),
	(NUMBERNS,u'text'):(
	),
	(NUMBERNS,u'text-content'):(
	),
	(NUMBERNS,u'text-style'):(
		(NUMBERNS,u'transliteration-language'),
		(STYLENS,u'name'),
		(STYLENS,u'display-name'),
		(NUMBERNS,u'language'),
		(NUMBERNS,u'title'),
		(NUMBERNS,u'country'),
		(NUMBERNS,u'transliteration-format'),
		(NUMBERNS,u'transliteration-style'),
		(STYLENS,u'volatile'),
		(NUMBERNS,u'transliteration-country'),
	),
	(NUMBERNS,u'time-style'):(
		(NUMBERNS,u'transliteration-language'),
		(NUMBERNS,u'transliteration-format'),
		(STYLENS,u'name'),
		(STYLENS,u'display-name'),
		(NUMBERNS,u'language'),
		(NUMBERNS,u'title'),
		(NUMBERNS,u'country'),
		(NUMBERNS,u'truncate-on-overflow'),
		(NUMBERNS,u'transliteration-style'),
		(NUMBERNS,u'format-source'),
		(STYLENS,u'volatile'),
		(NUMBERNS,u'transliteration-country'),
	),
	(NUMBERNS,u'week-of-year'):(
		(NUMBERNS,u'calendar'),
	),
	(NUMBERNS,u'year'):(
		(NUMBERNS,u'style'),
		(NUMBERNS,u'calendar'),
	),
	(DR3DNS,u'cube'):(
		(DR3DNS,u'min-edge'),
		(DR3DNS,u'max-edge'),
		(DRAWNS,u'layer'),
		(DR3DNS,u'transform'),
		(DRAWNS,u'z-index'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
		(DRAWNS,u'id'),
	),
	(DR3DNS,u'extrude'):(
		(DRAWNS,u'layer'),
		(SVGNS,u'd'),
		(DR3DNS,u'transform'),
		(SVGNS,u'viewBox'),
		(DRAWNS,u'z-index'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
		(DRAWNS,u'id'),
	),
	(DR3DNS,u'light'):(
		(DR3DNS,u'diffuse-color'),
		(DR3DNS,u'direction'),
		(DR3DNS,u'specular'),
		(DR3DNS,u'enabled'),
	),
	(DR3DNS,u'rotate'):(
		(DRAWNS,u'layer'),
		(SVGNS,u'd'),
		(DR3DNS,u'transform'),
		(SVGNS,u'viewBox'),
		(DRAWNS,u'z-index'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
		(DRAWNS,u'id'),
	),
# allowed_attributes
	(DR3DNS,u'scene'):(
		(DR3DNS,u'ambient-color'),
		(DR3DNS,u'distance'),
		(DR3DNS,u'focal-length'),
		(DR3DNS,u'lighting-mode'),
		(DR3DNS,u'projection'),
		(DR3DNS,u'shade-mode'),
		(DR3DNS,u'shadow-slant'),
		(DR3DNS,u'transform'),
		(DR3DNS,u'vpn'),
		(DR3DNS,u'vrp'),
		(DR3DNS,u'vup'),
		(DRAWNS,u'id'),
                (DRAWNS,u'caption-id'),
		(DRAWNS,u'layer'),
		(DRAWNS,u'z-index'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
		(PRESENTATIONNS,u'style-name'),
		(SVGNS,u'height'),
		(SVGNS,u'width'),
		(SVGNS,u'x'),
		(SVGNS,u'y'),
		(TABLENS,u'end-cell-address'),
		(TABLENS,u'end-x'),
		(TABLENS,u'end-y'),
		(TABLENS,u'table-background'),
		(TEXTNS,u'anchor-page-number'),
		(TEXTNS,u'anchor-type'),
	),
	(DR3DNS,u'sphere'):(
		(DRAWNS,u'layer'),
		(DR3DNS,u'center'),
		(DR3DNS,u'transform'),
		(DRAWNS,u'z-index'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
		(DRAWNS,u'id'),
		(DR3DNS,u'size'),
	),
	(DRAWNS,u'a'):(
		(OFFICENS,u'name'),
		(OFFICENS,u'title'),
		(XLINKNS,u'show'),
		(OFFICENS,u'target-frame-name'),
		(XLINKNS,u'actuate'),
		(XLINKNS,u'href'),
		(XLINKNS,u'type'),
		(OFFICENS,u'server-map'),
	),
	(DRAWNS,u'applet'):(
		(DRAWNS,u'code'),
		(XLINKNS,u'show'),
		(DRAWNS,u'object'),
		(XLINKNS,u'actuate'),
		(XLINKNS,u'href'),
		(XLINKNS,u'type'),
		(DRAWNS,u'archive'),
		(DRAWNS,u'may-script'),
	),
	(DRAWNS,u'area-circle'):(
		(OFFICENS,u'name'),
		(XLINKNS,u'show'),
		(SVGNS,u'cx'),
		(XLINKNS,u'type'),
		(DRAWNS,u'nohref'),
		(SVGNS,u'cy'),
		(XLINKNS,u'href'),
		(SVGNS,u'r'),
		(OFFICENS,u'target-frame-name'),
	),
	(DRAWNS,u'area-polygon'):(
		(OFFICENS,u'name'),
		(XLINKNS,u'show'),
		(XLINKNS,u'type'),
		(SVGNS,u'height'),
		(DRAWNS,u'nohref'),
		(SVGNS,u'width'),
		(XLINKNS,u'href'),
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(OFFICENS,u'target-frame-name'),
		(SVGNS,u'viewBox'),
		(DRAWNS,u'points'),
	),
	(DRAWNS,u'area-rectangle'):(
		(OFFICENS,u'name'),
		(XLINKNS,u'show'),
		(XLINKNS,u'type'),
		(SVGNS,u'height'),
		(DRAWNS,u'nohref'),
		(SVGNS,u'width'),
		(XLINKNS,u'href'),
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(OFFICENS,u'target-frame-name'),
	),
	(DRAWNS,u'caption'):(
		(TABLENS,u'table-background'),
		(DRAWNS,u'layer'),
                (DRAWNS,u'caption-id'),
		(TABLENS,u'end-cell-address'),
		(DRAWNS,u'name'),
		(DRAWNS,u'text-style-name'),
		(DRAWNS,u'caption-point-y'),
		(DRAWNS,u'caption-point-x'),
		(DRAWNS,u'transform'),
		(TABLENS,u'end-y'),
		(DRAWNS,u'corner-radius'),
		(SVGNS,u'width'),
		(DRAWNS,u'z-index'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
		(TABLENS,u'end-x'),
		(TEXTNS,u'anchor-page-number'),
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(SVGNS,u'height'),
		(DRAWNS,u'id'),
		(TEXTNS,u'anchor-type'),
	),
	(DRAWNS,u'circle'):(
		(DRAWNS,u'end-angle'),
		(DRAWNS,u'id'),
		(DRAWNS,u'kind'),
		(DRAWNS,u'layer'),
		(DRAWNS,u'name'),
		(DRAWNS,u'start-angle'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
                (DRAWNS,u'caption-id'),
		(DRAWNS,u'text-style-name'),
		(DRAWNS,u'transform'),
		(DRAWNS,u'z-index'),
		(PRESENTATIONNS,u'class-names'),
		(PRESENTATIONNS,u'style-name'),
		(SVGNS,u'cx'),
		(SVGNS,u'cy'),
		(SVGNS,u'height'),
		(SVGNS,u'r'),
		(SVGNS,u'width'),
		(SVGNS,u'x'),
		(SVGNS,u'y'),
		(TABLENS,u'end-cell-address'),
		(TABLENS,u'end-x'),
		(TABLENS,u'end-y'),
		(TABLENS,u'table-background'),
		(TEXTNS,u'anchor-page-number'),
		(TEXTNS,u'anchor-type'),
	),
	(DRAWNS,u'connector'):(
		(DRAWNS,u'layer'),
		(DRAWNS,u'end-shape'),
		(TEXTNS,u'anchor-page-number'),
		(SVGNS,u'y1'),
		(SVGNS,u'y2'),
		(TABLENS,u'table-background'),
		(TABLENS,u'end-cell-address'),
		(DRAWNS,u'transform'),
		(DRAWNS,u'id'),
		(TABLENS,u'end-y'),
		(TABLENS,u'end-x'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
                (DRAWNS,u'caption-id'),
		(DRAWNS,u'type'),
		(DRAWNS,u'start-shape'),
		(DRAWNS,u'z-index'),
		(PRESENTATIONNS,u'style-name'),
		(DRAWNS,u'start-glue-point'),
		(SVGNS,u'x2'),
		(SVGNS,u'x1'),
		(TEXTNS,u'anchor-type'),
		(DRAWNS,u'line-skew'),
		(DRAWNS,u'name'),
		(DRAWNS,u'end-glue-point'),
		(DRAWNS,u'text-style-name'),
	),
	(DRAWNS,u'contour-path'):(
		(SVGNS,u'd'),
		(SVGNS,u'width'),
		(DRAWNS,u'recreate-on-edit'),
		(SVGNS,u'viewBox'),
		(SVGNS,u'height'),
	),
	(DRAWNS,u'contour-polygon'):(
		(SVGNS,u'width'),
		(DRAWNS,u'points'),
		(DRAWNS,u'recreate-on-edit'),
		(SVGNS,u'viewBox'),
		(SVGNS,u'height'),
	),
	(DRAWNS,u'control'):(
		(DRAWNS,u'control'),
		(DRAWNS,u'layer'),
                (DRAWNS,u'caption-id'),
		(TABLENS,u'end-cell-address'),
		(DRAWNS,u'name'),
		(DRAWNS,u'text-style-name'),
		(TABLENS,u'table-background'),
		(DRAWNS,u'transform'),
		(SVGNS,u'height'),
		(SVGNS,u'width'),
		(DRAWNS,u'z-index'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
		(TABLENS,u'end-x'),
		(TEXTNS,u'anchor-page-number'),
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(TABLENS,u'end-y'),
		(DRAWNS,u'id'),
		(TEXTNS,u'anchor-type'),
	),
	(DRAWNS,u'custom-shape'):(
		(DRAWNS,u'engine'),
                (DRAWNS,u'caption-id'),
		(DRAWNS,u'layer'),
		(TABLENS,u'end-cell-address'),
		(DRAWNS,u'name'),
		(DRAWNS,u'text-style-name'),
		(TABLENS,u'table-background'),
		(DRAWNS,u'transform'),
		(SVGNS,u'height'),
		(SVGNS,u'width'),
		(DRAWNS,u'z-index'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
		(TABLENS,u'end-x'),
		(TEXTNS,u'anchor-page-number'),
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(TABLENS,u'end-y'),
		(DRAWNS,u'data'),
		(DRAWNS,u'id'),
		(TEXTNS,u'anchor-type'),
	),
# allowed_attributes
	(DRAWNS,u'ellipse'):(
		(DRAWNS,u'layer'),
		(DRAWNS,u'start-angle'),
		(SVGNS,u'cy'),
		(SVGNS,u'cx'),
		(TABLENS,u'table-background'),
		(TABLENS,u'end-cell-address'),
		(SVGNS,u'rx'),
		(DRAWNS,u'transform'),
		(DRAWNS,u'id'),
		(SVGNS,u'width'),
		(TABLENS,u'end-y'),
		(TABLENS,u'end-x'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
		(DRAWNS,u'end-angle'),
		(DRAWNS,u'z-index'),
                (DRAWNS,u'caption-id'),
		(PRESENTATIONNS,u'style-name'),
		(SVGNS,u'height'),
		(TEXTNS,u'anchor-type'),
		(SVGNS,u'ry'),
		(DRAWNS,u'kind'),
		(DRAWNS,u'name'),
		(TEXTNS,u'anchor-page-number'),
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(DRAWNS,u'text-style-name'),
	),
# allowed_attributes
	(DRAWNS,u'enhanced-geometry'):(
		(DRAWNS,u'extrusion-rotation-center'),
		(DRAWNS,u'extrusion-shininess'),
		(DRAWNS,u'extrusion-rotation-angle'),
		(DRAWNS,u'extrusion-allowed'),
		(DRAWNS,u'extrusion-first-light-level'),
		(DRAWNS,u'extrusion-specularity'),
		(DRAWNS,u'extrusion-viewpoint'),
		(DRAWNS,u'extrusion-second-light-level'),
		(DRAWNS,u'extrusion-origin'),
		(DRAWNS,u'extrusion-color'),
		(SVGNS,u'viewBox'),
		(DR3DNS,u'projection'),
		(DRAWNS,u'extrusion-metal'),
		(DRAWNS,u'extrusion-number-of-line-segments'),
		(DRAWNS,u'text-path-same-letter-heights'),
		(DRAWNS,u'extrusion-first-light-harsh'),
		(DRAWNS,u'enhanced-path'),
		(DRAWNS,u'text-rotate-angle'),
		(DRAWNS,u'type'),
		(DRAWNS,u'glue-point-leaving-directions'),
		(DRAWNS,u'concentric-gradient-fill-allowed'),
		(DRAWNS,u'text-path-scale'),
		(DRAWNS,u'extrusion-brightness'),
		(DRAWNS,u'extrusion-first-light-direction'),
		(DRAWNS,u'extrusion-light-face'),
		(DRAWNS,u'text-path-allowed'),
		(DRAWNS,u'glue-points'),
		(DRAWNS,u'mirror-vertical'),
		(DRAWNS,u'extrusion-depth'),
		(DRAWNS,u'extrusion-diffusion'),
		(DRAWNS,u'extrusion-second-light-direction'),
		(DRAWNS,u'extrusion-skew'),
		(DR3DNS,u'shade-mode'),
		(DRAWNS,u'path-stretchpoint-y'),
		(DRAWNS,u'modifiers'),
		(DRAWNS,u'extrusion'),
		(DRAWNS,u'path-stretchpoint-x'),
		(DRAWNS,u'text-areas'),
		(DRAWNS,u'mirror-horizontal'),
		(DRAWNS,u'text-path-mode'),
		(DRAWNS,u'extrusion-second-light-harsh'),
		(DRAWNS,u'glue-point-type'),
		(DRAWNS,u'text-path'),
	),
# allowed_attributes
	(DRAWNS,u'equation'):(
		(DRAWNS,u'formula'),
		(DRAWNS,u'name'),
	),
	(DRAWNS,u'fill-image'):(
		(DRAWNS,u'name'),
		(XLINKNS,u'show'),
		(XLINKNS,u'actuate'),
		(SVGNS,u'height'),
		(SVGNS,u'width'),
		(XLINKNS,u'href'),
		(DRAWNS,u'display-name'),
		(XLINKNS,u'type'),
	),
	(DRAWNS,u'floating-frame'):(
		(XLINKNS,u'href'),
		(XLINKNS,u'actuate'),
		(DRAWNS,u'frame-name'),
		(XLINKNS,u'type'),
		(XLINKNS,u'show'),
	),
	(DRAWNS,u'frame'):(
		(DRAWNS,u'copy-of'),
		(DRAWNS,u'id'),
		(DRAWNS,u'layer'),
		(DRAWNS,u'name'),
		(DRAWNS,u'class-names'),
                (DRAWNS,u'caption-id'),
		(DRAWNS,u'style-name'),
		(DRAWNS,u'text-style-name'),
		(DRAWNS,u'transform'),
		(DRAWNS,u'z-index'),
		(PRESENTATIONNS,u'class'),
		(PRESENTATIONNS,u'class-names'),
		(PRESENTATIONNS,u'placeholder'),
		(PRESENTATIONNS,u'style-name'),
		(PRESENTATIONNS,u'user-transformed'),
		(STYLENS,u'rel-height'),
		(STYLENS,u'rel-width'),
		(SVGNS,u'height'),
		(SVGNS,u'width'),
		(SVGNS,u'x'),
		(SVGNS,u'y'),
		(TABLENS,u'end-cell-address'),
		(TABLENS,u'end-x'),
		(TABLENS,u'end-y'),
		(TABLENS,u'table-background'),
		(TEXTNS,u'anchor-page-number'),
		(TEXTNS,u'anchor-type'),
	),
# allowed_attributes
	(DRAWNS,u'g'):(
		(DRAWNS,u'id'),
                (DRAWNS,u'caption-id'),
		(DRAWNS,u'name'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(DRAWNS,u'z-index'),
		(PRESENTATIONNS,u'class-names'),
		(PRESENTATIONNS,u'style-name'),
		(SVGNS,u'y'),
		(TABLENS,u'end-cell-address'),
		(TABLENS,u'end-x'),
		(TABLENS,u'end-y'),
		(TABLENS,u'table-background'),
		(TEXTNS,u'anchor-page-number'),
		(TEXTNS,u'anchor-type'),
	),
	(DRAWNS,u'glue-point'):(
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(DRAWNS,u'align'),
		(DRAWNS,u'id'),
		(DRAWNS,u'escape-direction'),
	),
	(DRAWNS,u'gradient'):(
		(DRAWNS,u'style'),
		(DRAWNS,u'angle'),
		(DRAWNS,u'name'),
		(DRAWNS,u'end-color'),
		(DRAWNS,u'start-color'),
		(DRAWNS,u'cy'),
		(DRAWNS,u'cx'),
		(DRAWNS,u'display-name'),
		(DRAWNS,u'border'),
		(DRAWNS,u'end-intensity'),
		(DRAWNS,u'start-intensity'),
	),
	(DRAWNS,u'handle'):(
		(DRAWNS,u'handle-radius-range-minimum'),
		(DRAWNS,u'handle-switched'),
		(DRAWNS,u'handle-range-y-maximum'),
		(DRAWNS,u'handle-mirror-horizontal'),
		(DRAWNS,u'handle-range-x-maximum'),
		(DRAWNS,u'handle-mirror-vertical'),
		(DRAWNS,u'handle-range-y-minimum'),
		(DRAWNS,u'handle-radius-range-maximum'),
		(DRAWNS,u'handle-range-x-minimum'),
		(DRAWNS,u'handle-position'),
		(DRAWNS,u'handle-polar'),
	),
	(DRAWNS,u'hatch'):(
		(DRAWNS,u'distance'),
		(DRAWNS,u'style'),
		(DRAWNS,u'name'),
		(DRAWNS,u'color'),
		(DRAWNS,u'display-name'),
		(DRAWNS,u'rotation'),
	),
	(DRAWNS,u'image'):(
		(DRAWNS,u'filter-name'),
		(XLINKNS,u'href'),
		(XLINKNS,u'type'),
		(XLINKNS,u'actuate'),
		(XLINKNS,u'show'),
	),
	(DRAWNS,u'image-map'):(
	),
	(DRAWNS,u'layer'):(
		(DRAWNS,u'protected'),
		(DRAWNS,u'name'),
		(DRAWNS,u'display'),
	),
# allowed_attributes
	(DRAWNS,u'layer-set'):(
	),
	(DRAWNS,u'line'):(
		(DRAWNS,u'class-names'),
		(DRAWNS,u'id'),
                (DRAWNS,u'caption-id'),
		(DRAWNS,u'layer'),
		(DRAWNS,u'name'),
		(DRAWNS,u'style-name'),
		(DRAWNS,u'text-style-name'),
		(DRAWNS,u'transform'),
		(DRAWNS,u'z-index'),
		(PRESENTATIONNS,u'class-names'),
		(PRESENTATIONNS,u'style-name'),
		(SVGNS,u'x1'),
		(SVGNS,u'x2'),
		(SVGNS,u'y1'),
		(SVGNS,u'y2'),
		(TABLENS,u'end-cell-address'),
		(TABLENS,u'end-x'),
		(TABLENS,u'end-y'),
		(TABLENS,u'table-background'),
		(TEXTNS,u'anchor-page-number'),
		(TEXTNS,u'anchor-type'),
	),
	(DRAWNS,u'marker'):(
		(SVGNS,u'd'),
		(DRAWNS,u'display-name'),
		(DRAWNS,u'name'),
		(SVGNS,u'viewBox'),
	),
# allowed_attributes
	(DRAWNS,u'measure'):(
		(TABLENS,u'end-cell-address'),
		(DRAWNS,u'layer'),
		(SVGNS,u'y2'),
		(DRAWNS,u'name'),
		(DRAWNS,u'text-style-name'),
		(DRAWNS,u'transform'),
		(TABLENS,u'table-background'),
		(SVGNS,u'x2'),
		(DRAWNS,u'z-index'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
		(TABLENS,u'end-x'),
		(TEXTNS,u'anchor-page-number'),
		(SVGNS,u'y1'),
                (DRAWNS,u'caption-id'),
		(TABLENS,u'end-y'),
		(SVGNS,u'x1'),
		(DRAWNS,u'id'),
		(TEXTNS,u'anchor-type'),
	),
	(DRAWNS,u'object'):(
		(XLINKNS,u'type'),
		(XLINKNS,u'href'),
		(DRAWNS,u'notify-on-update-of-ranges'),
		(XLINKNS,u'actuate'),
		(XLINKNS,u'show'),
	),
	(DRAWNS,u'object-ole'):(
		(XLINKNS,u'actuate'),
		(XLINKNS,u'href'),
		(XLINKNS,u'type'),
		(DRAWNS,u'class-id'),
		(XLINKNS,u'show'),
	),
	(DRAWNS,u'opacity'):(
		(DRAWNS,u'style'),
		(DRAWNS,u'angle'),
		(DRAWNS,u'name'),
		(DRAWNS,u'start'),
		(DRAWNS,u'cy'),
		(DRAWNS,u'cx'),
		(DRAWNS,u'end'),
		(DRAWNS,u'display-name'),
		(DRAWNS,u'border'),
	),
	(DRAWNS,u'page'):(
		(PRESENTATIONNS,u'presentation-page-layout-name'),
		(DRAWNS,u'name'),
		(DRAWNS,u'nav-order'),
		(PRESENTATIONNS,u'use-footer-name'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'use-header-name'),
		(DRAWNS,u'master-page-name'),
		(DRAWNS,u'id'),
		(PRESENTATIONNS,u'use-date-time-name'),
	),
	(DRAWNS,u'page-thumbnail'):(
		(TABLENS,u'table-background'),
                (DRAWNS,u'caption-id'),
		(PRESENTATIONNS,u'user-transformed'),
		(DRAWNS,u'layer'),
		(TABLENS,u'end-cell-address'),
		(DRAWNS,u'name'),
		(DRAWNS,u'id'),
		(DRAWNS,u'transform'),
		(DRAWNS,u'page-number'),
		(SVGNS,u'height'),
		(SVGNS,u'width'),
		(DRAWNS,u'z-index'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
		(TABLENS,u'end-x'),
		(TEXTNS,u'anchor-page-number'),
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(TABLENS,u'end-y'),
		(PRESENTATIONNS,u'placeholder'),
		(PRESENTATIONNS,u'class'),
		(TEXTNS,u'anchor-type'),
	),
	(DRAWNS,u'param'):(
		(DRAWNS,u'name'),
		(DRAWNS,u'value'),
	),
# allowed_attributes
	(DRAWNS,u'path'):(
		(TABLENS,u'table-background'),
		(DRAWNS,u'layer'),
		(TABLENS,u'end-cell-address'),
                (DRAWNS,u'caption-id'),
		(SVGNS,u'd'),
		(DRAWNS,u'text-style-name'),
		(DRAWNS,u'id'),
		(DRAWNS,u'transform'),
		(SVGNS,u'height'),
		(SVGNS,u'width'),
		(DRAWNS,u'z-index'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
		(TABLENS,u'end-x'),
		(TEXTNS,u'anchor-type'),
		(TEXTNS,u'anchor-page-number'),
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(TABLENS,u'end-y'),
		(SVGNS,u'viewBox'),
		(DRAWNS,u'name'),
	),
	(DRAWNS,u'plugin'):(
		(XLINKNS,u'type'),
		(XLINKNS,u'href'),
		(DRAWNS,u'mime-type'),
		(XLINKNS,u'actuate'),
		(XLINKNS,u'show'),
	),
	(DRAWNS,u'polygon'):(
                (DRAWNS,u'caption-id'),
		(TABLENS,u'table-background'),
		(DRAWNS,u'layer'),
		(TABLENS,u'end-cell-address'),
		(DRAWNS,u'name'),
		(DRAWNS,u'text-style-name'),
		(DRAWNS,u'id'),
		(DRAWNS,u'transform'),
		(PRESENTATIONNS,u'style-name'),
		(SVGNS,u'height'),
		(SVGNS,u'width'),
		(DRAWNS,u'z-index'),
		(DRAWNS,u'points'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
		(TABLENS,u'end-x'),
		(TEXTNS,u'anchor-page-number'),
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(TABLENS,u'end-y'),
		(SVGNS,u'viewBox'),
		(TEXTNS,u'anchor-type'),
	),
# allowed_attributes
	(DRAWNS,u'polyline'):(
		(TABLENS,u'table-background'),
		(DRAWNS,u'layer'),
		(TABLENS,u'end-cell-address'),
		(DRAWNS,u'name'),
		(DRAWNS,u'text-style-name'),
		(DRAWNS,u'id'),
                (DRAWNS,u'caption-id'),
		(DRAWNS,u'transform'),
		(PRESENTATIONNS,u'style-name'),
		(SVGNS,u'height'),
		(SVGNS,u'width'),
		(DRAWNS,u'z-index'),
		(DRAWNS,u'points'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
		(TABLENS,u'end-x'),
		(TEXTNS,u'anchor-page-number'),
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(TABLENS,u'end-y'),
		(SVGNS,u'viewBox'),
		(TEXTNS,u'anchor-type'),
	),
	(DRAWNS,u'rect'):(
		(DRAWNS,u'corner-radius'),
                (DRAWNS,u'caption-id'),
		(DRAWNS,u'id'),
		(DRAWNS,u'layer'),
		(DRAWNS,u'name'),
		(DRAWNS,u'text-style-name'),
		(DRAWNS,u'transform'),
		(DRAWNS,u'z-index'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
		(PRESENTATIONNS,u'style-name'),
		(SVGNS,u'height'),
		(SVGNS,u'width'),
		(SVGNS,u'x'),
		(SVGNS,u'y'),
		(TABLENS,u'end-cell-address'),
		(TABLENS,u'end-x'),
		(TABLENS,u'end-y'),
		(TABLENS,u'table-background'),
		(TEXTNS,u'anchor-page-number'),
		(TEXTNS,u'anchor-type'),
	),
# allowed_attributes
	(DRAWNS,u'regular-polygon'):(
		(TABLENS,u'table-background'),
		(DRAWNS,u'layer'),
		(TABLENS,u'end-cell-address'),
                (DRAWNS,u'caption-id'),
		(DRAWNS,u'name'),
		(DRAWNS,u'text-style-name'),
		(TEXTNS,u'anchor-page-number'),
		(DRAWNS,u'concave'),
		(DRAWNS,u'sharpness'),
		(DRAWNS,u'transform'),
		(SVGNS,u'height'),
		(SVGNS,u'width'),
		(DRAWNS,u'z-index'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
		(TABLENS,u'end-x'),
		(DRAWNS,u'corners'),
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(TABLENS,u'end-y'),
		(DRAWNS,u'id'),
		(TEXTNS,u'anchor-type'),
	),
	(DRAWNS,u'stroke-dash'):(
		(DRAWNS,u'distance'),
		(DRAWNS,u'dots1-length'),
		(DRAWNS,u'name'),
		(DRAWNS,u'dots2-length'),
		(DRAWNS,u'style'),
		(DRAWNS,u'dots1'),
		(DRAWNS,u'display-name'),
		(DRAWNS,u'dots2'),
	),
	(DRAWNS,u'text-box'):(
		(FONS,u'min-width'),
		(DRAWNS,u'corner-radius'),
		(FONS,u'max-height'),
		(FONS,u'min-height'),
		(DRAWNS,u'chain-next-name'),
		(FONS,u'max-width'),
                (TEXTNS,u'id'),
	),
# allowed_attributes
	(FORMNS,u'button'):(
		(FORMNS,u'tab-stop'),
		(FORMNS,u'focus-on-click'),
		(FORMNS,u'image-align'),
		(FORMNS,u'name'),
		(FORMNS,u'tab-index'),
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'button-type'),
		(FORMNS,u'title'),
		(FORMNS,u'default-button'),
		(FORMNS,u'value'),
		(FORMNS,u'label'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'image-data'),
		(XLINKNS,u'href'),
		(FORMNS,u'toggle'),
		(FORMNS,u'xforms-submission'),
		(OFFICENS,u'target-frame'),
		(FORMNS,u'id'),
		(FORMNS,u'image-position'),
	),
	(FORMNS,u'checkbox'):(
		(FORMNS,u'tab-stop'),
		(FORMNS,u'image-align'),
		(FORMNS,u'name'),
		(FORMNS,u'tab-index'),
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'data-field'),
		(FORMNS,u'title'),
		(FORMNS,u'is-tristate'),
		(FORMNS,u'current-state'),
		(FORMNS,u'value'),
		(FORMNS,u'label'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'state'),
		(FORMNS,u'visual-effect'),
		(FORMNS,u'id'),
		(FORMNS,u'image-position'),
	),
	(FORMNS,u'column'):(
		(FORMNS,u'control-implementation'),
		(FORMNS,u'text-style-name'),
		(FORMNS,u'name'),
		(FORMNS,u'label'),
	),
	(FORMNS,u'combobox'):(
		(FORMNS,u'convert-empty-to-null'),
		(FORMNS,u'max-length'),
		(FORMNS,u'tab-stop'),
		(FORMNS,u'name'),
		(FORMNS,u'dropdown'),
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'data-field'),
		(FORMNS,u'tab-index'),
		(FORMNS,u'auto-complete'),
		(FORMNS,u'value'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'readonly'),
		(FORMNS,u'list-source'),
		(FORMNS,u'title'),
		(FORMNS,u'list-source-type'),
		(FORMNS,u'id'),
		(FORMNS,u'current-value'),
		(FORMNS,u'size'),
	),
# allowed_attributes
	(FORMNS,u'connection-resource'):(
		(XLINKNS,u'href'),
	),
	(FORMNS,u'date'):(
		(FORMNS,u'convert-empty-to-null'),
		(FORMNS,u'max-length'),
		(FORMNS,u'tab-stop'),
		(FORMNS,u'name'),
		(FORMNS,u'tab-index'),
		(FORMNS,u'control-implementation'),
		(FORMNS,u'min-value'),
		(FORMNS,u'data-field'),
		(FORMNS,u'max-value'),
		(FORMNS,u'value'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'readonly'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'title'),
		(FORMNS,u'id'),
		(FORMNS,u'current-value'),
	),
	(FORMNS,u'file'):(
		(FORMNS,u'max-length'),
		(FORMNS,u'tab-stop'),
		(FORMNS,u'name'),
		(FORMNS,u'tab-index'),
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'title'),
		(FORMNS,u'value'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'readonly'),
		(FORMNS,u'id'),
		(FORMNS,u'current-value'),
	),
	(FORMNS,u'fixed-text'):(
		(FORMNS,u'name'),
		(FORMNS,u'for'),
		(FORMNS,u'title'),
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'multi-line'),
		(FORMNS,u'label'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'id'),
	),
# allowed_attributes
	(FORMNS,u'form'):(
		(XLINKNS,u'actuate'),
		(XLINKNS,u'href'),
		(FORMNS,u'allow-deletes'),
		(FORMNS,u'command-type'),
		(FORMNS,u'apply-filter'),
		(XLINKNS,u'type'),
		(FORMNS,u'method'),
		(OFFICENS,u'target-frame'),
		(FORMNS,u'navigation-mode'),
		(FORMNS,u'detail-fields'),
		(FORMNS,u'master-fields'),
		(FORMNS,u'allow-updates'),
		(FORMNS,u'name'),
		(FORMNS,u'tab-cycle'),
		(FORMNS,u'control-implementation'),
		(FORMNS,u'escape-processing'),
		(FORMNS,u'filter'),
		(FORMNS,u'command'),
		(FORMNS,u'datasource'),
		(FORMNS,u'enctype'),
		(FORMNS,u'allow-inserts'),
		(FORMNS,u'ignore-result'),
		(FORMNS,u'order'),
	),
	(FORMNS,u'formatted-text'):(
		(FORMNS,u'convert-empty-to-null'),
		(FORMNS,u'max-length'),
		(FORMNS,u'tab-stop'),
		(FORMNS,u'max-value'),
		(FORMNS,u'name'),
		(FORMNS,u'tab-index'),
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'data-field'),
		(FORMNS,u'title'),
		(FORMNS,u'value'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'readonly'),
		(FORMNS,u'min-value'),
		(FORMNS,u'validation'),
		(FORMNS,u'id'),
		(FORMNS,u'current-value'),
	),
	(FORMNS,u'frame'):(
		(FORMNS,u'name'),
		(FORMNS,u'for'),
		(FORMNS,u'title'),
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'label'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'id'),
	),
# allowed_attributes
	(FORMNS,u'generic-control'):(
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'name'),
		(FORMNS,u'id'),
	),
	(FORMNS,u'grid'):(
		(FORMNS,u'tab-stop'),
		(FORMNS,u'name'),
		(FORMNS,u'tab-index'),
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'title'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'id'),
	),
	(FORMNS,u'hidden'):(
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'name'),
		(FORMNS,u'value'),
		(FORMNS,u'id'),
	),
	(FORMNS,u'image'):(
		(FORMNS,u'tab-stop'),
		(FORMNS,u'name'),
		(FORMNS,u'tab-index'),
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'button-type'),
		(FORMNS,u'title'),
		(FORMNS,u'value'),
		(OFFICENS,u'target-frame'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'image-data'),
		(XLINKNS,u'href'),
		(FORMNS,u'id'),
	),
	(FORMNS,u'image-frame'):(
		(FORMNS,u'name'),
		(FORMNS,u'title'),
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'data-field'),
		(FORMNS,u'readonly'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'image-data'),
		(FORMNS,u'id'),
	),
	(FORMNS,u'item'):(
		(FORMNS,u'label'),
	),
	(FORMNS,u'list-property'):(
		(FORMNS,u'property-name'),
		(OFFICENS,u'value-type'),
	),
	(FORMNS,u'list-value'):(
		(OFFICENS,u'string-value'),
	),
# allowed_attributes
	(FORMNS,u'listbox'):(
		(FORMNS,u'tab-stop'),
		(FORMNS,u'bound-column'),
		(FORMNS,u'multiple'),
		(FORMNS,u'name'),
		(FORMNS,u'dropdown'),
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'data-field'),
		(FORMNS,u'tab-index'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'list-source'),
		(FORMNS,u'title'),
		(FORMNS,u'list-source-type'),
		(FORMNS,u'id'),
		(FORMNS,u'xforms-list-source'),
		(FORMNS,u'size'),
	),
	(FORMNS,u'number'):(
		(FORMNS,u'convert-empty-to-null'),
		(FORMNS,u'max-length'),
		(FORMNS,u'tab-stop'),
		(FORMNS,u'name'),
		(FORMNS,u'tab-index'),
		(FORMNS,u'control-implementation'),
		(FORMNS,u'min-value'),
		(FORMNS,u'data-field'),
		(FORMNS,u'max-value'),
		(FORMNS,u'value'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'readonly'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'title'),
		(FORMNS,u'id'),
		(FORMNS,u'current-value'),
	),
	(FORMNS,u'option'):(
		(FORMNS,u'current-selected'),
		(FORMNS,u'selected'),
		(FORMNS,u'value'),
		(FORMNS,u'label'),
	),
	(FORMNS,u'password'):(
		(FORMNS,u'convert-empty-to-null'),
		(FORMNS,u'max-length'),
		(FORMNS,u'tab-stop'),
		(FORMNS,u'name'),
		(FORMNS,u'tab-index'),
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'title'),
		(FORMNS,u'value'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'echo-char'),
		(FORMNS,u'id'),
	),
	(FORMNS,u'properties'):(
	),
	(FORMNS,u'property'):(
		(OFFICENS,u'string-value'),
		(OFFICENS,u'value'),
		(OFFICENS,u'boolean-value'),
		(FORMNS,u'property-name'),
		(OFFICENS,u'currency'),
		(OFFICENS,u'date-value'),
		(OFFICENS,u'value-type'),
		(OFFICENS,u'time-value'),
	),
	(FORMNS,u'radio'):(
		(FORMNS,u'tab-stop'),
		(FORMNS,u'selected'),
		(FORMNS,u'image-align'),
		(FORMNS,u'name'),
		(FORMNS,u'tab-index'),
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'data-field'),
		(FORMNS,u'current-selected'),
		(FORMNS,u'value'),
		(FORMNS,u'label'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'title'),
		(FORMNS,u'visual-effect'),
		(FORMNS,u'id'),
		(FORMNS,u'image-position'),
	),
	(FORMNS,u'text'):(
		(FORMNS,u'convert-empty-to-null'),
		(FORMNS,u'max-length'),
		(FORMNS,u'tab-stop'),
		(FORMNS,u'name'),
		(FORMNS,u'tab-index'),
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'data-field'),
		(FORMNS,u'title'),
		(FORMNS,u'value'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'readonly'),
		(FORMNS,u'id'),
		(FORMNS,u'current-value'),
	),
	(FORMNS,u'textarea'):(
		(FORMNS,u'convert-empty-to-null'),
		(FORMNS,u'max-length'),
		(FORMNS,u'tab-stop'),
		(FORMNS,u'name'),
		(FORMNS,u'tab-index'),
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'data-field'),
		(FORMNS,u'title'),
		(FORMNS,u'value'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'readonly'),
		(FORMNS,u'id'),
		(FORMNS,u'current-value'),
	),
	(FORMNS,u'time'):(
		(FORMNS,u'convert-empty-to-null'),
		(FORMNS,u'max-length'),
		(FORMNS,u'tab-stop'),
		(FORMNS,u'name'),
		(FORMNS,u'tab-index'),
		(FORMNS,u'control-implementation'),
		(FORMNS,u'min-value'),
		(FORMNS,u'data-field'),
		(FORMNS,u'max-value'),
		(FORMNS,u'value'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'readonly'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'title'),
		(FORMNS,u'id'),
		(FORMNS,u'current-value'),
	),
	(FORMNS,u'value-range'):(
		(FORMNS,u'tab-stop'),
		(FORMNS,u'max-value'),
		(FORMNS,u'name'),
		(FORMNS,u'tab-index'),
		(FORMNS,u'control-implementation'),
		(XFORMSNS,u'bind'),
		(FORMNS,u'title'),
		(FORMNS,u'value'),
		(FORMNS,u'disabled'),
		(FORMNS,u'printable'),
		(FORMNS,u'orientation'),
		(FORMNS,u'page-step-size'),
		(FORMNS,u'delay-for-repeat'),
		(FORMNS,u'min-value'),
		(FORMNS,u'id'),
		(FORMNS,u'step-size'),
	),
	(MANIFESTNS,'algorithm') : (
		(MANIFESTNS,'algorithm-name'),
		(MANIFESTNS,'initialisation-vector'),
	),
	(MANIFESTNS,'encryption-data') : (
		(MANIFESTNS,'checksum-type'),
		(MANIFESTNS,'checksum'),
	),
	(MANIFESTNS,'file-entry') : (
		(MANIFESTNS,'full-path'),
		(MANIFESTNS,'media-type'),
		(MANIFESTNS,'size'),
	),
	(MANIFESTNS,'key-derivation') : (
		(MANIFESTNS,'key-derivation-name'),
		(MANIFESTNS,'salt'),
		(MANIFESTNS,'iteration-count'),
	),
	(MANIFESTNS,u'manifest'):(
	),
# allowed_attributes
	(METANS,u'auto-reload'):(
		(METANS,u'delay'),
		(XLINKNS,u'actuate'),
		(XLINKNS,u'href'),
		(XLINKNS,u'type'),
		(XLINKNS,u'show'),
	),
	(METANS,u'creation-date'):(
	),
	(METANS,u'date-string'):(
	),
	(METANS,u'document-statistic'):(
		(METANS,u'non-whitespace-character-count'),
		(METANS,u'ole-object-count'),
		(METANS,u'table-count'),
		(METANS,u'row-count'),
		(METANS,u'character-count'),
		(METANS,u'sentence-count'),
		(METANS,u'draw-count'),
		(METANS,u'paragraph-count'),
		(METANS,u'word-count'),
		(METANS,u'object-count'),
		(METANS,u'syllable-count'),
		(METANS,u'image-count'),
		(METANS,u'page-count'),
		(METANS,u'frame-count'),
		(METANS,u'cell-count'),
	),
	(METANS,u'editing-cycles'):(
	),
	(METANS,u'editing-duration'):(
	),
	(METANS,u'generator'):(
	),
# allowed_attributes
	(METANS,u'hyperlink-behaviour'):(
		(OFFICENS,u'target-frame-name'),
		(XLINKNS,u'show'),
	),
	(METANS,u'initial-creator'):(
	),
	(METANS,u'keyword'):(
	),
	(METANS,u'print-date'):(
	),
	(METANS,u'printed-by'):(
	),
	(METANS,u'template'):(
		(METANS,u'date'),
		(XLINKNS,u'actuate'),
		(XLINKNS,u'href'),
		(XLINKNS,u'type'),
		(XLINKNS,u'title'),
	),
	(METANS,u'user-defined'):(
		(METANS,u'name'),
		(METANS,u'value-type'),
	),
	(OFFICENS,u'annotation'):(
		(DRAWNS,u'layer'),
		(SVGNS,u'height'),
		(TEXTNS,u'anchor-page-number'),
		(TABLENS,u'table-background'),
		(TABLENS,u'end-cell-address'),
		(DRAWNS,u'transform'),
		(DRAWNS,u'id'),
		(SVGNS,u'width'),
		(DRAWNS,u'class-names'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'class-names'),
		(TABLENS,u'end-x'),
		(DRAWNS,u'text-style-name'),
		(DRAWNS,u'z-index'),
		(PRESENTATIONNS,u'style-name'),
		(TEXTNS,u'anchor-type'),
		(DRAWNS,u'name'),
		(DRAWNS,u'caption-point-y'),
		(DRAWNS,u'caption-point-x'),
		(DRAWNS,u'corner-radius'),
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(TABLENS,u'end-y'),
		(OFFICENS,u'display'),
	),
	(OFFICENS,u'automatic-styles'):(
	),
	(OFFICENS,u'binary-data'):(
	),
	(OFFICENS,u'body'):(
	),
	(OFFICENS,u'change-info'):(
	),
	(OFFICENS,u'chart'):(
	),
	(OFFICENS,u'dde-source'):(
		(OFFICENS,u'dde-application'),
		(OFFICENS,u'automatic-update'),
		(OFFICENS,u'conversion-mode'),
		(OFFICENS,u'dde-item'),
		(OFFICENS,u'dde-topic'),
		(OFFICENS,u'name'),
	),
	(OFFICENS,u'document'):(
		(OFFICENS,u'mimetype'),
		(OFFICENS,u'version'),
	),
	(OFFICENS,u'document-content'):(
		(OFFICENS,u'version'),
	),
	(OFFICENS,u'document-meta'):(
		(OFFICENS,u'version'),
	),
	(OFFICENS,u'document-settings'):(
		(OFFICENS,u'version'),
	),
	(OFFICENS,u'document-styles'):(
		(OFFICENS,u'version'),
	),
	(OFFICENS,u'drawing'):(
	),
	(OFFICENS,u'event-listeners'):(
	),
	(OFFICENS,u'font-face-decls'):(
	),
	(OFFICENS,u'forms'):(
		(FORMNS,u'automatic-focus'),
		(FORMNS,u'apply-design-mode'),
	),
	(OFFICENS,u'image'):(
	),
# allowed_attributes
	(OFFICENS,u'master-styles'):(
	),
	(OFFICENS,u'meta'):(
	),
	(OFFICENS,u'presentation'):(
	),
	(OFFICENS,u'script'):(
		(SCRIPTNS,u'language'),
	),
	(OFFICENS,u'scripts'):(
	),
	(OFFICENS,u'settings'):(
	),
	(OFFICENS,u'spreadsheet'):(
		(TABLENS,u'structure-protected'),
		(TABLENS,u'protection-key'),
	),
	(OFFICENS,u'styles'):(
	),
	(OFFICENS,u'text'):(
		(TEXTNS,u'global'),
		(TEXTNS,u'use-soft-page-breaks'),
	),
	(PRESENTATIONNS,u'animation-group'):(
	),
	(PRESENTATIONNS,u'animations'):(
	),
	(PRESENTATIONNS,u'date-time'):(
	),
	(PRESENTATIONNS,u'date-time-decl'):(
		(PRESENTATIONNS,u'source'),
		(STYLENS,u'data-style-name'),
		(PRESENTATIONNS,u'name'),
	),
	(PRESENTATIONNS,u'dim'):(
		(DRAWNS,u'color'),
		(DRAWNS,u'shape-id'),
	),
	(PRESENTATIONNS,u'event-listener'):(
		(PRESENTATIONNS,u'direction'),
		(XLINKNS,u'show'),
		(XLINKNS,u'type'),
		(XLINKNS,u'actuate'),
		(PRESENTATIONNS,u'effect'),
		(SCRIPTNS,u'event-name'),
		(PRESENTATIONNS,u'start-scale'),
		(XLINKNS,u'href'),
		(PRESENTATIONNS,u'verb'),
		(PRESENTATIONNS,u'action'),
		(PRESENTATIONNS,u'speed'),
	),
	(PRESENTATIONNS,u'footer'):(
	),
	(PRESENTATIONNS,u'footer-decl'):(
		(PRESENTATIONNS,u'name'),
	),
	(PRESENTATIONNS,u'header'):(
	),
	(PRESENTATIONNS,u'header-decl'):(
		(PRESENTATIONNS,u'name'),
	),
	(PRESENTATIONNS,u'hide-shape'):(
		(PRESENTATIONNS,u'direction'),
		(PRESENTATIONNS,u'effect'),
		(PRESENTATIONNS,u'delay'),
		(PRESENTATIONNS,u'start-scale'),
		(PRESENTATIONNS,u'path-id'),
		(PRESENTATIONNS,u'speed'),
		(DRAWNS,u'shape-id'),
	),
# allowed_attributes
	(PRESENTATIONNS,u'hide-text'):(
		(PRESENTATIONNS,u'direction'),
		(PRESENTATIONNS,u'effect'),
		(PRESENTATIONNS,u'delay'),
		(PRESENTATIONNS,u'start-scale'),
		(PRESENTATIONNS,u'path-id'),
		(PRESENTATIONNS,u'speed'),
		(DRAWNS,u'shape-id'),
	),
	(PRESENTATIONNS,u'notes'):(
		(STYLENS,u'page-layout-name'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'use-header-name'),
		(PRESENTATIONNS,u'use-date-time-name'),
		(PRESENTATIONNS,u'use-footer-name'),
	),
	(PRESENTATIONNS,u'placeholder'):(
		(SVGNS,u'y'),
		(SVGNS,u'x'),
		(SVGNS,u'height'),
		(PRESENTATIONNS,u'object'),
		(SVGNS,u'width'),
	),
	(PRESENTATIONNS,u'play'):(
		(PRESENTATIONNS,u'speed'),
		(DRAWNS,u'shape-id'),
	),
# allowed_attributes
	(PRESENTATIONNS,u'settings'):(
		(PRESENTATIONNS,u'animations'),
		(PRESENTATIONNS,u'endless'),
		(PRESENTATIONNS,u'force-manual'),
		(PRESENTATIONNS,u'full-screen'),
		(PRESENTATIONNS,u'mouse-as-pen'),
		(PRESENTATIONNS,u'mouse-visible'),
		(PRESENTATIONNS,u'pause'),
		(PRESENTATIONNS,u'show'),
		(PRESENTATIONNS,u'show-end-of-presentation-slide'),
		(PRESENTATIONNS,u'show-logo'),
		(PRESENTATIONNS,u'start-page'),
		(PRESENTATIONNS,u'start-with-navigator'),
		(PRESENTATIONNS,u'stay-on-top'),
		(PRESENTATIONNS,u'transition-on-click'),
	),
	(PRESENTATIONNS,u'show'):(
		(PRESENTATIONNS,u'name'),
		(PRESENTATIONNS,u'pages'),
	),
	(PRESENTATIONNS,u'show-shape'):(
		(PRESENTATIONNS,u'direction'),
		(PRESENTATIONNS,u'effect'),
		(PRESENTATIONNS,u'delay'),
		(PRESENTATIONNS,u'start-scale'),
		(PRESENTATIONNS,u'path-id'),
		(PRESENTATIONNS,u'speed'),
		(DRAWNS,u'shape-id'),
	),
	(PRESENTATIONNS,u'show-text'):(
		(PRESENTATIONNS,u'direction'),
		(PRESENTATIONNS,u'effect'),
		(PRESENTATIONNS,u'delay'),
		(PRESENTATIONNS,u'start-scale'),
		(PRESENTATIONNS,u'path-id'),
		(PRESENTATIONNS,u'speed'),
		(DRAWNS,u'shape-id'),
	),
	(PRESENTATIONNS,u'sound'):(
		(XLINKNS,u'actuate'),
		(XLINKNS,u'href'),
		(XLINKNS,u'type'),
		(PRESENTATIONNS,u'play-full'),
		(XLINKNS,u'show'),
	),
# allowed_attributes
	(SCRIPTNS,u'event-listener'):(
		(SCRIPTNS,u'language'),
		(SCRIPTNS,u'macro-name'),
		(XLINKNS,u'actuate'),
		(SCRIPTNS,u'event-name'),
		(XLINKNS,u'href'),
		(XLINKNS,u'type'),
	),
	(STYLENS,u'background-image'):(
		(DRAWNS,u'opacity'),
		(STYLENS,u'repeat'),
		(XLINKNS,u'show'),
		(XLINKNS,u'actuate'),
		(STYLENS,u'filter-name'),
		(XLINKNS,u'href'),
		(STYLENS,u'position'),
		(XLINKNS,u'type'),
	),
	(STYLENS,u'chart-properties'): (
		(CHARTNS,u'connect-bars'),
		(CHARTNS,u'data-label-number'),
		(CHARTNS,u'data-label-symbol'),
		(CHARTNS,u'data-label-text'),
		(CHARTNS,u'deep'),
		(CHARTNS,u'display-label'),
		(CHARTNS,u'error-category'),
		(CHARTNS,u'error-lower-indicator'),
		(CHARTNS,u'error-lower-limit'),
		(CHARTNS,u'error-margin'),
		(CHARTNS,u'error-percentage'),
		(CHARTNS,u'error-upper-indicator'),
		(CHARTNS,u'error-upper-limit'),
		(CHARTNS,u'gap-width'),
		(CHARTNS,u'interpolation'),
		(CHARTNS,u'interval-major'),
		(CHARTNS,u'interval-minor-divisor'),
		(CHARTNS,u'japanese-candle-stick'),
		(CHARTNS,u'label-arrangement'),
		(CHARTNS,u'lines'),
		(CHARTNS,u'link-data-style-to-source'),
		(CHARTNS,u'logarithmic'),
		(CHARTNS,u'maximum'),
		(CHARTNS,u'mean-value'),
		(CHARTNS,u'minimum'),
		(CHARTNS,u'origin'),
		(CHARTNS,u'overlap'),
		(CHARTNS,u'percentage'),
		(CHARTNS,u'pie-offset'),
		(CHARTNS,u'regression-type'),
		(CHARTNS,u'scale-text'),
		(CHARTNS,u'series-source'),
		(CHARTNS,u'solid-type'),
		(CHARTNS,u'spline-order'),
		(CHARTNS,u'spline-resolution'),
		(CHARTNS,u'stacked'),
		(CHARTNS,u'symbol-height'),
		(CHARTNS,u'symbol-name'),
		(CHARTNS,u'symbol-type'),
		(CHARTNS,u'symbol-width'),
		(CHARTNS,u'text-overlap'),
		(CHARTNS,u'three-dimensional'),
		(CHARTNS,u'tick-marks-major-inner'),
		(CHARTNS,u'tick-marks-major-outer'),
		(CHARTNS,u'tick-marks-minor-inner'),
		(CHARTNS,u'tick-marks-minor-outer'),
		(CHARTNS,u'vertical'),
		(CHARTNS,u'visible'),
		(STYLENS,u'direction'),
		(STYLENS,u'rotation-angle'),
		(TEXTNS,u'line-break'),
	),
	(STYLENS,u'column'):(
		(FONS,u'end-indent'),
		(FONS,u'space-before'),
		(FONS,u'start-indent'),
		(FONS,u'space-after'),
		(STYLENS,u'rel-width'),
	),
	(STYLENS,u'column-sep'):(
		(STYLENS,u'color'),
		(STYLENS,u'width'),
		(STYLENS,u'style'),
		(STYLENS,u'vertical-align'),
		(STYLENS,u'height'),
	),
	(STYLENS,u'columns'):(
		(FONS,u'column-count'),
		(FONS,u'column-gap'),
	),
	(STYLENS,u'default-style'):(
		(STYLENS,u'family'),
	),
# allowed_attributes
	(STYLENS,u'drawing-page-properties'): (
		(DRAWNS,u'fill'),
		(DRAWNS,u'fill-color'),
		(DRAWNS,u'secondary-fill-color'),
		(DRAWNS,u'fill-gradient-name'),
		(DRAWNS,u'gradient-step-count'),
		(DRAWNS,u'fill-hatch-name'),
		(DRAWNS,u'fill-hatch-solid'),
		(DRAWNS,u'fill-image-name'),
		(STYLENS,u'repeat'),
		(DRAWNS,u'fill-image-width'),
		(DRAWNS,u'fill-image-height'),
		(DRAWNS,u'fill-image-ref-point-x'),
		(DRAWNS,u'fill-image-ref-point-y'),
		(DRAWNS,u'fill-image-ref-point'),
		(DRAWNS,u'tile-repeat-offset'),
		(DRAWNS,u'opacity'),
		(DRAWNS,u'opacity-name'),
		(SVGNS,u'fill-rule'),
		(PRESENTATIONNS,u'transition-type'),
		(PRESENTATIONNS,u'transition-style'),
		(PRESENTATIONNS,u'transition-speed'),
		(SMILNS,u'type'),
		(SMILNS,u'subtype'),
		(SMILNS,u'direction'),
		(SMILNS,u'fadeColor'),
		(PRESENTATIONNS,u'duration'),
		(PRESENTATIONNS,u'visibility'),
		(DRAWNS,u'background-size'),
		(PRESENTATIONNS,u'background-objects-visible'),
		(PRESENTATIONNS,u'background-visible'),
		(PRESENTATIONNS,u'display-header'),
		(PRESENTATIONNS,u'display-footer'),
		(PRESENTATIONNS,u'display-page-number'),
		(PRESENTATIONNS,u'display-date-time'),
	),
	(STYLENS,u'drop-cap'):(
		(STYLENS,u'distance'),
		(STYLENS,u'length'),
		(STYLENS,u'style-name'),
		(STYLENS,u'lines'),
	),
# allowed_attributes
	(STYLENS,u'font-face'):(
		(STYLENS,u'font-adornments'),
		(STYLENS,u'font-charset'),
		(STYLENS,u'font-family-generic'),
		(STYLENS,u'font-pitch'),
		(STYLENS,u'name'),
		(SVGNS,u'accent-height'),
		(SVGNS,u'alphabetic'),
		(SVGNS,u'ascent'),
		(SVGNS,u'bbox'),
		(SVGNS,u'cap-height'),
		(SVGNS,u'descent'),
		(SVGNS,u'font-family'),
		(SVGNS,u'font-size'),
		(SVGNS,u'font-stretch'),
		(SVGNS,u'font-style'),
		(SVGNS,u'font-variant'),
		(SVGNS,u'font-weight'),
		(SVGNS,u'hanging'),
		(SVGNS,u'ideographic'),
		(SVGNS,u'mathematical'),
		(SVGNS,u'overline-position'),
		(SVGNS,u'overline-thickness'),
		(SVGNS,u'panose-1'),
		(SVGNS,u'slope'),
		(SVGNS,u'stemh'),
		(SVGNS,u'stemv'),
		(SVGNS,u'strikethrough-position'),
		(SVGNS,u'strikethrough-thickness'),
		(SVGNS,u'underline-position'),
		(SVGNS,u'underline-thickness'),
		(SVGNS,u'unicode-range'),
		(SVGNS,u'units-per-em'),
		(SVGNS,u'v-alphabetic'),
		(SVGNS,u'v-hanging'),
		(SVGNS,u'v-ideographic'),
		(SVGNS,u'v-mathematical'),
		(SVGNS,u'widths'),
		(SVGNS,u'x-height'),
	),
	(STYLENS,u'footer'):(
		(STYLENS,u'display'),
	),
	(STYLENS,u'footer-left'):(
		(STYLENS,u'display'),
	),
	(STYLENS,u'footer-style'):(
	),
	(STYLENS,u'footnote-sep'):(
		(STYLENS,u'distance-after-sep'),
		(STYLENS,u'color'),
		(STYLENS,u'rel-width'),
		(STYLENS,u'width'),
		(STYLENS,u'distance-before-sep'),
		(STYLENS,u'line-style'),
		(STYLENS,u'adjustment'),
	),
# allowed_attributes
	(STYLENS,u'graphic-properties'): (
		(DR3DNS,u'ambient-color'),
		(DR3DNS,u'back-scale'),
		(DR3DNS,u'backface-culling'),
		(DR3DNS,u'close-back'),
		(DR3DNS,u'close-front'),
		(DR3DNS,u'depth'),
		(DR3DNS,u'diffuse-color'),
		(DR3DNS,u'edge-rounding'),
		(DR3DNS,u'edge-rounding-mode'),
		(DR3DNS,u'emissive-color'),
		(DR3DNS,u'end-angle'),
		(DR3DNS,u'horizontal-segments'),
		(DR3DNS,u'lighting-mode'),
		(DR3DNS,u'normals-direction'),
		(DR3DNS,u'normals-kind'),
		(DR3DNS,u'shadow'),
		(DR3DNS,u'shininess'),
		(DR3DNS,u'specular-color'),
		(DR3DNS,u'texture-filter'),
		(DR3DNS,u'texture-generation-mode-x'),
		(DR3DNS,u'texture-generation-mode-y'),
		(DR3DNS,u'texture-kind'),
		(DR3DNS,u'texture-mode'),
		(DR3DNS,u'vertical-segments'),
		(DRAWNS,u'auto-grow-height'),
		(DRAWNS,u'auto-grow-width'),
		(DRAWNS,u'blue'),
		(DRAWNS,u'caption-angle'),
		(DRAWNS,u'caption-angle-type'),
		(DRAWNS,u'caption-escape'),
		(DRAWNS,u'caption-escape-direction'),
		(DRAWNS,u'caption-fit-line-length'),
		(DRAWNS,u'caption-gap'),
		(DRAWNS,u'caption-line-length'),
		(DRAWNS,u'caption-type'),
		(DRAWNS,u'color-inversion'),
		(DRAWNS,u'color-mode'),
		(DRAWNS,u'contrast'),
		(DRAWNS,u'decimal-places'),
		(DRAWNS,u'end-guide'),
		(DRAWNS,u'end-line-spacing-horizontal'),
		(DRAWNS,u'end-line-spacing-vertical'),
		(DRAWNS,u'fill'),
		(DRAWNS,u'fill-color'),
		(DRAWNS,u'fill-gradient-name'),
		(DRAWNS,u'fill-hatch-name'),
		(DRAWNS,u'fill-hatch-solid'),
		(DRAWNS,u'fill-image-height'),
		(DRAWNS,u'fill-image-name'),
		(DRAWNS,u'fill-image-ref-point'),
		(DRAWNS,u'fill-image-ref-point-x'),
		(DRAWNS,u'fill-image-ref-point-y'),
		(DRAWNS,u'fill-image-width'),
# allowed_attributes
		(DRAWNS,u'fit-to-contour'),
		(DRAWNS,u'fit-to-size'),
		(DRAWNS,u'frame-display-border'),
		(DRAWNS,u'frame-display-scrollbar'),
		(DRAWNS,u'frame-margin-horizontal'),
		(DRAWNS,u'frame-margin-vertical'),
		(DRAWNS,u'gamma'),
		(DRAWNS,u'gradient-step-count'),
		(DRAWNS,u'green'),
		(DRAWNS,u'guide-distance'),
		(DRAWNS,u'guide-overhang'),
		(DRAWNS,u'image-opacity'),
		(DRAWNS,u'line-distance'),
		(DRAWNS,u'luminance'),
		(DRAWNS,u'marker-end'),
		(DRAWNS,u'marker-end-center'),
		(DRAWNS,u'marker-end-width'),
		(DRAWNS,u'marker-start'),
		(DRAWNS,u'marker-start-center'),
		(DRAWNS,u'marker-start-width'),
		(DRAWNS,u'measure-align'),
		(DRAWNS,u'measure-vertical-align'),
		(DRAWNS,u'ole-draw-aspect'),
		(DRAWNS,u'opacity'),
		(DRAWNS,u'opacity-name'),
		(DRAWNS,u'parallel'),
		(DRAWNS,u'placing'),
		(DRAWNS,u'red'),
		(DRAWNS,u'secondary-fill-color'),
		(DRAWNS,u'shadow'),
		(DRAWNS,u'shadow-color'),
		(DRAWNS,u'shadow-offset-x'),
		(DRAWNS,u'shadow-offset-y'),
		(DRAWNS,u'shadow-opacity'),
		(DRAWNS,u'show-unit'),
		(DRAWNS,u'start-guide'),
		(DRAWNS,u'start-line-spacing-horizontal'),
		(DRAWNS,u'start-line-spacing-vertical'),
		(DRAWNS,u'stroke'),
		(DRAWNS,u'stroke-dash'),
		(DRAWNS,u'stroke-dash-names'),
		(DRAWNS,u'stroke-linejoin'),
		(DRAWNS,u'symbol-color'),
		(DRAWNS,u'textarea-horizontal-align'),
		(DRAWNS,u'textarea-vertical-align'),
		(DRAWNS,u'tile-repeat-offset'),
		(DRAWNS,u'unit'),
		(DRAWNS,u'visible-area-height'),
		(DRAWNS,u'visible-area-left'),
		(DRAWNS,u'visible-area-top'),
		(DRAWNS,u'visible-area-width'),
		(DRAWNS,u'wrap-influence-on-position'),
# allowed_attributes
		(FONS,u'background-color'),
		(FONS,u'border'),
		(FONS,u'border-bottom'),
		(FONS,u'border-left'),
		(FONS,u'border-right'),
		(FONS,u'border-top'),
		(FONS,u'clip'),
		(FONS,u'margin'),
		(FONS,u'margin-bottom'),
		(FONS,u'margin-left'),
		(FONS,u'margin-right'),
		(FONS,u'margin-top'),
		(FONS,u'max-height'),
		(FONS,u'max-width'),
		(FONS,u'min-height'),
		(FONS,u'min-width'),
		(FONS,u'padding'),
		(FONS,u'padding-bottom'),
		(FONS,u'padding-left'),
		(FONS,u'padding-right'),
		(FONS,u'padding-top'),
		(FONS,u'wrap-option'),
		(STYLENS,u'border-line-width'),
		(STYLENS,u'border-line-width-bottom'),
		(STYLENS,u'border-line-width-left'),
		(STYLENS,u'border-line-width-right'),
		(STYLENS,u'border-line-width-top'),
		(STYLENS,u'editable'),
		(STYLENS,u'flow-with-text'),
		(STYLENS,u'horizontal-pos'),
		(STYLENS,u'horizontal-rel'),
		(STYLENS,u'mirror'),
		(STYLENS,u'number-wrapped-paragraphs'),
		(STYLENS,u'overflow-behavior'),
		(STYLENS,u'print-content'),
		(STYLENS,u'protect'),
		(STYLENS,u'rel-height'),
		(STYLENS,u'rel-width'),
		(STYLENS,u'repeat'),
		(STYLENS,u'run-through'),
		(STYLENS,u'shadow'),
		(STYLENS,u'vertical-pos'),
		(STYLENS,u'vertical-rel'),
		(STYLENS,u'wrap'),
		(STYLENS,u'wrap-contour'),
		(STYLENS,u'wrap-contour-mode'),
		(STYLENS,u'wrap-dynamic-threshold'),
		(STYLENS,u'writing-mode'),
		(SVGNS,u'fill-rule'),
		(SVGNS,u'height'),
		(SVGNS,u'stroke-color'),
		(SVGNS,u'stroke-opacity'),
		(SVGNS,u'stroke-width'),
		(SVGNS,u'width'),
		(SVGNS,u'x'),
		(SVGNS,u'y'),
		(TEXTNS,u'anchor-page-number'),
		(TEXTNS,u'anchor-type'),
		(TEXTNS,u'animation'),
		(TEXTNS,u'animation-delay'),
		(TEXTNS,u'animation-direction'),
		(TEXTNS,u'animation-repeat'),
		(TEXTNS,u'animation-start-inside'),
		(TEXTNS,u'animation-steps'),
		(TEXTNS,u'animation-stop-inside'),
	),
	(STYLENS,u'handout-master'):(
		(PRESENTATIONNS,u'presentation-page-layout-name'),
		(STYLENS,u'page-layout-name'),
		(PRESENTATIONNS,u'use-footer-name'),
		(DRAWNS,u'style-name'),
		(PRESENTATIONNS,u'use-header-name'),
		(PRESENTATIONNS,u'use-date-time-name'),
	),
# allowed_attributes
	(STYLENS,u'header'):(
		(STYLENS,u'display'),
	),
	(STYLENS,u'header-footer-properties'): (
		(FONS,u'background-color'),
		(FONS,u'border'),
		(FONS,u'border-bottom'),
		(FONS,u'border-left'),
		(FONS,u'border-right'),
		(FONS,u'border-top'),
		(FONS,u'margin'),
		(FONS,u'margin-bottom'),
		(FONS,u'margin-left'),
		(FONS,u'margin-right'),
		(FONS,u'margin-top'),
		(FONS,u'min-height'),
		(FONS,u'padding'),
		(FONS,u'padding-bottom'),
		(FONS,u'padding-left'),
		(FONS,u'padding-right'),
		(FONS,u'padding-top'),
		(STYLENS,u'border-line-width'),
		(STYLENS,u'border-line-width-bottom'),
		(STYLENS,u'border-line-width-left'),
		(STYLENS,u'border-line-width-right'),
		(STYLENS,u'border-line-width-top'),
		(STYLENS,u'dynamic-spacing'),
		(STYLENS,u'shadow'),
		(SVGNS,u'height'),
	),
	(STYLENS,u'header-left'):(
		(STYLENS,u'display'),
	),
	(STYLENS,u'header-style'):(
	),
# allowed_attributes
	(STYLENS,u'list-level-properties'): (
		(FONS,u'height'),
		(FONS,u'text-align'),
		(FONS,u'width'),
		(STYLENS,u'font-name'),
		(STYLENS,u'vertical-pos'),
		(STYLENS,u'vertical-rel'),
		(SVGNS,u'y'),
		(TEXTNS,u'min-label-distance'),
		(TEXTNS,u'min-label-width'),
		(TEXTNS,u'space-before'),
	),
	(STYLENS,u'map'):(
		(STYLENS,u'apply-style-name'),
		(STYLENS,u'base-cell-address'),
		(STYLENS,u'condition'),
	),
	(STYLENS,u'master-page'):(
		(STYLENS,u'page-layout-name'),
		(STYLENS,u'display-name'),
		(DRAWNS,u'style-name'),
		(STYLENS,u'name'),
		(STYLENS,u'next-style-name'),
	),
	(STYLENS,u'page-layout'):(
		(STYLENS,u'name'),
		(STYLENS,u'page-usage'),
	),
# allowed_attributes
	(STYLENS,u'page-layout-properties'): (
		(FONS,u'background-color'),
		(FONS,u'border'),
		(FONS,u'border-bottom'),
		(FONS,u'border-left'),
		(FONS,u'border-right'),
		(FONS,u'border-top'),
		(FONS,u'margin'),
		(FONS,u'margin-bottom'),
		(FONS,u'margin-left'),
		(FONS,u'margin-right'),
		(FONS,u'margin-top'),
		(FONS,u'padding'),
		(FONS,u'padding-bottom'),
		(FONS,u'padding-left'),
		(FONS,u'padding-right'),
		(FONS,u'padding-top'),
		(FONS,u'page-height'),
		(FONS,u'page-width'),
		(STYLENS,u'border-line-width'),
		(STYLENS,u'border-line-width-bottom'),
		(STYLENS,u'border-line-width-left'),
		(STYLENS,u'border-line-width-right'),
		(STYLENS,u'border-line-width-top'),
		(STYLENS,u'first-page-number'),
		(STYLENS,u'footnote-max-height'),
		(STYLENS,u'layout-grid-base-height'),
		(STYLENS,u'layout-grid-color'),
		(STYLENS,u'layout-grid-display'),
		(STYLENS,u'layout-grid-lines'),
		(STYLENS,u'layout-grid-mode'),
		(STYLENS,u'layout-grid-print'),
		(STYLENS,u'layout-grid-ruby-below'),
		(STYLENS,u'layout-grid-ruby-height'),
		(STYLENS,u'num-format'),
		(STYLENS,u'num-letter-sync'),
		(STYLENS,u'num-prefix'),
		(STYLENS,u'num-suffix'),
		(STYLENS,u'paper-tray-name'),
		(STYLENS,u'print'),
		(STYLENS,u'print-orientation'),
		(STYLENS,u'print-page-order'),
		(STYLENS,u'register-truth-ref-style-name'),
		(STYLENS,u'scale-to'),
		(STYLENS,u'scale-to-pages'),
		(STYLENS,u'shadow'),
		(STYLENS,u'table-centering'),
		(STYLENS,u'writing-mode'),
	),
# allowed_attributes
	(STYLENS,u'paragraph-properties'): (
		(FONS,u'background-color'),
		(FONS,u'border'),
		(FONS,u'border-bottom'),
		(FONS,u'border-left'),
		(FONS,u'border-right'),
		(FONS,u'border-top'),
		(FONS,u'break-after'),
		(FONS,u'break-before'),
		(FONS,u'hyphenation-keep'),
		(FONS,u'hyphenation-ladder-count'),
		(FONS,u'keep-together'),
		(FONS,u'keep-with-next'),
		(FONS,u'line-height'),
		(FONS,u'margin'),
		(FONS,u'margin-bottom'),
		(FONS,u'margin-left'),
		(FONS,u'margin-right'),
		(FONS,u'margin-top'),
		(FONS,u'orphans'),
		(FONS,u'padding'),
		(FONS,u'padding-bottom'),
		(FONS,u'padding-left'),
		(FONS,u'padding-right'),
		(FONS,u'padding-top'),
		(FONS,u'text-align'),
		(FONS,u'text-align-last'),
		(FONS,u'text-indent'),
		(FONS,u'widows'),
		(STYLENS,u'auto-text-indent'),
		(STYLENS,u'background-transparency'),
		(STYLENS,u'border-line-width'),
		(STYLENS,u'border-line-width-bottom'),
		(STYLENS,u'border-line-width-left'),
		(STYLENS,u'border-line-width-right'),
		(STYLENS,u'border-line-width-top'),
		(STYLENS,u'font-independent-line-spacing'),
		(STYLENS,u'justify-single-word'),
		(STYLENS,u'line-break'),
		(STYLENS,u'line-height-at-least'),
		(STYLENS,u'line-spacing'),
		(STYLENS,u'page-number'),
		(STYLENS,u'punctuation-wrap'),
		(STYLENS,u'register-true'),
		(STYLENS,u'shadow'),
		(STYLENS,u'snap-to-layout-grid'),
		(STYLENS,u'tab-stop-distance'),
		(STYLENS,u'text-autospace'),
		(STYLENS,u'vertical-align'),
		(STYLENS,u'writing-mode'),
		(STYLENS,u'writing-mode-automatic'),
		(TEXTNS,u'line-number'),
		(TEXTNS,u'number-lines'),
	),
	(STYLENS,u'presentation-page-layout'):(
		(STYLENS,u'display-name'),
		(STYLENS,u'name'),
	),
# allowed_attributes
	(STYLENS,u'region-center'):(
	),
	(STYLENS,u'region-left'):(
	),
	(STYLENS,u'region-right'):(
	),
	(STYLENS,u'ruby-properties'): (
		(STYLENS,u'ruby-position'),
		(STYLENS,u'ruby-align'),
	),
	(STYLENS,u'section-properties'): (
		(FONS,u'background-color'),
		(FONS,u'margin-left'),
		(FONS,u'margin-right'),
		(STYLENS,u'protect'),
		(STYLENS,u'writing-mode'),
		(TEXTNS,u'dont-balance-text-columns'),
	),
	(STYLENS,u'style'):(
		(STYLENS,u'family'),
		(STYLENS,u'list-style-name'),
		(STYLENS,u'name'),
		(STYLENS,u'auto-update'),
		(STYLENS,u'default-outline-level'),
		(STYLENS,u'class'),
		(STYLENS,u'next-style-name'),
		(STYLENS,u'data-style-name'),
		(STYLENS,u'master-page-name'),
		(STYLENS,u'display-name'),
		(STYLENS,u'parent-style-name'),
	),
# allowed_attributes
	(STYLENS,u'tab-stop'):(
		(STYLENS,u'leader-text-style'),
		(STYLENS,u'leader-width'),
		(STYLENS,u'leader-style'),
		(STYLENS,u'char'),
		(STYLENS,u'leader-color'),
		(STYLENS,u'position'),
		(STYLENS,u'leader-text'),
		(STYLENS,u'type'),
		(STYLENS,u'leader-type'),
	),
	(STYLENS,u'tab-stops'):(
	),
	(STYLENS,u'table-cell-properties'): (
		(FONS,u'background-color'),
		(FONS,u'border'),
		(FONS,u'border-bottom'),
		(FONS,u'border-left'),
		(FONS,u'border-right'),
		(FONS,u'border-top'),
		(FONS,u'padding'),
		(FONS,u'padding-bottom'),
		(FONS,u'padding-left'),
		(FONS,u'padding-right'),
		(FONS,u'padding-top'),
		(FONS,u'wrap-option'),
		(STYLENS,u'border-line-width'),
		(STYLENS,u'border-line-width-bottom'),
		(STYLENS,u'border-line-width-left'),
		(STYLENS,u'border-line-width-right'),
		(STYLENS,u'border-line-width-top'),
		(STYLENS,u'cell-protect'),
		(STYLENS,u'decimal-places'),
		(STYLENS,u'diagonal-bl-tr'),
		(STYLENS,u'diagonal-bl-tr-widths'),
		(STYLENS,u'diagonal-tl-br'),
		(STYLENS,u'diagonal-tl-br-widths'),
		(STYLENS,u'direction'),
		(STYLENS,u'glyph-orientation-vertical'),
		(STYLENS,u'print-content'),
		(STYLENS,u'repeat-content'),
		(STYLENS,u'rotation-align'),
		(STYLENS,u'rotation-angle'),
		(STYLENS,u'shadow'),
		(STYLENS,u'shrink-to-fit'),
		(STYLENS,u'text-align-source'),
		(STYLENS,u'vertical-align'),
	),
# allowed_attributes
	(STYLENS,u'table-column-properties'): (
		(FONS,u'break-after'),
		(FONS,u'break-before'),
		(STYLENS,u'column-width'),
		(STYLENS,u'rel-column-width'),
		(STYLENS,u'use-optimal-column-width'),
	),
	(STYLENS,u'table-properties'): (
		(FONS,u'background-color'),
		(FONS,u'break-after'),
		(FONS,u'break-before'),
		(FONS,u'keep-with-next'),
		(FONS,u'margin'),
		(FONS,u'margin-bottom'),
		(FONS,u'margin-left'),
		(FONS,u'margin-right'),
		(FONS,u'margin-top'),
		(STYLENS,u'may-break-between-rows'),
		(STYLENS,u'page-number'),
		(STYLENS,u'rel-width'),
		(STYLENS,u'shadow'),
		(STYLENS,u'width'),
		(STYLENS,u'writing-mode'),
		(TABLENS,u'align'),
		(TABLENS,u'border-model'),
		(TABLENS,u'display'),
	),
	(STYLENS,u'table-row-properties'): (
		(FONS,u'background-color'),
		(FONS,u'break-after'),
		(FONS,u'break-before'),
		(FONS,u'keep-together'),
		(STYLENS,u'min-row-height'),
		(STYLENS,u'row-height'),
		(STYLENS,u'use-optimal-row-height'),
	),
# allowed_attributes
	(STYLENS,u'text-properties'): (
		(FONS,u'background-color'),
		(FONS,u'color'),
		(FONS,u'country'),
		(FONS,u'font-family'),
		(FONS,u'font-size'),
		(FONS,u'font-style'),
		(FONS,u'font-variant'),
		(FONS,u'font-weight'),
		(FONS,u'hyphenate'),
		(FONS,u'hyphenation-push-char-count'),
		(FONS,u'hyphenation-remain-char-count'),
		(FONS,u'language'),
		(FONS,u'letter-spacing'),
		(FONS,u'text-shadow'),
		(FONS,u'text-transform'),
		(STYLENS,u'country-asian'),
		(STYLENS,u'country-complex'),
		(STYLENS,u'font-charset'),
		(STYLENS,u'font-charset-asian'),
		(STYLENS,u'font-charset-complex'),
		(STYLENS,u'font-family-asian'),
		(STYLENS,u'font-family-complex'),
		(STYLENS,u'font-family-generic'),
		(STYLENS,u'font-family-generic-asian'),
		(STYLENS,u'font-family-generic-complex'),
		(STYLENS,u'font-name'),
		(STYLENS,u'font-name-asian'),
		(STYLENS,u'font-name-complex'),
		(STYLENS,u'font-pitch'),
		(STYLENS,u'font-pitch-asian'),
		(STYLENS,u'font-pitch-complex'),
		(STYLENS,u'font-relief'),
		(STYLENS,u'font-size-asian'),
		(STYLENS,u'font-size-complex'),
		(STYLENS,u'font-size-rel'),
		(STYLENS,u'font-size-rel-asian'),
		(STYLENS,u'font-size-rel-complex'),
		(STYLENS,u'font-style-asian'),
		(STYLENS,u'font-style-complex'),
		(STYLENS,u'font-style-name'),
		(STYLENS,u'font-style-name-asian'),
		(STYLENS,u'font-style-name-complex'),
		(STYLENS,u'font-weight-asian'),
		(STYLENS,u'font-weight-complex'),
		(STYLENS,u'language-asian'),
		(STYLENS,u'language-complex'),
		(STYLENS,u'letter-kerning'),
		(STYLENS,u'script-type'),
		(STYLENS,u'text-blinking'),
		(STYLENS,u'text-combine'),
		(STYLENS,u'text-combine-end-char'),
		(STYLENS,u'text-combine-start-char'),
		(STYLENS,u'text-emphasize'),
		(STYLENS,u'text-line-through-color'),
		(STYLENS,u'text-line-through-mode'),
		(STYLENS,u'text-line-through-style'),
		(STYLENS,u'text-line-through-text'),
		(STYLENS,u'text-line-through-text-style'),
		(STYLENS,u'text-line-through-type'),
		(STYLENS,u'text-line-through-width'),
		(STYLENS,u'text-outline'),
		(STYLENS,u'text-position'),
		(STYLENS,u'text-rotation-angle'),
		(STYLENS,u'text-rotation-scale'),
		(STYLENS,u'text-scale'),
		(STYLENS,u'text-underline-color'),
		(STYLENS,u'text-underline-mode'),
		(STYLENS,u'text-underline-style'),
		(STYLENS,u'text-underline-type'),
		(STYLENS,u'text-underline-width'),
		(STYLENS,u'use-window-font-color'),
		(TEXTNS,u'condition'),
		(TEXTNS,u'display'),
	),
	(SVGNS,u'definition-src'):(
		(XLINKNS,u'actuate'),
		(XLINKNS,u'href'),
		(XLINKNS,u'type'),
	),
	(SVGNS,u'desc'):(
	),
	(SVGNS,u'font-face-format'):(
		(SVGNS,u'string'),
	),
# allowed_attributes
	(SVGNS,u'font-face-name'):(
		(SVGNS,u'name'),
	),
	(SVGNS,u'font-face-src'):(
	),
	(SVGNS,u'font-face-uri'):(
		(XLINKNS,u'actuate'),
		(XLINKNS,u'href'),
		(XLINKNS,u'type'),
	),
	(SVGNS,u'linearGradient'):(
		(SVGNS,u'y2'),
		(DRAWNS,u'name'),
		(SVGNS,u'spreadMethod'),
		(SVGNS,u'gradientUnits'),
		(SVGNS,u'x2'),
		(SVGNS,u'gradientTransform'),
		(SVGNS,u'y1'),
		(DRAWNS,u'display-name'),
		(SVGNS,u'x1'),
	),
	(SVGNS,u'radialGradient'):(
		(DRAWNS,u'name'),
		(SVGNS,u'fx'),
		(SVGNS,u'fy'),
		(SVGNS,u'spreadMethod'),
		(SVGNS,u'gradientUnits'),
		(SVGNS,u'cy'),
		(SVGNS,u'cx'),
		(SVGNS,u'gradientTransform'),
		(DRAWNS,u'display-name'),
		(SVGNS,u'r'),
	),
	(SVGNS,u'stop'):(
		(SVGNS,u'stop-color'),
		(SVGNS,u'stop-opacity'),
		(SVGNS,u'offset'),
	),
	(SVGNS,u'title'):(
	),
# allowed_attributes
	(TABLENS,u'body'):(
		(TEXTNS,u'paragraph-style-name'),
		(TEXTNS,u'style-name'),
	),
	(TABLENS,u'calculation-settings'):(
		(TABLENS,u'automatic-find-labels'),
		(TABLENS,u'case-sensitive'),
		(TABLENS,u'search-criteria-must-apply-to-whole-cell'),
		(TABLENS,u'precision-as-shown'),
		(TABLENS,u'use-regular-expressions'),
		(TABLENS,u'null-year'),
	),
	(TABLENS,u'cell-address'):(
		(TABLENS,u'column'),
		(TABLENS,u'table'),
		(TABLENS,u'row'),
	),
	(TABLENS,u'cell-content-change'):(
		(TABLENS,u'id'),
		(TABLENS,u'rejecting-change-id'),
		(TABLENS,u'acceptance-state'),
	),
	(TABLENS,u'cell-content-deletion'):(
		(TABLENS,u'id'),
	),
	(TABLENS,u'cell-range-source'):(
		(TABLENS,u'last-row-spanned'),
		(TABLENS,u'last-column-spanned'),
		(TABLENS,u'name'),
		(TABLENS,u'filter-options'),
		(XLINKNS,u'actuate'),
		(TABLENS,u'filter-name'),
		(XLINKNS,u'href'),
		(TABLENS,u'refresh-delay'),
		(XLINKNS,u'type'),
	),
	(TABLENS,u'change-deletion'):(
		(TABLENS,u'id'),
	),
	(TABLENS,u'change-track-table-cell'):(
		(OFFICENS,u'string-value'),
		(TABLENS,u'cell-address'),
		(TABLENS,u'number-matrix-columns-spanned'),
		(TABLENS,u'number-matrix-rows-spanned'),
		(TABLENS,u'matrix-covered'),
		(OFFICENS,u'value-type'),
		(OFFICENS,u'boolean-value'),
		(OFFICENS,u'currency'),
		(OFFICENS,u'date-value'),
		(OFFICENS,u'value'),
		(TABLENS,u'formula'),
		(OFFICENS,u'time-value'),
	),
	(TABLENS,u'consolidation'):(
		(TABLENS,u'function'),
		(TABLENS,u'source-cell-range-addresses'),
		(TABLENS,u'target-cell-address'),
		(TABLENS,u'link-to-source-data'),
		(TABLENS,u'use-labels'),
	),
	(TABLENS,u'content-validation'):(
		(TABLENS,u'base-cell-address'),
		(TABLENS,u'display-list'),
		(TABLENS,u'allow-empty-cell'),
		(TABLENS,u'name'),
		(TABLENS,u'condition'),
	),
	(TABLENS,u'content-validations'):(
	),
# allowed_attributes
	(TABLENS,u'covered-table-cell'):(
		(TABLENS,u'protect'),
		(OFFICENS,u'string-value'),
		(OFFICENS,u'value'),
		(OFFICENS,u'boolean-value'),
		(OFFICENS,u'currency'),
		(OFFICENS,u'date-value'),
		(TABLENS,u'style-name'),
		(TABLENS,u'content-validation-name'),
		(OFFICENS,u'value-type'),
		(TABLENS,u'number-columns-repeated'),
		(TABLENS,u'formula'),
		(OFFICENS,u'time-value'),
	),
	(TABLENS,u'cut-offs'):(
	),
	(TABLENS,u'data-pilot-display-info'):(
		(TABLENS,u'member-count'),
		(TABLENS,u'data-field'),
		(TABLENS,u'enabled'),
		(TABLENS,u'display-member-mode'),
	),
	(TABLENS,u'data-pilot-field'):(
		(TABLENS,u'selected-page'),
		(TABLENS,u'function'),
		(TABLENS,u'orientation'),
		(TABLENS,u'used-hierarchy'),
		(TABLENS,u'is-data-layout-field'),
		(TABLENS,u'source-field-name'),
	),
	(TABLENS,u'data-pilot-field-reference'):(
		(TABLENS,u'member-name'),
		(TABLENS,u'field-name'),
		(TABLENS,u'member-type'),
		(TABLENS,u'type'),
	),
# allowed_attributes
	(TABLENS,u'data-pilot-group'):(
		(TABLENS,u'name'),
	),
	(TABLENS,u'data-pilot-group-member'):(
		(TABLENS,u'name'),
	),
	(TABLENS,u'data-pilot-groups'):(
		(TABLENS,u'date-end'),
		(TABLENS,u'end'),
		(TABLENS,u'start'),
		(TABLENS,u'source-field-name'),
		(TABLENS,u'step'),
		(TABLENS,u'date-start'),
		(TABLENS,u'grouped-by'),
	),
	(TABLENS,u'data-pilot-layout-info'):(
		(TABLENS,u'add-empty-lines'),
		(TABLENS,u'layout-mode'),
	),
	(TABLENS,u'data-pilot-level'):(
		(TABLENS,u'show-empty'),
	),
# allowed_attributes
	(TABLENS,u'data-pilot-member'):(
		(TABLENS,u'show-details'),
		(TABLENS,u'name'),
		(TABLENS,u'display'),
	),
	(TABLENS,u'data-pilot-members'):(
	),
	(TABLENS,u'data-pilot-sort-info'):(
		(TABLENS,u'data-field'),
		(TABLENS,u'sort-mode'),
		(TABLENS,u'order'),
	),
	(TABLENS,u'data-pilot-subtotal'):(
		(TABLENS,u'function'),
	),
	(TABLENS,u'data-pilot-subtotals'):(
	),
	(TABLENS,u'data-pilot-table'):(
		(TABLENS,u'buttons'),
		(TABLENS,u'application-data'),
		(TABLENS,u'name'),
		(TABLENS,u'drill-down-on-double-click'),
		(TABLENS,u'target-range-address'),
		(TABLENS,u'ignore-empty-rows'),
		(TABLENS,u'identify-categories'),
		(TABLENS,u'show-filter-button'),
		(TABLENS,u'grand-total'),
	),
# allowed_attributes
	(TABLENS,u'data-pilot-tables'):(
	),
	(TABLENS,u'database-range'):(
		(TABLENS,u'orientation'),
		(TABLENS,u'target-range-address'),
		(TABLENS,u'contains-header'),
		(TABLENS,u'on-update-keep-size'),
		(TABLENS,u'name'),
		(TABLENS,u'is-selection'),
		(TABLENS,u'refresh-delay'),
		(TABLENS,u'display-filter-buttons'),
		(TABLENS,u'has-persistent-data'),
		(TABLENS,u'on-update-keep-styles'),
	),
	(TABLENS,u'database-ranges'):(
	),
	(TABLENS,u'database-source-query'):(
		(TABLENS,u'query-name'),
		(TABLENS,u'database-name'),
	),
# allowed_attributes
	(TABLENS,u'database-source-sql'):(
		(TABLENS,u'parse-sql-statement'),
		(TABLENS,u'database-name'),
		(TABLENS,u'sql-statement'),
	),
	(TABLENS,u'database-source-table'):(
		(TABLENS,u'database-table-name'),
		(TABLENS,u'database-name'),
	),
	(TABLENS,u'dde-link'):(
	),
	(TABLENS,u'dde-links'):(
	),
	(TABLENS,u'deletion'):(
		(TABLENS,u'rejecting-change-id'),
		(TABLENS,u'multi-deletion-spanned'),
		(TABLENS,u'acceptance-state'),
		(TABLENS,u'table'),
		(TABLENS,u'position'),
		(TABLENS,u'type'),
		(TABLENS,u'id'),
	),
# allowed_attributes
	(TABLENS,u'deletions'):(
	),
	(TABLENS,u'dependencies'):(
	),
	(TABLENS,u'dependency'):(
		(TABLENS,u'id'),
	),
	(TABLENS,u'detective'):(
	),
	(TABLENS,u'error-macro'):(
		(TABLENS,u'execute'),
	),
	(TABLENS,u'error-message'):(
		(TABLENS,u'display'),
		(TABLENS,u'message-type'),
		(TABLENS,u'title'),
	),
	(TABLENS,u'even-columns'):(
		(TEXTNS,u'paragraph-style-name'),
		(TEXTNS,u'style-name'),
	),
	(TABLENS,u'even-rows'):(
		(TEXTNS,u'paragraph-style-name'),
		(TEXTNS,u'style-name'),
	),
# allowed_attributes
	(TABLENS,u'filter'):(
		(TABLENS,u'target-range-address'),
		(TABLENS,u'display-duplicates'),
		(TABLENS,u'condition-source-range-address'),
		(TABLENS,u'condition-source'),
	),
	(TABLENS,u'filter-and'):(
	),
	(TABLENS,u'filter-condition'):(
		(TABLENS,u'operator'),
		(TABLENS,u'field-number'),
		(TABLENS,u'data-type'),
		(TABLENS,u'case-sensitive'),
		(TABLENS,u'value'),
	),
	(TABLENS,u'filter-or'):(
	),
	(TABLENS,u'first-column'):(
		(TEXTNS,u'paragraph-style-name'),
		(TEXTNS,u'style-name'),
	),
	(TABLENS,u'first-row'):(
		(TEXTNS,u'paragraph-style-name'),
		(TEXTNS,u'style-name'),
	),
# allowed_attributes
	(TABLENS,u'help-message'):(
		(TABLENS,u'display'),
		(TABLENS,u'title'),
	),
	(TABLENS,u'highlighted-range'):(
		(TABLENS,u'contains-error'),
		(TABLENS,u'direction'),
		(TABLENS,u'marked-invalid'),
		(TABLENS,u'cell-range-address'),
	),
	(TABLENS,u'insertion'):(
		(TABLENS,u'count'),
		(TABLENS,u'rejecting-change-id'),
		(TABLENS,u'acceptance-state'),
		(TABLENS,u'table'),
		(TABLENS,u'position'),
		(TABLENS,u'type'),
		(TABLENS,u'id'),
	),
	(TABLENS,u'insertion-cut-off'):(
		(TABLENS,u'position'),
		(TABLENS,u'id'),
	),
	(TABLENS,u'iteration'):(
		(TABLENS,u'status'),
		(TABLENS,u'maximum-difference'),
		(TABLENS,u'steps'),
	),
# allowed_attributes
	(TABLENS,u'label-range'):(
		(TABLENS,u'label-cell-range-address'),
		(TABLENS,u'data-cell-range-address'),
		(TABLENS,u'orientation'),
	),
	(TABLENS,u'label-ranges'):(
	),
	(TABLENS,u'last-column'):(
		(TEXTNS,u'paragraph-style-name'),
		(TEXTNS,u'style-name'),
	),
	(TABLENS,u'last-row'):(
		(TEXTNS,u'paragraph-style-name'),
		(TEXTNS,u'style-name'),
	),
	(TABLENS,u'movement'):(
		(TABLENS,u'id'),
		(TABLENS,u'rejecting-change-id'),
		(TABLENS,u'acceptance-state'),
	),
	(TABLENS,u'movement-cut-off'):(
		(TABLENS,u'position'),
		(TABLENS,u'end-position'),
		(TABLENS,u'start-position'),
	),
	(TABLENS,u'named-expression'):(
		(TABLENS,u'base-cell-address'),
		(TABLENS,u'expression'),
		(TABLENS,u'name'),
	),
	(TABLENS,u'named-expressions'):(
	),
	(TABLENS,u'named-range'):(
		(TABLENS,u'range-usable-as'),
		(TABLENS,u'base-cell-address'),
		(TABLENS,u'name'),
		(TABLENS,u'cell-range-address'),
	),
	(TABLENS,u'null-date'):(
		(TABLENS,u'date-value'),
		(TABLENS,u'value-type'),
	),
	(TABLENS,u'odd-columns'):(
		(TEXTNS,u'paragraph-style-name'),
		(TEXTNS,u'style-name'),
	),
	(TABLENS,u'odd-rows'):(
		(TEXTNS,u'paragraph-style-name'),
		(TEXTNS,u'style-name'),
	),
	(TABLENS,u'operation'):(
		(TABLENS,u'index'),
		(TABLENS,u'name'),
	),
	(TABLENS,u'previous'):(
		(TABLENS,u'id'),
	),
	(TABLENS,u'scenario'):(
		(TABLENS,u'comment'),
		(TABLENS,u'border-color'),
		(TABLENS,u'copy-back'),
		(TABLENS,u'is-active'),
		(TABLENS,u'protected'),
		(TABLENS,u'copy-formulas'),
		(TABLENS,u'copy-styles'),
		(TABLENS,u'scenario-ranges'),
		(TABLENS,u'display-border'),
	),
	(TABLENS,u'shapes'):(
	),
	(TABLENS,u'sort'):(
		(TABLENS,u'case-sensitive'),
		(TABLENS,u'algorithm'),
		(TABLENS,u'target-range-address'),
		(TABLENS,u'country'),
		(TABLENS,u'language'),
		(TABLENS,u'bind-styles-to-content'),
	),
	(TABLENS,u'sort-by'):(
		(TABLENS,u'field-number'),
		(TABLENS,u'data-type'),
		(TABLENS,u'order'),
	),
	(TABLENS,u'sort-groups'):(
		(TABLENS,u'data-type'),
		(TABLENS,u'order'),
	),
	(TABLENS,u'source-cell-range'):(
		(TABLENS,u'cell-range-address'),
	),
	(TABLENS,u'source-range-address'):(
		(TABLENS,u'column'),
		(TABLENS,u'end-column'),
		(TABLENS,u'start-table'),
		(TABLENS,u'end-row'),
		(TABLENS,u'table'),
		(TABLENS,u'start-row'),
		(TABLENS,u'row'),
		(TABLENS,u'end-table'),
		(TABLENS,u'start-column'),
	),
# allowed_attributes
	(TABLENS,u'source-service'):(
		(TABLENS,u'user-name'),
		(TABLENS,u'source-name'),
		(TABLENS,u'password'),
		(TABLENS,u'object-name'),
		(TABLENS,u'name'),
	),
	(TABLENS,u'subtotal-field'):(
		(TABLENS,u'function'),
		(TABLENS,u'field-number'),
	),
	(TABLENS,u'subtotal-rule'):(
		(TABLENS,u'group-by-field-number'),
	),
	(TABLENS,u'subtotal-rules'):(
		(TABLENS,u'bind-styles-to-content'),
		(TABLENS,u'page-breaks-on-group-change'),
		(TABLENS,u'case-sensitive'),
	),
	(TABLENS,u'table'):(
		(TABLENS,u'name'),
		(TABLENS,u'is-sub-table'),
		(TABLENS,u'style-name'),
		(TABLENS,u'protected'),
		(TABLENS,u'print-ranges'),
		(TABLENS,u'print'),
		(TABLENS,u'protection-key'),
	),
	(TABLENS,u'table-cell'):(
		(TABLENS,u'protect'),
		(TABLENS,u'number-matrix-rows-spanned'),
		(TABLENS,u'number-matrix-columns-spanned'),
		(OFFICENS,u'string-value'),
		(TABLENS,u'number-columns-spanned'),
		(OFFICENS,u'value'),
		(OFFICENS,u'boolean-value'),
		(OFFICENS,u'currency'),
		(OFFICENS,u'date-value'),
		(TABLENS,u'style-name'),
		(TABLENS,u'content-validation-name'),
		(OFFICENS,u'value-type'),
		(TABLENS,u'number-rows-spanned'),
		(TABLENS,u'number-columns-repeated'),
		(TABLENS,u'formula'),
		(OFFICENS,u'time-value'),
	),
# allowed_attributes
	(TABLENS,u'table-column'):(
		(TABLENS,u'style-name'),
		(TABLENS,u'default-cell-style-name'),
		(TABLENS,u'visibility'),
		(TABLENS,u'number-columns-repeated'),
	),
	(TABLENS,u'table-column-group'):(
		(TABLENS,u'display'),
	),
	(TABLENS,u'table-columns'):(
	),
	(TABLENS,u'table-header-columns'):(
	),
	(TABLENS,u'table-header-rows'):(
	),
	(TABLENS,u'table-row'):(
		(TABLENS,u'number-rows-repeated'),
		(TABLENS,u'style-name'),
		(TABLENS,u'visibility'),
		(TABLENS,u'default-cell-style-name'),
	),
	(TABLENS,u'table-row-group'):(
		(TABLENS,u'display'),
	),
	(TABLENS,u'table-rows'):(
	),
	(TABLENS,u'table-source'):(
		(TABLENS,u'filter-options'),
		(XLINKNS,u'actuate'),
		(TABLENS,u'filter-name'),
		(XLINKNS,u'href'),
		(TABLENS,u'mode'),
		(TABLENS,u'table-name'),
		(XLINKNS,u'type'),
		(TABLENS,u'refresh-delay'),
	),
	(TABLENS,u'table-template'):(
		(TEXTNS,u'last-row-end-column'),
		(TEXTNS,u'first-row-end-column'),
		(TEXTNS,u'name'),
		(TEXTNS,u'last-row-start-column'),
		(TEXTNS,u'first-row-start-column'),
	),
	(TABLENS,u'target-range-address'):(
		(TABLENS,u'column'),
		(TABLENS,u'end-column'),
		(TABLENS,u'start-table'),
		(TABLENS,u'end-row'),
		(TABLENS,u'table'),
		(TABLENS,u'start-row'),
		(TABLENS,u'row'),
		(TABLENS,u'end-table'),
		(TABLENS,u'start-column'),
	),
	(TABLENS,u'tracked-changes'):(
		(TABLENS,u'track-changes'),
	),
# allowed_attributes
	(TEXTNS,u'a'):(
		(TEXTNS,u'visited-style-name'),
		(OFFICENS,u'name'),
		(OFFICENS,u'title'),
		(XLINKNS,u'show'),
		(OFFICENS,u'target-frame-name'),
		(XLINKNS,u'actuate'),
		(TEXTNS,u'style-name'),
		(XLINKNS,u'href'),
		(XLINKNS,u'type'),
	),
	(TEXTNS,u'alphabetical-index'):(
		(TEXTNS,u'protected'),
		(TEXTNS,u'style-name'),
		(TEXTNS,u'name'),
		(TEXTNS,u'protection-key'),
	),
	(TEXTNS,u'alphabetical-index-auto-mark-file'):(
		(XLINKNS,u'href'),
		(XLINKNS,u'type'),
	),
	(TEXTNS,u'alphabetical-index-entry-template'):(
		(TEXTNS,u'style-name'),
		(TEXTNS,u'outline-level'),
	),
	(TEXTNS,u'alphabetical-index-mark'):(
		(TEXTNS,u'main-entry'),
		(TEXTNS,u'key1-phonetic'),
		(TEXTNS,u'key2'),
		(TEXTNS,u'key1'),
		(TEXTNS,u'string-value'),
		(TEXTNS,u'key2-phonetic'),
		(TEXTNS,u'string-value-phonetic'),
	),
# allowed_attributes
	(TEXTNS,u'alphabetical-index-mark-end'):(
		(TEXTNS,u'id'),
	),
	(TEXTNS,u'alphabetical-index-mark-start'):(
		(TEXTNS,u'main-entry'),
		(TEXTNS,u'key1-phonetic'),
		(TEXTNS,u'key2'),
		(TEXTNS,u'key1'),
		(TEXTNS,u'string-value-phonetic'),
		(TEXTNS,u'key2-phonetic'),
		(TEXTNS,u'id'),
	),
	(TEXTNS,u'alphabetical-index-source'):(
		(TEXTNS,u'capitalize-entries'),
		(FONS,u'language'),
		(TEXTNS,u'relative-tab-stop-position'),
		(TEXTNS,u'alphabetical-separators'),
		(TEXTNS,u'combine-entries-with-pp'),
		(TEXTNS,u'combine-entries-with-dash'),
		(TEXTNS,u'sort-algorithm'),
		(TEXTNS,u'ignore-case'),
		(TEXTNS,u'combine-entries'),
		(TEXTNS,u'comma-separated'),
		(FONS,u'country'),
		(TEXTNS,u'index-scope'),
		(TEXTNS,u'main-entry-style-name'),
		(TEXTNS,u'use-keys-as-entries'),
	),
# allowed_attributes
	(TEXTNS,u'author-initials'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'author-name'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'bibliography'):(
		(TEXTNS,u'protected'),
		(TEXTNS,u'style-name'),
		(TEXTNS,u'name'),
		(TEXTNS,u'protection-key'),
	),
	(TEXTNS,u'bibliography-configuration'):(
		(TEXTNS,u'suffix'),
		(FONS,u'language'),
		(TEXTNS,u'numbered-entries'),
		(FONS,u'country'),
		(TEXTNS,u'sort-by-position'),
		(TEXTNS,u'sort-algorithm'),
		(TEXTNS,u'prefix'),
	),
	(TEXTNS,u'bibliography-entry-template'):(
		(TEXTNS,u'style-name'),
		(TEXTNS,u'bibliography-type'),
	),
# allowed_attributes
	(TEXTNS,u'bibliography-mark'):(
		(TEXTNS,u'address'),
		(TEXTNS,u'annote'),
		(TEXTNS,u'author'),
		(TEXTNS,u'bibliography-type'),
		(TEXTNS,u'booktitle'),
		(TEXTNS,u'chapter'),
		(TEXTNS,u'custom1'),
		(TEXTNS,u'custom2'),
		(TEXTNS,u'custom3'),
		(TEXTNS,u'custom4'),
		(TEXTNS,u'custom5'),
		(TEXTNS,u'edition'),
		(TEXTNS,u'editor'),
		(TEXTNS,u'howpublished'),
		(TEXTNS,u'identifier'),
		(TEXTNS,u'institution'),
		(TEXTNS,u'isbn'),
		(TEXTNS,u'issn'),
		(TEXTNS,u'journal'),
		(TEXTNS,u'month'),
		(TEXTNS,u'note'),
		(TEXTNS,u'number'),
		(TEXTNS,u'organizations'),
		(TEXTNS,u'pages'),
		(TEXTNS,u'publisher'),
		(TEXTNS,u'report-type'),
		(TEXTNS,u'school'),
		(TEXTNS,u'series'),
		(TEXTNS,u'title'),
		(TEXTNS,u'url'),
		(TEXTNS,u'volume'),
		(TEXTNS,u'year'),
	),
	(TEXTNS,u'bibliography-source'):(
	),
	(TEXTNS,u'bookmark'):(
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'bookmark-end'):(
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'bookmark-ref'):(
		(TEXTNS,u'ref-name'),
		(TEXTNS,u'reference-format'),
	),
	(TEXTNS,u'bookmark-start'):(
		(TEXTNS,u'name'),
	),
# allowed_attributes
	(TEXTNS,u'change'):(
		(TEXTNS,u'change-id'),
	),
	(TEXTNS,u'change-end'):(
		(TEXTNS,u'change-id'),
	),
	(TEXTNS,u'change-start'):(
		(TEXTNS,u'change-id'),
	),
	(TEXTNS,u'changed-region'):(
		(TEXTNS,u'id'),
	),
	(TEXTNS,u'chapter'):(
		(TEXTNS,u'display'),
		(TEXTNS,u'outline-level'),
	),
	(TEXTNS,u'conditional-text'):(
		(TEXTNS,u'string-value-if-true'),
		(TEXTNS,u'current-value'),
		(TEXTNS,u'string-value-if-false'),
		(TEXTNS,u'condition'),
	),
	(TEXTNS,u'creation-date'):(
		(TEXTNS,u'date-value'),
		(TEXTNS,u'fixed'),
		(STYLENS,u'data-style-name'),
	),
	(TEXTNS,u'creation-time'):(
		(TEXTNS,u'fixed'),
		(TEXTNS,u'time-value'),
		(STYLENS,u'data-style-name'),
	),
	(TEXTNS,u'creator'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'database-display'):(
		(TEXTNS,u'column-name'),
		(TEXTNS,u'table-name'),
		(TEXTNS,u'table-type'),
		(TEXTNS,u'database-name'),
		(STYLENS,u'data-style-name'),
	),
	(TEXTNS,u'database-name'):(
		(TEXTNS,u'table-name'),
		(TEXTNS,u'table-type'),
		(TEXTNS,u'database-name'),
	),
	(TEXTNS,u'database-next'):(
		(TEXTNS,u'table-name'),
		(TEXTNS,u'table-type'),
		(TEXTNS,u'database-name'),
		(TEXTNS,u'condition'),
	),
	(TEXTNS,u'database-row-number'):(
		(STYLENS,u'num-format'),
		(TEXTNS,u'database-name'),
		(TEXTNS,u'value'),
		(STYLENS,u'num-letter-sync'),
		(TEXTNS,u'table-name'),
		(TEXTNS,u'table-type'),
	),
	(TEXTNS,u'database-row-select'):(
		(TEXTNS,u'row-number'),
		(TEXTNS,u'table-name'),
		(TEXTNS,u'table-type'),
		(TEXTNS,u'database-name'),
		(TEXTNS,u'condition'),
	),
# allowed_attributes
	(TEXTNS,u'date'):(
		(TEXTNS,u'date-value'),
		(TEXTNS,u'fixed'),
		(TEXTNS,u'date-adjust'),
		(STYLENS,u'data-style-name'),
	),
	(TEXTNS,u'dde-connection'):(
		(TEXTNS,u'connection-name'),
	),
	(TEXTNS,u'dde-connection-decl'):(
		(OFFICENS,u'automatic-update'),
		(OFFICENS,u'dde-topic'),
		(OFFICENS,u'dde-application'),
		(OFFICENS,u'name'),
		(OFFICENS,u'dde-item'),
	),
	(TEXTNS,u'dde-connection-decls'):(
	),
	(TEXTNS,u'deletion'):(
	),
	(TEXTNS,u'description'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'editing-cycles'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'editing-duration'):(
		(TEXTNS,u'duration'),
		(TEXTNS,u'fixed'),
		(STYLENS,u'data-style-name'),
	),
	(TEXTNS,u'execute-macro'):(
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'expression'):(
		(TEXTNS,u'display'),
		(OFFICENS,u'string-value'),
		(OFFICENS,u'value'),
		(OFFICENS,u'boolean-value'),
		(OFFICENS,u'currency'),
		(OFFICENS,u'date-value'),
		(STYLENS,u'data-style-name'),
		(OFFICENS,u'value-type'),
		(TEXTNS,u'formula'),
		(OFFICENS,u'time-value'),
	),
	(TEXTNS,u'file-name'):(
		(TEXTNS,u'fixed'),
		(TEXTNS,u'display'),
	),
# allowed_attributes
	(TEXTNS,u'format-change'):(
	),
	(TEXTNS,u'h'):(
		(TEXTNS,u'restart-numbering'),
		(TEXTNS,u'cond-style-name'),
		(TEXTNS,u'is-list-header'),
		(TEXTNS,u'style-name'),
		(TEXTNS,u'class-names'),
		(TEXTNS,u'start-value'),
		(TEXTNS,u'id'),
		(TEXTNS,u'outline-level'),
	),
	(TEXTNS,u'hidden-paragraph'):(
		(TEXTNS,u'is-hidden'),
		(TEXTNS,u'condition'),
	),
	(TEXTNS,u'hidden-text'):(
		(TEXTNS,u'string-value'),
		(TEXTNS,u'is-hidden'),
		(TEXTNS,u'condition'),
	),
	(TEXTNS,u'illustration-index'):(
		(TEXTNS,u'protected'),
		(TEXTNS,u'style-name'),
		(TEXTNS,u'name'),
		(TEXTNS,u'protection-key'),
	),
	(TEXTNS,u'illustration-index-entry-template'):(
		(TEXTNS,u'style-name'),
	),
	(TEXTNS,u'illustration-index-source'):(
		(TEXTNS,u'index-scope'),
		(TEXTNS,u'caption-sequence-name'),
		(TEXTNS,u'use-caption'),
		(TEXTNS,u'caption-sequence-format'),
		(TEXTNS,u'relative-tab-stop-position'),
	),
	(TEXTNS,u'index-body'):(
	),
	(TEXTNS,u'index-entry-bibliography'):(
		(TEXTNS,u'bibliography-data-field'),
		(TEXTNS,u'style-name'),
	),
	(TEXTNS,u'index-entry-chapter'):(
		(TEXTNS,u'style-name'),
		(TEXTNS,u'display'),
	),
# allowed_attributes
	(TEXTNS,u'index-entry-link-end'):(
		(TEXTNS,u'style-name'),
	),
	(TEXTNS,u'index-entry-link-start'):(
		(TEXTNS,u'style-name'),
	),
	(TEXTNS,u'index-entry-page-number'):(
		(TEXTNS,u'style-name'),
	),
	(TEXTNS,u'index-entry-span'):(
		(TEXTNS,u'style-name'),
	),
	(TEXTNS,u'index-entry-tab-stop'):(
		(STYLENS,u'position'),
		(TEXTNS,u'style-name'),
		(STYLENS,u'type'),
		(STYLENS,u'leader-char'),
	),
	(TEXTNS,u'index-entry-text'):(
		(TEXTNS,u'style-name'),
	),
	(TEXTNS,u'index-source-style'):(
		(TEXTNS,u'style-name'),
	),
	(TEXTNS,u'index-source-styles'):(
		(TEXTNS,u'outline-level'),
	),
	(TEXTNS,u'index-title'):(
		(TEXTNS,u'protected'),
		(TEXTNS,u'style-name'),
		(TEXTNS,u'name'),
		(TEXTNS,u'protection-key'),
	),
	(TEXTNS,u'index-title-template'):(
		(TEXTNS,u'style-name'),
	),
	(TEXTNS,u'initial-creator'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'insertion'):(
	),
# allowed_attributes
	(TEXTNS,u'keywords'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'line-break'):(
	),
	(TEXTNS,u'linenumbering-configuration'):(
		(TEXTNS,u'number-position'),
		(TEXTNS,u'number-lines'),
		(STYLENS,u'num-format'),
		(TEXTNS,u'count-empty-lines'),
		(TEXTNS,u'count-in-text-boxes'),
		(TEXTNS,u'style-name'),
		(STYLENS,u'num-letter-sync'),
		(TEXTNS,u'increment'),
		(TEXTNS,u'offset'),
		(TEXTNS,u'restart-on-page'),
	),
	(TEXTNS,u'linenumbering-separator'):(
		(TEXTNS,u'increment'),
	),
	(TEXTNS,u'list'):(
		(TEXTNS,u'style-name'),
		(TEXTNS,u'continue-numbering'),
	),
	(TEXTNS,u'list-header'):(
	),
	(TEXTNS,u'list-item'):(
		(TEXTNS,u'start-value'),
	),
	(TEXTNS,u'list-level-style-bullet'):(
		(TEXTNS,u'level'),
		(STYLENS,u'num-prefix'),
		(STYLENS,u'num-suffix'),
		(TEXTNS,u'bullet-relative-size'),
		(TEXTNS,u'style-name'),
		(TEXTNS,u'bullet-char'),
	),
	(TEXTNS,u'list-level-style-image'):(
		(XLINKNS,u'show'),
		(XLINKNS,u'actuate'),
		(XLINKNS,u'href'),
		(XLINKNS,u'type'),
		(TEXTNS,u'level'),
	),
	(TEXTNS,u'list-level-style-number'):(
		(TEXTNS,u'level'),
		(TEXTNS,u'display-levels'),
		(STYLENS,u'num-format'),
		(STYLENS,u'num-suffix'),
		(TEXTNS,u'style-name'),
		(STYLENS,u'num-prefix'),
		(STYLENS,u'num-letter-sync'),
		(TEXTNS,u'start-value'),
	),
# allowed_attributes
	(TEXTNS,u'list-style'):(
		(TEXTNS,u'consecutive-numbering'),
		(STYLENS,u'display-name'),
		(STYLENS,u'name'),
	),
	(TEXTNS,u'measure'):(
		(TEXTNS,u'kind'),
	),
	(TEXTNS,u'modification-date'):(
		(TEXTNS,u'date-value'),
		(TEXTNS,u'fixed'),
		(STYLENS,u'data-style-name'),
	),
	(TEXTNS,u'modification-time'):(
		(TEXTNS,u'fixed'),
		(TEXTNS,u'time-value'),
		(STYLENS,u'data-style-name'),
	),
	(TEXTNS,u'note'):(
		(TEXTNS,u'note-class'),
		(TEXTNS,u'id'),
	),
	(TEXTNS,u'note-body'):(
	),
	(TEXTNS,u'note-citation'):(
		(TEXTNS,u'label'),
	),
	(TEXTNS,u'note-continuation-notice-backward'):(
	),
	(TEXTNS,u'note-continuation-notice-forward'):(
	),
	(TEXTNS,u'note-ref'):(
		(TEXTNS,u'ref-name'),
		(TEXTNS,u'note-class'),
		(TEXTNS,u'reference-format'),
	),
	(TEXTNS,u'notes-configuration'):(
		(TEXTNS,u'citation-body-style-name'),
		(STYLENS,u'num-format'),
		(TEXTNS,u'default-style-name'),
		(STYLENS,u'num-suffix'),
		(TEXTNS,u'start-numbering-at'),
		(STYLENS,u'num-prefix'),
		(STYLENS,u'num-letter-sync'),
		(TEXTNS,u'citation-style-name'),
		(TEXTNS,u'footnotes-position'),
		(TEXTNS,u'master-page-name'),
		(TEXTNS,u'start-value'),
		(TEXTNS,u'note-class'),
	),
	(TEXTNS,u'number'):(
	),
	(TEXTNS,u'numbered-paragraph'):(
		(TEXTNS,u'continue-numbering'),
		(TEXTNS,u'style-name'),
		(TEXTNS,u'start-value'),
		(TEXTNS,u'level'),
	),
	(TEXTNS,u'object-count'):(
		(STYLENS,u'num-format'),
		(STYLENS,u'num-letter-sync'),
	),
	(TEXTNS,u'object-index'):(
		(TEXTNS,u'protected'),
		(TEXTNS,u'style-name'),
		(TEXTNS,u'name'),
		(TEXTNS,u'protection-key'),
	),
# allowed_attributes
	(TEXTNS,u'object-index-entry-template'):(
		(TEXTNS,u'style-name'),
	),
	(TEXTNS,u'object-index-source'):(
		(TEXTNS,u'use-draw-objects'),
		(TEXTNS,u'use-math-objects'),
		(TEXTNS,u'relative-tab-stop-position'),
		(TEXTNS,u'use-chart-objects'),
		(TEXTNS,u'index-scope'),
		(TEXTNS,u'use-spreadsheet-objects'),
		(TEXTNS,u'use-other-objects'),
	),
	(TEXTNS,u'outline-level-style'):(
		(TEXTNS,u'level'),
		(TEXTNS,u'display-levels'),
		(STYLENS,u'num-format'),
		(STYLENS,u'num-suffix'),
		(TEXTNS,u'style-name'),
		(STYLENS,u'num-prefix'),
		(STYLENS,u'num-letter-sync'),
		(TEXTNS,u'start-value'),
	),
	(TEXTNS,u'outline-style'):(
	),
	(TEXTNS,u'p'):(
		(TEXTNS,u'cond-style-name'),
		(TEXTNS,u'style-name'),
		(TEXTNS,u'class-names'),
		(TEXTNS,u'id'),
	),
	(TEXTNS,u'page'):(
		(TEXTNS,u'master-page-name'),
	),
	(TEXTNS,u'page-continuation'):(
		(TEXTNS,u'string-value'),
		(TEXTNS,u'select-page'),
	),
	(TEXTNS,u'page-number'):(
		(TEXTNS,u'page-adjust'),
		(STYLENS,u'num-format'),
		(TEXTNS,u'fixed'),
		(STYLENS,u'num-letter-sync'),
		(TEXTNS,u'select-page'),
	),
	(TEXTNS,u'page-sequence'):(
	),
	(TEXTNS,u'page-variable-get'):(
		(STYLENS,u'num-format'),
		(STYLENS,u'num-letter-sync'),
	),
	(TEXTNS,u'page-variable-set'):(
		(TEXTNS,u'active'),
		(TEXTNS,u'page-adjust'),
	),
	(TEXTNS,u'placeholder'):(
		(TEXTNS,u'placeholder-type'),
		(TEXTNS,u'description'),
	),
	(TEXTNS,u'print-date'):(
		(TEXTNS,u'date-value'),
		(TEXTNS,u'fixed'),
		(STYLENS,u'data-style-name'),
	),
	(TEXTNS,u'print-time'):(
		(TEXTNS,u'fixed'),
		(TEXTNS,u'time-value'),
		(STYLENS,u'data-style-name'),
	),
	(TEXTNS,u'printed-by'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'reference-mark'):(
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'reference-mark-end'):(
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'reference-mark-start'):(
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'ruby'):(
		(TEXTNS,u'style-name'),
	),
	(TEXTNS,u'ruby-base'):(
	),
	(TEXTNS,u'ruby-text'):(
		(TEXTNS,u'style-name'),
	),
	(TEXTNS,u's'):(
		(TEXTNS,u'c'),
	),
	(TEXTNS,u'script'):(
		(XLINKNS,u'href'),
		(XLINKNS,u'type'),
		(SCRIPTNS,u'language'),
	),
	(TEXTNS,u'section'):(
		(TEXTNS,u'name'),
		(TEXTNS,u'protection-key'),
		(TEXTNS,u'style-name'),
		(TEXTNS,u'protected'),
		(TEXTNS,u'display'),
		(TEXTNS,u'condition'),
	),
	(TEXTNS,u'section-source'):(
		(TEXTNS,u'filter-name'),
		(XLINKNS,u'href'),
		(XLINKNS,u'type'),
		(TEXTNS,u'section-name'),
		(XLINKNS,u'show'),
	),
	(TEXTNS,u'sender-city'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'sender-company'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'sender-country'):(
		(TEXTNS,u'fixed'),
	),
# allowed_attributes
	(TEXTNS,u'sender-email'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'sender-fax'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'sender-firstname'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'sender-initials'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'sender-lastname'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'sender-phone-private'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'sender-phone-work'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'sender-position'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'sender-postal-code'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'sender-state-or-province'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'sender-street'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'sender-title'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'sequence'):(
		(TEXTNS,u'formula'),
		(STYLENS,u'num-format'),
		(STYLENS,u'num-letter-sync'),
		(TEXTNS,u'name'),
		(TEXTNS,u'ref-name'),
	),
	(TEXTNS,u'sequence-decl'):(
		(TEXTNS,u'separation-character'),
		(TEXTNS,u'display-outline-level'),
		(TEXTNS,u'name'),
	),
	(TEXTNS,u'sequence-decls'):(
	),
	(TEXTNS,u'sequence-ref'):(
		(TEXTNS,u'ref-name'),
		(TEXTNS,u'reference-format'),
	),
	(TEXTNS,u'sheet-name'):(
	),
	(TEXTNS,u'soft-page-break'):(
	),
	(TEXTNS,u'sort-key'):(
		(TEXTNS,u'sort-ascending'),
		(TEXTNS,u'key'),
	),
# allowed_attributes
	(TEXTNS,u'span'):(
		(TEXTNS,u'style-name'),
		(TEXTNS,u'class-names'),
	),
	(TEXTNS,u'subject'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'tab'):(
		(TEXTNS,u'tab-ref'),
	),
	(TEXTNS,u'table-formula'):(
		(TEXTNS,u'formula'),
		(STYLENS,u'data-style-name'),
		(TEXTNS,u'display'),
	),
	(TEXTNS,u'table-index'):(
		(TEXTNS,u'protected'),
		(TEXTNS,u'style-name'),
		(TEXTNS,u'name'),
		(TEXTNS,u'protection-key'),
	),
	(TEXTNS,u'table-index-entry-template'):(
		(TEXTNS,u'style-name'),
	),
	(TEXTNS,u'table-index-source'):(
		(TEXTNS,u'index-scope'),
		(TEXTNS,u'caption-sequence-name'),
		(TEXTNS,u'use-caption'),
		(TEXTNS,u'caption-sequence-format'),
		(TEXTNS,u'relative-tab-stop-position'),
	),
# allowed_attributes
	(TEXTNS,u'table-of-content'):(
		(TEXTNS,u'protected'),
		(TEXTNS,u'style-name'),
		(TEXTNS,u'name'),
		(TEXTNS,u'protection-key'),
	),
	(TEXTNS,u'table-of-content-entry-template'):(
		(TEXTNS,u'style-name'),
		(TEXTNS,u'outline-level'),
	),
	(TEXTNS,u'table-of-content-source'):(
		(TEXTNS,u'index-scope'),
		(TEXTNS,u'outline-level'),
		(TEXTNS,u'relative-tab-stop-position'),
		(TEXTNS,u'use-index-marks'),
		(TEXTNS,u'use-outline-level'),
		(TEXTNS,u'use-index-source-styles'),
	),
	(TEXTNS,u'template-name'):(
		(TEXTNS,u'display'),
	),
	(TEXTNS,u'text-input'):(
		(TEXTNS,u'description'),
	),
	(TEXTNS,u'time'):(
		(TEXTNS,u'time-adjust'),
		(TEXTNS,u'fixed'),
		(TEXTNS,u'time-value'),
		(STYLENS,u'data-style-name'),
	),
	(TEXTNS,u'title'):(
		(TEXTNS,u'fixed'),
	),
	(TEXTNS,u'toc-mark'):(
		(TEXTNS,u'string-value'),
		(TEXTNS,u'outline-level'),
	),
	(TEXTNS,u'toc-mark-end'):(
		(TEXTNS,u'id'),
	),
	(TEXTNS,u'toc-mark-start'):(
		(TEXTNS,u'id'),
		(TEXTNS,u'outline-level'),
	),
	(TEXTNS,u'tracked-changes'):(
		(TEXTNS,u'track-changes'),
	),
	(TEXTNS,u'user-defined'):(
		(TEXTNS,u'name'),
		(OFFICENS,u'string-value'),
		(OFFICENS,u'value'),
		(OFFICENS,u'boolean-value'),
		(OFFICENS,u'date-value'),
		(STYLENS,u'data-style-name'),
		(TEXTNS,u'fixed'),
		(OFFICENS,u'time-value'),
	),
	(TEXTNS,u'user-field-decl'):(
		(TEXTNS,u'name'),
		(OFFICENS,u'string-value'),
		(OFFICENS,u'value'),
		(OFFICENS,u'boolean-value'),
		(OFFICENS,u'currency'),
		(OFFICENS,u'date-value'),
		(OFFICENS,u'value-type'),
		(TEXTNS,u'formula'),
		(OFFICENS,u'time-value'),
	),
	(TEXTNS,u'user-field-decls'):(
	),
	(TEXTNS,u'user-field-get'):(
		(STYLENS,u'data-style-name'),
		(TEXTNS,u'name'),
		(TEXTNS,u'display'),
	),
# allowed_attributes
	(TEXTNS,u'user-field-input'):(
		(STYLENS,u'data-style-name'),
		(TEXTNS,u'name'),
		(TEXTNS,u'description'),
	),
	(TEXTNS,u'user-index'):(
		(TEXTNS,u'protected'),
		(TEXTNS,u'style-name'),
		(TEXTNS,u'name'),
		(TEXTNS,u'protection-key'),
	),
	(TEXTNS,u'user-index-entry-template'):(
		(TEXTNS,u'style-name'),
		(TEXTNS,u'outline-level'),
	),
	(TEXTNS,u'user-index-mark'):(
		(TEXTNS,u'index-name'),
		(TEXTNS,u'string-value'),
		(TEXTNS,u'outline-level'),
	),
	(TEXTNS,u'user-index-mark-end'):(
		(TEXTNS,u'id'),
		(TEXTNS,u'outline-level'),
	),
	(TEXTNS,u'user-index-mark-start'):(
		(TEXTNS,u'index-name'),
		(TEXTNS,u'id'),
		(TEXTNS,u'outline-level'),
	),
# allowed_attributes
	(TEXTNS,u'user-index-source'):(
		(TEXTNS,u'copy-outline-levels'),
		(TEXTNS,u'index-name'),
		(TEXTNS,u'index-scope'),
		(TEXTNS,u'relative-tab-stop-position'),
		(TEXTNS,u'use-floating-frames'),
		(TEXTNS,u'use-graphics'),
		(TEXTNS,u'use-index-marks'),
		(TEXTNS,u'use-objects'),
		(TEXTNS,u'use-tables'),
	),
	(TEXTNS,u'variable-decl'):(
		(TEXTNS,u'name'),
		(OFFICENS,u'value-type'),
	),
	(TEXTNS,u'variable-decls'):(
	),
	(TEXTNS,u'variable-get'):(
		(STYLENS,u'data-style-name'),
		(TEXTNS,u'name'),
		(TEXTNS,u'display'),
	),
	(TEXTNS,u'variable-input'):(
		(STYLENS,u'data-style-name'),
		(TEXTNS,u'display'),
		(TEXTNS,u'name'),
		(OFFICENS,u'value-type'),
		(TEXTNS,u'description'),
	),
	(TEXTNS,u'variable-set'):(
		(TEXTNS,u'name'),
		(TEXTNS,u'display'),
		(OFFICENS,u'string-value'),
		(OFFICENS,u'value'),
		(OFFICENS,u'boolean-value'),
		(OFFICENS,u'currency'),
		(OFFICENS,u'date-value'),
		(STYLENS,u'data-style-name'),
		(OFFICENS,u'value-type'),
		(TEXTNS,u'formula'),
		(OFFICENS,u'time-value'),
	),
# allowed_attributes
}

########NEW FILE########
__FILENAME__ = load
#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2007-2008 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

# This script is to be embedded in opendocument.py later
# The purpose is to read an ODT/ODP/ODS file and create the datastructure
# in memory. The user should then be able to make operations and then save
# the structure again.

from xml.sax import make_parser,handler
from xml.sax.xmlreader import InputSource
import xml.sax.saxutils
from element import Element
from namespaces import OFFICENS
from cStringIO import StringIO

#
# Parse the XML files
#
class LoadParser(handler.ContentHandler):
    """ Extract headings from content.xml of an ODT file """
    triggers = (
       (OFFICENS, 'automatic-styles'), (OFFICENS, 'body'),
       (OFFICENS, 'font-face-decls'), (OFFICENS, 'master-styles'),
       (OFFICENS, 'meta'), (OFFICENS, 'scripts'),
       (OFFICENS, 'settings'), (OFFICENS, 'styles') )

    def __init__(self, document):
        self.doc = document
        self.data = []
        self.level = 0
        self.parse = False

    def characters(self, data):
        if self.parse == False:
            return
        self.data.append(data)

    def startElementNS(self, tag, qname, attrs):
        if tag in self.triggers:
            self.parse = True
        if self.doc._parsing != "styles.xml" and tag == (OFFICENS, 'font-face-decls'):
            self.parse = False
        if self.parse == False:
            return

        self.level = self.level + 1
        # Add any accumulated text content
        content = ''.join(self.data)
        if len(content.strip()) > 0:
            self.parent.addText(content, check_grammar=False)
            self.data = []
        # Create the element
        attrdict = {}
        for (att,value) in attrs.items():
            attrdict[att] = value
        try:
            e = Element(qname = tag, qattributes=attrdict, check_grammar=False)
            self.curr = e
        except AttributeError, v:
            print "Error: %s" % v

        if tag == (OFFICENS, 'automatic-styles'):
            e = self.doc.automaticstyles
        elif tag == (OFFICENS, 'body'):
            e = self.doc.body
        elif tag == (OFFICENS, 'master-styles'):
            e = self.doc.masterstyles
        elif tag == (OFFICENS, 'meta'):
            e = self.doc.meta
        elif tag == (OFFICENS,'scripts'):
            e = self.doc.scripts
        elif tag == (OFFICENS,'settings'):
            e = self.doc.settings
        elif tag == (OFFICENS,'styles'):
            e = self.doc.styles
        elif self.doc._parsing == "styles.xml" and tag == (OFFICENS, 'font-face-decls'):
            e = self.doc.fontfacedecls
        elif hasattr(self,'parent'):
            self.parent.addElement(e, check_grammar=False)
        self.parent = e


    def endElementNS(self, tag, qname):
        if self.parse == False:
            return
        self.level = self.level - 1
        str = ''.join(self.data)
        if len(str.strip()) > 0:
            self.curr.addText(str, check_grammar=False)
        self.data = []
        self.curr = self.curr.parentNode
        self.parent = self.curr
        if tag in self.triggers:
            self.parse = False

########NEW FILE########
__FILENAME__ = manifest
#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#
#

from namespaces import MANIFESTNS
from element import Element

# Autogenerated
def Manifest(**args):
    return Element(qname = (MANIFESTNS,'manifest'), **args)

def FileEntry(**args):
    return Element(qname = (MANIFESTNS,'file-entry'), **args)

def EncryptionData(**args):
    return Element(qname = (MANIFESTNS,'encryption-data'), **args)

def Algorithm(**args):
    return Element(qname = (MANIFESTNS,'algorithm'), **args)

def KeyDerivation(**args):
    return Element(qname = (MANIFESTNS,'key-derivation'), **args)


########NEW FILE########
__FILENAME__ = math
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import MATHNS
from element import Element

# ODF 1.0 section 12.5
# Mathematical content is represented by MathML 2.0

# Autogenerated
def Math(**args):
    return Element(qname = (MATHNS,'math'), **args)


########NEW FILE########
__FILENAME__ = meta
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import METANS
from element import Element

# Autogenerated
def AutoReload(**args):
    return Element(qname = (METANS,'auto-reload'), **args)

def CreationDate(**args):
    return Element(qname = (METANS,'creation-date'), **args)

def DateString(**args):
    return Element(qname = (METANS,'date-string'), **args)

def DocumentStatistic(**args):
    return Element(qname = (METANS,'document-statistic'), **args)

def EditingCycles(**args):
    return Element(qname = (METANS,'editing-cycles'), **args)

def EditingDuration(**args):
    return Element(qname = (METANS,'editing-duration'), **args)

def Generator(**args):
    return Element(qname = (METANS,'generator'), **args)

def HyperlinkBehaviour(**args):
    return Element(qname = (METANS,'hyperlink-behaviour'), **args)

def InitialCreator(**args):
    return Element(qname = (METANS,'initial-creator'), **args)

def Keyword(**args):
    return Element(qname = (METANS,'keyword'), **args)

def PrintDate(**args):
    return Element(qname = (METANS,'print-date'), **args)

def PrintedBy(**args):
    return Element(qname = (METANS,'printed-by'), **args)

def Template(**args):
    return Element(qname = (METANS,'template'), **args)

def UserDefined(**args):
    return Element(qname = (METANS,'user-defined'), **args)


########NEW FILE########
__FILENAME__ = namespaces
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2010 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#
TOOLSVERSION = u"ODFPY/0.9.3"

ANIMNS         = u"urn:oasis:names:tc:opendocument:xmlns:animation:1.0"
DBNS           = u"urn:oasis:names:tc:opendocument:xmlns:database:1.0"
CHARTNS        = u"urn:oasis:names:tc:opendocument:xmlns:chart:1.0"
CONFIGNS       = u"urn:oasis:names:tc:opendocument:xmlns:config:1.0"
#DBNS           = u"http://openoffice.org/2004/database"
DCNS           = u"http://purl.org/dc/elements/1.1/"
DOMNS          = u"http://www.w3.org/2001/xml-events"
DR3DNS         = u"urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0"
DRAWNS         = u"urn:oasis:names:tc:opendocument:xmlns:drawing:1.0"
FIELDNS        = u"urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0"
FONS           = u"urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0"
FORMNS         = u"urn:oasis:names:tc:opendocument:xmlns:form:1.0"
GRDDLNS        = u"http://www.w3.org/2003/g/data-view#"
KOFFICENS      = u"http://www.koffice.org/2005/"
MANIFESTNS     = u"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0"
MATHNS         = u"http://www.w3.org/1998/Math/MathML"
METANS         = u"urn:oasis:names:tc:opendocument:xmlns:meta:1.0"
NUMBERNS       = u"urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0"
OFFICENS       = u"urn:oasis:names:tc:opendocument:xmlns:office:1.0"
OFNS           = u"urn:oasis:names:tc:opendocument:xmlns:of:1.2"
OOONS          = u"http://openoffice.org/2004/office"
OOOWNS         = u"http://openoffice.org/2004/writer"
OOOCNS         = u"http://openoffice.org/2004/calc"
PRESENTATIONNS = u"urn:oasis:names:tc:opendocument:xmlns:presentation:1.0"
RDFANS         = u"http://docs.oasis-open.org/opendocument/meta/rdfa#"
RPTNS          = u"http://openoffice.org/2005/report"
SCRIPTNS       = u"urn:oasis:names:tc:opendocument:xmlns:script:1.0"
SMILNS         = u"urn:oasis:names:tc:opendocument:xmlns:smil-compatible:1.0"
STYLENS        = u"urn:oasis:names:tc:opendocument:xmlns:style:1.0"
SVGNS          = u"urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0"
TABLENS        = u"urn:oasis:names:tc:opendocument:xmlns:table:1.0"
TEXTNS         = u"urn:oasis:names:tc:opendocument:xmlns:text:1.0"
XFORMSNS       = u"http://www.w3.org/2002/xforms"
XLINKNS        = u"http://www.w3.org/1999/xlink"
XMLNS          = u"http://www.w3.org/XML/1998/namespace"
XSDNS          = u"http://www.w3.org/2001/XMLSchema"
XSINS          = u"http://www.w3.org/2001/XMLSchema-instance"

nsdict = {
   ANIMNS: u'anim',
   CHARTNS: u'chart',
   CONFIGNS: u'config',
   DBNS: u'db',
   DCNS: u'dc',
   DOMNS: u'dom',
   DR3DNS: u'dr3d',
   DRAWNS: u'draw',
   FIELDNS: u'field',
   FONS: u'fo',
   FORMNS: u'form',
   GRDDLNS: u'grddl',
   KOFFICENS: u'koffice',
   MANIFESTNS: u'manifest',
   MATHNS: u'math',
   METANS: u'meta',
   NUMBERNS: u'number',
   OFFICENS: u'office',
   OFNS: u'of',
   OOONS: u'ooo',
   OOOWNS: u'ooow',
   OOOCNS: u'oooc',
   PRESENTATIONNS: u'presentation',
   RDFANS: u'rdfa',
   RPTNS:  u'rpt',
   SCRIPTNS: u'script',
   SMILNS: u'smil',
   STYLENS: u'style',
   SVGNS: u'svg',
   TABLENS: u'table',
   TEXTNS: u'text',
   XFORMSNS: u'xforms',
   XLINKNS: u'xlink',
   XMLNS: u'xml',
   XSDNS: u'xsd',
   XSINS: u'xsi',
}

########NEW FILE########
__FILENAME__ = number
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import NUMBERNS
from element import Element
from style import StyleElement


# Autogenerated
def AmPm(**args):
    return Element(qname = (NUMBERNS,'am-pm'), **args)

def Boolean(**args):
    return Element(qname = (NUMBERNS,'boolean'), **args)

def BooleanStyle(**args):
    return StyleElement(qname = (NUMBERNS,'boolean-style'), **args)

def CurrencyStyle(**args):
    return StyleElement(qname = (NUMBERNS,'currency-style'), **args)

def CurrencySymbol(**args):
    return Element(qname = (NUMBERNS,'currency-symbol'), **args)

def DateStyle(**args):
    return StyleElement(qname = (NUMBERNS,'date-style'), **args)

def Day(**args):
    return Element(qname = (NUMBERNS,'day'), **args)

def DayOfWeek(**args):
    return Element(qname = (NUMBERNS,'day-of-week'), **args)

def EmbeddedText(**args):
    return Element(qname = (NUMBERNS,'embedded-text'), **args)

def Era(**args):
    return Element(qname = (NUMBERNS,'era'), **args)

def Fraction(**args):
    return Element(qname = (NUMBERNS,'fraction'), **args)

def Hours(**args):
    return Element(qname = (NUMBERNS,'hours'), **args)

def Minutes(**args):
    return Element(qname = (NUMBERNS,'minutes'), **args)

def Month(**args):
    return Element(qname = (NUMBERNS,'month'), **args)

def Number(**args):
    return Element(qname = (NUMBERNS,'number'), **args)

def NumberStyle(**args):
    return StyleElement(qname = (NUMBERNS,'number-style'), **args)

def PercentageStyle(**args):
    return StyleElement(qname = (NUMBERNS,'percentage-style'), **args)

def Quarter(**args):
    return Element(qname = (NUMBERNS,'quarter'), **args)

def ScientificNumber(**args):
    return Element(qname = (NUMBERNS,'scientific-number'), **args)

def Seconds(**args):
    return Element(qname = (NUMBERNS,'seconds'), **args)

def Text(**args):
    return Element(qname = (NUMBERNS,'text'), **args)

def TextContent(**args):
    return Element(qname = (NUMBERNS,'text-content'), **args)

def TextStyle(**args):
    return StyleElement(qname = (NUMBERNS,'text-style'), **args)

def TimeStyle(**args):
    return StyleElement(qname = (NUMBERNS,'time-style'), **args)

def WeekOfYear(**args):
    return Element(qname = (NUMBERNS,'week-of-year'), **args)

def Year(**args):
    return Element(qname = (NUMBERNS,'year'), **args)


########NEW FILE########
__FILENAME__ = odf2moinmoin
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2008 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# See http://trac.edgewall.org/wiki/WikiFormatting
#
# Contributor(s):
#

import sys, zipfile, xml.dom.minidom
from namespaces import nsdict
from elementtypes import *

IGNORED_TAGS = [
    'draw:a'
    'draw:g',
    'draw:line',
    'draw:object-ole',
    'office:annotation',
    'presentation:notes',
    'svg:desc',
] + [ nsdict[item[0]]+":"+item[1] for item in empty_elements]

INLINE_TAGS = [ nsdict[item[0]]+":"+item[1] for item in inline_elements]


class TextProps:
    """ Holds properties for a text style. """

    def __init__(self):

        self.italic = False
        self.bold = False
        self.fixed = False
        self.underlined = False
        self.strikethrough = False
        self.superscript = False
        self.subscript = False

    def setItalic(self, value):
        if value == "italic":
            self.italic = True
        elif value == "normal":
            self.italic = False

    def setBold(self, value):
        if value == "bold":
            self.bold = True
        elif value == "normal":
            self.bold = False

    def setFixed(self, value):
        self.fixed = value

    def setUnderlined(self, value):
        if value and value != "none":
            self.underlined = True

    def setStrikethrough(self, value):
        if value and value != "none":
            self.strikethrough = True

    def setPosition(self, value):
        if value is None or value == '':
            return
        posisize = value.split(' ')
        textpos = posisize[0]
        if textpos.find('%') == -1:
            if textpos == "sub":
                self.superscript = False
                self.subscript = True
            elif textpos == "super":
                self.superscript = True
                self.subscript = False
        else:
            itextpos = int(textpos[:textpos.find('%')])
            if itextpos > 10:
                self.superscript = False
                self.subscript = True
            elif itextpos < -10:
                self.superscript = True
                self.subscript = False

    def __str__(self):

        return "[italic=%s, bold=i%s, fixed=%s]" % (str(self.italic),
                                          str(self.bold),
                                          str(self.fixed))

class ParagraphProps:
    """ Holds properties of a paragraph style. """

    def __init__(self):

        self.blockquote = False
        self.headingLevel = 0
        self.code = False
        self.title = False
        self.indented = 0

    def setIndented(self, value):
        self.indented = value

    def setHeading(self, level):
        self.headingLevel = level

    def setTitle(self, value):
        self.title = value

    def setCode(self, value):
        self.code = value


    def __str__(self):

        return "[bq=%s, h=%d, code=%s]" % (str(self.blockquote),
                                           self.headingLevel,
                                           str(self.code))


class ListProperties:
    """ Holds properties for a list style. """

    def __init__(self):
        self.ordered = False

    def setOrdered(self, value):
        self.ordered = value



class ODF2MoinMoin(object):


    def __init__(self, filepath):
        self.footnotes = []
        self.footnoteCounter = 0
        self.textStyles = {"Standard": TextProps()}
        self.paragraphStyles = {"Standard": ParagraphProps()}
        self.listStyles = {}
        self.fixedFonts = []
        self.hasTitle = 0
        self.lastsegment = None

        # Tags
        self.elements = {
         'draw:page': self.textToString,
         'draw:frame': self.textToString,
         'draw:image': self.draw_image,
         'draw:text-box': self.textToString,
         'text:a': self.text_a,
         'text:note': self.text_note,
        }
        for tag in IGNORED_TAGS:
            self.elements[tag] = self.do_nothing

        for tag in INLINE_TAGS:
            self.elements[tag] = self.inline_markup
        self.elements['text:line-break'] = self.text_line_break
        self.elements['text:s'] = self.text_s
        self.elements['text:tab'] = self.text_tab

        self.load(filepath)

    def processFontDeclarations(self, fontDecl):
        """ Extracts necessary font information from a font-declaration
            element.
            """
        for fontFace in fontDecl.getElementsByTagName("style:font-face"):
            if fontFace.getAttribute("style:font-pitch") == "fixed":
                self.fixedFonts.append(fontFace.getAttribute("style:name"))



    def extractTextProperties(self, style, parent=None):
        """ Extracts text properties from a style element. """

        textProps = TextProps()

        if parent:
            parentProp = self.textStyles.get(parent, None)
            if parentProp:
                textProp = parentProp

        textPropEl = style.getElementsByTagName("style:text-properties")
        if not textPropEl: return textProps

        textPropEl = textPropEl[0]

        textProps.setItalic(textPropEl.getAttribute("fo:font-style"))
        textProps.setBold(textPropEl.getAttribute("fo:font-weight"))
        textProps.setUnderlined(textPropEl.getAttribute("style:text-underline-style"))
        textProps.setStrikethrough(textPropEl.getAttribute("style:text-line-through-style"))
        textProps.setPosition(textPropEl.getAttribute("style:text-position"))

        if textPropEl.getAttribute("style:font-name") in self.fixedFonts:
            textProps.setFixed(True)

        return textProps

    def extractParagraphProperties(self, style, parent=None):
        """ Extracts paragraph properties from a style element. """

        paraProps = ParagraphProps()

        name = style.getAttribute("style:name")

        if name.startswith("Heading_20_"):
            level = name[11:]
            try:
                level = int(level)
                paraProps.setHeading(level)
            except:
                level = 0

        if name == "Title":
            paraProps.setTitle(True)

        paraPropEl = style.getElementsByTagName("style:paragraph-properties")
        if paraPropEl:
            paraPropEl = paraPropEl[0]
            leftMargin = paraPropEl.getAttribute("fo:margin-left")
            if leftMargin:
                try:
                    leftMargin = float(leftMargin[:-2])
                    if leftMargin > 0.01:
                        paraProps.setIndented(True)
                except:
                    pass

        textProps = self.extractTextProperties(style)
        if textProps.fixed:
            paraProps.setCode(True)

        return paraProps


    def processStyles(self, styleElements):
        """ Runs through "style" elements extracting necessary information.
        """

        for style in styleElements:

            name = style.getAttribute("style:name")

            if name == "Standard": continue

            family = style.getAttribute("style:family")
            parent = style.getAttribute("style:parent-style-name")

            if family == "text":
                self.textStyles[name] = self.extractTextProperties(style, parent)

            elif family == "paragraph":
                self.paragraphStyles[name] = \
                                 self.extractParagraphProperties(style, parent)
                self.textStyles[name] = self.extractTextProperties(style, parent)

    def processListStyles(self, listStyleElements):

        for style in listStyleElements:
            name = style.getAttribute("style:name")

            prop = ListProperties()
            if style.hasChildNodes():
                subitems = [el for el in style.childNodes
                     if el.nodeType == xml.dom.Node.ELEMENT_NODE
                     and el.tagName == "text:list-level-style-number"]
                if len(subitems) > 0:
                    prop.setOrdered(True)

            self.listStyles[name] = prop


    def load(self, filepath):
        """ Loads an ODT file. """

        zip = zipfile.ZipFile(filepath)

        styles_doc = xml.dom.minidom.parseString(zip.read("styles.xml"))
        fontfacedecls = styles_doc.getElementsByTagName("office:font-face-decls")
        if fontfacedecls:
            self.processFontDeclarations(fontfacedecls[0])
        self.processStyles(styles_doc.getElementsByTagName("style:style"))
        self.processListStyles(styles_doc.getElementsByTagName("text:list-style"))

        self.content = xml.dom.minidom.parseString(zip.read("content.xml"))
        fontfacedecls = self.content.getElementsByTagName("office:font-face-decls")
        if fontfacedecls:
            self.processFontDeclarations(fontfacedecls[0])

        self.processStyles(self.content.getElementsByTagName("style:style"))
        self.processListStyles(self.content.getElementsByTagName("text:list-style"))

    def compressCodeBlocks(self, text):
        """ Removes extra blank lines from code blocks. """

        return text
        lines = text.split("\n")
        buffer = []
        numLines = len(lines)
        for i in range(numLines):

            if (lines[i].strip() or i == numLines-1  or i == 0 or
                not ( lines[i-1].startswith("    ")
                      and lines[i+1].startswith("    ") ) ):
                buffer.append("\n" + lines[i])

        return ''.join(buffer)

#-----------------------------------
    def do_nothing(self, node):
        return ''

    def draw_image(self, node):
        """
        """

        link = node.getAttribute("xlink:href")
        if link and link[:2] == './': # Indicates a sub-object, which isn't supported
            return "%s\n" % link
        if link and link[:9] == 'Pictures/':
            link = link[9:]
        return "[[Image(%s)]]\n" % link

    def text_a(self, node):
        text = self.textToString(node)
        link = node.getAttribute("xlink:href")
        if link.strip() == text.strip():
            return "[%s] " % link.strip()
        else:
            return "[%s %s] " % (link.strip(), text.strip())


    def text_line_break(self, node):
        return "[[BR]]"

    def text_note(self, node):
        cite = (node.getElementsByTagName("text:note-citation")[0]
                    .childNodes[0].nodeValue)
        body = (node.getElementsByTagName("text:note-body")[0]
                    .childNodes[0])
        self.footnotes.append((cite, self.textToString(body)))
        return "^%s^" % cite

    def text_s(self, node):
        try:
            num = int(node.getAttribute("text:c"))
            return " "*num
        except:
            return " "

    def text_tab(self, node):
        return "    "

    def inline_markup(self, node):
        text = self.textToString(node)

        if not text.strip():
            return ''  # don't apply styles to white space

        styleName = node.getAttribute("text:style-name")
        style = self.textStyles.get(styleName, TextProps())

        if style.fixed:
            return "`" + text + "`"

        mark = []
        if style:
            if style.italic:
                mark.append("''")
            if style.bold:
                mark.append("'''")
            if style.underlined:
                mark.append("__")
            if style.strikethrough:
                mark.append("~~")
            if style.superscript:
                mark.append("^")
            if style.subscript:
                mark.append(",,")
        revmark = mark[:]
        revmark.reverse()
        return "%s%s%s" % (''.join(mark), text, ''.join(revmark))

#-----------------------------------
    def listToString(self, listElement, indent = 0):

        self.lastsegment = listElement.tagName
        buffer = []

        styleName = listElement.getAttribute("text:style-name")
        props = self.listStyles.get(styleName, ListProperties())

        i = 0
        for item in listElement.childNodes:
            buffer.append(" "*indent)
            i += 1
            if props.ordered:
                number = str(i)
                number = " " + number + ". "
                buffer.append(" 1. ")
            else:
                buffer.append(" * ")
            subitems = [el for el in item.childNodes
                          if el.tagName in ["text:p", "text:h", "text:list"]]
            for subitem in subitems:
                if subitem.tagName == "text:list":
                    buffer.append("\n")
                    buffer.append(self.listToString(subitem, indent+3))
                else:
                    buffer.append(self.paragraphToString(subitem, indent+3))
                self.lastsegment = subitem.tagName
            self.lastsegment = item.tagName
            buffer.append("\n")

        return ''.join(buffer)

    def tableToString(self, tableElement):
        """ MoinMoin uses || to delimit table cells
        """

        self.lastsegment = tableElement.tagName
        buffer = []

        for item in tableElement.childNodes:
            self.lastsegment = item.tagName
            if item.tagName == "table:table-header-rows":
                buffer.append(self.tableToString(item))
            if item.tagName == "table:table-row":
                buffer.append("\n||")
                for cell in item.childNodes:
                    buffer.append(self.inline_markup(cell))
                    buffer.append("||")
                    self.lastsegment = cell.tagName
        return ''.join(buffer)


    def toString(self):
        """ Converts the document to a string.
            FIXME: Result from second call differs from first call
        """
        body = self.content.getElementsByTagName("office:body")[0]
        text = body.childNodes[0]

        buffer = []

        paragraphs = [el for el in text.childNodes
                      if el.tagName in ["draw:page", "text:p", "text:h","text:section",
                                        "text:list", "table:table"]]

        for paragraph in paragraphs:
            if paragraph.tagName == "text:list":
                text = self.listToString(paragraph)
            elif paragraph.tagName == "text:section":
                text = self.textToString(paragraph)
            elif paragraph.tagName == "table:table":
                text = self.tableToString(paragraph)
            else:
                text = self.paragraphToString(paragraph)
            if text:
                buffer.append(text)

        if self.footnotes:

            buffer.append("----")
            for cite, body in self.footnotes:
                buffer.append("%s: %s" % (cite, body))


        buffer.append("")
        return self.compressCodeBlocks('\n'.join(buffer))


    def textToString(self, element):

        buffer = []

        for node in element.childNodes:

            if node.nodeType == xml.dom.Node.TEXT_NODE:
                buffer.append(node.nodeValue)

            elif node.nodeType == xml.dom.Node.ELEMENT_NODE:
                tag = node.tagName

                if tag in ("draw:text-box", "draw:frame"):
                    buffer.append(self.textToString(node))

                elif tag in ("text:p", "text:h"):
                    text = self.paragraphToString(node)
                    if text:
                        buffer.append(text)
                elif tag == "text:list":
                    buffer.append(self.listToString(node))
                else:
                    method = self.elements.get(tag)
                    if method:
                        buffer.append(method(node))
                    else:
                        buffer.append(" {" + tag + "} ")

        return ''.join(buffer)

    def paragraphToString(self, paragraph, indent = 0):

        dummyParaProps = ParagraphProps()

        style_name = paragraph.getAttribute("text:style-name")
        paraProps = self.paragraphStyles.get(style_name, dummyParaProps)
        text = self.inline_markup(paragraph)

        if paraProps and not paraProps.code:
            text = text.strip()

        if paragraph.tagName == "text:p" and self.lastsegment == "text:p":
            text = "\n" + text

        self.lastsegment = paragraph.tagName

        if paraProps.title:
            self.hasTitle = 1
            return "= " + text + " =\n"

        outlinelevel = paragraph.getAttribute("text:outline-level")
        if outlinelevel:

            level = int(outlinelevel)
            if self.hasTitle: level += 1

            if level >= 1:
                return "=" * level + " " + text + " " + "=" * level + "\n"

        elif paraProps.code:
            return "{{{\n" + text + "\n}}}\n"

        if paraProps.indented:
            return self.wrapParagraph(text, indent = indent, blockquote = True)

        else:
            return self.wrapParagraph(text, indent = indent)


    def wrapParagraph(self, text, indent = 0, blockquote=False):

        counter = 0
        buffer = []
        LIMIT = 50

        if blockquote:
            buffer.append("  ")

        return ''.join(buffer) + text
        # Unused from here
        for token in text.split():

            if counter > LIMIT - indent:
                buffer.append("\n" + " "*indent)
                if blockquote:
                    buffer.append("  ")
                counter = 0

            buffer.append(token + " ")
            counter += len(token)

        return ''.join(buffer)

########NEW FILE########
__FILENAME__ = odf2xhtml
#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2010 Sren Roug, European Environment Agency
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#
#import pdb
#pdb.set_trace()
from xml.sax import handler
from xml.sax.saxutils import escape, quoteattr
from xml.dom import Node

from opendocument import load

from namespaces import ANIMNS, CHARTNS, CONFIGNS, DCNS, DR3DNS, DRAWNS, FONS, \
  FORMNS, MATHNS, METANS, NUMBERNS, OFFICENS, PRESENTATIONNS, SCRIPTNS, \
  SMILNS, STYLENS, SVGNS, TABLENS, TEXTNS, XLINKNS

# Handling of styles
#
# First there are font face declarations. These set up a font style that will be
# referenced from a text-property. The declaration describes the font making
# it possible for the application to find a similar font should the system not
# have that particular one. The StyleToCSS stores these attributes to be used
# for the CSS2 font declaration.
#
# Then there are default-styles. These set defaults for various style types:
#  "text", "paragraph", "section", "ruby", "table", "table-column", "table-row",
#  "table-cell", "graphic", "presentation", "drawing-page", "chart".
# Since CSS2 can't refer to another style, ODF2XHTML add these to all
# styles unless overridden.
#
# The real styles are declared in the <style:style> element. They have a
# family referring to the default-styles, and may have a parent style.
# 
# Styles have scope. The same name can be used for both paragraph and
# character etc. styles Since CSS2 has no scope we use a prefix. (Not elegant)
# In ODF a style can have a parent, these parents can be chained.

class StyleToCSS:
    """ The purpose of the StyleToCSS class is to contain the rules to convert
        ODF styles to CSS2. Since it needs the generic fonts, it would probably
        make sense to also contain the Styles in a dict as well..
    """

    def __init__(self):
        # Font declarations
        self.fontdict = {}

        # Fill-images from presentations for backgrounds
        self.fillimages = {}

        self.ruleconversions = {
            (DRAWNS,u'fill-image-name'): self.c_drawfillimage,
            (FONS,u"background-color"): self.c_fo,
            (FONS,u"border"): self.c_fo,
            (FONS,u"border-bottom"): self.c_fo,
            (FONS,u"border-left"): self.c_fo,
            (FONS,u"border-right"): self.c_fo,
            (FONS,u"border-top"): self.c_fo,
            (FONS,u"color"): self.c_fo,
            (FONS,u"font-family"): self.c_fo,
            (FONS,u"font-size"): self.c_fo,
            (FONS,u"font-style"): self.c_fo,
            (FONS,u"font-variant"): self.c_fo,
            (FONS,u"font-weight"): self.c_fo,
            (FONS,u"line-height"): self.c_fo,
            (FONS,u"margin"): self.c_fo,
            (FONS,u"margin-bottom"): self.c_fo,
            (FONS,u"margin-left"): self.c_fo,
            (FONS,u"margin-right"): self.c_fo,
            (FONS,u"margin-top"): self.c_fo,
            (FONS,u"min-height"): self.c_fo,
            (FONS,u"padding"): self.c_fo,
            (FONS,u"padding-bottom"): self.c_fo,
            (FONS,u"padding-left"): self.c_fo,
            (FONS,u"padding-right"): self.c_fo,
            (FONS,u"padding-top"): self.c_fo,
            (FONS,u"page-width"): self.c_page_width,
            (FONS,u"page-height"): self.c_page_height,
            (FONS,u"text-align"): self.c_text_align,
            (FONS,u"text-indent") :self.c_fo,
            (TABLENS,u'border-model') :self.c_border_model,
            (STYLENS,u'column-width') : self.c_width,
            (STYLENS,u"font-name"): self.c_fn,
            (STYLENS,u'horizontal-pos'): self.c_hp,
            (STYLENS,u'text-position'): self.c_text_position,
            (STYLENS,u'text-line-through-style'): self.c_text_line_through_style,
            (STYLENS,u'text-underline-style'): self.c_text_underline_style,
            (STYLENS,u'width') : self.c_width,
            # FIXME Should do style:vertical-pos here
        }

    def save_font(self, name, family, generic):
        """ It is possible that the HTML browser doesn't know how to
            show a particular font. Fortunately ODF provides generic fallbacks.
            Unfortunately they are not the same as CSS2.
            CSS2: serif, sans-serif, cursive, fantasy, monospace
            ODF: roman, swiss, modern, decorative, script, system
            This method put the font and fallback into a dictionary
        """
        htmlgeneric = "sans-serif"
        if   generic == "roman": htmlgeneric = "serif"
        elif generic == "swiss": htmlgeneric = "sans-serif"
        elif generic == "modern": htmlgeneric = "monospace"
        elif generic == "decorative": htmlgeneric = "sans-serif"
        elif generic == "script": htmlgeneric = "monospace"
        elif generic == "system": htmlgeneric = "serif"
        self.fontdict[name] = (family, htmlgeneric)

    def c_drawfillimage(self, ruleset, sdict, rule, val):
        """ Fill a figure with an image. Since CSS doesn't let you resize images
            this should really be implemented as an absolutely position <img>
            with a width and a height
        """
        sdict['background-image'] = "url('%s')" % self.fillimages[val]

    def c_fo(self, ruleset, sdict, rule, val):
        """ XSL formatting attributes """
        selector = rule[1]
        sdict[selector] = val

    def c_border_model(self, ruleset, sdict, rule, val):
        """ Convert to CSS2 border model """
        if val == 'collapsing':
            sdict['border-collapse'] ='collapse'
        else:
            sdict['border-collapse'] ='separate'

    def c_width(self, ruleset, sdict, rule, val):
        """ Set width of box """
        sdict['width'] = val

    def c_text_align(self, ruleset, sdict, rule, align):
        """ Text align """
        if align == "start": align = "left"
        if align == "end": align = "right"
        sdict['text-align'] = align

    def c_fn(self, ruleset, sdict, rule, fontstyle):
        """ Generate the CSS font family
            A generic font can be found in two ways. In a <style:font-face>
            element or as a font-family-generic attribute in text-properties.
        """
        generic = ruleset.get((STYLENS,'font-family-generic') )
        if generic is not None:
            self.save_font(fontstyle, fontstyle, generic)
        family, htmlgeneric = self.fontdict.get(fontstyle, (fontstyle, 'serif'))
        sdict['font-family'] = '%s, %s'  % (family, htmlgeneric)

    def c_text_position(self, ruleset, sdict, rule, tp):
        """ Text position. This is used e.g. to make superscript and subscript
            This attribute can have one or two values.

            The first value must be present and specifies the vertical
            text position as a percentage that relates to the current font
            height or it takes one of the values sub or super. Negative
            percentages or the sub value place the text below the
            baseline. Positive percentages or the super value place
            the text above the baseline. If sub or super is specified,
            the application can choose an appropriate text position.

            The second value is optional and specifies the font height
            as a percentage that relates to the current font-height. If
            this value is not specified, an appropriate font height is
            used. Although this value may change the font height that
            is displayed, it never changes the current font height that
            is used for additional calculations.
        """
        textpos = tp.split(' ')
        if len(textpos) == 2 and textpos[0] != "0%":
            # Bug in OpenOffice. If vertical-align is 0% - ignore the text size.
            sdict['font-size'] = textpos[1]
        if textpos[0] == "super":
            sdict['vertical-align'] = "33%"
        elif textpos[0] == "sub":
            sdict['vertical-align'] = "-33%"
        else:
            sdict['vertical-align'] = textpos[0]

    def c_hp(self, ruleset, sdict, rule, hpos):
        #FIXME: Frames wrap-style defaults to 'parallel', graphics to 'none'.
        # It is properly set in the parent-styles, but the program doesn't
        # collect the information.
        wrap = ruleset.get((STYLENS,'wrap'),'parallel')
        # Can have: from-left, left, center, right, from-inside, inside, outside
        if hpos == "center":
            sdict['margin-left'] = "auto"
            sdict['margin-right'] = "auto"
#       else:
#           # force it to be *something* then delete it
#           sdict['margin-left'] = sdict['margin-right'] = ''
#           del sdict['margin-left'], sdict['margin-right']

        if hpos in ("right","outside"):
            if wrap in ( "left", "parallel","dynamic"):
                sdict['float'] = "right"
            elif wrap == "run-through":
                sdict['position'] = "absolute" # Simulate run-through
                sdict['top'] = "0"
                sdict['right'] = "0";
            else: # No wrapping
                sdict['margin-left'] = "auto"
                sdict['margin-right'] = "0px"
        elif hpos in ("left", "inside"):
            if wrap in ( "right", "parallel","dynamic"):
                sdict['float'] = "left"
            elif wrap == "run-through":
                sdict['position'] = "absolute" # Simulate run-through
                sdict['top'] = "0"
                sdict['left'] = "0"
            else: # No wrapping
                sdict['margin-left'] = "0px"
                sdict['margin-right'] = "auto"
        elif hpos in ("from-left", "from-inside"):
            if wrap in ( "right", "parallel"):
                sdict['float'] = "left"
            else:
                sdict['position'] = "relative" # No wrapping
                if ruleset.has_key( (SVGNS,'x') ):
                    sdict['left'] = ruleset[(SVGNS,'x')]

    def c_page_width(self, ruleset, sdict, rule, val):
        """ Set width of box
            HTML doesn't really have a page-width. It is always 100% of the browser width
        """
        sdict['width'] = val

    def c_text_underline_style(self, ruleset, sdict, rule, val):
        """ Set underline decoration
            HTML doesn't really have a page-width. It is always 100% of the browser width
        """
        if val and val != "none":
            sdict['text-decoration'] = "underline"

    def c_text_line_through_style(self, ruleset, sdict, rule, val):
        """ Set underline decoration
            HTML doesn't really have a page-width. It is always 100% of the browser width
        """
        if val and val != "none":
            sdict['text-decoration'] = "line-through"

    def c_page_height(self, ruleset, sdict, rule, val):
        """ Set height of box """
        sdict['height'] = val

    def convert_styles(self, ruleset):
        """ Rule is a tuple of (namespace, name). If the namespace is '' then
            it is already CSS2
        """
        sdict = {}
        for rule,val in ruleset.items():
            if rule[0] == '':
                sdict[rule[1]] = val
                continue
            method = self.ruleconversions.get(rule, None )
            if method:
                method(ruleset, sdict, rule, val)
        return sdict


class TagStack:
    def __init__(self):
        self.stack = []

    def push(self, tag, attrs):
        self.stack.append( (tag, attrs) )

    def pop(self):
        item = self.stack.pop()
        return item

    def stackparent(self):
        item = self.stack[-1]
        return item[1]

    def rfindattr(self, attr):
        """ Find a tag with the given attribute """
        for tag, attrs in self.stack:
            if attrs.has_key(attr):
                return attrs[attr]
        return None
    def count_tags(self, tag):
        c = 0
        for ttag, tattrs in self.stack:
            if ttag == tag: c = c + 1
        return c

special_styles = {
   'S-Emphasis':'em',
   'S-Citation':'cite',
   'S-Strong_20_Emphasis':'strong',
   'S-Variable':'var',
   'S-Definition':'dfn',
   'S-Teletype':'tt',
   'P-Heading_20_1':'h1',
   'P-Heading_20_2':'h2',
   'P-Heading_20_3':'h3',
   'P-Heading_20_4':'h4',
   'P-Heading_20_5':'h5',
   'P-Heading_20_6':'h6',
#  'P-Caption':'caption',
   'P-Addressee':'address',
#  'P-List_20_Heading':'dt',
#  'P-List_20_Contents':'dd',
   'P-Preformatted_20_Text':'pre',
#  'P-Table_20_Heading':'th',
#  'P-Table_20_Contents':'td',
#  'P-Text_20_body':'p'
}

#-----------------------------------------------------------------------------
#
# ODFCONTENTHANDLER
#
#-----------------------------------------------------------------------------
class ODF2XHTML(handler.ContentHandler):
    """ The ODF2XHTML parses an ODF file and produces XHTML"""

    def __init__(self, generate_css=True, embedable=False):
        # Tags
        self.generate_css = generate_css
        self.elements = {
        (DCNS, 'title'): (self.s_processcont, self.e_dc_title),
        (DCNS, 'language'): (self.s_processcont, self.e_dc_contentlanguage),
        (DCNS, 'creator'): (self.s_processcont, self.e_dc_creator),
        (DCNS, 'description'): (self.s_processcont, self.e_dc_metatag),
        (DCNS, 'date'): (self.s_processcont, self.e_dc_metatag),
        (DRAWNS, 'custom-shape'): (self.s_custom_shape, self.e_custom_shape),
        (DRAWNS, 'frame'): (self.s_draw_frame, self.e_draw_frame),
        (DRAWNS, 'image'): (self.s_draw_image, None),
        (DRAWNS, 'fill-image'): (self.s_draw_fill_image, None),
        (DRAWNS, "layer-set"):(self.s_ignorexml, None),
        (DRAWNS, 'object'): (self.s_draw_object, None),
        (DRAWNS, 'object-ole'): (self.s_draw_object_ole, None),
        (DRAWNS, 'page'): (self.s_draw_page, self.e_draw_page),
        (DRAWNS, 'text-box'): (self.s_draw_textbox, self.e_draw_textbox),
        (METANS, 'creation-date'):(self.s_processcont, self.e_dc_metatag),
        (METANS, 'generator'):(self.s_processcont, self.e_dc_metatag),
        (METANS, 'initial-creator'): (self.s_processcont, self.e_dc_metatag),
        (METANS, 'keyword'): (self.s_processcont, self.e_dc_metatag),
        (NUMBERNS, "boolean-style"):(self.s_ignorexml, None),
        (NUMBERNS, "currency-style"):(self.s_ignorexml, None),
        (NUMBERNS, "date-style"):(self.s_ignorexml, None),
        (NUMBERNS, "number-style"):(self.s_ignorexml, None),
        (NUMBERNS, "text-style"):(self.s_ignorexml, None),
        (OFFICENS, "annotation"):(self.s_ignorexml, None),
        (OFFICENS, "automatic-styles"):(self.s_office_automatic_styles, None),
        (OFFICENS, "document"):(self.s_office_document_content, self.e_office_document_content),
        (OFFICENS, "document-content"):(self.s_office_document_content, self.e_office_document_content),
        (OFFICENS, "forms"):(self.s_ignorexml, None),
        (OFFICENS, "master-styles"):(self.s_office_master_styles, None),
        (OFFICENS, "meta"):(self.s_ignorecont, None),
        (OFFICENS, "presentation"):(self.s_office_presentation, self.e_office_presentation),
        (OFFICENS, "spreadsheet"):(self.s_office_spreadsheet, self.e_office_spreadsheet),
        (OFFICENS, "styles"):(self.s_office_styles, None),
        (OFFICENS, "text"):(self.s_office_text, self.e_office_text),
        (OFFICENS, "scripts"):(self.s_ignorexml, None),
        (OFFICENS, "settings"):(self.s_ignorexml, None),
        (PRESENTATIONNS, "notes"):(self.s_ignorexml, None),
#       (STYLENS, "default-page-layout"):(self.s_style_default_page_layout, self.e_style_page_layout),
        (STYLENS, "default-page-layout"):(self.s_ignorexml, None),
        (STYLENS, "default-style"):(self.s_style_default_style, self.e_style_default_style),
        (STYLENS, "drawing-page-properties"):(self.s_style_handle_properties, None),
        (STYLENS, "font-face"):(self.s_style_font_face, None),
#       (STYLENS, "footer"):(self.s_style_footer, self.e_style_footer),
#       (STYLENS, "footer-style"):(self.s_style_footer_style, None),
        (STYLENS, "graphic-properties"):(self.s_style_handle_properties, None),
        (STYLENS, "handout-master"):(self.s_ignorexml, None),
#       (STYLENS, "header"):(self.s_style_header, self.e_style_header),
#       (STYLENS, "header-footer-properties"):(self.s_style_handle_properties, None),
#       (STYLENS, "header-style"):(self.s_style_header_style, None),
        (STYLENS, "master-page"):(self.s_style_master_page, None),
        (STYLENS, "page-layout-properties"):(self.s_style_handle_properties, None),
        (STYLENS, "page-layout"):(self.s_style_page_layout, self.e_style_page_layout),
#       (STYLENS, "page-layout"):(self.s_ignorexml, None),
        (STYLENS, "paragraph-properties"):(self.s_style_handle_properties, None),
        (STYLENS, "style"):(self.s_style_style, self.e_style_style),
        (STYLENS, "table-cell-properties"):(self.s_style_handle_properties, None),
        (STYLENS, "table-column-properties"):(self.s_style_handle_properties, None),
        (STYLENS, "table-properties"):(self.s_style_handle_properties, None),
        (STYLENS, "text-properties"):(self.s_style_handle_properties, None),
        (SVGNS, 'desc'): (self.s_ignorexml, None),
        (TABLENS, 'covered-table-cell'): (self.s_ignorexml, None),
        (TABLENS, 'table-cell'): (self.s_table_table_cell, self.e_table_table_cell),
        (TABLENS, 'table-column'): (self.s_table_table_column, None),
        (TABLENS, 'table-row'): (self.s_table_table_row, self.e_table_table_row),
        (TABLENS, 'table'): (self.s_table_table, self.e_table_table),
        (TEXTNS, 'a'): (self.s_text_a, self.e_text_a),
        (TEXTNS, "alphabetical-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, "bibliography-configuration"):(self.s_ignorexml, None),
        (TEXTNS, "bibliography-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, 'bookmark'): (self.s_text_bookmark, None),
        (TEXTNS, 'bookmark-start'): (self.s_text_bookmark, None),
        (TEXTNS, 'bookmark-ref'): (self.s_text_bookmark_ref, self.e_text_a),
        (TEXTNS, 'bookmark-ref-start'): (self.s_text_bookmark_ref, None),
        (TEXTNS, 'h'): (self.s_text_h, self.e_text_h),
        (TEXTNS, "illustration-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, 'line-break'):(self.s_text_line_break, None),
        (TEXTNS, "linenumbering-configuration"):(self.s_ignorexml, None),
        (TEXTNS, "list"):(self.s_text_list, self.e_text_list),
        (TEXTNS, "list-item"):(self.s_text_list_item, self.e_text_list_item),
        (TEXTNS, "list-level-style-bullet"):(self.s_text_list_level_style_bullet, self.e_text_list_level_style_bullet),
        (TEXTNS, "list-level-style-number"):(self.s_text_list_level_style_number, self.e_text_list_level_style_number),
        (TEXTNS, "list-style"):(None, None),
        (TEXTNS, "note"):(self.s_text_note, None),
        (TEXTNS, "note-body"):(self.s_text_note_body, self.e_text_note_body),
        (TEXTNS, "note-citation"):(None, self.e_text_note_citation),
        (TEXTNS, "notes-configuration"):(self.s_ignorexml, None),
        (TEXTNS, "object-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, 'p'): (self.s_text_p, self.e_text_p),
        (TEXTNS, 's'): (self.s_text_s, None),
        (TEXTNS, 'span'): (self.s_text_span, self.e_text_span),
        (TEXTNS, 'tab'): (self.s_text_tab, None),
        (TEXTNS, "table-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, "table-of-content-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, "user-index-source"):(self.s_text_x_source, self.e_text_x_source),
        }
        if embedable:
            self.make_embedable()
        self._resetobject()

    def set_plain(self):
        """ Tell the parser to not generate CSS """
        self.generate_css = False

    def set_embedable(self):
        """ Tells the converter to only output the parts inside the <body>"""
        self.elements[(OFFICENS, u"text")] = (None,None)
        self.elements[(OFFICENS, u"spreadsheet")] = (None,None)
        self.elements[(OFFICENS, u"presentation")] = (None,None)
        self.elements[(OFFICENS, u"document-content")] = (None,None)


    def add_style_file(self, stylefilename, media=None):
        """ Add a link to an external style file.
            Also turns of the embedding of styles in the HTML
        """
        self.use_internal_css = False
        self.stylefilename = stylefilename
        if media:
            self.metatags.append('<link rel="stylesheet" type="text/css" href="%s" media="%s"/>\n' % (stylefilename,media))
        else:
            self.metatags.append('<link rel="stylesheet" type="text/css" href="%s"/>\n' % (stylefilename))

    def _resetfootnotes(self):
        # Footnotes and endnotes
        self.notedict = {}
        self.currentnote = 0
        self.notebody = ''

    def _resetobject(self):
        self.lines = []
        self._wfunc = self._wlines
        self.xmlfile = ''
        self.title = ''
        self.language = ''
        self.creator = ''
        self.data = []
        self.tagstack = TagStack()
        self.htmlstack = []
        self.pstack = []
        self.processelem = True
        self.processcont = True
        self.listtypes = {}
        self.headinglevels = [0, 0,0,0,0,0, 0,0,0,0,0] # level 0 to 10
        self.use_internal_css = True
        self.cs = StyleToCSS()
        self.anchors = {}

        # Style declarations
        self.stylestack = []
        self.styledict = {}
        self.currentstyle = None

        self._resetfootnotes()

        # Tags from meta.xml
        self.metatags = []


    def writeout(self, s):
        if s != '':
            self._wfunc(s)

    def writedata(self):
        d = ''.join(self.data)
        if d != '':
            self.writeout(escape(d))

    def opentag(self, tag, attrs={}, block=False):
        """ Create an open HTML tag """
        self.htmlstack.append((tag,attrs,block))
        a = []
        for key,val in attrs.items():
            a.append('''%s=%s''' % (key, quoteattr(val)))
        if len(a) == 0:
            self.writeout("<%s>" % tag)
        else:
            self.writeout("<%s %s>" % (tag, " ".join(a)))
        if block == True:
            self.writeout("\n")

    def closetag(self, tag, block=True):
        """ Close an open HTML tag """
        self.htmlstack.pop()
        self.writeout("</%s>" % tag)
        if block == True:
            self.writeout("\n")

    def emptytag(self, tag, attrs={}):
        a = []
        for key,val in attrs.items():
            a.append('''%s=%s''' % (key, quoteattr(val)))
        self.writeout("<%s %s/>\n" % (tag, " ".join(a)))

#--------------------------------------------------
# Interface to parser
#--------------------------------------------------
    def characters(self, data):
        if self.processelem and self.processcont:
            self.data.append(data)

    def startElementNS(self, tag, qname, attrs):
        self.pstack.append( (self.processelem, self.processcont) )
        if self.processelem:
            method = self.elements.get(tag, (None, None) )[0]
            if method:
                self.handle_starttag(tag, method, attrs)
            else:
                self.unknown_starttag(tag,attrs)
        self.tagstack.push( tag, attrs )

    def endElementNS(self, tag, qname):
        stag, attrs = self.tagstack.pop()
        if self.processelem:
            method = self.elements.get(tag, (None, None) )[1]
            if method:
                self.handle_endtag(tag, attrs, method)
            else:
                self.unknown_endtag(tag, attrs)
        self.processelem, self.processcont = self.pstack.pop()

#--------------------------------------------------
    def handle_starttag(self, tag, method, attrs):
        method(tag,attrs)

    def handle_endtag(self, tag, attrs, method):
        method(tag, attrs)

    def unknown_starttag(self, tag, attrs):
        pass

    def unknown_endtag(self, tag, attrs):
        pass

    def s_ignorexml(self, tag, attrs):
        """ Ignore this xml element and all children of it
            It will automatically stop ignoring
        """
        self.processelem = False

    def s_ignorecont(self, tag, attrs):
        """ Stop processing the text nodes """
        self.processcont = False

    def s_processcont(self, tag, attrs):
        """ Start processing the text nodes """
        self.processcont = True

    def classname(self, attrs):
        """ Generate a class name from a style name """
        c = attrs.get((TEXTNS,'style-name'),'')
        c = c.replace(".","_")
        return c

    def get_anchor(self, name):
        """ Create a unique anchor id for a href name """
        if not self.anchors.has_key(name):
            self.anchors[name] = "anchor%03d" % (len(self.anchors) + 1)
        return self.anchors.get(name)


#--------------------------------------------------

    def purgedata(self):
        self.data = []

#-----------------------------------------------------------------------------
#
# Handle meta data
#
#-----------------------------------------------------------------------------
    def e_dc_title(self, tag, attrs):
        """ Get the title from the meta data and create a HTML <title>
        """
        self.title = ''.join(self.data)
        #self.metatags.append('<title>%s</title>\n' % escape(self.title))
        self.data = []

    def e_dc_metatag(self, tag, attrs):
        """ Any other meta data is added as a <meta> element
        """
        self.metatags.append('<meta name="%s" content=%s/>\n' % (tag[1], quoteattr(''.join(self.data))))
        self.data = []

    def e_dc_contentlanguage(self, tag, attrs):
        """ Set the content language. Identifies the targeted audience
        """
        self.language = ''.join(self.data)
        self.metatags.append('<meta http-equiv="content-language" content="%s"/>\n' % escape(self.language))
        self.data = []

    def e_dc_creator(self, tag, attrs):
        """ Set the content creator. Identifies the targeted audience
        """
        self.creator = ''.join(self.data)
        self.metatags.append('<meta http-equiv="creator" content="%s"/>\n' % escape(self.creator))
        self.data = []

    def s_custom_shape(self, tag, attrs):
        """ A <draw:custom-shape> is made into a <div> in HTML which is then styled
        """
        anchor_type = attrs.get((TEXTNS,'anchor-type'),'notfound')
        htmltag = 'div'
        name = "G-" + attrs.get( (DRAWNS,'style-name'), "")
        if name == 'G-':
            name = "PR-" + attrs.get( (PRESENTATIONNS,'style-name'), "")
        name = name.replace(".","_")
        if anchor_type == "paragraph":
            style = 'position:absolute;'
        elif anchor_type == 'char':
            style = "position:absolute;"
        elif anchor_type == 'as-char':
            htmltag = 'div'
            style = ''
        else:
            style = "position: absolute;"
        if attrs.has_key( (SVGNS,"width") ):
            style = style + "width:" + attrs[(SVGNS,"width")] + ";"
        if attrs.has_key( (SVGNS,"height") ):
            style = style + "height:" +  attrs[(SVGNS,"height")] + ";"
        if attrs.has_key( (SVGNS,"x") ):
            style = style + "left:" +  attrs[(SVGNS,"x")] + ";"
        if attrs.has_key( (SVGNS,"y") ):
            style = style + "top:" +  attrs[(SVGNS,"y")] + ";"
        if self.generate_css:
            self.opentag(htmltag, {'class': name, 'style': style})
        else:
            self.opentag(htmltag)

    def e_custom_shape(self, tag, attrs):
        """ End the <draw:frame>
        """
        self.closetag('div')

    def s_draw_frame(self, tag, attrs):
        """ A <draw:frame> is made into a <div> in HTML which is then styled
        """
        anchor_type = attrs.get((TEXTNS,'anchor-type'),'notfound')
        htmltag = 'div'
        name = "G-" + attrs.get( (DRAWNS,'style-name'), "")
        if name == 'G-':
            name = "PR-" + attrs.get( (PRESENTATIONNS,'style-name'), "")
        name = name.replace(".","_")
        if anchor_type == "paragraph":
            style = 'position:relative;'
        elif anchor_type == 'char':
            style = "position:relative;"
        elif anchor_type == 'as-char':
            htmltag = 'div'
            style = ''
        else:
            style = "position:absolute;"
        if attrs.has_key( (SVGNS,"width") ):
            style = style + "width:" + attrs[(SVGNS,"width")] + ";"
        if attrs.has_key( (SVGNS,"height") ):
            style = style + "height:" +  attrs[(SVGNS,"height")] + ";"
        if attrs.has_key( (SVGNS,"x") ):
            style = style + "left:" +  attrs[(SVGNS,"x")] + ";"
        if attrs.has_key( (SVGNS,"y") ):
            style = style + "top:" +  attrs[(SVGNS,"y")] + ";"
        if self.generate_css:
            self.opentag(htmltag, {'class': name, 'style': style})
        else:
            self.opentag(htmltag)

    def e_draw_frame(self, tag, attrs):
        """ End the <draw:frame>
        """
        self.closetag('div')

    def s_draw_fill_image(self, tag, attrs):
        name = attrs.get( (DRAWNS,'name'), "NoName")
        imghref = attrs[(XLINKNS,"href")]
        imghref = self.rewritelink(imghref)
        self.cs.fillimages[name] = imghref

    def rewritelink(self, imghref):
        """ Intended to be overloaded if you don't store your pictures
            in a Pictures subfolder
        """
        return imghref

    def s_draw_image(self, tag, attrs):
        """ A <draw:image> becomes an <img/> element
        """
        parent = self.tagstack.stackparent()
        anchor_type = parent.get((TEXTNS,'anchor-type'))
        imghref = attrs[(XLINKNS,"href")]
        imghref = self.rewritelink(imghref)
        htmlattrs = {'alt':"", 'src':imghref }
        if self.generate_css:
            if anchor_type != "char":
                htmlattrs['style'] = "display: block;"
        self.emptytag('img', htmlattrs)

    def s_draw_object(self, tag, attrs):
        """ A <draw:object> is embedded object in the document (e.g. spreadsheet in presentation).
        """
        objhref = attrs[(XLINKNS,"href")]
        # Remove leading "./": from "./Object 1" to "Object 1"
#       objhref = objhref [2:]
       
        # Not using os.path.join since it fails to find the file on Windows.
#       objcontentpath = '/'.join([objhref, 'content.xml'])

        for c in self.document.childnodes:
            if c.folder == objhref:
                self._walknode(c.topnode)

    def s_draw_object_ole(self, tag, attrs):
        """ A <draw:object-ole> is embedded OLE object in the document (e.g. MS Graph).
        """
        class_id = attrs[(DRAWNS,"class-id")]
        if class_id and class_id.lower() == "00020803-0000-0000-c000-000000000046": ## Microsoft Graph 97 Chart
            tagattrs = { 'name':'object_ole_graph', 'class':'ole-graph' }
            self.opentag('a', tagattrs)
            self.closetag('a', tagattrs)

    def s_draw_page(self, tag, attrs):
        """ A <draw:page> is a slide in a presentation. We use a <fieldset> element in HTML.
            Therefore if you convert a ODP file, you get a series of <fieldset>s.
            Override this for your own purpose.
        """
        name = attrs.get( (DRAWNS,'name'), "NoName")
        stylename = attrs.get( (DRAWNS,'style-name'), "")
        stylename = stylename.replace(".","_")
        masterpage = attrs.get( (DRAWNS,'master-page-name'),"")
        masterpage = masterpage.replace(".","_")
        if self.generate_css:
            self.opentag('fieldset', {'class':"DP-%s MP-%s" % (stylename, masterpage) })
        else:
            self.opentag('fieldset')
        self.opentag('legend')
        self.writeout(escape(name))
        self.closetag('legend')

    def e_draw_page(self, tag, attrs):
        self.closetag('fieldset')

    def s_draw_textbox(self, tag, attrs):
        style = ''
        if attrs.has_key( (FONS,"min-height") ):
            style = style + "min-height:" +  attrs[(FONS,"min-height")] + ";"
        self.opentag('div')
#       self.opentag('div', {'style': style})

    def e_draw_textbox(self, tag, attrs):
        """ End the <draw:text-box>
        """
        self.closetag('div')

    def html_body(self, tag, attrs):
        self.writedata()
        if self.generate_css and self.use_internal_css:
            self.opentag('style', {'type':"text/css"}, True)
            self.writeout('/*<![CDATA[*/\n')
            self.generate_stylesheet()
            self.writeout('/*]]>*/\n')
            self.closetag('style')
        self.purgedata()
        self.closetag('head')
        self.opentag('body', block=True)

    default_styles = """
img { width: 100%; height: 100%; }
* { padding: 0; margin: 0;  background-color:white; }
body { margin: 0 1em; }
ol, ul { padding-left: 2em; }
"""

    def generate_stylesheet(self):
        for name in self.stylestack:
            styles = self.styledict.get(name)
            # Preload with the family's default style
            if styles.has_key('__style-family') and self.styledict.has_key(styles['__style-family']):
                familystyle = self.styledict[styles['__style-family']].copy()
                del styles['__style-family']
                for style, val in styles.items():
                    familystyle[style] = val
                styles = familystyle
            # Resolve the remaining parent styles
            while styles.has_key('__parent-style-name') and self.styledict.has_key(styles['__parent-style-name']):
                parentstyle = self.styledict[styles['__parent-style-name']].copy()
                del styles['__parent-style-name']
                for style, val in styles.items():
                    parentstyle[style] = val
                styles = parentstyle
            self.styledict[name] = styles
        # Write the styles to HTML
        self.writeout(self.default_styles)
        for name in self.stylestack:
            styles = self.styledict.get(name)
            css2 = self.cs.convert_styles(styles)
            self.writeout("%s {\n" % name)
            for style, val in css2.items():
                self.writeout("\t%s: %s;\n" % (style, val) )
            self.writeout("}\n")

    def generate_footnotes(self):
        if self.currentnote == 0:
            return
        if self.generate_css:
            self.opentag('ol', {'style':'border-top: 1px solid black'}, True)
        else:
            self.opentag('ol')
        for key in range(1,self.currentnote+1):
            note = self.notedict[key]
#       for key,note in self.notedict.items():
            self.opentag('li', { 'id':"footnote-%d" % key })
#           self.opentag('sup')
#           self.writeout(escape(note['citation']))
#           self.closetag('sup', False)
            self.writeout(note['body'])
            self.closetag('li')
        self.closetag('ol')

    def s_office_automatic_styles(self, tag, attrs):
        if self.xmlfile == 'styles.xml':
            self.autoprefix = "A"
        else:
            self.autoprefix = ""

    def s_office_document_content(self, tag, attrs):
        """ First tag in the content.xml file"""
        self.writeout('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" ')
        self.writeout('"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">\n')
        self.opentag('html', {'xmlns':"http://www.w3.org/1999/xhtml"}, True)
        self.opentag('head', block=True)
        self.emptytag('meta', { 'http-equiv':"Content-Type", 'content':"text/html;charset=UTF-8"})
        for metaline in self.metatags:
            self.writeout(metaline)
        self.writeout('<title>%s</title>\n' % escape(self.title))

    def e_office_document_content(self, tag, attrs):
        """ Last tag """
        self.closetag('html')

    def s_office_master_styles(self, tag, attrs):
        """ """

    def s_office_presentation(self, tag, attrs):
        """ For some odd reason, OpenOffice Impress doesn't define a default-style
            for the 'paragraph'. We therefore force a standard when we see
            it is a presentation
        """
        self.styledict['p'] = {(FONS,u'font-size'): u"24pt" }
        self.styledict['presentation'] = {(FONS,u'font-size'): u"24pt" }
        self.html_body(tag, attrs)

    def e_office_presentation(self, tag, attrs):
        self.generate_footnotes()
        self.closetag('body')

    def s_office_spreadsheet(self, tag, attrs):
        self.html_body(tag, attrs)

    def e_office_spreadsheet(self, tag, attrs):
        self.generate_footnotes()
        self.closetag('body')

    def s_office_styles(self, tag, attrs):
        self.autoprefix = ""

    def s_office_text(self, tag, attrs):
        """ OpenDocument text """
        self.styledict['frame'] = { (STYLENS,'wrap'): u'parallel'}
        self.html_body(tag, attrs)

    def e_office_text(self, tag, attrs):
        self.generate_footnotes()
        self.closetag('body')

    def s_style_handle_properties(self, tag, attrs):
        """ Copy all attributes to a struct.
            We will later convert them to CSS2
        """
        for key,attr in attrs.items():
            self.styledict[self.currentstyle][key] = attr


    familymap = {'frame':'frame', 'paragraph':'p', 'presentation':'presentation',
        'text':'span','section':'div',
        'table':'table','table-cell':'td','table-column':'col',
        'table-row':'tr','graphic':'graphic' }

    def s_style_default_style(self, tag, attrs):
        """ A default style is like a style on an HTML tag
        """
        family = attrs[(STYLENS,'family')]
        htmlfamily = self.familymap.get(family,'unknown')
        self.currentstyle = htmlfamily
#       self.stylestack.append(self.currentstyle)
        self.styledict[self.currentstyle] = {}

    def e_style_default_style(self, tag, attrs):
        self.currentstyle = None

    def s_style_font_face(self, tag, attrs):
        """ It is possible that the HTML browser doesn't know how to
            show a particular font. Luckily ODF provides generic fallbacks
            Unfortunately they are not the same as CSS2.
            CSS2: serif, sans-serif, cursive, fantasy, monospace
            ODF: roman, swiss, modern, decorative, script, system
        """
        name = attrs[(STYLENS,"name")]
        family = attrs[(SVGNS,"font-family")]
        generic = attrs.get( (STYLENS,'font-family-generic'),"" )
        self.cs.save_font(name, family, generic)

    def s_style_footer(self, tag, attrs):
        self.opentag('div', { 'id':"footer" })
        self.purgedata()

    def e_style_footer(self, tag, attrs):
        self.writedata()
        self.closetag('div')
        self.purgedata()

    def s_style_footer_style(self, tag, attrs):
        self.currentstyle = "@print #footer"
        self.stylestack.append(self.currentstyle)
        self.styledict[self.currentstyle] = {}

    def s_style_header(self, tag, attrs):
        self.opentag('div', { 'id':"header" })
        self.purgedata()

    def e_style_header(self, tag, attrs):
        self.writedata()
        self.closetag('div')
        self.purgedata()

    def s_style_header_style(self, tag, attrs):
        self.currentstyle = "@print #header"
        self.stylestack.append(self.currentstyle)
        self.styledict[self.currentstyle] = {}

    def s_style_default_page_layout(self, tag, attrs):
        """ Collect the formatting for the default page layout style.
        """
        self.currentstyle = "@page"
        self.stylestack.append(self.currentstyle)
        self.styledict[self.currentstyle] = {}

    def s_style_page_layout(self, tag, attrs):
        """ Collect the formatting for the page layout style.
            This won't work in CSS 2.1, as page identifiers are not allowed.
            It is legal in CSS3, but the rest of the application doesn't specify when to use what page layout
        """
        name = attrs[(STYLENS,'name')]
        name = name.replace(".","_")
        self.currentstyle = ".PL-" + name
        self.stylestack.append(self.currentstyle)
        self.styledict[self.currentstyle] = {}

    def e_style_page_layout(self, tag, attrs):
        """ End this style
        """
        self.currentstyle = None

    def s_style_master_page(self, tag, attrs):
        """ Collect the formatting for the page layout style.
        """
        name = attrs[(STYLENS,'name')]
        name = name.replace(".","_")

        self.currentstyle = ".MP-" + name
        self.stylestack.append(self.currentstyle)
        self.styledict[self.currentstyle] = {('','position'):'relative'}
        # Then load the pagelayout style if we find it
        pagelayout = attrs.get( (STYLENS,'page-layout-name'), None)
        if pagelayout:
            pagelayout = ".PL-" + pagelayout
            if self.styledict.has_key( pagelayout ):
                styles = self.styledict[pagelayout]
                for style, val in styles.items():
                    self.styledict[self.currentstyle][style] = val
            else:
                self.styledict[self.currentstyle]['__parent-style-name'] = pagelayout
        self.s_ignorexml(tag, attrs)

    # Short prefixes for class selectors
    _familyshort = {'drawing-page':'DP', 'paragraph':'P', 'presentation':'PR',
        'text':'S', 'section':'D',
         'table':'T', 'table-cell':'TD', 'table-column':'TC',
         'table-row':'TR', 'graphic':'G' }

    def s_style_style(self, tag, attrs):
        """ Collect the formatting for the style.
            Styles have scope. The same name can be used for both paragraph and
            character styles Since CSS has no scope we use a prefix. (Not elegant)
            In ODF a style can have a parent, these parents can be chained.
            We may not have encountered the parent yet, but if we have, we resolve it.
        """
        name = attrs[(STYLENS,'name')]
        name = name.replace(".","_")
        family = attrs[(STYLENS,'family')]
        htmlfamily = self.familymap.get(family,'unknown')
        sfamily = self._familyshort.get(family,'X')
        name = "%s%s-%s" % (self.autoprefix, sfamily, name)
        parent = attrs.get( (STYLENS,'parent-style-name') )
        self.currentstyle = special_styles.get(name,"."+name)
        self.stylestack.append(self.currentstyle)
        if not self.styledict.has_key(self.currentstyle):
            self.styledict[self.currentstyle] = {}

        self.styledict[self.currentstyle]['__style-family'] = htmlfamily

        # Then load the parent style if we find it
        if parent:
            parent = "%s-%s" % (sfamily, parent)
            parent = special_styles.get(parent, "."+parent)
            if self.styledict.has_key( parent ):
                styles = self.styledict[parent]
                for style, val in styles.items():
                    self.styledict[self.currentstyle][style] = val
            else:
                self.styledict[self.currentstyle]['__parent-style-name'] = parent

    def e_style_style(self, tag, attrs):
        """ End this style
        """
        self.currentstyle = None

    def s_table_table(self, tag, attrs):
        """ Start a table
        """
        c = attrs.get( (TABLENS,'style-name'), None)
        if c and self.generate_css:
            c = c.replace(".","_")
            self.opentag('table',{ 'class': "T-%s" % c })
        else:
            self.opentag('table')
        self.purgedata()

    def e_table_table(self, tag, attrs):
        """ End a table
        """
        self.writedata()
        self.closetag('table')
        self.purgedata()

    def s_table_table_cell(self, tag, attrs):
        """ Start a table cell """
        #FIXME: number-columns-repeated  8.1.3
        #repeated = int(attrs.get( (TABLENS,'number-columns-repeated'), 1))
        htmlattrs = {}
        rowspan = attrs.get( (TABLENS,'number-rows-spanned') )
        if rowspan:
            htmlattrs['rowspan'] = rowspan
        colspan = attrs.get( (TABLENS,'number-columns-spanned') )
        if colspan:
            htmlattrs['colspan'] = colspan

        c = attrs.get( (TABLENS,'style-name') )
        if c:
            htmlattrs['class'] = 'TD-%s' % c.replace(".","_")
        self.opentag('td', htmlattrs)
        self.purgedata()

    def e_table_table_cell(self, tag, attrs):
        """ End a table cell """
        self.writedata()
        self.closetag('td')
        self.purgedata()

    def s_table_table_column(self, tag, attrs):
        """ Start a table column """
        c = attrs.get( (TABLENS,'style-name'), None)
        repeated = int(attrs.get( (TABLENS,'number-columns-repeated'), 1))
        htmlattrs = {}
        if c:
            htmlattrs['class'] = "TC-%s" % c.replace(".","_")
        for x in xrange(repeated):
            self.emptytag('col', htmlattrs)
        self.purgedata()

    def s_table_table_row(self, tag, attrs):
        """ Start a table row """
        #FIXME: table:number-rows-repeated
        c = attrs.get( (TABLENS,'style-name'), None)
        htmlattrs = {}
        if c:
            htmlattrs['class'] = "TR-%s" % c.replace(".","_")
        self.opentag('tr', htmlattrs)
        self.purgedata()

    def e_table_table_row(self, tag, attrs):
        """ End a table row """
        self.writedata()
        self.closetag('tr')
        self.purgedata()

    def s_text_a(self, tag, attrs):
        """ Anchors start """
        self.writedata()
        href = attrs[(XLINKNS,"href")].split("|")[0]
        if href[0] == "#":
            href = "#" + self.get_anchor(href[1:])
        self.opentag('a', {'href':href})
        self.purgedata()

    def e_text_a(self, tag, attrs):
        """ End an anchor or bookmark reference """
        self.writedata()
        self.closetag('a', False)
        self.purgedata()

    def s_text_bookmark(self, tag, attrs):
        """ Bookmark definition """
        name = attrs[(TEXTNS,'name')]
        html_id = self.get_anchor(name)
        self.writedata()
        self.opentag('span', {'id':html_id})
        self.closetag('span', False)
        self.purgedata()

    def s_text_bookmark_ref(self, tag, attrs):
        """ Bookmark reference """
        name = attrs[(TEXTNS,'ref-name')]
        html_id = "#" + self.get_anchor(name)
        self.writedata()
        self.opentag('a', {'href':html_id})
        self.purgedata()

    def s_text_h(self, tag, attrs):
        """ Headings start """
        level = int(attrs[(TEXTNS,'outline-level')])
        if level > 6: level = 6 # Heading levels go only to 6 in XHTML
        if level < 1: level = 1
        self.headinglevels[level] = self.headinglevels[level] + 1
        name = self.classname(attrs)
        for x in range(level + 1,10):
            self.headinglevels[x] = 0
        special = special_styles.get("P-"+name)
        if special or not self.generate_css:
            self.opentag('h%s' % level)
        else:
            self.opentag('h%s' % level, {'class':"P-%s" % name })
        self.purgedata()

    def e_text_h(self, tag, attrs):
        """ Headings end
            Side-effect: If there is no title in the metadata, then it is taken
            from the first heading of any level.
        """
        self.writedata()
        level = int(attrs[(TEXTNS,'outline-level')])
        if level > 6: level = 6 # Heading levels go only to 6 in XHTML
        if level < 1: level = 1
        lev = self.headinglevels[1:level+1]
        outline = '.'.join(map(str,lev) )
        heading = ''.join(self.data)
        if self.title == '': self.title = heading
        anchor = self.get_anchor("%s.%s" % ( outline, heading))
        self.opentag('a', {'id': anchor} )
        self.closetag('a', False)
        self.closetag('h%s' % level)
        self.purgedata()

    def s_text_line_break(self, tag, attrs):
        """ Force a line break (<br/>) """
        self.writedata()
        self.emptytag('br')
        self.purgedata()

    def s_text_list(self, tag, attrs):
        """ Start a list (<ul> or <ol>)
            To know which level we're at, we have to count the number
            of <text:list> elements on the tagstack.
        """
        name = attrs.get( (TEXTNS,'style-name') )
        level = self.tagstack.count_tags(tag) + 1
        if name:
            name = name.replace(".","_")
        else:
            # FIXME: If a list is contained in a table cell or text box,
            # the list level must return to 1, even though the table or
            # textbox itself may be nested within another list.
            name = self.tagstack.rfindattr( (TEXTNS,'style-name') )
        list_class = "%s_%d" % (name, level)
        if self.generate_css:
            self.opentag('%s' % self.listtypes.get(list_class,'ul'), {'class': list_class })
        else:
            self.opentag('%s' % self.listtypes.get(list_class,'ul'))
        self.purgedata()

    def e_text_list(self, tag, attrs):
        """ End a list """
        self.writedata()
        name = attrs.get( (TEXTNS,'style-name') )
        level = self.tagstack.count_tags(tag) + 1
        if name:
            name = name.replace(".","_")
        else:
            # FIXME: If a list is contained in a table cell or text box,
            # the list level must return to 1, even though the table or
            # textbox itself may be nested within another list.
            name = self.tagstack.rfindattr( (TEXTNS,'style-name') )
        list_class = "%s_%d" % (name, level)
        self.closetag(self.listtypes.get(list_class,'ul'))
        self.purgedata()

    def s_text_list_item(self, tag, attrs):
        """ Start list item """
        self.opentag('li')
        self.purgedata()

    def e_text_list_item(self, tag, attrs):
        """ End list item """
        self.writedata()
        self.closetag('li')
        self.purgedata()

    def s_text_list_level_style_bullet(self, tag, attrs):
        """ CSS doesn't have the ability to set the glyph
            to a particular character, so we just go through
            the available glyphs
        """
        name = self.tagstack.rfindattr( (STYLENS,'name') )
        level = attrs[(TEXTNS,'level')]
        self.prevstyle = self.currentstyle
        list_class = "%s_%s" % (name, level)
        self.listtypes[list_class] = 'ul'
        self.currentstyle = ".%s_%s" % ( name.replace(".","_"), level)
        self.stylestack.append(self.currentstyle)
        self.styledict[self.currentstyle] = {}

        level = int(level)
        listtype = ("square", "disc", "circle")[level % 3]
        self.styledict[self.currentstyle][('','list-style-type')] = listtype

    def e_text_list_level_style_bullet(self, tag, attrs):
        self.currentstyle = self.prevstyle
        del self.prevstyle

    def s_text_list_level_style_number(self, tag, attrs):
        name = self.tagstack.stackparent()[(STYLENS,'name')]
        level = attrs[(TEXTNS,'level')]
        num_format = attrs.get( (STYLENS,'name'),"1")
        list_class = "%s_%s" % (name, level)
        self.prevstyle = self.currentstyle
        self.currentstyle = ".%s_%s" % ( name.replace(".","_"), level)
        self.listtypes[list_class] = 'ol'
        self.stylestack.append(self.currentstyle)
        self.styledict[self.currentstyle] = {}
        if   num_format == "1": listtype = "decimal"
        elif num_format == "I": listtype = "upper-roman"
        elif num_format == "i": listtype = "lower-roman"
        elif num_format == "A": listtype = "upper-alpha"
        elif num_format == "a": listtype = "lower-alpha"
        else: listtype = "decimal"
        self.styledict[self.currentstyle][('','list-style-type')] = listtype

    def e_text_list_level_style_number(self, tag, attrs):
        self.currentstyle = self.prevstyle
        del self.prevstyle

    def s_text_note(self, tag, attrs):
        self.writedata()
        self.purgedata()
        self.currentnote = self.currentnote + 1
        self.notedict[self.currentnote] = {}
        self.notebody = []

    def e_text_note(self, tag, attrs):
        pass

    def collectnote(self,s):
        if s != '':
            self.notebody.append(s)

    def s_text_note_body(self, tag, attrs):
        self._orgwfunc = self._wfunc
        self._wfunc = self.collectnote

    def e_text_note_body(self, tag, attrs):
        self._wfunc = self._orgwfunc
        self.notedict[self.currentnote]['body'] = ''.join(self.notebody)
        self.notebody = ''
        del self._orgwfunc

    def e_text_note_citation(self, tag, attrs):
        mark = ''.join(self.data)
        self.notedict[self.currentnote]['citation'] = mark
        self.opentag('a',{ 'href': "#footnote-%s" % self.currentnote })
        self.opentag('sup')
#        self.writeout( escape(mark) )
        # Since HTML only knows about endnotes, there is too much risk that the
        # marker is reused in the source. Therefore we force numeric markers
        self.writeout(unicode(self.currentnote))
        self.closetag('sup')
        self.closetag('a')

    def s_text_p(self, tag, attrs):
        """ Paragraph
        """
        htmlattrs = {}
        specialtag = "p"
        c = attrs.get( (TEXTNS,'style-name'), None)
        if c:
            c = c.replace(".","_")
            specialtag = special_styles.get("P-"+c)
            if specialtag is None:
                specialtag = 'p'
                if self.generate_css:
                    htmlattrs['class'] = "P-%s" % c
        self.opentag(specialtag, htmlattrs)
        self.purgedata()

    def e_text_p(self, tag, attrs):
        """ End Paragraph
        """
        specialtag = "p"
        c = attrs.get( (TEXTNS,'style-name'), None)
        if c:
            c = c.replace(".","_")
            specialtag = special_styles.get("P-"+c)
            if specialtag is None:
                specialtag = 'p'
        self.writedata()
        self.closetag(specialtag)
        self.purgedata()

    def s_text_s(self, tag, attrs):
        """ Generate a number of spaces. ODF has an element; HTML uses &nbsp;
            We use &#160; so we can send the output through an XML parser if we desire to
        """
        c = attrs.get( (TEXTNS,'c'),"1")
        for x in xrange(int(c)):
            self.writeout('&#160;')

    def s_text_span(self, tag, attrs):
        """ The <text:span> element matches the <span> element in HTML. It is
            typically used to properties of the text.
        """
        self.writedata()
        c = attrs.get( (TEXTNS,'style-name'), None)
        htmlattrs = {}
        if c:
            c = c.replace(".","_")
            special = special_styles.get("S-"+c)
            if special is None and self.generate_css:
                htmlattrs['class'] = "S-%s" % c
        self.opentag('span', htmlattrs)
        self.purgedata()

    def e_text_span(self, tag, attrs):
        """ End the <text:span> """
        self.writedata()
        self.closetag('span', False)
        self.purgedata()

    def s_text_tab(self, tag, attrs):
        """ Move to the next tabstop. We ignore this in HTML
        """
        self.writedata()
        self.writeout(' ')
        self.purgedata()

    def s_text_x_source(self, tag, attrs):
        """ Various indexes and tables of contents. We ignore those.
        """
        self.writedata()
        self.purgedata()
        self.s_ignorexml(tag, attrs)

    def e_text_x_source(self, tag, attrs):
        """ Various indexes and tables of contents. We ignore those.
        """
        self.writedata()
        self.purgedata()


#-----------------------------------------------------------------------------
#
# Reading the file
#
#-----------------------------------------------------------------------------

    def load(self, odffile):
        """ Loads a document into the parser and parses it.
            The argument can either be a filename or a document in memory.
        """
        self.lines = []
        self._wfunc = self._wlines
        if isinstance(odffile, basestring):
            self.document = load(odffile)
        else:
            self.document = odffile
        self._walknode(self.document.topnode)

    def _walknode(self, node):
        if node.nodeType == Node.ELEMENT_NODE:
            self.startElementNS(node.qname, node.tagName, node.attributes)
            for c in node.childNodes:
                self._walknode(c)
            self.endElementNS(node.qname, node.tagName)
        if node.nodeType == Node.TEXT_NODE or node.nodeType == Node.CDATA_SECTION_NODE:
            self.characters(unicode(node))


    def odf2xhtml(self, odffile):
        """ Load a file and return the XHTML
        """
        self.load(odffile)
        return self.xhtml()

    def _wlines(self,s):
        if s != '': self.lines.append(s)

    def xhtml(self):
        """ Returns the xhtml
        """
        return ''.join(self.lines)

    def _writecss(self, s):
        if s != '': self._csslines.append(s)

    def _writenothing(self, s):
        pass

    def css(self):
        """ Returns the CSS content """
        self._csslines = []
        self._wfunc = self._writecss
        self.generate_stylesheet()
        res = ''.join(self._csslines)
        self._wfunc = self._wlines
        del self._csslines
        return res

    def save(self, outputfile, addsuffix=False):
        """ Save the HTML under the filename.
            If the filename is '-' then save to stdout
            We have the last style filename in self.stylefilename
        """
        if outputfile == '-':
            outputfp = sys.stdout
        else:
            if addsuffix:
                outputfile = outputfile + ".html"
            outputfp = file(outputfile, "w")
        outputfp.write(self.xhtml().encode('us-ascii','xmlcharrefreplace'))
        outputfp.close()


class ODF2XHTMLembedded(ODF2XHTML):
    """ The ODF2XHTML parses an ODF file and produces XHTML"""

    def __init__(self, lines, generate_css=True, embedable=False):
        self._resetobject()
        self.lines = lines

        # Tags
        self.generate_css = generate_css
        self.elements = {
#        (DCNS, 'title'): (self.s_processcont, self.e_dc_title),
#        (DCNS, 'language'): (self.s_processcont, self.e_dc_contentlanguage),
#        (DCNS, 'creator'): (self.s_processcont, self.e_dc_metatag),
#        (DCNS, 'description'): (self.s_processcont, self.e_dc_metatag),
#        (DCNS, 'date'): (self.s_processcont, self.e_dc_metatag),
        (DRAWNS, 'frame'): (self.s_draw_frame, self.e_draw_frame),
        (DRAWNS, 'image'): (self.s_draw_image, None),
        (DRAWNS, 'fill-image'): (self.s_draw_fill_image, None),
        (DRAWNS, "layer-set"):(self.s_ignorexml, None),
        (DRAWNS, 'page'): (self.s_draw_page, self.e_draw_page),
        (DRAWNS, 'object'): (self.s_draw_object, None),
        (DRAWNS, 'object-ole'): (self.s_draw_object_ole, None),
        (DRAWNS, 'text-box'): (self.s_draw_textbox, self.e_draw_textbox),
#        (METANS, 'creation-date'):(self.s_processcont, self.e_dc_metatag),
#        (METANS, 'generator'):(self.s_processcont, self.e_dc_metatag),
#        (METANS, 'initial-creator'): (self.s_processcont, self.e_dc_metatag),
#        (METANS, 'keyword'): (self.s_processcont, self.e_dc_metatag),
        (NUMBERNS, "boolean-style"):(self.s_ignorexml, None),
        (NUMBERNS, "currency-style"):(self.s_ignorexml, None),
        (NUMBERNS, "date-style"):(self.s_ignorexml, None),
        (NUMBERNS, "number-style"):(self.s_ignorexml, None),
        (NUMBERNS, "text-style"):(self.s_ignorexml, None),
#        (OFFICENS, "automatic-styles"):(self.s_office_automatic_styles, None),
#        (OFFICENS, "document-content"):(self.s_office_document_content, self.e_office_document_content),
        (OFFICENS, "forms"):(self.s_ignorexml, None),
#        (OFFICENS, "master-styles"):(self.s_office_master_styles, None),
        (OFFICENS, "meta"):(self.s_ignorecont, None),
#        (OFFICENS, "presentation"):(self.s_office_presentation, self.e_office_presentation),
#        (OFFICENS, "spreadsheet"):(self.s_office_spreadsheet, self.e_office_spreadsheet),
#        (OFFICENS, "styles"):(self.s_office_styles, None),
#        (OFFICENS, "text"):(self.s_office_text, self.e_office_text),
        (OFFICENS, "scripts"):(self.s_ignorexml, None),
        (PRESENTATIONNS, "notes"):(self.s_ignorexml, None),
##       (STYLENS, "default-page-layout"):(self.s_style_default_page_layout, self.e_style_page_layout),
#        (STYLENS, "default-page-layout"):(self.s_ignorexml, None),
#        (STYLENS, "default-style"):(self.s_style_default_style, self.e_style_default_style),
#        (STYLENS, "drawing-page-properties"):(self.s_style_handle_properties, None),
#        (STYLENS, "font-face"):(self.s_style_font_face, None),
##       (STYLENS, "footer"):(self.s_style_footer, self.e_style_footer),
##       (STYLENS, "footer-style"):(self.s_style_footer_style, None),
#        (STYLENS, "graphic-properties"):(self.s_style_handle_properties, None),
#        (STYLENS, "handout-master"):(self.s_ignorexml, None),
##       (STYLENS, "header"):(self.s_style_header, self.e_style_header),
##       (STYLENS, "header-footer-properties"):(self.s_style_handle_properties, None),
##       (STYLENS, "header-style"):(self.s_style_header_style, None),
#        (STYLENS, "master-page"):(self.s_style_master_page, None),
#        (STYLENS, "page-layout-properties"):(self.s_style_handle_properties, None),
##       (STYLENS, "page-layout"):(self.s_style_page_layout, self.e_style_page_layout),
#        (STYLENS, "page-layout"):(self.s_ignorexml, None),
#        (STYLENS, "paragraph-properties"):(self.s_style_handle_properties, None),
#        (STYLENS, "style"):(self.s_style_style, self.e_style_style),
#        (STYLENS, "table-cell-properties"):(self.s_style_handle_properties, None),
#        (STYLENS, "table-column-properties"):(self.s_style_handle_properties, None),
#        (STYLENS, "table-properties"):(self.s_style_handle_properties, None),
#        (STYLENS, "text-properties"):(self.s_style_handle_properties, None),
        (SVGNS, 'desc'): (self.s_ignorexml, None),
        (TABLENS, 'covered-table-cell'): (self.s_ignorexml, None),
        (TABLENS, 'table-cell'): (self.s_table_table_cell, self.e_table_table_cell),
        (TABLENS, 'table-column'): (self.s_table_table_column, None),
        (TABLENS, 'table-row'): (self.s_table_table_row, self.e_table_table_row),
        (TABLENS, 'table'): (self.s_table_table, self.e_table_table),
        (TEXTNS, 'a'): (self.s_text_a, self.e_text_a),
        (TEXTNS, "alphabetical-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, "bibliography-configuration"):(self.s_ignorexml, None),
        (TEXTNS, "bibliography-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, 'h'): (self.s_text_h, self.e_text_h),
        (TEXTNS, "illustration-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, 'line-break'):(self.s_text_line_break, None),
        (TEXTNS, "linenumbering-configuration"):(self.s_ignorexml, None),
        (TEXTNS, "list"):(self.s_text_list, self.e_text_list),
        (TEXTNS, "list-item"):(self.s_text_list_item, self.e_text_list_item),
        (TEXTNS, "list-level-style-bullet"):(self.s_text_list_level_style_bullet, self.e_text_list_level_style_bullet),
        (TEXTNS, "list-level-style-number"):(self.s_text_list_level_style_number, self.e_text_list_level_style_number),
        (TEXTNS, "list-style"):(None, None),
        (TEXTNS, "note"):(self.s_text_note, None),
        (TEXTNS, "note-body"):(self.s_text_note_body, self.e_text_note_body),
        (TEXTNS, "note-citation"):(None, self.e_text_note_citation),
        (TEXTNS, "notes-configuration"):(self.s_ignorexml, None),
        (TEXTNS, "object-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, 'p'): (self.s_text_p, self.e_text_p),
        (TEXTNS, 's'): (self.s_text_s, None),
        (TEXTNS, 'span'): (self.s_text_span, self.e_text_span),
        (TEXTNS, 'tab'): (self.s_text_tab, None),
        (TEXTNS, "table-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, "table-of-content-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, "user-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, "page-number"):(None, None),
        }


########NEW FILE########
__FILENAME__ = odfmanifest
#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

# This script lists the content of the manifest.xml file
import zipfile
from xml.sax import make_parser,handler
from xml.sax.xmlreader import InputSource
import xml.sax.saxutils
from cStringIO import StringIO

MANIFESTNS="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0"

#-----------------------------------------------------------------------------
#
# ODFMANIFESTHANDLER
#
#-----------------------------------------------------------------------------

class ODFManifestHandler(handler.ContentHandler):
    """ The ODFManifestHandler parses a manifest file and produces a list of
        content """

    def __init__(self):
        self.manifest = {}

        # Tags
        # FIXME: Also handle encryption data
        self.elements = {
        (MANIFESTNS, 'file-entry'): (self.s_file_entry, self.donothing),
        }

    def handle_starttag(self, tag, method, attrs):
        method(tag,attrs)

    def handle_endtag(self, tag, method):
        method(tag)

    def startElementNS(self, tag, qname, attrs):
        method = self.elements.get(tag, (None, None))[0]
        if method:
            self.handle_starttag(tag, method, attrs)
        else:
            self.unknown_starttag(tag,attrs)

    def endElementNS(self, tag, qname):
        method = self.elements.get(tag, (None, None))[1]
        if method:
            self.handle_endtag(tag, method)
        else:
            self.unknown_endtag(tag)

    def unknown_starttag(self, tag, attrs):
        pass

    def unknown_endtag(self, tag):
        pass

    def donothing(self, tag, attrs=None):
        pass

    def s_file_entry(self, tag, attrs):
        m = attrs.get((MANIFESTNS, 'media-type'),"application/octet-stream")
        p = attrs.get((MANIFESTNS, 'full-path'))
        self.manifest[p] = { 'media-type':m, 'full-path':p }


#-----------------------------------------------------------------------------
#
# Reading the file
#
#-----------------------------------------------------------------------------

def manifestlist(manifestxml):
    odhandler = ODFManifestHandler()
    parser = make_parser()
    parser.setFeature(handler.feature_namespaces, 1)
    parser.setContentHandler(odhandler)
    parser.setErrorHandler(handler.ErrorHandler())

    inpsrc = InputSource()
    inpsrc.setByteStream(StringIO(manifestxml))
    parser.parse(inpsrc)

    return odhandler.manifest

def odfmanifest(odtfile):
    z = zipfile.ZipFile(odtfile)
    manifest = z.read('META-INF/manifest.xml')
    z.close()
    return manifestlist(manifest)

if __name__ == "__main__":
    import sys
    result = odfmanifest(sys.argv[1])
    for file in result.values():
        print "%-40s %-40s" % (file['media-type'], file['full-path'])


########NEW FILE########
__FILENAME__ = office
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import OFFICENS
from element import Element
from draw import StyleRefElement

# Autogenerated
def Annotation(**args):
    return StyleRefElement(qname = (OFFICENS,'annotation'), **args)

def AutomaticStyles(**args):
    return Element(qname = (OFFICENS, 'automatic-styles'), **args)

def BinaryData(**args):
    return Element(qname = (OFFICENS,'binary-data'), **args)

def Body(**args):
    return Element(qname = (OFFICENS, 'body'), **args)

def ChangeInfo(**args):
    return Element(qname = (OFFICENS,'change-info'), **args)

def Chart(**args):
    return Element(qname = (OFFICENS,'chart'), **args)

def DdeSource(**args):
    return Element(qname = (OFFICENS,'dde-source'), **args)

def Document(version="1.1", **args):
    return Element(qname = (OFFICENS,'document'), version=version, **args)

def DocumentContent(version="1.1", **args):
    return Element(qname = (OFFICENS, 'document-content'), version=version, **args)

def DocumentMeta(version="1.1", **args):
    return Element(qname = (OFFICENS, 'document-meta'), version=version, **args)

def DocumentSettings(version="1.1", **args):
    return Element(qname = (OFFICENS, 'document-settings'), version=version, **args)

def DocumentStyles(version="1.1", **args):
    return Element(qname = (OFFICENS, 'document-styles'), version=version, **args)

def Drawing(**args):
    return Element(qname = (OFFICENS,'drawing'), **args)

def EventListeners(**args):
    return Element(qname = (OFFICENS,'event-listeners'), **args)

def FontFaceDecls(**args):
    return Element(qname = (OFFICENS, 'font-face-decls'), **args)

def Forms(**args):
    return Element(qname = (OFFICENS,'forms'), **args)

def Image(**args):
    return Element(qname = (OFFICENS,'image'), **args)

def MasterStyles(**args):
    return Element(qname = (OFFICENS, 'master-styles'), **args)

def Meta(**args):
    return Element(qname = (OFFICENS, 'meta'), **args)

def Presentation(**args):
    return Element(qname = (OFFICENS,'presentation'), **args)

def Script(**args):
    return Element(qname = (OFFICENS, 'script'), **args)

def Scripts(**args):
    return Element(qname = (OFFICENS, 'scripts'), **args)

def Settings(**args):
    return Element(qname = (OFFICENS, 'settings'), **args)

def Spreadsheet(**args):
    return Element(qname = (OFFICENS, 'spreadsheet'), **args)

def Styles(**args):
    return Element(qname = (OFFICENS, 'styles'), **args)

def Text(**args):
    return Element(qname = (OFFICENS, 'text'), **args)

# Autogenerated end

########NEW FILE########
__FILENAME__ = opendocument
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2010 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
#
# Contributor(s):
#

__doc__="""Use OpenDocument to generate your documents."""

import zipfile, time, sys, mimetypes, copy
from cStringIO import StringIO
from namespaces import *
import manifest, meta
from office import *
import element
from attrconverters import make_NCName
from xml.sax.xmlreader import InputSource
from odfmanifest import manifestlist

__version__= TOOLSVERSION

_XMLPROLOGUE = u"<?xml version='1.0' encoding='UTF-8'?>\n"

UNIXPERMS = 0100644 << 16L  # -rw-r--r--

IS_FILENAME = 0
IS_IMAGE = 1
# We need at least Python 2.2
assert sys.version_info[0]>=2 and sys.version_info[1] >= 2

#sys.setrecursionlimit(100)
#The recursion limit is set conservative so mistakes like
# s=content() s.addElement(s) won't eat up too much processor time.

odmimetypes = {
 'application/vnd.oasis.opendocument.text':                  '.odt',
 'application/vnd.oasis.opendocument.text-template':         '.ott',
 'application/vnd.oasis.opendocument.graphics':              '.odg',
 'application/vnd.oasis.opendocument.graphics-template':     '.otg',
 'application/vnd.oasis.opendocument.presentation':          '.odp',
 'application/vnd.oasis.opendocument.presentation-template': '.otp',
 'application/vnd.oasis.opendocument.spreadsheet':           '.ods',
 'application/vnd.oasis.opendocument.spreadsheet-template':  '.ots',
 'application/vnd.oasis.opendocument.chart':                 '.odc',
 'application/vnd.oasis.opendocument.chart-template':        '.otc',
 'application/vnd.oasis.opendocument.image':                 '.odi',
 'application/vnd.oasis.opendocument.image-template':        '.oti',
 'application/vnd.oasis.opendocument.formula':               '.odf',
 'application/vnd.oasis.opendocument.formula-template':      '.otf',
 'application/vnd.oasis.opendocument.text-master':           '.odm',
 'application/vnd.oasis.opendocument.text-web':              '.oth',
}

class OpaqueObject:
    def __init__(self, filename, mediatype, content=None):
       self.mediatype = mediatype
       self.filename = filename
       self.content = content

class OpenDocument:
    """ A class to hold the content of an OpenDocument document
        Use the xml method to write the XML
        source to the screen or to a file
        d = OpenDocument(mimetype)
        fd.write(d.xml())
    """
    thumbnail = None

    def __init__(self, mimetype, add_generator=True):
        self.mimetype = mimetype
        self.childobjects = []
        self._extra = []
        self.folder = "" # Always empty for toplevel documents
        self.topnode = Document(mimetype=self.mimetype)
        self.topnode.ownerDocument = self

        self.clear_caches()

        self.Pictures = {}
        self.meta = Meta()
        self.topnode.addElement(self.meta)
        if add_generator:
            self.meta.addElement(meta.Generator(text=TOOLSVERSION))
        self.scripts = Scripts()
        self.topnode.addElement(self.scripts)
        self.fontfacedecls = FontFaceDecls()
        self.topnode.addElement(self.fontfacedecls)
        self.settings = Settings()
        self.topnode.addElement(self.settings)
        self.styles = Styles()
        self.topnode.addElement(self.styles)
        self.automaticstyles = AutomaticStyles()
        self.topnode.addElement(self.automaticstyles)
        self.masterstyles = MasterStyles()
        self.topnode.addElement(self.masterstyles)
        self.body = Body()
        self.topnode.addElement(self.body)

    def rebuild_caches(self, node=None):
        if node is None: node = self.topnode
        self.build_caches(node)
        for e in node.childNodes:
            if e.nodeType == element.Node.ELEMENT_NODE:
                self.rebuild_caches(e)

    def clear_caches(self):
        self.element_dict = {}
        self._styles_dict = {}
        self._styles_ooo_fix = {}

    def build_caches(self, element):
        """ Called from element.py
        """
        if not self.element_dict.has_key(element.qname):
            self.element_dict[element.qname] = []
        self.element_dict[element.qname].append(element)
        if element.qname == (STYLENS, u'style'):
            self.__register_stylename(element) # Add to style dictionary
        styleref = element.getAttrNS(TEXTNS,u'style-name')
        if styleref is not None and self._styles_ooo_fix.has_key(styleref):
            element.setAttrNS(TEXTNS,u'style-name', self._styles_ooo_fix[styleref])

    def __register_stylename(self, element):
        ''' Register a style. But there are three style dictionaries:
            office:styles, office:automatic-styles and office:master-styles
            Chapter 14
        '''
        name = element.getAttrNS(STYLENS, u'name')
        if name is None:
            return
        if element.parentNode.qname in ((OFFICENS,u'styles'), (OFFICENS,u'automatic-styles')):
            if self._styles_dict.has_key(name):
                newname = 'M'+name # Rename style
                self._styles_ooo_fix[name] = newname
                # From here on all references to the old name will refer to the new one
                name = newname
                element.setAttrNS(STYLENS, u'name', name)
            self._styles_dict[name] = element

    def toXml(self, filename=''):
        xml=StringIO()
        xml.write(_XMLPROLOGUE)
        self.body.toXml(0, xml)
        if not filename:
            return xml.getvalue()
        else:
            f=file(filename,'w')
            f.write(xml.getvalue())
            f.close()

    def xml(self):
        """ Generates the full document as an XML file
            Always written as a bytestream in UTF-8 encoding
        """
        self.__replaceGenerator()
        xml=StringIO()
        xml.write(_XMLPROLOGUE)
        self.topnode.toXml(0, xml)
        return xml.getvalue()


    def contentxml(self):
        """ Generates the content.xml file
            Always written as a bytestream in UTF-8 encoding
        """
        xml=StringIO()
        xml.write(_XMLPROLOGUE)
        x = DocumentContent()
        x.write_open_tag(0, xml)
        if self.scripts.hasChildNodes():
            self.scripts.toXml(1, xml)
        if self.fontfacedecls.hasChildNodes():
            self.fontfacedecls.toXml(1, xml)
        a = AutomaticStyles()
        stylelist = self._used_auto_styles([self.styles, self.automaticstyles, self.body])
        if len(stylelist) > 0:
            a.write_open_tag(1, xml)
            for s in stylelist:
                s.toXml(2, xml)
            a.write_close_tag(1, xml)
        else:
            a.toXml(1, xml)
        self.body.toXml(1, xml)
        x.write_close_tag(0, xml)
        return xml.getvalue()

    def __manifestxml(self):
        """ Generates the manifest.xml file
            The self.manifest isn't avaible unless the document is being saved
        """
        xml=StringIO()
        xml.write(_XMLPROLOGUE)
        self.manifest.toXml(0,xml)
        return xml.getvalue()

    def metaxml(self):
        """ Generates the meta.xml file """
        self.__replaceGenerator()
        x = DocumentMeta()
        x.addElement(self.meta)
        xml=StringIO()
        xml.write(_XMLPROLOGUE)
        x.toXml(0,xml)
        return xml.getvalue()

    def settingsxml(self):
        """ Generates the settings.xml file """
        x = DocumentSettings()
        x.addElement(self.settings)
        xml=StringIO()
        xml.write(_XMLPROLOGUE)
        x.toXml(0,xml)
        return xml.getvalue()

    def _parseoneelement(self, top, stylenamelist):
        """ Finds references to style objects in master-styles
            and add the style name to the style list if not already there.
            Recursive
        """
        for e in top.childNodes:
            if e.nodeType == element.Node.ELEMENT_NODE:
                for styleref in ( (DRAWNS,u'style-name'),
                        (DRAWNS,u'text-style-name'),
                        (PRESENTATIONNS,u'style-name'),
                        (STYLENS,u'data-style-name'),
                        (STYLENS,u'list-style-name'),
                        (STYLENS,u'page-layout-name'),
                        (STYLENS,u'style-name'),
                        (TABLENS,u'default-cell-style-name'),
                        (TABLENS,u'style-name'),
                        (TEXTNS,u'style-name') ):
                    if e.getAttrNS(styleref[0],styleref[1]):
                        stylename = e.getAttrNS(styleref[0],styleref[1])
                        if stylename not in stylenamelist:
                            stylenamelist.append(stylename)
                stylenamelist = self._parseoneelement(e, stylenamelist)
        return stylenamelist

    def _used_auto_styles(self, segments):
        """ Loop through the masterstyles elements, and find the automatic
            styles that are used. These will be added to the automatic-styles
            element in styles.xml
        """
        stylenamelist = []
        for top in segments:
            stylenamelist = self._parseoneelement(top, stylenamelist)
        stylelist = []
        for e in self.automaticstyles.childNodes:
            if e.getAttrNS(STYLENS,u'name') in stylenamelist:
                stylelist.append(e)
        return stylelist

    def stylesxml(self):
        """ Generates the styles.xml file """
        xml=StringIO()
        xml.write(_XMLPROLOGUE)
        x = DocumentStyles()
        x.write_open_tag(0, xml)
        if self.fontfacedecls.hasChildNodes():
            self.fontfacedecls.toXml(1, xml)
        self.styles.toXml(1, xml)
        a = AutomaticStyles()
        a.write_open_tag(1, xml)
        for s in self._used_auto_styles([self.masterstyles]):
            s.toXml(2, xml)
        a.write_close_tag(1, xml)
        if self.masterstyles.hasChildNodes():
            self.masterstyles.toXml(1, xml)
        x.write_close_tag(0, xml)
        return xml.getvalue()

    def addPicture(self, filename, mediatype=None, content=None):
        """ Add a picture
            It uses the same convention as OOo, in that it saves the picture in
            the zipfile in the subdirectory 'Pictures'
            If passed a file ptr, mediatype must be set
        """
        if content is None:
            if mediatype is None:
                mediatype, encoding = mimetypes.guess_type(filename)
            if mediatype is None:
                mediatype = ''
                try: ext = filename[filename.rindex('.'):]
                except: ext=''
            else:
                ext = mimetypes.guess_extension(mediatype)
            manifestfn = "Pictures/%0.0f%s" % ((time.time()*10000000000), ext)
            self.Pictures[manifestfn] = (IS_FILENAME, filename, mediatype)
        else:
            manifestfn = filename
            self.Pictures[manifestfn] = (IS_IMAGE, content, mediatype)
        return manifestfn

    def addPictureFromFile(self, filename, mediatype=None):
        """ Add a picture
            It uses the same convention as OOo, in that it saves the picture in
            the zipfile in the subdirectory 'Pictures'.
            If mediatype is not given, it will be guessed from the filename
            extension.
        """
        if mediatype is None:
            mediatype, encoding = mimetypes.guess_type(filename)
        if mediatype is None:
            mediatype = ''
            try: ext = filename[filename.rindex('.'):]
            except ValueError: ext=''
        else:
            ext = mimetypes.guess_extension(mediatype)
        manifestfn = "Pictures/%0.0f%s" % ((time.time()*10000000000), ext)
        self.Pictures[manifestfn] = (IS_FILENAME, filename, mediatype)
        return manifestfn

    def addPictureFromString(self, content, mediatype):
        """ Add a picture
            It uses the same convention as OOo, in that it saves the picture in
            the zipfile in the subdirectory 'Pictures'. The content variable
            is a string that contains the binary image data. The mediatype
            indicates the image format.
        """
        ext = mimetypes.guess_extension(mediatype)
        manifestfn = "Pictures/%0.0f%s" % ((time.time()*10000000000), ext)
        self.Pictures[manifestfn] = (IS_IMAGE, content, mediatype)
        return manifestfn

    def addThumbnail(self, filecontent=None):
        """ Add a fixed thumbnail
            The thumbnail in the library is big, so this is pretty useless.
        """
        if filecontent is None:
            import thumbnail
            self.thumbnail = thumbnail.thumbnail()
        else:
            self.thumbnail = filecontent

    def addObject(self, document, objectname=None):
        """ Adds an object (subdocument). The object must be an OpenDocument class
            The return value will be the folder in the zipfile the object is stored in
        """
        self.childobjects.append(document)
        if objectname is None:
            document.folder = "%s/Object %d" % (self.folder, len(self.childobjects))
        else:
            document.folder = objectname
        return ".%s" % document.folder

    def _savePictures(self, object, folder):
        hasPictures = False
        for arcname, picturerec in object.Pictures.items():
            what_it_is, fileobj, mediatype = picturerec
            self.manifest.addElement(manifest.FileEntry(fullpath="%s%s" % ( folder ,arcname), mediatype=mediatype))
            hasPictures = True
            if what_it_is == IS_FILENAME:
                self._z.write(fileobj, arcname, zipfile.ZIP_STORED)
            else:
                zi = zipfile.ZipInfo(str(arcname), self._now)
                zi.compress_type = zipfile.ZIP_STORED
                zi.external_attr = UNIXPERMS
                self._z.writestr(zi, fileobj)
        # According to section 17.7.3 in ODF 1.1, the pictures folder should not have a manifest entry
#       if hasPictures:
#           self.manifest.addElement(manifest.FileEntry(fullpath="%sPictures/" % folder, mediatype=""))
        # Look in subobjects
        subobjectnum = 1
        for subobject in object.childobjects:
            self._savePictures(subobject,'%sObject %d/' % (folder, subobjectnum))
            subobjectnum += 1

    def __replaceGenerator(self):
        """ Section 3.1.1: The application MUST NOT export the original identifier
            belonging to the application that created the document.
        """
        for m in self.meta.childNodes[:]:
            if m.qname == (METANS, u'generator'):
                self.meta.removeChild(m)
        self.meta.addElement(meta.Generator(text=TOOLSVERSION))

    def save(self, outputfile, addsuffix=False):
        """ Save the document under the filename.
            If the filename is '-' then save to stdout
        """
        if outputfile == '-':
            outputfp = zipfile.ZipFile(sys.stdout,"w")
        else:
            if addsuffix:
                outputfile = outputfile + odmimetypes.get(self.mimetype,'.xxx')
            outputfp = zipfile.ZipFile(outputfile, "w")
        self.__zipwrite(outputfp)
        outputfp.close()

    def write(self, outputfp):
        """ User API to write the ODF file to an open file descriptor
            Writes the ZIP format
        """
        zipoutputfp = zipfile.ZipFile(outputfp,"w")
        self.__zipwrite(zipoutputfp)

    def __zipwrite(self, outputfp):
        """ Write the document to an open file pointer
            This is where the real work is done
        """
        self._z = outputfp
        self._now = time.localtime()[:6]
        self.manifest = manifest.Manifest()

        # Write mimetype
        zi = zipfile.ZipInfo('mimetype', self._now)
        zi.compress_type = zipfile.ZIP_STORED
        zi.external_attr = UNIXPERMS
        self._z.writestr(zi, self.mimetype)

        self._saveXmlObjects(self,"")

        # Write pictures
        self._savePictures(self,"")

        # Write the thumbnail
        if self.thumbnail is not None:
            self.manifest.addElement(manifest.FileEntry(fullpath="Thumbnails/", mediatype=''))
            self.manifest.addElement(manifest.FileEntry(fullpath="Thumbnails/thumbnail.png", mediatype=''))
            zi = zipfile.ZipInfo("Thumbnails/thumbnail.png", self._now)
            zi.compress_type = zipfile.ZIP_DEFLATED
            zi.external_attr = UNIXPERMS
            self._z.writestr(zi, self.thumbnail)

        # Write any extra files
        for op in self._extra:
            if op.filename == "META-INF/documentsignatures.xml": continue # Don't save signatures
            self.manifest.addElement(manifest.FileEntry(fullpath=op.filename, mediatype=op.mediatype))
            zi = zipfile.ZipInfo(op.filename.encode('utf-8'), self._now)
            zi.compress_type = zipfile.ZIP_DEFLATED
            zi.external_attr = UNIXPERMS
            if op.content is not None:
                self._z.writestr(zi, op.content)
        # Write manifest
        zi = zipfile.ZipInfo("META-INF/manifest.xml", self._now)
        zi.compress_type = zipfile.ZIP_DEFLATED
        zi.external_attr = UNIXPERMS
        self._z.writestr(zi, self.__manifestxml() )
        del self._z
        del self._now
        del self.manifest


    def _saveXmlObjects(self, object, folder):
        if self == object:
            self.manifest.addElement(manifest.FileEntry(fullpath="/", mediatype=object.mimetype))
        else:
            self.manifest.addElement(manifest.FileEntry(fullpath=folder, mediatype=object.mimetype))
        # Write styles
        self.manifest.addElement(manifest.FileEntry(fullpath="%sstyles.xml" % folder, mediatype="text/xml"))
        zi = zipfile.ZipInfo("%sstyles.xml" % folder, self._now)
        zi.compress_type = zipfile.ZIP_DEFLATED
        zi.external_attr = UNIXPERMS
        self._z.writestr(zi, object.stylesxml() )

        # Write content
        self.manifest.addElement(manifest.FileEntry(fullpath="%scontent.xml" % folder, mediatype="text/xml"))
        zi = zipfile.ZipInfo("%scontent.xml" % folder, self._now)
        zi.compress_type = zipfile.ZIP_DEFLATED
        zi.external_attr = UNIXPERMS
        self._z.writestr(zi, object.contentxml() )

        # Write settings
        if object.settings.hasChildNodes():
            self.manifest.addElement(manifest.FileEntry(fullpath="%ssettings.xml" % folder, mediatype="text/xml"))
            zi = zipfile.ZipInfo("%ssettings.xml" % folder, self._now)
            zi.compress_type = zipfile.ZIP_DEFLATED
            zi.external_attr = UNIXPERMS
            self._z.writestr(zi, object.settingsxml() )

        # Write meta
        if self == object:
            self.manifest.addElement(manifest.FileEntry(fullpath="meta.xml", mediatype="text/xml"))
            zi = zipfile.ZipInfo("meta.xml", self._now)
            zi.compress_type = zipfile.ZIP_DEFLATED
            zi.external_attr = UNIXPERMS
            self._z.writestr(zi, object.metaxml() )

        # Write subobjects
        subobjectnum = 1
        for subobject in object.childobjects:
            self._saveXmlObjects(subobject, '%sObject %d/' % (folder, subobjectnum))
            subobjectnum += 1

# Document's DOM methods
    def createElement(self, element):
        """ Inconvenient interface to create an element, but follows XML-DOM.
            Does not allow attributes as argument, therefore can't check grammar.
        """
        return element(check_grammar=False)

    def createTextNode(self, data):
        """ Method to create a text node """
        return element.Text(data)

    def createCDATASection(self, data):
        """ Method to create a CDATA section """
        return element.CDATASection(cdata)

    def getMediaType(self):
        """ Returns the media type """
        return self.mimetype

    def getStyleByName(self, name):
        """ Finds a style object based on the name """
        ncname = make_NCName(name)
        if self._styles_dict == {}:
            self.rebuild_caches()
        return self._styles_dict.get(ncname, None)

    def getElementsByType(self, element):
        """ Gets elements based on the type, which is function from text.py, draw.py etc. """
        obj = element(check_grammar=False)
        if self.element_dict == {}:
            self.rebuild_caches()
        return self.element_dict.get(obj.qname, [])

# Convenience functions
def OpenDocumentChart():
    """ Creates a chart document """
    doc = OpenDocument('application/vnd.oasis.opendocument.chart')
    doc.chart = Chart()
    doc.body.addElement(doc.chart)
    return doc

def OpenDocumentDrawing():
    """ Creates a drawing document """
    doc = OpenDocument('application/vnd.oasis.opendocument.graphics')
    doc.drawing = Drawing()
    doc.body.addElement(doc.drawing)
    return doc

def OpenDocumentImage():
    """ Creates an image document """
    doc = OpenDocument('application/vnd.oasis.opendocument.image')
    doc.image = Image()
    doc.body.addElement(doc.image)
    return doc

def OpenDocumentPresentation():
    """ Creates a presentation document """
    doc = OpenDocument('application/vnd.oasis.opendocument.presentation')
    doc.presentation = Presentation()
    doc.body.addElement(doc.presentation)
    return doc

def OpenDocumentSpreadsheet():
    """ Creates a spreadsheet document """
    doc = OpenDocument('application/vnd.oasis.opendocument.spreadsheet')
    doc.spreadsheet = Spreadsheet()
    doc.body.addElement(doc.spreadsheet)
    return doc

def OpenDocumentText():
    """ Creates a text document """
    doc = OpenDocument('application/vnd.oasis.opendocument.text')
    doc.text = Text()
    doc.body.addElement(doc.text)
    return doc

def OpenDocumentTextMaster():
    """ Creates a text master document """
    doc = OpenDocument('application/vnd.oasis.opendocument.text-master')
    doc.text = Text()
    doc.body.addElement(doc.text)
    return doc

def __loadxmlparts(z, manifest, doc, objectpath):
    from load import LoadParser
    from xml.sax import make_parser, handler

    for xmlfile in (objectpath+'settings.xml', objectpath+'meta.xml', objectpath+'content.xml', objectpath+'styles.xml'):
        if not manifest.has_key(xmlfile):
            continue
        try:
            xmlpart = z.read(xmlfile)
            doc._parsing = xmlfile

            parser = make_parser()
            parser.setFeature(handler.feature_namespaces, 1)
            parser.setContentHandler(LoadParser(doc))
            parser.setErrorHandler(handler.ErrorHandler())

            inpsrc = InputSource()
            inpsrc.setByteStream(StringIO(xmlpart))
            parser.parse(inpsrc)
            del doc._parsing
        except KeyError, v: pass

def load(odffile):
    """ Load an ODF file into memory
        Returns a reference to the structure
    """
    z = zipfile.ZipFile(odffile)
    mimetype = z.read('mimetype')
    doc = OpenDocument(mimetype, add_generator=False)

    # Look in the manifest file to see if which of the four files there are
    manifestpart = z.read('META-INF/manifest.xml')
    manifest =  manifestlist(manifestpart)
    __loadxmlparts(z, manifest, doc, '')
    for mentry,mvalue in manifest.items():
        if mentry[:9] == "Pictures/" and len(mentry) > 9:
            doc.addPicture(mvalue['full-path'], mvalue['media-type'], z.read(mentry))
        elif mentry == "Thumbnails/thumbnail.png":
            doc.addThumbnail(z.read(mentry))
        elif mentry in ('settings.xml', 'meta.xml', 'content.xml', 'styles.xml'):
            pass
        # Load subobjects into structure
        elif mentry[:7] == "Object " and len(mentry) < 11 and mentry[-1] == "/":
            subdoc = OpenDocument(mvalue['media-type'], add_generator=False)
            doc.addObject(subdoc, "/" + mentry[:-1])
            __loadxmlparts(z, manifest, subdoc, mentry)
        elif mentry[:7] == "Object ":
            pass # Don't load subobjects as opaque objects
        else:
            if mvalue['full-path'][-1] == '/':
                doc._extra.append(OpaqueObject(mvalue['full-path'], mvalue['media-type'], None))
            else:
                doc._extra.append(OpaqueObject(mvalue['full-path'], mvalue['media-type'], z.read(mentry)))
            # Add the SUN junk here to the struct somewhere
            # It is cached data, so it can be out-of-date
    z.close()
    b = doc.getElementsByType(Body)
    if mimetype[:39] == 'application/vnd.oasis.opendocument.text':
        doc.text = b[0].firstChild
    elif mimetype[:43] == 'application/vnd.oasis.opendocument.graphics':
        doc.graphics = b[0].firstChild
    elif mimetype[:47] == 'application/vnd.oasis.opendocument.presentation':
        doc.presentation = b[0].firstChild
    elif mimetype[:46] == 'application/vnd.oasis.opendocument.spreadsheet':
        doc.spreadsheet = b[0].firstChild
    elif mimetype[:40] == 'application/vnd.oasis.opendocument.chart':
        doc.chart = b[0].firstChild
    elif mimetype[:40] == 'application/vnd.oasis.opendocument.image':
        doc.image = b[0].firstChild
    elif mimetype[:42] == 'application/vnd.oasis.opendocument.formula':
        doc.formula = b[0].firstChild
    return doc

# vim: set expandtab sw=4 :

########NEW FILE########
__FILENAME__ = presentation
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import PRESENTATIONNS
from element import Element

# ODF 1.0 section 9.6 and 9.7
# Autogenerated
def AnimationGroup(**args):
    return Element(qname = (PRESENTATIONNS,'animation-group'), **args)

def Animations(**args):
    return Element(qname = (PRESENTATIONNS,'animations'), **args)

def DateTime(**args):
    return Element(qname = (PRESENTATIONNS,'date-time'), **args)

def DateTimeDecl(**args):
    return Element(qname = (PRESENTATIONNS,'date-time-decl'), **args)

def Dim(**args):
    return Element(qname = (PRESENTATIONNS,'dim'), **args)

def EventListener(**args):
    return Element(qname = (PRESENTATIONNS,'event-listener'), **args)

def Footer(**args):
    return Element(qname = (PRESENTATIONNS,'footer'), **args)

def FooterDecl(**args):
    return Element(qname = (PRESENTATIONNS,'footer-decl'), **args)

def Header(**args):
    return Element(qname = (PRESENTATIONNS,'header'), **args)

def HeaderDecl(**args):
    return Element(qname = (PRESENTATIONNS,'header-decl'), **args)

def HideShape(**args):
    return Element(qname = (PRESENTATIONNS,'hide-shape'), **args)

def HideText(**args):
    return Element(qname = (PRESENTATIONNS,'hide-text'), **args)

def Notes(**args):
    return Element(qname = (PRESENTATIONNS,'notes'), **args)

def Placeholder(**args):
    return Element(qname = (PRESENTATIONNS,'placeholder'), **args)

def Play(**args):
    return Element(qname = (PRESENTATIONNS,'play'), **args)

def Settings(**args):
    return Element(qname = (PRESENTATIONNS,'settings'), **args)

def Show(**args):
    return Element(qname = (PRESENTATIONNS,'show'), **args)

def ShowShape(**args):
    return Element(qname = (PRESENTATIONNS,'show-shape'), **args)

def ShowText(**args):
    return Element(qname = (PRESENTATIONNS,'show-text'), **args)

def Sound(**args):
    return Element(qname = (PRESENTATIONNS,'sound'), **args)


########NEW FILE########
__FILENAME__ = script
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import SCRIPTNS
from element import Element

# ODF 1.0 section 12.4.1
# The <script:event-listener> element binds an event to a macro.

# Autogenerated
def EventListener(**args):
    return Element(qname = (SCRIPTNS,'event-listener'), **args)


########NEW FILE########
__FILENAME__ = style
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import STYLENS
from element import Element

def StyleElement(**args):
    e = Element(**args)
    if args.get('check_grammar', True) == True:
        if not args.has_key('displayname'):
            e.setAttrNS(STYLENS,'display-name', args.get('name'))
    return e

# Autogenerated
def BackgroundImage(**args):
    return Element(qname = (STYLENS,'background-image'), **args)

def ChartProperties(**args):
    return Element(qname = (STYLENS,'chart-properties'), **args)

def Column(**args):
    return Element(qname = (STYLENS,'column'), **args)

def ColumnSep(**args):
    return Element(qname = (STYLENS,'column-sep'), **args)

def Columns(**args):
    return Element(qname = (STYLENS,'columns'), **args)

def DefaultStyle(**args):
    return Element(qname = (STYLENS,'default-style'), **args)

def DrawingPageProperties(**args):
    return Element(qname = (STYLENS,'drawing-page-properties'), **args)

def DropCap(**args):
    return Element(qname = (STYLENS,'drop-cap'), **args)

def FontFace(**args):
    return Element(qname = (STYLENS,'font-face'), **args)

def Footer(**args):
    return Element(qname = (STYLENS,'footer'), **args)

def FooterLeft(**args):
    return Element(qname = (STYLENS,'footer-left'), **args)

def FooterStyle(**args):
    return Element(qname = (STYLENS,'footer-style'), **args)

def FootnoteSep(**args):
    return Element(qname = (STYLENS,'footnote-sep'), **args)

def GraphicProperties(**args):
    return Element(qname = (STYLENS,'graphic-properties'), **args)

def HandoutMaster(**args):
    return Element(qname = (STYLENS,'handout-master'), **args)

def Header(**args):
    return Element(qname = (STYLENS,'header'), **args)

def HeaderFooterProperties(**args):
    return Element(qname = (STYLENS,'header-footer-properties'), **args)

def HeaderLeft(**args):
    return Element(qname = (STYLENS,'header-left'), **args)

def HeaderStyle(**args):
    return Element(qname = (STYLENS,'header-style'), **args)

def ListLevelProperties(**args):
    return Element(qname = (STYLENS,'list-level-properties'), **args)

def Map(**args):
    return Element(qname = (STYLENS,'map'), **args)

def MasterPage(**args):
    return StyleElement(qname = (STYLENS,'master-page'), **args)

def PageLayout(**args):
    return Element(qname = (STYLENS,'page-layout'), **args)

def PageLayoutProperties(**args):
    return Element(qname = (STYLENS,'page-layout-properties'), **args)

def ParagraphProperties(**args):
    return Element(qname = (STYLENS,'paragraph-properties'), **args)

def PresentationPageLayout(**args):
    return StyleElement(qname = (STYLENS,'presentation-page-layout'), **args)

def RegionCenter(**args):
    return Element(qname = (STYLENS,'region-center'), **args)

def RegionLeft(**args):
    return Element(qname = (STYLENS,'region-left'), **args)

def RegionRight(**args):
    return Element(qname = (STYLENS,'region-right'), **args)

def RubyProperties(**args):
    return Element(qname = (STYLENS,'ruby-properties'), **args)

def SectionProperties(**args):
    return Element(qname = (STYLENS,'section-properties'), **args)

def Style(**args):
    return StyleElement(qname = (STYLENS,'style'), **args)

def TabStop(**args):
    return Element(qname = (STYLENS,'tab-stop'), **args)

def TabStops(**args):
    return Element(qname = (STYLENS,'tab-stops'), **args)

def TableCellProperties(**args):
    return Element(qname = (STYLENS,'table-cell-properties'), **args)

def TableColumnProperties(**args):
    return Element(qname = (STYLENS,'table-column-properties'), **args)

def TableProperties(**args):
    return Element(qname = (STYLENS,'table-properties'), **args)

def TableRowProperties(**args):
    return Element(qname = (STYLENS,'table-row-properties'), **args)

def TextProperties(**args):
    return Element(qname = (STYLENS,'text-properties'), **args)


########NEW FILE########
__FILENAME__ = svg
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import SVGNS
from element import Element
from draw import DrawElement

# Autogenerated
def DefinitionSrc(**args):
    return Element(qname = (SVGNS,'definition-src'), **args)

def Desc(**args):
    return Element(qname = (SVGNS,'desc'), **args)

def FontFaceFormat(**args):
    return Element(qname = (SVGNS,'font-face-format'), **args)

def FontFaceName(**args):
    return Element(qname = (SVGNS,'font-face-name'), **args)

def FontFaceSrc(**args):
    return Element(qname = (SVGNS,'font-face-src'), **args)

def FontFaceUri(**args):
    return Element(qname = (SVGNS,'font-face-uri'), **args)

def Lineargradient(**args):
    return DrawElement(qname = (SVGNS,'linearGradient'), **args)

def Radialgradient(**args):
    return DrawElement(qname = (SVGNS,'radialGradient'), **args)

def Stop(**args):
    return Element(qname = (SVGNS,'stop'), **args)

def Title(**args):
    return Element(qname = (SVGNS,'title'), **args)

########NEW FILE########
__FILENAME__ = table
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import TABLENS
from element import Element


# Autogenerated
def Body(**args):
    return Element(qname = (TABLENS,'body'), **args)

def CalculationSettings(**args):
    return Element(qname = (TABLENS,'calculation-settings'), **args)

def CellAddress(**args):
    return Element(qname = (TABLENS,'cell-address'), **args)

def CellContentChange(**args):
    return Element(qname = (TABLENS,'cell-content-change'), **args)

def CellContentDeletion(**args):
    return Element(qname = (TABLENS,'cell-content-deletion'), **args)

def CellRangeSource(**args):
    return Element(qname = (TABLENS,'cell-range-source'), **args)

def ChangeDeletion(**args):
    return Element(qname = (TABLENS,'change-deletion'), **args)

def ChangeTrackTableCell(**args):
    return Element(qname = (TABLENS,'change-track-table-cell'), **args)

def Consolidation(**args):
    return Element(qname = (TABLENS,'consolidation'), **args)

def ContentValidation(**args):
    return Element(qname = (TABLENS,'content-validation'), **args)

def ContentValidations(**args):
    return Element(qname = (TABLENS,'content-validations'), **args)

def CoveredTableCell(**args):
    return Element(qname = (TABLENS,'covered-table-cell'), **args)

def CutOffs(**args):
    return Element(qname = (TABLENS,'cut-offs'), **args)

def DataPilotDisplayInfo(**args):
    return Element(qname = (TABLENS,'data-pilot-display-info'), **args)

def DataPilotField(**args):
    return Element(qname = (TABLENS,'data-pilot-field'), **args)

def DataPilotFieldReference(**args):
    return Element(qname = (TABLENS,'data-pilot-field-reference'), **args)

def DataPilotGroup(**args):
    return Element(qname = (TABLENS,'data-pilot-group'), **args)

def DataPilotGroupMember(**args):
    return Element(qname = (TABLENS,'data-pilot-group-member'), **args)

def DataPilotGroups(**args):
    return Element(qname = (TABLENS,'data-pilot-groups'), **args)

def DataPilotLayoutInfo(**args):
    return Element(qname = (TABLENS,'data-pilot-layout-info'), **args)

def DataPilotLevel(**args):
    return Element(qname = (TABLENS,'data-pilot-level'), **args)

def DataPilotMember(**args):
    return Element(qname = (TABLENS,'data-pilot-member'), **args)

def DataPilotMembers(**args):
    return Element(qname = (TABLENS,'data-pilot-members'), **args)

def DataPilotSortInfo(**args):
    return Element(qname = (TABLENS,'data-pilot-sort-info'), **args)

def DataPilotSubtotal(**args):
    return Element(qname = (TABLENS,'data-pilot-subtotal'), **args)

def DataPilotSubtotals(**args):
    return Element(qname = (TABLENS,'data-pilot-subtotals'), **args)

def DataPilotTable(**args):
    return Element(qname = (TABLENS,'data-pilot-table'), **args)

def DataPilotTables(**args):
    return Element(qname = (TABLENS,'data-pilot-tables'), **args)

def DatabaseRange(**args):
    return Element(qname = (TABLENS,'database-range'), **args)

def DatabaseRanges(**args):
    return Element(qname = (TABLENS,'database-ranges'), **args)

def DatabaseSourceQuery(**args):
    return Element(qname = (TABLENS,'database-source-query'), **args)

def DatabaseSourceSql(**args):
    return Element(qname = (TABLENS,'database-source-sql'), **args)

def DatabaseSourceTable(**args):
    return Element(qname = (TABLENS,'database-source-table'), **args)

def DdeLink(**args):
    return Element(qname = (TABLENS,'dde-link'), **args)

def DdeLinks(**args):
    return Element(qname = (TABLENS,'dde-links'), **args)

def Deletion(**args):
    return Element(qname = (TABLENS,'deletion'), **args)

def Deletions(**args):
    return Element(qname = (TABLENS,'deletions'), **args)

def Dependencies(**args):
    return Element(qname = (TABLENS,'dependencies'), **args)

def Dependency(**args):
    return Element(qname = (TABLENS,'dependency'), **args)

def Detective(**args):
    return Element(qname = (TABLENS,'detective'), **args)

def ErrorMacro(**args):
    return Element(qname = (TABLENS,'error-macro'), **args)

def ErrorMessage(**args):
    return Element(qname = (TABLENS,'error-message'), **args)

def EvenColumns(**args):
    return Element(qname = (TABLENS,'even-columns'), **args)

def EvenRows(**args):
    return Element(qname = (TABLENS,'even-rows'), **args)

def Filter(**args):
    return Element(qname = (TABLENS,'filter'), **args)

def FilterAnd(**args):
    return Element(qname = (TABLENS,'filter-and'), **args)

def FilterCondition(**args):
    return Element(qname = (TABLENS,'filter-condition'), **args)

def FilterOr(**args):
    return Element(qname = (TABLENS,'filter-or'), **args)

def FirstColumn(**args):
    return Element(qname = (TABLENS,'first-column'), **args)

def FirstRow(**args):
    return Element(qname = (TABLENS,'first-row'), **args)

def HelpMessage(**args):
    return Element(qname = (TABLENS,'help-message'), **args)

def HighlightedRange(**args):
    return Element(qname = (TABLENS,'highlighted-range'), **args)

def Insertion(**args):
    return Element(qname = (TABLENS,'insertion'), **args)

def InsertionCutOff(**args):
    return Element(qname = (TABLENS,'insertion-cut-off'), **args)

def Iteration(**args):
    return Element(qname = (TABLENS,'iteration'), **args)

def LabelRange(**args):
    return Element(qname = (TABLENS,'label-range'), **args)

def LabelRanges(**args):
    return Element(qname = (TABLENS,'label-ranges'), **args)

def LastColumn(**args):
    return Element(qname = (TABLENS,'last-column'), **args)

def LastRow(**args):
    return Element(qname = (TABLENS,'last-row'), **args)

def Movement(**args):
    return Element(qname = (TABLENS,'movement'), **args)

def MovementCutOff(**args):
    return Element(qname = (TABLENS,'movement-cut-off'), **args)

def NamedExpression(**args):
    return Element(qname = (TABLENS,'named-expression'), **args)

def NamedExpressions(**args):
    return Element(qname = (TABLENS,'named-expressions'), **args)

def NamedRange(**args):
    return Element(qname = (TABLENS,'named-range'), **args)

def NullDate(**args):
    return Element(qname = (TABLENS,'null-date'), **args)

def OddColumns(**args):
    return Element(qname = (TABLENS,'odd-columns'), **args)

def OddRows(**args):
    return Element(qname = (TABLENS,'odd-rows'), **args)

def Operation(**args):
    return Element(qname = (TABLENS,'operation'), **args)

def Previous(**args):
    return Element(qname = (TABLENS,'previous'), **args)

def Scenario(**args):
    return Element(qname = (TABLENS,'scenario'), **args)

def Shapes(**args):
    return Element(qname = (TABLENS,'shapes'), **args)

def Sort(**args):
    return Element(qname = (TABLENS,'sort'), **args)

def SortBy(**args):
    return Element(qname = (TABLENS,'sort-by'), **args)

def SortGroups(**args):
    return Element(qname = (TABLENS,'sort-groups'), **args)

def SourceCellRange(**args):
    return Element(qname = (TABLENS,'source-cell-range'), **args)

def SourceRangeAddress(**args):
    return Element(qname = (TABLENS,'source-range-address'), **args)

def SourceService(**args):
    return Element(qname = (TABLENS,'source-service'), **args)

def SubtotalField(**args):
    return Element(qname = (TABLENS,'subtotal-field'), **args)

def SubtotalRule(**args):
    return Element(qname = (TABLENS,'subtotal-rule'), **args)

def SubtotalRules(**args):
    return Element(qname = (TABLENS,'subtotal-rules'), **args)

def Table(**args):
    return Element(qname = (TABLENS,'table'), **args)

def TableCell(**args):
    return Element(qname = (TABLENS,'table-cell'), **args)

def TableColumn(**args):
    return Element(qname = (TABLENS,'table-column'), **args)

def TableColumnGroup(**args):
    return Element(qname = (TABLENS,'table-column-group'), **args)

def TableColumns(**args):
    return Element(qname = (TABLENS,'table-columns'), **args)

def TableHeaderColumns(**args):
    return Element(qname = (TABLENS,'table-header-columns'), **args)

def TableHeaderRows(**args):
    return Element(qname = (TABLENS,'table-header-rows'), **args)

def TableRow(**args):
    return Element(qname = (TABLENS,'table-row'), **args)

def TableRowGroup(**args):
    return Element(qname = (TABLENS,'table-row-group'), **args)

def TableRows(**args):
    return Element(qname = (TABLENS,'table-rows'), **args)

def TableSource(**args):
    return Element(qname = (TABLENS,'table-source'), **args)

def TableTemplate(**args):
    return Element(qname = (TABLENS,'table-template'), **args)

def TargetRangeAddress(**args):
    return Element(qname = (TABLENS,'target-range-address'), **args)

def TrackedChanges(**args):
    return Element(qname = (TABLENS,'tracked-changes'), **args)


########NEW FILE########
__FILENAME__ = teletype
# -*- coding: utf-8 -*-
#
#   Create and extract text from ODF, handling whitespace correctly.
#   Copyright (C) 2008 J. David Eisenberg
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program; if not, write to the Free Software Foundation, Inc.,
#   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.


"""
Class for handling whitespace properly in OpenDocument.

While it is possible to use getTextContent() and setTextContent()
to extract or create ODF content, these won't extract or create
the appropriate <text:s>, <text:tab>, or <text:line-break>
elements.  This module takes care of that problem.
"""

from odf.element import Node
import odf.opendocument
from odf.text import S,LineBreak,Tab

class WhitespaceText(object):

    def __init__(self):
        self.textBuffer = []
        self.spaceCount = 0

    def addTextToElement(self, odfElement, s):
        """ Process an input string, inserting
            <text:tab> elements for '\t',
            <text:line-break> elements for '\n', and
            <text:s> elements for runs of more than one blank.
            These will be added to the given element.
        """
        i = 0
        ch = ' '

        # When we encounter a tab or newline, we can immediately
        # dump any accumulated text and then emit the appropriate
        # ODF element.
        #
        # When we encounter a space, we add it to the text buffer,
        # and then collect more spaces.  If there are more spaces
        # after the first one, we dump the text buffer and then
        # then emit the appropriate <text:s> element.

        while i < len(s):
            ch = s[i]
            if ch == '\t':
                self._emitTextBuffer(odfElement)
                odfElement.addElement(Tab())
                i += 1
            elif ch == '\n':
                self._emitTextBuffer(odfElement);
                odfElement.addElement(LineBreak())
                i += 1
            elif ch == ' ':
                self.textBuffer.append(' ')
                i += 1
                self.spaceCount = 0
                while i < len(s) and (s[i] == ' '):
                    self.spaceCount += 1
                    i += 1
                if self.spaceCount > 0:
                    self._emitTextBuffer(odfElement)
                    self._emitSpaces(odfElement)
            else:
                self.textBuffer.append(ch)
                i += 1

        self._emitTextBuffer(odfElement)

    def _emitTextBuffer(self, odfElement):
        """ Creates a Text Node whose contents are the current textBuffer.
            Side effect: clears the text buffer.
        """
        if len(self.textBuffer) > 0:
            odfElement.addText(''.join(self.textBuffer))
        self.textBuffer = []


    def _emitSpaces(self, odfElement):
        """ Creates a <text:s> element for the current spaceCount.
            Side effect: sets spaceCount back to zero
        """
        if self.spaceCount > 0:
            spaceElement = S(c=self.spaceCount)
            odfElement.addElement(spaceElement)
        self.spaceCount = 0

def addTextToElement(odfElement, s):
    wst = WhitespaceText()
    wst.addTextToElement(odfElement, s)

def extractText(odfElement):
    """ Extract text content from an Element, with whitespace represented
        properly. Returns the text, with tabs, spaces, and newlines
        correctly evaluated. This method recursively descends through the
        children of the given element, accumulating text and "unwrapping"
        <text:s>, <text:tab>, and <text:line-break> elements along the way.
    """
    result = [];

    if len(odfElement.childNodes) != 0:
        for child in odfElement.childNodes:
            if child.nodeType == Node.TEXT_NODE:
                result.append(child.data)
            elif child.nodeType == Node.ELEMENT_NODE:
                subElement = child
                tagName = subElement.qname;
                if tagName == (u"urn:oasis:names:tc:opendocument:xmlns:text:1.0", u"line-break"):
                    result.append("\n")
                elif tagName == (u"urn:oasis:names:tc:opendocument:xmlns:text:1.0", u"tab"):
                    result.append("\t")
                elif tagName == (u"urn:oasis:names:tc:opendocument:xmlns:text:1.0", u"s"):
                    c = subElement.getAttribute('c')
                    if c:
                        spaceCount =  int(c)
                    else:
                        spaceCount = 1

                    result.append(" " * spaceCount)
                else:
                    result.append(extractText(subElement))
    return ''.join(result)

########NEW FILE########
__FILENAME__ = text
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import TEXTNS
from element import Element
from style import StyleElement

# Autogenerated
def A(**args):
    return Element(qname = (TEXTNS,'a'), **args)

def AlphabeticalIndex(**args):
    return Element(qname = (TEXTNS,'alphabetical-index'), **args)

def AlphabeticalIndexAutoMarkFile(**args):
    return Element(qname = (TEXTNS,'alphabetical-index-auto-mark-file'), **args)

def AlphabeticalIndexEntryTemplate(**args):
    return Element(qname = (TEXTNS,'alphabetical-index-entry-template'), **args)

def AlphabeticalIndexMark(**args):
    return Element(qname = (TEXTNS,'alphabetical-index-mark'), **args)

def AlphabeticalIndexMarkEnd(**args):
    return Element(qname = (TEXTNS,'alphabetical-index-mark-end'), **args)

def AlphabeticalIndexMarkStart(**args):
    return Element(qname = (TEXTNS,'alphabetical-index-mark-start'), **args)

def AlphabeticalIndexSource(**args):
    return Element(qname = (TEXTNS,'alphabetical-index-source'), **args)

def AuthorInitials(**args):
    return Element(qname = (TEXTNS,'author-initials'), **args)

def AuthorName(**args):
    return Element(qname = (TEXTNS,'author-name'), **args)

def Bibliography(**args):
    return Element(qname = (TEXTNS,'bibliography'), **args)

def BibliographyConfiguration(**args):
    return Element(qname = (TEXTNS,'bibliography-configuration'), **args)

def BibliographyEntryTemplate(**args):
    return Element(qname = (TEXTNS,'bibliography-entry-template'), **args)

def BibliographyMark(**args):
    return Element(qname = (TEXTNS,'bibliography-mark'), **args)

def BibliographySource(**args):
    return Element(qname = (TEXTNS,'bibliography-source'), **args)

def Bookmark(**args):
    return Element(qname = (TEXTNS,'bookmark'), **args)

def BookmarkEnd(**args):
    return Element(qname = (TEXTNS,'bookmark-end'), **args)

def BookmarkRef(**args):
    return Element(qname = (TEXTNS,'bookmark-ref'), **args)

def BookmarkStart(**args):
    return Element(qname = (TEXTNS,'bookmark-start'), **args)

def Change(**args):
    return Element(qname = (TEXTNS,'change'), **args)

def ChangeEnd(**args):
    return Element(qname = (TEXTNS,'change-end'), **args)

def ChangeStart(**args):
    return Element(qname = (TEXTNS,'change-start'), **args)

def ChangedRegion(**args):
    return Element(qname = (TEXTNS,'changed-region'), **args)

def Chapter(**args):
    return Element(qname = (TEXTNS,'chapter'), **args)

def CharacterCount(**args):
    return Element(qname = (TEXTNS,'character-count'), **args)

def ConditionalText(**args):
    return Element(qname = (TEXTNS,'conditional-text'), **args)

def CreationDate(**args):
    return Element(qname = (TEXTNS,'creation-date'), **args)

def CreationTime(**args):
    return Element(qname = (TEXTNS,'creation-time'), **args)

def Creator(**args):
    return Element(qname = (TEXTNS,'creator'), **args)

def DatabaseDisplay(**args):
    return Element(qname = (TEXTNS,'database-display'), **args)

def DatabaseName(**args):
    return Element(qname = (TEXTNS,'database-name'), **args)

def DatabaseNext(**args):
    return Element(qname = (TEXTNS,'database-next'), **args)

def DatabaseRowNumber(**args):
    return Element(qname = (TEXTNS,'database-row-number'), **args)

def DatabaseRowSelect(**args):
    return Element(qname = (TEXTNS,'database-row-select'), **args)

def Date(**args):
    return Element(qname = (TEXTNS,'date'), **args)

def DdeConnection(**args):
    return Element(qname = (TEXTNS,'dde-connection'), **args)

def DdeConnectionDecl(**args):
    return Element(qname = (TEXTNS,'dde-connection-decl'), **args)

def DdeConnectionDecls(**args):
    return Element(qname = (TEXTNS,'dde-connection-decls'), **args)

def Deletion(**args):
    return Element(qname = (TEXTNS,'deletion'), **args)

def Description(**args):
    return Element(qname = (TEXTNS,'description'), **args)

def EditingCycles(**args):
    return Element(qname = (TEXTNS,'editing-cycles'), **args)

def EditingDuration(**args):
    return Element(qname = (TEXTNS,'editing-duration'), **args)

def ExecuteMacro(**args):
    return Element(qname = (TEXTNS,'execute-macro'), **args)

def Expression(**args):
    return Element(qname = (TEXTNS,'expression'), **args)

def FileName(**args):
    return Element(qname = (TEXTNS,'file-name'), **args)

def FormatChange(**args):
    return Element(qname = (TEXTNS,'format-change'), **args)

def H(**args):
    return Element(qname = (TEXTNS, 'h'), **args)

def HiddenParagraph(**args):
    return Element(qname = (TEXTNS,'hidden-paragraph'), **args)

def HiddenText(**args):
    return Element(qname = (TEXTNS,'hidden-text'), **args)

def IllustrationIndex(**args):
    return Element(qname = (TEXTNS,'illustration-index'), **args)

def IllustrationIndexEntryTemplate(**args):
    return Element(qname = (TEXTNS,'illustration-index-entry-template'), **args)

def IllustrationIndexSource(**args):
    return Element(qname = (TEXTNS,'illustration-index-source'), **args)

def ImageCount(**args):
    return Element(qname = (TEXTNS,'image-count'), **args)

def IndexBody(**args):
    return Element(qname = (TEXTNS,'index-body'), **args)

def IndexEntryBibliography(**args):
    return Element(qname = (TEXTNS,'index-entry-bibliography'), **args)

def IndexEntryChapter(**args):
    return Element(qname = (TEXTNS,'index-entry-chapter'), **args)

def IndexEntryLinkEnd(**args):
    return Element(qname = (TEXTNS,'index-entry-link-end'), **args)

def IndexEntryLinkStart(**args):
    return Element(qname = (TEXTNS,'index-entry-link-start'), **args)

def IndexEntryPageNumber(**args):
    return Element(qname = (TEXTNS,'index-entry-page-number'), **args)

def IndexEntrySpan(**args):
    return Element(qname = (TEXTNS,'index-entry-span'), **args)

def IndexEntryTabStop(**args):
    return Element(qname = (TEXTNS,'index-entry-tab-stop'), **args)

def IndexEntryText(**args):
    return Element(qname = (TEXTNS,'index-entry-text'), **args)

def IndexSourceStyle(**args):
    return Element(qname = (TEXTNS,'index-source-style'), **args)

def IndexSourceStyles(**args):
    return Element(qname = (TEXTNS,'index-source-styles'), **args)

def IndexTitle(**args):
    return Element(qname = (TEXTNS,'index-title'), **args)

def IndexTitleTemplate(**args):
    return Element(qname = (TEXTNS,'index-title-template'), **args)

def InitialCreator(**args):
    return Element(qname = (TEXTNS,'initial-creator'), **args)

def Insertion(**args):
    return Element(qname = (TEXTNS,'insertion'), **args)

def Keywords(**args):
    return Element(qname = (TEXTNS,'keywords'), **args)

def LineBreak(**args):
    return Element(qname = (TEXTNS,'line-break'), **args)

def LinenumberingConfiguration(**args):
    return Element(qname = (TEXTNS,'linenumbering-configuration'), **args)

def LinenumberingSeparator(**args):
    return Element(qname = (TEXTNS,'linenumbering-separator'), **args)

def List(**args):
    return Element(qname = (TEXTNS,'list'), **args)

def ListHeader(**args):
    return Element(qname = (TEXTNS,'list-header'), **args)

def ListItem(**args):
    return Element(qname = (TEXTNS,'list-item'), **args)

def ListLevelStyleBullet(**args):
    return Element(qname = (TEXTNS,'list-level-style-bullet'), **args)

def ListLevelStyleImage(**args):
    return Element(qname = (TEXTNS,'list-level-style-image'), **args)

def ListLevelStyleNumber(**args):
    return Element(qname = (TEXTNS,'list-level-style-number'), **args)

def ListStyle(**args):
    return StyleElement(qname = (TEXTNS,'list-style'), **args)

def Measure(**args):
    return Element(qname = (TEXTNS,'measure'), **args)

def ModificationDate(**args):
    return Element(qname = (TEXTNS,'modification-date'), **args)

def ModificationTime(**args):
    return Element(qname = (TEXTNS,'modification-time'), **args)

def Note(**args):
    return Element(qname = (TEXTNS,'note'), **args)

def NoteBody(**args):
    return Element(qname = (TEXTNS,'note-body'), **args)

def NoteCitation(**args):
    return Element(qname = (TEXTNS,'note-citation'), **args)

def NoteContinuationNoticeBackward(**args):
    return Element(qname = (TEXTNS,'note-continuation-notice-backward'), **args)

def NoteContinuationNoticeForward(**args):
    return Element(qname = (TEXTNS,'note-continuation-notice-forward'), **args)

def NoteRef(**args):
    return Element(qname = (TEXTNS,'note-ref'), **args)

def NotesConfiguration(**args):
    return Element(qname = (TEXTNS,'notes-configuration'), **args)

def Number(**args):
    return Element(qname = (TEXTNS,'number'), **args)

def NumberedParagraph(**args):
    return Element(qname = (TEXTNS,'numbered-paragraph'), **args)

def ObjectCount(**args):
    return Element(qname = (TEXTNS,'object-count'), **args)

def ObjectIndex(**args):
    return Element(qname = (TEXTNS,'object-index'), **args)

def ObjectIndexEntryTemplate(**args):
    return Element(qname = (TEXTNS,'object-index-entry-template'), **args)

def ObjectIndexSource(**args):
    return Element(qname = (TEXTNS,'object-index-source'), **args)

def OutlineLevelStyle(**args):
    return Element(qname = (TEXTNS,'outline-level-style'), **args)

def OutlineStyle(**args):
    return Element(qname = (TEXTNS,'outline-style'), **args)

def P(**args):
    return Element(qname = (TEXTNS, 'p'), **args)

def Page(**args):
    return Element(qname = (TEXTNS,'page'), **args)

def PageContinuation(**args):
    return Element(qname = (TEXTNS,'page-continuation'), **args)

def PageCount(**args):
    return Element(qname = (TEXTNS,'page-count'), **args)

def PageNumber(**args):
    return Element(qname = (TEXTNS,'page-number'), **args)

def PageSequence(**args):
    return Element(qname = (TEXTNS,'page-sequence'), **args)

def PageVariableGet(**args):
    return Element(qname = (TEXTNS,'page-variable-get'), **args)

def PageVariableSet(**args):
    return Element(qname = (TEXTNS,'page-variable-set'), **args)

def ParagraphCount(**args):
    return Element(qname = (TEXTNS,'paragraph-count'), **args)

def Placeholder(**args):
    return Element(qname = (TEXTNS,'placeholder'), **args)

def PrintDate(**args):
    return Element(qname = (TEXTNS,'print-date'), **args)

def PrintTime(**args):
    return Element(qname = (TEXTNS,'print-time'), **args)

def PrintedBy(**args):
    return Element(qname = (TEXTNS,'printed-by'), **args)

def ReferenceMark(**args):
    return Element(qname = (TEXTNS,'reference-mark'), **args)

def ReferenceMarkEnd(**args):
    return Element(qname = (TEXTNS,'reference-mark-end'), **args)

def ReferenceMarkStart(**args):
    return Element(qname = (TEXTNS,'reference-mark-start'), **args)

def ReferenceRef(**args):
    return Element(qname = (TEXTNS,'reference-ref'), **args)

def Ruby(**args):
    return Element(qname = (TEXTNS,'ruby'), **args)

def RubyBase(**args):
    return Element(qname = (TEXTNS,'ruby-base'), **args)

def RubyText(**args):
    return Element(qname = (TEXTNS,'ruby-text'), **args)

def S(**args):
    return Element(qname = (TEXTNS,'s'), **args)

def Script(**args):
    return Element(qname = (TEXTNS,'script'), **args)

def Section(**args):
    return Element(qname = (TEXTNS,'section'), **args)

def SectionSource(**args):
    return Element(qname = (TEXTNS,'section-source'), **args)

def SenderCity(**args):
    return Element(qname = (TEXTNS,'sender-city'), **args)

def SenderCompany(**args):
    return Element(qname = (TEXTNS,'sender-company'), **args)

def SenderCountry(**args):
    return Element(qname = (TEXTNS,'sender-country'), **args)

def SenderEmail(**args):
    return Element(qname = (TEXTNS,'sender-email'), **args)

def SenderFax(**args):
    return Element(qname = (TEXTNS,'sender-fax'), **args)

def SenderFirstname(**args):
    return Element(qname = (TEXTNS,'sender-firstname'), **args)

def SenderInitials(**args):
    return Element(qname = (TEXTNS,'sender-initials'), **args)

def SenderLastname(**args):
    return Element(qname = (TEXTNS,'sender-lastname'), **args)

def SenderPhonePrivate(**args):
    return Element(qname = (TEXTNS,'sender-phone-private'), **args)

def SenderPhoneWork(**args):
    return Element(qname = (TEXTNS,'sender-phone-work'), **args)

def SenderPosition(**args):
    return Element(qname = (TEXTNS,'sender-position'), **args)

def SenderPostalCode(**args):
    return Element(qname = (TEXTNS,'sender-postal-code'), **args)

def SenderStateOrProvince(**args):
    return Element(qname = (TEXTNS,'sender-state-or-province'), **args)

def SenderStreet(**args):
    return Element(qname = (TEXTNS,'sender-street'), **args)

def SenderTitle(**args):
    return Element(qname = (TEXTNS,'sender-title'), **args)

def Sequence(**args):
    return Element(qname = (TEXTNS,'sequence'), **args)

def SequenceDecl(**args):
    return Element(qname = (TEXTNS,'sequence-decl'), **args)

def SequenceDecls(**args):
    return Element(qname = (TEXTNS,'sequence-decls'), **args)

def SequenceRef(**args):
    return Element(qname = (TEXTNS,'sequence-ref'), **args)

def SheetName(**args):
    return Element(qname = (TEXTNS,'sheet-name'), **args)

def SoftPageBreak(**args):
    return Element(qname = (TEXTNS,'soft-page-break'), **args)

def SortKey(**args):
    return Element(qname = (TEXTNS,'sort-key'), **args)

def Span(**args):
    return Element(qname = (TEXTNS,'span'), **args)

def Subject(**args):
    return Element(qname = (TEXTNS,'subject'), **args)

def Tab(**args):
    return Element(qname = (TEXTNS,'tab'), **args)

def TableCount(**args):
    return Element(qname = (TEXTNS,'table-count'), **args)

def TableFormula(**args):
    return Element(qname = (TEXTNS,'table-formula'), **args)

def TableIndex(**args):
    return Element(qname = (TEXTNS,'table-index'), **args)

def TableIndexEntryTemplate(**args):
    return Element(qname = (TEXTNS,'table-index-entry-template'), **args)

def TableIndexSource(**args):
    return Element(qname = (TEXTNS,'table-index-source'), **args)

def TableOfContent(**args):
    return Element(qname = (TEXTNS,'table-of-content'), **args)

def TableOfContentEntryTemplate(**args):
    return Element(qname = (TEXTNS,'table-of-content-entry-template'), **args)

def TableOfContentSource(**args):
    return Element(qname = (TEXTNS,'table-of-content-source'), **args)

def TemplateName(**args):
    return Element(qname = (TEXTNS,'template-name'), **args)

def TextInput(**args):
    return Element(qname = (TEXTNS,'text-input'), **args)

def Time(**args):
    return Element(qname = (TEXTNS,'time'), **args)

def Title(**args):
    return Element(qname = (TEXTNS,'title'), **args)

def TocMark(**args):
    return Element(qname = (TEXTNS,'toc-mark'), **args)

def TocMarkEnd(**args):
    return Element(qname = (TEXTNS,'toc-mark-end'), **args)

def TocMarkStart(**args):
    return Element(qname = (TEXTNS,'toc-mark-start'), **args)

def TrackedChanges(**args):
    return Element(qname = (TEXTNS,'tracked-changes'), **args)

def UserDefined(**args):
    return Element(qname = (TEXTNS,'user-defined'), **args)

def UserFieldDecl(**args):
    return Element(qname = (TEXTNS,'user-field-decl'), **args)

def UserFieldDecls(**args):
    return Element(qname = (TEXTNS,'user-field-decls'), **args)

def UserFieldGet(**args):
    return Element(qname = (TEXTNS,'user-field-get'), **args)

def UserFieldInput(**args):
    return Element(qname = (TEXTNS,'user-field-input'), **args)

def UserIndex(**args):
    return Element(qname = (TEXTNS,'user-index'), **args)

def UserIndexEntryTemplate(**args):
    return Element(qname = (TEXTNS,'user-index-entry-template'), **args)

def UserIndexMark(**args):
    return Element(qname = (TEXTNS,'user-index-mark'), **args)

def UserIndexMarkEnd(**args):
    return Element(qname = (TEXTNS,'user-index-mark-end'), **args)

def UserIndexMarkStart(**args):
    return Element(qname = (TEXTNS,'user-index-mark-start'), **args)

def UserIndexSource(**args):
    return Element(qname = (TEXTNS,'user-index-source'), **args)

def VariableDecl(**args):
    return Element(qname = (TEXTNS,'variable-decl'), **args)

def VariableDecls(**args):
    return Element(qname = (TEXTNS,'variable-decls'), **args)

def VariableGet(**args):
    return Element(qname = (TEXTNS,'variable-get'), **args)

def VariableInput(**args):
    return Element(qname = (TEXTNS,'variable-input'), **args)

def VariableSet(**args):
    return Element(qname = (TEXTNS,'variable-set'), **args)

def WordCount(**args):
    return Element(qname = (TEXTNS,'word-count'), **args)


########NEW FILE########
__FILENAME__ = thumbnail
#!/usr/bin/python
# -*- coding: utf-8 -*-
# This contains a 128x128 px thumbnail in PNG format
# Taken from http://www.zwahlendesign.ch/en/node/20
# openoffice_icons/openoffice_icons_linux/openoffice11.png
# License: Freeware
import base64

iconstr = """\
iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAAG0OVFdAAAABGdBTUEAANbY1E9YMgAAABl0RVh0
U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAFoHSURBVHjaYvz//z8DJQAggFhu3LiBU1JI
SOiPmJgYM7IYUD0jMh8ggFhAhKamJuOHDx/+8fPz4zQsMTGRYf78+RjiAAHEBCJOnTr1HZvmN2/e
MDAyQiycOXMmw5MnTxhmzZoViqwGIIAYrl+/DqKM/6OBNWvWgOmvX7/+37Rp0/8jR478//fv3/+f
P3/+h+phPHHixH+AAIK75D8WMGnSpP8vXrz4//v37/9///6Fi4MMALruf3Bw8H+AAAJp5rQrOoeh
edmyZWAbgd77f/bsWTAbBoB6JOpbmkF0OkAAgcLgO8gUYCCCnSIlJQWmw8LCGA4cOAAOAyMjI3hY
gMDvP7+f3791+weQuQAggGBi7FPmrvnf3NwMtgnkt/Xr1//fuXMn2EaQ5TB89+nX/wUlJSDbPUFe
AQgguKleiY2/QIpBTv727TuKJhB+//nf/xtP/4ANrK6tBRnAATIAIICQEwUjUCHIoyjOBYGbz/8y
8HMwMXCzfmcoLC1kMDH3YNDU1mGQ4PvLCBBALEjq/t958Zfh0dt/DL/+MDD8BdkBNIeXnYFBhIeR
4efffwybNqxgEOEXZLjw25Xh2QMWhmi9BwwAAYRsAMO5268ZZMREGGSEGBmYgcEL1MMAcgwo3D9/
+sIwf84cBhHLGoYAVVYGxi/3wDYABBCKU6dPn37s1vM//3/+/v//20+gn5/9+b/7yq//iw++/6+o
qAhy0zUg1gH5HYYBAgg99Srsvvzz//6Tt//beSf+V/doBGkqheaFL0CKF1kzCAMEECOWfAMSY3Yq
PvF7X68FKCcCPcLAA8QqQHwB3VaAAGKktDwACCCc5QETE5ODjIzMfi4uLoRtjIwiQBe8RVYHEEDg
WODh4dkBTMLuQE1YDdPR0WG4cuUKw6tXr968ffsWxdsAAQTWAbQJq+aenh5wogJpBpUNzMzMGGoA
AggckshZFRmA8sXz58/BeQKY2WA5kRmkp7Oz8z8vL+8WgAACG3Lv3j0Mze/fvwcpBuaLb/9//foF
FweG2U9dXV2RixcvguTNAAKIAVQWaPt2oGgGlT4gzSBDNm/e/P/jx48o8n/+/PlraWkJil5OgAAC
OUDEKvsgWOLdu3f/k5KSwOxPnz79nzt3LrgIQwY/fvz4X1FbDbIgAOQVgAACxcIbFnZesFcEBQXB
AbdhwwYGNjY2BmdnZzANSypffvxn4OFgY/j5+TvI9i0gMYAAgkUJI7Dc+/flyxeGly9fMaipqWEE
9m1gTv329RvDjAmVDE52dgx6enpgvQABBIu7//fvPwCmB14Mze+//geXBwKcTAwn9q9kEOIXYNC2
8IfLAwQQcqIIOHPv9/o3X/4z/PkLzABAR7KyQMoCPi5Ghm9fvjJM7i5lUDbwYXjI4sIwK41LHBgG
rwACCLk82Pvq038GaQEmBi52iAEwK/4BDbx7cTeDEB8/w42/TgwhRt8ZzNeeeAHyAUAAoSTL15/+
/f/++z+DrBATw/P3/xgeAkunt5//MSzYcpOhJYyNQUNDowGorA9o82eYHoAAQjFgw6kv/yV4/zLc
v3WRoaRxBoOEtj/D2cXhPECNAcAExAbUiFE5AgQQenkAis/PrkWH/u/us3MGsvdBxYOAeD3QAIy8
DxBAjNiKJXIAqIZ//PjxYT4+PmtgHmEAJjiGhw8fMhLSBxBALIQUcHBw1AINbAIZCkqUuABywQZM
kwzAnMBw//79TcCy2A+f+QABBA4BoOuZHj169FdWVpYs3wPzKoOAgACKI0BsYCnDwMrKyg204xsu
vQABxAQtkv6FhISUEmuho6Mjw9OnT+F8UNsIWHQxAMsChtOnT4PaSwzAVglYDBgNX9H129raci8C
AhAbIICQkTCoACEWgAoVDw8PcKl17Nix/ydPnvx//vz5/9jMAKqRh9Vi9fX1YLHe3l6QuD1AAMEs
ZwUVi6s37CTK8t27d4MtBrW7QPj169f/79y58x+YCDFKP1jJCIruurq6VyC+t4/Pf2DUgAozSYAA
Atvu4Wm5D+QA47hVoLIWwwBQsVpaWgq2FIRVVVX/gxp427dv/79kyZL/Fy5cAIcIPrBh/QZwtZOS
mvoXmLDngDIOKEQAAgg5CmLsis7+v3XrFlgDyAJIWoIAkM+A8Q5ufYEqidmzZ4Md8PnzZxzVGQSD
wN79+8F0ekb6X2C92AyqRmFRAhBA6PnUVtuv99CVjUXwlAysicEKQZUuKJcAm/7AlM0GrmyBwYi9
ogWa+hYY6m+AxeDPt9cY9PV0GSoqKxjef/jGMGvGZGmgec9gSgECCFtBofvu3ftLoJQNjFuwI0RF
RRlwNRkQbQ4Ghmfv/jF8BlZaoKDjAzYnb1w4wHDx+lWG98A66s27zwwVZUUM8vJyakAH3IbpAwgg
rCXVxo2bnvr5+Ur9+w+pFX78+s/w8w+kvQnyMCsQs7GAeIwM91//A6r5z8DLAQwRFmDVwwnUA1R6
4uhBhl0H9jG8efacgZldgCE4Pp+BiUuc4fTNLwyVwUJMsGIZIIBwFZUam89+u84GrND+QZMeKQ04
acYbDGs3bWR4B/T5kbtcDLouWQycvKLgqp0FGJBGghdu2mgLaoDUAgQQrqL4BjOw/augogGuXNnZ
GBn4OUG+Y2RgY4W2l7//Bwb3P2BpB2oGMjKwMDMy3ARW+5nRbgwB7hYMTk5ODIVdWxmiQp0Yvj5b
9qy1uHIn0NyroH4dyHxYDgAIIHyVhdvzd392vvj4nwGYdhi+AKOBGdpY//vvDwPr348MX94+BVed
fTPXMry4tm02qMbLzs7eBmynrwOWgsuA/G1Ai77jCy2AAMLnAM75S1a/SIwJ3QTqpoAEzFO3N7Nx
CTEwMrMycN8qvLB9y8FAoPADmFna2tp/rl69mglyCKh9QExNCxBAjCTWOxKg+h6Iv2KRAzXDxYD4
ORD/ROoG4wUAAURx/4BSABBAeMcbSAHA4jUF2M2YDWo3sLOzM0ybNi0SmBBXENIHEEAkt4hALR9g
FTsX2PJJBFrIwMKCPSMB2xcMwI4BwSgGCCC8LSJgBSMtLi5+AGiRCsgyUPFLTJRt3bqVwdXVFRQS
oK7MX3xqAQII7gCgTyKBrZplIIuAwUlyFADbAwwWFhZgB3p7e8OEZYD4IT59AAEEGzKyBuVb9CEC
YsHy5csZysvLUUIH1Bq6du3aLdBACD69AAEEC4GXwHYAuHYjFqxevZph3bp1DCtWrACH2Pfv38EO
AHWQgFU0OLqEhYXZQM00fAAggGBV3DPYeA8hAEq0SkpKDKGhoWCfgywFWQ7shTLcvXuXAdjzBLeI
QVEpIiICCl1hdDMWLFiwCtirBdsNEEDwEQdgcBFsih08eBCFD2qOgTqloEYMaIwJmPjATTPkLvG2
bds2IY9sAHt/6rDhNFAAAAQQ3FWtra1biW2Qgjrvly5dAteTwP422HJQo/TBgwcYTTpgg+Y/zHIX
FxdWYGj9P3fu3H9g6LwHNYQBAgil8kEel8NneXp6OthyUF8e1H8HNddAoYGtPQlSD+3LM2ZmZoLF
Nm7c+B86XMcLEEBgmw10JazMUrYSbFiC23VQy0EhABreACa6/8BCBxz0oEEFbJ4ANmiDgXoEQOyG
1tb/VlZWIDNAvWxGgABiSSqseXiHMUju359fDEADGCQkJHAmwJUrV4LbiKDEBeyxgjodDLdv3wY3
19TV1Rm4ubkZsGXlnJycNdpa2vfAQwXAtAbsP2wEMu+AWkUAAQQSkwU1yUH4ypUrGK4HKQImJHiT
HIRBiezy5cvgJjko4b18+fI/vugDhdK/P//+VTfU/09ISACNliaCogWULgACCJQVHp+aYtQEToiz
9qK4fP/+/aBsBC5WQdkNVLiAshtoCBqU3Tg5ORmMjY3BjVZ8hdiZM2eBbQhGxhdPnv4DOrofZDSs
oQIQQOC8+OMXQw+IvvaSB16axcTEMJiYmID5oKY3KG/fvHmTAZjwwMUuyCGgQTRcloOMAeFPX34A
+4I2DKWVlUA9P38DE+oRoDS8YwkQQLCS8POhPiNfi/Rdm0H9ehUVFXjnE2QRsMvFAExkDF+/fgWX
lqAmu4KCArifAIp/XPXTm8//GW5dPs9gbW3JwAxUtGL5ik7ooOVvmBqAAEKuDXfwcLIwvH37Fm45
MHuBfQ2MY3DilJSUZIDUikxgi5EHsVC668DAffcF2Ef4/BVseU5hAYMwjyBo3ABUN7xEVgsQQMi9
jT97JjgZvHkDGc8E9e1BdfqPHz8Z9PUNGLS1QcEtBox3LnDZj2uw4hWwEfvyw1+G38B+BOsviEcE
efkYXgNzGLC/0Qn0/R9k9QABhN7duTRn/pyPIF/9/PkLWJ9zAC3WBscz1i4YUsPy0zfIAPuHb//A
vSRulh8MZ8+dY4iMjWX49/cfg6OjHYORiYU0ul6AAMKWdAP+/v23HpT4YAmQEHj05h/Dj9//wRYL
8zCBHXTs4DaG81cuM7x98YLh229mhqjEPAZpaRkGNSkWPuRhMoAAwtbhOwmKe2ZmYDwDLf8G7A98
+g7qG/wHxi2w5gPy//6HWPYOmMhuPvsL7raJAC2WFmQGdlCAXTfGbwzPgenm0YMHQHNYGGxsHRg+
M4kz3H71jyGlbGoOsmUAAYStSfbm3M3XDAIiUkAL/zF8+8nI8PM3pMMJshSMQcPGTJA+IiewCcEJ
7Dm9AAYzGzNktuHZrdMMt+7eYeAA9qKffGBmEPinx3DkNNDRTH8Yfoh4tAHzVjvMMoAAwhYCv6/f
f/Xv6XtgKgam5j/AugTUMQZZyMSImKwAWfQdmJnefQM1Jv6D50zuAH14/fFnBhU1VYY3r18y8PHx
M3zms2F4/EUEaDmk06ogKw4q3OAeBwggrI3SnprEqgnLz3aAesCgXi8fEIPLGuiEDIyJngVBFZ+l
jgLDbWCZIcgrwLDj4l8GbSdDBi52JgZ3/f8M74FZ/O2rZ7C2IrhHBRBAWB1w89rlAwrC0PAGdXlY
GRmE+BjBQQ0S+v7zP8MvoO+/AtPDDyAN6jPyczEyHLryHjyC9ub1awZhUQkGHVZRBnOJ2wzt5Zbb
Jj55AuqYngXlNOSSECCAcBXgou8/fnn16RcneGxAQpAJHBKgIASNmoMGgD8AE+QXYBR9A6aPP7//
MGw69prh8e1zDOZCFxiAjRSGkJCQbaD5JKilr9HzPwwABBAuBzBdu3n/LwuvLDCOgTng639wnP+D
TFcC8Q+Gv19fMnx5/5yhu386w9kDK0CWzAE269k3bdo0wc7ODlTkggai7mIbH0YGAAGEq2Py7/jl
J98klKW5+Dj+MvAxfWJ4+/opw707VxnaJq1g4BRUYOCT1GWQF3z9G2i5JdSXjOvXr/8HtXwZMZaD
AEAA4esIRLu7e+bu3Ln9JJB9xSh2+SwOPikG2AQHsPIKh3bDwRULsGiWB9aeB48dOxYH5B4FZRRi
un0AAYTPAWxQ+Z9Qvg2w0XIYaDGo6gb58g2aen0gVgXiXaCSmdjuOUAAkdIVAqlVBjWlcMhLgio0
qMP+E+sAgACi2nwBLQGoRw7se7gCO7uJwHZnBLBNyobcpqAEAAQQy0B6DNjkUAR6KAnYvIgFpWFQ
EwM0tgEackBu5SH3eUHNlNOnT98GBgpovPMXpW4ACCAWWsQWsPUYB/RIPNBjjjBPgVqShAZ7iQGg
1omysrK8lpaWJpB7kVLzAAKI6CwA9IAlECcBPRMDxBwgj4EwrgEiagDQnHdRURHD4sWLGbq7uxlK
Skrgcvfv3weNEaA0rcgBAAEEDwBQzC1cuNDO39//AB8fHwO5QzUUZgmG3t5ehoqKCnCyB3UPQHMT
2ABoQGTt2rU9sbGxZcTUN7gAQACxII26/AcGwndQgIACgB4A5MEHwDbrt2/fGC5cuMCQl5cHbkb8
g89aI8oAkBhoCAuEQWxQdrK1tQUlCVA38xm5bgAIIPRMeX/Xrl0HQQ6iNgD1Ljdu3Ahf2hQVFQVO
xvr6+iCPMOTm5oI9eunSJUgHDehR0Fjb8+fPwaMP165dA9MgPkgclFrExMRAXeRjwIhjJdddAAGE
UgYADQL1f1yBsbJdTk6OKtkAlH+zs7PBMY0rOYNiFIRBngIFFMiDoNQBKgNAM+CgIRfQcAxIP6hX
DCp7YAUqaDjHxsbGAJgdLuIrmC0tLa+tXLlSA2Tew4cP/8bFxXE9efLkH0AAYRSCQMWKBw8ePG9h
YcGPb5qeGIBtZRhsNh00/gByfG1tLcPSpUvBMd7f389gaGgIlgOpA2VF0HAAqFMMWo6Eq3967949
UM2AtUD08vLiAeK7QHvEQOtjgCmcAeh50Ey/FjDQHwIEEDbzuCQlJVNB403UBKCRPNDYZEZGxn9g
coePc7W0tPwHDc6C1iEBYwS8aAlkN2jgFbT+CNuQIzoAqQOmtG5YioZGKouTk9NP0FgodNnR/zlz
5vzfsWPHf2Dq6QOldCAWAQggbM1NXv9Q/9OggTpcq6tIBaAx1Pz8/P8bNmyAexxkPmjFJmzBJciB
oOFR0BQ4aMUWSA/IYyB5YsZtQdPpoKk0qOfZHBwcnoNGob/+/P5/2owZ/1tbW/8fPXoUZn8CA2Rp
HStAADFCPS0UXTbt3uM/FuDi/8+PTwzavNcYeqqiKa4ROjo6wENtoDF9cHe7p4ehsLAQnMRBox+g
/A5aeAIa+wMlfVAyB+VzUHIF2Q0agCSmrQHKVsCa5AGwR6QBbKeI37x585S8vLz49bt3GKrLKxiE
geYBszaoIAWtGQCtKboIDKz3AAEEMhlUglrCPA9OOxy8DCfvsYCn7EFTb8QWhiALlixZAsqP4NId
BCorK1GW9IAKO1DeB40zg0p0EBvkeJA9oPwuLi4OXoUDaj0SMyaF3EJUVFRUAJZhFgcOHlwtBiw4
rty6yVBXVc1gaW7+e+bMmX/v3r3bC+0qgpZ1fgTpAwggRqT2gI1D0en9/xgglv78/JIhy/kPQ5i/
C96JM1DVBmrmIk2OMVhbWzP4+vqCqylQTIPqeGDeZ5CWlmZ49uwZeGAdFLigwACV7KAaB7QaGDTo
CjKLnNoHZA9oDJWNg51BSECQ4cLVqwz1wALWztr61+zZs/8CU0QtdLIe5Pn3oNVKIH0AAcSI1iYw
DClZfOLVP22Wf39/Mby7e4hh98xo+FJlGAAtS9q5cydDQkICQ1JSEsPcuXMxqjVQqQ6q0kDJHJS0
QUkd5GlQAIDm0UClOmh0GTTKDKriQDFOnsch9j14cB8YgIJAs4QYTl04z9Bc38BgbWnxa+HCRb9u
3LhRCvU8qCv9GbnlCBBAjFgKQZXo9MwDj7lTpb69vccwr1gNPEkAyoegUAbFKmhcHjR5gJ4HQR4F
5WVQsgZNEILYoCYrKOmD5EGBAqveQLEOzKPgFIArqROaFgbJv//yl+E2MKmrK0sByw0BhqOnTjK0
tbQymJub/dm6ecvXUydPlgGVnoZ6/gt6sxkggHAFuZStrfb0f/oz/ER/n2GY1x4PLpSAfQWG+Ph4
lGQHimVQIQZqtIBiGDSHAAKgGAU1YEAxDcpCIE+CYhjUgIHI8eCt23EtDQItGP/4DTRI9h/o+X8M
j+9fY7AxVgWaxcmw/8gRhq72dgYfbx+GbVu3MWzbtiULmudB81NfsfUZAAIIX5oDNdviDCLm969s
tGJQVVVFSaIgj4Nmd0GFGSjGQYEBKshAMcrLCym9YV1gSlqUIK0/gb3+Lz//M4DWp3798R+ezR7e
vshgZ64N9vzOffsYJgA7UmGh4cDGzg4GNQ19hlUrFmfcuH51KS7PgwBAABFyGTdotqp76vIZWQl+
DLDF4aA5E5CnQRjkEJDHQSU3SJ4a3WOQp0EDvp+BMf3l5z8wm4kRkez//vvL8PzueQZBXlaGA0eP
APM+L8OqlasZEmPjGLZs3sygq2/IYGRmy8DPx8NgYaIjBKrucNkFEEDERA1oPX7Z06fPakEzVKCY
BuVpUOEGHY2k2mDHT6BHQTMhn779g+yLgI3GM0JWwoGG6n//Bub5GxeAofCDYdf+feAIuHDmLIOn
pwfDWSCtpaPHYGRqzSAjr8bwl4GN4cal4/uC/ZxdYaU+OgAIIGKiC7SbYQ0wf9eCCkBQnoUNhmAL
TZiDiVmKBFL3DZi8P4Cm84Aeh818gD3MCfEwaECcA9hS4WJnZPj2/Q/DjZvnGVgY/zFs2buH4dfv
XwwXz55jcHJwZLh46QaDpJIeg4qOLYOEHNDzzFwMX4Fm/+RRd4LORTzC5gaAACI2c/L7+fnX9U+Z
W8TOLcjw4w+ou/of4mFGREiCVheCkuq//4jQ+AddrffnH2Q66ecfyLJDYIUAXob4H+pvUALi4WAE
eg6Y74CeZwZng/8MXGyM4MV77z7/YTh/9igDO8tfhv2HD4Gr1XvA7rGRgSHDk2cvGIRkdBgUtKwY
FJWUGV594WC49OgfUA/QTqb/DNy/b3+fmGcgCEwFP9E9BhBApJROVnM3Xz0qLq0CXiXIiJQn/xNZ
bRGq0hiQZp1AAQlis4Irib8MX5+cAmaDfwyHjh4GN3hePX/BoKWpxXDl9nMGRkEDBhZxCwZeEQUG
VnYuFHMFuBgZXr37yHB6frD1mmVzjqHbCxBApJRYd989vnRDSFRagxVY2KE7GBTTyEkfFOuw/QxM
0Lk1ZmhJxsQEmnAEBiJUzz/QfA+QAZoLBPFBMQ5SCp4P+veHYd/ayQyeThYMf5mYwY2mA3v3MTjY
2TOsP/yYQVDWhEFc0pyBT0SRgZmVA6wXZIacMCODtjwzMACAfY5ffAy2SvOOamqqg1IBysIkgAAi
JQWAAstj54n7m+VlpRkYgWkWFDl//6PGPCz1w1begqZsQetLQROczEAT/v+DrEVlBq3EBQYEKIBA
+kFiIDlQVmAH5oPfQPY3YPE/d/kOhsnNmQx1dXVg80FtClC12j5nP4OIgjmDsLwZg7aaNIOGFNCQ
318Yvnz9zPDtyycG1l8vv+/duvzaxg3rQas+QbUAaHpwKzAAUMoCgAAiJQWAZl1u/Pr8+g8zgySL
IBczMK8ygh0LCvHfwJAANVJAc9pfvjFA5rGheZyXG6IOtCKNm50RkufBSZwRHDi//oECCVHPP3r3
n+HOiz8MB84+Z1hbG85QX18H7iGCWqCgwY/mrml/OX99eHp40XzwXOcGYOucAbJi9DFopQJ0dgg0
PQVqlf3CN2gKEECkVtrPw/0ds05cuDdLUkiUgYMFMl0MSqqgCdsvPyHzp8CaiuEbkA2a0P/5F5Sk
/4HV/IUmedA8J0iM4T+wifz7BzDGvjB8+/aJ4dzNTwzs/94zPDm/+sW61YtBnvsI7G+EgjwOnnzT
198DigRo6w7UvH1M6eQIQACRGgBfv337eu78rZcMz77xAz3EBE7qoOQNbqBAS3w2pn/A0vwPA/P/
XwzMwGT5++snhi/AfsGfH58ZDhw6yrB+x3Fgl5uPgZVTgIGVS5iB+/3Gu5cu3JwH9RhoNQson7J2
dnbeBdXzISEhi4HtjtfQadhz0Jj+RslwOAwABBA5zbYH146t26wYmuoL9D445j59+szw68fn/6eO
7Hy6ceMG4R9cepwsQM+BVlqz80owsHELAz0rCB5nYGb1YNDx8WDY32cFmmXdDp2yfwdJF4iZ2ebm
5sfAzpNQbW1tFTAQQJ6/AO3QgJL2P2rNaQIEECOZekBp0hwaU8+hee49NM8JGBrId/E6rY9Cnbo9
9mtlX04xkAlarXWbAfsKcGjjkq0F2NfwgY75g8y/Ah37/4U0j0GVAAAIIFpN/4A6UmG+gS6pm9fv
6YT2xZ/CJvMJuIcX2nKTgMb2I2gKQVljQa0AAAgg+s9/EZctWaBu+w1uBWHZQkKtAAAIoAHfPzDQ
ACCAqLZ/gZYA2PsUAbYDkoGNoOi/f/+elJWVTaNGDQACAAHEMtg8C+xtGgMLQdCiiRggzQcaPUKe
hn/06JEukCqE9lIpBgABNGABAJqvu3v3biDQcwlAT/rCutggjG+YDDTSxABZ8U6VAAAIILoEwMeP
H/nExMSSgZ6LA8asAciToAFUEE3qcBmoSbx48eIcYACWUSMbAAQQ1QOAiYlJFxijoJUksUAsDPIk
aGaIWitJQJ0hU1PTPCAT1Dv6Tql5AAHEQkkSvnPnjjfQk6AkHAwaFoPlV1JGeokFt27dAk+ogNbw
8/Lygoaj+KkRAAABxEJkEmYXFRVNAXouHpgHTSlJwqQA0CYl0KoRkB2ghROwgxdAg7DA7rEDkLmC
UjsAAgjbIil1oCfBSRjoQUlYrJKyu4oSAJo8aWxsZGhpaQHzQVsI0GemQJMs58+ffwjMCqqUrhcE
CCAWpCTNAUxi30GW0XLlFz6wY8cOhm3btjFMnjwZfMzSvHnzcFWVoBkqeSATNKH7lhI7AQII2aeg
c2zuiYuLKw1EAGzZsoVh1apV4CU1oO0xoAlW7GOHkAVToDkIYKTJUhoAAAGE7NPfu3fvPmphYaEE
Svb0SOqgPX+g6TRQeQKaaAWtCwJNnoLmH5ABbP0QSA+IBgFQluzs7GwGBkIgrsXoxACAAEJeJwjy
tT/QASvRHUBNcOLECXCBBtqLtGfPHlBehssdP34cvBcVOa8jzzCDAgB2lgGoOgTNUqurq/MD/fCJ
XPcABBByCgD1tV+AJjexLW6iFID6HKBtp9XV1eApcdBiSBCGrRwDeRQ22QKKcdDsE8gtoKl0EA3b
5gqbbAWxoatXBKHdZrIAQAAxIXUvQa2qt6CQhiUzagHQMlfQFDtkp9l/8PrA9PR0lGVzMM+D7AZN
qYNmm0H79EAYNgcJagaDWoKgQACpBwUAtFVIMLaAhWrUokWLDgL9aY4sDhBA6BN6H65evXoLFPrU
AqB1AKB1AiCPg2IcW6EGS+ogj4PUgiY+QB4H0aDkD/KwsLAwGIM8DZtuBwUItFWId+93dHS0eEBA
wJKmpiY7QUHBE8AI2QvN9kwAAYRe3H8BFoR73N3d1aCdDoqAoqIieAceNgAr1JDzOCibwM4mAk19
gWIZ5GnQuiHQ8hlQ4Yw8CQvKpoRahaBNUubm5mdiY2MZQakIlJ02bNjgAKxiQWXeL4AAQk8B3+fO
nbsXtsiBEgDyFCipowOQI0ByoJjetGkTfAuqm5sbOGa/gIfIv4E9C5qMBRXIoKwCksM2Aw0KsNLS
UmtczfWqqqrslJQUGVD75syZM+B5BWCqew1tQzABBBC2ITJr0M5wYtbmkQpAawFBB/2ATjg0NDSE
rxlcunTpf2ANAN4MDtoUfvr0afDiSdCCSdAebXxuAZkJVP8AVDOiHebH6Ojo+AHoafiud9CJksAs
AFooCVrmAtrfww4QQOhZAFwQghYoApMoIzUbRKDkfvToUXBDB9S8BVV/oGwG2g8Mil3kTRWwKXhY
aY+vRsLWKgTFPDD7cTo5OfGDVp/DaiGQWba2tn+AKQ+U/ME9NoAAwubDj2fPnr2sqqqqR60AAOX3
9vZ2sOdA+5FB63VBHZu9e/eCCzjYNhnYchpYNUxsVQzKBlpaWjJIrUIWYEx/Bq1MBwUkyP5jx46B
p9aAnmeBDuGDlsT/BQggJiztAuH1R1/pggoiaoH6+npwPgYGLNjzoCoRdAoYKO+DCjdQSgB5HpRK
QDUBqAyANXyIGbQFLcbq6ekBtQqZQbEvIiIiYGVlxQQKmMvA7NDX1wcuT0CbMYABAjpXCzR/CFpY
/RcggFiQ8j5/aknt6Rt//FTu3z8CdgRoZRilDSLQSnBQSQ7y2Pr168GrQUHJH5a6QJ4EeRbmaVBs
geRAKQPkMWJSISiWgS1CXwbI0To/gO0GXmDT+j+wgGW8AWxunwQWfpcvXwY3xIDgALTh9BPU9gEI
IJDp7EH+phFvlGcuuAk6ahQ0t8clzECNmgA2fg/q2Hh5eYH5oPodFKiw2AbVBqDVZqDSH9bYAaUK
UN6GLa0jNhtAW4VvJ06cuFNbWxs01cYMOnOEA5j3QRsugI2obUB73kHHE8GNHYAAAmUBaZDnUfIB
Bx94Cz65LULQ5ghQzIMKPNCZlTDPg8RBHgJVg6DWHSgwQNUSqK0AW2oHinVQYweUAkhZfAVqIQJb
ernAVMsbHh7OCyxAmUELpa8A+x3A5P8PtBwf6HnQ/CJoiu0jdMKFASCAQKb/lf4w4S5KALDzMGw/
fBW+EozYer+hoQG8Ehy0aBpU74I6PKBDtkAAtBECtDQW1swFDW+B2gmgDg2oMQTyAKjBA8qroBQA
a+2RMlYITPJ5EydOOAEMBNAJUwwrli1nEOTn//fu3bs/wOy1kgFywM8TBshyWfBkLEAAgQLg+fJ5
i3JR2sesHAz7zr5kILYgBK0g3b59O7hkB7YkwV1bkMeBTU+4GlAfH2QeqMsLqglAGLScFhTDoGUv
MjIy4PIBFPsUDLWxOTu78gMDjvEysNq7dOECg6aGxl9gO+EfMOBBjQNQRIMaQfCYBQggFmgv8Pyz
DS6zpAL2pIEDgJmd4c03SKsMVHrjcgwoX4GWvIPorq4usBjIE5mZmaATVcHJGORh0EgPKDZh/X1Q
OwBkNii/g2Ic5HlQjQDikzugCuq/fPzwkUFdQ1UAHPvAvC8iJPQPWPiBlsnPYoCsOwC1yz8hrxkE
CCBYEfv6zr13C1UY36d9+w8s+ZmYGVi5BOEnJWELAFCMgo75ADYzwckX1MgBVj1YOzqgAAGtJwZ1
bkBJHtTFBeVvUMyDltCDaEo8D1sqr6yizMDMxMpw7vIlcOzb29r8mT17zl9g9gR5/h567IMAQADB
ShhQgXBtR69zFkyClYOf4cWrd+DSGh2A8jiwcwH2PGgrG8hDyJ6HrRwHeRoU6yBPg2IelFpAYqAA
BVWxoHY+yPOkLppG9Tyk/Ll29TqDsAjkAKmVK1YyiAMLvqtXroEKvwnQvA9aZ4CxZhgggJCLWFDJ
eEjm/x5w/cfMxg0sCG+ACyhkADpHy8HBgcHPzw8c8qBJD2SPg1INqFoDeRZ24hBoTB9U2oOGv0Dm
gTwMSvIgz4NKfWI9Dzsi5z/SyrT///8xXL/1kMHU3BQY+8wMJ4CNravAOl9ZSfnP8RPHvgMjELSc
5inUfxixCRBALGj9gPvL+ssS7YrOrQKtudt//jVDMbCBAkriIABqURUXF4M9BurnIydB2AgOyPOg
wg1UrYH4oNhB3vEJ8jyoXAF5HlR342vo4GsEgpfZAhPzu4/ArvOHVwyCupA5g1WrVgIbRSpANz74
//DhoxkMkPVEoKSPdU0RQACh2w5qH58SfFh56p1cq9kPBl5wCw12YhrI8+hNU1CsgzwJ2zMASvKg
LAEbVIHtG4DV56DqChT7sH1BsPKFlGUKoMWQn779B680u3HrDoO5oQHYnIPA9v6N6zcYXBwdGRYt
XPgVmA3vI8U+1kYNQABhC/5nG9furLIrat8DWtgEC4CAgACsngfJg2IctG8AFPuwsT1QXQ7yOKhw
Q97pCRvXA22YAJ2LRIrHQWEFOlEEVCyBzlB59/E7gxDXX1grkGHdmjUMOsB+xof3HxiuXr26HFrn
g2L/O66JVIAAwnqUDRBfvrnYsg/UInzw+BU4NkE9N3TPg5I4bPcXyPOwOh20FQa0cww0IgTZECUN
LPCkwBh0JhPoiBtS6nrwThGgq95+hhwm9OYr6Iyfvwyvnt6GT5ftPngAWN7cAtqpwHDrzi2GiKhY
FwbIAspPuGIfBAACCFc78+3L1z9XiLC//rfj6C2MghCUl0GFHSjmQUkeVOKDyglQlQYa8QUdmwTy
KD+/ADimQakAlPRh/X70EyLwl3yQWActp38P9DhoPwFI56+fPxhkRDmA9nKDlW1Yt57B2MgE2MZ4
wSAkLMVgaGyuDh0m+4FvGh0ggHAFACjEbm6bmph18OI7BuTd5LB9QqB8Dsr3oMAQEBAEexoUw4KC
QuCkT+kmCvDxLX8g55KB8vubL5DVprDU9+zBTQZFYGCDwLbdu8C1jaqyCrBtcoNBQU6KQUddEWYM
3g4NQADhcyGov3xY7P+5j7ByAGL5P/BpX9+//wB6kBnsYVC7H1SwgVIBufv+0D3/Hhjm7z//Y3gH
Su7Qw7pALgDvRfj7k4HpzzuGNevXMazZuJFhy6bNDJampuC+B6htISElx8AvJscwceLkIEJ2AQQQ
E/7Ex3Bvz+bV9aA9Qoj6F3LSGMijoJIc1JSFleiUbpuB7QoDndX0DohBB4jBAgTkcdDaZEHO/wwf
XtwB2ivOcA/Yuzx//hywN/kQmPUUge2N2wzSMrIMmmoKDGqKUgzWdk7VDJDzgHACgAAiNNoA6g2d
BvbZ/wGTHRMs78ImJUB8ap0jAj4DEJTXf/4H7xBjZEDsPwB5nIcTkqq+ASv/r5/fMVy78YiBA1i2
3Lt7l0FPW5fhDpCWkBRnkJFVYmDlFmf4+IMDWKfzgsb2QX2Dl7jsBQggYqLs/smTJ27Beoaw4/xA
+RxUqFHqefAOMWAZ+/LTf4ZXwFj/CvU8eA8B0OMivEwM3KCTvEBVKPM/hif3L4PPtr4PbIx9/gRs
agNbl5Cjyd8x8AnLMnAKyDL8ZeEHNvmYGPh4eBk8fYK08dkPEEDEBMCn/Pz86aBSHzYZARutwZXk
GdFoXB4HD0EDC7kXH4DJHZjX/0G334D2FIE8DtpDBB7t4WIEn5cGKndAVfI9YJJnBAbC08dPGJSA
SR80qvSHkZNBXFoR2BsVB3qcA1hjABsBn9kZotPK5iGfIIcOAAKImOgD+fwmrCBkgm57+Qvd3QGq
n3/9hZQN4H4T1GNMDBB5kEdBu0ZA2yQgZ7RDxL8CExSogANtkGCEbuIHJSbQ9jiYGlDMgzZn/QTW
/Rxs/xju3boMNucBMPa/f//G8ArYyVIwNWN4+OQlg6qaJugweYb3f/gYPr1hAqaW/wxvvzAzHLsn
CBoyB7XlsZ7hCxBAxAQAKPW9ffv+CwMb31+G33+ZgB7+D94OA9shBk4I/xHbZUD7BpihGynAaqDi
0L0S4MBhYERsjgKZwcsJ2jEG2VnCycYAPikRZAc7KyPDb2DA3n/2DVzt3n94H7xd7svnTwyyMjIM
n4DVMTsnL8NvLjmGrwzAzhUjO8P5+8DAevGPQYyfkeHHf3A/RhRXAAAEELEZ+M2TVx++cQn/5mJi
YQNvZwPV0d9/gUptSEkN2hYHa9b+Q/IYOCCQdoGBNleAT2UESjAz/gemCkbwJguQmSAZkOf/ADWA
jg/8/x+y2eoHMIk9un0B3Oh5/voVw3dganz98jV4y9yFG48ZZJR1GfiE5BhOPeIBFn7/wZuyQJEC
akCxsnMzVE7YMQWYDTyxbZ4ECCBiA+Dz0SOHD//h1XTn5mFBKaFh9SUjUqZnxkHDCjdwfQ4MOFCb
G+Tx/9CtNKAN0UyMsJ0nEFNBSfnPr+8MrAy/GK5cv8vw9dtX8F0+wP4+OEX8ZRFkePhNjuHtMyEG
Lj52BuSeNShSmJhZGR59l3GDDpljrC4FCCBiK+5v3S2VS379/A452hLN88g0uTUBAyx1MEK23cBM
/fkb2Od4fpHByMiYQUpWhuHLx88Mn4D9DkkJKYaDl94xvPkry8DGK8PAzsUL7lyhjx0oSTAzaCmA
F1IIYLMbIICITQGgOvDZD2Do//uHKAj/w/sGiC2zIDbIIyAOEzCJs4L2D4JikhGRD0AeBJcTwFj+
9x+0fxBC/2eA7CeEtDoh+wh/AmP/9+dnDEdPfAGP+LwGdr6kxCWA3fPPDP/YgP0NUXkGDl4RBmYW
drCHQQWyALD2V5dhYlARhxROHz9yMJRV1oFOjcG4wAgggIgNAJCL3v0COgYUAP8ZIHe2gU5VZQWm
bw5WUOEF3SzJAKEhSZ0RvgEStDHyP9QkRkbYRktGaEqCjQkwQrMSRBzY+mIwt5QDjzBPmTKFYc++
fcBW3wMGG0trhgVbrjAIyZkw8AjJMDCy8ALtYGJQFmNk0JAB1h5sv4F9lW8Mz55+Ae8h/A10t6GJ
RRKwHFiKvssMIIBIacW85f7/7r2UwB9BLtDmRQZEgYdcXcCqSPDuT1BMQ/cQM0PTOQsrKFVAPAra
LAkrI0ClP6g8ZWOGlAkgvadvfQMPxIDmC0BrB0FrCDrbOhhWrFjJwM4rycAhoMDAySvAYKr8l0GY
8w2wlfiF4cndjwys/78xPL5x7OmCOdMuALvqL6HjgfuxNU0AAoiUAPhyeM/6rRra+jHAJiB0Hz8D
tIUGSQnswBTBww6p70H7i1mQCiRQbQHaHg9K6qCzekF7C0E0qBAE6f3C8B+8hZaXiwl8aPCdFz8Z
7jz4AG5xgqa4QR0t0PgC6Hqlg1d/MEgr8TIYyf1iEBG4B+z1v/uxevuq6+vWrgbt/ngHHQR5Bh0Q
gW2kfMuAtOkKBgACiJRuG3gZ3ZHzj1cqyUuBW2mgqgrkSVAqAHViQB4CbZz8Br0h5e8/SMBwcUCy
BUg9JysjvO0AKi/AbYr/kOYw6BDblx//MTz98B9YwH0BtvNvMTzfUwjOAqBRaNC9evWds4F5/O+X
OzcvX3v58uVd6JDXS6hnn0E9C5v/+0FoDSFAAJGSAsDL6MR5fgA9D7l35jWw7Q5L6qCmKg/QgxIC
TPCNlKBTtsG7SH9B1IPO/PgBPRIYVEWBYh+8dfYvpCT9++83w5X7Xxku3vkMLPheMDy/vpPBztaW
wcDAADys3tPT8/Lq6ROg1SCgbXTHGSC7SGFzfQS3yWIDAAFESgCAC8L7z78x8IkAW1kCLPDqCpS0
wUNVn0FJ+h+4kQQ+9/gXxHOgghMUUKB2DbhQBLXy/oMkfjH8+Qls4X36zPD+/QeGs7c+Mwj/Pv/r
4vq512/evHFfVFTU0ts4Txw09L5ixYrXJ06cOMgA2T0K2gYP2gz9gdJNEwABRGpX7u339w8f//uj
Ivv8HSPDp++QZP/tNyQ2QdkA3A+AlvL/oS3Bf/+BFSEwdln+/2D49xtYlX7/zPDzG7Aa+/WJYee+
wwxb95xm4AU2V+7dvAHaGwyawQUdjfddR0fHH3Sjwfnz5790dnZuZoDsMgXtGb4JneKieMcIQACR
GgDfZsyas/KfiEUJOw8rOPkyQmMV3BZghJzYwMr0D9xyY/jzneHXj08MX4F1NqiEfvboHsPaLfsZ
7j5+ywDeWsspyMDHy/b/9c1ds4Gl1mGg+WegJfYPAQEB5cbGRsZp06b9XwEq9iGevgid4PxI6C4Z
YgFAAJE6dgXaNOC9aNeD9YIiUuDSn53lHwMHy18Gpr+/QPuHgc1U6F5iYCwfPX6cYe3WowxMrDzg
uUZWLiFgo0WCgZVbBDz19mZ/4pb7D94vgObnl0jjd+zd3d1P//79K1xVVdX379+/N9CkfxVawv+i
1sZJgAAiNQWAmu+v+FiAeZX1HTAZfwG3yF4Ae2QfXj/4smTBrKe33/Gpg3eFg2KYR4xBTCcQHNMs
QA8zs3ExMLNyMsh8nf96+ezp5VCP30ebsGRUUFAIAhZ8wgsWLHgD9Pwz6MzuTWgJ/4uBigAggMgZ
znnH9Ovjr80r1jyfMqnv3OfPn99CHQaKwe9WNiZ5v1VTtUCHgIM8zMTMBll3AxrYYHr+f2uPPWi9
LCi5X4OO2aPnYzbQjpXU1NR/Dx48aIZmidvQ+pyqngcBgAAiZ/gWtA7HEUrD5t3eQj0DSiGWDkWn
d8NOpYOB55vc1t6+82YBNCm/wjFcDXKPILD0f/r69esMaODcgKaAj8iBRa0sABBA5G6f54Y65gcW
j4iJi7KXq8ceB19kKP15Nr7kjg5AoQZa3qLHANmBDkpZ16EzPDTZPQ4QQORkgf8M+Hdtvnn5+udy
B6Yz2St70uoIJHdsgcsEbdR8g3r8HaHJDUoAQADRas8baPBBCuqRVyR4ABQhoJlOPqgeWAsPYySH
WikAIIBotTsKFHt3yND3F+rhn1D2b2yepyYACKAhcb/AUAdycnKijx49ej0Y3QYQQCyj0UM6AK3H
vnbtmjILC4sRKyurAZDWB2I9ZmZmGdicEQyDJtJfvXr1DKgHdO7MF2pdjEEtABBAoyUAUqSeO3dO
gIeHxwgYmYbAyDMAYm1QBKNHKjImtBAAlABAa+MuXLiw2MfHB3SI0FtcRzsOBAAIIJaRELG3bt0C
5VBDJiYmUMTqAyNVF0gLIkck7Exv0GwvNc4GhfedWVnBK7iA7ohNTExcNH/+/OMMuE+QojsACKAh
WQKAIvXSpUuyXFxcoAgF51ZQEQzEirANV6A1C8gRTOnRvpQA0AJR0EIy0GHv9vb2oEtAX1Cy2Zua
ACCABlUCePHiBbesrKwhMKJAOdYYGHF60IhlJbcIHiwAtJwSVBVs2rSpMD8/fwF0RG/AT/ACCCAW
euRWYMrXBOZAI2h9qg+NVDH03ApaV4pv0c1gBaDVkqB7aEFHzYNORgAtJAJdLADaJQUazIdt8QZV
BQ4ODqA1a6C77b8TGBWhCwAIILJKAFCkXr16VYyNjQ25waQHjGB1WKSiF8MDWQRTC4Dm60ERDTrk
ZNasWeBiHQRAuz7KysoYsrKy8N5FAlpODyoFzp8/v9TPzw90ENqbgS4FAAKIBUcEMwEdZgX0TBe0
e8MNikBYhMIaTEOpCCYXgJbdgnbAga4HAR3tA9rjCA0j8C455CtFCAHYwlJtbe1oYINwwWBoEAIE
ELYLpkDlL9CdfPLHjh07JSEhwYZvx9xwBKAtD6CDbUA5HHTQzbRp08DioP0dkyZNYkhOTh42DUKA
AMJW2YKPcv/06RPfoUOHzoACA3mR/HAFoJ0HoLr88OHD4MifPXs2+EIgUOSD1qWAdiGAGnLERD7s
jCvk01FgJ6SAxEElgbS0tFlvb28YKLMRc/YNrQBAAGFUAdDbFkFj2R/WrFmzzc7OzgpU5JO6g3mw
AVAEgLamwzYtgiIHtp0FtMIatOcXtBES+bQX0EKkAwcOoOwLxBXZyPcEwjCIj5xxYGMMoHAEhSew
BADdvQVa7AAK7x8DES4AAYS1EQhdUg46zVl33bp1U42MjBRBy9PIvQFqIABoExeo/gZFOqjeBh2b
AzqlDrSkFgZg13rBLnSD7YkE7X4D7XoH3XyJL8Jhm0BBy/ZBCQzGhsnDIh3WIIadxQhiw+5ZAzYq
lwUEBBQMVIMQIICwNgJBdRIwEYDmPF/vBQIgO4Uep2ZSCkCbVUFHkoAiG3RoBbCnAt6Z6+PjwxAT
EwNeYAra0kRO6x+2+R1WpIPCA4ZBRTss4kEAFOGgiIZFOPJBnKDIh+02Apmpo6MTBWwQzqd2g3Dt
2rWcoqKi7MCq5hOwe41z6BkggHB2A6EnCkoDsdHRo0cXKCgocIP2gVJ68ygtAOhIBlCdDToXBrRV
s6CgAHwIJ7nXQ8KKbVgRDsvZoMgG9fFBbQFQuwjEhm0DRz7uCdTnh20PhR0JBetBwbrDsKNjqN0g
BCb2TBMTkwZgqSICtBvUXf8PLOm+ysvL7wOGU0p8fPwbpJ7eP4AAwjcQBFqAA1rF8BLYGzgOTE0u
oAClxk5IagFQfzw8PJwhKCgIfOwsMNWTnKtx1eEwNqx4hx1uBDvgCLYdHnacJag9AcPIEY9vDASU
KEDVDzCCzCZOnBgCGiEERgzJI4TQRiSzoaHhNFNT04S0tDRW0FlFoARpbm7OePnyZV5glegPbNR7
Aruuuc+fP58DLf1/AQQQzgSA1Bh8O2/evA3u7u4uIM9TY28gpQCU86ZPnw66bIXo3glyRMOKcljO
BuVoUOMPVH2ADlkDHfEFakMA++vgfj6ozw/SB0oIsLOUQIEL6haCIhA0wgeikTeDEzvwRekIIbTb
zqaurj4TiKOAPRcW0PEloMQHWk8Nqg5B7gFWMaBRSmZgKQ6KPNCarp+ghAMQQIRcCFukpbts2bJ+
S0tLLVBjEHa501AYuUPvjoGOKwIN6IAwMEdgRAao8RcREQGOQFgVgNyaB+Vo2CEYoEiHnQkBuxSX
nBFP2AghMLIWBAYGgq5DfUtMKVBYWOgKtHtzZGQkE7AtwSIpKckIa+OAGr6ghAyK/BkzZoCOdfoH
jLsZwEQB2iUEWqYFag1/AwggQlkZtkTpNbD+2KOvr68FKv4Ge28AuZUOammDLgIGHfQDO10I1LVD
BqCtF6BhXNg5+MjTwrD6GnY7Kqw1D8LI9TslQ92wEUI9Pb0EYNtlKTC3HoN2DXEW90B1icASaFZU
VBT4wCLkk59BpRdoAAvU4wF1e4Hs/8CcvwMY+aCl5YLQOAUfJQEQQMRuFH6/aNGi/cAGRAzQoUKw
Ix8Ha44H5XSge8FHRoIOMwDlVFBggA43gwFQ9w90tT3oiEnk1jm2xho6Rk4c1JjjAOmHHZYILIFa
gQkgGBjRv9AbhNDinhWY42uA3dUaUMIFlsrgHWQwAGpUgo7wApUooAEs2CAUMOH/grbrQBjUgAGZ
/Q8ggIhJAH+hgxTf9+7ddUdGRsYMdizOYCoFQJEPyu2gIzJBI3pKSkoMLi4u4HvPQUd2woCWlha4
iwg63AU54tFzPKzIhyUqbA1HWDVBjURAqEEIOhoUSLED3T8Z2F5JAs2cnjt/Dlx9gA6rAw1agfwD
mo0ERT5oTxVo/gJ0zzuwRAB5AHTkD2j1PmiZ8WdonP4FCCAWPEPEoP4eb3SUY9J3ibjGx+/52bdc
uckQ/AXSBQLVewPdGEQexgWd3Adq9IC2E4HugwYV+6BzHGEAJgY6zgi5yIZFNnp7AUbDqhPIMQmI
kTzkrh1swIfSRICrQQiLfNCwMTBidUE7Bt3c3cEnBcDAnIXzGXZs28HwH+hufz8/8FZK0IWcoHMj
GSB3z7yGRv5HaPUCKmH+AQQQC1qDD3QcOV96VlTPE664yM//xBgfg5M+sJ/L/h6YJIQYdh+7wRDq
xQ926GCYDQSdXgg6px6UIzw9PcFFPbDHApcHRdTmzZvBp5gin0qMbSQPNl4P4sOuhocV0bC6H1T1
wc7GofbQOMhMUCkgJCQksnr16srQ0NBKYOSDimvQriye6OjoBGAjUR7ov19AdfABmWWrVzKcPH6S
4Sewd8QDrEZAp7aCzssFRj6oNzEJ2p0HRfwXaKICVQPgYg0ggFighvNlFOVvvc0YZv77Pyd4LwbK
anRGoGdZOMA7nvaeeczg4/gd3BWDtXwHCoBOZATduGJrawsu0svLyxnOnTsHlwctygDleuSiHHly
BuQHGIaN6sFyP6zBB/Ij7MZ45HO/kBt/1FzrAGsQAtsmKcB23kpgewB0KSMjsHuXAaz704ENcR7U
yF/NsH/vfnDjVglYDYAOcAMd0yssLPwNKDaXAbK95hU093+CFf2wqgUggECuBu3ikOHnZfA0Sz00
4ScDD/Y69t9fhl9f3zB8fX2LoTpWjcHKRAvc+KB1WwCUw0ErbUBHboP666ChXdAxvLBxfFBktbW1
YbTsZ86cyZCamgofwkUfyYNhUHUGy/WwuhgUwbBGGQzDunrIgzu0WrkEGyEERtIpR0fH6IKCgqT4
uPhYdQ01EU5OLvilEUtWrmQ4CAybN69egaq+v3///Pm7b98+UAJ4B9S/mgGycRx0bCjo0FjQLjvY
2el/YAkAIIBge5FAFzEoA7FVQMma/nf/lLD67M/Pzwzf3z9k0JP4xFCR6gzueoBSK7USACiiQBfK
gCIblENBkQ27OQPWvQEdQwqKbNDp+/hGCIODg+E3dIAiHnYvC2jmDzThA+LDjiyHHYIFq4NhGDni
kXM7PQDIraA2zbp168+7u7tJamioCXBxcXPAjnpYtGI5OPLfv3nLoK+n9xcEDh8+/P/OnTvPnjx5
soEBcnrAIyh+AY3878iRDwIAAcQCLexBRwmBtiD+2tATkhhd2Dv9MaMjF0YdxcIO3uh66tZzhvcf
P4NP6oKd9E0uAKV0UGSCIgY0IwdrdIFGrkCRTSoA3UYGGhqG3U4CimyQ2aC2AYgGBSzsOFdQZMKG
cUERDvIPKMFRY3CH0owAsvPmzVsMAUGBhlISEr+Bkc8Ki/yFy5YwHNh/kOHDu7cMBnr6f4DhBY58
YO/gLjDyQXUeaFMx7MzcV9D4/Y5c9MMAQAAxorFBZ8yBLunSi80unfaQPVIErSJg+P39A8O3t/cZ
fI2ZGeKDbMClACgRkBJAoFwJGnYF5UJQZIOOogZFHHK/GHTlA2gWz8PDA9yyB/XniRnbB0UsKIJB
RT0o0kELWkAYFPmg4h5U1IPMh43mgSIcNHoGinzki4oGIuKR7xXaC8zdoKFoSdDIKycHA/QQHYZ5
wAbeoQP7GT4Au7z6unp/gHr+AqtIUORffvr0KSzynzIgbr3+jF7vIwOAAMLmO1B5CxpW0guNDmx9
KV6Lcubevz/AxtLHpwxsP+4xzKzxArcDQDmXmC4hqH8KGmsHRcSaNWsY5syZAxYH5T7QGeOgG6ZA
/XdiBnuQu23I3TdY5INyPigBgDAo14NKA5A62A0VsIgHYViuJ3UcnxaR/+3bd4YdO7YzGBgaAds4
kgzcnJDMBTqAYu7ChQwHgdXfZ2CC1tXR+QN0Jyjn/wOG6Vlg428zNOKfMiC2FYNa/T/xHSgBEEDY
Yu0H1JDfq5euL7K1vZXNaLrYD55imIG5g52X4dNnbobj5+8wuNnxEuwSglqooBwPKupB9yyAgLq6
OngaF7nLhmtYFxY4sEiGdduQaeSLqWAte9iULayBB8rZoFwOyu2g9gUo8kFuh1VjtO7W4pq3giRm
0FHM34Fd1k0MVpaWDBKgkpWDE9xCA3Xk5wJ7O4cPHQAdl/bf0FD/79cv3/+ePHXiH7CRfOzli5c7
oXH2BGmw5wu0r493azZAALHgmQoGpaLfhw9f7VN56vJcLnBb+p//bOAz2ZhZucAHX+w5+YjBxkQd
5xWroGIX1E0DXWUCatiBWu2gC7RA3TNiFl8gT8fC6nQYBkUsSAw5ASAP4sDEQGbBJnBgK39gkQ/i
w7p4lDbuSF0yCTtg8Nfv/wxff/xl+PDpK8Pxg9sYbGxswYcBgop9kPyP/38ZFsybD2z4HmT4A/Sz
vr7e35/ff4HOz/h/7+69Y69fvd6JVN/DGnuwyCe4BxEggPCV23+gdciVO/feLbjTa/HAu2Rr2+d/
kozM4MYgH8OVR88ZHj97Db/2BXmxyNatW8F1OAjExcWBZ97wzR8gT+Ag52RYLobNw8O6bLAEAksw
yO0H5BE62KgdyH2g3I5c38OmtglFPrXWwzJCT46DHbf5+88/8JF4X4F+O3pgK4M1MOeLiokwwHp6
34D+nD8fmPMPHgKfKWhhYQlqzzCev3D+77lz53a+efPmKDDMnqDl/K/ERj4IAAQQMbOBoBQFGhv6
sbXH+1VYybwZLxj0WZnZeRjYuIUYth+5xaAoJwmOGNhiEdDRdqALkUGrdEDXbBAzXQuLdNiiC1gf
Hbb4AjYsCzu2F3ZgM6ENKOgDOrArOZHre1oteIY5A2T+j98Q/A96NvDPv/+A/vvD8PHLV4ZH148y
uLm6Aksnfngm+gRM9AsXLgBHPsggcxMTcHg9e/6c6ezZsweA7alj0JwPi3xYzv9Nyu5jgAAi9tRc
0AgS6MSLX6t6khKj8xqmPWRx42PhEGA4eOEWQ0IApM6FzQ+A7kjEt1ADFvGw4h15cAaW40HisEkY
WA6GDcXCpmOREwGs/sbMzYjZO8yJH9pEPiP0pEDQ6X/gIxL/wU4U/A8+Dfj3b9BheX8YfoCOPr53
msHezoaBm4cbHvnvgI3WRYsWMhw5dJiBCajRzNKMgYWZheHalcsM33/8YRQRFfsKTABvGBAnBcJy
/m9St54DBBAjiWpB3UTQ2S96EQkx3Q/Y45S+vr3LEO8kwBDkYQ7uEYASAa6GFPJwLKyIB0U67BJN
kBhs/B2Wa2Fr7GBj8LBIhyysZMKYxcM35YpMUz3SGSCRDiraYQcBgxMBMMJB9Tz85GRw++YPwzeg
v5/dPgFs8JmDqyYODkj1+PrjB4bFixYzHDl8mIGTg43B3sYe3Ja6desOw2+gefwCggw83FzfWptq
QRsULkO7e2SdlAgCAAFE6kD+b6hln65cuHRGT/qpxncea6lXL54xOJrKwxdCYgtkWB8dlLNBkQ0b
lQPRoIQAu0QQ1B0D1dNCQqA7dEWQWut8SMuuQPdssqHM3eObv0fG1MzlsMOTwcdhgs4J/QmJfNDx
9yD8/Tfk7G+YeuTI//DkAoOdnS3QT6C1FZCc//ztG4ZFCxcxHAW2lziACd3F0QnYTvjDcOPmbWAY
/WQQl5BkkJGRZZCRlmI1MTFh3rdv7y5oO+0XuUvKAQKI3BABDf2BBol0NdQls1g0SvwbknQZzI00
wddooDf2YPU8YnQOMQYPm09HXlGLXEcPto2lIGeAzjr9CT0zHcT+BT75Fpg7oPU7NqeCMwAw8n98
/cLw7M4J0A13DLygYXQWZgZxYWGG+0+egIewjx45wsAJTNzOzi4Mf//8Zrhw8SIw4/xlkJaWZJCT
lWOQkQVmNB5+0DUmf50dLE1AVTMw8r+Q6x+AAKIkVEHtB9DyImNWFobQjPLJSbnx7sBqQAKcU5Ej
DP2CeORVtbCiHrmIH5SRDj/iGMKGHIH8H3zOMy5Xwq5QAB2qyQwsPH///MZw/tR+BiUlZXBiOHnm
NMNnYPX3BZgoPn74wPD502fwnLwtsCsICi/QzCbo2HQxcSnw5JeCvAKDvLw0g7CQAMOf3+CdTmfs
7OxAYzSvyD09FCCAKA1hkP9A65GsgUV34PHjJ6JAq1NAfW1YNwx5QwX6PDusBQ9q5MH64oPhbABY
d+3PP8hBwKCGHOj6hp/QRhz0VHeMiIcc9s3IwAY6RRVYqrMxQY6C//3rN7DE+8pw8exhYOQJgi8I
uH7zOsMXYCkIvnkNiEG3IbABw0JPVw9s+K1bN8CXFcnISDPIy8kDc74cg5gE6IYmEQbQOZzfgI4C
jazu2Lwqpam+cjUwAXwix68AAURpaP+DTjZcBjbmDt27dw982xLyTciwljlshwzyxAtsxo3Y/jit
Ix3cev8LOt6ageEtsFB99ekf+BToN5//MXz4/g/coEPv3oEii42ZEXz3hygvE4MwDyP4PHEWYOSD
unygYvzPr68Ml88fAUaeADjSL127DOwh/GJ49+EdeE3DV2A7iBNY8oEi/y+wSnzy5DG4lBERl2YQ
EpNn4BKWZ2DmkWL4xSLM8PEPN8OPf6wMP/8D21qsPAy2Tt49oOoYupGHZAAQQNQI8b/QRHBtxYoV
20GtetgdpMh9ceTtUrB5dXoMvxIzGgfK6V++Q+4rewmMdNDB7W8+/wXfXQYq6hlhuR0pwvk4IXcb
ifBAIh90ODxIEYgGXfYkxM0ATAh/GP79/sJw6vgh8GAZqLdz4/ZNYCn4h+Hp86cMTx48YvgFDCte
8FpAefC8BehiiJfvvjFwC0oyCIorALE8A+hsZm5+YciFdMCeAeSKIdDN19wMn/7xCkyau6YWNKVC
zi5jgACiVsiDmrGgBWpmwGpgAbC+YgdtI8M1TYwS3/8xXfEfS0MKXQybGhSz/iNu80DhQ5WBDrMH
Fe+gbhuoLod11ZBzN0w9GyvkFi9WFkYUp4IOx2cHi0PYoIQEOigfVMT/Bub8Xz++MFw8f5aBm4sL
XNdfv3mTgRGoEDQ3Arr27BuwMcwPLAVBRTzILlDv4MXbb8CiXhKcIBTk5RkkJaUZePgEGX4zcTF8
/8PK8OUXpDriZmcEJs5/DN+/fmT48uHt31gvTV3Q4g9gVfCNlIgDCCBqreoEzR2A1pw9OXXq5Glh
YSEbXl4eBhZW0C5YRshFGv8gl+OAijbQlSiw2wL+/oXcRAKuLf8zgtWAAuM/9H4qBuigCuwseiZo
1wt2NRMT9Daif9A7msB3VcEqcQZIfQyrWVjAF/NArmT59RvSgkdOM7Dj30GRycHGBG28QYo4UAYH
JQA26A0p4ET0B2QeyC+QhAG+RAAo/wvYL/z44QvDpfPHwLkbVMzffvCAgR2Ye9++e8vwCHT7GTC3
CwG7t7LAbh24ewy6DhpY9ygBG3kikgoM3MKyDF9YJBmefONnYP/PCUyELODBpE/A7ubrj0D8CZT4
/jPcf8HO8P0LO3P5xP2LOvMd/YClwE9SGoQAAVg7gx6CYSiO/4sEkxEjNjvgS/gwvpOvIOLuzNXd
wVEiMTcO2AxLNMO0fR2uEocemiZNmn/z3vu/NP39M/bKByQdMbrT2WJYqdrMrFgiCuTeQLBUlu/u
mxQ6TiEk4oRSR+WmnsTXUUIn9B8/vsRn+kIkTC8yEovIbNLzE7tDYqrImol5hr2RFkponfdTpld6
UdT+6v//D/JK4nFojaGQT1DSeKv4Qc6AikUiTF6jC/beXNU3fhBguV7BKBrwjz48b43zKUTTbijw
Ib9xYSljbLYhypaLmtOG7bZg1R1kClWE3MDulBUpSdOg2AeyZIpaQ/Yf7jwCjw7gy0FvPOpPfikI
XwKImuu6f0CHJJ8+fXz/wR8mXsXfTDwMzMBQ/AfNdX//IW6bQekv/0esQWVEaoVjqMNeY0DrA9S6
AFFF/IcnOlAigJUW/xkQF7/Brv+B3W32FzpCxsyMsBtUt7Mywdo0kMTBBG0cgC6KAJU8v4Fds2/A
Bt2rB8DI5+ECXwVy/fYt8DD250+fQBc8M7wHJgJxUVFonf8JPMDz8M0vBmExaQZOIXmGL8wyDC9f
iTP8fsMPbO1zgOt6ZmgpxobWYgNFvpQgE8PTd5wMzL+B7QiTyBkMC3sMgaXAD/Q7knABgACidusL
tB9bxcTcxj+pdEqdsKgEsKUvAGzhM2EclI5SCqDX4wyUXUdG+8UbiITxF5q6/v35BayPPzNwfzkP
vujuNbBrd+XGVWDk84AHve7fuwe+8lBESBi8FgI0FvL563eG07eB+YZTioFdQI6BV1iOgUdAnIGD
W5CBhY0TGOks2EeVkNzBDE0UX779YPj77Q2DEtOJvtbyuDZQZiRmdBAggKi9swO8m/jMySNnU/+8
//zzBz8vByc3+GozYiP/PzHTskh9cNj9NOCSA6k9ALu2EXZzIUwvuJ6H5nKG/6hdQORr4KCFA+SW
M6g5DFA1sO4TI/RGwN+gCa2v7xj4v19lUFJWAq9aBk3u+P8PYti0eRP4mufHjx8ySAH78ZqaWuD7
L998/MFw5NoPBl4haQZeEXkGHiFZBi4+cWDDHphhQHdtMDJjRD6sBAUJg25aFONnAnY9GRjkREGT
WtwM/37+ZvjxxSQfqHQWNC6+E4owgACiRf8LdNWDenZhdam+fWSgELAU4OLmBde/yJEIrsuRingm
eEQwQu/Y/A9udIEaVsyMSA0+RsiVdCxMsMiFVAqM0DodcicXpEEJa9QxIl1kBBcDLXj4zwC92Q0S
o///wa61Q5q4+Q9xNxO0OgG1ARABB7rf7yfDlJ46hucPb4BXItvZ2QEjn5fh+YvnDAcOHWI4euwo
w7PHTxjkgInCxNgEvD7x8cuPDOcf/AdffccL7ONzC8owcPGLM7BzCTAwA3M+sKUCbNZArtAD9UD4
gd1KcX5GBlEg5mUHNUb/gy9j+gdeDgdZ/AIab/j1E9ie+PGNgf3Hw21x4V5JoLklQrODAAFEi71d
4FJgan/r6lk2gX6/fnxn5uHmAqZYFgZ2ZkhLmgXauobVoUxMiEiBRdR/2DJIRuyLMuANSgZGlJQM
0/sfaaQKXM//Q5QU/5mQruWGDdn+Q1IPbRWC3McCvdIT3EYA8llZGaFtDFDk/2J4/uwlw7wZ/eB6
HtSaBxX3sDGOH8Cu3/tXrxnMTM3AmzZA3b+bD14z3H7NgYh8YGufi1eMgY2THzwgJsjDxCAh8B+Y
s/8BI/sv+D61nz9+gRuKvz78ZHjx+yewxIFgJoY/DOwM3/68f/Xg04M7116fP3v6PrAXBrqUBrQ7
hgfaM8N7+BRAANEiAYC2I4GWIT///ebqVTEpPj0R3j9Az7GCh0n//8cs6sGlwX9E5CNyHFoxzAQd
V4eWAuAWMTP0qkKkRASyB3SRLKjUgVxmCb30khF+gxHYnj/QIogZGMvg3shfyAW2sCvPwJdc/4a0
vkFXG4ISL0ju3ee/DE/e/GR49e4Tw5YV88Dmgep10A4l0CAYqNsH2phqb2/P4O/vD96rD9qxu33/
GYY/PGoMXAKSwFwvxSAiIswgLcHBICX2i0GQ6y3QDX/AufjHO6DZb/8wfGT88ffTm8ef79+58vrC
udMvjh879hwaod+hGe0bdHb2CzSyQYtC3kIH5t4yoF20gw0ABBCthuBAqU9JRlbOccbCLRNExMQZ
eICNQSZQbP1H3C0NijjYXZOgVjUogEFKQGxYVwdl3Pk/JIJAd9SBIu8ftA/+9z9kfAHUJYPdZghK
JGB5aGMAfMcltBvIAG0rgIZrQXdeguz/D78Z9T+YD6vz/0LNff3pP8ODN//ALe+Pn38y3Hn6heHW
/dcMW3pcGfh52MF7EUBL5EEJABT5IDbotLGHwD4/GxsHQ3nbPAYuYNUgJirCICslBox0gX/MwM7b
8yf33ty4dvn5yRMnnv38+fM7lsj9zIDY2/eZAXGhEEztD+g0PQz/IWVqGCAAbWewgjAMg+EyC3pS
BnrydXw194bzsOMUEaZDRTdmm9YkbezAq556Lfz52yYh/f413ksbaw/7ulL9qcln89V6ucBcOHX4
nA+FFOJnykrERRFRHluTLKRgGu89zc5Wn2CZor11pr4iRWoF3oWikyCuYYS0JGGfjKxMxNcBAgzd
R6Kzxfv+ZRwH3QVdXx0tOt+oDo922595PsKZDp2/4TY4tbZpQJXKvvT5FnX0tkVx25XlFQAe8WQk
ZzYqQU3b6Nz7SHQReIiiykw//Bo28RZAtEoAf6HF0ps1q1esj0stSvv69yuwMQhausUEabAxQe4Q
B12UDrqLmA+YOFiYGbBGJCRRMIJzPijyQJH47wcoIv+Bb7IHzdD9/c8AH0kEJag/0NwPHkz6C6GR
hh3ACewvtG5hBDakgOUFuEH1B6j5/79fwAbWL4bHr38x3H7yneH1+x/gbh4z4y8GEa4f/7m/P/j5
8uGFj7dP7Gc2MTERAZ0IDlrHACryQQ0yUOSvWrXqxYoVKx5CI/0FdPkWiA+76BW2hu87tKj+MxA3
iQAEEC1nYWDHzBmePHlqmaysDBtsfgA0/PsbWrT+/ou4ffcndFEFePj4P0IOrB46nAzr4kE7Coiu
IAN6V/A/9Cpx8NgiOJKB2RW0swUoB4xgYGPq31/QTN1Pho9ffjB8+fETfOPnr69vwcX2nVs3GW5c
2PPx/r1H95Dq1jfQnAqKtP/Aer/Cx8eHE5QATE1NYUezvC8pKTkC1QO72Re2OfMlA2J//u/BcHUM
QADR8oQH2PzAqz37Dx0xsfF24nnPycDGzg0dj4dE7p9//+GLJv/C+/T/4d035L4+A3w+ADpDB6KB
EczE+JeB6T+o7Aa12H6B8e8/wJbyT9A28J/gSGYElqCf3r9luHv/IcOVG/cYrt1+zPDl22/wfkcQ
Bu114Gd+8efx9f1XP378Cbql9DE04p5Bi+wP0OIZ5BJuYMRnAxt4nKCt2KAEA8z5PwsKCtYDq4Ef
0ITyHJrrnzEgVu1+hYbL38FwWQQIAAQQredhwfMDHJyc5v2Lj8zjFRBn4BUQAq9wRYlc2OwadPiV
BdSCByUCYN+MmfEfPOf+h0bsH3A36DfDDyANajUzAiP/88d3DPfuP2C4fus+MHKfMLz/9B18cSkT
KwcwgjmBEcwBub2VjZuBhY0HTLMBO9kiP3a/37VxLWg3Leh2x3vQiH/JgNhQ+QdpvIqFiYmJz8/P
b0JKSko0sMvHdOzYsX9AfP4UsP8FVf8GKeJhW7Q+Q+vzP4Ml4mEAIIBofcYLeH7gx/fvj3+9v3vn
Hw+vCjsTDwMX9KZ5pv9/wZH3Dxi5oCVOf0B93O8/wf1r0PIxEP7/H7SO7hP4HL9rN+8zXL35iOHt
x2+QLWosHOAIBl3JC8agyGWXYmCVVmWQVOCCyEHVMDEDczow4fGyvv3PcHvipZ3rD69ggNxlirF3
HsdINDM3N7coMNfPiYmJ8fj48SPTyZMn/+7cuXMjMFIvI0U+LOJfQyMeloj+MQxCABBAtE4A/6DF
3tvVi6YsLavrq//74TvDuz+/oQtCgXXw98+/nzy6/f761cuvTp449uzmzZvvYMUkdJ2BhIZdotNf
NklgnIsxsEgqMkjIQSMcnLs5IMU4Myuw/geWLEwgmhmImeAFnCTDsV/nNjVsvn3nzQEg9wEDYjMF
/MQMAqUkyDBOaWnpCmAR73rgwAGmT58+/QFG/hxgwrwJa/BCzYSVHt8YEDd/DtqpDYAAYqRTIgOd
PK4FxAbQhiEb2iAGbCADdo4NrBsECnhRINYMzp3Y85LRnA09crFaCGyti39aCLq1eCG0aH8IzZmw
7dKkXMkKPqBJSkoqRFhYuB/Y0BN8+vTpdGBVcBOYGH5CzXsNjfg3aIkKI+IH2y1tAAFEr7VY7NCZ
QtAqYg5o4MPOyP8JzfF/YH1dpICDHWEDOrBfPyavevojlmCsx32DLif/d6Pr4vYtB5dDc/ljIot2
fIAJ6nbQhcZmQJwKxCsZIMviGdByPnJdjzNxDbYEABBAQ+Hwf0ZoogHvSIpMiut+KlCgDCnaTwCL
9jpyi3ZiSy/QbijQETrC0ATMA3XTD6SBnY9ILXy8JctgSwAAATSULgIC5UTQZhR5aJXCBA3852QW
7cSEDTM0AYBKIW4oZmVAHJ4Ji/gfxJYwgy0BAATQULo69ic0sl9DI+Y/NND/0qiR9R+amGAN0p/Q
CGeAjdwhVVv/GQb3GhacACCAWIbY1bGwCKEL0NTU/A+1jxGaABiRIvs/NEcP6du0AAIMANtMxR3x
N38FAAAAAElFTkSuQmCC\
"""

def thumbnail():
    icon = base64.decodestring(iconstr)
    return icon

if __name__ == "__main__":
    icon = thumbnail()
    f = file("thumbnail.png","wb")
    f.write(icon)
    f.close()

########NEW FILE########
__FILENAME__ = userfield
#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2009 Sren Roug, European Environment Agency
#
# This is free software.  You may redistribute it under the terms
# of the Apache license and the GNU General Public License Version
# 2 or at your option any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s): Michael Howitz, gocept gmbh & co. kg
#
# $Id: userfield.py 447 2008-07-10 20:01:30Z roug $

"""Class to show and manipulate user fields in odf documents."""

import sys
import zipfile

from odf.text import UserFieldDecl
from odf.namespaces import OFFICENS
from odf.opendocument import load

OUTENCODING = "utf-8"


# OpenDocument v.1.0 section 6.7.1
VALUE_TYPES = {
    'float': (OFFICENS, u'value'),
    'percentage': (OFFICENS, u'value'),
    'currency': (OFFICENS, u'value'),
    'date': (OFFICENS, u'date-value'),
    'time': (OFFICENS, u'time-value'),
    'boolean': (OFFICENS, u'boolean-value'),
    'string': (OFFICENS, u'string-value'),
    }


class UserFields(object):
    """List, view and manipulate user fields."""

    # these attributes can be a filename or a file like object
    src_file = None
    dest_file = None

    def __init__(self, src=None, dest=None):
        """Constructor

        src ... source document name, file like object or None for stdin
        dest ... destination document name, file like object or None for stdout

        """
        self.src_file = src
        self.dest_file = dest
        self.document = None

    def loaddoc(self):
        if isinstance(self.src_file, basestring):
            # src_file is a filename, check if it is a zip-file
            if not zipfile.is_zipfile(self.src_file):
                raise TypeError("%s is no odt file." % self.src_file)
        elif self.src_file is None:
            # use stdin if no file given
            self.src_file = sys.stdin

        self.document = load(self.src_file)

    def savedoc(self):
        # write output
        if self.dest_file is None:
            # use stdout if no filename given
            self.document.save('-')
        else:
            self.document.save(self.dest_file)

    def list_fields(self):
        """List (extract) all known user-fields.

        Returns list of user-field names.

        """
        return [x[0] for x in self.list_fields_and_values()]

    def list_fields_and_values(self, field_names=None):
        """List (extract) user-fields with type and value.

        field_names ... list of field names to show or None for all.

        Returns list of tuples (<field name>, <field type>, <value>).

        """
        self.loaddoc()
        found_fields = []
        all_fields = self.document.getElementsByType(UserFieldDecl)
        for f in all_fields:
            value_type = f.getAttribute('valuetype')
            if value_type == 'string':
                value = f.getAttribute('stringvalue')
            else:
                value = f.getAttribute('value')
            field_name = f.getAttribute('name')

            if field_names is None or field_name in field_names:
                found_fields.append((field_name.encode(OUTENCODING),
                                     value_type.encode(OUTENCODING),
                                     value.encode(OUTENCODING)))
        return found_fields

    def list_values(self, field_names):
        """Extract the contents of given field names from the file.

        field_names ... list of field names

        Returns list of field values.

        """
        return [x[2] for x in self.list_fields_and_values(field_names)]

    def get(self, field_name):
        """Extract the contents of this field from the file.

        Returns field value or None if field does not exist.

        """
        values = self.list_values([field_name])
        if not values:
            return None
        return values[0]

    def get_type_and_value(self, field_name):
        """Extract the type and contents of this field from the file.

        Returns tuple (<type>, <field-value>) or None if field does not exist.

        """
        fields = self.list_fields_and_values([field_name])
        if not fields:
            return None
        field_name, value_type, value = fields[0]
        return value_type, value

    def update(self, data):
        """Set the value of user fields. The field types will be the same.

        data ... dict, with field name as key, field value as value

        Returns None

        """
        self.loaddoc()
        all_fields = self.document.getElementsByType(UserFieldDecl)
        for f in all_fields:
            field_name = f.getAttribute('name')
            if data.has_key(field_name):
                value_type = f.getAttribute('valuetype')
                value = data.get(field_name)
                if value_type == 'string':
                    f.setAttribute('stringvalue', value)
                else:
                    f.setAttribute('value', value) 
        self.savedoc()


########NEW FILE########
__FILENAME__ = xforms
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from namespaces import XFORMSNS
from element import Element

# ODF 1.0 section 11.2
# XForms is designed to be embedded in another XML format.
# Autogenerated
def Model(**args):
    return Element(qname = (XFORMSNS,'model'), **args)

def Instance(**args):
    return Element(qname = (XFORMSNS,'instance'), **args)

def Bind(**args):
    return Element(qname = (XFORMSNS,'bind'), **args)

########NEW FILE########
__FILENAME__ = anim
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import ANIMNS
from .element import Element


# Autogenerated
def Animate(**args):
    return Element(qname = (ANIMNS,'animate'), **args)

def Animatecolor(**args):
    return Element(qname = (ANIMNS,'animateColor'), **args)

def Animatemotion(**args):
    return Element(qname = (ANIMNS,'animateMotion'), **args)

def Animatetransform(**args):
    return Element(qname = (ANIMNS,'animateTransform'), **args)

def Audio(**args):
    return Element(qname = (ANIMNS,'audio'), **args)

def Command(**args):
    return Element(qname = (ANIMNS,'command'), **args)

def Iterate(**args):
    return Element(qname = (ANIMNS,'iterate'), **args)

def Par(**args):
    return Element(qname = (ANIMNS,'par'), **args)

def Param(**args):
    return Element(qname = (ANIMNS,'param'), **args)

def Seq(**args):
    return Element(qname = (ANIMNS,'seq'), **args)

def Set(**args):
    return Element(qname = (ANIMNS,'set'), **args)

def Transitionfilter(**args):
    return Element(qname = (ANIMNS,'transitionFilter'), **args)


########NEW FILE########
__FILENAME__ = attrconverters
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2010 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#
from .namespaces import *
import re, types

pattern_color =  re.compile(r'#[0-9a-fA-F]{6}')
pattern_vector3D = re.compile(r'\([ ]*-?([0-9]+(\.[0-9]*)?|\.[0-9]+)([ ]+-?([0-9]+(\.[0-9]*)?|\.[0-9]+)){2}[ ]*\)')

def make_NCName(arg):
    for c in (':',' '):
        arg = arg.replace(c,"_%x_" % ord(c))
    return arg

def cnv_anyURI(attribute, arg, element):
    return str(arg)

def cnv_boolean(attribute, arg, element):
    if arg.lower() in ("false","no"):
        return "false"
    if arg:
        return "true"
    return "false"

# Potentially accept color values
def cnv_color(attribute, arg, element):
    """ A RGB color in conformance with 5.9.11 of [XSL], that is a RGB color in notation #rrggbb, where
        rr, gg and bb are 8-bit hexadecimal digits.
    """
    return str(arg)

def cnv_configtype(attribute, arg, element):
    if str(arg) not in ("boolean", "short", "int", "long",
    "double", "string", "datetime", "base64Binary"):
        raise ValueError("'%s' not allowed" % str(arg))
    return str(arg)

def cnv_data_source_has_labels(attribute, arg, element):
    if str(arg) not in ("none","row","column","both"):
        raise ValueError("'%s' not allowed" % str(arg))
    return str(arg)

# Understand different date formats
def cnv_date(attribute, arg, element):
    """ A dateOrDateTime value is either an [xmlschema-2] date value or an [xmlschema-2] dateTime
        value.
    """
    return str(arg)

def cnv_dateTime(attribute, arg, element):
    """ A dateOrDateTime value is either an [xmlschema-2] date value or an [xmlschema-2] dateTime
        value.
    """
    return str(arg)

def cnv_double(attribute, arg, element):
    return str(arg)

def cnv_duration(attribute, arg, element):
    return str(arg)

def cnv_family(attribute, arg, element):
    """ A style family """
    if str(arg) not in ("text", "paragraph", "section", "ruby", "table", "table-column", "table-row", "table-cell",
      "graphic", "presentation", "drawing-page", "chart"):
        raise ValueError("'%s' not allowed" % str(arg))
    return str(arg)

def __save_prefix(attribute, arg, element):
    prefix = arg.split(':',1)[0]
    if prefix == arg:
        return str(arg)
    namespace = element.get_knownns(prefix)
    if namespace is None:
        #raise ValueError, "'%s' is an unknown prefix" % str(prefix)
        return str(arg)
    p = element.get_nsprefix(namespace)
    return str(arg)

def cnv_formula(attribute, arg, element):
    """ A string containing a formula. Formulas do not have a predefined syntax, but the string should
        begin with a namespace prefix, followed by a : (COLON, U+003A) separator, followed by the text
        of the formula. The namespace bound to the prefix determines the syntax and semantics of the
        formula.
    """
    return __save_prefix(attribute, arg, element)

def cnv_ID(attribute, arg, element):
    return str(arg)

def cnv_IDREF(attribute, arg, element):
    return str(arg)

def cnv_integer(attribute, arg, element):
    return str(arg)

def cnv_legend_position(attribute, arg, element):
    if str(arg) not in ("start", "end", "top", "bottom", "top-start", "bottom-start", "top-end", "bottom-end"):
        raise ValueError("'%s' not allowed" % str(arg))
    return str(arg)

pattern_length = re.compile(r'-?([0-9]+(\.[0-9]*)?|\.[0-9]+)((cm)|(mm)|(in)|(pt)|(pc)|(px))')

def cnv_length(attribute, arg, element):
    """ A (positive or negative) physical length, consisting of magnitude and unit, in conformance with the
        Units of Measure defined in 5.9.13 of [XSL].
    """
    global pattern_length
    if not pattern_length.match(arg):
        raise ValueError("'%s' is not a valid length" % arg)
    return arg

def cnv_lengthorpercent(attribute, arg, element):
    failed = False
    try: return cnv_length(attribute, arg, element)
    except: failed = True
    try: return cnv_percent(attribute, arg, element)
    except: failed = True
    if failed:
        raise ValueError("'%s' is not a valid length or percent" % arg)
    return arg

def cnv_metavaluetype(attribute, arg, element):
    if str(arg) not in ("float", "date", "time", "boolean", "string"):
        raise ValueError("'%s' not allowed" % str(arg))
    return str(arg)

def cnv_major_minor(attribute, arg, element):
    if arg not in ('major','minor'):
        raise ValueError("'%s' is not either 'minor' or 'major'" % arg)

pattern_namespacedToken = re.compile(r'[0-9a-zA-Z_]+:[0-9a-zA-Z._\-]+')

def cnv_namespacedToken(attribute, arg, element):
    global pattern_namespacedToken

    if not pattern_namespacedToken.match(arg):
        raise ValueError("'%s' is not a valid namespaced token" % arg)
    return __save_prefix(attribute, arg, element)

def cnv_NCName(attribute, arg, element):
    """ NCName is defined in http://www.w3.org/TR/REC-xml-names/#NT-NCName
        Essentially an XML name minus ':'
    """
    if isinstance(arg, str):
        return make_NCName(arg)
    else:
        return arg.getAttrNS(STYLENS, 'name')

# This function takes either an instance of a style (preferred)
# or a text string naming the style. If it is a text string, then it must
# already have been converted to an NCName
# The text-string argument is mainly for when we build a structure from XML
def cnv_StyleNameRef(attribute, arg, element):
    try:
        return arg.getAttrNS(STYLENS, 'name')
    except:
        return arg

# This function takes either an instance of a style (preferred)
# or a text string naming the style. If it is a text string, then it must
# already have been converted to an NCName
# The text-string argument is mainly for when we build a structure from XML
def cnv_DrawNameRef(attribute, arg, element):
    try:
        return arg.getAttrNS(DRAWNS, 'name')
    except:
        return arg

# Must accept list of Style objects
def cnv_NCNames(attribute, arg, element):
    return ' '.join(arg)

def cnv_nonNegativeInteger(attribute, arg, element):
    return str(arg)

pattern_percent = re.compile(r'-?([0-9]+(\.[0-9]*)?|\.[0-9]+)%')

def cnv_percent(attribute, arg, element):
    global pattern_percent
    if not pattern_percent.match(arg):
        raise ValueError("'%s' is not a valid length" % arg)
    return arg

# Real one doesn't allow floating point values
pattern_points = re.compile(r'-?[0-9]+,-?[0-9]+([ ]+-?[0-9]+,-?[0-9]+)*')
#pattern_points = re.compile(r'-?[0-9.]+,-?[0-9.]+([ ]+-?[0-9.]+,-?[0-9.]+)*')
def cnv_points(attribute, arg, element):
    global pattern_points
    if type(arg) in str:
        if not pattern_points.match(arg):
            raise ValueError("x,y are separated by a comma and the points are separated by white spaces")
        return arg
    else:
        try:
            strarg = ' '.join([ "%d,%d" % p for p in arg])
        except:
            raise ValueError("Points must be string or [(0,0),(1,1)] - not %s" % arg)
        return strarg

def cnv_positiveInteger(attribute, arg, element):
    return str(arg)

def cnv_string(attribute, arg, element):
    return str(arg)

def cnv_textnoteclass(attribute, arg, element):
    if str(arg) not in ("footnote", "endnote"):
        raise ValueError("'%s' not allowed" % str(arg))
    return str(arg)

# Understand different time formats
def cnv_time(attribute, arg, element):
    return str(arg)

def cnv_token(attribute, arg, element):
    return str(arg)

pattern_viewbox = re.compile(r'-?[0-9]+([ ]+-?[0-9]+){3}$')

def cnv_viewbox(attribute, arg, element):
    global pattern_viewbox
    if not pattern_viewbox.match(arg):
        raise ValueError("viewBox must be four integers separated by whitespaces")
    return arg

def cnv_xlinkshow(attribute, arg, element):
    if str(arg) not in ("new", "replace", "embed"):
        raise ValueError("'%s' not allowed" % str(arg))
    return str(arg)


attrconverters = {
	((ANIMNS,'audio-level'), None): cnv_double,
	((ANIMNS,'color-interpolation'), None): cnv_string,
	((ANIMNS,'color-interpolation-direction'), None): cnv_string,
	((ANIMNS,'command'), None): cnv_string,
	((ANIMNS,'formula'), None): cnv_string,
	((ANIMNS,'id'), None): cnv_ID,
	((ANIMNS,'iterate-interval'), None): cnv_duration,
	((ANIMNS,'iterate-type'), None): cnv_string,
	((ANIMNS,'name'), None): cnv_string,
	((ANIMNS,'sub-item'), None): cnv_string,
	((ANIMNS,'value'), None): cnv_string,
#	((DBNS,u'type'), None): cnv_namespacedToken,
	((CHARTNS,'attached-axis'), None): cnv_string,
	((CHARTNS,'class'), (CHARTNS,'grid')): cnv_major_minor,
	((CHARTNS,'class'), None): cnv_namespacedToken,
	((CHARTNS,'column-mapping'), None): cnv_string,
	((CHARTNS,'connect-bars'), None): cnv_boolean,
	((CHARTNS,'data-label-number'), None): cnv_string,
	((CHARTNS,'data-label-symbol'), None): cnv_boolean,
	((CHARTNS,'data-label-text'), None): cnv_boolean,
	((CHARTNS,'data-source-has-labels'), None): cnv_data_source_has_labels,
	((CHARTNS,'deep'), None): cnv_boolean,
	((CHARTNS,'dimension'), None): cnv_string,
	((CHARTNS,'display-label'), None): cnv_boolean,
	((CHARTNS,'error-category'), None): cnv_string,
	((CHARTNS,'error-lower-indicator'), None): cnv_boolean,
	((CHARTNS,'error-lower-limit'), None): cnv_string,
	((CHARTNS,'error-margin'), None): cnv_string,
	((CHARTNS,'error-percentage'), None): cnv_string,
	((CHARTNS,'error-upper-indicator'), None): cnv_boolean,
	((CHARTNS,'error-upper-limit'), None): cnv_string,
	((CHARTNS,'gap-width'), None): cnv_string,
	((CHARTNS,'interpolation'), None): cnv_string,
	((CHARTNS,'interval-major'), None): cnv_string,
	((CHARTNS,'interval-minor-divisor'), None): cnv_string,
	((CHARTNS,'japanese-candle-stick'), None): cnv_boolean,
	((CHARTNS,'label-arrangement'), None): cnv_string,
	((CHARTNS,'label-cell-address'), None): cnv_string,
	((CHARTNS,'legend-align'), None): cnv_string,
	((CHARTNS,'legend-position'), None): cnv_legend_position,
	((CHARTNS,'lines'), None): cnv_boolean,
	((CHARTNS,'link-data-style-to-source'), None): cnv_boolean,
	((CHARTNS,'logarithmic'), None): cnv_boolean,
	((CHARTNS,'maximum'), None): cnv_string,
	((CHARTNS,'mean-value'), None): cnv_boolean,
	((CHARTNS,'minimum'), None): cnv_string,
	((CHARTNS,'name'), None): cnv_string,
	((CHARTNS,'origin'), None): cnv_string,
	((CHARTNS,'overlap'), None): cnv_string,
	((CHARTNS,'percentage'), None): cnv_boolean,
	((CHARTNS,'pie-offset'), None): cnv_string,
	((CHARTNS,'regression-type'), None): cnv_string,
	((CHARTNS,'repeated'), None): cnv_nonNegativeInteger,
	((CHARTNS,'row-mapping'), None): cnv_string,
	((CHARTNS,'scale-text'), None): cnv_boolean,
	((CHARTNS,'series-source'), None): cnv_string,
	((CHARTNS,'solid-type'), None): cnv_string,
	((CHARTNS,'spline-order'), None): cnv_string,
	((CHARTNS,'spline-resolution'), None): cnv_string,
	((CHARTNS,'stacked'), None): cnv_boolean,
	((CHARTNS,'style-name'), None): cnv_StyleNameRef,
	((CHARTNS,'symbol-height'), None): cnv_string,
	((CHARTNS,'symbol-name'), None): cnv_string,
	((CHARTNS,'symbol-type'), None): cnv_string,
	((CHARTNS,'symbol-width'), None): cnv_string,
	((CHARTNS,'text-overlap'), None): cnv_boolean,
	((CHARTNS,'three-dimensional'), None): cnv_boolean,
	((CHARTNS,'tick-marks-major-inner'), None): cnv_boolean,
	((CHARTNS,'tick-marks-major-outer'), None): cnv_boolean,
	((CHARTNS,'tick-marks-minor-inner'), None): cnv_boolean,
	((CHARTNS,'tick-marks-minor-outer'), None): cnv_boolean,
	((CHARTNS,'values-cell-range-address'), None): cnv_string,
	((CHARTNS,'vertical'), None): cnv_boolean,
	((CHARTNS,'visible'), None): cnv_boolean,
	((CONFIGNS,'name'), None): cnv_formula,
	((CONFIGNS,'type'), None): cnv_configtype,
	((DR3DNS,'ambient-color'), None): cnv_string,
	((DR3DNS,'back-scale'), None): cnv_string,
	((DR3DNS,'backface-culling'), None): cnv_string,
	((DR3DNS,'center'), None): cnv_string,
	((DR3DNS,'close-back'), None): cnv_boolean,
	((DR3DNS,'close-front'), None): cnv_boolean,
	((DR3DNS,'depth'), None): cnv_length,
	((DR3DNS,'diffuse-color'), None): cnv_string,
	((DR3DNS,'direction'), None): cnv_string,
	((DR3DNS,'distance'), None): cnv_length,
	((DR3DNS,'edge-rounding'), None): cnv_string,
	((DR3DNS,'edge-rounding-mode'), None): cnv_string,
	((DR3DNS,'emissive-color'), None): cnv_string,
	((DR3DNS,'enabled'), None): cnv_boolean,
	((DR3DNS,'end-angle'), None): cnv_string,
	((DR3DNS,'focal-length'), None): cnv_length,
	((DR3DNS,'horizontal-segments'), None): cnv_string,
	((DR3DNS,'lighting-mode'), None): cnv_boolean,
	((DR3DNS,'max-edge'), None): cnv_string,
	((DR3DNS,'min-edge'), None): cnv_string,
	((DR3DNS,'normals-direction'), None): cnv_string,
	((DR3DNS,'normals-kind'), None): cnv_string,
	((DR3DNS,'projection'), None): cnv_string,
	((DR3DNS,'shade-mode'), None): cnv_string,
	((DR3DNS,'shadow'), None): cnv_string,
	((DR3DNS,'shadow-slant'), None): cnv_nonNegativeInteger,
	((DR3DNS,'shininess'), None): cnv_string,
	((DR3DNS,'size'), None): cnv_string,
	((DR3DNS,'specular'), None): cnv_boolean,
	((DR3DNS,'specular-color'), None): cnv_string,
	((DR3DNS,'texture-filter'), None): cnv_string,
	((DR3DNS,'texture-generation-mode-x'), None): cnv_string,
	((DR3DNS,'texture-generation-mode-y'), None): cnv_string,
	((DR3DNS,'texture-kind'), None): cnv_string,
	((DR3DNS,'texture-mode'), None): cnv_string,
	((DR3DNS,'transform'), None): cnv_string,
	((DR3DNS,'vertical-segments'), None): cnv_string,
	((DR3DNS,'vpn'), None): cnv_string,
	((DR3DNS,'vrp'), None): cnv_string,
	((DR3DNS,'vup'), None): cnv_string,
	((DRAWNS,'align'), None): cnv_string,
	((DRAWNS,'angle'), None): cnv_integer,
	((DRAWNS,'archive'), None): cnv_string,
	((DRAWNS,'auto-grow-height'), None): cnv_boolean,
	((DRAWNS,'auto-grow-width'), None): cnv_boolean,
	((DRAWNS,'background-size'), None): cnv_string,
	((DRAWNS,'blue'), None): cnv_string,
	((DRAWNS,'border'), None): cnv_string,
	((DRAWNS,'caption-angle'), None): cnv_string,
	((DRAWNS,'caption-angle-type'), None): cnv_string,
	((DRAWNS,'caption-escape'), None): cnv_string,
	((DRAWNS,'caption-escape-direction'), None): cnv_string,
	((DRAWNS,'caption-fit-line-length'), None): cnv_boolean,
	((DRAWNS,'caption-gap'), None): cnv_string,
	((DRAWNS,'caption-line-length'), None): cnv_length,
	((DRAWNS,'caption-point-x'), None): cnv_string,
	((DRAWNS,'caption-point-y'), None): cnv_string,
	((DRAWNS,'caption-id'), None): cnv_IDREF,
	((DRAWNS,'caption-type'), None): cnv_string,
	((DRAWNS,'chain-next-name'), None): cnv_string,
	((DRAWNS,'class-id'), None): cnv_string,
	((DRAWNS,'class-names'), None): cnv_NCNames,
	((DRAWNS,'code'), None): cnv_string,
	((DRAWNS,'color'), None): cnv_string,
	((DRAWNS,'color-inversion'), None): cnv_boolean,
	((DRAWNS,'color-mode'), None): cnv_string,
	((DRAWNS,'concave'), None): cnv_string,
	((DRAWNS,'concentric-gradient-fill-allowed'), None): cnv_boolean,
	((DRAWNS,'contrast'), None): cnv_string,
	((DRAWNS,'control'), None): cnv_IDREF,
	((DRAWNS,'copy-of'), None): cnv_string,
	((DRAWNS,'corner-radius'), None): cnv_length,
	((DRAWNS,'corners'), None): cnv_positiveInteger,
	((DRAWNS,'cx'), None): cnv_string,
	((DRAWNS,'cy'), None): cnv_string,
	((DRAWNS,'data'), None): cnv_string,
	((DRAWNS,'decimal-places'), None): cnv_string,
	((DRAWNS,'display'), None): cnv_string,
	((DRAWNS,'display-name'), None): cnv_string,
	((DRAWNS,'distance'), None): cnv_lengthorpercent,
	((DRAWNS,'dots1'), None): cnv_integer,
	((DRAWNS,'dots1-length'), None): cnv_lengthorpercent,
	((DRAWNS,'dots2'), None): cnv_integer,
	((DRAWNS,'dots2-length'), None): cnv_lengthorpercent,
	((DRAWNS,'end-angle'), None): cnv_double,
	((DRAWNS,'end'), None): cnv_string,
	((DRAWNS,'end-color'), None): cnv_string,
	((DRAWNS,'end-glue-point'), None): cnv_nonNegativeInteger,
	((DRAWNS,'end-guide'), None): cnv_length,
	((DRAWNS,'end-intensity'), None): cnv_string,
	((DRAWNS,'end-line-spacing-horizontal'), None): cnv_string,
	((DRAWNS,'end-line-spacing-vertical'), None): cnv_string,
	((DRAWNS,'end-shape'), None): cnv_IDREF,
	((DRAWNS,'engine'), None): cnv_namespacedToken,
	((DRAWNS,'enhanced-path'), None): cnv_string,
	((DRAWNS,'escape-direction'), None): cnv_string,
	((DRAWNS,'extrusion-allowed'), None): cnv_boolean,
	((DRAWNS,'extrusion-brightness'), None): cnv_string,
	((DRAWNS,'extrusion'), None): cnv_boolean,
	((DRAWNS,'extrusion-color'), None): cnv_boolean,
	((DRAWNS,'extrusion-depth'), None): cnv_double,
	((DRAWNS,'extrusion-diffusion'), None): cnv_string,
	((DRAWNS,'extrusion-first-light-direction'), None): cnv_string,
	((DRAWNS,'extrusion-first-light-harsh'), None): cnv_boolean,
	((DRAWNS,'extrusion-first-light-level'), None): cnv_string,
	((DRAWNS,'extrusion-light-face'), None): cnv_boolean,
	((DRAWNS,'extrusion-metal'), None): cnv_boolean,
	((DRAWNS,'extrusion-number-of-line-segments'), None): cnv_integer,
	((DRAWNS,'extrusion-origin'), None): cnv_double,
	((DRAWNS,'extrusion-rotation-angle'), None): cnv_double,
	((DRAWNS,'extrusion-rotation-center'), None): cnv_string,
	((DRAWNS,'extrusion-second-light-direction'), None): cnv_string,
	((DRAWNS,'extrusion-second-light-harsh'), None): cnv_boolean,
	((DRAWNS,'extrusion-second-light-level'), None): cnv_string,
	((DRAWNS,'extrusion-shininess'), None): cnv_string,
	((DRAWNS,'extrusion-skew'), None): cnv_double,
	((DRAWNS,'extrusion-specularity'), None): cnv_string,
	((DRAWNS,'extrusion-viewpoint'), None): cnv_string,
	((DRAWNS,'fill'), None): cnv_string,
	((DRAWNS,'fill-color'), None): cnv_string,
	((DRAWNS,'fill-gradient-name'), None): cnv_string,
	((DRAWNS,'fill-hatch-name'), None): cnv_string,
	((DRAWNS,'fill-hatch-solid'), None): cnv_boolean,
	((DRAWNS,'fill-image-height'), None): cnv_lengthorpercent,
	((DRAWNS,'fill-image-name'), None): cnv_DrawNameRef,
	((DRAWNS,'fill-image-ref-point'), None): cnv_string,
	((DRAWNS,'fill-image-ref-point-x'), None): cnv_string,
	((DRAWNS,'fill-image-ref-point-y'), None): cnv_string,
	((DRAWNS,'fill-image-width'), None): cnv_lengthorpercent,
	((DRAWNS,'filter-name'), None): cnv_string,
	((DRAWNS,'fit-to-contour'), None): cnv_boolean,
	((DRAWNS,'fit-to-size'), None): cnv_boolean,
	((DRAWNS,'formula'), None): cnv_string,
	((DRAWNS,'frame-display-border'), None): cnv_boolean,
	((DRAWNS,'frame-display-scrollbar'), None): cnv_boolean,
	((DRAWNS,'frame-margin-horizontal'), None): cnv_string,
	((DRAWNS,'frame-margin-vertical'), None): cnv_string,
	((DRAWNS,'frame-name'), None): cnv_string,
	((DRAWNS,'gamma'), None): cnv_string,
	((DRAWNS,'glue-point-leaving-directions'), None): cnv_string,
	((DRAWNS,'glue-point-type'), None): cnv_string,
	((DRAWNS,'glue-points'), None): cnv_string,
	((DRAWNS,'gradient-step-count'), None): cnv_string,
	((DRAWNS,'green'), None): cnv_string,
	((DRAWNS,'guide-distance'), None): cnv_string,
	((DRAWNS,'guide-overhang'), None): cnv_length,
	((DRAWNS,'handle-mirror-horizontal'), None): cnv_boolean,
	((DRAWNS,'handle-mirror-vertical'), None): cnv_boolean,
	((DRAWNS,'handle-polar'), None): cnv_string,
	((DRAWNS,'handle-position'), None): cnv_string,
	((DRAWNS,'handle-radius-range-maximum'), None): cnv_string,
	((DRAWNS,'handle-radius-range-minimum'), None): cnv_string,
	((DRAWNS,'handle-range-x-maximum'), None): cnv_string,
	((DRAWNS,'handle-range-x-minimum'), None): cnv_string,
	((DRAWNS,'handle-range-y-maximum'), None): cnv_string,
	((DRAWNS,'handle-range-y-minimum'), None): cnv_string,
	((DRAWNS,'handle-switched'), None): cnv_boolean,
#	((DRAWNS,u'id'), None): cnv_ID,
#	((DRAWNS,u'id'), None): cnv_nonNegativeInteger,   # ?? line 6581 in RNG
	((DRAWNS,'id'), None): cnv_string,
	((DRAWNS,'image-opacity'), None): cnv_string,
	((DRAWNS,'kind'), None): cnv_string,
	((DRAWNS,'layer'), None): cnv_string,
	((DRAWNS,'line-distance'), None): cnv_string,
	((DRAWNS,'line-skew'), None): cnv_string,
	((DRAWNS,'luminance'), None): cnv_string,
	((DRAWNS,'marker-end-center'), None): cnv_boolean,
	((DRAWNS,'marker-end'), None): cnv_string,
	((DRAWNS,'marker-end-width'), None): cnv_length,
	((DRAWNS,'marker-start-center'), None): cnv_boolean,
	((DRAWNS,'marker-start'), None): cnv_string,
	((DRAWNS,'marker-start-width'), None): cnv_length,
	((DRAWNS,'master-page-name'), None): cnv_StyleNameRef,
	((DRAWNS,'may-script'), None): cnv_boolean,
	((DRAWNS,'measure-align'), None): cnv_string,
	((DRAWNS,'measure-vertical-align'), None): cnv_string,
	((DRAWNS,'mime-type'), None): cnv_string,
	((DRAWNS,'mirror-horizontal'), None): cnv_boolean,
	((DRAWNS,'mirror-vertical'), None): cnv_boolean,
	((DRAWNS,'modifiers'), None): cnv_string,
	((DRAWNS,'name'), None): cnv_NCName,
#	((DRAWNS,u'name'), None): cnv_string,
	((DRAWNS,'nav-order'), None): cnv_IDREF,
	((DRAWNS,'nohref'), None): cnv_string,
	((DRAWNS,'notify-on-update-of-ranges'), None): cnv_string,
	((DRAWNS,'object'), None): cnv_string,
	((DRAWNS,'ole-draw-aspect'), None): cnv_string,
	((DRAWNS,'opacity'), None): cnv_string,
	((DRAWNS,'opacity-name'), None): cnv_string,
	((DRAWNS,'page-number'), None): cnv_positiveInteger,
	((DRAWNS,'parallel'), None): cnv_boolean,
	((DRAWNS,'path-stretchpoint-x'), None): cnv_double,
	((DRAWNS,'path-stretchpoint-y'), None): cnv_double,
	((DRAWNS,'placing'), None): cnv_string,
	((DRAWNS,'points'), None): cnv_points,
	((DRAWNS,'protected'), None): cnv_boolean,
	((DRAWNS,'recreate-on-edit'), None): cnv_boolean,
	((DRAWNS,'red'), None): cnv_string,
	((DRAWNS,'rotation'), None): cnv_integer,
	((DRAWNS,'secondary-fill-color'), None): cnv_string,
	((DRAWNS,'shadow'), None): cnv_string,
	((DRAWNS,'shadow-color'), None): cnv_string,
	((DRAWNS,'shadow-offset-x'), None): cnv_length,
	((DRAWNS,'shadow-offset-y'), None): cnv_length,
	((DRAWNS,'shadow-opacity'), None): cnv_string,
	((DRAWNS,'shape-id'), None): cnv_IDREF,
	((DRAWNS,'sharpness'), None): cnv_string,
	((DRAWNS,'show-unit'), None): cnv_boolean,
	((DRAWNS,'start-angle'), None): cnv_double,
	((DRAWNS,'start'), None): cnv_string,
	((DRAWNS,'start-color'), None): cnv_string,
	((DRAWNS,'start-glue-point'), None): cnv_nonNegativeInteger,
	((DRAWNS,'start-guide'), None): cnv_length,
	((DRAWNS,'start-intensity'), None): cnv_string,
	((DRAWNS,'start-line-spacing-horizontal'), None): cnv_string,
	((DRAWNS,'start-line-spacing-vertical'), None): cnv_string,
	((DRAWNS,'start-shape'), None): cnv_IDREF,
	((DRAWNS,'stroke'), None): cnv_string,
	((DRAWNS,'stroke-dash'), None): cnv_string,
	((DRAWNS,'stroke-dash-names'), None): cnv_string,
	((DRAWNS,'stroke-linejoin'), None): cnv_string,
	((DRAWNS,'style'), None): cnv_string,
	((DRAWNS,'style-name'), None): cnv_StyleNameRef,
	((DRAWNS,'symbol-color'), None): cnv_string,
	((DRAWNS,'text-areas'), None): cnv_string,
	((DRAWNS,'text-path-allowed'), None): cnv_boolean,
	((DRAWNS,'text-path'), None): cnv_boolean,
	((DRAWNS,'text-path-mode'), None): cnv_string,
	((DRAWNS,'text-path-same-letter-heights'), None): cnv_boolean,
	((DRAWNS,'text-path-scale'), None): cnv_string,
	((DRAWNS,'text-rotate-angle'), None): cnv_double,
	((DRAWNS,'text-style-name'), None): cnv_StyleNameRef,
	((DRAWNS,'textarea-horizontal-align'), None): cnv_string,
	((DRAWNS,'textarea-vertical-align'), None): cnv_string,
	((DRAWNS,'tile-repeat-offset'), None): cnv_string,
	((DRAWNS,'transform'), None): cnv_string,
	((DRAWNS,'type'), None): cnv_string,
	((DRAWNS,'unit'), None): cnv_string,
	((DRAWNS,'value'), None): cnv_string,
	((DRAWNS,'visible-area-height'), None): cnv_string,
	((DRAWNS,'visible-area-left'), None): cnv_string,
	((DRAWNS,'visible-area-top'), None): cnv_string,
	((DRAWNS,'visible-area-width'), None): cnv_string,
	((DRAWNS,'wrap-influence-on-position'), None): cnv_string,
	((DRAWNS,'z-index'), None): cnv_nonNegativeInteger,
	((FONS,'background-color'), None): cnv_string,
	((FONS,'border-bottom'), None): cnv_string,
	((FONS,'border'), None): cnv_string,
	((FONS,'border-left'), None): cnv_string,
	((FONS,'border-right'), None): cnv_string,
	((FONS,'border-top'), None): cnv_string,
	((FONS,'break-after'), None): cnv_string,
	((FONS,'break-before'), None): cnv_string,
	((FONS,'clip'), None): cnv_string,
	((FONS,'color'), None): cnv_string,
	((FONS,'column-count'), None): cnv_positiveInteger,
	((FONS,'column-gap'), None): cnv_length,
	((FONS,'country'), None): cnv_token,
	((FONS,'end-indent'), None): cnv_length,
	((FONS,'font-family'), None): cnv_string,
	((FONS,'font-size'), None): cnv_string,
	((FONS,'font-style'), None): cnv_string,
	((FONS,'font-variant'), None): cnv_string,
	((FONS,'font-weight'), None): cnv_string,
	((FONS,'height'), None): cnv_string,
	((FONS,'hyphenate'), None): cnv_boolean,
	((FONS,'hyphenation-keep'), None): cnv_string,
	((FONS,'hyphenation-ladder-count'), None): cnv_string,
	((FONS,'hyphenation-push-char-count'), None): cnv_string,
	((FONS,'hyphenation-remain-char-count'), None): cnv_string,
	((FONS,'keep-together'), None): cnv_string,
	((FONS,'keep-with-next'), None): cnv_string,
	((FONS,'language'), None): cnv_token,
	((FONS,'letter-spacing'), None): cnv_string,
	((FONS,'line-height'), None): cnv_string,
	((FONS,'margin-bottom'), None): cnv_string,
	((FONS,'margin'), None): cnv_string,
	((FONS,'margin-left'), None): cnv_string,
	((FONS,'margin-right'), None): cnv_string,
	((FONS,'margin-top'), None): cnv_string,
	((FONS,'max-height'), None): cnv_string,
	((FONS,'max-width'), None): cnv_string,
	((FONS,'min-height'), None): cnv_length,
	((FONS,'min-width'), None): cnv_string,
	((FONS,'orphans'), None): cnv_string,
	((FONS,'padding-bottom'), None): cnv_string,
	((FONS,'padding'), None): cnv_string,
	((FONS,'padding-left'), None): cnv_string,
	((FONS,'padding-right'), None): cnv_string,
	((FONS,'padding-top'), None): cnv_string,
	((FONS,'page-height'), None): cnv_length,
	((FONS,'page-width'), None): cnv_length,
	((FONS,'space-after'), None): cnv_length,
	((FONS,'space-before'), None): cnv_length,
	((FONS,'start-indent'), None): cnv_length,
	((FONS,'text-align'), None): cnv_string,
	((FONS,'text-align-last'), None): cnv_string,
	((FONS,'text-indent'), None): cnv_string,
	((FONS,'text-shadow'), None): cnv_string,
	((FONS,'text-transform'), None): cnv_string,
	((FONS,'widows'), None): cnv_string,
	((FONS,'width'), None): cnv_string,
	((FONS,'wrap-option'), None): cnv_string,
	((FORMNS,'allow-deletes'), None): cnv_boolean,
	((FORMNS,'allow-inserts'), None): cnv_boolean,
	((FORMNS,'allow-updates'), None): cnv_boolean,
	((FORMNS,'apply-design-mode'), None): cnv_boolean,
	((FORMNS,'apply-filter'), None): cnv_boolean,
	((FORMNS,'auto-complete'), None): cnv_boolean,
	((FORMNS,'automatic-focus'), None): cnv_boolean,
	((FORMNS,'bound-column'), None): cnv_string,
	((FORMNS,'button-type'), None): cnv_string,
	((FORMNS,'command'), None): cnv_string,
	((FORMNS,'command-type'), None): cnv_string,
	((FORMNS,'control-implementation'), None): cnv_namespacedToken,
	((FORMNS,'convert-empty-to-null'), None): cnv_boolean,
	((FORMNS,'current-selected'), None): cnv_boolean,
	((FORMNS,'current-state'), None): cnv_string,
#	((FORMNS,u'current-value'), None): cnv_date,
#	((FORMNS,u'current-value'), None): cnv_double,
	((FORMNS,'current-value'), None): cnv_string,
#	((FORMNS,u'current-value'), None): cnv_time,
	((FORMNS,'data-field'), None): cnv_string,
	((FORMNS,'datasource'), None): cnv_string,
	((FORMNS,'default-button'), None): cnv_boolean,
	((FORMNS,'delay-for-repeat'), None): cnv_duration,
	((FORMNS,'detail-fields'), None): cnv_string,
	((FORMNS,'disabled'), None): cnv_boolean,
	((FORMNS,'dropdown'), None): cnv_boolean,
	((FORMNS,'echo-char'), None): cnv_string,
	((FORMNS,'enctype'), None): cnv_string,
	((FORMNS,'escape-processing'), None): cnv_boolean,
	((FORMNS,'filter'), None): cnv_string,
	((FORMNS,'focus-on-click'), None): cnv_boolean,
	((FORMNS,'for'), None): cnv_string,
	((FORMNS,'id'), None): cnv_ID,
	((FORMNS,'ignore-result'), None): cnv_boolean,
	((FORMNS,'image-align'), None): cnv_string,
	((FORMNS,'image-data'), None): cnv_anyURI,
	((FORMNS,'image-position'), None): cnv_string,
	((FORMNS,'is-tristate'), None): cnv_boolean,
	((FORMNS,'label'), None): cnv_string,
	((FORMNS,'list-source'), None): cnv_string,
	((FORMNS,'list-source-type'), None): cnv_string,
	((FORMNS,'master-fields'), None): cnv_string,
	((FORMNS,'max-length'), None): cnv_nonNegativeInteger,
#	((FORMNS,u'max-value'), None): cnv_date,
#	((FORMNS,u'max-value'), None): cnv_double,
	((FORMNS,'max-value'), None): cnv_string,
#	((FORMNS,u'max-value'), None): cnv_time,
	((FORMNS,'method'), None): cnv_string,
#	((FORMNS,u'min-value'), None): cnv_date,
#	((FORMNS,u'min-value'), None): cnv_double,
	((FORMNS,'min-value'), None): cnv_string,
#	((FORMNS,u'min-value'), None): cnv_time,
	((FORMNS,'multi-line'), None): cnv_boolean,
	((FORMNS,'multiple'), None): cnv_boolean,
	((FORMNS,'name'), None): cnv_string,
	((FORMNS,'navigation-mode'), None): cnv_string,
	((FORMNS,'order'), None): cnv_string,
	((FORMNS,'orientation'), None): cnv_string,
	((FORMNS,'page-step-size'), None): cnv_positiveInteger,
	((FORMNS,'printable'), None): cnv_boolean,
	((FORMNS,'property-name'), None): cnv_string,
	((FORMNS,'readonly'), None): cnv_boolean,
	((FORMNS,'selected'), None): cnv_boolean,
	((FORMNS,'size'), None): cnv_nonNegativeInteger,
	((FORMNS,'state'), None): cnv_string,
	((FORMNS,'step-size'), None): cnv_positiveInteger,
	((FORMNS,'tab-cycle'), None): cnv_string,
	((FORMNS,'tab-index'), None): cnv_nonNegativeInteger,
	((FORMNS,'tab-stop'), None): cnv_boolean,
	((FORMNS,'text-style-name'), None): cnv_StyleNameRef,
	((FORMNS,'title'), None): cnv_string,
	((FORMNS,'toggle'), None): cnv_boolean,
	((FORMNS,'validation'), None): cnv_boolean,
#	((FORMNS,u'value'), None): cnv_date,
#	((FORMNS,u'value'), None): cnv_double,
	((FORMNS,'value'), None): cnv_string,
#	((FORMNS,u'value'), None): cnv_time,
	((FORMNS,'visual-effect'), None): cnv_string,
	((FORMNS,'xforms-list-source'), None): cnv_string,
	((FORMNS,'xforms-submission'), None): cnv_string,
	((MANIFESTNS,'algorithm-name'), None): cnv_string,
	((MANIFESTNS,'checksum'), None): cnv_string,
	((MANIFESTNS,'checksum-type'), None): cnv_string,
	((MANIFESTNS,'full-path'), None): cnv_string,
	((MANIFESTNS,'initialisation-vector'), None): cnv_string,
	((MANIFESTNS,'iteration-count'), None): cnv_nonNegativeInteger,
	((MANIFESTNS,'key-derivation-name'), None): cnv_string,
	((MANIFESTNS,'media-type'), None): cnv_string,
	((MANIFESTNS,'salt'), None): cnv_string,
	((MANIFESTNS,'size'), None): cnv_nonNegativeInteger,
	((METANS,'cell-count'), None): cnv_nonNegativeInteger,
	((METANS,'character-count'), None): cnv_nonNegativeInteger,
	((METANS,'date'), None): cnv_dateTime,
	((METANS,'delay'), None): cnv_duration,
	((METANS,'draw-count'), None): cnv_nonNegativeInteger,
	((METANS,'frame-count'), None): cnv_nonNegativeInteger,
	((METANS,'image-count'), None): cnv_nonNegativeInteger,
	((METANS,'name'), None): cnv_string,
	((METANS,'non-whitespace-character-count'), None): cnv_nonNegativeInteger,
	((METANS,'object-count'), None): cnv_nonNegativeInteger,
	((METANS,'ole-object-count'), None): cnv_nonNegativeInteger,
	((METANS,'page-count'), None): cnv_nonNegativeInteger,
	((METANS,'paragraph-count'), None): cnv_nonNegativeInteger,
	((METANS,'row-count'), None): cnv_nonNegativeInteger,
	((METANS,'sentence-count'), None): cnv_nonNegativeInteger,
	((METANS,'syllable-count'), None): cnv_nonNegativeInteger,
	((METANS,'table-count'), None): cnv_nonNegativeInteger,
	((METANS,'value-type'), None): cnv_metavaluetype,
	((METANS,'word-count'), None): cnv_nonNegativeInteger,
	((NUMBERNS,'automatic-order'), None): cnv_boolean,
	((NUMBERNS,'calendar'), None): cnv_string,
	((NUMBERNS,'country'), None): cnv_token,
	((NUMBERNS,'decimal-places'), None): cnv_integer,
	((NUMBERNS,'decimal-replacement'), None): cnv_string,
	((NUMBERNS,'denominator-value'), None): cnv_integer,
	((NUMBERNS,'display-factor'), None): cnv_double,
	((NUMBERNS,'format-source'), None): cnv_string,
	((NUMBERNS,'grouping'), None): cnv_boolean,
	((NUMBERNS,'language'), None): cnv_token,
	((NUMBERNS,'min-denominator-digits'), None): cnv_integer,
	((NUMBERNS,'min-exponent-digits'), None): cnv_integer,
	((NUMBERNS,'min-integer-digits'), None): cnv_integer,
	((NUMBERNS,'min-numerator-digits'), None): cnv_integer,
	((NUMBERNS,'position'), None): cnv_integer,
	((NUMBERNS,'possessive-form'), None): cnv_boolean,
	((NUMBERNS,'style'), None): cnv_string,
	((NUMBERNS,'textual'), None): cnv_boolean,
	((NUMBERNS,'title'), None): cnv_string,
	((NUMBERNS,'transliteration-country'), None): cnv_token,
	((NUMBERNS,'transliteration-format'), None): cnv_string,
	((NUMBERNS,'transliteration-language'), None): cnv_token,
	((NUMBERNS,'transliteration-style'), None): cnv_string,
	((NUMBERNS,'truncate-on-overflow'), None): cnv_boolean,
	((OFFICENS,'automatic-update'), None): cnv_boolean,
	((OFFICENS,'boolean-value'), None): cnv_boolean,
	((OFFICENS,'conversion-mode'), None): cnv_string,
	((OFFICENS,'currency'), None): cnv_string,
	((OFFICENS,'date-value'), None): cnv_dateTime,
	((OFFICENS,'dde-application'), None): cnv_string,
	((OFFICENS,'dde-item'), None): cnv_string,
	((OFFICENS,'dde-topic'), None): cnv_string,
	((OFFICENS,'display'), None): cnv_boolean,
	((OFFICENS,'mimetype'), None): cnv_string,
	((OFFICENS,'name'), None): cnv_string,
	((OFFICENS,'process-content'), None): cnv_boolean,
	((OFFICENS,'server-map'), None): cnv_boolean,
	((OFFICENS,'string-value'), None): cnv_string,
	((OFFICENS,'target-frame'), None): cnv_string,
	((OFFICENS,'target-frame-name'), None): cnv_string,
	((OFFICENS,'time-value'), None): cnv_duration,
	((OFFICENS,'title'), None): cnv_string,
	((OFFICENS,'value'), None): cnv_double,
	((OFFICENS,'value-type'), None): cnv_string,
	((OFFICENS,'version'), None): cnv_string,
	((PRESENTATIONNS,'action'), None): cnv_string,
	((PRESENTATIONNS,'animations'), None): cnv_string,
	((PRESENTATIONNS,'background-objects-visible'), None): cnv_boolean,
	((PRESENTATIONNS,'background-visible'), None): cnv_boolean,
	((PRESENTATIONNS,'class'), None): cnv_string,
	((PRESENTATIONNS,'class-names'), None): cnv_NCNames,
	((PRESENTATIONNS,'delay'), None): cnv_duration,
	((PRESENTATIONNS,'direction'), None): cnv_string,
	((PRESENTATIONNS,'display-date-time'), None): cnv_boolean,
	((PRESENTATIONNS,'display-footer'), None): cnv_boolean,
	((PRESENTATIONNS,'display-header'), None): cnv_boolean,
	((PRESENTATIONNS,'display-page-number'), None): cnv_boolean,
	((PRESENTATIONNS,'duration'), None): cnv_string,
	((PRESENTATIONNS,'effect'), None): cnv_string,
	((PRESENTATIONNS,'endless'), None): cnv_boolean,
	((PRESENTATIONNS,'force-manual'), None): cnv_boolean,
	((PRESENTATIONNS,'full-screen'), None): cnv_boolean,
	((PRESENTATIONNS,'group-id'), None): cnv_string,
	((PRESENTATIONNS,'master-element'), None): cnv_IDREF,
	((PRESENTATIONNS,'mouse-as-pen'), None): cnv_boolean,
	((PRESENTATIONNS,'mouse-visible'), None): cnv_boolean,
	((PRESENTATIONNS,'name'), None): cnv_string,
	((PRESENTATIONNS,'node-type'), None): cnv_string,
	((PRESENTATIONNS,'object'), None): cnv_string,
	((PRESENTATIONNS,'pages'), None): cnv_string,
	((PRESENTATIONNS,'path-id'), None): cnv_string,
	((PRESENTATIONNS,'pause'), None): cnv_duration,
	((PRESENTATIONNS,'placeholder'), None): cnv_boolean,
	((PRESENTATIONNS,'play-full'), None): cnv_boolean,
	((PRESENTATIONNS,'presentation-page-layout-name'), None): cnv_StyleNameRef,
	((PRESENTATIONNS,'preset-class'), None): cnv_string,
	((PRESENTATIONNS,'preset-id'), None): cnv_string,
	((PRESENTATIONNS,'preset-sub-type'), None): cnv_string,
	((PRESENTATIONNS,'show'), None): cnv_string,
	((PRESENTATIONNS,'show-end-of-presentation-slide'), None): cnv_boolean,
	((PRESENTATIONNS,'show-logo'), None): cnv_boolean,
	((PRESENTATIONNS,'source'), None): cnv_string,
	((PRESENTATIONNS,'speed'), None): cnv_string,
	((PRESENTATIONNS,'start-page'), None): cnv_string,
	((PRESENTATIONNS,'start-scale'), None): cnv_string,
	((PRESENTATIONNS,'start-with-navigator'), None): cnv_boolean,
	((PRESENTATIONNS,'stay-on-top'), None): cnv_boolean,
	((PRESENTATIONNS,'style-name'), None): cnv_StyleNameRef,
	((PRESENTATIONNS,'transition-on-click'), None): cnv_string,
	((PRESENTATIONNS,'transition-speed'), None): cnv_string,
	((PRESENTATIONNS,'transition-style'), None): cnv_string,
	((PRESENTATIONNS,'transition-type'), None): cnv_string,
	((PRESENTATIONNS,'use-date-time-name'), None): cnv_string,
	((PRESENTATIONNS,'use-footer-name'), None): cnv_string,
	((PRESENTATIONNS,'use-header-name'), None): cnv_string,
	((PRESENTATIONNS,'user-transformed'), None): cnv_boolean,
	((PRESENTATIONNS,'verb'), None): cnv_nonNegativeInteger,
	((PRESENTATIONNS,'visibility'), None): cnv_string,
	((SCRIPTNS,'event-name'), None): cnv_formula,
	((SCRIPTNS,'language'), None): cnv_formula,
	((SCRIPTNS,'macro-name'), None): cnv_string,
	((SMILNS,'accelerate'), None): cnv_double,
	((SMILNS,'accumulate'), None): cnv_string,
	((SMILNS,'additive'), None): cnv_string,
	((SMILNS,'attributeName'), None): cnv_string,
	((SMILNS,'autoReverse'), None): cnv_boolean,
	((SMILNS,'begin'), None): cnv_string,
	((SMILNS,'by'), None): cnv_string,
	((SMILNS,'calcMode'), None): cnv_string,
	((SMILNS,'decelerate'), None): cnv_double,
	((SMILNS,'direction'), None): cnv_string,
	((SMILNS,'dur'), None): cnv_string,
	((SMILNS,'end'), None): cnv_string,
	((SMILNS,'endsync'), None): cnv_string,
	((SMILNS,'fadeColor'), None): cnv_string,
	((SMILNS,'fill'), None): cnv_string,
	((SMILNS,'fillDefault'), None): cnv_string,
	((SMILNS,'from'), None): cnv_string,
	((SMILNS,'keySplines'), None): cnv_string,
	((SMILNS,'keyTimes'), None): cnv_string,
	((SMILNS,'mode'), None): cnv_string,
	((SMILNS,'repeatCount'), None): cnv_nonNegativeInteger,
	((SMILNS,'repeatDur'), None): cnv_string,
	((SMILNS,'restart'), None): cnv_string,
	((SMILNS,'restartDefault'), None): cnv_string,
	((SMILNS,'subtype'), None): cnv_string,
	((SMILNS,'targetElement'), None): cnv_IDREF,
	((SMILNS,'to'), None): cnv_string,
	((SMILNS,'type'), None): cnv_string,
	((SMILNS,'values'), None): cnv_string,
	((STYLENS,'adjustment'), None): cnv_string,
	((STYLENS,'apply-style-name'), None): cnv_StyleNameRef,
	((STYLENS,'auto-text-indent'), None): cnv_boolean,
	((STYLENS,'auto-update'), None): cnv_boolean,
	((STYLENS,'background-transparency'), None): cnv_string,
	((STYLENS,'base-cell-address'), None): cnv_string,
	((STYLENS,'border-line-width-bottom'), None): cnv_string,
	((STYLENS,'border-line-width'), None): cnv_string,
	((STYLENS,'border-line-width-left'), None): cnv_string,
	((STYLENS,'border-line-width-right'), None): cnv_string,
	((STYLENS,'border-line-width-top'), None): cnv_string,
	((STYLENS,'cell-protect'), None): cnv_string,
	((STYLENS,'char'), None): cnv_string,
	((STYLENS,'class'), None): cnv_string,
	((STYLENS,'color'), None): cnv_string,
	((STYLENS,'column-width'), None): cnv_string,
	((STYLENS,'condition'), None): cnv_string,
	((STYLENS,'country-asian'), None): cnv_string,
	((STYLENS,'country-complex'), None): cnv_string,
	((STYLENS,'data-style-name'), None): cnv_StyleNameRef,
	((STYLENS,'decimal-places'), None): cnv_string,
	((STYLENS,'default-outline-level'), None): cnv_positiveInteger,
	((STYLENS,'diagonal-bl-tr'), None): cnv_string,
	((STYLENS,'diagonal-bl-tr-widths'), None): cnv_string,
	((STYLENS,'diagonal-tl-br'), None): cnv_string,
	((STYLENS,'diagonal-tl-br-widths'), None): cnv_string,
	((STYLENS,'direction'), None): cnv_string,
	((STYLENS,'display'), None): cnv_boolean,
	((STYLENS,'display-name'), None): cnv_string,
	((STYLENS,'distance-after-sep'), None): cnv_length,
	((STYLENS,'distance-before-sep'), None): cnv_length,
	((STYLENS,'distance'), None): cnv_length,
	((STYLENS,'dynamic-spacing'), None): cnv_boolean,
	((STYLENS,'editable'), None): cnv_boolean,
	((STYLENS,'family'), None): cnv_family,
	((STYLENS,'filter-name'), None): cnv_string,
	((STYLENS,'first-page-number'), None): cnv_string,
	((STYLENS,'flow-with-text'), None): cnv_boolean,
	((STYLENS,'font-adornments'), None): cnv_string,
	((STYLENS,'font-charset'), None): cnv_string,
	((STYLENS,'font-charset-asian'), None): cnv_string,
	((STYLENS,'font-charset-complex'), None): cnv_string,
	((STYLENS,'font-family-asian'), None): cnv_string,
	((STYLENS,'font-family-complex'), None): cnv_string,
	((STYLENS,'font-family-generic-asian'), None): cnv_string,
	((STYLENS,'font-family-generic'), None): cnv_string,
	((STYLENS,'font-family-generic-complex'), None): cnv_string,
	((STYLENS,'font-independent-line-spacing'), None): cnv_boolean,
	((STYLENS,'font-name-asian'), None): cnv_string,
	((STYLENS,'font-name'), None): cnv_string,
	((STYLENS,'font-name-complex'), None): cnv_string,
	((STYLENS,'font-pitch-asian'), None): cnv_string,
	((STYLENS,'font-pitch'), None): cnv_string,
	((STYLENS,'font-pitch-complex'), None): cnv_string,
	((STYLENS,'font-relief'), None): cnv_string,
	((STYLENS,'font-size-asian'), None): cnv_string,
	((STYLENS,'font-size-complex'), None): cnv_string,
	((STYLENS,'font-size-rel-asian'), None): cnv_length,
	((STYLENS,'font-size-rel'), None): cnv_length,
	((STYLENS,'font-size-rel-complex'), None): cnv_length,
	((STYLENS,'font-style-asian'), None): cnv_string,
	((STYLENS,'font-style-complex'), None): cnv_string,
	((STYLENS,'font-style-name-asian'), None): cnv_string,
	((STYLENS,'font-style-name'), None): cnv_string,
	((STYLENS,'font-style-name-complex'), None): cnv_string,
	((STYLENS,'font-weight-asian'), None): cnv_string,
	((STYLENS,'font-weight-complex'), None): cnv_string,
	((STYLENS,'footnote-max-height'), None): cnv_length,
	((STYLENS,'glyph-orientation-vertical'), None): cnv_string,
	((STYLENS,'height'), None): cnv_string,
	((STYLENS,'horizontal-pos'), None): cnv_string,
	((STYLENS,'horizontal-rel'), None): cnv_string,
	((STYLENS,'justify-single-word'), None): cnv_boolean,
	((STYLENS,'language-asian'), None): cnv_string,
	((STYLENS,'language-complex'), None): cnv_string,
	((STYLENS,'layout-grid-base-height'), None): cnv_length,
	((STYLENS,'layout-grid-color'), None): cnv_string,
	((STYLENS,'layout-grid-display'), None): cnv_boolean,
	((STYLENS,'layout-grid-lines'), None): cnv_string,
	((STYLENS,'layout-grid-mode'), None): cnv_string,
	((STYLENS,'layout-grid-print'), None): cnv_boolean,
	((STYLENS,'layout-grid-ruby-below'), None): cnv_boolean,
	((STYLENS,'layout-grid-ruby-height'), None): cnv_length,
	((STYLENS,'leader-char'), None): cnv_string,
	((STYLENS,'leader-color'), None): cnv_string,
	((STYLENS,'leader-style'), None): cnv_string,
	((STYLENS,'leader-text'), None): cnv_string,
	((STYLENS,'leader-text-style'), None): cnv_StyleNameRef,
	((STYLENS,'leader-type'), None): cnv_string,
	((STYLENS,'leader-width'), None): cnv_string,
	((STYLENS,'legend-expansion-aspect-ratio'), None): cnv_double,
	((STYLENS,'legend-expansion'), None): cnv_string,
	((STYLENS,'length'), None): cnv_positiveInteger,
	((STYLENS,'letter-kerning'), None): cnv_boolean,
	((STYLENS,'line-break'), None): cnv_string,
	((STYLENS,'line-height-at-least'), None): cnv_string,
	((STYLENS,'line-spacing'), None): cnv_length,
	((STYLENS,'line-style'), None): cnv_string,
	((STYLENS,'lines'), None): cnv_positiveInteger,
	((STYLENS,'list-style-name'), None): cnv_StyleNameRef,
	((STYLENS,'master-page-name'), None): cnv_StyleNameRef,
	((STYLENS,'may-break-between-rows'), None): cnv_boolean,
	((STYLENS,'min-row-height'), None): cnv_string,
	((STYLENS,'mirror'), None): cnv_string,
	((STYLENS,'name'), None): cnv_NCName,
 	((STYLENS,'name'), (STYLENS,'font-face')): cnv_string,
	((STYLENS,'next-style-name'), None): cnv_StyleNameRef,
	((STYLENS,'num-format'), None): cnv_string,
	((STYLENS,'num-letter-sync'), None): cnv_boolean,
	((STYLENS,'num-prefix'), None): cnv_string,
	((STYLENS,'num-suffix'), None): cnv_string,
	((STYLENS,'number-wrapped-paragraphs'), None): cnv_string,
	((STYLENS,'overflow-behavior'), None): cnv_string,
	((STYLENS,'page-layout-name'), None): cnv_StyleNameRef,
	((STYLENS,'page-number'), None): cnv_string,
	((STYLENS,'page-usage'), None): cnv_string,
	((STYLENS,'paper-tray-name'), None): cnv_string,
	((STYLENS,'parent-style-name'), None): cnv_StyleNameRef,
	((STYLENS,'position'), (STYLENS,'tab-stop')): cnv_length,
	((STYLENS,'position'), None): cnv_string,
	((STYLENS,'print'), None): cnv_string,
	((STYLENS,'print-content'), None): cnv_boolean,
	((STYLENS,'print-orientation'), None): cnv_string,
	((STYLENS,'print-page-order'), None): cnv_string,
	((STYLENS,'protect'), None): cnv_boolean,
	((STYLENS,'punctuation-wrap'), None): cnv_string,
	((STYLENS,'register-true'), None): cnv_boolean,
	((STYLENS,'register-truth-ref-style-name'), None): cnv_string,
	((STYLENS,'rel-column-width'), None): cnv_string,
	((STYLENS,'rel-height'), None): cnv_string,
	((STYLENS,'rel-width'), None): cnv_string,
	((STYLENS,'repeat'), None): cnv_string,
	((STYLENS,'repeat-content'), None): cnv_boolean,
	((STYLENS,'rotation-align'), None): cnv_string,
	((STYLENS,'rotation-angle'), None): cnv_string,
	((STYLENS,'row-height'), None): cnv_string,
	((STYLENS,'ruby-align'), None): cnv_string,
	((STYLENS,'ruby-position'), None): cnv_string,
	((STYLENS,'run-through'), None): cnv_string,
	((STYLENS,'scale-to'), None): cnv_string,
	((STYLENS,'scale-to-pages'), None): cnv_string,
	((STYLENS,'script-type'), None): cnv_string,
	((STYLENS,'shadow'), None): cnv_string,
	((STYLENS,'shrink-to-fit'), None): cnv_boolean,
	((STYLENS,'snap-to-layout-grid'), None): cnv_boolean,
	((STYLENS,'style'), None): cnv_string,
	((STYLENS,'style-name'), None): cnv_StyleNameRef,
	((STYLENS,'tab-stop-distance'), None): cnv_string,
	((STYLENS,'table-centering'), None): cnv_string,
	((STYLENS,'text-align-source'), None): cnv_string,
	((STYLENS,'text-autospace'), None): cnv_string,
	((STYLENS,'text-blinking'), None): cnv_boolean,
	((STYLENS,'text-combine'), None): cnv_string,
	((STYLENS,'text-combine-end-char'), None): cnv_string,
	((STYLENS,'text-combine-start-char'), None): cnv_string,
	((STYLENS,'text-emphasize'), None): cnv_string,
	((STYLENS,'text-line-through-color'), None): cnv_string,
	((STYLENS,'text-line-through-mode'), None): cnv_string,
	((STYLENS,'text-line-through-style'), None): cnv_string,
	((STYLENS,'text-line-through-text'), None): cnv_string,
	((STYLENS,'text-line-through-text-style'), None): cnv_string,
	((STYLENS,'text-line-through-type'), None): cnv_string,
	((STYLENS,'text-line-through-width'), None): cnv_string,
	((STYLENS,'text-outline'), None): cnv_boolean,
	((STYLENS,'text-position'), None): cnv_string,
	((STYLENS,'text-rotation-angle'), None): cnv_string,
	((STYLENS,'text-rotation-scale'), None): cnv_string,
	((STYLENS,'text-scale'), None): cnv_string,
	((STYLENS,'text-underline-color'), None): cnv_string,
	((STYLENS,'text-underline-mode'), None): cnv_string,
	((STYLENS,'text-underline-style'), None): cnv_string,
	((STYLENS,'text-underline-type'), None): cnv_string,
	((STYLENS,'text-underline-width'), None): cnv_string,
	((STYLENS,'type'), None): cnv_string,
	((STYLENS,'use-optimal-column-width'), None): cnv_boolean,
	((STYLENS,'use-optimal-row-height'), None): cnv_boolean,
	((STYLENS,'use-window-font-color'), None): cnv_boolean,
	((STYLENS,'vertical-align'), None): cnv_string,
	((STYLENS,'vertical-pos'), None): cnv_string,
	((STYLENS,'vertical-rel'), None): cnv_string,
	((STYLENS,'volatile'), None): cnv_boolean,
	((STYLENS,'width'), None): cnv_string,
	((STYLENS,'wrap'), None): cnv_string,
	((STYLENS,'wrap-contour'), None): cnv_boolean,
	((STYLENS,'wrap-contour-mode'), None): cnv_string,
	((STYLENS,'wrap-dynamic-threshold'), None): cnv_length,
	((STYLENS,'writing-mode-automatic'), None): cnv_boolean,
	((STYLENS,'writing-mode'), None): cnv_string,
	((SVGNS,'accent-height'), None): cnv_integer,
	((SVGNS,'alphabetic'), None): cnv_integer,
	((SVGNS,'ascent'), None): cnv_integer,
	((SVGNS,'bbox'), None): cnv_string,
	((SVGNS,'cap-height'), None): cnv_integer,
	((SVGNS,'cx'), None): cnv_string,
	((SVGNS,'cy'), None): cnv_string,
	((SVGNS,'d'), None): cnv_string,
	((SVGNS,'descent'), None): cnv_integer,
	((SVGNS,'fill-rule'), None): cnv_string,
	((SVGNS,'font-family'), None): cnv_string,
	((SVGNS,'font-size'), None): cnv_string,
	((SVGNS,'font-stretch'), None): cnv_string,
	((SVGNS,'font-style'), None): cnv_string,
	((SVGNS,'font-variant'), None): cnv_string,
	((SVGNS,'font-weight'), None): cnv_string,
	((SVGNS,'fx'), None): cnv_string,
	((SVGNS,'fy'), None): cnv_string,
	((SVGNS,'gradientTransform'), None): cnv_string,
	((SVGNS,'gradientUnits'), None): cnv_string,
	((SVGNS,'hanging'), None): cnv_integer,
	((SVGNS,'height'), None): cnv_length,
	((SVGNS,'ideographic'), None): cnv_integer,
	((SVGNS,'mathematical'), None): cnv_integer,
	((SVGNS,'name'), None): cnv_string,
	((SVGNS,'offset'), None): cnv_string,
	((SVGNS,'origin'), None): cnv_string,
	((SVGNS,'overline-position'), None): cnv_integer,
	((SVGNS,'overline-thickness'), None): cnv_integer,
	((SVGNS,'panose-1'), None): cnv_string,
	((SVGNS,'path'), None): cnv_string,
	((SVGNS,'r'), None): cnv_length,
	((SVGNS,'rx'), None): cnv_length,
	((SVGNS,'ry'), None): cnv_length,
	((SVGNS,'slope'), None): cnv_integer,
	((SVGNS,'spreadMethod'), None): cnv_string,
	((SVGNS,'stemh'), None): cnv_integer,
	((SVGNS,'stemv'), None): cnv_integer,
	((SVGNS,'stop-color'), None): cnv_string,
	((SVGNS,'stop-opacity'), None): cnv_double,
	((SVGNS,'strikethrough-position'), None): cnv_integer,
	((SVGNS,'strikethrough-thickness'), None): cnv_integer,
	((SVGNS,'string'), None): cnv_string,
	((SVGNS,'stroke-color'), None): cnv_string,
	((SVGNS,'stroke-opacity'), None): cnv_string,
	((SVGNS,'stroke-width'), None): cnv_length,
	((SVGNS,'type'), None): cnv_string,
	((SVGNS,'underline-position'), None): cnv_integer,
	((SVGNS,'underline-thickness'), None): cnv_integer,
	((SVGNS,'unicode-range'), None): cnv_string,
	((SVGNS,'units-per-em'), None): cnv_integer,
	((SVGNS,'v-alphabetic'), None): cnv_integer,
	((SVGNS,'v-hanging'), None): cnv_integer,
	((SVGNS,'v-ideographic'), None): cnv_integer,
	((SVGNS,'v-mathematical'), None): cnv_integer,
	((SVGNS,'viewBox'), None): cnv_viewbox,
	((SVGNS,'width'), None): cnv_length,
	((SVGNS,'widths'), None): cnv_string,
	((SVGNS,'x'), None): cnv_length,
	((SVGNS,'x-height'), None): cnv_integer,
	((SVGNS,'x1'), None): cnv_lengthorpercent,
	((SVGNS,'x2'), None): cnv_lengthorpercent,
	((SVGNS,'y'), None): cnv_length,
	((SVGNS,'y1'), None): cnv_lengthorpercent,
	((SVGNS,'y2'), None): cnv_lengthorpercent,
	((TABLENS,'acceptance-state'), None): cnv_string,
	((TABLENS,'add-empty-lines'), None): cnv_boolean,
	((TABLENS,'algorithm'), None): cnv_formula,
	((TABLENS,'align'), None): cnv_string,
	((TABLENS,'allow-empty-cell'), None): cnv_boolean,
	((TABLENS,'application-data'), None): cnv_string,
	((TABLENS,'automatic-find-labels'), None): cnv_boolean,
	((TABLENS,'base-cell-address'), None): cnv_string,
	((TABLENS,'bind-styles-to-content'), None): cnv_boolean,
	((TABLENS,'border-color'), None): cnv_string,
	((TABLENS,'border-model'), None): cnv_string,
	((TABLENS,'buttons'), None): cnv_string,
	((TABLENS,'buttons'), None): cnv_string,
	((TABLENS,'case-sensitive'), None): cnv_boolean,
	((TABLENS,'case-sensitive'), None): cnv_string,
	((TABLENS,'cell-address'), None): cnv_string,
	((TABLENS,'cell-range-address'), None): cnv_string,
	((TABLENS,'cell-range-address'), None): cnv_string,
	((TABLENS,'cell-range'), None): cnv_string,
	((TABLENS,'column'), None): cnv_integer,
	((TABLENS,'comment'), None): cnv_string,
	((TABLENS,'condition'), None): cnv_formula,
	((TABLENS,'condition-source'), None): cnv_string,
	((TABLENS,'condition-source-range-address'), None): cnv_string,
	((TABLENS,'contains-error'), None): cnv_boolean,
	((TABLENS,'contains-header'), None): cnv_boolean,
	((TABLENS,'content-validation-name'), None): cnv_string,
	((TABLENS,'copy-back'), None): cnv_boolean,
	((TABLENS,'copy-formulas'), None): cnv_boolean,
	((TABLENS,'copy-styles'), None): cnv_boolean,
	((TABLENS,'count'), None): cnv_positiveInteger,
	((TABLENS,'country'), None): cnv_token,
	((TABLENS,'data-cell-range-address'), None): cnv_string,
	((TABLENS,'data-field'), None): cnv_string,
	((TABLENS,'data-type'), None): cnv_string,
	((TABLENS,'database-name'), None): cnv_string,
	((TABLENS,'database-table-name'), None): cnv_string,
	((TABLENS,'date-end'), None): cnv_string,
	((TABLENS,'date-start'), None): cnv_string,
	((TABLENS,'date-value'), None): cnv_date,
	((TABLENS,'default-cell-style-name'), None): cnv_StyleNameRef,
	((TABLENS,'direction'), None): cnv_string,
	((TABLENS,'display-border'), None): cnv_boolean,
	((TABLENS,'display'), None): cnv_boolean,
	((TABLENS,'display-duplicates'), None): cnv_boolean,
	((TABLENS,'display-filter-buttons'), None): cnv_boolean,
	((TABLENS,'display-list'), None): cnv_string,
	((TABLENS,'display-member-mode'), None): cnv_string,
	((TABLENS,'drill-down-on-double-click'), None): cnv_boolean,
	((TABLENS,'enabled'), None): cnv_boolean,
	((TABLENS,'end-cell-address'), None): cnv_string,
	((TABLENS,'end'), None): cnv_string,
	((TABLENS,'end-column'), None): cnv_integer,
	((TABLENS,'end-position'), None): cnv_integer,
	((TABLENS,'end-row'), None): cnv_integer,
	((TABLENS,'end-table'), None): cnv_integer,
	((TABLENS,'end-x'), None): cnv_length,
	((TABLENS,'end-y'), None): cnv_length,
	((TABLENS,'execute'), None): cnv_boolean,
	((TABLENS,'expression'), None): cnv_formula,
	((TABLENS,'field-name'), None): cnv_string,
	((TABLENS,'field-number'), None): cnv_nonNegativeInteger,
	((TABLENS,'field-number'), None): cnv_string,
	((TABLENS,'filter-name'), None): cnv_string,
	((TABLENS,'filter-options'), None): cnv_string,
	((TABLENS,'formula'), None): cnv_formula,
	((TABLENS,'function'), None): cnv_string,
	((TABLENS,'function'), None): cnv_string,
	((TABLENS,'grand-total'), None): cnv_string,
	((TABLENS,'group-by-field-number'), None): cnv_nonNegativeInteger,
	((TABLENS,'grouped-by'), None): cnv_string,
	((TABLENS,'has-persistent-data'), None): cnv_boolean,
	((TABLENS,'id'), None): cnv_string,
	((TABLENS,'identify-categories'), None): cnv_boolean,
	((TABLENS,'ignore-empty-rows'), None): cnv_boolean,
	((TABLENS,'index'), None): cnv_nonNegativeInteger,
	((TABLENS,'is-active'), None): cnv_boolean,
	((TABLENS,'is-data-layout-field'), None): cnv_string,
	((TABLENS,'is-selection'), None): cnv_boolean,
	((TABLENS,'is-sub-table'), None): cnv_boolean,
	((TABLENS,'label-cell-range-address'), None): cnv_string,
	((TABLENS,'language'), None): cnv_token,
	((TABLENS,'language'), None): cnv_token,
	((TABLENS,'last-column-spanned'), None): cnv_positiveInteger,
	((TABLENS,'last-row-spanned'), None): cnv_positiveInteger,
	((TABLENS,'layout-mode'), None): cnv_string,
	((TABLENS,'link-to-source-data'), None): cnv_boolean,
	((TABLENS,'marked-invalid'), None): cnv_boolean,
	((TABLENS,'matrix-covered'), None): cnv_boolean,
	((TABLENS,'maximum-difference'), None): cnv_double,
	((TABLENS,'member-count'), None): cnv_nonNegativeInteger,
	((TABLENS,'member-name'), None): cnv_string,
	((TABLENS,'member-type'), None): cnv_string,
	((TABLENS,'message-type'), None): cnv_string,
	((TABLENS,'mode'), None): cnv_string,
	((TABLENS,'multi-deletion-spanned'), None): cnv_integer,
	((TABLENS,'name'), None): cnv_string,
	((TABLENS,'name'), None): cnv_string,
	((TABLENS,'null-year'), None): cnv_positiveInteger,
	((TABLENS,'number-columns-repeated'), None): cnv_positiveInteger,
	((TABLENS,'number-columns-spanned'), None): cnv_positiveInteger,
	((TABLENS,'number-matrix-columns-spanned'), None): cnv_positiveInteger,
	((TABLENS,'number-matrix-rows-spanned'), None): cnv_positiveInteger,
	((TABLENS,'number-rows-repeated'), None): cnv_positiveInteger,
	((TABLENS,'number-rows-spanned'), None): cnv_positiveInteger,
	((TABLENS,'object-name'), None): cnv_string,
	((TABLENS,'on-update-keep-size'), None): cnv_boolean,
	((TABLENS,'on-update-keep-styles'), None): cnv_boolean,
	((TABLENS,'operator'), None): cnv_string,
	((TABLENS,'operator'), None): cnv_string,
	((TABLENS,'order'), None): cnv_string,
	((TABLENS,'orientation'), None): cnv_string,
	((TABLENS,'orientation'), None): cnv_string,
	((TABLENS,'page-breaks-on-group-change'), None): cnv_boolean,
	((TABLENS,'parse-sql-statement'), None): cnv_boolean,
	((TABLENS,'password'), None): cnv_string,
	((TABLENS,'position'), None): cnv_integer,
	((TABLENS,'precision-as-shown'), None): cnv_boolean,
	((TABLENS,'print'), None): cnv_boolean,
	((TABLENS,'print-ranges'), None): cnv_string,
	((TABLENS,'protect'), None): cnv_boolean,
	((TABLENS,'protected'), None): cnv_boolean,
	((TABLENS,'protection-key'), None): cnv_string,
	((TABLENS,'query-name'), None): cnv_string,
	((TABLENS,'range-usable-as'), None): cnv_string,
	((TABLENS,'refresh-delay'), None): cnv_boolean,
	((TABLENS,'refresh-delay'), None): cnv_duration,
	((TABLENS,'rejecting-change-id'), None): cnv_string,
	((TABLENS,'row'), None): cnv_integer,
	((TABLENS,'scenario-ranges'), None): cnv_string,
	((TABLENS,'search-criteria-must-apply-to-whole-cell'), None): cnv_boolean,
	((TABLENS,'selected-page'), None): cnv_string,
	((TABLENS,'show-details'), None): cnv_boolean,
	((TABLENS,'show-empty'), None): cnv_boolean,
	((TABLENS,'show-empty'), None): cnv_string,
	((TABLENS,'show-filter-button'), None): cnv_boolean,
	((TABLENS,'sort-mode'), None): cnv_string,
	((TABLENS,'source-cell-range-addresses'), None): cnv_string,
	((TABLENS,'source-cell-range-addresses'), None): cnv_string,
	((TABLENS,'source-field-name'), None): cnv_string,
	((TABLENS,'source-field-name'), None): cnv_string,
	((TABLENS,'source-name'), None): cnv_string,
	((TABLENS,'sql-statement'), None): cnv_string,
	((TABLENS,'start'), None): cnv_string,
	((TABLENS,'start-column'), None): cnv_integer,
	((TABLENS,'start-position'), None): cnv_integer,
	((TABLENS,'start-row'), None): cnv_integer,
	((TABLENS,'start-table'), None): cnv_integer,
	((TABLENS,'status'), None): cnv_string,
	((TABLENS,'step'), None): cnv_double,
	((TABLENS,'steps'), None): cnv_positiveInteger,
	((TABLENS,'structure-protected'), None): cnv_boolean,
	((TABLENS,'style-name'), None): cnv_StyleNameRef,
	((TABLENS,'table-background'), None): cnv_boolean,
	((TABLENS,'table'), None): cnv_integer,
	((TABLENS,'table-name'), None): cnv_string,
	((TABLENS,'target-cell-address'), None): cnv_string,
	((TABLENS,'target-cell-address'), None): cnv_string,
	((TABLENS,'target-range-address'), None): cnv_string,
	((TABLENS,'target-range-address'), None): cnv_string,
	((TABLENS,'title'), None): cnv_string,
	((TABLENS,'track-changes'), None): cnv_boolean,
	((TABLENS,'type'), None): cnv_string,
	((TABLENS,'use-labels'), None): cnv_string,
	((TABLENS,'use-regular-expressions'), None): cnv_boolean,
	((TABLENS,'used-hierarchy'), None): cnv_integer,
	((TABLENS,'user-name'), None): cnv_string,
	((TABLENS,'value'), None): cnv_string,
	((TABLENS,'value'), None): cnv_string,
	((TABLENS,'value-type'), None): cnv_string,
	((TABLENS,'visibility'), None): cnv_string,
	((TEXTNS,'active'), None): cnv_boolean,
	((TEXTNS,'address'), None): cnv_string,
	((TEXTNS,'alphabetical-separators'), None): cnv_boolean,
	((TEXTNS,'anchor-page-number'), None): cnv_positiveInteger,
	((TEXTNS,'anchor-type'), None): cnv_string,
	((TEXTNS,'animation'), None): cnv_string,
	((TEXTNS,'animation-delay'), None): cnv_string,
	((TEXTNS,'animation-direction'), None): cnv_string,
	((TEXTNS,'animation-repeat'), None): cnv_string,
	((TEXTNS,'animation-start-inside'), None): cnv_boolean,
	((TEXTNS,'animation-steps'), None): cnv_length,
	((TEXTNS,'animation-stop-inside'), None): cnv_boolean,
	((TEXTNS,'annote'), None): cnv_string,
	((TEXTNS,'author'), None): cnv_string,
	((TEXTNS,'bibliography-data-field'), None): cnv_string,
	((TEXTNS,'bibliography-type'), None): cnv_string,
	((TEXTNS,'booktitle'), None): cnv_string,
	((TEXTNS,'bullet-char'), None): cnv_string,
	((TEXTNS,'bullet-relative-size'), None): cnv_string,
	((TEXTNS,'c'), None): cnv_nonNegativeInteger,
	((TEXTNS,'capitalize-entries'), None): cnv_boolean,
	((TEXTNS,'caption-sequence-format'), None): cnv_string,
	((TEXTNS,'caption-sequence-name'), None): cnv_string,
	((TEXTNS,'change-id'), None): cnv_IDREF,
	((TEXTNS,'chapter'), None): cnv_string,
	((TEXTNS,'citation-body-style-name'), None): cnv_StyleNameRef,
	((TEXTNS,'citation-style-name'), None): cnv_StyleNameRef,
	((TEXTNS,'class-names'), None): cnv_NCNames,
	((TEXTNS,'column-name'), None): cnv_string,
	((TEXTNS,'combine-entries'), None): cnv_boolean,
	((TEXTNS,'combine-entries-with-dash'), None): cnv_boolean,
	((TEXTNS,'combine-entries-with-pp'), None): cnv_boolean,
	((TEXTNS,'comma-separated'), None): cnv_boolean,
	((TEXTNS,'cond-style-name'), None): cnv_StyleNameRef,
	((TEXTNS,'condition'), None): cnv_formula,
	((TEXTNS,'connection-name'), None): cnv_string,
	((TEXTNS,'consecutive-numbering'), None): cnv_boolean,
	((TEXTNS,'continue-numbering'), None): cnv_boolean,
	((TEXTNS,'copy-outline-levels'), None): cnv_boolean,
	((TEXTNS,'count-empty-lines'), None): cnv_boolean,
	((TEXTNS,'count-in-text-boxes'), None): cnv_boolean,
	((TEXTNS,'current-value'), None): cnv_boolean,
	((TEXTNS,'custom1'), None): cnv_string,
	((TEXTNS,'custom2'), None): cnv_string,
	((TEXTNS,'custom3'), None): cnv_string,
	((TEXTNS,'custom4'), None): cnv_string,
	((TEXTNS,'custom5'), None): cnv_string,
	((TEXTNS,'database-name'), None): cnv_string,
	((TEXTNS,'date-adjust'), None): cnv_duration,
	((TEXTNS,'date-value'), None): cnv_date,
#	((TEXTNS,u'date-value'), None): cnv_dateTime,
	((TEXTNS,'default-style-name'), None): cnv_StyleNameRef,
	((TEXTNS,'description'), None): cnv_string,
	((TEXTNS,'display'), None): cnv_string,
	((TEXTNS,'display-levels'), None): cnv_positiveInteger,
	((TEXTNS,'display-outline-level'), None): cnv_nonNegativeInteger,
	((TEXTNS,'dont-balance-text-columns'), None): cnv_boolean,
	((TEXTNS,'duration'), None): cnv_duration,
	((TEXTNS,'edition'), None): cnv_string,
	((TEXTNS,'editor'), None): cnv_string,
	((TEXTNS,'filter-name'), None): cnv_string,
	((TEXTNS,'first-row-end-column'), None): cnv_string,
	((TEXTNS,'first-row-start-column'), None): cnv_string,
	((TEXTNS,'fixed'), None): cnv_boolean,
	((TEXTNS,'footnotes-position'), None): cnv_string,
	((TEXTNS,'formula'), None): cnv_formula,
	((TEXTNS,'global'), None): cnv_boolean,
	((TEXTNS,'howpublished'), None): cnv_string,
	((TEXTNS,'id'), None): cnv_ID,
#	((TEXTNS,u'id'), None): cnv_string,
	((TEXTNS,'identifier'), None): cnv_string,
	((TEXTNS,'ignore-case'), None): cnv_boolean,
	((TEXTNS,'increment'), None): cnv_nonNegativeInteger,
	((TEXTNS,'index-name'), None): cnv_string,
	((TEXTNS,'index-scope'), None): cnv_string,
	((TEXTNS,'institution'), None): cnv_string,
	((TEXTNS,'is-hidden'), None): cnv_boolean,
	((TEXTNS,'is-list-header'), None): cnv_boolean,
	((TEXTNS,'isbn'), None): cnv_string,
	((TEXTNS,'issn'), None): cnv_string,
	((TEXTNS,'issn'), None): cnv_string,
	((TEXTNS,'journal'), None): cnv_string,
	((TEXTNS,'key'), None): cnv_string,
	((TEXTNS,'key1'), None): cnv_string,
	((TEXTNS,'key1-phonetic'), None): cnv_string,
	((TEXTNS,'key2'), None): cnv_string,
	((TEXTNS,'key2-phonetic'), None): cnv_string,
	((TEXTNS,'kind'), None): cnv_string,
	((TEXTNS,'label'), None): cnv_string,
	((TEXTNS,'last-row-end-column'), None): cnv_string,
	((TEXTNS,'last-row-start-column'), None): cnv_string,
	((TEXTNS,'level'), None): cnv_positiveInteger,
	((TEXTNS,'line-break'), None): cnv_boolean,
	((TEXTNS,'line-number'), None): cnv_string,
	((TEXTNS,'main-entry'), None): cnv_boolean,
	((TEXTNS,'main-entry-style-name'), None): cnv_StyleNameRef,
	((TEXTNS,'master-page-name'), None): cnv_StyleNameRef,
	((TEXTNS,'min-label-distance'), None): cnv_string,
	((TEXTNS,'min-label-width'), None): cnv_string,
	((TEXTNS,'month'), None): cnv_string,
	((TEXTNS,'name'), None): cnv_string,
	((TEXTNS,'note-class'), None): cnv_textnoteclass,
	((TEXTNS,'note'), None): cnv_string,
	((TEXTNS,'number'), None): cnv_string,
	((TEXTNS,'number-lines'), None): cnv_boolean,
	((TEXTNS,'number-position'), None): cnv_string,
	((TEXTNS,'numbered-entries'), None): cnv_boolean,
	((TEXTNS,'offset'), None): cnv_string,
	((TEXTNS,'organizations'), None): cnv_string,
	((TEXTNS,'outline-level'), None): cnv_string,
	((TEXTNS,'page-adjust'), None): cnv_integer,
	((TEXTNS,'pages'), None): cnv_string,
	((TEXTNS,'paragraph-style-name'), None): cnv_StyleNameRef,
	((TEXTNS,'placeholder-type'), None): cnv_string,
	((TEXTNS,'prefix'), None): cnv_string,
	((TEXTNS,'protected'), None): cnv_boolean,
	((TEXTNS,'protection-key'), None): cnv_string,
	((TEXTNS,'publisher'), None): cnv_string,
	((TEXTNS,'ref-name'), None): cnv_string,
	((TEXTNS,'reference-format'), None): cnv_string,
	((TEXTNS,'relative-tab-stop-position'), None): cnv_boolean,
	((TEXTNS,'report-type'), None): cnv_string,
	((TEXTNS,'restart-numbering'), None): cnv_boolean,
	((TEXTNS,'restart-on-page'), None): cnv_boolean,
	((TEXTNS,'row-number'), None): cnv_nonNegativeInteger,
	((TEXTNS,'school'), None): cnv_string,
	((TEXTNS,'section-name'), None): cnv_string,
	((TEXTNS,'select-page'), None): cnv_string,
	((TEXTNS,'separation-character'), None): cnv_string,
	((TEXTNS,'series'), None): cnv_string,
	((TEXTNS,'sort-algorithm'), None): cnv_string,
	((TEXTNS,'sort-ascending'), None): cnv_boolean,
	((TEXTNS,'sort-by-position'), None): cnv_boolean,
	((TEXTNS,'space-before'), None): cnv_string,
	((TEXTNS,'start-numbering-at'), None): cnv_string,
	((TEXTNS,'start-value'), None): cnv_nonNegativeInteger,
	((TEXTNS,'start-value'), None): cnv_positiveInteger,
	((TEXTNS,'string-value'), None): cnv_string,
	((TEXTNS,'string-value-if-false'), None): cnv_string,
	((TEXTNS,'string-value-if-true'), None): cnv_string,
	((TEXTNS,'string-value-phonetic'), None): cnv_string,
	((TEXTNS,'style-name'), None): cnv_StyleNameRef,
	((TEXTNS,'suffix'), None): cnv_string,
	((TEXTNS,'tab-ref'), None): cnv_nonNegativeInteger,
	((TEXTNS,'table-name'), None): cnv_string,
	((TEXTNS,'table-type'), None): cnv_string,
	((TEXTNS,'time-adjust'), None): cnv_duration,
	((TEXTNS,'time-value'), None): cnv_dateTime,
	((TEXTNS,'time-value'), None): cnv_time,
	((TEXTNS,'title'), None): cnv_string,
	((TEXTNS,'track-changes'), None): cnv_boolean,
	((TEXTNS,'url'), None): cnv_string,
	((TEXTNS,'use-caption'), None): cnv_boolean,
	((TEXTNS,'use-chart-objects'), None): cnv_boolean,
	((TEXTNS,'use-draw-objects'), None): cnv_boolean,
	((TEXTNS,'use-floating-frames'), None): cnv_boolean,
	((TEXTNS,'use-graphics'), None): cnv_boolean,
	((TEXTNS,'use-index-marks'), None): cnv_boolean,
	((TEXTNS,'use-index-source-styles'), None): cnv_boolean,
	((TEXTNS,'use-keys-as-entries'), None): cnv_boolean,
	((TEXTNS,'use-math-objects'), None): cnv_boolean,
	((TEXTNS,'use-objects'), None): cnv_boolean,
	((TEXTNS,'use-other-objects'), None): cnv_boolean,
	((TEXTNS,'use-outline-level'), None): cnv_boolean,
	((TEXTNS,'use-soft-page-breaks'), None): cnv_boolean,
	((TEXTNS,'use-spreadsheet-objects'), None): cnv_boolean,
	((TEXTNS,'use-tables'), None): cnv_boolean,
	((TEXTNS,'value'), None): cnv_nonNegativeInteger,
	((TEXTNS,'visited-style-name'), None): cnv_StyleNameRef,
	((TEXTNS,'volume'), None): cnv_string,
	((TEXTNS,'year'), None): cnv_string,
	((XFORMSNS,'bind'), None): cnv_string,
	((XLINKNS,'actuate'), None): cnv_string,
	((XLINKNS,'href'), None): cnv_anyURI,
	((XLINKNS,'show'), None): cnv_xlinkshow,
	((XLINKNS,'title'), None): cnv_string,
	((XLINKNS,'type'), None): cnv_string,
}

class AttrConverters:
    def convert(self, attribute, value, element):
        """ Based on the element, figures out how to check/convert the attribute value
            All values are converted to string
        """
        conversion = attrconverters.get((attribute, element.qname), None)
        if conversion is not None:
            return conversion(attribute, value, element)
        else:
            conversion = attrconverters.get((attribute, None), None)
            if conversion is not None:
                return conversion(attribute, value, element)
        return str(value)


########NEW FILE########
__FILENAME__ = chart
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import CHARTNS
from .element import Element

# Autogenerated
def Axis(**args):
    return Element(qname = (CHARTNS,'axis'), **args)

def Categories(**args):
    return Element(qname = (CHARTNS,'categories'), **args)

def Chart(**args):
    return Element(qname = (CHARTNS,'chart'), **args)

def DataPoint(**args):
    return Element(qname = (CHARTNS,'data-point'), **args)

def Domain(**args):
    return Element(qname = (CHARTNS,'domain'), **args)

def ErrorIndicator(**args):
    return Element(qname = (CHARTNS,'error-indicator'), **args)

def Floor(**args):
    return Element(qname = (CHARTNS,'floor'), **args)

def Footer(**args):
    return Element(qname = (CHARTNS,'footer'), **args)

def Grid(**args):
    return Element(qname = (CHARTNS,'grid'), **args)

def Legend(**args):
    return Element(qname = (CHARTNS,'legend'), **args)

def MeanValue(**args):
    return Element(qname = (CHARTNS,'mean-value'), **args)

def PlotArea(**args):
    return Element(qname = (CHARTNS,'plot-area'), **args)

def RegressionCurve(**args):
    return Element(qname = (CHARTNS,'regression-curve'), **args)

def Series(**args):
    return Element(qname = (CHARTNS,'series'), **args)

def StockGainMarker(**args):
    return Element(qname = (CHARTNS,'stock-gain-marker'), **args)

def StockLossMarker(**args):
    return Element(qname = (CHARTNS,'stock-loss-marker'), **args)

def StockRangeLine(**args):
    return Element(qname = (CHARTNS,'stock-range-line'), **args)

def Subtitle(**args):
    return Element(qname = (CHARTNS,'subtitle'), **args)

def SymbolImage(**args):
    return Element(qname = (CHARTNS,'symbol-image'), **args)

def Title(**args):
    return Element(qname = (CHARTNS,'title'), **args)

def Wall(**args):
    return Element(qname = (CHARTNS,'wall'), **args)


########NEW FILE########
__FILENAME__ = config
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import CONFIGNS
from .element import Element

# Autogenerated
def ConfigItem(**args):
    return Element(qname = (CONFIGNS, 'config-item'), **args)

def ConfigItemMapEntry(**args):
    return Element(qname = (CONFIGNS,'config-item-map-entry'), **args)

def ConfigItemMapIndexed(**args):
    return Element(qname = (CONFIGNS,'config-item-map-indexed'), **args)

def ConfigItemMapNamed(**args):
    return Element(qname = (CONFIGNS,'config-item-map-named'), **args)

def ConfigItemSet(**args):
    return Element(qname = (CONFIGNS, 'config-item-set'), **args)


########NEW FILE########
__FILENAME__ = dc
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import DCNS
from .element import Element

# Autogenerated
def Creator(**args):
    return Element(qname = (DCNS,'creator'), **args)

def Date(**args):
    return Element(qname = (DCNS,'date'), **args)

def Description(**args):
    return Element(qname = (DCNS,'description'), **args)

def Language(**args):
    return Element(qname = (DCNS,'language'), **args)

def Subject(**args):
    return Element(qname = (DCNS,'subject'), **args)

def Title(**args):
    return Element(qname = (DCNS,'title'), **args)

# The following complete the Dublin Core elements, but there is no
# guarantee a compliant implementation of OpenDocument will preserve
# these elements

#def Contributor(**args):
#    return Element(qname = (DCNS,'contributor'), **args)

#def Coverage(**args):
#    return Element(qname = (DCNS,'coverage'), **args)

#def Format(**args):
#    return Element(qname = (DCNS,'format'), **args)

#def Identifier(**args):
#    return Element(qname = (DCNS,'identifier'), **args)

#def Publisher(**args):
#    return Element(qname = (DCNS,'publisher'), **args)

#def Relation(**args):
#    return Element(qname = (DCNS,'relation'), **args)

#def Rights(**args):
#    return Element(qname = (DCNS,'rights'), **args)

#def Source(**args):
#    return Element(qname = (DCNS,'source'), **args)

#def Type(**args):
#    return Element(qname = (DCNS,'type'), **args)

########NEW FILE########
__FILENAME__ = dr3d
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import DR3DNS
from .element import Element
from .draw import StyleRefElement

# Autogenerated
def Cube(**args):
    return StyleRefElement(qname = (DR3DNS,'cube'), **args)

def Extrude(**args):
    return StyleRefElement(qname = (DR3DNS,'extrude'), **args)

def Light(Element):
    return StyleRefElement(qname = (DR3DNS,'light'), **args)

def Rotate(**args):
    return StyleRefElement(qname = (DR3DNS,'rotate'), **args)

def Scene(**args):
    return StyleRefElement(qname = (DR3DNS,'scene'), **args)

def Sphere(**args):
    return StyleRefElement(qname = (DR3DNS,'sphere'), **args)


########NEW FILE########
__FILENAME__ = draw
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import DRAWNS, STYLENS, PRESENTATIONNS
from .element import Element

def StyleRefElement(stylename=None, classnames=None, **args):
    qattrs = {}
    if stylename is not None:
        f = stylename.getAttrNS(STYLENS, 'family')
        if f == 'graphic':
            qattrs[(DRAWNS,'style-name')]= stylename
        elif f == 'presentation':
            qattrs[(PRESENTATIONNS,'style-name')]= stylename
        else:
            raise ValueError("Style's family must be either 'graphic' or 'presentation'")
    if classnames is not None:
        f = classnames[0].getAttrNS(STYLENS, 'family')
        if f == 'graphic':
            qattrs[(DRAWNS,'class-names')]= classnames
        elif f == 'presentation':
            qattrs[(PRESENTATIONNS,'class-names')]= classnames
        else:
            raise ValueError("Style's family must be either 'graphic' or 'presentation'")
    return Element(qattributes=qattrs, **args)

def DrawElement(name=None, **args):
    e = Element(name=name, **args)
    if 'displayname' not in args:
        e.setAttrNS(DRAWNS,'display-name', name)
    return e

# Autogenerated
def A(**args):
    return Element(qname = (DRAWNS,'a'), **args)

def Applet(**args):
    return Element(qname = (DRAWNS,'applet'), **args)

def AreaCircle(**args):
    return Element(qname = (DRAWNS,'area-circle'), **args)

def AreaPolygon(**args):
    return Element(qname = (DRAWNS,'area-polygon'), **args)

def AreaRectangle(**args):
    return Element(qname = (DRAWNS,'area-rectangle'), **args)

def Caption(**args):
    return StyleRefElement(qname = (DRAWNS,'caption'), **args)

def Circle(**args):
    return StyleRefElement(qname = (DRAWNS,'circle'), **args)

def Connector(**args):
    return StyleRefElement(qname = (DRAWNS,'connector'), **args)

def ContourPath(**args):
    return Element(qname = (DRAWNS,'contour-path'), **args)

def ContourPolygon(**args):
    return Element(qname = (DRAWNS,'contour-polygon'), **args)

def Control(**args):
    return StyleRefElement(qname = (DRAWNS,'control'), **args)

def CustomShape(**args):
    return StyleRefElement(qname = (DRAWNS,'custom-shape'), **args)

def Ellipse(**args):
    return StyleRefElement(qname = (DRAWNS,'ellipse'), **args)

def EnhancedGeometry(**args):
    return Element(qname = (DRAWNS,'enhanced-geometry'), **args)

def Equation(**args):
    return Element(qname = (DRAWNS,'equation'), **args)

def FillImage(**args):
    return DrawElement(qname = (DRAWNS,'fill-image'), **args)

def FloatingFrame(**args):
    return Element(qname = (DRAWNS,'floating-frame'), **args)

def Frame(**args):
    return StyleRefElement(qname = (DRAWNS,'frame'), **args)

def G(**args):
    return StyleRefElement(qname = (DRAWNS,'g'), **args)

def GluePoint(**args):
    return Element(qname = (DRAWNS,'glue-point'), **args)

def Gradient(**args):
    return DrawElement(qname = (DRAWNS,'gradient'), **args)

def Handle(**args):
    return Element(qname = (DRAWNS,'handle'), **args)

def Hatch(**args):
    return DrawElement(qname = (DRAWNS,'hatch'), **args)

def Image(**args):
    return Element(qname = (DRAWNS,'image'), **args)

def ImageMap(**args):
    return Element(qname = (DRAWNS,'image-map'), **args)

def Layer(**args):
    return Element(qname = (DRAWNS,'layer'), **args)

def LayerSet(**args):
    return Element(qname = (DRAWNS,'layer-set'), **args)

def Line(**args):
    return StyleRefElement(qname = (DRAWNS,'line'), **args)

def Marker(**args):
    return DrawElement(qname = (DRAWNS,'marker'), **args)

def Measure(**args):
    return StyleRefElement(qname = (DRAWNS,'measure'), **args)

def Object(**args):
    return Element(qname = (DRAWNS,'object'), **args)

def ObjectOle(**args):
    return Element(qname = (DRAWNS,'object-ole'), **args)

def Opacity(**args):
    return DrawElement(qname = (DRAWNS,'opacity'), **args)

def Page(**args):
    return Element(qname = (DRAWNS,'page'), **args)

def PageThumbnail(**args):
    return StyleRefElement(qname = (DRAWNS,'page-thumbnail'), **args)

def Param(**args):
    return Element(qname = (DRAWNS,'param'), **args)

def Path(**args):
    return StyleRefElement(qname = (DRAWNS,'path'), **args)

def Plugin(**args):
    return Element(qname = (DRAWNS,'plugin'), **args)

def Polygon(**args):
    return StyleRefElement(qname = (DRAWNS,'polygon'), **args)

def Polyline(**args):
    return StyleRefElement(qname = (DRAWNS,'polyline'), **args)

def Rect(**args):
    return StyleRefElement(qname = (DRAWNS,'rect'), **args)

def RegularPolygon(**args):
    return StyleRefElement(qname = (DRAWNS,'regular-polygon'), **args)

def StrokeDash(**args):
    return DrawElement(qname = (DRAWNS,'stroke-dash'), **args)

def TextBox(**args):
    return Element(qname = (DRAWNS,'text-box'), **args)


########NEW FILE########
__FILENAME__ = easyliststyle
# -*- coding: utf-8 -*-
#   Create a <text:list-style> element from a text string.
#   Copyright (C) 2008 J. David Eisenberg
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program; if not, write to the Free Software Foundation, Inc.,
#   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Contributor(s):
#

import re
from .style import Style, TextProperties, ListLevelProperties
from .text import ListStyle,ListLevelStyleNumber,ListLevelStyleBullet

"""
Create a <text:list-style> element from a string or array.

List styles require a lot of code to create one level at a time.
These routines take a string and delimiter, or a list of
strings, and creates a <text:list-style> element for you.
Each item in the string (or array) represents a list level
 * style for levels 1-10.</p>
 *
 * <p>If an item contains <code>1</code>, <code>I</code>,
 * <code>i</code>, <code>A</code>, or <code>a</code>, then it is presumed
 * to be a numbering style; otherwise it is a bulleted style.</p>
"""

_MAX_LIST_LEVEL = 10
SHOW_ALL_LEVELS = True
SHOW_ONE_LEVEL = False

def styleFromString(name, specifiers, delim, spacing, showAllLevels):
    specArray = specifiers.split(delim)
    return styleFromList( name, specArray, spacing, showAllLevels )

def styleFromList( styleName, specArray, spacing, showAllLevels):
    bullet = ""
    numPrefix = ""
    numSuffix = ""
    numberFormat = ""
    cssLengthNum = 0
    cssLengthUnits = ""
    numbered = False
    displayLevels = 0
    listStyle = ListStyle(name=styleName)
    numFormatPattern = re.compile("([1IiAa])")
    cssLengthPattern = re.compile("([^a-z]+)\\s*([a-z]+)?")
    m = cssLengthPattern.search( spacing )
    if (m != None):
        cssLengthNum = float(m.group(1))
        if (m.lastindex == 2):
            cssLengthUnits = m.group(2)
    i = 0
    while i < len(specArray):
        specification = specArray[i]
        m = numFormatPattern.search(specification)
        if (m != None):
            numberFormat = m.group(1)
            numPrefix = specification[0:m.start(1)]
            numSuffix = specification[m.end(1):]
            bullet = ""
            numbered = True
            if (showAllLevels):
                displayLevels = i + 1
            else:
                displayLevels = 1
        else:    # it's a bullet style
            bullet = specification
            numPrefix = ""
            numSuffix = ""
            numberFormat = ""
            displayLevels = 1
            numbered = False
        if (numbered):
            lls = ListLevelStyleNumber(level=(i+1))
            if (numPrefix != ''):
                lls.setAttribute('numprefix', numPrefix)
            if (numSuffix != ''):
                lls.setAttribute('numsuffix', numSuffix)
            lls.setAttribute('displaylevels', displayLevels)
        else:
            lls = ListLevelStyleBullet(level=(i+1),bulletchar=bullet[0])
        llp = ListLevelProperties()
        llp.setAttribute('spacebefore', str(cssLengthNum * (i+1)) + cssLengthUnits)
        llp.setAttribute('minlabelwidth', str(cssLengthNum) + cssLengthUnits)
        lls.addElement( llp )
        listStyle.addElement(lls)
        i += 1
    return listStyle

# vim: set expandtab sw=4 :

########NEW FILE########
__FILENAME__ = element
#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2007-2010 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

# Note: This script has copied a lot of text from xml.dom.minidom.
# Whatever license applies to that file also applies to this file.
#
import xml.dom
from xml.dom.minicompat import *
from .namespaces import nsdict
from . import grammar
from .attrconverters import AttrConverters

# The following code is pasted form xml.sax.saxutils
# Tt makes it possible to run the code without the xml sax package installed
# To make it possible to have <rubbish> in your text elements, it is necessary to escape the texts
def _escape(data, entities={}):
    """ Escape &, <, and > in a string of data.

        You can escape other strings of data by passing a dictionary as
        the optional entities parameter.  The keys and values must all be
        strings; each key will be replaced with its corresponding value.
    """
    try:
        data = data.decode('utf-8')
    except (TypeError, AttributeError):
        ## Make sure our stream is a string
        ## If it comes through as bytes it fails
        pass
    data = data.replace("&", "&amp;")
    data = data.replace("<", "&lt;")
    data = data.replace(">", "&gt;")
    for chars, entity in list(entities.items()):
        data = data.replace(chars, entity)
    return data

def _quoteattr(data, entities={}):
    """ Escape and quote an attribute value.

        Escape &, <, and > in a string of data, then quote it for use as
        an attribute value.  The \" character will be escaped as well, if
        necessary.

        You can escape other strings of data by passing a dictionary as
        the optional entities parameter.  The keys and values must all be
        strings; each key will be replaced with its corresponding value.
    """
    entities['\n']='&#10;'
    entities['\r']='&#12;'
    data = _escape(data, entities)
    if '"' in data:
        if "'" in data:
            data = '"%s"' % data.replace('"', "&quot;")
        else:
            data = "'%s'" % data
    else:
        data = '"%s"' % data
    return data

def _nssplit(qualifiedName):
    """ Split a qualified name into namespace part and local part.  """
    fields = qualifiedName.split(':', 1)
    if len(fields) == 2:
        return fields
    else:
        return (None, fields[0])

def _nsassign(namespace):
    return nsdict.setdefault(namespace,"ns" + str(len(nsdict)))

# Exceptions
class IllegalChild(Exception):
    """ Complains if you add an element to a parent where it is not allowed """
class IllegalText(Exception):
    """ Complains if you add text or cdata to an element where it is not allowed """

class Node(xml.dom.Node):
    """ super class for more specific nodes """
    parentNode = None
    nextSibling = None
    previousSibling = None

    def hasChildNodes(self):
        """ Tells whether this element has any children; text nodes,
            subelements, whatever.
        """
        if self.childNodes:
            return True
        else:
            return False

    def _get_childNodes(self):
        return self.childNodes

    def _get_firstChild(self):
        if self.childNodes:
            return self.childNodes[0]

    def _get_lastChild(self):
        if self.childNodes:
            return self.childNodes[-1]

    def insertBefore(self, newChild, refChild):
        """ Inserts the node newChild before the existing child node refChild.
            If refChild is null, insert newChild at the end of the list of children.
        """
        if newChild.nodeType not in self._child_node_types:
            raise IllegalChild("%s cannot be child of %s" % (newChild.tagName, self.tagName))
        if newChild.parentNode is not None:
            newChild.parentNode.removeChild(newChild)
        if refChild is None:
            self.appendChild(newChild)
        else:
            try:
                index = self.childNodes.index(refChild)
            except ValueError:
                raise xml.dom.NotFoundErr()
            self.childNodes.insert(index, newChild)
            newChild.nextSibling = refChild
            refChild.previousSibling = newChild
            if index:
                node = self.childNodes[index-1]
                node.nextSibling = newChild
                newChild.previousSibling = node
            else:
                newChild.previousSibling = None
            newChild.parentNode = self
        return newChild

    def appendChild(self, newChild):
        """ Adds the node newChild to the end of the list of children of this node.
            If the newChild is already in the tree, it is first removed.
        """
        if newChild.nodeType == self.DOCUMENT_FRAGMENT_NODE:
            for c in tuple(newChild.childNodes):
                self.appendChild(c)
            ### The DOM does not clearly specify what to return in this case
            return newChild
        if newChild.nodeType not in self._child_node_types:
            raise IllegalChild("<%s> is not allowed in %s" % ( newChild.tagName, self.tagName))
        if newChild.parentNode is not None:
            newChild.parentNode.removeChild(newChild)
        _append_child(self, newChild)
        newChild.nextSibling = None
        return newChild

    def removeChild(self, oldChild):
        """ Removes the child node indicated by oldChild from the list of children, and returns it.
        """
        #FIXME: update ownerDocument.element_dict or find other solution
        try:
            self.childNodes.remove(oldChild)
        except ValueError:
            raise xml.dom.NotFoundErr()
        if oldChild.nextSibling is not None:
            oldChild.nextSibling.previousSibling = oldChild.previousSibling
        if oldChild.previousSibling is not None:
            oldChild.previousSibling.nextSibling = oldChild.nextSibling
        oldChild.nextSibling = oldChild.previousSibling = None
        if self.ownerDocument:
            self.ownerDocument.clear_caches()
        oldChild.parentNode = None
        return oldChild

    def __str__(self):
        val = []
        for c in self.childNodes:
            val.append(str(c))
        return ''.join(val)

    def __unicode__(self):
        val = []
        for c in self.childNodes:
            val.append(str(c))
        return ''.join(val)

defproperty(Node, "firstChild", doc="First child node, or None.")
defproperty(Node, "lastChild",  doc="Last child node, or None.")

def _append_child(self, node):
    # fast path with less checks; usable by DOM builders if careful
    childNodes = self.childNodes
    if childNodes:
        last = childNodes[-1]
        node.__dict__["previousSibling"] = last
        last.__dict__["nextSibling"] = node
    childNodes.append(node)
    node.__dict__["parentNode"] = self

class Childless(object):
    """ Mixin that makes childless-ness easy to implement and avoids
        the complexity of the Node methods that deal with children.
    """

    attributes = None
    childNodes = EmptyNodeList()
    firstChild = None
    lastChild = None

    def _get_firstChild(self):
        return None

    def _get_lastChild(self):
        return None

    def appendChild(self, node):
        """ Raises an error """
        raise xml.dom.HierarchyRequestErr(
            self.tagName + " nodes cannot have children")

    def hasChildNodes(self):
        return False

    def insertBefore(self, newChild, refChild):
        """ Raises an error """
        raise xml.dom.HierarchyRequestErr(
            self.tagName + " nodes do not have children")

    def removeChild(self, oldChild):
        """ Raises an error """
        raise xml.dom.NotFoundErr(
            self.tagName + " nodes do not have children")

    def replaceChild(self, newChild, oldChild):
        """ Raises an error """
        raise xml.dom.HierarchyRequestErr(
            self.tagName + " nodes do not have children")

class Text(Childless, Node):
    nodeType = Node.TEXT_NODE
    tagName = "Text"

    def __init__(self, data):
        self.data = data

    def __str__(self):
        return self.data.encode()

    def __unicode__(self):
        return self.data

    def toXml(self,level,f):
        """ Write XML in UTF-8 """
        if self.data:
            f.write(_escape(str(self.data).encode('utf-8')))

class CDATASection(Text, Childless):
    nodeType = Node.CDATA_SECTION_NODE

    def toXml(self,level,f):
        """ Generate XML output of the node. If the text contains "]]>", then
            escape it by going out of CDATA mode (]]>), then write the string
            and then go into CDATA mode again. (<![CDATA[)
        """
        if self.data:
            f.write('<![CDATA[%s]]>' % self.data.replace(']]>',']]>]]><![CDATA['))

class Element(Node):
    """ Creates a arbitrary element and is intended to be subclassed not used on its own.
        This element is the base of every element it defines a class which resembles
        a xml-element. The main advantage of this kind of implementation is that you don't
        have to create a toXML method for every different object. Every element
        consists of an attribute, optional subelements, optional text and optional cdata.
    """

    nodeType = Node.ELEMENT_NODE
    namespaces = {}  # Due to shallow copy this is a static variable

    _child_node_types = (Node.ELEMENT_NODE,
                         Node.PROCESSING_INSTRUCTION_NODE,
                         Node.COMMENT_NODE,
                         Node.TEXT_NODE,
                         Node.CDATA_SECTION_NODE,
                         Node.ENTITY_REFERENCE_NODE)

    def __init__(self, attributes=None, text=None, cdata=None, qname=None, qattributes=None, check_grammar=True, **args):
        if qname is not None:
            self.qname = qname
        assert(hasattr(self, 'qname'))
        self.ownerDocument = None
        self.childNodes=[]
        self.allowed_children = grammar.allowed_children.get(self.qname)
        prefix = self.get_nsprefix(self.qname[0])
        self.tagName = prefix + ":" + self.qname[1]
        if text is not None:
            self.addText(text)
        if cdata is not None:
            self.addCDATA(cdata)

        allowed_attrs = self.allowed_attributes()
        if allowed_attrs is not None:
            allowed_args = [ a[1].lower().replace('-','') for a in allowed_attrs]
        self.attributes={}
        # Load the attributes from the 'attributes' argument
        if attributes:
            for attr, value in list(attributes.items()):
                self.setAttribute(attr, value)
        # Load the qualified attributes
        if qattributes:
            for attr, value in list(qattributes.items()):
                self.setAttrNS(attr[0], attr[1], value)
        if allowed_attrs is not None:
            # Load the attributes from the 'args' argument
            for arg in list(args.keys()):
                self.setAttribute(arg, args[arg])
        else:
            for arg in list(args.keys()):  # If any attribute is allowed
                self.attributes[arg]=args[arg]
        if not check_grammar:
            return
        # Test that all mandatory attributes have been added.
        required = grammar.required_attributes.get(self.qname)
        if required:
            for r in required:
                if self.getAttrNS(r[0],r[1]) is None:
                    raise AttributeError("Required attribute missing: %s in <%s>" % (r[1].lower().replace('-',''), self.tagName))

    def get_knownns(self, prefix):
        """ Odfpy maintains a list of known namespaces. In some cases a prefix is used, and
            we need to know which namespace it resolves to.
        """
        global nsdict
        for ns,p in list(nsdict.items()):
            if p == prefix: return ns
        return None

    def get_nsprefix(self, namespace):
        """ Odfpy maintains a list of known namespaces. In some cases we have a namespace URL,
            and needs to look up or assign the prefix for it.
        """
        if namespace is None: namespace = ""
        prefix = _nsassign(namespace)
        if namespace not in self.namespaces:
            self.namespaces[namespace] = prefix
        return prefix

    def allowed_attributes(self):
        return grammar.allowed_attributes.get(self.qname)

    def _setOwnerDoc(self, element):
        element.ownerDocument = self.ownerDocument
        for child in element.childNodes:
            self._setOwnerDoc(child)

    def addElement(self, element, check_grammar=True):
        """ adds an element to an Element

            Element.addElement(Element)
        """
        if check_grammar and self.allowed_children is not None:
            if element.qname not in self.allowed_children:
                raise IllegalChild("<%s> is not allowed in <%s>" % ( element.tagName, self.tagName))
        self.appendChild(element)
        self._setOwnerDoc(element)
        if self.ownerDocument:
            self.ownerDocument.rebuild_caches(element)

    def addText(self, text, check_grammar=True):
        """ Adds text to an element
            Setting check_grammar=False turns off grammar checking
        """
        if check_grammar and self.qname not in grammar.allows_text:
            raise IllegalText("The <%s> element does not allow text" % self.tagName)
        else:
            if text != '':
                self.appendChild(Text(text))

    def addCDATA(self, cdata, check_grammar=True):
        """ Adds CDATA to an element
            Setting check_grammar=False turns off grammar checking
        """
        if check_grammar and self.qname not in grammar.allows_text:
            raise IllegalText("The <%s> element does not allow text" % self.tagName)
        else:
            self.appendChild(CDATASection(cdata))

    def removeAttribute(self, attr, check_grammar=True):
        """ Removes an attribute by name. """
        allowed_attrs = self.allowed_attributes()
        if allowed_attrs is None:
            if type(attr) == type(()):
                prefix, localname = attr
                self.removeAttrNS(prefix, localname)
            else:
                raise AttributeError("Unable to add simple attribute - use (namespace, localpart)")
        else:
            # Construct a list of allowed arguments
            allowed_args = [ a[1].lower().replace('-','') for a in allowed_attrs]
            if check_grammar and attr not in allowed_args:
                raise AttributeError("Attribute %s is not allowed in <%s>" % ( attr, self.tagName))
            i = allowed_args.index(attr)
            self.removeAttrNS(allowed_attrs[i][0], allowed_attrs[i][1])

    def setAttribute(self, attr, value, check_grammar=True):
        """ Add an attribute to the element
            This is sort of a convenience method. All attributes in ODF have
            namespaces. The library knows what attributes are legal and then allows
            the user to provide the attribute as a keyword argument and the
            library will add the correct namespace.
            Must overwrite, If attribute already exists.
        """
        allowed_attrs = self.allowed_attributes()
        if allowed_attrs is None:
            if type(attr) == type(()):
                prefix, localname = attr
                self.setAttrNS(prefix, localname, value)
            else:
                raise AttributeError("Unable to add simple attribute - use (namespace, localpart)")
        else:
            # Construct a list of allowed arguments
            allowed_args = [ a[1].lower().replace('-','') for a in allowed_attrs]
            if check_grammar and attr not in allowed_args:
                raise AttributeError("Attribute %s is not allowed in <%s>" % ( attr, self.tagName))
            i = allowed_args.index(attr)
            self.setAttrNS(allowed_attrs[i][0], allowed_attrs[i][1], value)

    def setAttrNS(self, namespace, localpart, value):
        """ Add an attribute to the element
            In case you need to add an attribute the library doesn't know about
            then you must provide the full qualified name
            It will not check that the attribute is legal according to the schema.
            Must overwrite, If attribute already exists.
        """
        allowed_attrs = self.allowed_attributes()
        prefix = self.get_nsprefix(namespace)
#       if allowed_attrs and (namespace, localpart) not in allowed_attrs:
#           raise AttributeError, "Attribute %s:%s is not allowed in element <%s>" % ( prefix, localpart, self.tagName)
        c = AttrConverters()
        self.attributes[(namespace, localpart)] = c.convert((namespace, localpart), value, self)

    def getAttrNS(self, namespace, localpart):
        prefix = self.get_nsprefix(namespace)
        return self.attributes.get((namespace, localpart))

    def removeAttrNS(self, namespace, localpart):
        del self.attributes[(namespace, localpart)]

    def getAttribute(self, attr):
        """ Get an attribute value. The method knows which namespace the attribute is in
        """
        allowed_attrs = self.allowed_attributes()
        if allowed_attrs is None:
            if type(attr) == type(()):
                prefix, localname = attr
                return self.getAttrNS(prefix, localname)
            else:
                raise AttributeError("Unable to get simple attribute - use (namespace, localpart)")
        else:
            # Construct a list of allowed arguments
            allowed_args = [ a[1].lower().replace('-','') for a in allowed_attrs]
            i = allowed_args.index(attr)
            return self.getAttrNS(allowed_attrs[i][0], allowed_attrs[i][1])

    def write_open_tag(self, level, f):
        f.write('<'+self.tagName)
        if level == 0:
            for namespace, prefix in list(self.namespaces.items()):
                f.write(' xmlns:' + prefix + '="'+ _escape(str(namespace))+'"')
        for qname in list(self.attributes.keys()):
            prefix = self.get_nsprefix(qname[0])
            f.write(' '+_escape(str(prefix+':'+qname[1]))+'='+_quoteattr(str(self.attributes[qname]).encode('utf-8')))
        f.write('>')

    def write_close_tag(self, level, f):
        f.write('</'+self.tagName+'>')

    def toXml(self, level, f):
        """ Generate XML stream out of the tree structure """
        f.write('<'+self.tagName)
        if level == 0:
            for namespace, prefix in list(self.namespaces.items()):
                f.write(' xmlns:' + prefix + '="'+ _escape(str(namespace))+'"')
        for qname in list(self.attributes.keys()):
            prefix = self.get_nsprefix(qname[0])
            f.write(' '+_escape(str(prefix+':'+qname[1]))+'='+_quoteattr(str(self.attributes[qname]).encode('utf-8')))
        if self.childNodes:
            f.write('>')
            for element in self.childNodes:
                element.toXml(level+1,f)
            f.write('</'+self.tagName+'>')
        else:
            f.write('/>')

    def _getElementsByObj(self, obj, accumulator):
        if self.qname == obj.qname:
            accumulator.append(self)
        for e in self.childNodes:
            if e.nodeType == Node.ELEMENT_NODE:
                accumulator = e._getElementsByObj(obj, accumulator)
        return accumulator

    def getElementsByType(self, element):
        """ Gets elements based on the type, which is function from text.py, draw.py etc. """
        obj = element(check_grammar=False)
        return self._getElementsByObj(obj,[])

    def isInstanceOf(self, element):
        """ This is a check to see if the object is an instance of a type """
        obj = element(check_grammar=False)
        return self.qname == obj.qname



########NEW FILE########
__FILENAME__ = elementtypes
#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2008 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import *

# Inline element don't cause a box
# They are analogous to the HTML elements SPAN, B, I etc.
inline_elements = (
    (TEXTNS,'a'),
    (TEXTNS,'author-initials'),
    (TEXTNS,'author-name'),
    (TEXTNS,'bibliography-mark'),
    (TEXTNS,'bookmark-ref'),
    (TEXTNS,'chapter'),
    (TEXTNS,'character-count'),
    (TEXTNS,'conditional-text'),
    (TEXTNS,'creation-date'),
    (TEXTNS,'creation-time'),
    (TEXTNS,'creator'),
    (TEXTNS,'database-display'),
    (TEXTNS,'database-name'),
    (TEXTNS,'database-next'),
    (TEXTNS,'database-row-number'),
    (TEXTNS,'database-row-select'),
    (TEXTNS,'date'),
    (TEXTNS,'dde-connection'),
    (TEXTNS,'description'),
    (TEXTNS,'editing-cycles'),
    (TEXTNS,'editing-duration'),
    (TEXTNS,'execute-macro'),
    (TEXTNS,'expression'),
    (TEXTNS,'file-name'),
    (TEXTNS,'hidden-paragraph'),
    (TEXTNS,'hidden-text'),
    (TEXTNS,'image-count'),
    (TEXTNS,'initial-creator'),
    (TEXTNS,'keywords'),
    (TEXTNS,'measure'),
    (TEXTNS,'modification-date'),
    (TEXTNS,'modification-time'),
    (TEXTNS,'note-ref'),
    (TEXTNS,'object-count'),
    (TEXTNS,'page-continuation'),
    (TEXTNS,'page-count'),
    (TEXTNS,'page-number'),
    (TEXTNS,'page-variable-get'),
    (TEXTNS,'page-variable-set'),
    (TEXTNS,'paragraph-count'),
    (TEXTNS,'placeholder'),
    (TEXTNS,'print-date'),
    (TEXTNS,'printed-by'),
    (TEXTNS,'print-time'),
    (TEXTNS,'reference-ref'),
    (TEXTNS,'ruby'),
    (TEXTNS,'ruby-base'),
    (TEXTNS,'ruby-text'),
    (TEXTNS,'script'),
    (TEXTNS,'sender-city'),
    (TEXTNS,'sender-company'),
    (TEXTNS,'sender-country'),
    (TEXTNS,'sender-email'),
    (TEXTNS,'sender-fax'),
    (TEXTNS,'sender-firstname'),
    (TEXTNS,'sender-initials'),
    (TEXTNS,'sender-lastname'),
    (TEXTNS,'sender-phone-private'),
    (TEXTNS,'sender-phone-work'),
    (TEXTNS,'sender-position'),
    (TEXTNS,'sender-postal-code'),
    (TEXTNS,'sender-state-or-province'),
    (TEXTNS,'sender-street'),
    (TEXTNS,'sender-title'),
    (TEXTNS,'sequence'),
    (TEXTNS,'sequence-ref'),
    (TEXTNS,'sheet-name'),
    (TEXTNS,'span'),
    (TEXTNS,'subject'),
    (TEXTNS,'table-count'),
    (TEXTNS,'table-formula'),
    (TEXTNS,'template-name'),
    (TEXTNS,'text-input'),
    (TEXTNS,'time'),
    (TEXTNS,'title'),
    (TEXTNS,'user-defined'),
    (TEXTNS,'user-field-get'),
    (TEXTNS,'user-field-input'),
    (TEXTNS,'variable-get'),
    (TEXTNS,'variable-input'),
    (TEXTNS,'variable-set'),
    (TEXTNS,'word-count'),
)


# It is almost impossible to determine what elements are block elements.
# There are so many that don't fit the form
block_elements = (
    (TEXTNS,'h'),
    (TEXTNS,'p'),
    (TEXTNS,'list'),
    (TEXTNS,'list-item'),
    (TEXTNS,'section'),
)

declarative_elements = (
    (OFFICENS,'font-face-decls'),
    (PRESENTATIONNS,'date-time-decl'),
    (PRESENTATIONNS,'footer-decl'),
    (PRESENTATIONNS,'header-decl'),
    (TABLENS,'table-template'),
    (TEXTNS,'alphabetical-index-entry-template'),
    (TEXTNS,'alphabetical-index-source'),
    (TEXTNS,'bibliography-entry-template'),
    (TEXTNS,'bibliography-source'),
    (TEXTNS,'dde-connection-decls'),
    (TEXTNS,'illustration-index-entry-template'),
    (TEXTNS,'illustration-index-source'),
    (TEXTNS,'index-source-styles'),
    (TEXTNS,'index-title-template'),
    (TEXTNS,'note-continuation-notice-backward'),
    (TEXTNS,'note-continuation-notice-forward'),
    (TEXTNS,'notes-configuration'),
    (TEXTNS,'object-index-entry-template'),
    (TEXTNS,'object-index-source'),
    (TEXTNS,'sequence-decls'),
    (TEXTNS,'table-index-entry-template'),
    (TEXTNS,'table-index-source'),
    (TEXTNS,'table-of-content-entry-template'),
    (TEXTNS,'table-of-content-source'),
    (TEXTNS,'user-field-decls'),
    (TEXTNS,'user-index-entry-template'),
    (TEXTNS,'user-index-source'),
    (TEXTNS,'variable-decls'),
)

empty_elements = (
    (ANIMNS,'animate'),
    (ANIMNS,'animateColor'),
    (ANIMNS,'animateMotion'),
    (ANIMNS,'animateTransform'),
    (ANIMNS,'audio'),
    (ANIMNS,'param'),
    (ANIMNS,'set'),
    (ANIMNS,'transitionFilter'),
    (CHARTNS,'categories'),
    (CHARTNS,'data-point'),
    (CHARTNS,'domain'),
    (CHARTNS,'error-indicator'),
    (CHARTNS,'floor'),
    (CHARTNS,'grid'),
    (CHARTNS,'legend'),
    (CHARTNS,'mean-value'),
    (CHARTNS,'regression-curve'),
    (CHARTNS,'stock-gain-marker'),
    (CHARTNS,'stock-loss-marker'),
    (CHARTNS,'stock-range-line'),
    (CHARTNS,'symbol-image'),
    (CHARTNS,'wall'),
    (DR3DNS,'cube'),
    (DR3DNS,'extrude'),
    (DR3DNS,'light'),
    (DR3DNS,'rotate'),
    (DR3DNS,'sphere'),
    (DRAWNS,'contour-path'),
    (DRAWNS,'contour-polygon'),
    (DRAWNS,'equation'),
    (DRAWNS,'fill-image'),
    (DRAWNS,'floating-frame'),
    (DRAWNS,'glue-point'),
    (DRAWNS,'gradient'),
    (DRAWNS,'handle'),
    (DRAWNS,'hatch'),
    (DRAWNS,'layer'),
    (DRAWNS,'marker'),
    (DRAWNS,'opacity'),
    (DRAWNS,'page-thumbnail'),
    (DRAWNS,'param'),
    (DRAWNS,'stroke-dash'),
    (FORMNS,'connection-resource'),
    (FORMNS,'list-value'),
    (FORMNS,'property'),
    (MANIFESTNS,'algorithm'),
    (MANIFESTNS,'key-derivation'),
    (METANS,'auto-reload'),
    (METANS,'document-statistic'),
    (METANS,'hyperlink-behaviour'),
    (METANS,'template'),
    (NUMBERNS,'am-pm'),
    (NUMBERNS,'boolean'),
    (NUMBERNS,'day'),
    (NUMBERNS,'day-of-week'),
    (NUMBERNS,'era'),
    (NUMBERNS,'fraction'),
    (NUMBERNS,'hours'),
    (NUMBERNS,'minutes'),
    (NUMBERNS,'month'),
    (NUMBERNS,'quarter'),
    (NUMBERNS,'scientific-number'),
    (NUMBERNS,'seconds'),
    (NUMBERNS,'text-content'),
    (NUMBERNS,'week-of-year'),
    (NUMBERNS,'year'),
    (OFFICENS,'dde-source'),
    (PRESENTATIONNS,'date-time'),
    (PRESENTATIONNS,'footer'),
    (PRESENTATIONNS,'header'),
    (PRESENTATIONNS,'placeholder'),
    (PRESENTATIONNS,'play'),
    (PRESENTATIONNS,'show'),
    (PRESENTATIONNS,'sound'),
    (SCRIPTNS,'event-listener'),
    (STYLENS,'column'),
    (STYLENS,'column-sep'),
    (STYLENS,'drop-cap'),
    (STYLENS,'footnote-sep'),
    (STYLENS,'list-level-properties'),
    (STYLENS,'map'),
    (STYLENS,'ruby-properties'),
    (STYLENS,'table-column-properties'),
    (STYLENS,'tab-stop'),
    (STYLENS,'text-properties'),
    (SVGNS,'definition-src'),
    (SVGNS,'font-face-format'),
    (SVGNS,'font-face-name'),
    (SVGNS,'stop'),
    (TABLENS,'body'),
    (TABLENS,'cell-address'),
    (TABLENS,'cell-range-source'),
    (TABLENS,'change-deletion'),
    (TABLENS,'consolidation'),
    (TABLENS,'database-source-query'),
    (TABLENS,'database-source-sql'),
    (TABLENS,'database-source-table'),
    (TABLENS,'data-pilot-display-info'),
    (TABLENS,'data-pilot-field-reference'),
    (TABLENS,'data-pilot-group-member'),
    (TABLENS,'data-pilot-layout-info'),
    (TABLENS,'data-pilot-member'),
    (TABLENS,'data-pilot-sort-info'),
    (TABLENS,'data-pilot-subtotal'),
    (TABLENS,'dependency'),
    (TABLENS,'error-macro'),
    (TABLENS,'even-columns'),
    (TABLENS,'even-rows'),
    (TABLENS,'filter-condition'),
    (TABLENS,'first-column'),
    (TABLENS,'first-row'),
    (TABLENS,'highlighted-range'),
    (TABLENS,'insertion-cut-off'),
    (TABLENS,'iteration'),
    (TABLENS,'label-range'),
    (TABLENS,'last-column'),
    (TABLENS,'last-row'),
    (TABLENS,'movement-cut-off'),
    (TABLENS,'named-expression'),
    (TABLENS,'named-range'),
    (TABLENS,'null-date'),
    (TABLENS,'odd-columns'),
    (TABLENS,'odd-rows'),
    (TABLENS,'operation'),
    (TABLENS,'scenario'),
    (TABLENS,'sort-by'),
    (TABLENS,'sort-groups'),
    (TABLENS,'source-range-address'),
    (TABLENS,'source-service'),
    (TABLENS,'subtotal-field'),
    (TABLENS,'table-column'),
    (TABLENS,'table-source'),
    (TABLENS,'target-range-address'),
    (TEXTNS,'alphabetical-index-auto-mark-file'),
    (TEXTNS,'alphabetical-index-mark'),
    (TEXTNS,'alphabetical-index-mark-end'),
    (TEXTNS,'alphabetical-index-mark-start'),
    (TEXTNS,'bookmark'),
    (TEXTNS,'bookmark-end'),
    (TEXTNS,'bookmark-start'),
    (TEXTNS,'change'),
    (TEXTNS,'change-end'),
    (TEXTNS,'change-start'),
    (TEXTNS,'dde-connection-decl'),
    (TEXTNS,'index-entry-bibliography'),
    (TEXTNS,'index-entry-chapter'),
    (TEXTNS,'index-entry-link-end'),
    (TEXTNS,'index-entry-link-start'),
    (TEXTNS,'index-entry-page-number'),
    (TEXTNS,'index-entry-tab-stop'),
    (TEXTNS,'index-entry-text'),
    (TEXTNS,'index-source-style'),
    (TEXTNS,'line-break'),
    (TEXTNS,'page'),
    (TEXTNS,'reference-mark'),
    (TEXTNS,'reference-mark-end'),
    (TEXTNS,'reference-mark-start'),
    (TEXTNS,'s'),
    (TEXTNS,'section-source'),
    (TEXTNS,'sequence-decl'),
    (TEXTNS,'soft-page-break'),
    (TEXTNS,'sort-key'),
    (TEXTNS,'tab'),
    (TEXTNS,'toc-mark'),
    (TEXTNS,'toc-mark-end'),
    (TEXTNS,'toc-mark-start'),
    (TEXTNS,'user-field-decl'),
    (TEXTNS,'user-index-mark'),
    (TEXTNS,'user-index-mark-end'),
    (TEXTNS,'user-index-mark-start'),
    (TEXTNS,'variable-decl')
)

########NEW FILE########
__FILENAME__ = form
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import FORMNS
from .element import Element


# Autogenerated
def Button(**args):
    return Element(qname = (FORMNS,'button'), **args)

def Checkbox(**args):
    return Element(qname = (FORMNS,'checkbox'), **args)

def Column(**args):
    return Element(qname = (FORMNS,'column'), **args)

def Combobox(**args):
    return Element(qname = (FORMNS,'combobox'), **args)

def ConnectionResource(**args):
    return Element(qname = (FORMNS,'connection-resource'), **args)

def Date(**args):
    return Element(qname = (FORMNS,'date'), **args)

def File(**args):
    return Element(qname = (FORMNS,'file'), **args)

def FixedText(**args):
    return Element(qname = (FORMNS,'fixed-text'), **args)

def Form(**args):
    return Element(qname = (FORMNS,'form'), **args)

def FormattedText(**args):
    return Element(qname = (FORMNS,'formatted-text'), **args)

def Frame(**args):
    return Element(qname = (FORMNS,'frame'), **args)

def GenericControl(**args):
    return Element(qname = (FORMNS,'generic-control'), **args)

def Grid(**args):
    return Element(qname = (FORMNS,'grid'), **args)

def Hidden(**args):
    return Element(qname = (FORMNS,'hidden'), **args)

def Image(**args):
    return Element(qname = (FORMNS,'image'), **args)

def ImageFrame(**args):
    return Element(qname = (FORMNS,'image-frame'), **args)

def Item(**args):
    return Element(qname = (FORMNS,'item'), **args)

def ListProperty(**args):
    return Element(qname = (FORMNS,'list-property'), **args)

def ListValue(**args):
    return Element(qname = (FORMNS,'list-value'), **args)

def Listbox(**args):
    return Element(qname = (FORMNS,'listbox'), **args)

def Number(**args):
    return Element(qname = (FORMNS,'number'), **args)

def Option(**args):
    return Element(qname = (FORMNS,'option'), **args)

def Password(**args):
    return Element(qname = (FORMNS,'password'), **args)

def Properties(**args):
    return Element(qname = (FORMNS,'properties'), **args)

def Property(**args):
    return Element(qname = (FORMNS,'property'), **args)

def Radio(**args):
    return Element(qname = (FORMNS,'radio'), **args)

def Text(**args):
    return Element(qname = (FORMNS,'text'), **args)

def Textarea(**args):
    return Element(qname = (FORMNS,'textarea'), **args)

def Time(**args):
    return Element(qname = (FORMNS,'time'), **args)

def ValueRange(**args):
    return Element(qname = (FORMNS,'value-range'), **args)


########NEW FILE########
__FILENAME__ = grammar
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2010 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

__doc__=""" In principle the OpenDocument schema converted to python structures.
Currently it contains the legal child elements of a given element.
To be used for validation check in the API
"""

from .namespaces import *

# The following code is generated from the RelaxNG schema with this notice:

#   OASIS OpenDocument v1.1
#   OASIS Standard, 1 Feb 2007
#   Relax-NG Schema

#   $Id$

#    2002-2007 OASIS Open
#    1999-2007 Sun Microsystems, Inc.

#   This document and translations of it may be copied and furnished
#   to others, and derivative works that comment on or otherwise explain
#   it or assist in its implementation may be prepared, copied,
#   published and distributed, in whole or in part, without restriction
#   of any kind, provided that the above copyright notice and this
#   paragraph are included on all such copies and derivative works.
#   However, this document itself does not be modified in any way, such
#   as by removing the copyright notice or references to OASIS, except
#   as needed for the purpose of developing OASIS specifications, in
#   which case the procedures for copyrights defined in the OASIS
#   Intellectual Property Rights document must be followed, or as
#   required to translate it into languages other than English.
#

allowed_children = {
	(DCNS,'creator') : (
	),
	(DCNS,'date') : (
	),
	(DCNS,'description') : (
	),
	(DCNS,'language') : (
	),
	(DCNS,'subject') : (
	),
	(DCNS,'title') : (
	),
# Completes Dublin Core start
#	(DCNS,'contributor') : (
#	),
#	(DCNS,'coverage') : (
#	),
#	(DCNS,'format') : (
#	),
#	(DCNS,'identifier') : (
#	),
#	(DCNS,'publisher') : (
#	),
#	(DCNS,'relation') : (
#	),
#	(DCNS,'rights') : (
#	),
#	(DCNS,'source') : (
#	),
#	(DCNS,'type') : (
#	),
# Completes Dublin Core end
	(MATHNS,'math') : None,

	(XFORMSNS,'model') : None,

	(ANIMNS,'animate') : (
	),
	(ANIMNS,'animateColor') : (
	),
	(ANIMNS,'animateMotion') : (
	),
	(ANIMNS,'animateTransform') : (
	),
	(ANIMNS,'audio') : (
	),
	(ANIMNS,'command') : (
		(ANIMNS,'param'),
	),
# allowed_children
	(ANIMNS,'iterate') : (
		(ANIMNS,'animate'),
		(ANIMNS,'animateColor'),
		(ANIMNS,'animateMotion'),
		(ANIMNS,'animateTransform'),
		(ANIMNS,'audio'),
		(ANIMNS,'command'),
		(ANIMNS,'iterate'),
		(ANIMNS,'par'),
		(ANIMNS,'seq'),
		(ANIMNS,'set'),
		(ANIMNS,'transitionFilter'),
	),
	(ANIMNS,'par') : (
		(ANIMNS,'animate'),
		(ANIMNS,'animateColor'),
		(ANIMNS,'animateMotion'),
		(ANIMNS,'animateTransform'),
		(ANIMNS,'audio'),
		(ANIMNS,'command'),
		(ANIMNS,'iterate'),
		(ANIMNS,'par'),
		(ANIMNS,'seq'),
		(ANIMNS,'set'),
		(ANIMNS,'transitionFilter'),
	),
# allowed_children
	(ANIMNS,'param') : (
	),
	(ANIMNS,'seq') : (
		(ANIMNS,'animate'),
		(ANIMNS,'animateColor'),
		(ANIMNS,'animateMotion'),
		(ANIMNS,'animateTransform'),
		(ANIMNS,'audio'),
		(ANIMNS,'command'),
		(ANIMNS,'iterate'),
		(ANIMNS,'par'),
		(ANIMNS,'seq'),
		(ANIMNS,'set'),
		(ANIMNS,'transitionFilter'),
	),
	(ANIMNS,'set') : (
	),
	(ANIMNS,'transitionFilter') : (
	),
	(CHARTNS,'axis') : (
		(CHARTNS,'categories'),
		(CHARTNS,'grid'),
		(CHARTNS,'title'),
	),
# allowed_children
	(CHARTNS,'categories') : (
	),
	(CHARTNS,'chart') : (
		(CHARTNS,'footer'),
		(CHARTNS,'legend'),
		(CHARTNS,'plot-area'),
		(CHARTNS,'subtitle'),
		(CHARTNS,'title'),
		(TABLENS,'table'),
	),
	(CHARTNS,'data-point') : (
	),
	(CHARTNS,'domain') : (
	),
	(CHARTNS,'error-indicator') : (
	),
	(CHARTNS,'floor') : (
	),
	(CHARTNS,'footer') : (
		(TEXTNS,'p'),
	),
	(CHARTNS,'grid') : (
	),
	(CHARTNS,'legend') : (
	),
# allowed_children
	(CHARTNS,'mean-value') : (
	),
	(CHARTNS,'plot-area') : (
		(CHARTNS,'axis'),
		(CHARTNS,'floor'),
		(CHARTNS,'series'),
		(CHARTNS,'stock-gain-marker'),
		(CHARTNS,'stock-loss-marker'),
		(CHARTNS,'stock-range-line'),
		(CHARTNS,'wall'),
		(DR3DNS,'light'),
	),
	(CHARTNS,'regression-curve') : (
	),
	(CHARTNS,'series') : (
		(CHARTNS,'data-point'),
		(CHARTNS,'domain'),
		(CHARTNS,'error-indicator'),
		(CHARTNS,'mean-value'),
		(CHARTNS,'regression-curve'),
	),
	(CHARTNS,'stock-gain-marker') : (
	),
	(CHARTNS,'stock-loss-marker') : (
	),
# allowed_children
	(CHARTNS,'stock-range-line') : (
	),
	(CHARTNS,'subtitle') : (
		(TEXTNS,'p'),
	),
	(CHARTNS,'symbol-image') : (
	),
	(CHARTNS,'title') : (
		(TEXTNS,'p'),
	),
	(CHARTNS,'wall') : (
	),
	(CONFIGNS,'config-item') : (
	),
	(CONFIGNS,'config-item-map-entry') : (
		(CONFIGNS,'config-item'),
		(CONFIGNS,'config-item-map-indexed'),
		(CONFIGNS,'config-item-map-named'),
		(CONFIGNS,'config-item-set'),
	),
	(CONFIGNS,'config-item-map-indexed') : (
		(CONFIGNS,'config-item-map-entry'),
	),
	(CONFIGNS,'config-item-map-named') : (
		(CONFIGNS,'config-item-map-entry'),
	),
# allowed_children
	(CONFIGNS,'config-item-set') : (
		(CONFIGNS,'config-item'),
		(CONFIGNS,'config-item-map-indexed'),
		(CONFIGNS,'config-item-map-named'),
		(CONFIGNS,'config-item-set'),
	),
	(MANIFESTNS,'algorithm') : (
	),
	(MANIFESTNS,'encryption-data') : (
		(MANIFESTNS,'algorithm'),
		(MANIFESTNS,'key-derivation'),
	),
	(MANIFESTNS,'file-entry') : (
		(MANIFESTNS,'encryption-data'),
	),
	(MANIFESTNS,'key-derivation') : (
	),
	(MANIFESTNS,'manifest') : (
		(MANIFESTNS,'file-entry'),
	),
	(NUMBERNS,'am-pm') : (
	),
	(NUMBERNS,'boolean') : (
	),
# allowed_children
	(NUMBERNS,'boolean-style') : (
		(NUMBERNS,'boolean'),
		(NUMBERNS,'text'),
		(STYLENS,'map'),
		(STYLENS,'text-properties'),
	),
	(NUMBERNS,'currency-style') : (
		(NUMBERNS,'currency-symbol'),
		(NUMBERNS,'number'),
		(NUMBERNS,'text'),
		(STYLENS,'map'),
		(STYLENS,'text-properties'),
	),
	(NUMBERNS,'currency-symbol') : (
	),
	(NUMBERNS,'date-style') : (
		(NUMBERNS,'am-pm'),
		(NUMBERNS,'day'),
		(NUMBERNS,'day-of-week'),
		(NUMBERNS,'era'),
		(NUMBERNS,'hours'),
		(NUMBERNS,'minutes'),
		(NUMBERNS,'month'),
		(NUMBERNS,'quarter'),
		(NUMBERNS,'seconds'),
		(NUMBERNS,'text'),
		(NUMBERNS,'week-of-year'),
		(NUMBERNS,'year'),
		(STYLENS,'map'),
		(STYLENS,'text-properties'),
	),
# allowed_children
	(NUMBERNS,'day') : (
	),
	(NUMBERNS,'day-of-week') : (
	),
	(NUMBERNS,'embedded-text') : (
	),
	(NUMBERNS,'era') : (
	),
	(NUMBERNS,'fraction') : (
	),
	(NUMBERNS,'hours') : (
	),
	(NUMBERNS,'minutes') : (
	),
	(NUMBERNS,'month') : (
	),
	(NUMBERNS,'number') : (
		(NUMBERNS,'embedded-text'),
	),
	(NUMBERNS,'number-style') : (
		(NUMBERNS,'fraction'),
		(NUMBERNS,'number'),
		(NUMBERNS,'scientific-number'),
		(NUMBERNS,'text'),
		(STYLENS,'map'),
		(STYLENS,'text-properties'),
	),
# allowed_children
	(NUMBERNS,'percentage-style') : (
		(NUMBERNS,'number'),
		(NUMBERNS,'text'),
		(STYLENS,'map'),
		(STYLENS,'text-properties'),
	),
	(NUMBERNS,'quarter') : (
	),
	(NUMBERNS,'scientific-number') : (
	),
	(NUMBERNS,'seconds') : (
	),
	(NUMBERNS,'text') : (
	),
	(NUMBERNS,'text-content') : (
	),
	(NUMBERNS,'text-style') : (
		(NUMBERNS,'text'),
		(NUMBERNS,'text-content'),
		(STYLENS,'map'),
		(STYLENS,'text-properties'),
	),
# allowed_children
	(NUMBERNS,'time-style') : (
		(NUMBERNS,'am-pm'),
		(NUMBERNS,'hours'),
		(NUMBERNS,'minutes'),
		(NUMBERNS,'seconds'),
		(NUMBERNS,'text'),
		(STYLENS,'map'),
		(STYLENS,'text-properties'),
	),
# allowed_children
	(NUMBERNS,'week-of-year') : (
	),
	(NUMBERNS,'year') : (
	),
	(DR3DNS,'cube') : (
	),
	(DR3DNS,'extrude') : (
	),
	(DR3DNS,'light') : (
	),
	(DR3DNS,'rotate') : (
	),
	(DR3DNS,'scene') : (
		(DR3DNS,'cube'),
		(DR3DNS,'extrude'),
		(DR3DNS,'light'),
		(DR3DNS,'rotate'),
		(DR3DNS,'scene'),
		(DR3DNS,'sphere'),
		(SVGNS,'title'),
		(SVGNS,'desc'),
	),
	(DR3DNS,'sphere') : (
	),
	(DRAWNS,'a') : (
		(DRAWNS,'frame'),
	),
# allowed_children
	(DRAWNS,'applet') : (
		(DRAWNS,'param'),
	),
	(DRAWNS,'area-circle') : (
		(OFFICENS,'event-listeners'),
		(SVGNS,'desc'),
		(SVGNS,'title'),
	),
	(DRAWNS,'area-polygon') : (
		(OFFICENS,'event-listeners'),
		(SVGNS,'desc'),
		(SVGNS,'title'),
	),
	(DRAWNS,'area-rectangle') : (
		(OFFICENS,'event-listeners'),
		(SVGNS,'desc'),
		(SVGNS,'title'),
	),
	(DRAWNS,'caption') : (
		(DRAWNS,'glue-point'),
		(OFFICENS,'event-listeners'),
		(SVGNS,'desc'),
		(SVGNS,'title'),
		(TEXTNS,'list'),
		(TEXTNS,'p'),
	),
	(DRAWNS,'circle') : (
		(DRAWNS,'glue-point'),
		(OFFICENS,'event-listeners'),
		(SVGNS,'desc'),
		(SVGNS,'title'),
		(TEXTNS,'list'),
		(TEXTNS,'p'),
	),
# allowed_children
	(DRAWNS,'connector') : (
		(DRAWNS,'glue-point'),
		(OFFICENS,'event-listeners'),
		(SVGNS,'desc'),
		(SVGNS,'title'),
		(TEXTNS,'list'),
		(TEXTNS,'p'),
	),
	(DRAWNS,'contour-path') : (
	),
	(DRAWNS,'contour-polygon') : (
	),
	(DRAWNS,'control') : (
		(DRAWNS,'glue-point'),
		(SVGNS,'desc'),
		(SVGNS,'title'),
	),
	(DRAWNS,'custom-shape') : (
		(DRAWNS,'enhanced-geometry'),
		(DRAWNS,'glue-point'),
		(OFFICENS,'event-listeners'),
		(SVGNS,'desc'),
		(SVGNS,'title'),
		(TEXTNS,'list'),
		(TEXTNS,'p'),
	),
# allowed_children
	(DRAWNS,'ellipse') : (
		(DRAWNS,'glue-point'),
		(OFFICENS,'event-listeners'),
		(SVGNS,'desc'),
		(SVGNS,'title'),
		(TEXTNS,'list'),
		(TEXTNS,'p'),
	),
	(DRAWNS,'enhanced-geometry') : (
		(DRAWNS,'equation'),
		(DRAWNS,'handle'),
	),
	(DRAWNS,'equation') : (
	),
# allowed_children
	(DRAWNS,'fill-image') : (
	),
	(DRAWNS,'floating-frame') : (
	),
	(DRAWNS,'frame') : (
		(DRAWNS,'applet'),
		(DRAWNS,'contour-path'),
		(DRAWNS,'contour-polygon'),
		(DRAWNS,'floating-frame'),
		(DRAWNS,'glue-point'),
		(DRAWNS,'image'),
		(DRAWNS,'image-map'),
		(DRAWNS,'object'),
		(DRAWNS,'object-ole'),
		(DRAWNS,'plugin'),
		(DRAWNS,'text-box'),
		(OFFICENS,'event-listeners'),
		(SVGNS,'desc'),
		(SVGNS,'title'),
	),
# allowed_children
	(DRAWNS,'g') : (
		(DR3DNS,'scene'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'glue-point'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(SVGNS,'desc'),
		(SVGNS,'title'),
		(OFFICENS,'event-listeners'),
	),
	(DRAWNS,'glue-point') : (
	),
	(DRAWNS,'gradient') : (
	),
	(DRAWNS,'handle') : (
	),
	(DRAWNS,'hatch') : (
	),
# allowed_children
	(DRAWNS,'image') : (
		(OFFICENS,'binary-data'),
		(TEXTNS,'list'),
		(TEXTNS,'p'),
	),
	(DRAWNS,'image-map') : (
		(DRAWNS,'area-circle'),
		(DRAWNS,'area-polygon'),
		(DRAWNS,'area-rectangle'),
	),
	(DRAWNS,'layer') : (
		(SVGNS,'desc'),
		(SVGNS,'title'),
	),
	(DRAWNS,'layer-set') : (
		(DRAWNS,'layer'),
	),
	(DRAWNS,'line') : (
		(DRAWNS,'glue-point'),
		(OFFICENS,'event-listeners'),
		(SVGNS,'desc'),
		(SVGNS,'title'),
		(TEXTNS,'list'),
		(TEXTNS,'p'),
	),
	(DRAWNS,'marker') : (
	),
	(DRAWNS,'measure') : (
		(DRAWNS,'glue-point'),
		(OFFICENS,'event-listeners'),
		(TEXTNS,'list'),
		(TEXTNS,'p'),
		(SVGNS,'title'),
		(SVGNS,'desc'),
	),
	(DRAWNS,'object') : (
		(MATHNS,'math'),
		(OFFICENS,'document'),
	),
# allowed_children
	(DRAWNS,'object-ole') : (
		(OFFICENS,'binary-data'),
	),
	(DRAWNS,'opacity') : (
	),
	(DRAWNS,'page') : (
		(ANIMNS,'animate'),
		(ANIMNS,'animateColor'),
		(ANIMNS,'animateMotion'),
		(ANIMNS,'animateTransform'),
		(ANIMNS,'audio'),
		(ANIMNS,'command'),
		(ANIMNS,'iterate'),
		(ANIMNS,'par'),
		(ANIMNS,'seq'),
		(ANIMNS,'set'),
		(ANIMNS,'transitionFilter'),
		(DR3DNS,'scene'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(OFFICENS,'forms'),
		(PRESENTATIONNS,'animations'),
		(PRESENTATIONNS,'notes'),
	),
# allowed_children
	(DRAWNS,'page-thumbnail') : (
		(SVGNS,'desc'),
		(SVGNS,'title'),
	),
	(DRAWNS,'param') : (
	),
	(DRAWNS,'path') : (
		(DRAWNS,'glue-point'),
		(OFFICENS,'event-listeners'),
		(SVGNS,'desc'),
		(SVGNS,'title'),
		(TEXTNS,'list'),
		(TEXTNS,'p'),
	),
	(DRAWNS,'plugin') : (
		(DRAWNS,'param'),
	),
	(DRAWNS,'polygon') : (
		(DRAWNS,'glue-point'),
		(OFFICENS,'event-listeners'),
		(SVGNS,'title'),
		(SVGNS,'desc'),
		(TEXTNS,'list'),
		(TEXTNS,'p'),
	),
	(DRAWNS,'polyline') : (
		(DRAWNS,'glue-point'),
		(OFFICENS,'event-listeners'),
		(SVGNS,'desc'),
		(SVGNS,'title'),
		(TEXTNS,'list'),
		(TEXTNS,'p'),
	),
# allowed_children
	(DRAWNS,'rect') : (
		(DRAWNS,'glue-point'),
		(OFFICENS,'event-listeners'),
		(SVGNS,'desc'),
		(SVGNS,'title'),
		(TEXTNS,'list'),
		(TEXTNS,'p'),
	),
	(DRAWNS,'regular-polygon') : (
		(DRAWNS,'glue-point'),
		(OFFICENS,'event-listeners'),
		(SVGNS,'desc'),
		(SVGNS,'title'),
		(TEXTNS,'list'),
		(TEXTNS,'p'),
	),
	(DRAWNS,'stroke-dash') : (
	),
	(DRAWNS,'text-box') : (
		(DR3DNS,'scene'),
		(DRAWNS,'a'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(TABLENS,'table'),
		(TEXTNS,'alphabetical-index'),
		(TEXTNS,'bibliography'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'h'),
		(TEXTNS,'illustration-index'),
		(TEXTNS,'list'),
		(TEXTNS,'numbered-paragraph'),
		(TEXTNS,'object-index'),
		(TEXTNS,'p'),
		(TEXTNS,'section'),
		(TEXTNS,'soft-page-break'),
		(TEXTNS,'table-index'),
		(TEXTNS,'table-of-content'),
		(TEXTNS,'user-index'),
	),
# allowed_children
	(FORMNS,'button') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'checkbox') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'column') : (
		(FORMNS,'checkbox'),
		(FORMNS,'combobox'),
		(FORMNS,'date'),
		(FORMNS,'formatted-text'),
		(FORMNS,'listbox'),
		(FORMNS,'number'),
		(FORMNS,'text'),
		(FORMNS,'textarea'),
	),
	(FORMNS,'combobox') : (
		(FORMNS,'item'),
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'connection-resource') : (
	),
	(FORMNS,'date') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'file') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'fixed-text') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
# allowed_children
	(FORMNS,'form') : (
		(FORMNS,'button'),
		(FORMNS,'checkbox'),
		(FORMNS,'combobox'),
		(FORMNS,'connection-resource'),
		(FORMNS,'date'),
		(FORMNS,'file'),
		(FORMNS,'fixed-text'),
		(FORMNS,'form'),
		(FORMNS,'formatted-text'),
		(FORMNS,'frame'),
		(FORMNS,'generic-control'),
		(FORMNS,'grid'),
		(FORMNS,'hidden'),
		(FORMNS,'image'),
		(FORMNS,'image-frame'),
		(FORMNS,'listbox'),
		(FORMNS,'number'),
		(FORMNS,'password'),
		(FORMNS,'properties'),
		(FORMNS,'radio'),
		(FORMNS,'text'),
		(FORMNS,'textarea'),
		(FORMNS,'time'),
		(FORMNS,'value-range'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'formatted-text') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'frame') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'generic-control') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'grid') : (
		(FORMNS,'column'),
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'hidden') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'image') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
# allowed_children
	(FORMNS,'image-frame') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'item') : (
	),
	(FORMNS,'list-property') : (
		(FORMNS,'list-value'),
		(FORMNS,'list-value'),
		(FORMNS,'list-value'),
		(FORMNS,'list-value'),
		(FORMNS,'list-value'),
		(FORMNS,'list-value'),
		(FORMNS,'list-value'),
	),
	(FORMNS,'list-value') : (
	),
	(FORMNS,'listbox') : (
		(FORMNS,'option'),
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'number') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'option') : (
	),
	(FORMNS,'password') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'properties') : (
		(FORMNS,'list-property'),
		(FORMNS,'property'),
	),
	(FORMNS,'property') : (
	),
	(FORMNS,'radio') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'text') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'textarea') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
		(TEXTNS,'p'),
	),
	(FORMNS,'time') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(FORMNS,'value-range') : (
		(FORMNS,'properties'),
		(OFFICENS,'event-listeners'),
	),
	(METANS,'auto-reload') : (
	),
	(METANS,'creation-date') : (
	),
	(METANS,'date-string') : (
	),
	(METANS,'document-statistic') : (
	),
	(METANS,'editing-cycles') : (
	),
	(METANS,'editing-duration') : (
	),
	(METANS,'generator') : (
	),
	(METANS,'hyperlink-behaviour') : (
	),
	(METANS,'initial-creator') : (
	),
	(METANS,'keyword') : (
	),
	(METANS,'print-date') : (
	),
	(METANS,'printed-by') : (
	),
	(METANS,'template') : (
	),
	(METANS,'user-defined') : (
	),
# allowed_children
	(OFFICENS,'annotation') : (
		(DCNS,'creator'),
		(DCNS,'date'),
		(METANS,'date-string'),
		(TEXTNS,'list'),
		(TEXTNS,'p'),
	),
	(OFFICENS,'automatic-styles') : (
		(NUMBERNS,'boolean-style'),
		(NUMBERNS,'currency-style'),
		(NUMBERNS,'date-style'),
		(NUMBERNS,'number-style'),
		(NUMBERNS,'percentage-style'),
		(NUMBERNS,'text-style'),
		(NUMBERNS,'time-style'),
		(STYLENS,'page-layout'),
		(STYLENS,'style'),
		(TEXTNS,'list-style'),
	),
	(OFFICENS,'binary-data') : (
	),
	(OFFICENS,'body') : (
		(OFFICENS,'chart'),
		(OFFICENS,'drawing'),
		(OFFICENS,'image'),
		(OFFICENS,'presentation'),
		(OFFICENS,'spreadsheet'),
		(OFFICENS,'text'),
	),
	(OFFICENS,'change-info') : (
		(DCNS,'creator'),
		(DCNS,'date'),
		(TEXTNS,'p'),
	),
	(OFFICENS,'chart') : (
		(CHARTNS,'chart'),
		(TABLENS,'calculation-settings'),
		(TABLENS,'consolidation'),
		(TABLENS,'content-validations'),
		(TABLENS,'data-pilot-tables'),
		(TABLENS,'database-ranges'),
		(TABLENS,'dde-links'),
		(TABLENS,'label-ranges'),
		(TABLENS,'named-expressions'),
		(TEXTNS,'alphabetical-index-auto-mark-file'),
		(TEXTNS,'dde-connection-decls'),
		(TEXTNS,'sequence-decls'),
		(TEXTNS,'user-field-decls'),
		(TEXTNS,'variable-decls'),
	),
	(OFFICENS,'dde-source') : (
	),
	(OFFICENS,'document') : (
		(OFFICENS,'automatic-styles'),
		(OFFICENS,'body'),
		(OFFICENS,'font-face-decls'),
		(OFFICENS,'master-styles'),
		(OFFICENS,'meta'),
		(OFFICENS,'scripts'),
		(OFFICENS,'settings'),
		(OFFICENS,'styles'),
	),
	(OFFICENS,'document-content') : (
		(OFFICENS,'automatic-styles'),
		(OFFICENS,'body'),
		(OFFICENS,'font-face-decls'),
		(OFFICENS,'scripts'),
	),
	(OFFICENS,'document-meta') : (
		(OFFICENS,'meta'),
	),
	(OFFICENS,'document-settings') : (
		(OFFICENS,'settings'),
	),
	(OFFICENS,'document-styles') : (
		(OFFICENS,'automatic-styles'),
		(OFFICENS,'font-face-decls'),
		(OFFICENS,'master-styles'),
		(OFFICENS,'styles'),
	),
	(OFFICENS,'drawing') : (
		(DRAWNS,'page'),
		(TABLENS,'calculation-settings'),
		(TABLENS,'consolidation'),
		(TABLENS,'content-validations'),
		(TABLENS,'data-pilot-tables'),
		(TABLENS,'database-ranges'),
		(TABLENS,'dde-links'),
		(TABLENS,'label-ranges'),
		(TABLENS,'named-expressions'),
		(TEXTNS,'alphabetical-index-auto-mark-file'),
		(TEXTNS,'dde-connection-decls'),
		(TEXTNS,'sequence-decls'),
		(TEXTNS,'user-field-decls'),
		(TEXTNS,'variable-decls'),
	),
	(OFFICENS,'event-listeners') : (
		(PRESENTATIONNS,'event-listener'),
		(SCRIPTNS,'event-listener'),
	),
	(OFFICENS,'font-face-decls') : (
		(STYLENS,'font-face'),
	),
# allowed_children
	(OFFICENS,'forms') : (
		(XFORMSNS,'model'),
		(FORMNS,'form'),
	),
	(OFFICENS,'image') : (
		(DRAWNS,'frame'),
	),
	(OFFICENS,'master-styles') : (
		(DRAWNS,'layer-set'),
		(STYLENS,'handout-master'),
		(STYLENS,'master-page'),
		(TABLENS,'table-template'),
	),
	(OFFICENS,'meta') : (
		(DCNS,'creator'),
		(DCNS,'date'),
		(DCNS,'description'),
		(DCNS,'language'),
		(DCNS,'subject'),
		(DCNS,'title'),
# Completes Dublin Core start
#		(DCNS,'contributor'),
#		(DCNS,'coverage'),
#		(DCNS,'format'),
#		(DCNS,'identifier'),
#		(DCNS,'publisher'),
#		(DCNS,'relation'),
#		(DCNS,'rights'),
#		(DCNS,'source'),
#		(DCNS,'type'),
# Completes Dublin Core end
		(METANS,'auto-reload'),
		(METANS,'creation-date'),
		(METANS,'document-statistic'),
		(METANS,'editing-cycles'),
		(METANS,'editing-duration'),
		(METANS,'generator'),
		(METANS,'hyperlink-behaviour'),
		(METANS,'initial-creator'),
		(METANS,'keyword'),
		(METANS,'print-date'),
		(METANS,'printed-by'),
		(METANS,'template'),
		(METANS,'user-defined'),
	),
	(OFFICENS,'presentation') : (
		(DRAWNS,'page'),
		(PRESENTATIONNS,'date-time-decl'),
		(PRESENTATIONNS,'footer-decl'),
		(PRESENTATIONNS,'header-decl'),
		(PRESENTATIONNS,'settings'),
		(TABLENS,'calculation-settings'),
		(TABLENS,'consolidation'),
		(TABLENS,'content-validations'),
		(TABLENS,'data-pilot-tables'),
		(TABLENS,'database-ranges'),
		(TABLENS,'dde-links'),
		(TABLENS,'label-ranges'),
		(TABLENS,'named-expressions'),
		(TEXTNS,'alphabetical-index-auto-mark-file'),
		(TEXTNS,'dde-connection-decls'),
		(TEXTNS,'sequence-decls'),
		(TEXTNS,'user-field-decls'),
		(TEXTNS,'variable-decls'),
	),
# allowed_children
	(OFFICENS,'script') : None,

	(OFFICENS,'scripts') : (
		(OFFICENS,'event-listeners'),
		(OFFICENS,'script'),
	),
	(OFFICENS,'settings') : (
		(CONFIGNS,'config-item-set'),
	),
	(OFFICENS,'spreadsheet') : (
		(TABLENS,'calculation-settings'),
		(TABLENS,'consolidation'),
		(TABLENS,'content-validations'),
		(TABLENS,'data-pilot-tables'),
		(TABLENS,'database-ranges'),
		(TABLENS,'dde-links'),
		(TABLENS,'label-ranges'),
		(TABLENS,'named-expressions'),
		(TABLENS,'table'),
		(TABLENS,'tracked-changes'),
		(TEXTNS,'alphabetical-index-auto-mark-file'),
		(TEXTNS,'dde-connection-decls'),
		(TEXTNS,'sequence-decls'),
		(TEXTNS,'user-field-decls'),
		(TEXTNS,'variable-decls'),
	),
	(OFFICENS,'styles') : (
		(NUMBERNS,'boolean-style'),
		(NUMBERNS,'currency-style'),
		(NUMBERNS,'date-style'),
		(NUMBERNS,'number-style'),
		(NUMBERNS,'percentage-style'),
		(NUMBERNS,'text-style'),
		(NUMBERNS,'time-style'),
		(DRAWNS,'fill-image'),
		(DRAWNS,'gradient'),
		(DRAWNS,'hatch'),
		(DRAWNS,'marker'),
		(DRAWNS,'opacity'),
		(DRAWNS,'stroke-dash'),
		(STYLENS,'default-style'),
		(STYLENS,'presentation-page-layout'),
		(STYLENS,'style'),
		(SVGNS,'linearGradient'),
		(SVGNS,'radialGradient'),
		(TEXTNS,'bibliography-configuration'),
		(TEXTNS,'linenumbering-configuration'),
		(TEXTNS,'list-style'),
		(TEXTNS,'notes-configuration'),
		(TEXTNS,'outline-style'),
	),
	(OFFICENS,'text') : (
		(DR3DNS,'scene'),
		(DRAWNS,'a'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(OFFICENS,'forms'),
		(TABLENS,'calculation-settings'),
		(TABLENS,'consolidation'),
		(TABLENS,'content-validations'),
		(TABLENS,'data-pilot-tables'),
		(TABLENS,'database-ranges'),
		(TABLENS,'dde-links'),
		(TABLENS,'label-ranges'),
		(TABLENS,'named-expressions'),
		(TABLENS,'table'),
		(TEXTNS,'alphabetical-index'),
		(TEXTNS,'alphabetical-index-auto-mark-file'),
		(TEXTNS,'bibliography'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'dde-connection-decls'),
		(TEXTNS,'h'),
		(TEXTNS,'illustration-index'),
		(TEXTNS,'list'),
		(TEXTNS,'numbered-paragraph'),
		(TEXTNS,'object-index'),
		(TEXTNS,'p'),
		(TEXTNS,'page-sequence'),
		(TEXTNS,'section'),
		(TEXTNS,'sequence-decls'),
		(TEXTNS,'soft-page-break'),
		(TEXTNS,'table-index'),
		(TEXTNS,'table-of-content'),
		(TEXTNS,'tracked-changes'),
		(TEXTNS,'user-field-decls'),
		(TEXTNS,'user-index'),
		(TEXTNS,'variable-decls'),
	),
	(PRESENTATIONNS,'animation-group') : (
		(PRESENTATIONNS,'dim'),
		(PRESENTATIONNS,'hide-shape'),
		(PRESENTATIONNS,'hide-text'),
		(PRESENTATIONNS,'play'),
		(PRESENTATIONNS,'show-shape'),
		(PRESENTATIONNS,'show-text'),
	),
	(PRESENTATIONNS,'animations') : (
		(PRESENTATIONNS,'animation-group'),
		(PRESENTATIONNS,'dim'),
		(PRESENTATIONNS,'hide-shape'),
		(PRESENTATIONNS,'hide-text'),
		(PRESENTATIONNS,'play'),
		(PRESENTATIONNS,'show-shape'),
		(PRESENTATIONNS,'show-text'),
	),
	(PRESENTATIONNS,'date-time') : (
	),
	(PRESENTATIONNS,'date-time-decl') : (
	),
	(PRESENTATIONNS,'dim') : (
		(PRESENTATIONNS,'sound'),
	),
	(PRESENTATIONNS,'event-listener') : (
		(PRESENTATIONNS,'sound'),
	),
	(PRESENTATIONNS,'footer') : (
	),
	(PRESENTATIONNS,'footer-decl') : (
	),
	(PRESENTATIONNS,'header') : (
	),
	(PRESENTATIONNS,'header-decl') : (
	),
	(PRESENTATIONNS,'hide-shape') : (
		(PRESENTATIONNS,'sound'),
	),
	(PRESENTATIONNS,'hide-text') : (
		(PRESENTATIONNS,'sound'),
	),
# allowed_children
	(PRESENTATIONNS,'notes') : (
		(DR3DNS,'scene'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(OFFICENS,'forms'),
	),
	(PRESENTATIONNS,'placeholder') : (
	),
	(PRESENTATIONNS,'play') : (
	),
	(PRESENTATIONNS,'settings') : (
		(PRESENTATIONNS,'show'),
	),
	(PRESENTATIONNS,'show') : (
	),
	(PRESENTATIONNS,'show-shape') : (
		(PRESENTATIONNS,'sound'),
	),
	(PRESENTATIONNS,'show-text') : (
		(PRESENTATIONNS,'sound'),
	),
	(PRESENTATIONNS,'sound') : (
	),
	(SCRIPTNS,'event-listener') : (
	),
	(STYLENS,'background-image') : (
		(OFFICENS,'binary-data'),
	),
	(STYLENS,'chart-properties') : (
		(CHARTNS,'symbol-image'),
	),
	(STYLENS,'column') : (
	),
	(STYLENS,'column-sep') : (
	),
	(STYLENS,'columns') : (
		(STYLENS,'column'),
		(STYLENS,'column-sep'),
	),
	(STYLENS,'default-style') : (
		(STYLENS,'chart-properties'),
		(STYLENS,'drawing-page-properties'),
		(STYLENS,'graphic-properties'),
		(STYLENS,'paragraph-properties'),
		(STYLENS,'ruby-properties'),
		(STYLENS,'section-properties'),
		(STYLENS,'table-cell-properties'),
		(STYLENS,'table-column-properties'),
		(STYLENS,'table-properties'),
		(STYLENS,'table-row-properties'),
		(STYLENS,'text-properties'),
	),
	(STYLENS,'drawing-page-properties') : (
		(PRESENTATIONNS,'sound'),
	),
	(STYLENS,'drop-cap') : (
	),
	(STYLENS,'font-face') : (
		(SVGNS,'definition-src'),
		(SVGNS,'font-face-src'),
	),
	(STYLENS,'footer') : (
		(STYLENS,'region-center'),
		(STYLENS,'region-left'),
		(STYLENS,'region-right'),
		(TABLENS,'table'),
		(TEXTNS,'alphabetical-index'),
		(TEXTNS,'alphabetical-index-auto-mark-file'),
		(TEXTNS,'bibliography'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'dde-connection-decls'),
		(TEXTNS,'h'),
		(TEXTNS,'illustration-index'),
		(TEXTNS,'index-title'),
		(TEXTNS,'list'),
		(TEXTNS,'object-index'),
		(TEXTNS,'p'),
		(TEXTNS,'section'),
		(TEXTNS,'sequence-decls'),
		(TEXTNS,'table-index'),
		(TEXTNS,'table-of-content'),
		(TEXTNS,'tracked-changes'),
		(TEXTNS,'user-field-decls'),
		(TEXTNS,'user-index'),
		(TEXTNS,'variable-decls'),
	),
# allowed_children
	(STYLENS,'footer-left') : (
		(STYLENS,'region-center'),
		(STYLENS,'region-left'),
		(STYLENS,'region-right'),
		(TABLENS,'table'),
		(TEXTNS,'alphabetical-index'),
		(TEXTNS,'alphabetical-index-auto-mark-file'),
		(TEXTNS,'bibliography'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'dde-connection-decls'),
		(TEXTNS,'h'),
		(TEXTNS,'illustration-index'),
		(TEXTNS,'index-title'),
		(TEXTNS,'list'),
		(TEXTNS,'object-index'),
		(TEXTNS,'p'),
		(TEXTNS,'section'),
		(TEXTNS,'sequence-decls'),
		(TEXTNS,'table-index'),
		(TEXTNS,'table-of-content'),
		(TEXTNS,'tracked-changes'),
		(TEXTNS,'user-field-decls'),
		(TEXTNS,'user-index'),
		(TEXTNS,'variable-decls'),
	),
	(STYLENS,'footer-style') : (
		(STYLENS,'header-footer-properties'),
	),
	(STYLENS,'footnote-sep') : (
	),
	(STYLENS,'graphic-properties') : (
		(STYLENS,'background-image'),
		(STYLENS,'columns'),
		(TEXTNS,'list-style'),
	),
# allowed_children
	(STYLENS,'handout-master') : (
		(DR3DNS,'scene'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
	),
	(STYLENS,'header') : (
		(STYLENS,'region-center'),
		(STYLENS,'region-left'),
		(STYLENS,'region-right'),
		(TABLENS,'table'),
		(TEXTNS,'alphabetical-index'),
		(TEXTNS,'alphabetical-index-auto-mark-file'),
		(TEXTNS,'bibliography'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'dde-connection-decls'),
		(TEXTNS,'h'),
		(TEXTNS,'illustration-index'),
		(TEXTNS,'index-title'),
		(TEXTNS,'list'),
		(TEXTNS,'object-index'),
		(TEXTNS,'p'),
		(TEXTNS,'section'),
		(TEXTNS,'sequence-decls'),
		(TEXTNS,'table-index'),
		(TEXTNS,'table-of-content'),
		(TEXTNS,'tracked-changes'),
		(TEXTNS,'user-field-decls'),
		(TEXTNS,'user-index'),
		(TEXTNS,'variable-decls'),
	),
# allowed_children
	(STYLENS,'header-footer-properties') : (
		(STYLENS,'background-image'),
	),
	(STYLENS,'header-left') : (
		(STYLENS,'region-center'),
		(STYLENS,'region-left'),
		(STYLENS,'region-right'),
		(TABLENS,'table'),
		(TEXTNS,'alphabetical-index'),
		(TEXTNS,'alphabetical-index-auto-mark-file'),
		(TEXTNS,'bibliography'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'dde-connection-decls'),
		(TEXTNS,'h'),
		(TEXTNS,'illustration-index'),
		(TEXTNS,'index-title'),
		(TEXTNS,'list'),
		(TEXTNS,'object-index'),
		(TEXTNS,'p'),
		(TEXTNS,'section'),
		(TEXTNS,'sequence-decls'),
		(TEXTNS,'table-index'),
		(TEXTNS,'table-of-content'),
		(TEXTNS,'tracked-changes'),
		(TEXTNS,'user-field-decls'),
		(TEXTNS,'user-index'),
		(TEXTNS,'variable-decls'),
	),
	(STYLENS,'header-style') : (
		(STYLENS,'header-footer-properties'),
	),
	(STYLENS,'list-level-properties') : (
	),
	(STYLENS,'map') : (
	),
	(STYLENS,'master-page') : (
		(DR3DNS,'scene'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(OFFICENS,'forms'),
		(PRESENTATIONNS,'notes'),
		(STYLENS,'footer'),
		(STYLENS,'footer-left'),
		(STYLENS,'header'),
		(STYLENS,'header-left'),
		(STYLENS,'style'),
	),
	(STYLENS,'page-layout') : (
		(STYLENS,'footer-style'),
		(STYLENS,'header-style'),
		(STYLENS,'page-layout-properties'),
	),
	(STYLENS,'page-layout-properties') : (
		(STYLENS,'background-image'),
		(STYLENS,'columns'),
		(STYLENS,'footnote-sep'),
	),
# allowed_children
	(STYLENS,'paragraph-properties') : (
		(STYLENS,'background-image'),
		(STYLENS,'drop-cap'),
		(STYLENS,'tab-stops'),
	),
	(STYLENS,'presentation-page-layout') : (
		(PRESENTATIONNS,'placeholder'),
	),
	(STYLENS,'region-center') : (
		(TEXTNS,'p'),
	),
	(STYLENS,'region-left') : (
		(TEXTNS,'p'),
	),
	(STYLENS,'region-right') : (
		(TEXTNS,'p'),
	),
	(STYLENS,'ruby-properties') : (
	),
	(STYLENS,'section-properties') : (
		(STYLENS,'background-image'),
		(STYLENS,'columns'),
		(TEXTNS,'notes-configuration'),
	),
	(STYLENS,'style') : (
		(STYLENS,'chart-properties'),
		(STYLENS,'drawing-page-properties'),
		(STYLENS,'graphic-properties'),
		(STYLENS,'map'),
		(STYLENS,'paragraph-properties'),
		(STYLENS,'ruby-properties'),
		(STYLENS,'section-properties'),
		(STYLENS,'table-cell-properties'),
		(STYLENS,'table-column-properties'),
		(STYLENS,'table-properties'),
		(STYLENS,'table-row-properties'),
		(STYLENS,'text-properties'),
	),
	(STYLENS,'tab-stop') : (
	),
	(STYLENS,'tab-stops') : (
		(STYLENS,'tab-stop'),
	),
# allowed_children
	(STYLENS,'table-cell-properties') : (
		(STYLENS,'background-image'),
	),
	(STYLENS,'table-column-properties') : (
	),
	(STYLENS,'table-properties') : (
		(STYLENS,'background-image'),
	),
	(STYLENS,'table-row-properties') : (
		(STYLENS,'background-image'),
	),
	(STYLENS,'text-properties') : (
	),
	(SVGNS,'definition-src') : (
	),
	(SVGNS,'desc') : (
	),
	(SVGNS,'font-face-format') : (
	),
	(SVGNS,'font-face-name') : (
	),
	(SVGNS,'font-face-src') : (
		(SVGNS,'font-face-name'),
		(SVGNS,'font-face-uri'),
	),
	(SVGNS,'font-face-uri') : (
		(SVGNS,'font-face-format'),
	),
	(SVGNS,'linearGradient') : (
		(SVGNS,'stop'),
	),
	(SVGNS,'radialGradient') : (
		(SVGNS,'stop'),
	),
	(SVGNS,'stop') : (
	),
	(SVGNS,'title') : (
	),
	(TABLENS,'body') : (
	),
	(TABLENS,'calculation-settings') : (
		(TABLENS,'iteration'),
		(TABLENS,'null-date'),
	),
# allowed_children
	(TABLENS,'cell-address') : (
	),
	(TABLENS,'cell-content-change') : (
		(OFFICENS,'change-info'),
		(TABLENS,'cell-address'),
		(TABLENS,'deletions'),
		(TABLENS,'dependencies'),
		(TABLENS,'previous'),
	),
	(TABLENS,'cell-content-deletion') : (
		(TABLENS,'cell-address'),
		(TABLENS,'change-track-table-cell'),
	),
	(TABLENS,'cell-range-source') : (
	),
	(TABLENS,'change-deletion') : (
	),
	(TABLENS,'change-track-table-cell') : (
		(TEXTNS,'p'),
	),
	(TABLENS,'consolidation') : (
	),
	(TABLENS,'content-validation') : (
		(OFFICENS,'event-listeners'),
		(TABLENS,'error-macro'),
		(TABLENS,'error-message'),
		(TABLENS,'help-message'),
	),
# allowed_children
	(TABLENS,'content-validations') : (
		(TABLENS,'content-validation'),
	),
	(TABLENS,'covered-table-cell') : (
		(DR3DNS,'scene'),
		(DRAWNS,'a'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(OFFICENS,'annotation'),
		(TABLENS,'cell-range-source'),
		(TABLENS,'detective'),
		(TABLENS,'table'),
		(TEXTNS,'alphabetical-index'),
		(TEXTNS,'bibliography'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'h'),
		(TEXTNS,'illustration-index'),
		(TEXTNS,'list'),
		(TEXTNS,'numbered-paragraph'),
		(TEXTNS,'object-index'),
		(TEXTNS,'p'),
		(TEXTNS,'section'),
		(TEXTNS,'soft-page-break'),
		(TEXTNS,'table-index'),
		(TEXTNS,'table-of-content'),
		(TEXTNS,'user-index'),
	),
# allowed_children
	(TABLENS,'cut-offs') : (
		(TABLENS,'insertion-cut-off'),
		(TABLENS,'movement-cut-off'),
	),
	(TABLENS,'data-pilot-display-info') : (
	),
	(TABLENS,'data-pilot-field') : (
		(TABLENS,'data-pilot-field-reference'),
		(TABLENS,'data-pilot-groups'),
		(TABLENS,'data-pilot-level'),
	),
	(TABLENS,'data-pilot-field-reference') : (
	),
	(TABLENS,'data-pilot-group') : (
		(TABLENS,'data-pilot-group-member'),
	),
	(TABLENS,'data-pilot-group-member') : (
	),
	(TABLENS,'data-pilot-groups') : (
		(TABLENS,'data-pilot-group'),
	),
	(TABLENS,'data-pilot-layout-info') : (
	),
	(TABLENS,'data-pilot-level') : (
		(TABLENS,'data-pilot-display-info'),
		(TABLENS,'data-pilot-layout-info'),
		(TABLENS,'data-pilot-members'),
		(TABLENS,'data-pilot-sort-info'),
		(TABLENS,'data-pilot-subtotals'),
	),
	(TABLENS,'data-pilot-member') : (
	),
	(TABLENS,'data-pilot-members') : (
		(TABLENS,'data-pilot-member'),
	),
	(TABLENS,'data-pilot-sort-info') : (
	),
	(TABLENS,'data-pilot-subtotal') : (
	),
	(TABLENS,'data-pilot-subtotals') : (
		(TABLENS,'data-pilot-subtotal'),
	),
# allowed_children
	(TABLENS,'data-pilot-table') : (
		(TABLENS,'data-pilot-field'),
		(TABLENS,'database-source-query'),
		(TABLENS,'database-source-sql'),
		(TABLENS,'database-source-table'),
		(TABLENS,'source-cell-range'),
		(TABLENS,'source-service'),
	),
	(TABLENS,'data-pilot-tables') : (
		(TABLENS,'data-pilot-table'),
	),
	(TABLENS,'database-range') : (
		(TABLENS,'database-source-query'),
		(TABLENS,'database-source-sql'),
		(TABLENS,'database-source-table'),
		(TABLENS,'filter'),
		(TABLENS,'sort'),
		(TABLENS,'subtotal-rules'),
	),
	(TABLENS,'database-ranges') : (
		(TABLENS,'database-range'),
	),
	(TABLENS,'database-source-query') : (
	),
	(TABLENS,'database-source-sql') : (
	),
	(TABLENS,'database-source-table') : (
	),
# allowed_children
	(TABLENS,'dde-link') : (
		(OFFICENS,'dde-source'),
		(TABLENS,'table'),
	),
	(TABLENS,'dde-links') : (
		(TABLENS,'dde-link'),
	),
	(TABLENS,'deletion') : (
		(OFFICENS,'change-info'),
		(TABLENS,'cut-offs'),
		(TABLENS,'deletions'),
		(TABLENS,'dependencies'),
	),
	(TABLENS,'deletions') : (
		(TABLENS,'cell-content-deletion'),
		(TABLENS,'change-deletion'),
	),
	(TABLENS,'dependencies') : (
		(TABLENS,'dependency'),
	),
	(TABLENS,'dependency') : (
	),
	(TABLENS,'detective') : (
		(TABLENS,'highlighted-range'),
		(TABLENS,'operation'),
	),
# allowed_children
	(TABLENS,'error-macro') : (
	),
	(TABLENS,'error-message') : (
		(TEXTNS,'p'),
	),
	(TABLENS,'even-columns') : (
	),
	(TABLENS,'even-rows') : (
	),
	(TABLENS,'filter') : (
		(TABLENS,'filter-and'),
		(TABLENS,'filter-condition'),
		(TABLENS,'filter-or'),
	),
	(TABLENS,'filter-and') : (
		(TABLENS,'filter-condition'),
		(TABLENS,'filter-or'),
	),
	(TABLENS,'filter-condition') : (
	),
	(TABLENS,'filter-or') : (
		(TABLENS,'filter-and'),
		(TABLENS,'filter-condition'),
	),
# allowed_children
	(TABLENS,'first-column') : (
	),
	(TABLENS,'first-row') : (
	),
	(TABLENS,'help-message') : (
		(TEXTNS,'p'),
	),
	(TABLENS,'highlighted-range') : (
	),
	(TABLENS,'insertion') : (
		(OFFICENS,'change-info'),
		(TABLENS,'deletions'),
		(TABLENS,'dependencies'),
	),
	(TABLENS,'insertion-cut-off') : (
	),
	(TABLENS,'iteration') : (
	),
	(TABLENS,'label-range') : (
	),
	(TABLENS,'label-ranges') : (
		(TABLENS,'label-range'),
	),
	(TABLENS,'last-column') : (
	),
	(TABLENS,'last-row') : (
	),
	(TABLENS,'movement') : (
		(OFFICENS,'change-info'),
		(TABLENS,'deletions'),
		(TABLENS,'dependencies'),
		(TABLENS,'source-range-address'),
		(TABLENS,'target-range-address'),
	),
	(TABLENS,'movement-cut-off') : (
	),
	(TABLENS,'named-expression') : (
	),
	(TABLENS,'named-expressions') : (
		(TABLENS,'named-expression'),
		(TABLENS,'named-range'),
	),
# allowed_children
	(TABLENS,'named-range') : (
	),
	(TABLENS,'null-date') : (
	),
	(TABLENS,'odd-columns') : (
	),
	(TABLENS,'odd-rows') : (
	),
	(TABLENS,'operation') : (
	),
	(TABLENS,'previous') : (
		(TABLENS,'change-track-table-cell'),
	),
	(TABLENS,'scenario') : (
	),
	(TABLENS,'shapes') : (
		(DR3DNS,'scene'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
	),
# allowed_children
	(TABLENS,'sort') : (
		(TABLENS,'sort-by'),
	),
	(TABLENS,'sort-by') : (
	),
	(TABLENS,'sort-groups') : (
	),
	(TABLENS,'source-cell-range') : (
		(TABLENS,'filter'),
	),
	(TABLENS,'source-range-address') : (
	),
	(TABLENS,'source-service') : (
	),
	(TABLENS,'subtotal-field') : (
	),
	(TABLENS,'subtotal-rule') : (
		(TABLENS,'subtotal-field'),
	),
	(TABLENS,'subtotal-rules') : (
		(TABLENS,'sort-groups'),
		(TABLENS,'subtotal-rule'),
	),
# allowed_children
	(TABLENS,'table') : (
		(OFFICENS,'dde-source'),
		(OFFICENS,'forms'),
		(TEXTNS,'soft-page-break'),
		(TABLENS,'scenario'),
		(TABLENS,'shapes'),
		(TABLENS,'table-column'),
		(TABLENS,'table-column-group'),
		(TABLENS,'table-columns'),
		(TABLENS,'table-header-columns'),
		(TABLENS,'table-header-rows'),
		(TABLENS,'table-row'),
		(TABLENS,'table-row-group'),
		(TABLENS,'table-rows'),
		(TABLENS,'table-source'),
	),
	(TABLENS,'table-cell') : (
		(DR3DNS,'scene'),
		(DRAWNS,'a'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(OFFICENS,'annotation'),
		(TABLENS,'cell-range-source'),
		(TABLENS,'detective'),
		(TABLENS,'table'),
		(TEXTNS,'alphabetical-index'),
		(TEXTNS,'bibliography'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'h'),
		(TEXTNS,'illustration-index'),
		(TEXTNS,'list'),
		(TEXTNS,'numbered-paragraph'),
		(TEXTNS,'object-index'),
		(TEXTNS,'p'),
		(TEXTNS,'section'),
		(TEXTNS,'soft-page-break'),
		(TEXTNS,'table-index'),
		(TEXTNS,'table-of-content'),
		(TEXTNS,'user-index'),
	),
# allowed_children
	(TABLENS,'table-column') : (
	),
	(TABLENS,'table-column-group') : (
		(TABLENS,'table-column'),
		(TABLENS,'table-column-group'),
		(TABLENS,'table-columns'),
		(TABLENS,'table-header-columns'),
	),
	(TABLENS,'table-columns') : (
		(TABLENS,'table-column'),
	),
	(TABLENS,'table-header-columns') : (
		(TABLENS,'table-column'),
	),
	(TABLENS,'table-header-rows') : (
		(TABLENS,'table-row'),
		(TEXTNS,'soft-page-break'),
	),
	(TABLENS,'table-row') : (
		(TABLENS,'covered-table-cell'),
		(TABLENS,'table-cell'),
	),
	(TABLENS,'table-row-group') : (
		(TABLENS,'table-header-rows'),
		(TABLENS,'table-row'),
		(TABLENS,'table-row-group'),
		(TABLENS,'table-rows'),
		(TEXTNS,'soft-page-break'),
	),
	(TABLENS,'table-rows') : (
		(TABLENS,'table-row'),
		(TEXTNS,'soft-page-break'),
	),
# allowed_children
	(TABLENS,'table-source') : (
	),
	(TABLENS,'table-template') : (
		(TABLENS,'body'),
		(TABLENS,'even-columns'),
		(TABLENS,'even-rows'),
		(TABLENS,'first-column'),
		(TABLENS,'first-row'),
		(TABLENS,'last-column'),
		(TABLENS,'last-row'),
		(TABLENS,'odd-columns'),
		(TABLENS,'odd-rows'),
	),
	(TABLENS,'target-range-address') : (
	),
	(TABLENS,'tracked-changes') : (
		(TABLENS,'cell-content-change'),
		(TABLENS,'deletion'),
		(TABLENS,'insertion'),
		(TABLENS,'movement'),
	),
# allowed_children
	(TEXTNS,'a') : (
		(DR3DNS,'scene'),
		(DRAWNS,'a'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(OFFICENS,'annotation'),
		(OFFICENS,'event-listeners'),
		(PRESENTATIONNS,'date-time'),
		(PRESENTATIONNS,'footer'),
		(PRESENTATIONNS,'header'),
		(TEXTNS,'a'),
		(TEXTNS,'alphabetical-index-mark'),
		(TEXTNS,'alphabetical-index-mark-end'),
		(TEXTNS,'alphabetical-index-mark-start'),
		(TEXTNS,'author-initials'),
		(TEXTNS,'author-name'),
		(TEXTNS,'bibliography-mark'),
		(TEXTNS,'bookmark'),
		(TEXTNS,'bookmark-end'),
		(TEXTNS,'bookmark-ref'),
		(TEXTNS,'bookmark-start'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'chapter'),
		(TEXTNS,'conditional-text'),
		(TEXTNS,'creation-date'),
		(TEXTNS,'creation-time'),
		(TEXTNS,'creator'),
		(TEXTNS,'database-display'),
		(TEXTNS,'database-name'),
		(TEXTNS,'database-next'),
		(TEXTNS,'database-row-number'),
		(TEXTNS,'database-row-select'),
		(TEXTNS,'date'),
		(TEXTNS,'dde-connection'),
		(TEXTNS,'description'),
		(TEXTNS,'editing-cycles'),
		(TEXTNS,'editing-duration'),
		(TEXTNS,'execute-macro'),
		(TEXTNS,'expression'),
		(TEXTNS,'file-name'),
		(TEXTNS,'hidden-paragraph'),
		(TEXTNS,'hidden-text'),
		(TEXTNS,'initial-creator'),
		(TEXTNS,'keywords'),
		(TEXTNS,'line-break'),
		(TEXTNS,'measure'),
		(TEXTNS,'modification-date'),
		(TEXTNS,'modification-time'),
		(TEXTNS,'note'),
		(TEXTNS,'note-ref'),
		(TEXTNS,'page-count'),
		(TEXTNS,'paragraph-count'),
		(TEXTNS,'word-count'),
		(TEXTNS,'character-count'),
		(TEXTNS,'table-count'),
		(TEXTNS,'image-count'),
		(TEXTNS,'object-count'),
		(TEXTNS,'page-continuation'),
		(TEXTNS,'page-number'),
		(TEXTNS,'page-variable-get'),
		(TEXTNS,'page-variable-set'),
		(TEXTNS,'placeholder'),
		(TEXTNS,'print-date'),
		(TEXTNS,'print-time'),
		(TEXTNS,'printed-by'),
		(TEXTNS,'reference-mark'),
		(TEXTNS,'reference-mark-end'),
		(TEXTNS,'reference-mark-start'),
		(TEXTNS,'reference-ref'),
		(TEXTNS,'ruby'),
		(TEXTNS,'s'),
		(TEXTNS,'script'),
		(TEXTNS,'sender-city'),
		(TEXTNS,'sender-company'),
		(TEXTNS,'sender-country'),
		(TEXTNS,'sender-email'),
		(TEXTNS,'sender-fax'),
		(TEXTNS,'sender-firstname'),
		(TEXTNS,'sender-initials'),
		(TEXTNS,'sender-lastname'),
		(TEXTNS,'sender-phone-private'),
		(TEXTNS,'sender-phone-work'),
		(TEXTNS,'sender-position'),
		(TEXTNS,'sender-postal-code'),
		(TEXTNS,'sender-state-or-province'),
		(TEXTNS,'sender-street'),
		(TEXTNS,'sender-title'),
		(TEXTNS,'sequence'),
		(TEXTNS,'sequence-ref'),
		(TEXTNS,'sheet-name'),
		(TEXTNS,'soft-page-break'),
		(TEXTNS,'span'),
		(TEXTNS,'subject'),
		(TEXTNS,'tab'),
		(TEXTNS,'table-formula'),
		(TEXTNS,'template-name'),
		(TEXTNS,'text-input'),
		(TEXTNS,'time'),
		(TEXTNS,'title'),
		(TEXTNS,'toc-mark'),
		(TEXTNS,'toc-mark-end'),
		(TEXTNS,'toc-mark-start'),
		(TEXTNS,'user-defined'),
		(TEXTNS,'user-field-get'),
		(TEXTNS,'user-field-input'),
		(TEXTNS,'user-index-mark'),
		(TEXTNS,'user-index-mark-end'),
		(TEXTNS,'user-index-mark-start'),
		(TEXTNS,'variable-get'),
		(TEXTNS,'variable-input'),
		(TEXTNS,'variable-set'),
	),
# allowed_children
	(TEXTNS,'alphabetical-index') : (
		(TEXTNS,'alphabetical-index-source'),
		(TEXTNS,'index-body'),
	),
	(TEXTNS,'alphabetical-index-auto-mark-file') : (
	),
	(TEXTNS,'alphabetical-index-entry-template') : (
		(TEXTNS,'index-entry-chapter'),
		(TEXTNS,'index-entry-page-number'),
		(TEXTNS,'index-entry-span'),
		(TEXTNS,'index-entry-tab-stop'),
		(TEXTNS,'index-entry-text'),
	),
	(TEXTNS,'alphabetical-index-mark') : (
	),
	(TEXTNS,'alphabetical-index-mark-end') : (
	),
	(TEXTNS,'alphabetical-index-mark-start') : (
	),
	(TEXTNS,'alphabetical-index-source') : (
		(TEXTNS,'alphabetical-index-entry-template'),
		(TEXTNS,'index-title-template'),
	),
	(TEXTNS,'author-initials') : (
	),
	(TEXTNS,'author-name') : (
	),
	(TEXTNS,'bibliography') : (
		(TEXTNS,'bibliography-source'),
		(TEXTNS,'index-body'),
	),
	(TEXTNS,'bibliography-configuration') : (
		(TEXTNS,'sort-key'),
	),
	(TEXTNS,'bibliography-entry-template') : (
		(TEXTNS,'index-entry-bibliography'),
		(TEXTNS,'index-entry-span'),
		(TEXTNS,'index-entry-tab-stop'),
	),
# allowed_children
	(TEXTNS,'bibliography-mark') : (
	),
	(TEXTNS,'bibliography-source') : (
		(TEXTNS,'bibliography-entry-template'),
		(TEXTNS,'index-title-template'),
	),
	(TEXTNS,'bookmark') : (
	),
	(TEXTNS,'bookmark-end') : (
	),
	(TEXTNS,'bookmark-ref') : (
	),
	(TEXTNS,'bookmark-start') : (
	),
	(TEXTNS,'change') : (
	),
	(TEXTNS,'change-end') : (
	),
	(TEXTNS,'change-start') : (
	),
	(TEXTNS,'changed-region') : (
		(TEXTNS,'deletion'),
		(TEXTNS,'format-change'),
		(TEXTNS,'insertion'),
	),
	(TEXTNS,'chapter') : (
	),
	(TEXTNS,'character-count') : (
	),
	(TEXTNS,'conditional-text') : (
	),
	(TEXTNS,'creation-date') : (
	),
	(TEXTNS,'creation-time') : (
	),
	(TEXTNS,'creator') : (
	),
	(TEXTNS,'database-display') : (
		(FORMNS,'connection-resource'),
	),
	(TEXTNS,'database-name') : (
		(FORMNS,'connection-resource'),
	),
	(TEXTNS,'database-next') : (
		(FORMNS,'connection-resource'),
	),
	(TEXTNS,'database-row-number') : (
		(FORMNS,'connection-resource'),
	),
	(TEXTNS,'database-row-select') : (
		(FORMNS,'connection-resource'),
	),
	(TEXTNS,'date') : (
	),
	(TEXTNS,'dde-connection') : (
	),
	(TEXTNS,'dde-connection-decl') : (
	),
	(TEXTNS,'dde-connection-decls') : (
		(TEXTNS,'dde-connection-decl'),
	),
# allowed_children
	(TEXTNS,'deletion') : (
		(DR3DNS,'scene'),
		(DRAWNS,'a'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(OFFICENS,'change-info'),
		(TABLENS,'table'),
		(TEXTNS,'alphabetical-index'),
		(TEXTNS,'bibliography'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'h'),
		(TEXTNS,'illustration-index'),
		(TEXTNS,'list'),
		(TEXTNS,'numbered-paragraph'),
		(TEXTNS,'object-index'),
		(TEXTNS,'p'),
		(TEXTNS,'section'),
		(TEXTNS,'soft-page-break'),
		(TEXTNS,'table-index'),
		(TEXTNS,'table-of-content'),
		(TEXTNS,'user-index'),
	),
	(TEXTNS,'description') : (
	),
	(TEXTNS,'editing-cycles') : (
	),
	(TEXTNS,'editing-duration') : (
	),
	(TEXTNS,'execute-macro') : (
		(OFFICENS,'event-listeners'),
	),
	(TEXTNS,'expression') : (
	),
	(TEXTNS,'file-name') : (
	),
	(TEXTNS,'format-change') : (
		(OFFICENS,'change-info'),
	),
# allowed_children
	(TEXTNS,'h') : (
		(DR3DNS,'scene'),
		(DRAWNS,'a'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(OFFICENS,'annotation'),
		(PRESENTATIONNS,'date-time'),
		(PRESENTATIONNS,'footer'),
		(PRESENTATIONNS,'header'),
		(TEXTNS,'a'),
		(TEXTNS,'alphabetical-index-mark'),
		(TEXTNS,'alphabetical-index-mark-end'),
		(TEXTNS,'alphabetical-index-mark-start'),
		(TEXTNS,'author-initials'),
		(TEXTNS,'author-name'),
		(TEXTNS,'bibliography-mark'),
		(TEXTNS,'bookmark'),
		(TEXTNS,'bookmark-end'),
		(TEXTNS,'bookmark-ref'),
		(TEXTNS,'bookmark-start'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'chapter'),
		(TEXTNS,'conditional-text'),
		(TEXTNS,'creation-date'),
		(TEXTNS,'creation-time'),
		(TEXTNS,'creator'),
		(TEXTNS,'database-display'),
		(TEXTNS,'database-name'),
		(TEXTNS,'database-next'),
		(TEXTNS,'database-row-number'),
		(TEXTNS,'database-row-select'),
		(TEXTNS,'date'),
		(TEXTNS,'dde-connection'),
		(TEXTNS,'description'),
		(TEXTNS,'editing-cycles'),
		(TEXTNS,'editing-duration'),
		(TEXTNS,'execute-macro'),
		(TEXTNS,'expression'),
		(TEXTNS,'file-name'),
		(TEXTNS,'hidden-paragraph'),
		(TEXTNS,'hidden-text'),
		(TEXTNS,'initial-creator'),
		(TEXTNS,'keywords'),
		(TEXTNS,'line-break'),
		(TEXTNS,'measure'),
		(TEXTNS,'modification-date'),
		(TEXTNS,'modification-time'),
		(TEXTNS,'note'),
		(TEXTNS,'note-ref'),
		(TEXTNS,'number'),
		(TEXTNS,'page-count'),
		(TEXTNS,'paragraph-count'),
		(TEXTNS,'word-count'),
		(TEXTNS,'character-count'),
		(TEXTNS,'table-count'),
		(TEXTNS,'image-count'),
		(TEXTNS,'object-count'),
		(TEXTNS,'page-continuation'),
		(TEXTNS,'page-number'),
		(TEXTNS,'page-variable-get'),
		(TEXTNS,'page-variable-set'),
		(TEXTNS,'placeholder'),
		(TEXTNS,'print-date'),
		(TEXTNS,'print-time'),
		(TEXTNS,'printed-by'),
		(TEXTNS,'reference-mark'),
		(TEXTNS,'reference-mark-end'),
		(TEXTNS,'reference-mark-start'),
		(TEXTNS,'reference-ref'),
		(TEXTNS,'ruby'),
		(TEXTNS,'s'),
		(TEXTNS,'script'),
		(TEXTNS,'sender-city'),
		(TEXTNS,'sender-company'),
		(TEXTNS,'sender-country'),
		(TEXTNS,'sender-email'),
		(TEXTNS,'sender-fax'),
		(TEXTNS,'sender-firstname'),
		(TEXTNS,'sender-initials'),
		(TEXTNS,'sender-lastname'),
		(TEXTNS,'sender-phone-private'),
		(TEXTNS,'sender-phone-work'),
		(TEXTNS,'sender-position'),
		(TEXTNS,'sender-postal-code'),
		(TEXTNS,'sender-state-or-province'),
		(TEXTNS,'sender-street'),
		(TEXTNS,'sender-title'),
		(TEXTNS,'sequence'),
		(TEXTNS,'sequence-ref'),
		(TEXTNS,'sheet-name'),
		(TEXTNS,'soft-page-break'),
		(TEXTNS,'span'),
		(TEXTNS,'subject'),
		(TEXTNS,'tab'),
		(TEXTNS,'table-formula'),
		(TEXTNS,'template-name'),
		(TEXTNS,'text-input'),
		(TEXTNS,'time'),
		(TEXTNS,'title'),
		(TEXTNS,'toc-mark'),
		(TEXTNS,'toc-mark-end'),
		(TEXTNS,'toc-mark-start'),
		(TEXTNS,'user-defined'),
		(TEXTNS,'user-field-get'),
		(TEXTNS,'user-field-input'),
		(TEXTNS,'user-index-mark'),
		(TEXTNS,'user-index-mark-end'),
		(TEXTNS,'user-index-mark-start'),
		(TEXTNS,'variable-get'),
		(TEXTNS,'variable-input'),
		(TEXTNS,'variable-set'),
	),
# allowed_children
	(TEXTNS,'hidden-paragraph') : (
	),
	(TEXTNS,'hidden-text') : (
	),
	(TEXTNS,'illustration-index') : (
		(TEXTNS,'illustration-index-source'),
		(TEXTNS,'index-body'),
	),
	(TEXTNS,'illustration-index-entry-template') : (
		(TEXTNS,'index-entry-page-number'),
		(TEXTNS,'index-entry-span'),
		(TEXTNS,'index-entry-tab-stop'),
		(TEXTNS,'index-entry-text'),
	),
	(TEXTNS,'illustration-index-source') : (
		(TEXTNS,'illustration-index-entry-template'),
		(TEXTNS,'index-title-template'),
	),
	(TEXTNS,'image-count') : (
	),
# allowed_children
	(TEXTNS,'index-body') : (
		(DR3DNS,'scene'),
		(DRAWNS,'a'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(TABLENS,'table'),
		(TEXTNS,'alphabetical-index'),
		(TEXTNS,'bibliography'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'h'),
		(TEXTNS,'illustration-index'),
		(TEXTNS,'index-title'),
		(TEXTNS,'list'),
		(TEXTNS,'numbered-paragraph'),
		(TEXTNS,'object-index'),
		(TEXTNS,'p'),
		(TEXTNS,'section'),
		(TEXTNS,'soft-page-break'),
		(TEXTNS,'table-index'),
		(TEXTNS,'table-of-content'),
		(TEXTNS,'user-index'),
	),
	(TEXTNS,'index-entry-bibliography') : (
	),
	(TEXTNS,'index-entry-chapter') : (
	),
	(TEXTNS,'index-entry-link-end') : (
	),
	(TEXTNS,'index-entry-link-start') : (
	),
	(TEXTNS,'index-entry-page-number') : (
	),
	(TEXTNS,'index-entry-span') : (
	),
	(TEXTNS,'index-entry-tab-stop') : (
	),
	(TEXTNS,'index-entry-text') : (
	),
	(TEXTNS,'index-source-style') : (
	),
	(TEXTNS,'index-source-styles') : (
		(TEXTNS,'index-source-style'),
	),
# allowed_children
	(TEXTNS,'index-title') : (
		(DR3DNS,'scene'),
		(DRAWNS,'a'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(TABLENS,'table'),
		(TEXTNS,'alphabetical-index'),
		(TEXTNS,'bibliography'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'h'),
		(TEXTNS,'illustration-index'),
		(TEXTNS,'index-title'),
		(TEXTNS,'list'),
		(TEXTNS,'numbered-paragraph'),
		(TEXTNS,'object-index'),
		(TEXTNS,'p'),
		(TEXTNS,'section'),
		(TEXTNS,'soft-page-break'),
		(TEXTNS,'table-index'),
		(TEXTNS,'table-of-content'),
		(TEXTNS,'user-index'),
	),
	(TEXTNS,'index-title-template') : (
	),
	(TEXTNS,'initial-creator') : (
	),
	(TEXTNS,'insertion') : (
		(OFFICENS,'change-info'),
	),
	(TEXTNS,'keywords') : (
	),
	(TEXTNS,'line-break') : (
	),
	(TEXTNS,'linenumbering-configuration') : (
		(TEXTNS,'linenumbering-separator'),
	),
	(TEXTNS,'linenumbering-separator') : (
	),
	(TEXTNS,'list') : (
		(TEXTNS,'list-header'),
		(TEXTNS,'list-item'),
	),
	(TEXTNS,'list-header') : (
		(TEXTNS,'h'),
		(TEXTNS,'list'),
		(TEXTNS,'number'),
		(TEXTNS,'p'),
		(TEXTNS,'soft-page-break'),
	),
	(TEXTNS,'list-item') : (
		(TEXTNS,'h'),
		(TEXTNS,'list'),
		(TEXTNS,'number'),
		(TEXTNS,'p'),
		(TEXTNS,'soft-page-break'),
	),
	(TEXTNS,'list-level-style-bullet') : (
		(STYLENS,'list-level-properties'),
		(STYLENS,'text-properties'),
	),
	(TEXTNS,'list-level-style-image') : (
		(OFFICENS,'binary-data'),
		(STYLENS,'list-level-properties'),
	),
	(TEXTNS,'list-level-style-number') : (
		(STYLENS,'list-level-properties'),
		(STYLENS,'text-properties'),
	),
	(TEXTNS,'list-style') : (
		(TEXTNS,'list-level-style-bullet'),
		(TEXTNS,'list-level-style-image'),
		(TEXTNS,'list-level-style-number'),
	),
	(TEXTNS,'measure') : (
	),
	(TEXTNS,'modification-date') : (
	),
	(TEXTNS,'modification-time') : (
	),
	(TEXTNS,'note') : (
		(TEXTNS,'note-body'),
		(TEXTNS,'note-citation'),
	),
# allowed_children
	(TEXTNS,'note-body') : (
		(DR3DNS,'scene'),
		(DRAWNS,'a'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(TABLENS,'table'),
		(TEXTNS,'alphabetical-index'),
		(TEXTNS,'bibliography'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'h'),
		(TEXTNS,'illustration-index'),
		(TEXTNS,'list'),
		(TEXTNS,'numbered-paragraph'),
		(TEXTNS,'object-index'),
		(TEXTNS,'p'),
		(TEXTNS,'section'),
		(TEXTNS,'soft-page-break'),
		(TEXTNS,'table-index'),
		(TEXTNS,'table-of-content'),
		(TEXTNS,'user-index'),
	),
	(TEXTNS,'note-citation') : (
	),
	(TEXTNS,'note-continuation-notice-backward') : (
	),
	(TEXTNS,'note-continuation-notice-forward') : (
	),
	(TEXTNS,'note-ref') : (
	),
	(TEXTNS,'notes-configuration') : (
		(TEXTNS,'note-continuation-notice-backward'),
		(TEXTNS,'note-continuation-notice-forward'),
	),
	(TEXTNS,'number') : (
	),
	(TEXTNS,'numbered-paragraph') : (
		(TEXTNS,'h'),
		(TEXTNS,'number'),
		(TEXTNS,'p'),
	),
	(TEXTNS,'object-count') : (
	),
	(TEXTNS,'object-index') : (
		(TEXTNS,'index-body'),
		(TEXTNS,'object-index-source'),
	),
	(TEXTNS,'object-index-entry-template') : (
		(TEXTNS,'index-entry-page-number'),
		(TEXTNS,'index-entry-span'),
		(TEXTNS,'index-entry-tab-stop'),
		(TEXTNS,'index-entry-text'),
	),
	(TEXTNS,'object-index-source') : (
		(TEXTNS,'index-title-template'),
		(TEXTNS,'object-index-entry-template'),
	),
	(TEXTNS,'outline-level-style') : (
		(STYLENS,'list-level-properties'),
		(STYLENS,'text-properties'),
	),
	(TEXTNS,'outline-style') : (
		(TEXTNS,'outline-level-style'),
	),
# allowed_children
	(TEXTNS,'p') : (
		(DR3DNS,'scene'),
		(DRAWNS,'a'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(OFFICENS,'annotation'),
		(PRESENTATIONNS,'date-time'),
		(PRESENTATIONNS,'footer'),
		(PRESENTATIONNS,'header'),
		(TEXTNS,'a'),
		(TEXTNS,'alphabetical-index-mark'),
		(TEXTNS,'alphabetical-index-mark-end'),
		(TEXTNS,'alphabetical-index-mark-start'),
		(TEXTNS,'author-initials'),
		(TEXTNS,'author-name'),
		(TEXTNS,'bibliography-mark'),
		(TEXTNS,'bookmark'),
		(TEXTNS,'bookmark-end'),
		(TEXTNS,'bookmark-ref'),
		(TEXTNS,'bookmark-start'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'chapter'),
		(TEXTNS,'character-count'),
		(TEXTNS,'conditional-text'),
		(TEXTNS,'creation-date'),
		(TEXTNS,'creation-time'),
		(TEXTNS,'creator'),
		(TEXTNS,'database-display'),
		(TEXTNS,'database-name'),
		(TEXTNS,'database-next'),
		(TEXTNS,'database-row-number'),
		(TEXTNS,'database-row-select'),
		(TEXTNS,'date'),
		(TEXTNS,'dde-connection'),
		(TEXTNS,'description'),
		(TEXTNS,'editing-cycles'),
		(TEXTNS,'editing-duration'),
		(TEXTNS,'execute-macro'),
		(TEXTNS,'expression'),
		(TEXTNS,'file-name'),
		(TEXTNS,'hidden-paragraph'),
		(TEXTNS,'hidden-text'),
		(TEXTNS,'image-count'),
		(TEXTNS,'initial-creator'),
		(TEXTNS,'keywords'),
		(TEXTNS,'line-break'),
		(TEXTNS,'measure'),
		(TEXTNS,'modification-date'),
		(TEXTNS,'modification-time'),
		(TEXTNS,'note'),
		(TEXTNS,'note-ref'),
		(TEXTNS,'object-count'),
		(TEXTNS,'page-continuation'),
		(TEXTNS,'page-count'),
		(TEXTNS,'page-number'),
		(TEXTNS,'page-variable-get'),
		(TEXTNS,'page-variable-set'),
		(TEXTNS,'paragraph-count'),
		(TEXTNS,'placeholder'),
		(TEXTNS,'print-date'),
		(TEXTNS,'printed-by'),
		(TEXTNS,'print-time'),
		(TEXTNS,'reference-mark'),
		(TEXTNS,'reference-mark-end'),
		(TEXTNS,'reference-mark-start'),
		(TEXTNS,'reference-ref'),
		(TEXTNS,'ruby'),
		(TEXTNS,'s'),
		(TEXTNS,'script'),
		(TEXTNS,'sender-city'),
		(TEXTNS,'sender-company'),
		(TEXTNS,'sender-country'),
		(TEXTNS,'sender-email'),
		(TEXTNS,'sender-fax'),
		(TEXTNS,'sender-firstname'),
		(TEXTNS,'sender-initials'),
		(TEXTNS,'sender-lastname'),
		(TEXTNS,'sender-phone-private'),
		(TEXTNS,'sender-phone-work'),
		(TEXTNS,'sender-position'),
		(TEXTNS,'sender-postal-code'),
		(TEXTNS,'sender-state-or-province'),
		(TEXTNS,'sender-street'),
		(TEXTNS,'sender-title'),
		(TEXTNS,'sequence'),
		(TEXTNS,'sequence-ref'),
		(TEXTNS,'sheet-name'),
		(TEXTNS,'soft-page-break'),
		(TEXTNS,'span'),
		(TEXTNS,'subject'),
		(TEXTNS,'tab'),
		(TEXTNS,'table-count'),
		(TEXTNS,'table-formula'),
		(TEXTNS,'template-name'),
		(TEXTNS,'text-input'),
		(TEXTNS,'time'),
		(TEXTNS,'title'),
		(TEXTNS,'toc-mark'),
		(TEXTNS,'toc-mark-end'),
		(TEXTNS,'toc-mark-start'),
		(TEXTNS,'user-defined'),
		(TEXTNS,'user-field-get'),
		(TEXTNS,'user-field-input'),
		(TEXTNS,'user-index-mark'),
		(TEXTNS,'user-index-mark-end'),
		(TEXTNS,'user-index-mark-start'),
		(TEXTNS,'variable-get'),
		(TEXTNS,'variable-input'),
		(TEXTNS,'variable-set'),
		(TEXTNS,'word-count'),
	),
	(TEXTNS,'page') : (
	),
	(TEXTNS,'page-count') : (
	),
	(TEXTNS,'page-continuation') : (
	),
	(TEXTNS,'page-number') : (
	),
	(TEXTNS,'page-sequence') : (
		(TEXTNS,'page'),
	),
	(TEXTNS,'page-variable-get') : (
	),
	(TEXTNS,'page-variable-set') : (
	),
	(TEXTNS,'paragraph-count') : (
	),
	(TEXTNS,'placeholder') : (
	),
	(TEXTNS,'print-date') : (
	),
	(TEXTNS,'print-time') : (
	),
	(TEXTNS,'printed-by') : (
	),
	(TEXTNS,'reference-mark') : (
	),
	(TEXTNS,'reference-mark-end') : (
	),
# allowed_children
	(TEXTNS,'reference-mark-start') : (
	),
	(TEXTNS,'reference-ref') : (
	),
	(TEXTNS,'ruby') : (
		(TEXTNS,'ruby-base'),
		(TEXTNS,'ruby-text'),
	),
	(TEXTNS,'ruby-base') : (
		(DR3DNS,'scene'),
		(DRAWNS,'a'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(OFFICENS,'annotation'),
		(PRESENTATIONNS,'date-time'),
		(PRESENTATIONNS,'footer'),
		(PRESENTATIONNS,'header'),
		(TEXTNS,'a'),
		(TEXTNS,'alphabetical-index-mark'),
		(TEXTNS,'alphabetical-index-mark-end'),
		(TEXTNS,'alphabetical-index-mark-start'),
		(TEXTNS,'author-initials'),
		(TEXTNS,'author-name'),
		(TEXTNS,'bibliography-mark'),
		(TEXTNS,'bookmark'),
		(TEXTNS,'bookmark-end'),
		(TEXTNS,'bookmark-ref'),
		(TEXTNS,'bookmark-start'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'chapter'),
		(TEXTNS,'conditional-text'),
		(TEXTNS,'creation-date'),
		(TEXTNS,'creation-time'),
		(TEXTNS,'creator'),
		(TEXTNS,'database-display'),
		(TEXTNS,'database-name'),
		(TEXTNS,'database-next'),
		(TEXTNS,'database-row-number'),
		(TEXTNS,'database-row-select'),
		(TEXTNS,'date'),
		(TEXTNS,'dde-connection'),
		(TEXTNS,'description'),
		(TEXTNS,'editing-cycles'),
		(TEXTNS,'editing-duration'),
		(TEXTNS,'execute-macro'),
		(TEXTNS,'expression'),
		(TEXTNS,'file-name'),
		(TEXTNS,'hidden-paragraph'),
		(TEXTNS,'hidden-text'),
		(TEXTNS,'initial-creator'),
		(TEXTNS,'keywords'),
		(TEXTNS,'line-break'),
		(TEXTNS,'measure'),
		(TEXTNS,'modification-date'),
		(TEXTNS,'modification-time'),
		(TEXTNS,'note'),
		(TEXTNS,'note-ref'),
		(TEXTNS,'page-count'),
		(TEXTNS,'paragraph-count'),
		(TEXTNS,'word-count'),
		(TEXTNS,'character-count'),
		(TEXTNS,'table-count'),
		(TEXTNS,'image-count'),
		(TEXTNS,'object-count'),
		(TEXTNS,'page-continuation'),
		(TEXTNS,'page-number'),
		(TEXTNS,'page-variable-get'),
		(TEXTNS,'page-variable-set'),
		(TEXTNS,'placeholder'),
		(TEXTNS,'print-date'),
		(TEXTNS,'print-time'),
		(TEXTNS,'printed-by'),
		(TEXTNS,'reference-mark'),
		(TEXTNS,'reference-mark-end'),
		(TEXTNS,'reference-mark-start'),
		(TEXTNS,'reference-ref'),
		(TEXTNS,'ruby'),
		(TEXTNS,'s'),
		(TEXTNS,'script'),
		(TEXTNS,'sender-city'),
		(TEXTNS,'sender-company'),
		(TEXTNS,'sender-country'),
		(TEXTNS,'sender-email'),
		(TEXTNS,'sender-fax'),
		(TEXTNS,'sender-firstname'),
		(TEXTNS,'sender-initials'),
		(TEXTNS,'sender-lastname'),
		(TEXTNS,'sender-phone-private'),
		(TEXTNS,'sender-phone-work'),
		(TEXTNS,'sender-position'),
		(TEXTNS,'sender-postal-code'),
		(TEXTNS,'sender-state-or-province'),
		(TEXTNS,'sender-street'),
		(TEXTNS,'sender-title'),
		(TEXTNS,'sequence'),
		(TEXTNS,'sequence-ref'),
		(TEXTNS,'sheet-name'),
		(TEXTNS,'soft-page-break'),
		(TEXTNS,'span'),
		(TEXTNS,'subject'),
		(TEXTNS,'tab'),
		(TEXTNS,'table-formula'),
		(TEXTNS,'template-name'),
		(TEXTNS,'text-input'),
		(TEXTNS,'time'),
		(TEXTNS,'title'),
		(TEXTNS,'toc-mark'),
		(TEXTNS,'toc-mark-end'),
		(TEXTNS,'toc-mark-start'),
		(TEXTNS,'user-defined'),
		(TEXTNS,'user-field-get'),
		(TEXTNS,'user-field-input'),
		(TEXTNS,'user-index-mark'),
		(TEXTNS,'user-index-mark-end'),
		(TEXTNS,'user-index-mark-start'),
		(TEXTNS,'variable-get'),
		(TEXTNS,'variable-input'),
		(TEXTNS,'variable-set'),
	),
# allowed_children
	(TEXTNS,'ruby-text') : (
	),
	(TEXTNS,'s') : (
	),
	(TEXTNS,'script') : (
	),
	(TEXTNS,'section') : (
		(DR3DNS,'scene'),
		(DRAWNS,'a'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(OFFICENS,'dde-source'),
		(TABLENS,'table'),
		(TEXTNS,'alphabetical-index'),
		(TEXTNS,'bibliography'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'h'),
		(TEXTNS,'illustration-index'),
		(TEXTNS,'list'),
		(TEXTNS,'numbered-paragraph'),
		(TEXTNS,'object-index'),
		(TEXTNS,'p'),
		(TEXTNS,'section'),
		(TEXTNS,'section-source'),
		(TEXTNS,'soft-page-break'),
		(TEXTNS,'table-index'),
		(TEXTNS,'table-of-content'),
		(TEXTNS,'user-index'),
	),
	(TEXTNS,'section-source') : (
	),
	(TEXTNS,'sender-city') : (
	),
	(TEXTNS,'sender-company') : (
	),
	(TEXTNS,'sender-country') : (
	),
# allowed_children
	(TEXTNS,'sender-email') : (
	),
	(TEXTNS,'sender-fax') : (
	),
	(TEXTNS,'sender-firstname') : (
	),
	(TEXTNS,'sender-initials') : (
	),
	(TEXTNS,'sender-lastname') : (
	),
	(TEXTNS,'sender-phone-private') : (
	),
	(TEXTNS,'sender-phone-work') : (
	),
	(TEXTNS,'sender-position') : (
	),
	(TEXTNS,'sender-postal-code') : (
	),
	(TEXTNS,'sender-state-or-province') : (
	),
	(TEXTNS,'sender-street') : (
	),
	(TEXTNS,'sender-title') : (
	),
	(TEXTNS,'sequence') : (
	),
	(TEXTNS,'sequence-decl') : (
	),
	(TEXTNS,'sequence-decls') : (
		(TEXTNS,'sequence-decl'),
	),
	(TEXTNS,'sequence-ref') : (
	),
	(TEXTNS,'sheet-name') : (
	),
	(TEXTNS,'soft-page-break') : (
	),
	(TEXTNS,'sort-key') : (
	),
# allowed_children
	(TEXTNS,'span') : (
		(DR3DNS,'scene'),
		(DRAWNS,'a'),
		(DRAWNS,'caption'),
		(DRAWNS,'circle'),
		(DRAWNS,'connector'),
		(DRAWNS,'control'),
		(DRAWNS,'custom-shape'),
		(DRAWNS,'ellipse'),
		(DRAWNS,'frame'),
		(DRAWNS,'g'),
		(DRAWNS,'line'),
		(DRAWNS,'measure'),
		(DRAWNS,'page-thumbnail'),
		(DRAWNS,'path'),
		(DRAWNS,'polygon'),
		(DRAWNS,'polyline'),
		(DRAWNS,'rect'),
		(DRAWNS,'regular-polygon'),
		(OFFICENS,'annotation'),
		(PRESENTATIONNS,'date-time'),
		(PRESENTATIONNS,'footer'),
		(PRESENTATIONNS,'header'),
		(TEXTNS,'a'),
		(TEXTNS,'alphabetical-index-mark'),
		(TEXTNS,'alphabetical-index-mark-end'),
		(TEXTNS,'alphabetical-index-mark-start'),
		(TEXTNS,'author-initials'),
		(TEXTNS,'author-name'),
		(TEXTNS,'bibliography-mark'),
		(TEXTNS,'bookmark'),
		(TEXTNS,'bookmark-end'),
		(TEXTNS,'bookmark-ref'),
		(TEXTNS,'bookmark-start'),
		(TEXTNS,'change'),
		(TEXTNS,'change-end'),
		(TEXTNS,'change-start'),
		(TEXTNS,'chapter'),
		(TEXTNS,'conditional-text'),
		(TEXTNS,'creation-date'),
		(TEXTNS,'creation-time'),
		(TEXTNS,'creator'),
		(TEXTNS,'database-display'),
		(TEXTNS,'database-name'),
		(TEXTNS,'database-next'),
		(TEXTNS,'database-row-number'),
		(TEXTNS,'database-row-select'),
		(TEXTNS,'date'),
		(TEXTNS,'dde-connection'),
		(TEXTNS,'description'),
		(TEXTNS,'editing-cycles'),
		(TEXTNS,'editing-duration'),
		(TEXTNS,'execute-macro'),
		(TEXTNS,'expression'),
		(TEXTNS,'file-name'),
		(TEXTNS,'hidden-paragraph'),
		(TEXTNS,'hidden-text'),
		(TEXTNS,'initial-creator'),
		(TEXTNS,'keywords'),
		(TEXTNS,'line-break'),
		(TEXTNS,'measure'),
		(TEXTNS,'modification-date'),
		(TEXTNS,'modification-time'),
		(TEXTNS,'note'),
		(TEXTNS,'note-ref'),
		(TEXTNS,'page-count'),
		(TEXTNS,'paragraph-count'),
		(TEXTNS,'word-count'),
		(TEXTNS,'character-count'),
		(TEXTNS,'table-count'),
		(TEXTNS,'image-count'),
		(TEXTNS,'object-count'),
		(TEXTNS,'page-continuation'),
		(TEXTNS,'page-number'),
		(TEXTNS,'page-variable-get'),
		(TEXTNS,'page-variable-set'),
		(TEXTNS,'placeholder'),
		(TEXTNS,'print-date'),
		(TEXTNS,'print-time'),
		(TEXTNS,'printed-by'),
		(TEXTNS,'reference-mark'),
		(TEXTNS,'reference-mark-end'),
		(TEXTNS,'reference-mark-start'),
		(TEXTNS,'reference-ref'),
		(TEXTNS,'ruby'),
		(TEXTNS,'s'),
		(TEXTNS,'script'),
		(TEXTNS,'sender-city'),
		(TEXTNS,'sender-company'),
		(TEXTNS,'sender-country'),
		(TEXTNS,'sender-email'),
		(TEXTNS,'sender-fax'),
		(TEXTNS,'sender-firstname'),
		(TEXTNS,'sender-initials'),
		(TEXTNS,'sender-lastname'),
		(TEXTNS,'sender-phone-private'),
		(TEXTNS,'sender-phone-work'),
		(TEXTNS,'sender-position'),
		(TEXTNS,'sender-postal-code'),
		(TEXTNS,'sender-state-or-province'),
		(TEXTNS,'sender-street'),
		(TEXTNS,'sender-title'),
		(TEXTNS,'sequence'),
		(TEXTNS,'sequence-ref'),
		(TEXTNS,'sheet-name'),
		(TEXTNS,'soft-page-break'),
		(TEXTNS,'span'),
		(TEXTNS,'subject'),
		(TEXTNS,'tab'),
		(TEXTNS,'table-formula'),
		(TEXTNS,'template-name'),
		(TEXTNS,'text-input'),
		(TEXTNS,'time'),
		(TEXTNS,'title'),
		(TEXTNS,'toc-mark'),
		(TEXTNS,'toc-mark-end'),
		(TEXTNS,'toc-mark-start'),
		(TEXTNS,'user-defined'),
		(TEXTNS,'user-field-get'),
		(TEXTNS,'user-field-input'),
		(TEXTNS,'user-index-mark'),
		(TEXTNS,'user-index-mark-end'),
		(TEXTNS,'user-index-mark-start'),
		(TEXTNS,'variable-get'),
		(TEXTNS,'variable-input'),
		(TEXTNS,'variable-set'),
	),
# allowed_children
	(TEXTNS,'subject') : (
	),
	(TEXTNS,'tab') : (
	),
	(TEXTNS,'table-count') : (
	),
	(TEXTNS,'table-formula') : (
	),
	(TEXTNS,'table-index') : (
		(TEXTNS,'index-body'),
		(TEXTNS,'table-index-source'),
	),
	(TEXTNS,'table-index-entry-template') : (
		(TEXTNS,'index-entry-page-number'),
		(TEXTNS,'index-entry-span'),
		(TEXTNS,'index-entry-tab-stop'),
		(TEXTNS,'index-entry-text'),
	),
	(TEXTNS,'table-index-source') : (
		(TEXTNS,'index-title-template'),
		(TEXTNS,'table-index-entry-template'),
	),
	(TEXTNS,'table-of-content') : (
		(TEXTNS,'index-body'),
		(TEXTNS,'table-of-content-source'),
	),
	(TEXTNS,'table-of-content-entry-template') : (
		(TEXTNS,'index-entry-chapter'),
		(TEXTNS,'index-entry-link-end'),
		(TEXTNS,'index-entry-link-start'),
		(TEXTNS,'index-entry-page-number'),
		(TEXTNS,'index-entry-span'),
		(TEXTNS,'index-entry-tab-stop'),
		(TEXTNS,'index-entry-text'),
	),
	(TEXTNS,'table-of-content-source') : (
		(TEXTNS,'index-source-styles'),
		(TEXTNS,'index-title-template'),
		(TEXTNS,'table-of-content-entry-template'),
	),
	(TEXTNS,'template-name') : (
	),
	(TEXTNS,'text-input') : (
	),
	(TEXTNS,'time') : (
	),
	(TEXTNS,'title') : (
	),
	(TEXTNS,'toc-mark') : (
	),
	(TEXTNS,'toc-mark-end') : (
	),
	(TEXTNS,'toc-mark-start') : (
	),
# allowed_children
	(TEXTNS,'tracked-changes') : (
		(TEXTNS,'changed-region'),
	),
	(TEXTNS,'user-defined') : (
	),
	(TEXTNS,'user-field-decl') : (
	),
	(TEXTNS,'user-field-decls') : (
		(TEXTNS,'user-field-decl'),
	),
	(TEXTNS,'user-field-get') : (
	),
	(TEXTNS,'user-field-input') : (
	),
	(TEXTNS,'user-index') : (
		(TEXTNS,'index-body'),
		(TEXTNS,'user-index-source'),
	),
	(TEXTNS,'user-index-entry-template') : (
		(TEXTNS,'index-entry-chapter'),
		(TEXTNS,'index-entry-page-number'),
		(TEXTNS,'index-entry-span'),
		(TEXTNS,'index-entry-tab-stop'),
		(TEXTNS,'index-entry-text'),
	),
# allowed_children
	(TEXTNS,'user-index-mark') : (
	),
	(TEXTNS,'user-index-mark-end') : (
	),
	(TEXTNS,'user-index-mark-start') : (
	),
	(TEXTNS,'user-index-source') : (
		(TEXTNS,'index-source-styles'),
		(TEXTNS,'index-title-template'),
		(TEXTNS,'user-index-entry-template'),
	),
	(TEXTNS,'variable-decl') : (
	),
	(TEXTNS,'variable-decls') : (
		(TEXTNS,'variable-decl'),
	),
	(TEXTNS,'variable-get') : (
	),
	(TEXTNS,'variable-input') : (
	),
	(TEXTNS,'variable-set') : (
	),
	(TEXTNS,'word-count') : (
	),
}

#
# List of elements that allows text nodes
#
allows_text = (
	(CONFIGNS,'config-item'),
	(DCNS,'creator'),
	(DCNS,'date'),
	(DCNS,'description'),
	(DCNS,'language'),
	(DCNS,'subject'),
	(DCNS,'title'),
# Completes Dublin Core start
#	(DCNS,'contributor'),
#	(DCNS,'coverage'),
#	(DCNS,'format'),
#	(DCNS,'identifier'),
#	(DCNS,'publisher'),
#	(DCNS,'relation'),
#	(DCNS,'rights'),
#	(DCNS,'source'),
#	(DCNS,'type'),
# Completes Dublin Core end
	(FORMNS,'item'),
	(FORMNS,'option'),
	(MATHNS,'math'),
	(METANS,'creation-date'),
	(METANS,'date-string'),
	(METANS,'editing-cycles'),
	(METANS,'editing-duration'),
# allows_text
	(METANS,'generator'),
	(METANS,'initial-creator'),
	(METANS,'keyword'),
	(METANS,'print-date'),
	(METANS,'printed-by'),
	(METANS,'user-defined'),
	(NUMBERNS,'currency-symbol'),
	(NUMBERNS,'embedded-text'),
	(NUMBERNS,'text'),
	(OFFICENS,'binary-data'),
	(OFFICENS,'script'),
	(PRESENTATIONNS,'date-time-decl'),
	(PRESENTATIONNS,'footer-decl'),
	(PRESENTATIONNS,'header-decl'),
	(SVGNS,'desc'),
	(SVGNS,'title'),
	(TEXTNS,'a'),
	(TEXTNS,'author-initials'),
	(TEXTNS,'author-name'),
	(TEXTNS,'bibliography-mark'),
	(TEXTNS,'bookmark-ref'),
	(TEXTNS,'chapter'),
	(TEXTNS,'character-count'),
	(TEXTNS,'conditional-text'),
	(TEXTNS,'creation-date'),
	(TEXTNS,'creation-time'),
	(TEXTNS,'creator'),
	(TEXTNS,'database-display'),
	(TEXTNS,'database-name'),
	(TEXTNS,'database-row-number'),
	(TEXTNS,'date'),
	(TEXTNS,'dde-connection'),
	(TEXTNS,'description'),
	(TEXTNS,'editing-cycles'),
	(TEXTNS,'editing-duration'),
	(TEXTNS,'execute-macro'),
	(TEXTNS,'expression'),
	(TEXTNS,'file-name'),
	(TEXTNS,'h'),
	(TEXTNS,'hidden-paragraph'),
	(TEXTNS,'hidden-text'),
	(TEXTNS,'image-count'),
# allowed_children
	(TEXTNS,'index-entry-span'),
	(TEXTNS,'index-title-template'),
	(TEXTNS,'initial-creator'),
	(TEXTNS,'keywords'),
	(TEXTNS,'linenumbering-separator'),
	(TEXTNS,'measure'),
	(TEXTNS,'modification-date'),
	(TEXTNS,'modification-time'),
	(TEXTNS,'note-citation'),
	(TEXTNS,'note-continuation-notice-backward'),
	(TEXTNS,'note-continuation-notice-forward'),
	(TEXTNS,'note-ref'),
	(TEXTNS,'number'),
	(TEXTNS,'object-count'),
	(TEXTNS,'p'),
	(TEXTNS,'page-continuation'),
	(TEXTNS,'page-count'),
	(TEXTNS,'page-number'),
	(TEXTNS,'page-variable-get'),
	(TEXTNS,'page-variable-set'),
	(TEXTNS,'paragraph-count'),
	(TEXTNS,'placeholder'),
	(TEXTNS,'print-date'),
	(TEXTNS,'print-time'),
	(TEXTNS,'printed-by'),
	(TEXTNS,'reference-ref'),
	(TEXTNS,'ruby-base'),
	(TEXTNS,'ruby-text'),
	(TEXTNS,'script'),
	(TEXTNS,'sender-city'),
	(TEXTNS,'sender-company'),
	(TEXTNS,'sender-country'),
	(TEXTNS,'sender-email'),
	(TEXTNS,'sender-fax'),
	(TEXTNS,'sender-firstname'),
	(TEXTNS,'sender-initials'),
	(TEXTNS,'sender-lastname'),
	(TEXTNS,'sender-phone-private'),
	(TEXTNS,'sender-phone-work'),
	(TEXTNS,'sender-position'),
	(TEXTNS,'sender-postal-code'),
	(TEXTNS,'sender-state-or-province'),
	(TEXTNS,'sender-street'),
	(TEXTNS,'sender-title'),
	(TEXTNS,'sequence'),
	(TEXTNS,'sequence-ref'),
	(TEXTNS,'sheet-name'),
# allowed_children
	(TEXTNS,'span'),
	(TEXTNS,'subject'),
	(TEXTNS,'table-count'),
	(TEXTNS,'table-formula'),
	(TEXTNS,'template-name'),
	(TEXTNS,'text-input'),
	(TEXTNS,'time'),
	(TEXTNS,'title'),
	(TEXTNS,'user-defined'),
	(TEXTNS,'user-field-get'),
	(TEXTNS,'user-field-input'),
	(TEXTNS,'variable-get'),
	(TEXTNS,'variable-input'),
	(TEXTNS,'variable-set'),
	(TEXTNS,'word-count'),
)

# Only the elements with at least one required attribute is listed

required_attributes = {
	(ANIMNS,'animate'): (
		(SMILNS,'attributeName'),
	),
	(ANIMNS,'animateColor'): (
		(SMILNS,'attributeName'),
	),
	(ANIMNS,'animateMotion'): (
		(SMILNS,'attributeName'),
	),
	(ANIMNS,'animateTransform'): (
		(SVGNS,'type'),
		(SMILNS,'attributeName'),
	),
	(ANIMNS,'command'): (
		(ANIMNS,'command'),
	),
	(ANIMNS,'param'): (
		(ANIMNS,'name'),
		(ANIMNS,'value'),
	),
	(ANIMNS,'set'): (
		(SMILNS,'attributeName'),
	),
# required_attributes
	(ANIMNS,'transitionFilter'): (
		(SMILNS,'type'),
	),
	(CHARTNS,'axis'): (
		(CHARTNS,'dimension'),
	),
	(CHARTNS,'chart'): (
		(CHARTNS,'class'),
	),
	(CHARTNS,'symbol-image'): (
		(XLINKNS,'href'),
	),
	(CONFIGNS,'config-item'): (
		(CONFIGNS,'type'),
		(CONFIGNS,'name'),
	),
	(CONFIGNS,'config-item-map-indexed'): (
		(CONFIGNS,'name'),
	),
	(CONFIGNS,'config-item-map-named'): (
		(CONFIGNS,'name'),
	),
	(CONFIGNS,'config-item-set'): (
		(CONFIGNS,'name'),
	),
# required_attributes
	(NUMBERNS,'boolean-style'): (
		(STYLENS,'name'),
	),
	(NUMBERNS,'currency-style'): (
		(STYLENS,'name'),
	),
	(NUMBERNS,'date-style'): (
		(STYLENS,'name'),
	),
	(NUMBERNS,'embedded-text'): (
		(NUMBERNS,'position'),
	),
	(NUMBERNS,'number-style'): (
		(STYLENS,'name'),
	),
	(NUMBERNS,'percentage-style'): (
		(STYLENS,'name'),
	),
	(NUMBERNS,'text-style'): (
		(STYLENS,'name'),
	),
	(NUMBERNS,'time-style'): (
		(STYLENS,'name'),
	),
	(DR3DNS,'extrude'): (
		(SVGNS,'d'),
		(SVGNS,'viewBox'),
	),
	(DR3DNS,'light'): (
		(DR3DNS,'direction'),
	),
	(DR3DNS,'rotate'): (
		(SVGNS,'viewBox'),
		(SVGNS,'d'),
	),
# required_attributes
	(DRAWNS,'a'): (
		(XLINKNS,'href'),
	),
	(DRAWNS,'area-circle'): (
		(SVGNS,'cy'),
		(SVGNS,'cx'),
		(SVGNS,'r'),
	),
	(DRAWNS,'area-polygon'): (
		(SVGNS,'height'),
		(SVGNS,'width'),
		(DRAWNS,'points'),
		(SVGNS,'y'),
		(SVGNS,'x'),
		(SVGNS,'viewBox'),
	),
	(DRAWNS,'area-rectangle'): (
		(SVGNS,'y'),
		(SVGNS,'x'),
		(SVGNS,'height'),
		(SVGNS,'width'),
	),
	(DRAWNS,'contour-path'): (
		(DRAWNS,'recreate-on-edit'),
		(SVGNS,'viewBox'),
		(SVGNS,'d'),
	),
	(DRAWNS,'contour-polygon'): (
		(DRAWNS,'points'),
		(DRAWNS,'recreate-on-edit'),
		(SVGNS,'viewBox'),
	),
	(DRAWNS,'control'): (
		(DRAWNS,'control'),
	),
	(DRAWNS,'fill-image'): (
		(XLINKNS,'href'),
		(DRAWNS,'name'),
	),
	(DRAWNS,'floating-frame'): (
		(XLINKNS,'href'),
	),
	(DRAWNS,'glue-point'): (
		(SVGNS,'y'),
		(SVGNS,'x'),
		(DRAWNS,'id'),
		(DRAWNS,'escape-direction'),
	),
# required_attributes
	(DRAWNS,'gradient'): (
		(DRAWNS,'style'),
	),
	(DRAWNS,'handle'): (
		(DRAWNS,'handle-position'),
	),
	(DRAWNS,'hatch'): (
		(DRAWNS,'style'),
		(DRAWNS,'name'),
	),
	(DRAWNS,'layer'): (
		(DRAWNS,'name'),
	),
	(DRAWNS,'line'): (
		(SVGNS,'y1'),
		(SVGNS,'x2'),
		(SVGNS,'x1'),
		(SVGNS,'y2'),
	),
	(DRAWNS,'marker'): (
		(SVGNS,'d'),
		(DRAWNS,'name'),
		(SVGNS,'viewBox'),
	),
	(DRAWNS,'measure'): (
		(SVGNS,'y1'),
		(SVGNS,'x2'),
		(SVGNS,'x1'),
		(SVGNS,'y2'),
	),
	(DRAWNS,'opacity'): (
		(DRAWNS,'style'),
	),
	(DRAWNS,'page'): (
		(DRAWNS,'master-page-name'),
	),
	(DRAWNS,'path'): (
		(SVGNS,'d'),
		(SVGNS,'viewBox'),
	),
	(DRAWNS,'plugin'): (
		(XLINKNS,'href'),
	),
	(DRAWNS,'polygon'): (
		(DRAWNS,'points'),
		(SVGNS,'viewBox'),
	),
# required_attributes
	(DRAWNS,'polyline'): (
		(DRAWNS,'points'),
		(SVGNS,'viewBox'),
	),
	(DRAWNS,'regular-polygon'): (
		(DRAWNS,'corners'),
	),
	(DRAWNS,'stroke-dash'): (
		(DRAWNS,'name'),
	),
	(FORMNS,'button'): (
		(FORMNS,'id'),
	),
	(FORMNS,'checkbox'): (
		(FORMNS,'id'),
	),
	(FORMNS,'combobox'): (
		(FORMNS,'id'),
	),
	(FORMNS,'connection-resource'): (
		(XLINKNS,'href'),
	),
	(FORMNS,'date'): (
		(FORMNS,'id'),
	),
	(FORMNS,'file'): (
		(FORMNS,'id'),
	),
	(FORMNS,'fixed-text'): (
		(FORMNS,'id'),
	),
	(FORMNS,'formatted-text'): (
		(FORMNS,'id'),
	),
	(FORMNS,'frame'): (
		(FORMNS,'id'),
	),
	(FORMNS,'generic-control'): (
		(FORMNS,'id'),
	),
	(FORMNS,'grid'): (
		(FORMNS,'id'),
	),
	(FORMNS,'hidden'): (
		(FORMNS,'id'),
	),
# required_attributes
	(FORMNS,'image'): (
		(FORMNS,'id'),
	),
	(FORMNS,'image-frame'): (
		(FORMNS,'id'),
	),
	(FORMNS,'list-property'): (
		(FORMNS,'property-name'),
	),
	(FORMNS,'list-value'): (
		(OFFICENS,'string-value'),
	),
	(FORMNS,'listbox'): (
		(FORMNS,'id'),
	),
	(FORMNS,'number'): (
		(FORMNS,'id'),
	),
	(FORMNS,'password'): (
		(FORMNS,'id'),
	),
	(FORMNS,'property'): (
		(FORMNS,'property-name'),
	),
	(FORMNS,'radio'): (
		(FORMNS,'id'),
	),
	(FORMNS,'text'): (
		(FORMNS,'id'),
	),
	(FORMNS,'textarea'): (
		(FORMNS,'id'),
	),
	(FORMNS,'time'): (
		(FORMNS,'id'),
	),
	(FORMNS,'value-range'): (
		(FORMNS,'id'),
	),
	(MANIFESTNS,'algorithm') : (
		(MANIFESTNS,'algorithm-name'),
		(MANIFESTNS,'initialisation-vector'),
	),
	(MANIFESTNS,'encryption-data') : (
		(MANIFESTNS,'checksum-type'),
		(MANIFESTNS,'checksum'),
	),
	(MANIFESTNS,'file-entry') : (
		(MANIFESTNS,'full-path'),
		(MANIFESTNS,'media-type'),
	),
	(MANIFESTNS,'key-derivation') : (
		(MANIFESTNS,'key-derivation-name'),
		(MANIFESTNS,'salt'),
		(MANIFESTNS,'iteration-count'),
	),
# required_attributes
	(METANS,'template'): (
		(XLINKNS,'href'),
	),
	(METANS,'user-defined'): (
		(METANS,'name'),
	),
	(OFFICENS,'dde-source'): (
		(OFFICENS,'dde-topic'),
		(OFFICENS,'dde-application'),
		(OFFICENS,'dde-item'),
	),
	(OFFICENS,'document'): (
		(OFFICENS,'mimetype'),
	),
	(OFFICENS,'script'): (
		(SCRIPTNS,'language'),
	),
	(PRESENTATIONNS,'date-time-decl'): (
		(PRESENTATIONNS,'source'),
		(PRESENTATIONNS,'name'),
	),
	(PRESENTATIONNS,'dim'): (
		(DRAWNS,'color'),
		(DRAWNS,'shape-id'),
	),
# required_attributes
	(PRESENTATIONNS,'event-listener'): (
		(PRESENTATIONNS,'action'),
		(SCRIPTNS,'event-name'),
	),
	(PRESENTATIONNS,'footer-decl'): (
		(PRESENTATIONNS,'name'),
	),
	(PRESENTATIONNS,'header-decl'): (
		(PRESENTATIONNS,'name'),
	),
	(PRESENTATIONNS,'hide-shape'): (
		(DRAWNS,'shape-id'),
	),
	(PRESENTATIONNS,'hide-text'): (
		(DRAWNS,'shape-id'),
	),
	(PRESENTATIONNS,'placeholder'): (
		(SVGNS,'y'),
		(SVGNS,'x'),
		(SVGNS,'height'),
		(PRESENTATIONNS,'object'),
		(SVGNS,'width'),
	),
	(PRESENTATIONNS,'play'): (
		(DRAWNS,'shape-id'),
	),
	(PRESENTATIONNS,'show'): (
		(PRESENTATIONNS,'name'),
		(PRESENTATIONNS,'pages'),
	),
	(PRESENTATIONNS,'show-shape'): (
		(DRAWNS,'shape-id'),
	),
	(PRESENTATIONNS,'show-text'): (
		(DRAWNS,'shape-id'),
	),
	(PRESENTATIONNS,'sound'): (
		(XLINKNS,'href'),
	),
	(SCRIPTNS,'event-listener'): (
		(SCRIPTNS,'language'),
		(SCRIPTNS,'event-name'),
	),
	(STYLENS,'column'): (
		(STYLENS,'rel-width'),
	),
# required_attributes
	(STYLENS,'column-sep'): (
		(STYLENS,'width'),
	),
	(STYLENS,'columns'): (
		(FONS,'column-count'),
	),
	(STYLENS,'font-face'): (
		(STYLENS,'name'),
	),
	(STYLENS,'handout-master'): (
		(STYLENS,'page-layout-name'),
	),
	(STYLENS,'map'): (
		(STYLENS,'apply-style-name'),
		(STYLENS,'condition'),
	),
	(STYLENS,'master-page'): (
		(STYLENS,'page-layout-name'),
		(STYLENS,'name'),
	),
	(STYLENS,'page-layout'): (
		(STYLENS,'name'),
	),
	(STYLENS,'presentation-page-layout'): (
		(STYLENS,'name'),
	),
	(STYLENS,'style'): (
		(STYLENS,'name'),
	),
	(STYLENS,'tab-stop'): (
		(STYLENS,'position'),
	),
	(SVGNS,'definition-src'): (
		(XLINKNS,'href'),
	),
	(SVGNS,'font-face-uri'): (
		(XLINKNS,'href'),
	),
	(SVGNS,'linearGradient'): (
		(DRAWNS,'name'),
	),
	(SVGNS,'radialGradient'): (
		(DRAWNS,'name'),
	),
	(SVGNS,'stop'): (
		(SVGNS,'offset'),
	),
# required_attributes
	(TABLENS,'body'): (
		(TEXTNS,'style-name'),
	),
	(TABLENS,'cell-address'): (
		(TABLENS,'column'),
		(TABLENS,'table'),
		(TABLENS,'row'),
	),
	(TABLENS,'cell-content-change'): (
		(TABLENS,'id'),
	),
	(TABLENS,'cell-range-source'): (
		(TABLENS,'last-row-spanned'),
		(TABLENS,'last-column-spanned'),
		(XLINKNS,'href'),
		(TABLENS,'name'),
	),
	(TABLENS,'consolidation'): (
		(TABLENS,'function'),
		(TABLENS,'source-cell-range-addresses'),
		(TABLENS,'target-cell-address'),
	),
	(TABLENS,'content-validation'): (
		(TABLENS,'name'),
	),
	(TABLENS,'data-pilot-display-info'): (
		(TABLENS,'member-count'),
		(TABLENS,'data-field'),
		(TABLENS,'enabled'),
		(TABLENS,'display-member-mode'),
	),
# required_attributes
	(TABLENS,'data-pilot-field'): (
		(TABLENS,'source-field-name'),
	),
	(TABLENS,'data-pilot-field-reference'): (
		(TABLENS,'field-name'),
		(TABLENS,'type'),
	),
	(TABLENS,'data-pilot-group'): (
		(TABLENS,'name'),
	),
	(TABLENS,'data-pilot-group-member'): (
		(TABLENS,'name'),
	),
	(TABLENS,'data-pilot-groups'): (
		(TABLENS,'source-field-name'),
		(TABLENS,'step'),
		(TABLENS,'grouped-by'),
	),
	(TABLENS,'data-pilot-layout-info'): (
		(TABLENS,'add-empty-lines'),
		(TABLENS,'layout-mode'),
	),
	(TABLENS,'data-pilot-member'): (
		(TABLENS,'name'),
	),
	(TABLENS,'data-pilot-sort-info'): (
		(TABLENS,'order'),
	),
	(TABLENS,'data-pilot-subtotal'): (
		(TABLENS,'function'),
	),
	(TABLENS,'data-pilot-table'): (
		(TABLENS,'target-range-address'),
		(TABLENS,'name'),
	),
	(TABLENS,'database-range'): (
		(TABLENS,'target-range-address'),
	),
# required_attributes
	(TABLENS,'database-source-query'): (
		(TABLENS,'query-name'),
		(TABLENS,'database-name'),
	),
	(TABLENS,'database-source-sql'): (
		(TABLENS,'database-name'),
		(TABLENS,'sql-statement'),
	),
	(TABLENS,'database-source-table'): (
		(TABLENS,'database-table-name'),
		(TABLENS,'database-name'),
	),
	(TABLENS,'deletion'): (
		(TABLENS,'position'),
		(TABLENS,'type'),
		(TABLENS,'id'),
	),
	(TABLENS,'dependency'): (
		(TABLENS,'id'),
	),
	(TABLENS,'even-columns'): (
		(TEXTNS,'style-name'),
	),
	(TABLENS,'even-rows'): (
		(TEXTNS,'style-name'),
	),
	(TABLENS,'filter-condition'): (
		(TABLENS,'operator'),
		(TABLENS,'field-number'),
		(TABLENS,'value'),
	),
	(TABLENS,'first-column'): (
		(TEXTNS,'style-name'),
	),
	(TABLENS,'first-row'): (
		(TEXTNS,'style-name'),
	),
	(TABLENS,'insertion'): (
		(TABLENS,'position'),
		(TABLENS,'type'),
		(TABLENS,'id'),
	),
	(TABLENS,'insertion-cut-off'): (
		(TABLENS,'position'),
		(TABLENS,'id'),
	),
# required_attributes
	(TABLENS,'label-range'): (
		(TABLENS,'label-cell-range-address'),
		(TABLENS,'data-cell-range-address'),
		(TABLENS,'orientation'),
	),
	(TABLENS,'last-column'): (
		(TEXTNS,'style-name'),
	),
	(TABLENS,'last-row'): (
		(TEXTNS,'style-name'),
	),
	(TABLENS,'movement'): (
		(TABLENS,'id'),
	),
	(TABLENS,'named-expression'): (
		(TABLENS,'expression'),
		(TABLENS,'name'),
	),
	(TABLENS,'named-range'): (
		(TABLENS,'name'),
		(TABLENS,'cell-range-address'),
	),
	(TABLENS,'odd-columns'): (
		(TEXTNS,'style-name'),
	),
	(TABLENS,'odd-rows'): (
		(TEXTNS,'style-name'),
	),
	(TABLENS,'operation'): (
		(TABLENS,'index'),
		(TABLENS,'name'),
	),
# required_attributes
	(TABLENS,'scenario'): (
		(TABLENS,'is-active'),
		(TABLENS,'scenario-ranges'),
	),
	(TABLENS,'sort-by'): (
		(TABLENS,'field-number'),
	),
	(TABLENS,'source-cell-range'): (
		(TABLENS,'cell-range-address'),
	),
	(TABLENS,'source-service'): (
		(TABLENS,'source-name'),
		(TABLENS,'object-name'),
		(TABLENS,'name'),
	),
	(TABLENS,'subtotal-field'): (
		(TABLENS,'function'),
		(TABLENS,'field-number'),
	),
	(TABLENS,'subtotal-rule'): (
		(TABLENS,'group-by-field-number'),
	),
	(TABLENS,'table-source'): (
		(XLINKNS,'href'),
	),
	(TABLENS,'table-template'): (
		(TEXTNS,'last-row-end-column'),
		(TEXTNS,'first-row-end-column'),
		(TEXTNS,'name'),
		(TEXTNS,'last-row-start-column'),
		(TEXTNS,'first-row-start-column'),
	),
	(TEXTNS,'a'): (
		(XLINKNS,'href'),
	),
# required_attributes
	(TEXTNS,'alphabetical-index'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'alphabetical-index-auto-mark-file'): (
		(XLINKNS,'href'),
	),
	(TEXTNS,'alphabetical-index-entry-template'): (
		(TEXTNS,'style-name'),
		(TEXTNS,'outline-level'),
	),
	(TEXTNS,'alphabetical-index-mark'): (
		(TEXTNS,'string-value'),
	),
	(TEXTNS,'alphabetical-index-mark-end'): (
		(TEXTNS,'id'),
	),
	(TEXTNS,'alphabetical-index-mark-start'): (
		(TEXTNS,'id'),
	),
	(TEXTNS,'bibliography'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'bibliography-entry-template'): (
		(TEXTNS,'style-name'),
		(TEXTNS,'bibliography-type'),
	),
	(TEXTNS,'bibliography-mark'): (
		(TEXTNS,'bibliography-type'),
	),
	(TEXTNS,'bookmark'): (
		(TEXTNS,'name'),
	),
# required_attributes
	(TEXTNS,'bookmark-end'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'bookmark-start'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'change'): (
		(TEXTNS,'change-id'),
	),
	(TEXTNS,'change-end'): (
		(TEXTNS,'change-id'),
	),
	(TEXTNS,'change-start'): (
		(TEXTNS,'change-id'),
	),
	(TEXTNS,'changed-region'): (
		(TEXTNS,'id'),
	),
	(TEXTNS,'chapter'): (
		(TEXTNS,'display'),
		(TEXTNS,'outline-level'),
	),
	(TEXTNS,'conditional-text'): (
		(TEXTNS,'string-value-if-true'),
		(TEXTNS,'string-value-if-false'),
		(TEXTNS,'condition'),
	),
	(TEXTNS,'database-display'): (
		(TEXTNS,'column-name'),
		(TEXTNS,'table-name'),
	),
	(TEXTNS,'database-name'): (
		(TEXTNS,'table-name'),
	),
	(TEXTNS,'database-next'): (
		(TEXTNS,'table-name'),
	),
	(TEXTNS,'database-row-number'): (
		(TEXTNS,'table-name'),
	),
	(TEXTNS,'database-row-select'): (
		(TEXTNS,'table-name'),
	),
	(TEXTNS,'dde-connection'): (
		(TEXTNS,'connection-name'),
	),
# required_attributes
	(TEXTNS,'dde-connection-decl'): (
		(OFFICENS,'dde-topic'),
		(OFFICENS,'dde-application'),
		(OFFICENS,'name'),
		(OFFICENS,'dde-item'),
	),
	(TEXTNS,'h'): (
		(TEXTNS,'outline-level'),
	),
	(TEXTNS,'hidden-paragraph'): (
		(TEXTNS,'condition'),
	),
	(TEXTNS,'hidden-text'): (
		(TEXTNS,'string-value'),
		(TEXTNS,'condition'),
	),
	(TEXTNS,'illustration-index'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'illustration-index-entry-template'): (
		(TEXTNS,'style-name'),
	),
	(TEXTNS,'index-entry-bibliography'): (
		(TEXTNS,'bibliography-data-field'),
	),
	(TEXTNS,'index-source-style'): (
		(TEXTNS,'style-name'),
	),
	(TEXTNS,'index-source-styles'): (
		(TEXTNS,'outline-level'),
	),
	(TEXTNS,'index-title'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'list-level-style-bullet'): (
		(TEXTNS,'bullet-char'),
		(TEXTNS,'level'),
	),
	(TEXTNS,'list-level-style-image'): (
		(TEXTNS,'level'),
	),
	(TEXTNS,'list-level-style-number'): (
		(TEXTNS,'level'),
	),
	(TEXTNS,'list-style'): (
		(STYLENS,'name'),
	),
# required_attributes
	(TEXTNS,'measure'): (
		(TEXTNS,'kind'),
	),
	(TEXTNS,'note'): (
		(TEXTNS,'note-class'),
	),
	(TEXTNS,'note-ref'): (
		(TEXTNS,'note-class'),
	),
	(TEXTNS,'notes-configuration'): (
		(TEXTNS,'note-class'),
	),
	(TEXTNS,'object-index'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'object-index-entry-template'): (
		(TEXTNS,'style-name'),
	),
	(TEXTNS,'outline-level-style'): (
		(TEXTNS,'level'),
	),
	(TEXTNS,'page'): (
		(TEXTNS,'master-page-name'),
	),
	(TEXTNS,'page-continuation'): (
		(TEXTNS,'select-page'),
	),
	(TEXTNS,'placeholder'): (
		(TEXTNS,'placeholder-type'),
	),
	(TEXTNS,'reference-mark'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'reference-mark-end'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'reference-mark-start'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'section'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'sequence'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'sequence-decl'): (
		(TEXTNS,'display-outline-level'),
		(TEXTNS,'name'),
	),
# required_attributes
	(TEXTNS,'sort-key'): (
		(TEXTNS,'key'),
	),
	(TEXTNS,'table-index'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'table-index-entry-template'): (
		(TEXTNS,'style-name'),
	),
	(TEXTNS,'table-of-content'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'table-of-content-entry-template'): (
		(TEXTNS,'style-name'),
		(TEXTNS,'outline-level'),
	),
	(TEXTNS,'toc-mark'): (
		(TEXTNS,'string-value'),
	),
	(TEXTNS,'toc-mark-end'): (
		(TEXTNS,'id'),
	),
	(TEXTNS,'toc-mark-start'): (
		(TEXTNS,'id'),
	),
	(TEXTNS,'user-defined'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'user-field-decl'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'user-field-get'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'user-field-input'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'user-index'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'user-index-entry-template'): (
		(TEXTNS,'style-name'),
		(TEXTNS,'outline-level'),
	),
# required_attributes
	(TEXTNS,'user-index-mark'): (
		(TEXTNS,'index-name'),
		(TEXTNS,'string-value'),
	),
	(TEXTNS,'user-index-mark-end'): (
		(TEXTNS,'id'),
	),
	(TEXTNS,'user-index-mark-start'): (
		(TEXTNS,'index-name'),
		(TEXTNS,'id'),
	),
	(TEXTNS,'user-index-source'): (
		(TEXTNS,'index-name'),
	),
	(TEXTNS,'variable-decl'): (
		(TEXTNS,'name'),
		(OFFICENS,'value-type'),
	),
	(TEXTNS,'variable-get'): (
		(TEXTNS,'name'),
	),
	(TEXTNS,'variable-input'): (
		(TEXTNS,'name'),
		(OFFICENS,'value-type'),
	),
	(TEXTNS,'variable-set'): (
		(TEXTNS,'name'),
	),
}

# Empty list means the element has no allowed attributes
# None means anything goes

allowed_attributes = {
	(DCNS,'creator'):(
	),
	(DCNS,'date'):(
	),
	(DCNS,'description'):(
	),
	(DCNS,'language'):(
	),
	(DCNS,'subject'):(
	),
	(DCNS,'title'):(
	),
# Completes Dublin Core start
#	(DCNS,'contributor') : (
#	),
#	(DCNS,'coverage') : (
#	),
#	(DCNS,'format') : (
#	),
#	(DCNS,'identifier') : (
#	),
#	(DCNS,'publisher') : (
#	),
#	(DCNS,'relation') : (
#	),
#	(DCNS,'rights') : (
#	),
#	(DCNS,'source') : (
#	),
#	(DCNS,'type') : (
#	),
# Completes Dublin Core end
	(MATHNS,'math'): None,
	(XFORMSNS,'model'): None,
# allowed_attributes
	(ANIMNS,'animate'):(
		(ANIMNS,'formula'),
		(ANIMNS,'sub-item'),
		(SMILNS,'accelerate'),
		(SMILNS,'accumulate'),
		(SMILNS,'additive'),
		(SMILNS,'attributeName'),
		(SMILNS,'autoReverse'),
		(SMILNS,'begin'),
		(SMILNS,'by'),
		(SMILNS,'calcMode'),
		(SMILNS,'decelerate'),
		(SMILNS,'dur'),
		(SMILNS,'end'),
		(SMILNS,'fill'),
		(SMILNS,'fillDefault'),
		(SMILNS,'from'),
		(SMILNS,'keySplines'),
		(SMILNS,'keyTimes'),
		(SMILNS,'repeatCount'),
		(SMILNS,'repeatDur'),
		(SMILNS,'restart'),
		(SMILNS,'restartDefault'),
		(SMILNS,'targetElement'),
		(SMILNS,'to'),
		(SMILNS,'values'),
	),
# allowed_attributes
	(ANIMNS,'animateColor'):(
		(ANIMNS,'color-interpolation'),
		(ANIMNS,'color-interpolation-direction'),
		(ANIMNS,'formula'),
		(ANIMNS,'sub-item'),
		(SMILNS,'accelerate'),
		(SMILNS,'accumulate'),
		(SMILNS,'additive'),
		(SMILNS,'attributeName'),
		(SMILNS,'autoReverse'),
		(SMILNS,'begin'),
		(SMILNS,'by'),
		(SMILNS,'calcMode'),
		(SMILNS,'decelerate'),
		(SMILNS,'dur'),
		(SMILNS,'end'),
		(SMILNS,'fill'),
		(SMILNS,'fillDefault'),
		(SMILNS,'from'),
		(SMILNS,'keySplines'),
		(SMILNS,'keyTimes'),
		(SMILNS,'repeatCount'),
		(SMILNS,'repeatDur'),
		(SMILNS,'restart'),
		(SMILNS,'restartDefault'),
		(SMILNS,'targetElement'),
		(SMILNS,'to'),
		(SMILNS,'values'),
	),
# allowed_attributes
	(ANIMNS,'animateMotion'):(
		(ANIMNS,'formula'),
		(ANIMNS,'sub-item'),
		(SMILNS,'accelerate'),
		(SMILNS,'accumulate'),
		(SMILNS,'additive'),
		(SMILNS,'attributeName'),
		(SMILNS,'autoReverse'),
		(SMILNS,'begin'),
		(SMILNS,'by'),
		(SMILNS,'calcMode'),
		(SMILNS,'decelerate'),
		(SMILNS,'dur'),
		(SMILNS,'end'),
		(SMILNS,'fill'),
		(SMILNS,'fillDefault'),
		(SMILNS,'from'),
		(SMILNS,'keySplines'),
		(SMILNS,'keyTimes'),
		(SMILNS,'repeatCount'),
		(SMILNS,'repeatDur'),
		(SMILNS,'restart'),
		(SMILNS,'restartDefault'),
		(SMILNS,'targetElement'),
		(SMILNS,'to'),
		(SMILNS,'values'),
		(SVGNS,'origin'),
		(SVGNS,'path'),
	),
# allowed_attributes
	(ANIMNS,'animateTransform'):(
		(ANIMNS,'formula'),
		(ANIMNS,'sub-item'),
		(SMILNS,'accelerate'),
		(SMILNS,'accumulate'),
		(SMILNS,'additive'),
		(SMILNS,'attributeName'),
		(SMILNS,'autoReverse'),
		(SMILNS,'begin'),
		(SMILNS,'by'),
		(SMILNS,'decelerate'),
		(SMILNS,'dur'),
		(SMILNS,'end'),
		(SMILNS,'fill'),
		(SMILNS,'fillDefault'),
		(SMILNS,'from'),
		(SMILNS,'repeatCount'),
		(SMILNS,'repeatDur'),
		(SMILNS,'restart'),
		(SMILNS,'restartDefault'),
		(SMILNS,'targetElement'),
		(SMILNS,'to'),
		(SMILNS,'values'),
		(SVGNS,'type'),
	),
# allowed_attributes
	(ANIMNS,'audio'):(
		(ANIMNS,'audio-level'),
		(ANIMNS,'id'),
		(PRESENTATIONNS,'group-id'),
		(PRESENTATIONNS,'master-element'),
		(PRESENTATIONNS,'node-type'),
		(PRESENTATIONNS,'preset-class'),
		(PRESENTATIONNS,'preset-id'),
		(PRESENTATIONNS,'preset-sub-type'),
		(SMILNS,'begin'),
		(SMILNS,'dur'),
		(SMILNS,'end'),
		(SMILNS,'repeatCount'),
		(SMILNS,'repeatDur'),
		(XLINKNS,'href'),
	),
	(ANIMNS,'command'):(
		(PRESENTATIONNS,'node-type'),
		(SMILNS,'begin'),
		(SMILNS,'end'),
		(PRESENTATIONNS,'group-id'),
		(PRESENTATIONNS,'preset-class'),
		(PRESENTATIONNS,'preset-id'),
		(ANIMNS,'sub-item'),
		(ANIMNS,'command'),
		(PRESENTATIONNS,'preset-sub-type'),
		(SMILNS,'targetElement'),
		(ANIMNS,'id'),
		(PRESENTATIONNS,'master-element'),
	),
# allowed_attributes
	(ANIMNS,'iterate'):(
		(ANIMNS,'id'),
		(ANIMNS,'iterate-interval'),
		(ANIMNS,'iterate-type'),
		(ANIMNS,'sub-item'),
		(PRESENTATIONNS,'group-id'),
		(PRESENTATIONNS,'master-element'),
		(PRESENTATIONNS,'node-type'),
		(PRESENTATIONNS,'preset-class'),
		(PRESENTATIONNS,'preset-id'),
		(PRESENTATIONNS,'preset-sub-type'),
		(SMILNS,'accelerate'),
		(SMILNS,'autoReverse'),
		(SMILNS,'begin'),
		(SMILNS,'decelerate'),
		(SMILNS,'dur'),
		(SMILNS,'end'),
		(SMILNS,'endsync'),
		(SMILNS,'fill'),
		(SMILNS,'fillDefault'),
		(SMILNS,'repeatCount'),
		(SMILNS,'repeatDur'),
		(SMILNS,'restart'),
		(SMILNS,'restartDefault'),
		(SMILNS,'targetElement'),
	),
	(ANIMNS,'par'):(
		(PRESENTATIONNS,'node-type'),
		(SMILNS,'decelerate'),
		(SMILNS,'begin'),
		(SMILNS,'end'),
		(PRESENTATIONNS,'group-id'),
		(SMILNS,'accelerate'),
		(SMILNS,'repeatDur'),
		(SMILNS,'repeatCount'),
		(SMILNS,'autoReverse'),
		(PRESENTATIONNS,'preset-class'),
		(SMILNS,'fillDefault'),
		(PRESENTATIONNS,'preset-id'),
		(PRESENTATIONNS,'preset-sub-type'),
		(SMILNS,'restartDefault'),
		(SMILNS,'endsync'),
		(SMILNS,'dur'),
		(SMILNS,'fill'),
		(ANIMNS,'id'),
		(SMILNS,'restart'),
		(PRESENTATIONNS,'master-element'),
	),
# allowed_attributes
	(ANIMNS,'param'):(
		(ANIMNS,'name'),
		(ANIMNS,'value'),
	),
	(ANIMNS,'seq'):(
		(ANIMNS,'id'),
		(PRESENTATIONNS,'group-id'),
		(PRESENTATIONNS,'master-element'),
		(PRESENTATIONNS,'node-type'),
		(PRESENTATIONNS,'preset-class'),
		(PRESENTATIONNS,'preset-id'),
		(PRESENTATIONNS,'preset-sub-type'),
		(SMILNS,'accelerate'),
		(SMILNS,'autoReverse'),
		(SMILNS,'begin'),
		(SMILNS,'decelerate'),
		(SMILNS,'dur'),
		(SMILNS,'end'),
		(SMILNS,'endsync'),
		(SMILNS,'fill'),
		(SMILNS,'fillDefault'),
		(SMILNS,'repeatCount'),
		(SMILNS,'repeatDur'),
		(SMILNS,'restart'),
		(SMILNS,'restartDefault'),
	),
	(ANIMNS,'set'):(
		(ANIMNS,'sub-item'),
		(SMILNS,'accelerate'),
		(SMILNS,'accumulate'),
		(SMILNS,'autoReverse'),
		(SMILNS,'additive'),
		(SMILNS,'attributeName'),
		(SMILNS,'begin'),
		(SMILNS,'decelerate'),
		(SMILNS,'dur'),
		(SMILNS,'end'),
		(SMILNS,'fill'),
		(SMILNS,'fillDefault'),
		(SMILNS,'repeatCount'),
		(SMILNS,'repeatDur'),
		(SMILNS,'restart'),
		(SMILNS,'restartDefault'),
		(SMILNS,'targetElement'),
		(SMILNS,'to'),

	),
# allowed_attributes
	(ANIMNS,'transitionFilter'):(
		(ANIMNS,'formula'),
		(ANIMNS,'sub-item'),
		(SMILNS,'accelerate'),
		(SMILNS,'accumulate'),
		(SMILNS,'additive'),
		(SMILNS,'autoReverse'),
		(SMILNS,'begin'),
		(SMILNS,'by'),
		(SMILNS,'calcMode'),
		(SMILNS,'decelerate'),
		(SMILNS,'direction'),
		(SMILNS,'dur'),
		(SMILNS,'end'),
		(SMILNS,'fadeColor'),
		(SMILNS,'fill'),
		(SMILNS,'fillDefault'),
		(SMILNS,'from'),
		(SMILNS,'mode'),
		(SMILNS,'repeatCount'),
		(SMILNS,'repeatDur'),
		(SMILNS,'restart'),
		(SMILNS,'restartDefault'),
		(SMILNS,'subtype'),
		(SMILNS,'targetElement'),
		(SMILNS,'to'),
		(SMILNS,'type'),
		(SMILNS,'values'),

	),
# allowed_attributes
	(CHARTNS,'axis'):(
		(CHARTNS,'style-name'),
		(CHARTNS,'dimension'),
		(CHARTNS,'name'),
	),
	(CHARTNS,'categories'):(
		(TABLENS,'cell-range-address'),
	),
	(CHARTNS,'chart'):(
		(CHARTNS,'column-mapping'),
		(CHARTNS,'row-mapping'),
		(SVGNS,'height'),
		(SVGNS,'width'),
		(CHARTNS,'style-name'),
		(CHARTNS,'class'),
	),
	(CHARTNS,'data-point'):(
		(CHARTNS,'repeated'),
		(CHARTNS,'style-name'),
	),
	(CHARTNS,'domain'):(
		(TABLENS,'cell-range-address'),
	),
	(CHARTNS,'error-indicator'):(
		(CHARTNS,'style-name'),
	),
	(CHARTNS,'floor'):(
		(SVGNS,'width'),
		(CHARTNS,'style-name'),
	),
# allowed_attributes
	(CHARTNS,'footer'):(
		(SVGNS,'y'),
		(SVGNS,'x'),
		(TABLENS,'cell-range'),
		(CHARTNS,'style-name'),
	),
	(CHARTNS,'grid'):(
		(CHARTNS,'style-name'),
		(CHARTNS,'class'),
	),
	(CHARTNS,'legend'):(
		(CHARTNS,'legend-align'),
		(STYLENS,'legend-expansion-aspect-ratio'),
		(STYLENS,'legend-expansion'),
		(CHARTNS,'legend-position'),
		(CHARTNS,'style-name'),
		(SVGNS,'y'),
		(SVGNS,'x'),
	),
	(CHARTNS,'mean-value'):(
		(CHARTNS,'style-name'),
	),
	(CHARTNS,'plot-area'):(
		(DR3DNS,'ambient-color'),
		(DR3DNS,'distance'),
		(DR3DNS,'vrp'),
		(DR3DNS,'focal-length'),
		(CHARTNS,'data-source-has-labels'),
		(DR3DNS,'lighting-mode'),
		(DR3DNS,'shade-mode'),
		(DR3DNS,'transform'),
		(DR3DNS,'shadow-slant'),
		(SVGNS,'height'),
		(SVGNS,'width'),
		(CHARTNS,'style-name'),
		(DR3DNS,'vup'),
		(SVGNS,'y'),
		(SVGNS,'x'),
		(DR3DNS,'vpn'),
		(TABLENS,'cell-range-address'),
		(DR3DNS,'projection'),
	),
	(CHARTNS,'regression-curve'):(
		(CHARTNS,'style-name'),
	),
	(CHARTNS,'series'):(
		(CHARTNS,'style-name'),
		(CHARTNS,'attached-axis'),
		(CHARTNS,'values-cell-range-address'),
		(CHARTNS,'label-cell-address'),
		(CHARTNS,'class'),
	),
	(CHARTNS,'stock-gain-marker'):(
		(CHARTNS,'style-name'),
	),
# allowed_attributes
	(CHARTNS,'stock-loss-marker'):(
		(CHARTNS,'style-name'),
	),
	(CHARTNS,'stock-range-line'):(
		(CHARTNS,'style-name'),
	),
	(CHARTNS,'subtitle'):(
		(SVGNS,'y'),
		(SVGNS,'x'),
		(TABLENS,'cell-range'),
		(CHARTNS,'style-name'),
	),
	(CHARTNS,'symbol-image'):(
		(XLINKNS,'href'),
	),
	(CHARTNS,'title'):(
		(SVGNS,'y'),
		(SVGNS,'x'),
		(TABLENS,'cell-range'),
		(CHARTNS,'style-name'),
	),
	(CHARTNS,'wall'):(
		(SVGNS,'width'),
		(CHARTNS,'style-name'),
	),
	(CONFIGNS,'config-item'):(
		(CONFIGNS,'type'),
		(CONFIGNS,'name'),
	),
	(CONFIGNS,'config-item-map-entry'):(
		(CONFIGNS,'name'),
	),
	(CONFIGNS,'config-item-map-indexed'):(
		(CONFIGNS,'name'),
	),
	(CONFIGNS,'config-item-map-named'):(
		(CONFIGNS,'name'),
	),
	(CONFIGNS,'config-item-set'):(
		(CONFIGNS,'name'),
	),
# allowed_attributes
	(NUMBERNS,'am-pm'):(
	),
	(NUMBERNS,'boolean'):(
	),
	(NUMBERNS,'boolean-style'):(
		(NUMBERNS,'transliteration-language'),
		(STYLENS,'name'),
		(STYLENS,'display-name'),
		(NUMBERNS,'language'),
		(NUMBERNS,'title'),
		(NUMBERNS,'country'),
		(NUMBERNS,'transliteration-format'),
		(NUMBERNS,'transliteration-style'),
		(STYLENS,'volatile'),
		(NUMBERNS,'transliteration-country'),
	),
	(NUMBERNS,'currency-style'):(
		(NUMBERNS,'transliteration-language'),
		(STYLENS,'name'),
		(STYLENS,'display-name'),
		(NUMBERNS,'language'),
		(NUMBERNS,'title'),
		(NUMBERNS,'country'),
		(NUMBERNS,'transliteration-format'),
		(NUMBERNS,'transliteration-style'),
		(STYLENS,'volatile'),
		(NUMBERNS,'transliteration-country'),
		(NUMBERNS,'automatic-order'),
	),
	(NUMBERNS,'currency-symbol'):(
		(NUMBERNS,'country'),
		(NUMBERNS,'language'),
	),
# allowed_attributes
	(NUMBERNS,'date-style'):(
		(NUMBERNS,'transliteration-language'),
		(STYLENS,'name'),
		(STYLENS,'display-name'),
		(NUMBERNS,'language'),
		(NUMBERNS,'title'),
		(NUMBERNS,'country'),
		(NUMBERNS,'transliteration-format'),
		(NUMBERNS,'transliteration-style'),
		(NUMBERNS,'format-source'),
		(STYLENS,'volatile'),
		(NUMBERNS,'transliteration-country'),
		(NUMBERNS,'automatic-order'),
	),
	(NUMBERNS,'day'):(
		(NUMBERNS,'style'),
		(NUMBERNS,'calendar'),
	),
	(NUMBERNS,'day-of-week'):(
		(NUMBERNS,'style'),
		(NUMBERNS,'calendar'),
	),
	(NUMBERNS,'embedded-text'):(
		(NUMBERNS,'position'),
	),
	(NUMBERNS,'era'):(
		(NUMBERNS,'style'),
		(NUMBERNS,'calendar'),
	),
	(NUMBERNS,'fraction'):(
		(NUMBERNS,'grouping'),
		(NUMBERNS,'min-denominator-digits'),
		(NUMBERNS,'min-numerator-digits'),
		(NUMBERNS,'min-integer-digits'),
		(NUMBERNS,'denominator-value'),
	),
	(NUMBERNS,'hours'):(
		(NUMBERNS,'style'),
	),
# allowed_attributes
	(NUMBERNS,'minutes'):(
		(NUMBERNS,'style'),
	),
	(NUMBERNS,'month'):(
		(NUMBERNS,'style'),
		(NUMBERNS,'calendar'),
		(NUMBERNS,'possessive-form'),
		(NUMBERNS,'textual'),
	),
	(NUMBERNS,'number'):(
		(NUMBERNS,'display-factor'),
		(NUMBERNS,'decimal-places'),
		(NUMBERNS,'decimal-replacement'),
		(NUMBERNS,'min-integer-digits'),
		(NUMBERNS,'grouping'),
	),
	(NUMBERNS,'number-style'):(
		(NUMBERNS,'transliteration-language'),
		(STYLENS,'name'),
		(STYLENS,'display-name'),
		(NUMBERNS,'language'),
		(NUMBERNS,'title'),
		(NUMBERNS,'country'),
		(NUMBERNS,'transliteration-format'),
		(NUMBERNS,'transliteration-style'),
		(STYLENS,'volatile'),
		(NUMBERNS,'transliteration-country'),
	),
# allowed_attributes
	(NUMBERNS,'percentage-style'):(
		(NUMBERNS,'transliteration-language'),
		(STYLENS,'name'),
		(STYLENS,'display-name'),
		(NUMBERNS,'language'),
		(NUMBERNS,'title'),
		(NUMBERNS,'country'),
		(NUMBERNS,'transliteration-format'),
		(NUMBERNS,'transliteration-style'),
		(STYLENS,'volatile'),
		(NUMBERNS,'transliteration-country'),
	),
	(NUMBERNS,'quarter'):(
		(NUMBERNS,'style'),
		(NUMBERNS,'calendar'),
	),
	(NUMBERNS,'scientific-number'):(
		(NUMBERNS,'min-exponent-digits'),
		(NUMBERNS,'decimal-places'),
		(NUMBERNS,'min-integer-digits'),
		(NUMBERNS,'grouping'),
	),
	(NUMBERNS,'seconds'):(
		(NUMBERNS,'style'),
		(NUMBERNS,'decimal-places'),
	),
	(NUMBERNS,'text'):(
	),
	(NUMBERNS,'text-content'):(
	),
	(NUMBERNS,'text-style'):(
		(NUMBERNS,'transliteration-language'),
		(STYLENS,'name'),
		(STYLENS,'display-name'),
		(NUMBERNS,'language'),
		(NUMBERNS,'title'),
		(NUMBERNS,'country'),
		(NUMBERNS,'transliteration-format'),
		(NUMBERNS,'transliteration-style'),
		(STYLENS,'volatile'),
		(NUMBERNS,'transliteration-country'),
	),
	(NUMBERNS,'time-style'):(
		(NUMBERNS,'transliteration-language'),
		(NUMBERNS,'transliteration-format'),
		(STYLENS,'name'),
		(STYLENS,'display-name'),
		(NUMBERNS,'language'),
		(NUMBERNS,'title'),
		(NUMBERNS,'country'),
		(NUMBERNS,'truncate-on-overflow'),
		(NUMBERNS,'transliteration-style'),
		(NUMBERNS,'format-source'),
		(STYLENS,'volatile'),
		(NUMBERNS,'transliteration-country'),
	),
	(NUMBERNS,'week-of-year'):(
		(NUMBERNS,'calendar'),
	),
	(NUMBERNS,'year'):(
		(NUMBERNS,'style'),
		(NUMBERNS,'calendar'),
	),
	(DR3DNS,'cube'):(
		(DR3DNS,'min-edge'),
		(DR3DNS,'max-edge'),
		(DRAWNS,'layer'),
		(DR3DNS,'transform'),
		(DRAWNS,'z-index'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
		(DRAWNS,'id'),
	),
	(DR3DNS,'extrude'):(
		(DRAWNS,'layer'),
		(SVGNS,'d'),
		(DR3DNS,'transform'),
		(SVGNS,'viewBox'),
		(DRAWNS,'z-index'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
		(DRAWNS,'id'),
	),
	(DR3DNS,'light'):(
		(DR3DNS,'diffuse-color'),
		(DR3DNS,'direction'),
		(DR3DNS,'specular'),
		(DR3DNS,'enabled'),
	),
	(DR3DNS,'rotate'):(
		(DRAWNS,'layer'),
		(SVGNS,'d'),
		(DR3DNS,'transform'),
		(SVGNS,'viewBox'),
		(DRAWNS,'z-index'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
		(DRAWNS,'id'),
	),
# allowed_attributes
	(DR3DNS,'scene'):(
		(DR3DNS,'ambient-color'),
		(DR3DNS,'distance'),
		(DR3DNS,'focal-length'),
		(DR3DNS,'lighting-mode'),
		(DR3DNS,'projection'),
		(DR3DNS,'shade-mode'),
		(DR3DNS,'shadow-slant'),
		(DR3DNS,'transform'),
		(DR3DNS,'vpn'),
		(DR3DNS,'vrp'),
		(DR3DNS,'vup'),
		(DRAWNS,'id'),
                (DRAWNS,'caption-id'),
		(DRAWNS,'layer'),
		(DRAWNS,'z-index'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
		(PRESENTATIONNS,'style-name'),
		(SVGNS,'height'),
		(SVGNS,'width'),
		(SVGNS,'x'),
		(SVGNS,'y'),
		(TABLENS,'end-cell-address'),
		(TABLENS,'end-x'),
		(TABLENS,'end-y'),
		(TABLENS,'table-background'),
		(TEXTNS,'anchor-page-number'),
		(TEXTNS,'anchor-type'),
	),
	(DR3DNS,'sphere'):(
		(DRAWNS,'layer'),
		(DR3DNS,'center'),
		(DR3DNS,'transform'),
		(DRAWNS,'z-index'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
		(DRAWNS,'id'),
		(DR3DNS,'size'),
	),
	(DRAWNS,'a'):(
		(OFFICENS,'name'),
		(OFFICENS,'title'),
		(XLINKNS,'show'),
		(OFFICENS,'target-frame-name'),
		(XLINKNS,'actuate'),
		(XLINKNS,'href'),
		(XLINKNS,'type'),
		(OFFICENS,'server-map'),
	),
	(DRAWNS,'applet'):(
		(DRAWNS,'code'),
		(XLINKNS,'show'),
		(DRAWNS,'object'),
		(XLINKNS,'actuate'),
		(XLINKNS,'href'),
		(XLINKNS,'type'),
		(DRAWNS,'archive'),
		(DRAWNS,'may-script'),
	),
	(DRAWNS,'area-circle'):(
		(OFFICENS,'name'),
		(XLINKNS,'show'),
		(SVGNS,'cx'),
		(XLINKNS,'type'),
		(DRAWNS,'nohref'),
		(SVGNS,'cy'),
		(XLINKNS,'href'),
		(SVGNS,'r'),
		(OFFICENS,'target-frame-name'),
	),
	(DRAWNS,'area-polygon'):(
		(OFFICENS,'name'),
		(XLINKNS,'show'),
		(XLINKNS,'type'),
		(SVGNS,'height'),
		(DRAWNS,'nohref'),
		(SVGNS,'width'),
		(XLINKNS,'href'),
		(SVGNS,'y'),
		(SVGNS,'x'),
		(OFFICENS,'target-frame-name'),
		(SVGNS,'viewBox'),
		(DRAWNS,'points'),
	),
	(DRAWNS,'area-rectangle'):(
		(OFFICENS,'name'),
		(XLINKNS,'show'),
		(XLINKNS,'type'),
		(SVGNS,'height'),
		(DRAWNS,'nohref'),
		(SVGNS,'width'),
		(XLINKNS,'href'),
		(SVGNS,'y'),
		(SVGNS,'x'),
		(OFFICENS,'target-frame-name'),
	),
	(DRAWNS,'caption'):(
		(TABLENS,'table-background'),
		(DRAWNS,'layer'),
                (DRAWNS,'caption-id'),
		(TABLENS,'end-cell-address'),
		(DRAWNS,'name'),
		(DRAWNS,'text-style-name'),
		(DRAWNS,'caption-point-y'),
		(DRAWNS,'caption-point-x'),
		(DRAWNS,'transform'),
		(TABLENS,'end-y'),
		(DRAWNS,'corner-radius'),
		(SVGNS,'width'),
		(DRAWNS,'z-index'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
		(TABLENS,'end-x'),
		(TEXTNS,'anchor-page-number'),
		(SVGNS,'y'),
		(SVGNS,'x'),
		(SVGNS,'height'),
		(DRAWNS,'id'),
		(TEXTNS,'anchor-type'),
	),
	(DRAWNS,'circle'):(
		(DRAWNS,'end-angle'),
		(DRAWNS,'id'),
		(DRAWNS,'kind'),
		(DRAWNS,'layer'),
		(DRAWNS,'name'),
		(DRAWNS,'start-angle'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
                (DRAWNS,'caption-id'),
		(DRAWNS,'text-style-name'),
		(DRAWNS,'transform'),
		(DRAWNS,'z-index'),
		(PRESENTATIONNS,'class-names'),
		(PRESENTATIONNS,'style-name'),
		(SVGNS,'cx'),
		(SVGNS,'cy'),
		(SVGNS,'height'),
		(SVGNS,'r'),
		(SVGNS,'width'),
		(SVGNS,'x'),
		(SVGNS,'y'),
		(TABLENS,'end-cell-address'),
		(TABLENS,'end-x'),
		(TABLENS,'end-y'),
		(TABLENS,'table-background'),
		(TEXTNS,'anchor-page-number'),
		(TEXTNS,'anchor-type'),
	),
	(DRAWNS,'connector'):(
		(DRAWNS,'layer'),
		(DRAWNS,'end-shape'),
		(TEXTNS,'anchor-page-number'),
		(SVGNS,'y1'),
		(SVGNS,'y2'),
		(TABLENS,'table-background'),
		(TABLENS,'end-cell-address'),
		(DRAWNS,'transform'),
		(DRAWNS,'id'),
		(TABLENS,'end-y'),
		(TABLENS,'end-x'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
                (DRAWNS,'caption-id'),
		(DRAWNS,'type'),
		(DRAWNS,'start-shape'),
		(DRAWNS,'z-index'),
		(PRESENTATIONNS,'style-name'),
		(DRAWNS,'start-glue-point'),
		(SVGNS,'x2'),
		(SVGNS,'x1'),
		(TEXTNS,'anchor-type'),
		(DRAWNS,'line-skew'),
		(DRAWNS,'name'),
		(DRAWNS,'end-glue-point'),
		(DRAWNS,'text-style-name'),
	),
	(DRAWNS,'contour-path'):(
		(SVGNS,'d'),
		(SVGNS,'width'),
		(DRAWNS,'recreate-on-edit'),
		(SVGNS,'viewBox'),
		(SVGNS,'height'),
	),
	(DRAWNS,'contour-polygon'):(
		(SVGNS,'width'),
		(DRAWNS,'points'),
		(DRAWNS,'recreate-on-edit'),
		(SVGNS,'viewBox'),
		(SVGNS,'height'),
	),
	(DRAWNS,'control'):(
		(DRAWNS,'control'),
		(DRAWNS,'layer'),
                (DRAWNS,'caption-id'),
		(TABLENS,'end-cell-address'),
		(DRAWNS,'name'),
		(DRAWNS,'text-style-name'),
		(TABLENS,'table-background'),
		(DRAWNS,'transform'),
		(SVGNS,'height'),
		(SVGNS,'width'),
		(DRAWNS,'z-index'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
		(TABLENS,'end-x'),
		(TEXTNS,'anchor-page-number'),
		(SVGNS,'y'),
		(SVGNS,'x'),
		(TABLENS,'end-y'),
		(DRAWNS,'id'),
		(TEXTNS,'anchor-type'),
	),
	(DRAWNS,'custom-shape'):(
		(DRAWNS,'engine'),
                (DRAWNS,'caption-id'),
		(DRAWNS,'layer'),
		(TABLENS,'end-cell-address'),
		(DRAWNS,'name'),
		(DRAWNS,'text-style-name'),
		(TABLENS,'table-background'),
		(DRAWNS,'transform'),
		(SVGNS,'height'),
		(SVGNS,'width'),
		(DRAWNS,'z-index'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
		(TABLENS,'end-x'),
		(TEXTNS,'anchor-page-number'),
		(SVGNS,'y'),
		(SVGNS,'x'),
		(TABLENS,'end-y'),
		(DRAWNS,'data'),
		(DRAWNS,'id'),
		(TEXTNS,'anchor-type'),
	),
# allowed_attributes
	(DRAWNS,'ellipse'):(
		(DRAWNS,'layer'),
		(DRAWNS,'start-angle'),
		(SVGNS,'cy'),
		(SVGNS,'cx'),
		(TABLENS,'table-background'),
		(TABLENS,'end-cell-address'),
		(SVGNS,'rx'),
		(DRAWNS,'transform'),
		(DRAWNS,'id'),
		(SVGNS,'width'),
		(TABLENS,'end-y'),
		(TABLENS,'end-x'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
		(DRAWNS,'end-angle'),
		(DRAWNS,'z-index'),
                (DRAWNS,'caption-id'),
		(PRESENTATIONNS,'style-name'),
		(SVGNS,'height'),
		(TEXTNS,'anchor-type'),
		(SVGNS,'ry'),
		(DRAWNS,'kind'),
		(DRAWNS,'name'),
		(TEXTNS,'anchor-page-number'),
		(SVGNS,'y'),
		(SVGNS,'x'),
		(DRAWNS,'text-style-name'),
	),
# allowed_attributes
	(DRAWNS,'enhanced-geometry'):(
		(DRAWNS,'extrusion-rotation-center'),
		(DRAWNS,'extrusion-shininess'),
		(DRAWNS,'extrusion-rotation-angle'),
		(DRAWNS,'extrusion-allowed'),
		(DRAWNS,'extrusion-first-light-level'),
		(DRAWNS,'extrusion-specularity'),
		(DRAWNS,'extrusion-viewpoint'),
		(DRAWNS,'extrusion-second-light-level'),
		(DRAWNS,'extrusion-origin'),
		(DRAWNS,'extrusion-color'),
		(SVGNS,'viewBox'),
		(DR3DNS,'projection'),
		(DRAWNS,'extrusion-metal'),
		(DRAWNS,'extrusion-number-of-line-segments'),
		(DRAWNS,'text-path-same-letter-heights'),
		(DRAWNS,'extrusion-first-light-harsh'),
		(DRAWNS,'enhanced-path'),
		(DRAWNS,'text-rotate-angle'),
		(DRAWNS,'type'),
		(DRAWNS,'glue-point-leaving-directions'),
		(DRAWNS,'concentric-gradient-fill-allowed'),
		(DRAWNS,'text-path-scale'),
		(DRAWNS,'extrusion-brightness'),
		(DRAWNS,'extrusion-first-light-direction'),
		(DRAWNS,'extrusion-light-face'),
		(DRAWNS,'text-path-allowed'),
		(DRAWNS,'glue-points'),
		(DRAWNS,'mirror-vertical'),
		(DRAWNS,'extrusion-depth'),
		(DRAWNS,'extrusion-diffusion'),
		(DRAWNS,'extrusion-second-light-direction'),
		(DRAWNS,'extrusion-skew'),
		(DR3DNS,'shade-mode'),
		(DRAWNS,'path-stretchpoint-y'),
		(DRAWNS,'modifiers'),
		(DRAWNS,'extrusion'),
		(DRAWNS,'path-stretchpoint-x'),
		(DRAWNS,'text-areas'),
		(DRAWNS,'mirror-horizontal'),
		(DRAWNS,'text-path-mode'),
		(DRAWNS,'extrusion-second-light-harsh'),
		(DRAWNS,'glue-point-type'),
		(DRAWNS,'text-path'),
	),
# allowed_attributes
	(DRAWNS,'equation'):(
		(DRAWNS,'formula'),
		(DRAWNS,'name'),
	),
	(DRAWNS,'fill-image'):(
		(DRAWNS,'name'),
		(XLINKNS,'show'),
		(XLINKNS,'actuate'),
		(SVGNS,'height'),
		(SVGNS,'width'),
		(XLINKNS,'href'),
		(DRAWNS,'display-name'),
		(XLINKNS,'type'),
	),
	(DRAWNS,'floating-frame'):(
		(XLINKNS,'href'),
		(XLINKNS,'actuate'),
		(DRAWNS,'frame-name'),
		(XLINKNS,'type'),
		(XLINKNS,'show'),
	),
	(DRAWNS,'frame'):(
		(DRAWNS,'copy-of'),
		(DRAWNS,'id'),
		(DRAWNS,'layer'),
		(DRAWNS,'name'),
		(DRAWNS,'class-names'),
                (DRAWNS,'caption-id'),
		(DRAWNS,'style-name'),
		(DRAWNS,'text-style-name'),
		(DRAWNS,'transform'),
		(DRAWNS,'z-index'),
		(PRESENTATIONNS,'class'),
		(PRESENTATIONNS,'class-names'),
		(PRESENTATIONNS,'placeholder'),
		(PRESENTATIONNS,'style-name'),
		(PRESENTATIONNS,'user-transformed'),
		(STYLENS,'rel-height'),
		(STYLENS,'rel-width'),
		(SVGNS,'height'),
		(SVGNS,'width'),
		(SVGNS,'x'),
		(SVGNS,'y'),
		(TABLENS,'end-cell-address'),
		(TABLENS,'end-x'),
		(TABLENS,'end-y'),
		(TABLENS,'table-background'),
		(TEXTNS,'anchor-page-number'),
		(TEXTNS,'anchor-type'),
	),
# allowed_attributes
	(DRAWNS,'g'):(
		(DRAWNS,'id'),
                (DRAWNS,'caption-id'),
		(DRAWNS,'name'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(DRAWNS,'z-index'),
		(PRESENTATIONNS,'class-names'),
		(PRESENTATIONNS,'style-name'),
		(SVGNS,'y'),
		(TABLENS,'end-cell-address'),
		(TABLENS,'end-x'),
		(TABLENS,'end-y'),
		(TABLENS,'table-background'),
		(TEXTNS,'anchor-page-number'),
		(TEXTNS,'anchor-type'),
	),
	(DRAWNS,'glue-point'):(
		(SVGNS,'y'),
		(SVGNS,'x'),
		(DRAWNS,'align'),
		(DRAWNS,'id'),
		(DRAWNS,'escape-direction'),
	),
	(DRAWNS,'gradient'):(
		(DRAWNS,'style'),
		(DRAWNS,'angle'),
		(DRAWNS,'name'),
		(DRAWNS,'end-color'),
		(DRAWNS,'start-color'),
		(DRAWNS,'cy'),
		(DRAWNS,'cx'),
		(DRAWNS,'display-name'),
		(DRAWNS,'border'),
		(DRAWNS,'end-intensity'),
		(DRAWNS,'start-intensity'),
	),
	(DRAWNS,'handle'):(
		(DRAWNS,'handle-radius-range-minimum'),
		(DRAWNS,'handle-switched'),
		(DRAWNS,'handle-range-y-maximum'),
		(DRAWNS,'handle-mirror-horizontal'),
		(DRAWNS,'handle-range-x-maximum'),
		(DRAWNS,'handle-mirror-vertical'),
		(DRAWNS,'handle-range-y-minimum'),
		(DRAWNS,'handle-radius-range-maximum'),
		(DRAWNS,'handle-range-x-minimum'),
		(DRAWNS,'handle-position'),
		(DRAWNS,'handle-polar'),
	),
	(DRAWNS,'hatch'):(
		(DRAWNS,'distance'),
		(DRAWNS,'style'),
		(DRAWNS,'name'),
		(DRAWNS,'color'),
		(DRAWNS,'display-name'),
		(DRAWNS,'rotation'),
	),
	(DRAWNS,'image'):(
		(DRAWNS,'filter-name'),
		(XLINKNS,'href'),
		(XLINKNS,'type'),
		(XLINKNS,'actuate'),
		(XLINKNS,'show'),
	),
	(DRAWNS,'image-map'):(
	),
	(DRAWNS,'layer'):(
		(DRAWNS,'protected'),
		(DRAWNS,'name'),
		(DRAWNS,'display'),
	),
# allowed_attributes
	(DRAWNS,'layer-set'):(
	),
	(DRAWNS,'line'):(
		(DRAWNS,'class-names'),
		(DRAWNS,'id'),
                (DRAWNS,'caption-id'),
		(DRAWNS,'layer'),
		(DRAWNS,'name'),
		(DRAWNS,'style-name'),
		(DRAWNS,'text-style-name'),
		(DRAWNS,'transform'),
		(DRAWNS,'z-index'),
		(PRESENTATIONNS,'class-names'),
		(PRESENTATIONNS,'style-name'),
		(SVGNS,'x1'),
		(SVGNS,'x2'),
		(SVGNS,'y1'),
		(SVGNS,'y2'),
		(TABLENS,'end-cell-address'),
		(TABLENS,'end-x'),
		(TABLENS,'end-y'),
		(TABLENS,'table-background'),
		(TEXTNS,'anchor-page-number'),
		(TEXTNS,'anchor-type'),
	),
	(DRAWNS,'marker'):(
		(SVGNS,'d'),
		(DRAWNS,'display-name'),
		(DRAWNS,'name'),
		(SVGNS,'viewBox'),
	),
# allowed_attributes
	(DRAWNS,'measure'):(
		(TABLENS,'end-cell-address'),
		(DRAWNS,'layer'),
		(SVGNS,'y2'),
		(DRAWNS,'name'),
		(DRAWNS,'text-style-name'),
		(DRAWNS,'transform'),
		(TABLENS,'table-background'),
		(SVGNS,'x2'),
		(DRAWNS,'z-index'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
		(TABLENS,'end-x'),
		(TEXTNS,'anchor-page-number'),
		(SVGNS,'y1'),
                (DRAWNS,'caption-id'),
		(TABLENS,'end-y'),
		(SVGNS,'x1'),
		(DRAWNS,'id'),
		(TEXTNS,'anchor-type'),
	),
	(DRAWNS,'object'):(
		(XLINKNS,'type'),
		(XLINKNS,'href'),
		(DRAWNS,'notify-on-update-of-ranges'),
		(XLINKNS,'actuate'),
		(XLINKNS,'show'),
	),
	(DRAWNS,'object-ole'):(
		(XLINKNS,'actuate'),
		(XLINKNS,'href'),
		(XLINKNS,'type'),
		(DRAWNS,'class-id'),
		(XLINKNS,'show'),
	),
	(DRAWNS,'opacity'):(
		(DRAWNS,'style'),
		(DRAWNS,'angle'),
		(DRAWNS,'name'),
		(DRAWNS,'start'),
		(DRAWNS,'cy'),
		(DRAWNS,'cx'),
		(DRAWNS,'end'),
		(DRAWNS,'display-name'),
		(DRAWNS,'border'),
	),
	(DRAWNS,'page'):(
		(PRESENTATIONNS,'presentation-page-layout-name'),
		(DRAWNS,'name'),
		(DRAWNS,'nav-order'),
		(PRESENTATIONNS,'use-footer-name'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'use-header-name'),
		(DRAWNS,'master-page-name'),
		(DRAWNS,'id'),
		(PRESENTATIONNS,'use-date-time-name'),
	),
	(DRAWNS,'page-thumbnail'):(
		(TABLENS,'table-background'),
                (DRAWNS,'caption-id'),
		(PRESENTATIONNS,'user-transformed'),
		(DRAWNS,'layer'),
		(TABLENS,'end-cell-address'),
		(DRAWNS,'name'),
		(DRAWNS,'id'),
		(DRAWNS,'transform'),
		(DRAWNS,'page-number'),
		(SVGNS,'height'),
		(SVGNS,'width'),
		(DRAWNS,'z-index'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
		(TABLENS,'end-x'),
		(TEXTNS,'anchor-page-number'),
		(SVGNS,'y'),
		(SVGNS,'x'),
		(TABLENS,'end-y'),
		(PRESENTATIONNS,'placeholder'),
		(PRESENTATIONNS,'class'),
		(TEXTNS,'anchor-type'),
	),
	(DRAWNS,'param'):(
		(DRAWNS,'name'),
		(DRAWNS,'value'),
	),
# allowed_attributes
	(DRAWNS,'path'):(
		(TABLENS,'table-background'),
		(DRAWNS,'layer'),
		(TABLENS,'end-cell-address'),
                (DRAWNS,'caption-id'),
		(SVGNS,'d'),
		(DRAWNS,'text-style-name'),
		(DRAWNS,'id'),
		(DRAWNS,'transform'),
		(SVGNS,'height'),
		(SVGNS,'width'),
		(DRAWNS,'z-index'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
		(TABLENS,'end-x'),
		(TEXTNS,'anchor-type'),
		(TEXTNS,'anchor-page-number'),
		(SVGNS,'y'),
		(SVGNS,'x'),
		(TABLENS,'end-y'),
		(SVGNS,'viewBox'),
		(DRAWNS,'name'),
	),
	(DRAWNS,'plugin'):(
		(XLINKNS,'type'),
		(XLINKNS,'href'),
		(DRAWNS,'mime-type'),
		(XLINKNS,'actuate'),
		(XLINKNS,'show'),
	),
	(DRAWNS,'polygon'):(
                (DRAWNS,'caption-id'),
		(TABLENS,'table-background'),
		(DRAWNS,'layer'),
		(TABLENS,'end-cell-address'),
		(DRAWNS,'name'),
		(DRAWNS,'text-style-name'),
		(DRAWNS,'id'),
		(DRAWNS,'transform'),
		(PRESENTATIONNS,'style-name'),
		(SVGNS,'height'),
		(SVGNS,'width'),
		(DRAWNS,'z-index'),
		(DRAWNS,'points'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
		(TABLENS,'end-x'),
		(TEXTNS,'anchor-page-number'),
		(SVGNS,'y'),
		(SVGNS,'x'),
		(TABLENS,'end-y'),
		(SVGNS,'viewBox'),
		(TEXTNS,'anchor-type'),
	),
# allowed_attributes
	(DRAWNS,'polyline'):(
		(TABLENS,'table-background'),
		(DRAWNS,'layer'),
		(TABLENS,'end-cell-address'),
		(DRAWNS,'name'),
		(DRAWNS,'text-style-name'),
		(DRAWNS,'id'),
                (DRAWNS,'caption-id'),
		(DRAWNS,'transform'),
		(PRESENTATIONNS,'style-name'),
		(SVGNS,'height'),
		(SVGNS,'width'),
		(DRAWNS,'z-index'),
		(DRAWNS,'points'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
		(TABLENS,'end-x'),
		(TEXTNS,'anchor-page-number'),
		(SVGNS,'y'),
		(SVGNS,'x'),
		(TABLENS,'end-y'),
		(SVGNS,'viewBox'),
		(TEXTNS,'anchor-type'),
	),
	(DRAWNS,'rect'):(
		(DRAWNS,'corner-radius'),
                (DRAWNS,'caption-id'),
		(DRAWNS,'id'),
		(DRAWNS,'layer'),
		(DRAWNS,'name'),
		(DRAWNS,'text-style-name'),
		(DRAWNS,'transform'),
		(DRAWNS,'z-index'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
		(PRESENTATIONNS,'style-name'),
		(SVGNS,'height'),
		(SVGNS,'width'),
		(SVGNS,'x'),
		(SVGNS,'y'),
		(TABLENS,'end-cell-address'),
		(TABLENS,'end-x'),
		(TABLENS,'end-y'),
		(TABLENS,'table-background'),
		(TEXTNS,'anchor-page-number'),
		(TEXTNS,'anchor-type'),
	),
# allowed_attributes
	(DRAWNS,'regular-polygon'):(
		(TABLENS,'table-background'),
		(DRAWNS,'layer'),
		(TABLENS,'end-cell-address'),
                (DRAWNS,'caption-id'),
		(DRAWNS,'name'),
		(DRAWNS,'text-style-name'),
		(TEXTNS,'anchor-page-number'),
		(DRAWNS,'concave'),
		(DRAWNS,'sharpness'),
		(DRAWNS,'transform'),
		(SVGNS,'height'),
		(SVGNS,'width'),
		(DRAWNS,'z-index'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
		(TABLENS,'end-x'),
		(DRAWNS,'corners'),
		(SVGNS,'y'),
		(SVGNS,'x'),
		(TABLENS,'end-y'),
		(DRAWNS,'id'),
		(TEXTNS,'anchor-type'),
	),
	(DRAWNS,'stroke-dash'):(
		(DRAWNS,'distance'),
		(DRAWNS,'dots1-length'),
		(DRAWNS,'name'),
		(DRAWNS,'dots2-length'),
		(DRAWNS,'style'),
		(DRAWNS,'dots1'),
		(DRAWNS,'display-name'),
		(DRAWNS,'dots2'),
	),
	(DRAWNS,'text-box'):(
		(FONS,'min-width'),
		(DRAWNS,'corner-radius'),
		(FONS,'max-height'),
		(FONS,'min-height'),
		(DRAWNS,'chain-next-name'),
		(FONS,'max-width'),
                (TEXTNS,'id'),
	),
# allowed_attributes
	(FORMNS,'button'):(
		(FORMNS,'tab-stop'),
		(FORMNS,'focus-on-click'),
		(FORMNS,'image-align'),
		(FORMNS,'name'),
		(FORMNS,'tab-index'),
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'button-type'),
		(FORMNS,'title'),
		(FORMNS,'default-button'),
		(FORMNS,'value'),
		(FORMNS,'label'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'image-data'),
		(XLINKNS,'href'),
		(FORMNS,'toggle'),
		(FORMNS,'xforms-submission'),
		(OFFICENS,'target-frame'),
		(FORMNS,'id'),
		(FORMNS,'image-position'),
	),
	(FORMNS,'checkbox'):(
		(FORMNS,'tab-stop'),
		(FORMNS,'image-align'),
		(FORMNS,'name'),
		(FORMNS,'tab-index'),
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'data-field'),
		(FORMNS,'title'),
		(FORMNS,'is-tristate'),
		(FORMNS,'current-state'),
		(FORMNS,'value'),
		(FORMNS,'label'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'state'),
		(FORMNS,'visual-effect'),
		(FORMNS,'id'),
		(FORMNS,'image-position'),
	),
	(FORMNS,'column'):(
		(FORMNS,'control-implementation'),
		(FORMNS,'text-style-name'),
		(FORMNS,'name'),
		(FORMNS,'label'),
	),
	(FORMNS,'combobox'):(
		(FORMNS,'convert-empty-to-null'),
		(FORMNS,'max-length'),
		(FORMNS,'tab-stop'),
		(FORMNS,'name'),
		(FORMNS,'dropdown'),
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'data-field'),
		(FORMNS,'tab-index'),
		(FORMNS,'auto-complete'),
		(FORMNS,'value'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'readonly'),
		(FORMNS,'list-source'),
		(FORMNS,'title'),
		(FORMNS,'list-source-type'),
		(FORMNS,'id'),
		(FORMNS,'current-value'),
		(FORMNS,'size'),
	),
# allowed_attributes
	(FORMNS,'connection-resource'):(
		(XLINKNS,'href'),
	),
	(FORMNS,'date'):(
		(FORMNS,'convert-empty-to-null'),
		(FORMNS,'max-length'),
		(FORMNS,'tab-stop'),
		(FORMNS,'name'),
		(FORMNS,'tab-index'),
		(FORMNS,'control-implementation'),
		(FORMNS,'min-value'),
		(FORMNS,'data-field'),
		(FORMNS,'max-value'),
		(FORMNS,'value'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'readonly'),
		(XFORMSNS,'bind'),
		(FORMNS,'title'),
		(FORMNS,'id'),
		(FORMNS,'current-value'),
	),
	(FORMNS,'file'):(
		(FORMNS,'max-length'),
		(FORMNS,'tab-stop'),
		(FORMNS,'name'),
		(FORMNS,'tab-index'),
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'title'),
		(FORMNS,'value'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'readonly'),
		(FORMNS,'id'),
		(FORMNS,'current-value'),
	),
	(FORMNS,'fixed-text'):(
		(FORMNS,'name'),
		(FORMNS,'for'),
		(FORMNS,'title'),
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'multi-line'),
		(FORMNS,'label'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'id'),
	),
# allowed_attributes
	(FORMNS,'form'):(
		(XLINKNS,'actuate'),
		(XLINKNS,'href'),
		(FORMNS,'allow-deletes'),
		(FORMNS,'command-type'),
		(FORMNS,'apply-filter'),
		(XLINKNS,'type'),
		(FORMNS,'method'),
		(OFFICENS,'target-frame'),
		(FORMNS,'navigation-mode'),
		(FORMNS,'detail-fields'),
		(FORMNS,'master-fields'),
		(FORMNS,'allow-updates'),
		(FORMNS,'name'),
		(FORMNS,'tab-cycle'),
		(FORMNS,'control-implementation'),
		(FORMNS,'escape-processing'),
		(FORMNS,'filter'),
		(FORMNS,'command'),
		(FORMNS,'datasource'),
		(FORMNS,'enctype'),
		(FORMNS,'allow-inserts'),
		(FORMNS,'ignore-result'),
		(FORMNS,'order'),
	),
	(FORMNS,'formatted-text'):(
		(FORMNS,'convert-empty-to-null'),
		(FORMNS,'max-length'),
		(FORMNS,'tab-stop'),
		(FORMNS,'max-value'),
		(FORMNS,'name'),
		(FORMNS,'tab-index'),
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'data-field'),
		(FORMNS,'title'),
		(FORMNS,'value'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'readonly'),
		(FORMNS,'min-value'),
		(FORMNS,'validation'),
		(FORMNS,'id'),
		(FORMNS,'current-value'),
	),
	(FORMNS,'frame'):(
		(FORMNS,'name'),
		(FORMNS,'for'),
		(FORMNS,'title'),
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'label'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'id'),
	),
# allowed_attributes
	(FORMNS,'generic-control'):(
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'name'),
		(FORMNS,'id'),
	),
	(FORMNS,'grid'):(
		(FORMNS,'tab-stop'),
		(FORMNS,'name'),
		(FORMNS,'tab-index'),
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'title'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'id'),
	),
	(FORMNS,'hidden'):(
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'name'),
		(FORMNS,'value'),
		(FORMNS,'id'),
	),
	(FORMNS,'image'):(
		(FORMNS,'tab-stop'),
		(FORMNS,'name'),
		(FORMNS,'tab-index'),
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'button-type'),
		(FORMNS,'title'),
		(FORMNS,'value'),
		(OFFICENS,'target-frame'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'image-data'),
		(XLINKNS,'href'),
		(FORMNS,'id'),
	),
	(FORMNS,'image-frame'):(
		(FORMNS,'name'),
		(FORMNS,'title'),
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'data-field'),
		(FORMNS,'readonly'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'image-data'),
		(FORMNS,'id'),
	),
	(FORMNS,'item'):(
		(FORMNS,'label'),
	),
	(FORMNS,'list-property'):(
		(FORMNS,'property-name'),
		(OFFICENS,'value-type'),
	),
	(FORMNS,'list-value'):(
		(OFFICENS,'string-value'),
	),
# allowed_attributes
	(FORMNS,'listbox'):(
		(FORMNS,'tab-stop'),
		(FORMNS,'bound-column'),
		(FORMNS,'multiple'),
		(FORMNS,'name'),
		(FORMNS,'dropdown'),
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'data-field'),
		(FORMNS,'tab-index'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'list-source'),
		(FORMNS,'title'),
		(FORMNS,'list-source-type'),
		(FORMNS,'id'),
		(FORMNS,'xforms-list-source'),
		(FORMNS,'size'),
	),
	(FORMNS,'number'):(
		(FORMNS,'convert-empty-to-null'),
		(FORMNS,'max-length'),
		(FORMNS,'tab-stop'),
		(FORMNS,'name'),
		(FORMNS,'tab-index'),
		(FORMNS,'control-implementation'),
		(FORMNS,'min-value'),
		(FORMNS,'data-field'),
		(FORMNS,'max-value'),
		(FORMNS,'value'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'readonly'),
		(XFORMSNS,'bind'),
		(FORMNS,'title'),
		(FORMNS,'id'),
		(FORMNS,'current-value'),
	),
	(FORMNS,'option'):(
		(FORMNS,'current-selected'),
		(FORMNS,'selected'),
		(FORMNS,'value'),
		(FORMNS,'label'),
	),
	(FORMNS,'password'):(
		(FORMNS,'convert-empty-to-null'),
		(FORMNS,'max-length'),
		(FORMNS,'tab-stop'),
		(FORMNS,'name'),
		(FORMNS,'tab-index'),
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'title'),
		(FORMNS,'value'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'echo-char'),
		(FORMNS,'id'),
	),
	(FORMNS,'properties'):(
	),
	(FORMNS,'property'):(
		(OFFICENS,'string-value'),
		(OFFICENS,'value'),
		(OFFICENS,'boolean-value'),
		(FORMNS,'property-name'),
		(OFFICENS,'currency'),
		(OFFICENS,'date-value'),
		(OFFICENS,'value-type'),
		(OFFICENS,'time-value'),
	),
	(FORMNS,'radio'):(
		(FORMNS,'tab-stop'),
		(FORMNS,'selected'),
		(FORMNS,'image-align'),
		(FORMNS,'name'),
		(FORMNS,'tab-index'),
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'data-field'),
		(FORMNS,'current-selected'),
		(FORMNS,'value'),
		(FORMNS,'label'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'title'),
		(FORMNS,'visual-effect'),
		(FORMNS,'id'),
		(FORMNS,'image-position'),
	),
	(FORMNS,'text'):(
		(FORMNS,'convert-empty-to-null'),
		(FORMNS,'max-length'),
		(FORMNS,'tab-stop'),
		(FORMNS,'name'),
		(FORMNS,'tab-index'),
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'data-field'),
		(FORMNS,'title'),
		(FORMNS,'value'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'readonly'),
		(FORMNS,'id'),
		(FORMNS,'current-value'),
	),
	(FORMNS,'textarea'):(
		(FORMNS,'convert-empty-to-null'),
		(FORMNS,'max-length'),
		(FORMNS,'tab-stop'),
		(FORMNS,'name'),
		(FORMNS,'tab-index'),
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'data-field'),
		(FORMNS,'title'),
		(FORMNS,'value'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'readonly'),
		(FORMNS,'id'),
		(FORMNS,'current-value'),
	),
	(FORMNS,'time'):(
		(FORMNS,'convert-empty-to-null'),
		(FORMNS,'max-length'),
		(FORMNS,'tab-stop'),
		(FORMNS,'name'),
		(FORMNS,'tab-index'),
		(FORMNS,'control-implementation'),
		(FORMNS,'min-value'),
		(FORMNS,'data-field'),
		(FORMNS,'max-value'),
		(FORMNS,'value'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'readonly'),
		(XFORMSNS,'bind'),
		(FORMNS,'title'),
		(FORMNS,'id'),
		(FORMNS,'current-value'),
	),
	(FORMNS,'value-range'):(
		(FORMNS,'tab-stop'),
		(FORMNS,'max-value'),
		(FORMNS,'name'),
		(FORMNS,'tab-index'),
		(FORMNS,'control-implementation'),
		(XFORMSNS,'bind'),
		(FORMNS,'title'),
		(FORMNS,'value'),
		(FORMNS,'disabled'),
		(FORMNS,'printable'),
		(FORMNS,'orientation'),
		(FORMNS,'page-step-size'),
		(FORMNS,'delay-for-repeat'),
		(FORMNS,'min-value'),
		(FORMNS,'id'),
		(FORMNS,'step-size'),
	),
	(MANIFESTNS,'algorithm') : (
		(MANIFESTNS,'algorithm-name'),
		(MANIFESTNS,'initialisation-vector'),
	),
	(MANIFESTNS,'encryption-data') : (
		(MANIFESTNS,'checksum-type'),
		(MANIFESTNS,'checksum'),
	),
	(MANIFESTNS,'file-entry') : (
		(MANIFESTNS,'full-path'),
		(MANIFESTNS,'media-type'),
		(MANIFESTNS,'size'),
	),
	(MANIFESTNS,'key-derivation') : (
		(MANIFESTNS,'key-derivation-name'),
		(MANIFESTNS,'salt'),
		(MANIFESTNS,'iteration-count'),
	),
	(MANIFESTNS,'manifest'):(
	),
# allowed_attributes
	(METANS,'auto-reload'):(
		(METANS,'delay'),
		(XLINKNS,'actuate'),
		(XLINKNS,'href'),
		(XLINKNS,'type'),
		(XLINKNS,'show'),
	),
	(METANS,'creation-date'):(
	),
	(METANS,'date-string'):(
	),
	(METANS,'document-statistic'):(
		(METANS,'non-whitespace-character-count'),
		(METANS,'ole-object-count'),
		(METANS,'table-count'),
		(METANS,'row-count'),
		(METANS,'character-count'),
		(METANS,'sentence-count'),
		(METANS,'draw-count'),
		(METANS,'paragraph-count'),
		(METANS,'word-count'),
		(METANS,'object-count'),
		(METANS,'syllable-count'),
		(METANS,'image-count'),
		(METANS,'page-count'),
		(METANS,'frame-count'),
		(METANS,'cell-count'),
	),
	(METANS,'editing-cycles'):(
	),
	(METANS,'editing-duration'):(
	),
	(METANS,'generator'):(
	),
# allowed_attributes
	(METANS,'hyperlink-behaviour'):(
		(OFFICENS,'target-frame-name'),
		(XLINKNS,'show'),
	),
	(METANS,'initial-creator'):(
	),
	(METANS,'keyword'):(
	),
	(METANS,'print-date'):(
	),
	(METANS,'printed-by'):(
	),
	(METANS,'template'):(
		(METANS,'date'),
		(XLINKNS,'actuate'),
		(XLINKNS,'href'),
		(XLINKNS,'type'),
		(XLINKNS,'title'),
	),
	(METANS,'user-defined'):(
		(METANS,'name'),
		(METANS,'value-type'),
	),
	(OFFICENS,'annotation'):(
		(DRAWNS,'layer'),
		(SVGNS,'height'),
		(TEXTNS,'anchor-page-number'),
		(TABLENS,'table-background'),
		(TABLENS,'end-cell-address'),
		(DRAWNS,'transform'),
		(DRAWNS,'id'),
		(SVGNS,'width'),
		(DRAWNS,'class-names'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'class-names'),
		(TABLENS,'end-x'),
		(DRAWNS,'text-style-name'),
		(DRAWNS,'z-index'),
		(PRESENTATIONNS,'style-name'),
		(TEXTNS,'anchor-type'),
		(DRAWNS,'name'),
		(DRAWNS,'caption-point-y'),
		(DRAWNS,'caption-point-x'),
		(DRAWNS,'corner-radius'),
		(SVGNS,'y'),
		(SVGNS,'x'),
		(TABLENS,'end-y'),
		(OFFICENS,'display'),
	),
	(OFFICENS,'automatic-styles'):(
	),
	(OFFICENS,'binary-data'):(
	),
	(OFFICENS,'body'):(
	),
	(OFFICENS,'change-info'):(
	),
	(OFFICENS,'chart'):(
	),
	(OFFICENS,'dde-source'):(
		(OFFICENS,'dde-application'),
		(OFFICENS,'automatic-update'),
		(OFFICENS,'conversion-mode'),
		(OFFICENS,'dde-item'),
		(OFFICENS,'dde-topic'),
		(OFFICENS,'name'),
	),
	(OFFICENS,'document'):(
		(OFFICENS,'mimetype'),
		(OFFICENS,'version'),
	),
	(OFFICENS,'document-content'):(
		(OFFICENS,'version'),
	),
	(OFFICENS,'document-meta'):(
		(OFFICENS,'version'),
	),
	(OFFICENS,'document-settings'):(
		(OFFICENS,'version'),
	),
	(OFFICENS,'document-styles'):(
		(OFFICENS,'version'),
	),
	(OFFICENS,'drawing'):(
	),
	(OFFICENS,'event-listeners'):(
	),
	(OFFICENS,'font-face-decls'):(
	),
	(OFFICENS,'forms'):(
		(FORMNS,'automatic-focus'),
		(FORMNS,'apply-design-mode'),
	),
	(OFFICENS,'image'):(
	),
# allowed_attributes
	(OFFICENS,'master-styles'):(
	),
	(OFFICENS,'meta'):(
	),
	(OFFICENS,'presentation'):(
	),
	(OFFICENS,'script'):(
		(SCRIPTNS,'language'),
	),
	(OFFICENS,'scripts'):(
	),
	(OFFICENS,'settings'):(
	),
	(OFFICENS,'spreadsheet'):(
		(TABLENS,'structure-protected'),
		(TABLENS,'protection-key'),
	),
	(OFFICENS,'styles'):(
	),
	(OFFICENS,'text'):(
		(TEXTNS,'global'),
		(TEXTNS,'use-soft-page-breaks'),
	),
	(PRESENTATIONNS,'animation-group'):(
	),
	(PRESENTATIONNS,'animations'):(
	),
	(PRESENTATIONNS,'date-time'):(
	),
	(PRESENTATIONNS,'date-time-decl'):(
		(PRESENTATIONNS,'source'),
		(STYLENS,'data-style-name'),
		(PRESENTATIONNS,'name'),
	),
	(PRESENTATIONNS,'dim'):(
		(DRAWNS,'color'),
		(DRAWNS,'shape-id'),
	),
	(PRESENTATIONNS,'event-listener'):(
		(PRESENTATIONNS,'direction'),
		(XLINKNS,'show'),
		(XLINKNS,'type'),
		(XLINKNS,'actuate'),
		(PRESENTATIONNS,'effect'),
		(SCRIPTNS,'event-name'),
		(PRESENTATIONNS,'start-scale'),
		(XLINKNS,'href'),
		(PRESENTATIONNS,'verb'),
		(PRESENTATIONNS,'action'),
		(PRESENTATIONNS,'speed'),
	),
	(PRESENTATIONNS,'footer'):(
	),
	(PRESENTATIONNS,'footer-decl'):(
		(PRESENTATIONNS,'name'),
	),
	(PRESENTATIONNS,'header'):(
	),
	(PRESENTATIONNS,'header-decl'):(
		(PRESENTATIONNS,'name'),
	),
	(PRESENTATIONNS,'hide-shape'):(
		(PRESENTATIONNS,'direction'),
		(PRESENTATIONNS,'effect'),
		(PRESENTATIONNS,'delay'),
		(PRESENTATIONNS,'start-scale'),
		(PRESENTATIONNS,'path-id'),
		(PRESENTATIONNS,'speed'),
		(DRAWNS,'shape-id'),
	),
# allowed_attributes
	(PRESENTATIONNS,'hide-text'):(
		(PRESENTATIONNS,'direction'),
		(PRESENTATIONNS,'effect'),
		(PRESENTATIONNS,'delay'),
		(PRESENTATIONNS,'start-scale'),
		(PRESENTATIONNS,'path-id'),
		(PRESENTATIONNS,'speed'),
		(DRAWNS,'shape-id'),
	),
	(PRESENTATIONNS,'notes'):(
		(STYLENS,'page-layout-name'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'use-header-name'),
		(PRESENTATIONNS,'use-date-time-name'),
		(PRESENTATIONNS,'use-footer-name'),
	),
	(PRESENTATIONNS,'placeholder'):(
		(SVGNS,'y'),
		(SVGNS,'x'),
		(SVGNS,'height'),
		(PRESENTATIONNS,'object'),
		(SVGNS,'width'),
	),
	(PRESENTATIONNS,'play'):(
		(PRESENTATIONNS,'speed'),
		(DRAWNS,'shape-id'),
	),
# allowed_attributes
	(PRESENTATIONNS,'settings'):(
		(PRESENTATIONNS,'animations'),
		(PRESENTATIONNS,'endless'),
		(PRESENTATIONNS,'force-manual'),
		(PRESENTATIONNS,'full-screen'),
		(PRESENTATIONNS,'mouse-as-pen'),
		(PRESENTATIONNS,'mouse-visible'),
		(PRESENTATIONNS,'pause'),
		(PRESENTATIONNS,'show'),
		(PRESENTATIONNS,'show-end-of-presentation-slide'),
		(PRESENTATIONNS,'show-logo'),
		(PRESENTATIONNS,'start-page'),
		(PRESENTATIONNS,'start-with-navigator'),
		(PRESENTATIONNS,'stay-on-top'),
		(PRESENTATIONNS,'transition-on-click'),
	),
	(PRESENTATIONNS,'show'):(
		(PRESENTATIONNS,'name'),
		(PRESENTATIONNS,'pages'),
	),
	(PRESENTATIONNS,'show-shape'):(
		(PRESENTATIONNS,'direction'),
		(PRESENTATIONNS,'effect'),
		(PRESENTATIONNS,'delay'),
		(PRESENTATIONNS,'start-scale'),
		(PRESENTATIONNS,'path-id'),
		(PRESENTATIONNS,'speed'),
		(DRAWNS,'shape-id'),
	),
	(PRESENTATIONNS,'show-text'):(
		(PRESENTATIONNS,'direction'),
		(PRESENTATIONNS,'effect'),
		(PRESENTATIONNS,'delay'),
		(PRESENTATIONNS,'start-scale'),
		(PRESENTATIONNS,'path-id'),
		(PRESENTATIONNS,'speed'),
		(DRAWNS,'shape-id'),
	),
	(PRESENTATIONNS,'sound'):(
		(XLINKNS,'actuate'),
		(XLINKNS,'href'),
		(XLINKNS,'type'),
		(PRESENTATIONNS,'play-full'),
		(XLINKNS,'show'),
	),
# allowed_attributes
	(SCRIPTNS,'event-listener'):(
		(SCRIPTNS,'language'),
		(SCRIPTNS,'macro-name'),
		(XLINKNS,'actuate'),
		(SCRIPTNS,'event-name'),
		(XLINKNS,'href'),
		(XLINKNS,'type'),
	),
	(STYLENS,'background-image'):(
		(DRAWNS,'opacity'),
		(STYLENS,'repeat'),
		(XLINKNS,'show'),
		(XLINKNS,'actuate'),
		(STYLENS,'filter-name'),
		(XLINKNS,'href'),
		(STYLENS,'position'),
		(XLINKNS,'type'),
	),
	(STYLENS,'chart-properties'): (
		(CHARTNS,'connect-bars'),
		(CHARTNS,'data-label-number'),
		(CHARTNS,'data-label-symbol'),
		(CHARTNS,'data-label-text'),
		(CHARTNS,'deep'),
		(CHARTNS,'display-label'),
		(CHARTNS,'error-category'),
		(CHARTNS,'error-lower-indicator'),
		(CHARTNS,'error-lower-limit'),
		(CHARTNS,'error-margin'),
		(CHARTNS,'error-percentage'),
		(CHARTNS,'error-upper-indicator'),
		(CHARTNS,'error-upper-limit'),
		(CHARTNS,'gap-width'),
		(CHARTNS,'interpolation'),
		(CHARTNS,'interval-major'),
		(CHARTNS,'interval-minor-divisor'),
		(CHARTNS,'japanese-candle-stick'),
		(CHARTNS,'label-arrangement'),
		(CHARTNS,'lines'),
		(CHARTNS,'link-data-style-to-source'),
		(CHARTNS,'logarithmic'),
		(CHARTNS,'maximum'),
		(CHARTNS,'mean-value'),
		(CHARTNS,'minimum'),
		(CHARTNS,'origin'),
		(CHARTNS,'overlap'),
		(CHARTNS,'percentage'),
		(CHARTNS,'pie-offset'),
		(CHARTNS,'regression-type'),
		(CHARTNS,'scale-text'),
		(CHARTNS,'series-source'),
		(CHARTNS,'solid-type'),
		(CHARTNS,'spline-order'),
		(CHARTNS,'spline-resolution'),
		(CHARTNS,'stacked'),
		(CHARTNS,'symbol-height'),
		(CHARTNS,'symbol-name'),
		(CHARTNS,'symbol-type'),
		(CHARTNS,'symbol-width'),
		(CHARTNS,'text-overlap'),
		(CHARTNS,'three-dimensional'),
		(CHARTNS,'tick-marks-major-inner'),
		(CHARTNS,'tick-marks-major-outer'),
		(CHARTNS,'tick-marks-minor-inner'),
		(CHARTNS,'tick-marks-minor-outer'),
		(CHARTNS,'vertical'),
		(CHARTNS,'visible'),
		(STYLENS,'direction'),
		(STYLENS,'rotation-angle'),
		(TEXTNS,'line-break'),
	),
	(STYLENS,'column'):(
		(FONS,'end-indent'),
		(FONS,'space-before'),
		(FONS,'start-indent'),
		(FONS,'space-after'),
		(STYLENS,'rel-width'),
	),
	(STYLENS,'column-sep'):(
		(STYLENS,'color'),
		(STYLENS,'width'),
		(STYLENS,'style'),
		(STYLENS,'vertical-align'),
		(STYLENS,'height'),
	),
	(STYLENS,'columns'):(
		(FONS,'column-count'),
		(FONS,'column-gap'),
	),
	(STYLENS,'default-style'):(
		(STYLENS,'family'),
	),
# allowed_attributes
	(STYLENS,'drawing-page-properties'): (
		(DRAWNS,'fill'),
		(DRAWNS,'fill-color'),
		(DRAWNS,'secondary-fill-color'),
		(DRAWNS,'fill-gradient-name'),
		(DRAWNS,'gradient-step-count'),
		(DRAWNS,'fill-hatch-name'),
		(DRAWNS,'fill-hatch-solid'),
		(DRAWNS,'fill-image-name'),
		(STYLENS,'repeat'),
		(DRAWNS,'fill-image-width'),
		(DRAWNS,'fill-image-height'),
		(DRAWNS,'fill-image-ref-point-x'),
		(DRAWNS,'fill-image-ref-point-y'),
		(DRAWNS,'fill-image-ref-point'),
		(DRAWNS,'tile-repeat-offset'),
		(DRAWNS,'opacity'),
		(DRAWNS,'opacity-name'),
		(SVGNS,'fill-rule'),
		(PRESENTATIONNS,'transition-type'),
		(PRESENTATIONNS,'transition-style'),
		(PRESENTATIONNS,'transition-speed'),
		(SMILNS,'type'),
		(SMILNS,'subtype'),
		(SMILNS,'direction'),
		(SMILNS,'fadeColor'),
		(PRESENTATIONNS,'duration'),
		(PRESENTATIONNS,'visibility'),
		(DRAWNS,'background-size'),
		(PRESENTATIONNS,'background-objects-visible'),
		(PRESENTATIONNS,'background-visible'),
		(PRESENTATIONNS,'display-header'),
		(PRESENTATIONNS,'display-footer'),
		(PRESENTATIONNS,'display-page-number'),
		(PRESENTATIONNS,'display-date-time'),
	),
	(STYLENS,'drop-cap'):(
		(STYLENS,'distance'),
		(STYLENS,'length'),
		(STYLENS,'style-name'),
		(STYLENS,'lines'),
	),
# allowed_attributes
	(STYLENS,'font-face'):(
		(STYLENS,'font-adornments'),
		(STYLENS,'font-charset'),
		(STYLENS,'font-family-generic'),
		(STYLENS,'font-pitch'),
		(STYLENS,'name'),
		(SVGNS,'accent-height'),
		(SVGNS,'alphabetic'),
		(SVGNS,'ascent'),
		(SVGNS,'bbox'),
		(SVGNS,'cap-height'),
		(SVGNS,'descent'),
		(SVGNS,'font-family'),
		(SVGNS,'font-size'),
		(SVGNS,'font-stretch'),
		(SVGNS,'font-style'),
		(SVGNS,'font-variant'),
		(SVGNS,'font-weight'),
		(SVGNS,'hanging'),
		(SVGNS,'ideographic'),
		(SVGNS,'mathematical'),
		(SVGNS,'overline-position'),
		(SVGNS,'overline-thickness'),
		(SVGNS,'panose-1'),
		(SVGNS,'slope'),
		(SVGNS,'stemh'),
		(SVGNS,'stemv'),
		(SVGNS,'strikethrough-position'),
		(SVGNS,'strikethrough-thickness'),
		(SVGNS,'underline-position'),
		(SVGNS,'underline-thickness'),
		(SVGNS,'unicode-range'),
		(SVGNS,'units-per-em'),
		(SVGNS,'v-alphabetic'),
		(SVGNS,'v-hanging'),
		(SVGNS,'v-ideographic'),
		(SVGNS,'v-mathematical'),
		(SVGNS,'widths'),
		(SVGNS,'x-height'),
	),
	(STYLENS,'footer'):(
		(STYLENS,'display'),
	),
	(STYLENS,'footer-left'):(
		(STYLENS,'display'),
	),
	(STYLENS,'footer-style'):(
	),
	(STYLENS,'footnote-sep'):(
		(STYLENS,'distance-after-sep'),
		(STYLENS,'color'),
		(STYLENS,'rel-width'),
		(STYLENS,'width'),
		(STYLENS,'distance-before-sep'),
		(STYLENS,'line-style'),
		(STYLENS,'adjustment'),
	),
# allowed_attributes
	(STYLENS,'graphic-properties'): (
		(DR3DNS,'ambient-color'),
		(DR3DNS,'back-scale'),
		(DR3DNS,'backface-culling'),
		(DR3DNS,'close-back'),
		(DR3DNS,'close-front'),
		(DR3DNS,'depth'),
		(DR3DNS,'diffuse-color'),
		(DR3DNS,'edge-rounding'),
		(DR3DNS,'edge-rounding-mode'),
		(DR3DNS,'emissive-color'),
		(DR3DNS,'end-angle'),
		(DR3DNS,'horizontal-segments'),
		(DR3DNS,'lighting-mode'),
		(DR3DNS,'normals-direction'),
		(DR3DNS,'normals-kind'),
		(DR3DNS,'shadow'),
		(DR3DNS,'shininess'),
		(DR3DNS,'specular-color'),
		(DR3DNS,'texture-filter'),
		(DR3DNS,'texture-generation-mode-x'),
		(DR3DNS,'texture-generation-mode-y'),
		(DR3DNS,'texture-kind'),
		(DR3DNS,'texture-mode'),
		(DR3DNS,'vertical-segments'),
		(DRAWNS,'auto-grow-height'),
		(DRAWNS,'auto-grow-width'),
		(DRAWNS,'blue'),
		(DRAWNS,'caption-angle'),
		(DRAWNS,'caption-angle-type'),
		(DRAWNS,'caption-escape'),
		(DRAWNS,'caption-escape-direction'),
		(DRAWNS,'caption-fit-line-length'),
		(DRAWNS,'caption-gap'),
		(DRAWNS,'caption-line-length'),
		(DRAWNS,'caption-type'),
		(DRAWNS,'color-inversion'),
		(DRAWNS,'color-mode'),
		(DRAWNS,'contrast'),
		(DRAWNS,'decimal-places'),
		(DRAWNS,'end-guide'),
		(DRAWNS,'end-line-spacing-horizontal'),
		(DRAWNS,'end-line-spacing-vertical'),
		(DRAWNS,'fill'),
		(DRAWNS,'fill-color'),
		(DRAWNS,'fill-gradient-name'),
		(DRAWNS,'fill-hatch-name'),
		(DRAWNS,'fill-hatch-solid'),
		(DRAWNS,'fill-image-height'),
		(DRAWNS,'fill-image-name'),
		(DRAWNS,'fill-image-ref-point'),
		(DRAWNS,'fill-image-ref-point-x'),
		(DRAWNS,'fill-image-ref-point-y'),
		(DRAWNS,'fill-image-width'),
# allowed_attributes
		(DRAWNS,'fit-to-contour'),
		(DRAWNS,'fit-to-size'),
		(DRAWNS,'frame-display-border'),
		(DRAWNS,'frame-display-scrollbar'),
		(DRAWNS,'frame-margin-horizontal'),
		(DRAWNS,'frame-margin-vertical'),
		(DRAWNS,'gamma'),
		(DRAWNS,'gradient-step-count'),
		(DRAWNS,'green'),
		(DRAWNS,'guide-distance'),
		(DRAWNS,'guide-overhang'),
		(DRAWNS,'image-opacity'),
		(DRAWNS,'line-distance'),
		(DRAWNS,'luminance'),
		(DRAWNS,'marker-end'),
		(DRAWNS,'marker-end-center'),
		(DRAWNS,'marker-end-width'),
		(DRAWNS,'marker-start'),
		(DRAWNS,'marker-start-center'),
		(DRAWNS,'marker-start-width'),
		(DRAWNS,'measure-align'),
		(DRAWNS,'measure-vertical-align'),
		(DRAWNS,'ole-draw-aspect'),
		(DRAWNS,'opacity'),
		(DRAWNS,'opacity-name'),
		(DRAWNS,'parallel'),
		(DRAWNS,'placing'),
		(DRAWNS,'red'),
		(DRAWNS,'secondary-fill-color'),
		(DRAWNS,'shadow'),
		(DRAWNS,'shadow-color'),
		(DRAWNS,'shadow-offset-x'),
		(DRAWNS,'shadow-offset-y'),
		(DRAWNS,'shadow-opacity'),
		(DRAWNS,'show-unit'),
		(DRAWNS,'start-guide'),
		(DRAWNS,'start-line-spacing-horizontal'),
		(DRAWNS,'start-line-spacing-vertical'),
		(DRAWNS,'stroke'),
		(DRAWNS,'stroke-dash'),
		(DRAWNS,'stroke-dash-names'),
		(DRAWNS,'stroke-linejoin'),
		(DRAWNS,'symbol-color'),
		(DRAWNS,'textarea-horizontal-align'),
		(DRAWNS,'textarea-vertical-align'),
		(DRAWNS,'tile-repeat-offset'),
		(DRAWNS,'unit'),
		(DRAWNS,'visible-area-height'),
		(DRAWNS,'visible-area-left'),
		(DRAWNS,'visible-area-top'),
		(DRAWNS,'visible-area-width'),
		(DRAWNS,'wrap-influence-on-position'),
# allowed_attributes
		(FONS,'background-color'),
		(FONS,'border'),
		(FONS,'border-bottom'),
		(FONS,'border-left'),
		(FONS,'border-right'),
		(FONS,'border-top'),
		(FONS,'clip'),
		(FONS,'margin'),
		(FONS,'margin-bottom'),
		(FONS,'margin-left'),
		(FONS,'margin-right'),
		(FONS,'margin-top'),
		(FONS,'max-height'),
		(FONS,'max-width'),
		(FONS,'min-height'),
		(FONS,'min-width'),
		(FONS,'padding'),
		(FONS,'padding-bottom'),
		(FONS,'padding-left'),
		(FONS,'padding-right'),
		(FONS,'padding-top'),
		(FONS,'wrap-option'),
		(STYLENS,'border-line-width'),
		(STYLENS,'border-line-width-bottom'),
		(STYLENS,'border-line-width-left'),
		(STYLENS,'border-line-width-right'),
		(STYLENS,'border-line-width-top'),
		(STYLENS,'editable'),
		(STYLENS,'flow-with-text'),
		(STYLENS,'horizontal-pos'),
		(STYLENS,'horizontal-rel'),
		(STYLENS,'mirror'),
		(STYLENS,'number-wrapped-paragraphs'),
		(STYLENS,'overflow-behavior'),
		(STYLENS,'print-content'),
		(STYLENS,'protect'),
		(STYLENS,'rel-height'),
		(STYLENS,'rel-width'),
		(STYLENS,'repeat'),
		(STYLENS,'run-through'),
		(STYLENS,'shadow'),
		(STYLENS,'vertical-pos'),
		(STYLENS,'vertical-rel'),
		(STYLENS,'wrap'),
		(STYLENS,'wrap-contour'),
		(STYLENS,'wrap-contour-mode'),
		(STYLENS,'wrap-dynamic-threshold'),
		(STYLENS,'writing-mode'),
		(SVGNS,'fill-rule'),
		(SVGNS,'height'),
		(SVGNS,'stroke-color'),
		(SVGNS,'stroke-opacity'),
		(SVGNS,'stroke-width'),
		(SVGNS,'width'),
		(SVGNS,'x'),
		(SVGNS,'y'),
		(TEXTNS,'anchor-page-number'),
		(TEXTNS,'anchor-type'),
		(TEXTNS,'animation'),
		(TEXTNS,'animation-delay'),
		(TEXTNS,'animation-direction'),
		(TEXTNS,'animation-repeat'),
		(TEXTNS,'animation-start-inside'),
		(TEXTNS,'animation-steps'),
		(TEXTNS,'animation-stop-inside'),
	),
	(STYLENS,'handout-master'):(
		(PRESENTATIONNS,'presentation-page-layout-name'),
		(STYLENS,'page-layout-name'),
		(PRESENTATIONNS,'use-footer-name'),
		(DRAWNS,'style-name'),
		(PRESENTATIONNS,'use-header-name'),
		(PRESENTATIONNS,'use-date-time-name'),
	),
# allowed_attributes
	(STYLENS,'header'):(
		(STYLENS,'display'),
	),
	(STYLENS,'header-footer-properties'): (
		(FONS,'background-color'),
		(FONS,'border'),
		(FONS,'border-bottom'),
		(FONS,'border-left'),
		(FONS,'border-right'),
		(FONS,'border-top'),
		(FONS,'margin'),
		(FONS,'margin-bottom'),
		(FONS,'margin-left'),
		(FONS,'margin-right'),
		(FONS,'margin-top'),
		(FONS,'min-height'),
		(FONS,'padding'),
		(FONS,'padding-bottom'),
		(FONS,'padding-left'),
		(FONS,'padding-right'),
		(FONS,'padding-top'),
		(STYLENS,'border-line-width'),
		(STYLENS,'border-line-width-bottom'),
		(STYLENS,'border-line-width-left'),
		(STYLENS,'border-line-width-right'),
		(STYLENS,'border-line-width-top'),
		(STYLENS,'dynamic-spacing'),
		(STYLENS,'shadow'),
		(SVGNS,'height'),
	),
	(STYLENS,'header-left'):(
		(STYLENS,'display'),
	),
	(STYLENS,'header-style'):(
	),
# allowed_attributes
	(STYLENS,'list-level-properties'): (
		(FONS,'height'),
		(FONS,'text-align'),
		(FONS,'width'),
		(STYLENS,'font-name'),
		(STYLENS,'vertical-pos'),
		(STYLENS,'vertical-rel'),
		(SVGNS,'y'),
		(TEXTNS,'min-label-distance'),
		(TEXTNS,'min-label-width'),
		(TEXTNS,'space-before'),
	),
	(STYLENS,'map'):(
		(STYLENS,'apply-style-name'),
		(STYLENS,'base-cell-address'),
		(STYLENS,'condition'),
	),
	(STYLENS,'master-page'):(
		(STYLENS,'page-layout-name'),
		(STYLENS,'display-name'),
		(DRAWNS,'style-name'),
		(STYLENS,'name'),
		(STYLENS,'next-style-name'),
	),
	(STYLENS,'page-layout'):(
		(STYLENS,'name'),
		(STYLENS,'page-usage'),
	),
# allowed_attributes
	(STYLENS,'page-layout-properties'): (
		(FONS,'background-color'),
		(FONS,'border'),
		(FONS,'border-bottom'),
		(FONS,'border-left'),
		(FONS,'border-right'),
		(FONS,'border-top'),
		(FONS,'margin'),
		(FONS,'margin-bottom'),
		(FONS,'margin-left'),
		(FONS,'margin-right'),
		(FONS,'margin-top'),
		(FONS,'padding'),
		(FONS,'padding-bottom'),
		(FONS,'padding-left'),
		(FONS,'padding-right'),
		(FONS,'padding-top'),
		(FONS,'page-height'),
		(FONS,'page-width'),
		(STYLENS,'border-line-width'),
		(STYLENS,'border-line-width-bottom'),
		(STYLENS,'border-line-width-left'),
		(STYLENS,'border-line-width-right'),
		(STYLENS,'border-line-width-top'),
		(STYLENS,'first-page-number'),
		(STYLENS,'footnote-max-height'),
		(STYLENS,'layout-grid-base-height'),
		(STYLENS,'layout-grid-color'),
		(STYLENS,'layout-grid-display'),
		(STYLENS,'layout-grid-lines'),
		(STYLENS,'layout-grid-mode'),
		(STYLENS,'layout-grid-print'),
		(STYLENS,'layout-grid-ruby-below'),
		(STYLENS,'layout-grid-ruby-height'),
		(STYLENS,'num-format'),
		(STYLENS,'num-letter-sync'),
		(STYLENS,'num-prefix'),
		(STYLENS,'num-suffix'),
		(STYLENS,'paper-tray-name'),
		(STYLENS,'print'),
		(STYLENS,'print-orientation'),
		(STYLENS,'print-page-order'),
		(STYLENS,'register-truth-ref-style-name'),
		(STYLENS,'scale-to'),
		(STYLENS,'scale-to-pages'),
		(STYLENS,'shadow'),
		(STYLENS,'table-centering'),
		(STYLENS,'writing-mode'),
	),
# allowed_attributes
	(STYLENS,'paragraph-properties'): (
		(FONS,'background-color'),
		(FONS,'border'),
		(FONS,'border-bottom'),
		(FONS,'border-left'),
		(FONS,'border-right'),
		(FONS,'border-top'),
		(FONS,'break-after'),
		(FONS,'break-before'),
		(FONS,'hyphenation-keep'),
		(FONS,'hyphenation-ladder-count'),
		(FONS,'keep-together'),
		(FONS,'keep-with-next'),
		(FONS,'line-height'),
		(FONS,'margin'),
		(FONS,'margin-bottom'),
		(FONS,'margin-left'),
		(FONS,'margin-right'),
		(FONS,'margin-top'),
		(FONS,'orphans'),
		(FONS,'padding'),
		(FONS,'padding-bottom'),
		(FONS,'padding-left'),
		(FONS,'padding-right'),
		(FONS,'padding-top'),
		(FONS,'text-align'),
		(FONS,'text-align-last'),
		(FONS,'text-indent'),
		(FONS,'widows'),
		(STYLENS,'auto-text-indent'),
		(STYLENS,'background-transparency'),
		(STYLENS,'border-line-width'),
		(STYLENS,'border-line-width-bottom'),
		(STYLENS,'border-line-width-left'),
		(STYLENS,'border-line-width-right'),
		(STYLENS,'border-line-width-top'),
		(STYLENS,'font-independent-line-spacing'),
		(STYLENS,'justify-single-word'),
		(STYLENS,'line-break'),
		(STYLENS,'line-height-at-least'),
		(STYLENS,'line-spacing'),
		(STYLENS,'page-number'),
		(STYLENS,'punctuation-wrap'),
		(STYLENS,'register-true'),
		(STYLENS,'shadow'),
		(STYLENS,'snap-to-layout-grid'),
		(STYLENS,'tab-stop-distance'),
		(STYLENS,'text-autospace'),
		(STYLENS,'vertical-align'),
		(STYLENS,'writing-mode'),
		(STYLENS,'writing-mode-automatic'),
		(TEXTNS,'line-number'),
		(TEXTNS,'number-lines'),
	),
	(STYLENS,'presentation-page-layout'):(
		(STYLENS,'display-name'),
		(STYLENS,'name'),
	),
# allowed_attributes
	(STYLENS,'region-center'):(
	),
	(STYLENS,'region-left'):(
	),
	(STYLENS,'region-right'):(
	),
	(STYLENS,'ruby-properties'): (
		(STYLENS,'ruby-position'),
		(STYLENS,'ruby-align'),
	),
	(STYLENS,'section-properties'): (
		(FONS,'background-color'),
		(FONS,'margin-left'),
		(FONS,'margin-right'),
		(STYLENS,'protect'),
		(STYLENS,'writing-mode'),
		(TEXTNS,'dont-balance-text-columns'),
	),
	(STYLENS,'style'):(
		(STYLENS,'family'),
		(STYLENS,'list-style-name'),
		(STYLENS,'name'),
		(STYLENS,'auto-update'),
		(STYLENS,'default-outline-level'),
		(STYLENS,'class'),
		(STYLENS,'next-style-name'),
		(STYLENS,'data-style-name'),
		(STYLENS,'master-page-name'),
		(STYLENS,'display-name'),
		(STYLENS,'parent-style-name'),
	),
# allowed_attributes
	(STYLENS,'tab-stop'):(
		(STYLENS,'leader-text-style'),
		(STYLENS,'leader-width'),
		(STYLENS,'leader-style'),
		(STYLENS,'char'),
		(STYLENS,'leader-color'),
		(STYLENS,'position'),
		(STYLENS,'leader-text'),
		(STYLENS,'type'),
		(STYLENS,'leader-type'),
	),
	(STYLENS,'tab-stops'):(
	),
	(STYLENS,'table-cell-properties'): (
		(FONS,'background-color'),
		(FONS,'border'),
		(FONS,'border-bottom'),
		(FONS,'border-left'),
		(FONS,'border-right'),
		(FONS,'border-top'),
		(FONS,'padding'),
		(FONS,'padding-bottom'),
		(FONS,'padding-left'),
		(FONS,'padding-right'),
		(FONS,'padding-top'),
		(FONS,'wrap-option'),
		(STYLENS,'border-line-width'),
		(STYLENS,'border-line-width-bottom'),
		(STYLENS,'border-line-width-left'),
		(STYLENS,'border-line-width-right'),
		(STYLENS,'border-line-width-top'),
		(STYLENS,'cell-protect'),
		(STYLENS,'decimal-places'),
		(STYLENS,'diagonal-bl-tr'),
		(STYLENS,'diagonal-bl-tr-widths'),
		(STYLENS,'diagonal-tl-br'),
		(STYLENS,'diagonal-tl-br-widths'),
		(STYLENS,'direction'),
		(STYLENS,'glyph-orientation-vertical'),
		(STYLENS,'print-content'),
		(STYLENS,'repeat-content'),
		(STYLENS,'rotation-align'),
		(STYLENS,'rotation-angle'),
		(STYLENS,'shadow'),
		(STYLENS,'shrink-to-fit'),
		(STYLENS,'text-align-source'),
		(STYLENS,'vertical-align'),
	),
# allowed_attributes
	(STYLENS,'table-column-properties'): (
		(FONS,'break-after'),
		(FONS,'break-before'),
		(STYLENS,'column-width'),
		(STYLENS,'rel-column-width'),
		(STYLENS,'use-optimal-column-width'),
	),
	(STYLENS,'table-properties'): (
		(FONS,'background-color'),
		(FONS,'break-after'),
		(FONS,'break-before'),
		(FONS,'keep-with-next'),
		(FONS,'margin'),
		(FONS,'margin-bottom'),
		(FONS,'margin-left'),
		(FONS,'margin-right'),
		(FONS,'margin-top'),
		(STYLENS,'may-break-between-rows'),
		(STYLENS,'page-number'),
		(STYLENS,'rel-width'),
		(STYLENS,'shadow'),
		(STYLENS,'width'),
		(STYLENS,'writing-mode'),
		(TABLENS,'align'),
		(TABLENS,'border-model'),
		(TABLENS,'display'),
	),
	(STYLENS,'table-row-properties'): (
		(FONS,'background-color'),
		(FONS,'break-after'),
		(FONS,'break-before'),
		(FONS,'keep-together'),
		(STYLENS,'min-row-height'),
		(STYLENS,'row-height'),
		(STYLENS,'use-optimal-row-height'),
	),
# allowed_attributes
	(STYLENS,'text-properties'): (
		(FONS,'background-color'),
		(FONS,'color'),
		(FONS,'country'),
		(FONS,'font-family'),
		(FONS,'font-size'),
		(FONS,'font-style'),
		(FONS,'font-variant'),
		(FONS,'font-weight'),
		(FONS,'hyphenate'),
		(FONS,'hyphenation-push-char-count'),
		(FONS,'hyphenation-remain-char-count'),
		(FONS,'language'),
		(FONS,'letter-spacing'),
		(FONS,'text-shadow'),
		(FONS,'text-transform'),
		(STYLENS,'country-asian'),
		(STYLENS,'country-complex'),
		(STYLENS,'font-charset'),
		(STYLENS,'font-charset-asian'),
		(STYLENS,'font-charset-complex'),
		(STYLENS,'font-family-asian'),
		(STYLENS,'font-family-complex'),
		(STYLENS,'font-family-generic'),
		(STYLENS,'font-family-generic-asian'),
		(STYLENS,'font-family-generic-complex'),
		(STYLENS,'font-name'),
		(STYLENS,'font-name-asian'),
		(STYLENS,'font-name-complex'),
		(STYLENS,'font-pitch'),
		(STYLENS,'font-pitch-asian'),
		(STYLENS,'font-pitch-complex'),
		(STYLENS,'font-relief'),
		(STYLENS,'font-size-asian'),
		(STYLENS,'font-size-complex'),
		(STYLENS,'font-size-rel'),
		(STYLENS,'font-size-rel-asian'),
		(STYLENS,'font-size-rel-complex'),
		(STYLENS,'font-style-asian'),
		(STYLENS,'font-style-complex'),
		(STYLENS,'font-style-name'),
		(STYLENS,'font-style-name-asian'),
		(STYLENS,'font-style-name-complex'),
		(STYLENS,'font-weight-asian'),
		(STYLENS,'font-weight-complex'),
		(STYLENS,'language-asian'),
		(STYLENS,'language-complex'),
		(STYLENS,'letter-kerning'),
		(STYLENS,'script-type'),
		(STYLENS,'text-blinking'),
		(STYLENS,'text-combine'),
		(STYLENS,'text-combine-end-char'),
		(STYLENS,'text-combine-start-char'),
		(STYLENS,'text-emphasize'),
		(STYLENS,'text-line-through-color'),
		(STYLENS,'text-line-through-mode'),
		(STYLENS,'text-line-through-style'),
		(STYLENS,'text-line-through-text'),
		(STYLENS,'text-line-through-text-style'),
		(STYLENS,'text-line-through-type'),
		(STYLENS,'text-line-through-width'),
		(STYLENS,'text-outline'),
		(STYLENS,'text-position'),
		(STYLENS,'text-rotation-angle'),
		(STYLENS,'text-rotation-scale'),
		(STYLENS,'text-scale'),
		(STYLENS,'text-underline-color'),
		(STYLENS,'text-underline-mode'),
		(STYLENS,'text-underline-style'),
		(STYLENS,'text-underline-type'),
		(STYLENS,'text-underline-width'),
		(STYLENS,'use-window-font-color'),
		(TEXTNS,'condition'),
		(TEXTNS,'display'),
	),
	(SVGNS,'definition-src'):(
		(XLINKNS,'actuate'),
		(XLINKNS,'href'),
		(XLINKNS,'type'),
	),
	(SVGNS,'desc'):(
	),
	(SVGNS,'font-face-format'):(
		(SVGNS,'string'),
	),
# allowed_attributes
	(SVGNS,'font-face-name'):(
		(SVGNS,'name'),
	),
	(SVGNS,'font-face-src'):(
	),
	(SVGNS,'font-face-uri'):(
		(XLINKNS,'actuate'),
		(XLINKNS,'href'),
		(XLINKNS,'type'),
	),
	(SVGNS,'linearGradient'):(
		(SVGNS,'y2'),
		(DRAWNS,'name'),
		(SVGNS,'spreadMethod'),
		(SVGNS,'gradientUnits'),
		(SVGNS,'x2'),
		(SVGNS,'gradientTransform'),
		(SVGNS,'y1'),
		(DRAWNS,'display-name'),
		(SVGNS,'x1'),
	),
	(SVGNS,'radialGradient'):(
		(DRAWNS,'name'),
		(SVGNS,'fx'),
		(SVGNS,'fy'),
		(SVGNS,'spreadMethod'),
		(SVGNS,'gradientUnits'),
		(SVGNS,'cy'),
		(SVGNS,'cx'),
		(SVGNS,'gradientTransform'),
		(DRAWNS,'display-name'),
		(SVGNS,'r'),
	),
	(SVGNS,'stop'):(
		(SVGNS,'stop-color'),
		(SVGNS,'stop-opacity'),
		(SVGNS,'offset'),
	),
	(SVGNS,'title'):(
	),
# allowed_attributes
	(TABLENS,'body'):(
		(TEXTNS,'paragraph-style-name'),
		(TEXTNS,'style-name'),
	),
	(TABLENS,'calculation-settings'):(
		(TABLENS,'automatic-find-labels'),
		(TABLENS,'case-sensitive'),
		(TABLENS,'search-criteria-must-apply-to-whole-cell'),
		(TABLENS,'precision-as-shown'),
		(TABLENS,'use-regular-expressions'),
		(TABLENS,'null-year'),
	),
	(TABLENS,'cell-address'):(
		(TABLENS,'column'),
		(TABLENS,'table'),
		(TABLENS,'row'),
	),
	(TABLENS,'cell-content-change'):(
		(TABLENS,'id'),
		(TABLENS,'rejecting-change-id'),
		(TABLENS,'acceptance-state'),
	),
	(TABLENS,'cell-content-deletion'):(
		(TABLENS,'id'),
	),
	(TABLENS,'cell-range-source'):(
		(TABLENS,'last-row-spanned'),
		(TABLENS,'last-column-spanned'),
		(TABLENS,'name'),
		(TABLENS,'filter-options'),
		(XLINKNS,'actuate'),
		(TABLENS,'filter-name'),
		(XLINKNS,'href'),
		(TABLENS,'refresh-delay'),
		(XLINKNS,'type'),
	),
	(TABLENS,'change-deletion'):(
		(TABLENS,'id'),
	),
	(TABLENS,'change-track-table-cell'):(
		(OFFICENS,'string-value'),
		(TABLENS,'cell-address'),
		(TABLENS,'number-matrix-columns-spanned'),
		(TABLENS,'number-matrix-rows-spanned'),
		(TABLENS,'matrix-covered'),
		(OFFICENS,'value-type'),
		(OFFICENS,'boolean-value'),
		(OFFICENS,'currency'),
		(OFFICENS,'date-value'),
		(OFFICENS,'value'),
		(TABLENS,'formula'),
		(OFFICENS,'time-value'),
	),
	(TABLENS,'consolidation'):(
		(TABLENS,'function'),
		(TABLENS,'source-cell-range-addresses'),
		(TABLENS,'target-cell-address'),
		(TABLENS,'link-to-source-data'),
		(TABLENS,'use-labels'),
	),
	(TABLENS,'content-validation'):(
		(TABLENS,'base-cell-address'),
		(TABLENS,'display-list'),
		(TABLENS,'allow-empty-cell'),
		(TABLENS,'name'),
		(TABLENS,'condition'),
	),
	(TABLENS,'content-validations'):(
	),
# allowed_attributes
	(TABLENS,'covered-table-cell'):(
		(TABLENS,'protect'),
		(OFFICENS,'string-value'),
		(OFFICENS,'value'),
		(OFFICENS,'boolean-value'),
		(OFFICENS,'currency'),
		(OFFICENS,'date-value'),
		(TABLENS,'style-name'),
		(TABLENS,'content-validation-name'),
		(OFFICENS,'value-type'),
		(TABLENS,'number-columns-repeated'),
		(TABLENS,'formula'),
		(OFFICENS,'time-value'),
	),
	(TABLENS,'cut-offs'):(
	),
	(TABLENS,'data-pilot-display-info'):(
		(TABLENS,'member-count'),
		(TABLENS,'data-field'),
		(TABLENS,'enabled'),
		(TABLENS,'display-member-mode'),
	),
	(TABLENS,'data-pilot-field'):(
		(TABLENS,'selected-page'),
		(TABLENS,'function'),
		(TABLENS,'orientation'),
		(TABLENS,'used-hierarchy'),
		(TABLENS,'is-data-layout-field'),
		(TABLENS,'source-field-name'),
	),
	(TABLENS,'data-pilot-field-reference'):(
		(TABLENS,'member-name'),
		(TABLENS,'field-name'),
		(TABLENS,'member-type'),
		(TABLENS,'type'),
	),
# allowed_attributes
	(TABLENS,'data-pilot-group'):(
		(TABLENS,'name'),
	),
	(TABLENS,'data-pilot-group-member'):(
		(TABLENS,'name'),
	),
	(TABLENS,'data-pilot-groups'):(
		(TABLENS,'date-end'),
		(TABLENS,'end'),
		(TABLENS,'start'),
		(TABLENS,'source-field-name'),
		(TABLENS,'step'),
		(TABLENS,'date-start'),
		(TABLENS,'grouped-by'),
	),
	(TABLENS,'data-pilot-layout-info'):(
		(TABLENS,'add-empty-lines'),
		(TABLENS,'layout-mode'),
	),
	(TABLENS,'data-pilot-level'):(
		(TABLENS,'show-empty'),
	),
# allowed_attributes
	(TABLENS,'data-pilot-member'):(
		(TABLENS,'show-details'),
		(TABLENS,'name'),
		(TABLENS,'display'),
	),
	(TABLENS,'data-pilot-members'):(
	),
	(TABLENS,'data-pilot-sort-info'):(
		(TABLENS,'data-field'),
		(TABLENS,'sort-mode'),
		(TABLENS,'order'),
	),
	(TABLENS,'data-pilot-subtotal'):(
		(TABLENS,'function'),
	),
	(TABLENS,'data-pilot-subtotals'):(
	),
	(TABLENS,'data-pilot-table'):(
		(TABLENS,'buttons'),
		(TABLENS,'application-data'),
		(TABLENS,'name'),
		(TABLENS,'drill-down-on-double-click'),
		(TABLENS,'target-range-address'),
		(TABLENS,'ignore-empty-rows'),
		(TABLENS,'identify-categories'),
		(TABLENS,'show-filter-button'),
		(TABLENS,'grand-total'),
	),
# allowed_attributes
	(TABLENS,'data-pilot-tables'):(
	),
	(TABLENS,'database-range'):(
		(TABLENS,'orientation'),
		(TABLENS,'target-range-address'),
		(TABLENS,'contains-header'),
		(TABLENS,'on-update-keep-size'),
		(TABLENS,'name'),
		(TABLENS,'is-selection'),
		(TABLENS,'refresh-delay'),
		(TABLENS,'display-filter-buttons'),
		(TABLENS,'has-persistent-data'),
		(TABLENS,'on-update-keep-styles'),
	),
	(TABLENS,'database-ranges'):(
	),
	(TABLENS,'database-source-query'):(
		(TABLENS,'query-name'),
		(TABLENS,'database-name'),
	),
# allowed_attributes
	(TABLENS,'database-source-sql'):(
		(TABLENS,'parse-sql-statement'),
		(TABLENS,'database-name'),
		(TABLENS,'sql-statement'),
	),
	(TABLENS,'database-source-table'):(
		(TABLENS,'database-table-name'),
		(TABLENS,'database-name'),
	),
	(TABLENS,'dde-link'):(
	),
	(TABLENS,'dde-links'):(
	),
	(TABLENS,'deletion'):(
		(TABLENS,'rejecting-change-id'),
		(TABLENS,'multi-deletion-spanned'),
		(TABLENS,'acceptance-state'),
		(TABLENS,'table'),
		(TABLENS,'position'),
		(TABLENS,'type'),
		(TABLENS,'id'),
	),
# allowed_attributes
	(TABLENS,'deletions'):(
	),
	(TABLENS,'dependencies'):(
	),
	(TABLENS,'dependency'):(
		(TABLENS,'id'),
	),
	(TABLENS,'detective'):(
	),
	(TABLENS,'error-macro'):(
		(TABLENS,'execute'),
	),
	(TABLENS,'error-message'):(
		(TABLENS,'display'),
		(TABLENS,'message-type'),
		(TABLENS,'title'),
	),
	(TABLENS,'even-columns'):(
		(TEXTNS,'paragraph-style-name'),
		(TEXTNS,'style-name'),
	),
	(TABLENS,'even-rows'):(
		(TEXTNS,'paragraph-style-name'),
		(TEXTNS,'style-name'),
	),
# allowed_attributes
	(TABLENS,'filter'):(
		(TABLENS,'target-range-address'),
		(TABLENS,'display-duplicates'),
		(TABLENS,'condition-source-range-address'),
		(TABLENS,'condition-source'),
	),
	(TABLENS,'filter-and'):(
	),
	(TABLENS,'filter-condition'):(
		(TABLENS,'operator'),
		(TABLENS,'field-number'),
		(TABLENS,'data-type'),
		(TABLENS,'case-sensitive'),
		(TABLENS,'value'),
	),
	(TABLENS,'filter-or'):(
	),
	(TABLENS,'first-column'):(
		(TEXTNS,'paragraph-style-name'),
		(TEXTNS,'style-name'),
	),
	(TABLENS,'first-row'):(
		(TEXTNS,'paragraph-style-name'),
		(TEXTNS,'style-name'),
	),
# allowed_attributes
	(TABLENS,'help-message'):(
		(TABLENS,'display'),
		(TABLENS,'title'),
	),
	(TABLENS,'highlighted-range'):(
		(TABLENS,'contains-error'),
		(TABLENS,'direction'),
		(TABLENS,'marked-invalid'),
		(TABLENS,'cell-range-address'),
	),
	(TABLENS,'insertion'):(
		(TABLENS,'count'),
		(TABLENS,'rejecting-change-id'),
		(TABLENS,'acceptance-state'),
		(TABLENS,'table'),
		(TABLENS,'position'),
		(TABLENS,'type'),
		(TABLENS,'id'),
	),
	(TABLENS,'insertion-cut-off'):(
		(TABLENS,'position'),
		(TABLENS,'id'),
	),
	(TABLENS,'iteration'):(
		(TABLENS,'status'),
		(TABLENS,'maximum-difference'),
		(TABLENS,'steps'),
	),
# allowed_attributes
	(TABLENS,'label-range'):(
		(TABLENS,'label-cell-range-address'),
		(TABLENS,'data-cell-range-address'),
		(TABLENS,'orientation'),
	),
	(TABLENS,'label-ranges'):(
	),
	(TABLENS,'last-column'):(
		(TEXTNS,'paragraph-style-name'),
		(TEXTNS,'style-name'),
	),
	(TABLENS,'last-row'):(
		(TEXTNS,'paragraph-style-name'),
		(TEXTNS,'style-name'),
	),
	(TABLENS,'movement'):(
		(TABLENS,'id'),
		(TABLENS,'rejecting-change-id'),
		(TABLENS,'acceptance-state'),
	),
	(TABLENS,'movement-cut-off'):(
		(TABLENS,'position'),
		(TABLENS,'end-position'),
		(TABLENS,'start-position'),
	),
	(TABLENS,'named-expression'):(
		(TABLENS,'base-cell-address'),
		(TABLENS,'expression'),
		(TABLENS,'name'),
	),
	(TABLENS,'named-expressions'):(
	),
	(TABLENS,'named-range'):(
		(TABLENS,'range-usable-as'),
		(TABLENS,'base-cell-address'),
		(TABLENS,'name'),
		(TABLENS,'cell-range-address'),
	),
	(TABLENS,'null-date'):(
		(TABLENS,'date-value'),
		(TABLENS,'value-type'),
	),
	(TABLENS,'odd-columns'):(
		(TEXTNS,'paragraph-style-name'),
		(TEXTNS,'style-name'),
	),
	(TABLENS,'odd-rows'):(
		(TEXTNS,'paragraph-style-name'),
		(TEXTNS,'style-name'),
	),
	(TABLENS,'operation'):(
		(TABLENS,'index'),
		(TABLENS,'name'),
	),
	(TABLENS,'previous'):(
		(TABLENS,'id'),
	),
	(TABLENS,'scenario'):(
		(TABLENS,'comment'),
		(TABLENS,'border-color'),
		(TABLENS,'copy-back'),
		(TABLENS,'is-active'),
		(TABLENS,'protected'),
		(TABLENS,'copy-formulas'),
		(TABLENS,'copy-styles'),
		(TABLENS,'scenario-ranges'),
		(TABLENS,'display-border'),
	),
	(TABLENS,'shapes'):(
	),
	(TABLENS,'sort'):(
		(TABLENS,'case-sensitive'),
		(TABLENS,'algorithm'),
		(TABLENS,'target-range-address'),
		(TABLENS,'country'),
		(TABLENS,'language'),
		(TABLENS,'bind-styles-to-content'),
	),
	(TABLENS,'sort-by'):(
		(TABLENS,'field-number'),
		(TABLENS,'data-type'),
		(TABLENS,'order'),
	),
	(TABLENS,'sort-groups'):(
		(TABLENS,'data-type'),
		(TABLENS,'order'),
	),
	(TABLENS,'source-cell-range'):(
		(TABLENS,'cell-range-address'),
	),
	(TABLENS,'source-range-address'):(
		(TABLENS,'column'),
		(TABLENS,'end-column'),
		(TABLENS,'start-table'),
		(TABLENS,'end-row'),
		(TABLENS,'table'),
		(TABLENS,'start-row'),
		(TABLENS,'row'),
		(TABLENS,'end-table'),
		(TABLENS,'start-column'),
	),
# allowed_attributes
	(TABLENS,'source-service'):(
		(TABLENS,'user-name'),
		(TABLENS,'source-name'),
		(TABLENS,'password'),
		(TABLENS,'object-name'),
		(TABLENS,'name'),
	),
	(TABLENS,'subtotal-field'):(
		(TABLENS,'function'),
		(TABLENS,'field-number'),
	),
	(TABLENS,'subtotal-rule'):(
		(TABLENS,'group-by-field-number'),
	),
	(TABLENS,'subtotal-rules'):(
		(TABLENS,'bind-styles-to-content'),
		(TABLENS,'page-breaks-on-group-change'),
		(TABLENS,'case-sensitive'),
	),
	(TABLENS,'table'):(
		(TABLENS,'name'),
		(TABLENS,'is-sub-table'),
		(TABLENS,'style-name'),
		(TABLENS,'protected'),
		(TABLENS,'print-ranges'),
		(TABLENS,'print'),
		(TABLENS,'protection-key'),
	),
	(TABLENS,'table-cell'):(
		(TABLENS,'protect'),
		(TABLENS,'number-matrix-rows-spanned'),
		(TABLENS,'number-matrix-columns-spanned'),
		(OFFICENS,'string-value'),
		(TABLENS,'number-columns-spanned'),
		(OFFICENS,'value'),
		(OFFICENS,'boolean-value'),
		(OFFICENS,'currency'),
		(OFFICENS,'date-value'),
		(TABLENS,'style-name'),
		(TABLENS,'content-validation-name'),
		(OFFICENS,'value-type'),
		(TABLENS,'number-rows-spanned'),
		(TABLENS,'number-columns-repeated'),
		(TABLENS,'formula'),
		(OFFICENS,'time-value'),
	),
# allowed_attributes
	(TABLENS,'table-column'):(
		(TABLENS,'style-name'),
		(TABLENS,'default-cell-style-name'),
		(TABLENS,'visibility'),
		(TABLENS,'number-columns-repeated'),
	),
	(TABLENS,'table-column-group'):(
		(TABLENS,'display'),
	),
	(TABLENS,'table-columns'):(
	),
	(TABLENS,'table-header-columns'):(
	),
	(TABLENS,'table-header-rows'):(
	),
	(TABLENS,'table-row'):(
		(TABLENS,'number-rows-repeated'),
		(TABLENS,'style-name'),
		(TABLENS,'visibility'),
		(TABLENS,'default-cell-style-name'),
	),
	(TABLENS,'table-row-group'):(
		(TABLENS,'display'),
	),
	(TABLENS,'table-rows'):(
	),
	(TABLENS,'table-source'):(
		(TABLENS,'filter-options'),
		(XLINKNS,'actuate'),
		(TABLENS,'filter-name'),
		(XLINKNS,'href'),
		(TABLENS,'mode'),
		(TABLENS,'table-name'),
		(XLINKNS,'type'),
		(TABLENS,'refresh-delay'),
	),
	(TABLENS,'table-template'):(
		(TEXTNS,'last-row-end-column'),
		(TEXTNS,'first-row-end-column'),
		(TEXTNS,'name'),
		(TEXTNS,'last-row-start-column'),
		(TEXTNS,'first-row-start-column'),
	),
	(TABLENS,'target-range-address'):(
		(TABLENS,'column'),
		(TABLENS,'end-column'),
		(TABLENS,'start-table'),
		(TABLENS,'end-row'),
		(TABLENS,'table'),
		(TABLENS,'start-row'),
		(TABLENS,'row'),
		(TABLENS,'end-table'),
		(TABLENS,'start-column'),
	),
	(TABLENS,'tracked-changes'):(
		(TABLENS,'track-changes'),
	),
# allowed_attributes
	(TEXTNS,'a'):(
		(TEXTNS,'visited-style-name'),
		(OFFICENS,'name'),
		(OFFICENS,'title'),
		(XLINKNS,'show'),
		(OFFICENS,'target-frame-name'),
		(XLINKNS,'actuate'),
		(TEXTNS,'style-name'),
		(XLINKNS,'href'),
		(XLINKNS,'type'),
	),
	(TEXTNS,'alphabetical-index'):(
		(TEXTNS,'protected'),
		(TEXTNS,'style-name'),
		(TEXTNS,'name'),
		(TEXTNS,'protection-key'),
	),
	(TEXTNS,'alphabetical-index-auto-mark-file'):(
		(XLINKNS,'href'),
		(XLINKNS,'type'),
	),
	(TEXTNS,'alphabetical-index-entry-template'):(
		(TEXTNS,'style-name'),
		(TEXTNS,'outline-level'),
	),
	(TEXTNS,'alphabetical-index-mark'):(
		(TEXTNS,'main-entry'),
		(TEXTNS,'key1-phonetic'),
		(TEXTNS,'key2'),
		(TEXTNS,'key1'),
		(TEXTNS,'string-value'),
		(TEXTNS,'key2-phonetic'),
		(TEXTNS,'string-value-phonetic'),
	),
# allowed_attributes
	(TEXTNS,'alphabetical-index-mark-end'):(
		(TEXTNS,'id'),
	),
	(TEXTNS,'alphabetical-index-mark-start'):(
		(TEXTNS,'main-entry'),
		(TEXTNS,'key1-phonetic'),
		(TEXTNS,'key2'),
		(TEXTNS,'key1'),
		(TEXTNS,'string-value-phonetic'),
		(TEXTNS,'key2-phonetic'),
		(TEXTNS,'id'),
	),
	(TEXTNS,'alphabetical-index-source'):(
		(TEXTNS,'capitalize-entries'),
		(FONS,'language'),
		(TEXTNS,'relative-tab-stop-position'),
		(TEXTNS,'alphabetical-separators'),
		(TEXTNS,'combine-entries-with-pp'),
		(TEXTNS,'combine-entries-with-dash'),
		(TEXTNS,'sort-algorithm'),
		(TEXTNS,'ignore-case'),
		(TEXTNS,'combine-entries'),
		(TEXTNS,'comma-separated'),
		(FONS,'country'),
		(TEXTNS,'index-scope'),
		(TEXTNS,'main-entry-style-name'),
		(TEXTNS,'use-keys-as-entries'),
	),
# allowed_attributes
	(TEXTNS,'author-initials'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'author-name'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'bibliography'):(
		(TEXTNS,'protected'),
		(TEXTNS,'style-name'),
		(TEXTNS,'name'),
		(TEXTNS,'protection-key'),
	),
	(TEXTNS,'bibliography-configuration'):(
		(TEXTNS,'suffix'),
		(FONS,'language'),
		(TEXTNS,'numbered-entries'),
		(FONS,'country'),
		(TEXTNS,'sort-by-position'),
		(TEXTNS,'sort-algorithm'),
		(TEXTNS,'prefix'),
	),
	(TEXTNS,'bibliography-entry-template'):(
		(TEXTNS,'style-name'),
		(TEXTNS,'bibliography-type'),
	),
# allowed_attributes
	(TEXTNS,'bibliography-mark'):(
		(TEXTNS,'address'),
		(TEXTNS,'annote'),
		(TEXTNS,'author'),
		(TEXTNS,'bibliography-type'),
		(TEXTNS,'booktitle'),
		(TEXTNS,'chapter'),
		(TEXTNS,'custom1'),
		(TEXTNS,'custom2'),
		(TEXTNS,'custom3'),
		(TEXTNS,'custom4'),
		(TEXTNS,'custom5'),
		(TEXTNS,'edition'),
		(TEXTNS,'editor'),
		(TEXTNS,'howpublished'),
		(TEXTNS,'identifier'),
		(TEXTNS,'institution'),
		(TEXTNS,'isbn'),
		(TEXTNS,'issn'),
		(TEXTNS,'journal'),
		(TEXTNS,'month'),
		(TEXTNS,'note'),
		(TEXTNS,'number'),
		(TEXTNS,'organizations'),
		(TEXTNS,'pages'),
		(TEXTNS,'publisher'),
		(TEXTNS,'report-type'),
		(TEXTNS,'school'),
		(TEXTNS,'series'),
		(TEXTNS,'title'),
		(TEXTNS,'url'),
		(TEXTNS,'volume'),
		(TEXTNS,'year'),
	),
	(TEXTNS,'bibliography-source'):(
	),
	(TEXTNS,'bookmark'):(
		(TEXTNS,'name'),
	),
	(TEXTNS,'bookmark-end'):(
		(TEXTNS,'name'),
	),
	(TEXTNS,'bookmark-ref'):(
		(TEXTNS,'ref-name'),
		(TEXTNS,'reference-format'),
	),
	(TEXTNS,'bookmark-start'):(
		(TEXTNS,'name'),
	),
# allowed_attributes
	(TEXTNS,'change'):(
		(TEXTNS,'change-id'),
	),
	(TEXTNS,'change-end'):(
		(TEXTNS,'change-id'),
	),
	(TEXTNS,'change-start'):(
		(TEXTNS,'change-id'),
	),
	(TEXTNS,'changed-region'):(
		(TEXTNS,'id'),
	),
	(TEXTNS,'chapter'):(
		(TEXTNS,'display'),
		(TEXTNS,'outline-level'),
	),
	(TEXTNS,'conditional-text'):(
		(TEXTNS,'string-value-if-true'),
		(TEXTNS,'current-value'),
		(TEXTNS,'string-value-if-false'),
		(TEXTNS,'condition'),
	),
	(TEXTNS,'creation-date'):(
		(TEXTNS,'date-value'),
		(TEXTNS,'fixed'),
		(STYLENS,'data-style-name'),
	),
	(TEXTNS,'creation-time'):(
		(TEXTNS,'fixed'),
		(TEXTNS,'time-value'),
		(STYLENS,'data-style-name'),
	),
	(TEXTNS,'creator'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'database-display'):(
		(TEXTNS,'column-name'),
		(TEXTNS,'table-name'),
		(TEXTNS,'table-type'),
		(TEXTNS,'database-name'),
		(STYLENS,'data-style-name'),
	),
	(TEXTNS,'database-name'):(
		(TEXTNS,'table-name'),
		(TEXTNS,'table-type'),
		(TEXTNS,'database-name'),
	),
	(TEXTNS,'database-next'):(
		(TEXTNS,'table-name'),
		(TEXTNS,'table-type'),
		(TEXTNS,'database-name'),
		(TEXTNS,'condition'),
	),
	(TEXTNS,'database-row-number'):(
		(STYLENS,'num-format'),
		(TEXTNS,'database-name'),
		(TEXTNS,'value'),
		(STYLENS,'num-letter-sync'),
		(TEXTNS,'table-name'),
		(TEXTNS,'table-type'),
	),
	(TEXTNS,'database-row-select'):(
		(TEXTNS,'row-number'),
		(TEXTNS,'table-name'),
		(TEXTNS,'table-type'),
		(TEXTNS,'database-name'),
		(TEXTNS,'condition'),
	),
# allowed_attributes
	(TEXTNS,'date'):(
		(TEXTNS,'date-value'),
		(TEXTNS,'fixed'),
		(TEXTNS,'date-adjust'),
		(STYLENS,'data-style-name'),
	),
	(TEXTNS,'dde-connection'):(
		(TEXTNS,'connection-name'),
	),
	(TEXTNS,'dde-connection-decl'):(
		(OFFICENS,'automatic-update'),
		(OFFICENS,'dde-topic'),
		(OFFICENS,'dde-application'),
		(OFFICENS,'name'),
		(OFFICENS,'dde-item'),
	),
	(TEXTNS,'dde-connection-decls'):(
	),
	(TEXTNS,'deletion'):(
	),
	(TEXTNS,'description'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'editing-cycles'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'editing-duration'):(
		(TEXTNS,'duration'),
		(TEXTNS,'fixed'),
		(STYLENS,'data-style-name'),
	),
	(TEXTNS,'execute-macro'):(
		(TEXTNS,'name'),
	),
	(TEXTNS,'expression'):(
		(TEXTNS,'display'),
		(OFFICENS,'string-value'),
		(OFFICENS,'value'),
		(OFFICENS,'boolean-value'),
		(OFFICENS,'currency'),
		(OFFICENS,'date-value'),
		(STYLENS,'data-style-name'),
		(OFFICENS,'value-type'),
		(TEXTNS,'formula'),
		(OFFICENS,'time-value'),
	),
	(TEXTNS,'file-name'):(
		(TEXTNS,'fixed'),
		(TEXTNS,'display'),
	),
# allowed_attributes
	(TEXTNS,'format-change'):(
	),
	(TEXTNS,'h'):(
		(TEXTNS,'restart-numbering'),
		(TEXTNS,'cond-style-name'),
		(TEXTNS,'is-list-header'),
		(TEXTNS,'style-name'),
		(TEXTNS,'class-names'),
		(TEXTNS,'start-value'),
		(TEXTNS,'id'),
		(TEXTNS,'outline-level'),
	),
	(TEXTNS,'hidden-paragraph'):(
		(TEXTNS,'is-hidden'),
		(TEXTNS,'condition'),
	),
	(TEXTNS,'hidden-text'):(
		(TEXTNS,'string-value'),
		(TEXTNS,'is-hidden'),
		(TEXTNS,'condition'),
	),
	(TEXTNS,'illustration-index'):(
		(TEXTNS,'protected'),
		(TEXTNS,'style-name'),
		(TEXTNS,'name'),
		(TEXTNS,'protection-key'),
	),
	(TEXTNS,'illustration-index-entry-template'):(
		(TEXTNS,'style-name'),
	),
	(TEXTNS,'illustration-index-source'):(
		(TEXTNS,'index-scope'),
		(TEXTNS,'caption-sequence-name'),
		(TEXTNS,'use-caption'),
		(TEXTNS,'caption-sequence-format'),
		(TEXTNS,'relative-tab-stop-position'),
	),
	(TEXTNS,'index-body'):(
	),
	(TEXTNS,'index-entry-bibliography'):(
		(TEXTNS,'bibliography-data-field'),
		(TEXTNS,'style-name'),
	),
	(TEXTNS,'index-entry-chapter'):(
		(TEXTNS,'style-name'),
		(TEXTNS,'display'),
	),
# allowed_attributes
	(TEXTNS,'index-entry-link-end'):(
		(TEXTNS,'style-name'),
	),
	(TEXTNS,'index-entry-link-start'):(
		(TEXTNS,'style-name'),
	),
	(TEXTNS,'index-entry-page-number'):(
		(TEXTNS,'style-name'),
	),
	(TEXTNS,'index-entry-span'):(
		(TEXTNS,'style-name'),
	),
	(TEXTNS,'index-entry-tab-stop'):(
		(STYLENS,'position'),
		(TEXTNS,'style-name'),
		(STYLENS,'type'),
		(STYLENS,'leader-char'),
	),
	(TEXTNS,'index-entry-text'):(
		(TEXTNS,'style-name'),
	),
	(TEXTNS,'index-source-style'):(
		(TEXTNS,'style-name'),
	),
	(TEXTNS,'index-source-styles'):(
		(TEXTNS,'outline-level'),
	),
	(TEXTNS,'index-title'):(
		(TEXTNS,'protected'),
		(TEXTNS,'style-name'),
		(TEXTNS,'name'),
		(TEXTNS,'protection-key'),
	),
	(TEXTNS,'index-title-template'):(
		(TEXTNS,'style-name'),
	),
	(TEXTNS,'initial-creator'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'insertion'):(
	),
# allowed_attributes
	(TEXTNS,'keywords'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'line-break'):(
	),
	(TEXTNS,'linenumbering-configuration'):(
		(TEXTNS,'number-position'),
		(TEXTNS,'number-lines'),
		(STYLENS,'num-format'),
		(TEXTNS,'count-empty-lines'),
		(TEXTNS,'count-in-text-boxes'),
		(TEXTNS,'style-name'),
		(STYLENS,'num-letter-sync'),
		(TEXTNS,'increment'),
		(TEXTNS,'offset'),
		(TEXTNS,'restart-on-page'),
	),
	(TEXTNS,'linenumbering-separator'):(
		(TEXTNS,'increment'),
	),
	(TEXTNS,'list'):(
		(TEXTNS,'style-name'),
		(TEXTNS,'continue-numbering'),
	),
	(TEXTNS,'list-header'):(
	),
	(TEXTNS,'list-item'):(
		(TEXTNS,'start-value'),
	),
	(TEXTNS,'list-level-style-bullet'):(
		(TEXTNS,'level'),
		(STYLENS,'num-prefix'),
		(STYLENS,'num-suffix'),
		(TEXTNS,'bullet-relative-size'),
		(TEXTNS,'style-name'),
		(TEXTNS,'bullet-char'),
	),
	(TEXTNS,'list-level-style-image'):(
		(XLINKNS,'show'),
		(XLINKNS,'actuate'),
		(XLINKNS,'href'),
		(XLINKNS,'type'),
		(TEXTNS,'level'),
	),
	(TEXTNS,'list-level-style-number'):(
		(TEXTNS,'level'),
		(TEXTNS,'display-levels'),
		(STYLENS,'num-format'),
		(STYLENS,'num-suffix'),
		(TEXTNS,'style-name'),
		(STYLENS,'num-prefix'),
		(STYLENS,'num-letter-sync'),
		(TEXTNS,'start-value'),
	),
# allowed_attributes
	(TEXTNS,'list-style'):(
		(TEXTNS,'consecutive-numbering'),
		(STYLENS,'display-name'),
		(STYLENS,'name'),
	),
	(TEXTNS,'measure'):(
		(TEXTNS,'kind'),
	),
	(TEXTNS,'modification-date'):(
		(TEXTNS,'date-value'),
		(TEXTNS,'fixed'),
		(STYLENS,'data-style-name'),
	),
	(TEXTNS,'modification-time'):(
		(TEXTNS,'fixed'),
		(TEXTNS,'time-value'),
		(STYLENS,'data-style-name'),
	),
	(TEXTNS,'note'):(
		(TEXTNS,'note-class'),
		(TEXTNS,'id'),
	),
	(TEXTNS,'note-body'):(
	),
	(TEXTNS,'note-citation'):(
		(TEXTNS,'label'),
	),
	(TEXTNS,'note-continuation-notice-backward'):(
	),
	(TEXTNS,'note-continuation-notice-forward'):(
	),
	(TEXTNS,'note-ref'):(
		(TEXTNS,'ref-name'),
		(TEXTNS,'note-class'),
		(TEXTNS,'reference-format'),
	),
	(TEXTNS,'notes-configuration'):(
		(TEXTNS,'citation-body-style-name'),
		(STYLENS,'num-format'),
		(TEXTNS,'default-style-name'),
		(STYLENS,'num-suffix'),
		(TEXTNS,'start-numbering-at'),
		(STYLENS,'num-prefix'),
		(STYLENS,'num-letter-sync'),
		(TEXTNS,'citation-style-name'),
		(TEXTNS,'footnotes-position'),
		(TEXTNS,'master-page-name'),
		(TEXTNS,'start-value'),
		(TEXTNS,'note-class'),
	),
	(TEXTNS,'number'):(
	),
	(TEXTNS,'numbered-paragraph'):(
		(TEXTNS,'continue-numbering'),
		(TEXTNS,'style-name'),
		(TEXTNS,'start-value'),
		(TEXTNS,'level'),
	),
	(TEXTNS,'object-count'):(
		(STYLENS,'num-format'),
		(STYLENS,'num-letter-sync'),
	),
	(TEXTNS,'object-index'):(
		(TEXTNS,'protected'),
		(TEXTNS,'style-name'),
		(TEXTNS,'name'),
		(TEXTNS,'protection-key'),
	),
# allowed_attributes
	(TEXTNS,'object-index-entry-template'):(
		(TEXTNS,'style-name'),
	),
	(TEXTNS,'object-index-source'):(
		(TEXTNS,'use-draw-objects'),
		(TEXTNS,'use-math-objects'),
		(TEXTNS,'relative-tab-stop-position'),
		(TEXTNS,'use-chart-objects'),
		(TEXTNS,'index-scope'),
		(TEXTNS,'use-spreadsheet-objects'),
		(TEXTNS,'use-other-objects'),
	),
	(TEXTNS,'outline-level-style'):(
		(TEXTNS,'level'),
		(TEXTNS,'display-levels'),
		(STYLENS,'num-format'),
		(STYLENS,'num-suffix'),
		(TEXTNS,'style-name'),
		(STYLENS,'num-prefix'),
		(STYLENS,'num-letter-sync'),
		(TEXTNS,'start-value'),
	),
	(TEXTNS,'outline-style'):(
	),
	(TEXTNS,'p'):(
		(TEXTNS,'cond-style-name'),
		(TEXTNS,'style-name'),
		(TEXTNS,'class-names'),
		(TEXTNS,'id'),
	),
	(TEXTNS,'page'):(
		(TEXTNS,'master-page-name'),
	),
	(TEXTNS,'page-continuation'):(
		(TEXTNS,'string-value'),
		(TEXTNS,'select-page'),
	),
	(TEXTNS,'page-number'):(
		(TEXTNS,'page-adjust'),
		(STYLENS,'num-format'),
		(TEXTNS,'fixed'),
		(STYLENS,'num-letter-sync'),
		(TEXTNS,'select-page'),
	),
	(TEXTNS,'page-sequence'):(
	),
	(TEXTNS,'page-variable-get'):(
		(STYLENS,'num-format'),
		(STYLENS,'num-letter-sync'),
	),
	(TEXTNS,'page-variable-set'):(
		(TEXTNS,'active'),
		(TEXTNS,'page-adjust'),
	),
	(TEXTNS,'placeholder'):(
		(TEXTNS,'placeholder-type'),
		(TEXTNS,'description'),
	),
	(TEXTNS,'print-date'):(
		(TEXTNS,'date-value'),
		(TEXTNS,'fixed'),
		(STYLENS,'data-style-name'),
	),
	(TEXTNS,'print-time'):(
		(TEXTNS,'fixed'),
		(TEXTNS,'time-value'),
		(STYLENS,'data-style-name'),
	),
	(TEXTNS,'printed-by'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'reference-mark'):(
		(TEXTNS,'name'),
	),
	(TEXTNS,'reference-mark-end'):(
		(TEXTNS,'name'),
	),
	(TEXTNS,'reference-mark-start'):(
		(TEXTNS,'name'),
	),
	(TEXTNS,'ruby'):(
		(TEXTNS,'style-name'),
	),
	(TEXTNS,'ruby-base'):(
	),
	(TEXTNS,'ruby-text'):(
		(TEXTNS,'style-name'),
	),
	(TEXTNS,'s'):(
		(TEXTNS,'c'),
	),
	(TEXTNS,'script'):(
		(XLINKNS,'href'),
		(XLINKNS,'type'),
		(SCRIPTNS,'language'),
	),
	(TEXTNS,'section'):(
		(TEXTNS,'name'),
		(TEXTNS,'protection-key'),
		(TEXTNS,'style-name'),
		(TEXTNS,'protected'),
		(TEXTNS,'display'),
		(TEXTNS,'condition'),
	),
	(TEXTNS,'section-source'):(
		(TEXTNS,'filter-name'),
		(XLINKNS,'href'),
		(XLINKNS,'type'),
		(TEXTNS,'section-name'),
		(XLINKNS,'show'),
	),
	(TEXTNS,'sender-city'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'sender-company'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'sender-country'):(
		(TEXTNS,'fixed'),
	),
# allowed_attributes
	(TEXTNS,'sender-email'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'sender-fax'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'sender-firstname'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'sender-initials'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'sender-lastname'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'sender-phone-private'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'sender-phone-work'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'sender-position'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'sender-postal-code'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'sender-state-or-province'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'sender-street'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'sender-title'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'sequence'):(
		(TEXTNS,'formula'),
		(STYLENS,'num-format'),
		(STYLENS,'num-letter-sync'),
		(TEXTNS,'name'),
		(TEXTNS,'ref-name'),
	),
	(TEXTNS,'sequence-decl'):(
		(TEXTNS,'separation-character'),
		(TEXTNS,'display-outline-level'),
		(TEXTNS,'name'),
	),
	(TEXTNS,'sequence-decls'):(
	),
	(TEXTNS,'sequence-ref'):(
		(TEXTNS,'ref-name'),
		(TEXTNS,'reference-format'),
	),
	(TEXTNS,'sheet-name'):(
	),
	(TEXTNS,'soft-page-break'):(
	),
	(TEXTNS,'sort-key'):(
		(TEXTNS,'sort-ascending'),
		(TEXTNS,'key'),
	),
# allowed_attributes
	(TEXTNS,'span'):(
		(TEXTNS,'style-name'),
		(TEXTNS,'class-names'),
	),
	(TEXTNS,'subject'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'tab'):(
		(TEXTNS,'tab-ref'),
	),
	(TEXTNS,'table-formula'):(
		(TEXTNS,'formula'),
		(STYLENS,'data-style-name'),
		(TEXTNS,'display'),
	),
	(TEXTNS,'table-index'):(
		(TEXTNS,'protected'),
		(TEXTNS,'style-name'),
		(TEXTNS,'name'),
		(TEXTNS,'protection-key'),
	),
	(TEXTNS,'table-index-entry-template'):(
		(TEXTNS,'style-name'),
	),
	(TEXTNS,'table-index-source'):(
		(TEXTNS,'index-scope'),
		(TEXTNS,'caption-sequence-name'),
		(TEXTNS,'use-caption'),
		(TEXTNS,'caption-sequence-format'),
		(TEXTNS,'relative-tab-stop-position'),
	),
# allowed_attributes
	(TEXTNS,'table-of-content'):(
		(TEXTNS,'protected'),
		(TEXTNS,'style-name'),
		(TEXTNS,'name'),
		(TEXTNS,'protection-key'),
	),
	(TEXTNS,'table-of-content-entry-template'):(
		(TEXTNS,'style-name'),
		(TEXTNS,'outline-level'),
	),
	(TEXTNS,'table-of-content-source'):(
		(TEXTNS,'index-scope'),
		(TEXTNS,'outline-level'),
		(TEXTNS,'relative-tab-stop-position'),
		(TEXTNS,'use-index-marks'),
		(TEXTNS,'use-outline-level'),
		(TEXTNS,'use-index-source-styles'),
	),
	(TEXTNS,'template-name'):(
		(TEXTNS,'display'),
	),
	(TEXTNS,'text-input'):(
		(TEXTNS,'description'),
	),
	(TEXTNS,'time'):(
		(TEXTNS,'time-adjust'),
		(TEXTNS,'fixed'),
		(TEXTNS,'time-value'),
		(STYLENS,'data-style-name'),
	),
	(TEXTNS,'title'):(
		(TEXTNS,'fixed'),
	),
	(TEXTNS,'toc-mark'):(
		(TEXTNS,'string-value'),
		(TEXTNS,'outline-level'),
	),
	(TEXTNS,'toc-mark-end'):(
		(TEXTNS,'id'),
	),
	(TEXTNS,'toc-mark-start'):(
		(TEXTNS,'id'),
		(TEXTNS,'outline-level'),
	),
	(TEXTNS,'tracked-changes'):(
		(TEXTNS,'track-changes'),
	),
	(TEXTNS,'user-defined'):(
		(TEXTNS,'name'),
		(OFFICENS,'string-value'),
		(OFFICENS,'value'),
		(OFFICENS,'boolean-value'),
		(OFFICENS,'date-value'),
		(STYLENS,'data-style-name'),
		(TEXTNS,'fixed'),
		(OFFICENS,'time-value'),
	),
	(TEXTNS,'user-field-decl'):(
		(TEXTNS,'name'),
		(OFFICENS,'string-value'),
		(OFFICENS,'value'),
		(OFFICENS,'boolean-value'),
		(OFFICENS,'currency'),
		(OFFICENS,'date-value'),
		(OFFICENS,'value-type'),
		(TEXTNS,'formula'),
		(OFFICENS,'time-value'),
	),
	(TEXTNS,'user-field-decls'):(
	),
	(TEXTNS,'user-field-get'):(
		(STYLENS,'data-style-name'),
		(TEXTNS,'name'),
		(TEXTNS,'display'),
	),
# allowed_attributes
	(TEXTNS,'user-field-input'):(
		(STYLENS,'data-style-name'),
		(TEXTNS,'name'),
		(TEXTNS,'description'),
	),
	(TEXTNS,'user-index'):(
		(TEXTNS,'protected'),
		(TEXTNS,'style-name'),
		(TEXTNS,'name'),
		(TEXTNS,'protection-key'),
	),
	(TEXTNS,'user-index-entry-template'):(
		(TEXTNS,'style-name'),
		(TEXTNS,'outline-level'),
	),
	(TEXTNS,'user-index-mark'):(
		(TEXTNS,'index-name'),
		(TEXTNS,'string-value'),
		(TEXTNS,'outline-level'),
	),
	(TEXTNS,'user-index-mark-end'):(
		(TEXTNS,'id'),
		(TEXTNS,'outline-level'),
	),
	(TEXTNS,'user-index-mark-start'):(
		(TEXTNS,'index-name'),
		(TEXTNS,'id'),
		(TEXTNS,'outline-level'),
	),
# allowed_attributes
	(TEXTNS,'user-index-source'):(
		(TEXTNS,'copy-outline-levels'),
		(TEXTNS,'index-name'),
		(TEXTNS,'index-scope'),
		(TEXTNS,'relative-tab-stop-position'),
		(TEXTNS,'use-floating-frames'),
		(TEXTNS,'use-graphics'),
		(TEXTNS,'use-index-marks'),
		(TEXTNS,'use-objects'),
		(TEXTNS,'use-tables'),
	),
	(TEXTNS,'variable-decl'):(
		(TEXTNS,'name'),
		(OFFICENS,'value-type'),
	),
	(TEXTNS,'variable-decls'):(
	),
	(TEXTNS,'variable-get'):(
		(STYLENS,'data-style-name'),
		(TEXTNS,'name'),
		(TEXTNS,'display'),
	),
	(TEXTNS,'variable-input'):(
		(STYLENS,'data-style-name'),
		(TEXTNS,'display'),
		(TEXTNS,'name'),
		(OFFICENS,'value-type'),
		(TEXTNS,'description'),
	),
	(TEXTNS,'variable-set'):(
		(TEXTNS,'name'),
		(TEXTNS,'display'),
		(OFFICENS,'string-value'),
		(OFFICENS,'value'),
		(OFFICENS,'boolean-value'),
		(OFFICENS,'currency'),
		(OFFICENS,'date-value'),
		(STYLENS,'data-style-name'),
		(OFFICENS,'value-type'),
		(TEXTNS,'formula'),
		(OFFICENS,'time-value'),
	),
# allowed_attributes
}

########NEW FILE########
__FILENAME__ = load
#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2007-2008 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

# This script is to be embedded in opendocument.py later
# The purpose is to read an ODT/ODP/ODS file and create the datastructure
# in memory. The user should then be able to make operations and then save
# the structure again.

from xml.sax import make_parser,handler
from xml.sax.xmlreader import InputSource
import xml.sax.saxutils
from .element import Element
from .namespaces import OFFICENS
from io import StringIO

#
# Parse the XML files
#
class LoadParser(handler.ContentHandler):
    """ Extract headings from content.xml of an ODT file """
    triggers = (
       (OFFICENS, 'automatic-styles'), (OFFICENS, 'body'),
       (OFFICENS, 'font-face-decls'), (OFFICENS, 'master-styles'),
       (OFFICENS, 'meta'), (OFFICENS, 'scripts'),
       (OFFICENS, 'settings'), (OFFICENS, 'styles') )

    def __init__(self, document):
        self.doc = document
        self.data = []
        self.level = 0
        self.parse = False

    def characters(self, data):
        if self.parse == False:
            return
        self.data.append(data)

    def startElementNS(self, tag, qname, attrs):
        if tag in self.triggers:
            self.parse = True
        if self.doc._parsing != "styles.xml" and tag == (OFFICENS, 'font-face-decls'):
            self.parse = False
        if self.parse == False:
            return

        self.level = self.level + 1
        # Add any accumulated text content
        content = ''.join(self.data)
        if len(content.strip()) > 0:
            self.parent.addText(content, check_grammar=False)
            self.data = []
        # Create the element
        attrdict = {}
        for (att,value) in list(attrs.items()):
            attrdict[att] = value
        try:
            e = Element(qname = tag, qattributes=attrdict, check_grammar=False)
            self.curr = e
        except AttributeError as v:
            print("Error: %s" % v)

        if tag == (OFFICENS, 'automatic-styles'):
            e = self.doc.automaticstyles
        elif tag == (OFFICENS, 'body'):
            e = self.doc.body
        elif tag == (OFFICENS, 'master-styles'):
            e = self.doc.masterstyles
        elif tag == (OFFICENS, 'meta'):
            e = self.doc.meta
        elif tag == (OFFICENS,'scripts'):
            e = self.doc.scripts
        elif tag == (OFFICENS,'settings'):
            e = self.doc.settings
        elif tag == (OFFICENS,'styles'):
            e = self.doc.styles
        elif self.doc._parsing == "styles.xml" and tag == (OFFICENS, 'font-face-decls'):
            e = self.doc.fontfacedecls
        elif hasattr(self,'parent'):
            self.parent.addElement(e, check_grammar=False)
        self.parent = e


    def endElementNS(self, tag, qname):
        if self.parse == False:
            return
        self.level = self.level - 1
        str = ''.join(self.data)
        if len(str.strip()) > 0:
            self.curr.addText(str, check_grammar=False)
        self.data = []
        self.curr = self.curr.parentNode
        self.parent = self.curr
        if tag in self.triggers:
            self.parse = False

########NEW FILE########
__FILENAME__ = manifest
#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#
#

from .namespaces import MANIFESTNS
from .element import Element

# Autogenerated
def Manifest(**args):
    return Element(qname = (MANIFESTNS,'manifest'), **args)

def FileEntry(**args):
    return Element(qname = (MANIFESTNS,'file-entry'), **args)

def EncryptionData(**args):
    return Element(qname = (MANIFESTNS,'encryption-data'), **args)

def Algorithm(**args):
    return Element(qname = (MANIFESTNS,'algorithm'), **args)

def KeyDerivation(**args):
    return Element(qname = (MANIFESTNS,'key-derivation'), **args)


########NEW FILE########
__FILENAME__ = math
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import MATHNS
from .element import Element

# ODF 1.0 section 12.5
# Mathematical content is represented by MathML 2.0

# Autogenerated
def Math(**args):
    return Element(qname = (MATHNS,'math'), **args)


########NEW FILE########
__FILENAME__ = meta
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import METANS
from .element import Element

# Autogenerated
def AutoReload(**args):
    return Element(qname = (METANS,'auto-reload'), **args)

def CreationDate(**args):
    return Element(qname = (METANS,'creation-date'), **args)

def DateString(**args):
    return Element(qname = (METANS,'date-string'), **args)

def DocumentStatistic(**args):
    return Element(qname = (METANS,'document-statistic'), **args)

def EditingCycles(**args):
    return Element(qname = (METANS,'editing-cycles'), **args)

def EditingDuration(**args):
    return Element(qname = (METANS,'editing-duration'), **args)

def Generator(**args):
    return Element(qname = (METANS,'generator'), **args)

def HyperlinkBehaviour(**args):
    return Element(qname = (METANS,'hyperlink-behaviour'), **args)

def InitialCreator(**args):
    return Element(qname = (METANS,'initial-creator'), **args)

def Keyword(**args):
    return Element(qname = (METANS,'keyword'), **args)

def PrintDate(**args):
    return Element(qname = (METANS,'print-date'), **args)

def PrintedBy(**args):
    return Element(qname = (METANS,'printed-by'), **args)

def Template(**args):
    return Element(qname = (METANS,'template'), **args)

def UserDefined(**args):
    return Element(qname = (METANS,'user-defined'), **args)


########NEW FILE########
__FILENAME__ = namespaces
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2010 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#
TOOLSVERSION = "ODFPY/0.9.3"

ANIMNS         = "urn:oasis:names:tc:opendocument:xmlns:animation:1.0"
DBNS           = "urn:oasis:names:tc:opendocument:xmlns:database:1.0"
CHARTNS        = "urn:oasis:names:tc:opendocument:xmlns:chart:1.0"
CONFIGNS       = "urn:oasis:names:tc:opendocument:xmlns:config:1.0"
#DBNS           = u"http://openoffice.org/2004/database"
DCNS           = "http://purl.org/dc/elements/1.1/"
DOMNS          = "http://www.w3.org/2001/xml-events"
DR3DNS         = "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0"
DRAWNS         = "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0"
FIELDNS        = "urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0"
FONS           = "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0"
FORMNS         = "urn:oasis:names:tc:opendocument:xmlns:form:1.0"
GRDDLNS        = "http://www.w3.org/2003/g/data-view#"
KOFFICENS      = "http://www.koffice.org/2005/"
MANIFESTNS     = "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0"
MATHNS         = "http://www.w3.org/1998/Math/MathML"
METANS         = "urn:oasis:names:tc:opendocument:xmlns:meta:1.0"
NUMBERNS       = "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0"
OFFICENS       = "urn:oasis:names:tc:opendocument:xmlns:office:1.0"
OFNS           = "urn:oasis:names:tc:opendocument:xmlns:of:1.2"
OOONS          = "http://openoffice.org/2004/office"
OOOWNS         = "http://openoffice.org/2004/writer"
OOOCNS         = "http://openoffice.org/2004/calc"
PRESENTATIONNS = "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0"
RDFANS         = "http://docs.oasis-open.org/opendocument/meta/rdfa#"
RPTNS          = "http://openoffice.org/2005/report"
SCRIPTNS       = "urn:oasis:names:tc:opendocument:xmlns:script:1.0"
SMILNS         = "urn:oasis:names:tc:opendocument:xmlns:smil-compatible:1.0"
STYLENS        = "urn:oasis:names:tc:opendocument:xmlns:style:1.0"
SVGNS          = "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0"
TABLENS        = "urn:oasis:names:tc:opendocument:xmlns:table:1.0"
TEXTNS         = "urn:oasis:names:tc:opendocument:xmlns:text:1.0"
XFORMSNS       = "http://www.w3.org/2002/xforms"
XLINKNS        = "http://www.w3.org/1999/xlink"
XMLNS          = "http://www.w3.org/XML/1998/namespace"
XSDNS          = "http://www.w3.org/2001/XMLSchema"
XSINS          = "http://www.w3.org/2001/XMLSchema-instance"

nsdict = {
   ANIMNS: 'anim',
   CHARTNS: 'chart',
   CONFIGNS: 'config',
   DBNS: 'db',
   DCNS: 'dc',
   DOMNS: 'dom',
   DR3DNS: 'dr3d',
   DRAWNS: 'draw',
   FIELDNS: 'field',
   FONS: 'fo',
   FORMNS: 'form',
   GRDDLNS: 'grddl',
   KOFFICENS: 'koffice',
   MANIFESTNS: 'manifest',
   MATHNS: 'math',
   METANS: 'meta',
   NUMBERNS: 'number',
   OFFICENS: 'office',
   OFNS: 'of',
   OOONS: 'ooo',
   OOOWNS: 'ooow',
   OOOCNS: 'oooc',
   PRESENTATIONNS: 'presentation',
   RDFANS: 'rdfa',
   RPTNS:  'rpt',
   SCRIPTNS: 'script',
   SMILNS: 'smil',
   STYLENS: 'style',
   SVGNS: 'svg',
   TABLENS: 'table',
   TEXTNS: 'text',
   XFORMSNS: 'xforms',
   XLINKNS: 'xlink',
   XMLNS: 'xml',
   XSDNS: 'xsd',
   XSINS: 'xsi',
}

########NEW FILE########
__FILENAME__ = number
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import NUMBERNS
from .element import Element
from .style import StyleElement


# Autogenerated
def AmPm(**args):
    return Element(qname = (NUMBERNS,'am-pm'), **args)

def Boolean(**args):
    return Element(qname = (NUMBERNS,'boolean'), **args)

def BooleanStyle(**args):
    return StyleElement(qname = (NUMBERNS,'boolean-style'), **args)

def CurrencyStyle(**args):
    return StyleElement(qname = (NUMBERNS,'currency-style'), **args)

def CurrencySymbol(**args):
    return Element(qname = (NUMBERNS,'currency-symbol'), **args)

def DateStyle(**args):
    return StyleElement(qname = (NUMBERNS,'date-style'), **args)

def Day(**args):
    return Element(qname = (NUMBERNS,'day'), **args)

def DayOfWeek(**args):
    return Element(qname = (NUMBERNS,'day-of-week'), **args)

def EmbeddedText(**args):
    return Element(qname = (NUMBERNS,'embedded-text'), **args)

def Era(**args):
    return Element(qname = (NUMBERNS,'era'), **args)

def Fraction(**args):
    return Element(qname = (NUMBERNS,'fraction'), **args)

def Hours(**args):
    return Element(qname = (NUMBERNS,'hours'), **args)

def Minutes(**args):
    return Element(qname = (NUMBERNS,'minutes'), **args)

def Month(**args):
    return Element(qname = (NUMBERNS,'month'), **args)

def Number(**args):
    return Element(qname = (NUMBERNS,'number'), **args)

def NumberStyle(**args):
    return StyleElement(qname = (NUMBERNS,'number-style'), **args)

def PercentageStyle(**args):
    return StyleElement(qname = (NUMBERNS,'percentage-style'), **args)

def Quarter(**args):
    return Element(qname = (NUMBERNS,'quarter'), **args)

def ScientificNumber(**args):
    return Element(qname = (NUMBERNS,'scientific-number'), **args)

def Seconds(**args):
    return Element(qname = (NUMBERNS,'seconds'), **args)

def Text(**args):
    return Element(qname = (NUMBERNS,'text'), **args)

def TextContent(**args):
    return Element(qname = (NUMBERNS,'text-content'), **args)

def TextStyle(**args):
    return StyleElement(qname = (NUMBERNS,'text-style'), **args)

def TimeStyle(**args):
    return StyleElement(qname = (NUMBERNS,'time-style'), **args)

def WeekOfYear(**args):
    return Element(qname = (NUMBERNS,'week-of-year'), **args)

def Year(**args):
    return Element(qname = (NUMBERNS,'year'), **args)


########NEW FILE########
__FILENAME__ = odf2moinmoin
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2008 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# See http://trac.edgewall.org/wiki/WikiFormatting
#
# Contributor(s):
#

import sys, zipfile, xml.dom.minidom
from .namespaces import nsdict
from .elementtypes import *

IGNORED_TAGS = [
    'draw:a'
    'draw:g',
    'draw:line',
    'draw:object-ole',
    'office:annotation',
    'presentation:notes',
    'svg:desc',
] + [ nsdict[item[0]]+":"+item[1] for item in empty_elements]

INLINE_TAGS = [ nsdict[item[0]]+":"+item[1] for item in inline_elements]


class TextProps:
    """ Holds properties for a text style. """

    def __init__(self):

        self.italic = False
        self.bold = False
        self.fixed = False
        self.underlined = False
        self.strikethrough = False
        self.superscript = False
        self.subscript = False

    def setItalic(self, value):
        if value == "italic":
            self.italic = True
        elif value == "normal":
            self.italic = False

    def setBold(self, value):
        if value == "bold":
            self.bold = True
        elif value == "normal":
            self.bold = False

    def setFixed(self, value):
        self.fixed = value

    def setUnderlined(self, value):
        if value and value != "none":
            self.underlined = True

    def setStrikethrough(self, value):
        if value and value != "none":
            self.strikethrough = True

    def setPosition(self, value):
        if value is None or value == '':
            return
        posisize = value.split(' ')
        textpos = posisize[0]
        if textpos.find('%') == -1:
            if textpos == "sub":
                self.superscript = False
                self.subscript = True
            elif textpos == "super":
                self.superscript = True
                self.subscript = False
        else:
            itextpos = int(textpos[:textpos.find('%')])
            if itextpos > 10:
                self.superscript = False
                self.subscript = True
            elif itextpos < -10:
                self.superscript = True
                self.subscript = False

    def __str__(self):

        return "[italic=%s, bold=i%s, fixed=%s]" % (str(self.italic),
                                          str(self.bold),
                                          str(self.fixed))

class ParagraphProps:
    """ Holds properties of a paragraph style. """

    def __init__(self):

        self.blockquote = False
        self.headingLevel = 0
        self.code = False
        self.title = False
        self.indented = 0

    def setIndented(self, value):
        self.indented = value

    def setHeading(self, level):
        self.headingLevel = level

    def setTitle(self, value):
        self.title = value

    def setCode(self, value):
        self.code = value


    def __str__(self):

        return "[bq=%s, h=%d, code=%s]" % (str(self.blockquote),
                                           self.headingLevel,
                                           str(self.code))


class ListProperties:
    """ Holds properties for a list style. """

    def __init__(self):
        self.ordered = False

    def setOrdered(self, value):
        self.ordered = value



class ODF2MoinMoin(object):


    def __init__(self, filepath):
        self.footnotes = []
        self.footnoteCounter = 0
        self.textStyles = {"Standard": TextProps()}
        self.paragraphStyles = {"Standard": ParagraphProps()}
        self.listStyles = {}
        self.fixedFonts = []
        self.hasTitle = 0
        self.lastsegment = None

        # Tags
        self.elements = {
         'draw:page': self.textToString,
         'draw:frame': self.textToString,
         'draw:image': self.draw_image,
         'draw:text-box': self.textToString,
         'text:a': self.text_a,
         'text:note': self.text_note,
        }
        for tag in IGNORED_TAGS:
            self.elements[tag] = self.do_nothing

        for tag in INLINE_TAGS:
            self.elements[tag] = self.inline_markup
        self.elements['text:line-break'] = self.text_line_break
        self.elements['text:s'] = self.text_s
        self.elements['text:tab'] = self.text_tab

        self.load(filepath)

    def processFontDeclarations(self, fontDecl):
        """ Extracts necessary font information from a font-declaration
            element.
            """
        for fontFace in fontDecl.getElementsByTagName("style:font-face"):
            if fontFace.getAttribute("style:font-pitch") == "fixed":
                self.fixedFonts.append(fontFace.getAttribute("style:name"))



    def extractTextProperties(self, style, parent=None):
        """ Extracts text properties from a style element. """

        textProps = TextProps()

        if parent:
            parentProp = self.textStyles.get(parent, None)
            if parentProp:
                textProp = parentProp

        textPropEl = style.getElementsByTagName("style:text-properties")
        if not textPropEl: return textProps

        textPropEl = textPropEl[0]

        textProps.setItalic(textPropEl.getAttribute("fo:font-style"))
        textProps.setBold(textPropEl.getAttribute("fo:font-weight"))
        textProps.setUnderlined(textPropEl.getAttribute("style:text-underline-style"))
        textProps.setStrikethrough(textPropEl.getAttribute("style:text-line-through-style"))
        textProps.setPosition(textPropEl.getAttribute("style:text-position"))

        if textPropEl.getAttribute("style:font-name") in self.fixedFonts:
            textProps.setFixed(True)

        return textProps

    def extractParagraphProperties(self, style, parent=None):
        """ Extracts paragraph properties from a style element. """

        paraProps = ParagraphProps()

        name = style.getAttribute("style:name")

        if name.startswith("Heading_20_"):
            level = name[11:]
            try:
                level = int(level)
                paraProps.setHeading(level)
            except:
                level = 0

        if name == "Title":
            paraProps.setTitle(True)

        paraPropEl = style.getElementsByTagName("style:paragraph-properties")
        if paraPropEl:
            paraPropEl = paraPropEl[0]
            leftMargin = paraPropEl.getAttribute("fo:margin-left")
            if leftMargin:
                try:
                    leftMargin = float(leftMargin[:-2])
                    if leftMargin > 0.01:
                        paraProps.setIndented(True)
                except:
                    pass

        textProps = self.extractTextProperties(style)
        if textProps.fixed:
            paraProps.setCode(True)

        return paraProps


    def processStyles(self, styleElements):
        """ Runs through "style" elements extracting necessary information.
        """

        for style in styleElements:

            name = style.getAttribute("style:name")

            if name == "Standard": continue

            family = style.getAttribute("style:family")
            parent = style.getAttribute("style:parent-style-name")

            if family == "text":
                self.textStyles[name] = self.extractTextProperties(style, parent)

            elif family == "paragraph":
                self.paragraphStyles[name] = \
                                 self.extractParagraphProperties(style, parent)
                self.textStyles[name] = self.extractTextProperties(style, parent)

    def processListStyles(self, listStyleElements):

        for style in listStyleElements:
            name = style.getAttribute("style:name")

            prop = ListProperties()
            if style.hasChildNodes():
                subitems = [el for el in style.childNodes
                     if el.nodeType == xml.dom.Node.ELEMENT_NODE
                     and el.tagName == "text:list-level-style-number"]
                if len(subitems) > 0:
                    prop.setOrdered(True)

            self.listStyles[name] = prop


    def load(self, filepath):
        """ Loads an ODT file. """

        zip = zipfile.ZipFile(filepath)

        styles_doc = xml.dom.minidom.parseString(zip.read("styles.xml"))
        fontfacedecls = styles_doc.getElementsByTagName("office:font-face-decls")
        if fontfacedecls:
            self.processFontDeclarations(fontfacedecls[0])
        self.processStyles(styles_doc.getElementsByTagName("style:style"))
        self.processListStyles(styles_doc.getElementsByTagName("text:list-style"))

        self.content = xml.dom.minidom.parseString(zip.read("content.xml"))
        fontfacedecls = self.content.getElementsByTagName("office:font-face-decls")
        if fontfacedecls:
            self.processFontDeclarations(fontfacedecls[0])

        self.processStyles(self.content.getElementsByTagName("style:style"))
        self.processListStyles(self.content.getElementsByTagName("text:list-style"))

    def compressCodeBlocks(self, text):
        """ Removes extra blank lines from code blocks. """

        return text
        lines = text.split("\n")
        buffer = []
        numLines = len(lines)
        for i in range(numLines):

            if (lines[i].strip() or i == numLines-1  or i == 0 or
                not ( lines[i-1].startswith("    ")
                      and lines[i+1].startswith("    ") ) ):
                buffer.append("\n" + lines[i])

        return ''.join(buffer)

#-----------------------------------
    def do_nothing(self, node):
        return ''

    def draw_image(self, node):
        """
        """

        link = node.getAttribute("xlink:href")
        if link and link[:2] == './': # Indicates a sub-object, which isn't supported
            return "%s\n" % link
        if link and link[:9] == 'Pictures/':
            link = link[9:]
        return "[[Image(%s)]]\n" % link

    def text_a(self, node):
        text = self.textToString(node)
        link = node.getAttribute("xlink:href")
        if link.strip() == text.strip():
            return "[%s] " % link.strip()
        else:
            return "[%s %s] " % (link.strip(), text.strip())


    def text_line_break(self, node):
        return "[[BR]]"

    def text_note(self, node):
        cite = (node.getElementsByTagName("text:note-citation")[0]
                    .childNodes[0].nodeValue)
        body = (node.getElementsByTagName("text:note-body")[0]
                    .childNodes[0])
        self.footnotes.append((cite, self.textToString(body)))
        return "^%s^" % cite

    def text_s(self, node):
        try:
            num = int(node.getAttribute("text:c"))
            return " "*num
        except:
            return " "

    def text_tab(self, node):
        return "    "

    def inline_markup(self, node):
        text = self.textToString(node)

        if not text.strip():
            return ''  # don't apply styles to white space

        styleName = node.getAttribute("text:style-name")
        style = self.textStyles.get(styleName, TextProps())

        if style.fixed:
            return "`" + text + "`"

        mark = []
        if style:
            if style.italic:
                mark.append("''")
            if style.bold:
                mark.append("'''")
            if style.underlined:
                mark.append("__")
            if style.strikethrough:
                mark.append("~~")
            if style.superscript:
                mark.append("^")
            if style.subscript:
                mark.append(",,")
        revmark = mark[:]
        revmark.reverse()
        return "%s%s%s" % (''.join(mark), text, ''.join(revmark))

#-----------------------------------
    def listToString(self, listElement, indent = 0):

        self.lastsegment = listElement.tagName
        buffer = []

        styleName = listElement.getAttribute("text:style-name")
        props = self.listStyles.get(styleName, ListProperties())

        i = 0
        for item in listElement.childNodes:
            buffer.append(" "*indent)
            i += 1
            if props.ordered:
                number = str(i)
                number = " " + number + ". "
                buffer.append(" 1. ")
            else:
                buffer.append(" * ")
            subitems = [el for el in item.childNodes
                          if el.tagName in ["text:p", "text:h", "text:list"]]
            for subitem in subitems:
                if subitem.tagName == "text:list":
                    buffer.append("\n")
                    buffer.append(self.listToString(subitem, indent+3))
                else:
                    buffer.append(self.paragraphToString(subitem, indent+3))
                self.lastsegment = subitem.tagName
            self.lastsegment = item.tagName
            buffer.append("\n")

        return ''.join(buffer)

    def tableToString(self, tableElement):
        """ MoinMoin uses || to delimit table cells
        """

        self.lastsegment = tableElement.tagName
        buffer = []

        for item in tableElement.childNodes:
            self.lastsegment = item.tagName
            if item.tagName == "table:table-header-rows":
                buffer.append(self.tableToString(item))
            if item.tagName == "table:table-row":
                buffer.append("\n||")
                for cell in item.childNodes:
                    buffer.append(self.inline_markup(cell))
                    buffer.append("||")
                    self.lastsegment = cell.tagName
        return ''.join(buffer)


    def toString(self):
        """ Converts the document to a string.
            FIXME: Result from second call differs from first call
        """
        body = self.content.getElementsByTagName("office:body")[0]
        text = body.childNodes[0]

        buffer = []

        paragraphs = [el for el in text.childNodes
                      if el.tagName in ["draw:page", "text:p", "text:h","text:section",
                                        "text:list", "table:table"]]

        for paragraph in paragraphs:
            if paragraph.tagName == "text:list":
                text = self.listToString(paragraph)
            elif paragraph.tagName == "text:section":
                text = self.textToString(paragraph)
            elif paragraph.tagName == "table:table":
                text = self.tableToString(paragraph)
            else:
                text = self.paragraphToString(paragraph)
            if text:
                buffer.append(text)

        if self.footnotes:

            buffer.append("----")
            for cite, body in self.footnotes:
                buffer.append("%s: %s" % (cite, body))


        buffer.append("")
        return self.compressCodeBlocks('\n'.join(buffer))


    def textToString(self, element):

        buffer = []

        for node in element.childNodes:

            if node.nodeType == xml.dom.Node.TEXT_NODE:
                buffer.append(node.nodeValue)

            elif node.nodeType == xml.dom.Node.ELEMENT_NODE:
                tag = node.tagName

                if tag in ("draw:text-box", "draw:frame"):
                    buffer.append(self.textToString(node))

                elif tag in ("text:p", "text:h"):
                    text = self.paragraphToString(node)
                    if text:
                        buffer.append(text)
                elif tag == "text:list":
                    buffer.append(self.listToString(node))
                else:
                    method = self.elements.get(tag)
                    if method:
                        buffer.append(method(node))
                    else:
                        buffer.append(" {" + tag + "} ")

        return ''.join(buffer)

    def paragraphToString(self, paragraph, indent = 0):

        dummyParaProps = ParagraphProps()

        style_name = paragraph.getAttribute("text:style-name")
        paraProps = self.paragraphStyles.get(style_name, dummyParaProps)
        text = self.inline_markup(paragraph)

        if paraProps and not paraProps.code:
            text = text.strip()

        if paragraph.tagName == "text:p" and self.lastsegment == "text:p":
            text = "\n" + text

        self.lastsegment = paragraph.tagName

        if paraProps.title:
            self.hasTitle = 1
            return "= " + text + " =\n"

        outlinelevel = paragraph.getAttribute("text:outline-level")
        if outlinelevel:

            level = int(outlinelevel)
            if self.hasTitle: level += 1

            if level >= 1:
                return "=" * level + " " + text + " " + "=" * level + "\n"

        elif paraProps.code:
            return "{{{\n" + text + "\n}}}\n"

        if paraProps.indented:
            return self.wrapParagraph(text, indent = indent, blockquote = True)

        else:
            return self.wrapParagraph(text, indent = indent)


    def wrapParagraph(self, text, indent = 0, blockquote=False):

        counter = 0
        buffer = []
        LIMIT = 50

        if blockquote:
            buffer.append("  ")

        return ''.join(buffer) + text
        # Unused from here
        for token in text.split():

            if counter > LIMIT - indent:
                buffer.append("\n" + " "*indent)
                if blockquote:
                    buffer.append("  ")
                counter = 0

            buffer.append(token + " ")
            counter += len(token)

        return ''.join(buffer)

########NEW FILE########
__FILENAME__ = odf2xhtml
#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2010 Sren Roug, European Environment Agency
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#
#import pdb
#pdb.set_trace()
from xml.sax import handler
from xml.sax.saxutils import escape, quoteattr
from xml.dom import Node

from .opendocument import load

from .namespaces import ANIMNS, CHARTNS, CONFIGNS, DCNS, DR3DNS, DRAWNS, FONS, \
  FORMNS, MATHNS, METANS, NUMBERNS, OFFICENS, PRESENTATIONNS, SCRIPTNS, \
  SMILNS, STYLENS, SVGNS, TABLENS, TEXTNS, XLINKNS

# Handling of styles
#
# First there are font face declarations. These set up a font style that will be
# referenced from a text-property. The declaration describes the font making
# it possible for the application to find a similar font should the system not
# have that particular one. The StyleToCSS stores these attributes to be used
# for the CSS2 font declaration.
#
# Then there are default-styles. These set defaults for various style types:
#  "text", "paragraph", "section", "ruby", "table", "table-column", "table-row",
#  "table-cell", "graphic", "presentation", "drawing-page", "chart".
# Since CSS2 can't refer to another style, ODF2XHTML add these to all
# styles unless overridden.
#
# The real styles are declared in the <style:style> element. They have a
# family referring to the default-styles, and may have a parent style.
# 
# Styles have scope. The same name can be used for both paragraph and
# character etc. styles Since CSS2 has no scope we use a prefix. (Not elegant)
# In ODF a style can have a parent, these parents can be chained.

class StyleToCSS:
    """ The purpose of the StyleToCSS class is to contain the rules to convert
        ODF styles to CSS2. Since it needs the generic fonts, it would probably
        make sense to also contain the Styles in a dict as well..
    """

    def __init__(self):
        # Font declarations
        self.fontdict = {}

        # Fill-images from presentations for backgrounds
        self.fillimages = {}

        self.ruleconversions = {
            (DRAWNS,'fill-image-name'): self.c_drawfillimage,
            (FONS,"background-color"): self.c_fo,
            (FONS,"border"): self.c_fo,
            (FONS,"border-bottom"): self.c_fo,
            (FONS,"border-left"): self.c_fo,
            (FONS,"border-right"): self.c_fo,
            (FONS,"border-top"): self.c_fo,
            (FONS,"color"): self.c_fo,
            (FONS,"font-family"): self.c_fo,
            (FONS,"font-size"): self.c_fo,
            (FONS,"font-style"): self.c_fo,
            (FONS,"font-variant"): self.c_fo,
            (FONS,"font-weight"): self.c_fo,
            (FONS,"line-height"): self.c_fo,
            (FONS,"margin"): self.c_fo,
            (FONS,"margin-bottom"): self.c_fo,
            (FONS,"margin-left"): self.c_fo,
            (FONS,"margin-right"): self.c_fo,
            (FONS,"margin-top"): self.c_fo,
            (FONS,"min-height"): self.c_fo,
            (FONS,"padding"): self.c_fo,
            (FONS,"padding-bottom"): self.c_fo,
            (FONS,"padding-left"): self.c_fo,
            (FONS,"padding-right"): self.c_fo,
            (FONS,"padding-top"): self.c_fo,
            (FONS,"page-width"): self.c_page_width,
            (FONS,"page-height"): self.c_page_height,
            (FONS,"text-align"): self.c_text_align,
            (FONS,"text-indent") :self.c_fo,
            (TABLENS,'border-model') :self.c_border_model,
            (STYLENS,'column-width') : self.c_width,
            (STYLENS,"font-name"): self.c_fn,
            (STYLENS,'horizontal-pos'): self.c_hp,
            (STYLENS,'text-position'): self.c_text_position,
            (STYLENS,'text-line-through-style'): self.c_text_line_through_style,
            (STYLENS,'text-underline-style'): self.c_text_underline_style,
            (STYLENS,'width') : self.c_width,
            # FIXME Should do style:vertical-pos here
        }

    def save_font(self, name, family, generic):
        """ It is possible that the HTML browser doesn't know how to
            show a particular font. Fortunately ODF provides generic fallbacks.
            Unfortunately they are not the same as CSS2.
            CSS2: serif, sans-serif, cursive, fantasy, monospace
            ODF: roman, swiss, modern, decorative, script, system
            This method put the font and fallback into a dictionary
        """
        htmlgeneric = "sans-serif"
        if   generic == "roman": htmlgeneric = "serif"
        elif generic == "swiss": htmlgeneric = "sans-serif"
        elif generic == "modern": htmlgeneric = "monospace"
        elif generic == "decorative": htmlgeneric = "sans-serif"
        elif generic == "script": htmlgeneric = "monospace"
        elif generic == "system": htmlgeneric = "serif"
        self.fontdict[name] = (family, htmlgeneric)

    def c_drawfillimage(self, ruleset, sdict, rule, val):
        """ Fill a figure with an image. Since CSS doesn't let you resize images
            this should really be implemented as an absolutely position <img>
            with a width and a height
        """
        sdict['background-image'] = "url('%s')" % self.fillimages[val]

    def c_fo(self, ruleset, sdict, rule, val):
        """ XSL formatting attributes """
        selector = rule[1]
        sdict[selector] = val

    def c_border_model(self, ruleset, sdict, rule, val):
        """ Convert to CSS2 border model """
        if val == 'collapsing':
            sdict['border-collapse'] ='collapse'
        else:
            sdict['border-collapse'] ='separate'

    def c_width(self, ruleset, sdict, rule, val):
        """ Set width of box """
        sdict['width'] = val

    def c_text_align(self, ruleset, sdict, rule, align):
        """ Text align """
        if align == "start": align = "left"
        if align == "end": align = "right"
        sdict['text-align'] = align

    def c_fn(self, ruleset, sdict, rule, fontstyle):
        """ Generate the CSS font family
            A generic font can be found in two ways. In a <style:font-face>
            element or as a font-family-generic attribute in text-properties.
        """
        generic = ruleset.get((STYLENS,'font-family-generic') )
        if generic is not None:
            self.save_font(fontstyle, fontstyle, generic)
        family, htmlgeneric = self.fontdict.get(fontstyle, (fontstyle, 'serif'))
        sdict['font-family'] = '%s, %s'  % (family, htmlgeneric)

    def c_text_position(self, ruleset, sdict, rule, tp):
        """ Text position. This is used e.g. to make superscript and subscript
            This attribute can have one or two values.

            The first value must be present and specifies the vertical
            text position as a percentage that relates to the current font
            height or it takes one of the values sub or super. Negative
            percentages or the sub value place the text below the
            baseline. Positive percentages or the super value place
            the text above the baseline. If sub or super is specified,
            the application can choose an appropriate text position.

            The second value is optional and specifies the font height
            as a percentage that relates to the current font-height. If
            this value is not specified, an appropriate font height is
            used. Although this value may change the font height that
            is displayed, it never changes the current font height that
            is used for additional calculations.
        """
        textpos = tp.split(' ')
        if len(textpos) == 2 and textpos[0] != "0%":
            # Bug in OpenOffice. If vertical-align is 0% - ignore the text size.
            sdict['font-size'] = textpos[1]
        if textpos[0] == "super":
            sdict['vertical-align'] = "33%"
        elif textpos[0] == "sub":
            sdict['vertical-align'] = "-33%"
        else:
            sdict['vertical-align'] = textpos[0]

    def c_hp(self, ruleset, sdict, rule, hpos):
        #FIXME: Frames wrap-style defaults to 'parallel', graphics to 'none'.
        # It is properly set in the parent-styles, but the program doesn't
        # collect the information.
        wrap = ruleset.get((STYLENS,'wrap'),'parallel')
        # Can have: from-left, left, center, right, from-inside, inside, outside
        if hpos == "center":
            sdict['margin-left'] = "auto"
            sdict['margin-right'] = "auto"
#       else:
#           # force it to be *something* then delete it
#           sdict['margin-left'] = sdict['margin-right'] = ''
#           del sdict['margin-left'], sdict['margin-right']

        if hpos in ("right","outside"):
            if wrap in ( "left", "parallel","dynamic"):
                sdict['float'] = "right"
            elif wrap == "run-through":
                sdict['position'] = "absolute" # Simulate run-through
                sdict['top'] = "0"
                sdict['right'] = "0";
            else: # No wrapping
                sdict['margin-left'] = "auto"
                sdict['margin-right'] = "0px"
        elif hpos in ("left", "inside"):
            if wrap in ( "right", "parallel","dynamic"):
                sdict['float'] = "left"
            elif wrap == "run-through":
                sdict['position'] = "absolute" # Simulate run-through
                sdict['top'] = "0"
                sdict['left'] = "0"
            else: # No wrapping
                sdict['margin-left'] = "0px"
                sdict['margin-right'] = "auto"
        elif hpos in ("from-left", "from-inside"):
            if wrap in ( "right", "parallel"):
                sdict['float'] = "left"
            else:
                sdict['position'] = "relative" # No wrapping
                if (SVGNS,'x') in ruleset:
                    sdict['left'] = ruleset[(SVGNS,'x')]

    def c_page_width(self, ruleset, sdict, rule, val):
        """ Set width of box
            HTML doesn't really have a page-width. It is always 100% of the browser width
        """
        sdict['width'] = val

    def c_text_underline_style(self, ruleset, sdict, rule, val):
        """ Set underline decoration
            HTML doesn't really have a page-width. It is always 100% of the browser width
        """
        if val and val != "none":
            sdict['text-decoration'] = "underline"

    def c_text_line_through_style(self, ruleset, sdict, rule, val):
        """ Set underline decoration
            HTML doesn't really have a page-width. It is always 100% of the browser width
        """
        if val and val != "none":
            sdict['text-decoration'] = "line-through"

    def c_page_height(self, ruleset, sdict, rule, val):
        """ Set height of box """
        sdict['height'] = val

    def convert_styles(self, ruleset):
        """ Rule is a tuple of (namespace, name). If the namespace is '' then
            it is already CSS2
        """
        sdict = {}
        for rule,val in list(ruleset.items()):
            if rule[0] == '':
                sdict[rule[1]] = val
                continue
            method = self.ruleconversions.get(rule, None )
            if method:
                method(ruleset, sdict, rule, val)
        return sdict


class TagStack:
    def __init__(self):
        self.stack = []

    def push(self, tag, attrs):
        self.stack.append( (tag, attrs) )

    def pop(self):
        item = self.stack.pop()
        return item

    def stackparent(self):
        item = self.stack[-1]
        return item[1]

    def rfindattr(self, attr):
        """ Find a tag with the given attribute """
        for tag, attrs in self.stack:
            if attr in attrs:
                return attrs[attr]
        return None
    def count_tags(self, tag):
        c = 0
        for ttag, tattrs in self.stack:
            if ttag == tag: c = c + 1
        return c

special_styles = {
   'S-Emphasis':'em',
   'S-Citation':'cite',
   'S-Strong_20_Emphasis':'strong',
   'S-Variable':'var',
   'S-Definition':'dfn',
   'S-Teletype':'tt',
   'P-Heading_20_1':'h1',
   'P-Heading_20_2':'h2',
   'P-Heading_20_3':'h3',
   'P-Heading_20_4':'h4',
   'P-Heading_20_5':'h5',
   'P-Heading_20_6':'h6',
#  'P-Caption':'caption',
   'P-Addressee':'address',
#  'P-List_20_Heading':'dt',
#  'P-List_20_Contents':'dd',
   'P-Preformatted_20_Text':'pre',
#  'P-Table_20_Heading':'th',
#  'P-Table_20_Contents':'td',
#  'P-Text_20_body':'p'
}

#-----------------------------------------------------------------------------
#
# ODFCONTENTHANDLER
#
#-----------------------------------------------------------------------------
class ODF2XHTML(handler.ContentHandler):
    """ The ODF2XHTML parses an ODF file and produces XHTML"""

    def __init__(self, generate_css=True, embedable=False):
        # Tags
        self.generate_css = generate_css
        self.elements = {
        (DCNS, 'title'): (self.s_processcont, self.e_dc_title),
        (DCNS, 'language'): (self.s_processcont, self.e_dc_contentlanguage),
        (DCNS, 'creator'): (self.s_processcont, self.e_dc_creator),
        (DCNS, 'description'): (self.s_processcont, self.e_dc_metatag),
        (DCNS, 'date'): (self.s_processcont, self.e_dc_metatag),
        (DRAWNS, 'custom-shape'): (self.s_custom_shape, self.e_custom_shape),
        (DRAWNS, 'frame'): (self.s_draw_frame, self.e_draw_frame),
        (DRAWNS, 'image'): (self.s_draw_image, None),
        (DRAWNS, 'fill-image'): (self.s_draw_fill_image, None),
        (DRAWNS, "layer-set"):(self.s_ignorexml, None),
        (DRAWNS, 'object'): (self.s_draw_object, None),
        (DRAWNS, 'object-ole'): (self.s_draw_object_ole, None),
        (DRAWNS, 'page'): (self.s_draw_page, self.e_draw_page),
        (DRAWNS, 'text-box'): (self.s_draw_textbox, self.e_draw_textbox),
        (METANS, 'creation-date'):(self.s_processcont, self.e_dc_metatag),
        (METANS, 'generator'):(self.s_processcont, self.e_dc_metatag),
        (METANS, 'initial-creator'): (self.s_processcont, self.e_dc_metatag),
        (METANS, 'keyword'): (self.s_processcont, self.e_dc_metatag),
        (NUMBERNS, "boolean-style"):(self.s_ignorexml, None),
        (NUMBERNS, "currency-style"):(self.s_ignorexml, None),
        (NUMBERNS, "date-style"):(self.s_ignorexml, None),
        (NUMBERNS, "number-style"):(self.s_ignorexml, None),
        (NUMBERNS, "text-style"):(self.s_ignorexml, None),
        (OFFICENS, "annotation"):(self.s_ignorexml, None),
        (OFFICENS, "automatic-styles"):(self.s_office_automatic_styles, None),
        (OFFICENS, "document"):(self.s_office_document_content, self.e_office_document_content),
        (OFFICENS, "document-content"):(self.s_office_document_content, self.e_office_document_content),
        (OFFICENS, "forms"):(self.s_ignorexml, None),
        (OFFICENS, "master-styles"):(self.s_office_master_styles, None),
        (OFFICENS, "meta"):(self.s_ignorecont, None),
        (OFFICENS, "presentation"):(self.s_office_presentation, self.e_office_presentation),
        (OFFICENS, "spreadsheet"):(self.s_office_spreadsheet, self.e_office_spreadsheet),
        (OFFICENS, "styles"):(self.s_office_styles, None),
        (OFFICENS, "text"):(self.s_office_text, self.e_office_text),
        (OFFICENS, "scripts"):(self.s_ignorexml, None),
        (OFFICENS, "settings"):(self.s_ignorexml, None),
        (PRESENTATIONNS, "notes"):(self.s_ignorexml, None),
#       (STYLENS, "default-page-layout"):(self.s_style_default_page_layout, self.e_style_page_layout),
        (STYLENS, "default-page-layout"):(self.s_ignorexml, None),
        (STYLENS, "default-style"):(self.s_style_default_style, self.e_style_default_style),
        (STYLENS, "drawing-page-properties"):(self.s_style_handle_properties, None),
        (STYLENS, "font-face"):(self.s_style_font_face, None),
#       (STYLENS, "footer"):(self.s_style_footer, self.e_style_footer),
#       (STYLENS, "footer-style"):(self.s_style_footer_style, None),
        (STYLENS, "graphic-properties"):(self.s_style_handle_properties, None),
        (STYLENS, "handout-master"):(self.s_ignorexml, None),
#       (STYLENS, "header"):(self.s_style_header, self.e_style_header),
#       (STYLENS, "header-footer-properties"):(self.s_style_handle_properties, None),
#       (STYLENS, "header-style"):(self.s_style_header_style, None),
        (STYLENS, "master-page"):(self.s_style_master_page, None),
        (STYLENS, "page-layout-properties"):(self.s_style_handle_properties, None),
        (STYLENS, "page-layout"):(self.s_style_page_layout, self.e_style_page_layout),
#       (STYLENS, "page-layout"):(self.s_ignorexml, None),
        (STYLENS, "paragraph-properties"):(self.s_style_handle_properties, None),
        (STYLENS, "style"):(self.s_style_style, self.e_style_style),
        (STYLENS, "table-cell-properties"):(self.s_style_handle_properties, None),
        (STYLENS, "table-column-properties"):(self.s_style_handle_properties, None),
        (STYLENS, "table-properties"):(self.s_style_handle_properties, None),
        (STYLENS, "text-properties"):(self.s_style_handle_properties, None),
        (SVGNS, 'desc'): (self.s_ignorexml, None),
        (TABLENS, 'covered-table-cell'): (self.s_ignorexml, None),
        (TABLENS, 'table-cell'): (self.s_table_table_cell, self.e_table_table_cell),
        (TABLENS, 'table-column'): (self.s_table_table_column, None),
        (TABLENS, 'table-row'): (self.s_table_table_row, self.e_table_table_row),
        (TABLENS, 'table'): (self.s_table_table, self.e_table_table),
        (TEXTNS, 'a'): (self.s_text_a, self.e_text_a),
        (TEXTNS, "alphabetical-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, "bibliography-configuration"):(self.s_ignorexml, None),
        (TEXTNS, "bibliography-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, 'bookmark'): (self.s_text_bookmark, None),
        (TEXTNS, 'bookmark-start'): (self.s_text_bookmark, None),
        (TEXTNS, 'bookmark-ref'): (self.s_text_bookmark_ref, self.e_text_a),
        (TEXTNS, 'bookmark-ref-start'): (self.s_text_bookmark_ref, None),
        (TEXTNS, 'h'): (self.s_text_h, self.e_text_h),
        (TEXTNS, "illustration-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, 'line-break'):(self.s_text_line_break, None),
        (TEXTNS, "linenumbering-configuration"):(self.s_ignorexml, None),
        (TEXTNS, "list"):(self.s_text_list, self.e_text_list),
        (TEXTNS, "list-item"):(self.s_text_list_item, self.e_text_list_item),
        (TEXTNS, "list-level-style-bullet"):(self.s_text_list_level_style_bullet, self.e_text_list_level_style_bullet),
        (TEXTNS, "list-level-style-number"):(self.s_text_list_level_style_number, self.e_text_list_level_style_number),
        (TEXTNS, "list-style"):(None, None),
        (TEXTNS, "note"):(self.s_text_note, None),
        (TEXTNS, "note-body"):(self.s_text_note_body, self.e_text_note_body),
        (TEXTNS, "note-citation"):(None, self.e_text_note_citation),
        (TEXTNS, "notes-configuration"):(self.s_ignorexml, None),
        (TEXTNS, "object-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, 'p'): (self.s_text_p, self.e_text_p),
        (TEXTNS, 's'): (self.s_text_s, None),
        (TEXTNS, 'span'): (self.s_text_span, self.e_text_span),
        (TEXTNS, 'tab'): (self.s_text_tab, None),
        (TEXTNS, "table-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, "table-of-content-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, "user-index-source"):(self.s_text_x_source, self.e_text_x_source),
        }
        if embedable:
            self.make_embedable()
        self._resetobject()

    def set_plain(self):
        """ Tell the parser to not generate CSS """
        self.generate_css = False

    def set_embedable(self):
        """ Tells the converter to only output the parts inside the <body>"""
        self.elements[(OFFICENS, "text")] = (None,None)
        self.elements[(OFFICENS, "spreadsheet")] = (None,None)
        self.elements[(OFFICENS, "presentation")] = (None,None)
        self.elements[(OFFICENS, "document-content")] = (None,None)


    def add_style_file(self, stylefilename, media=None):
        """ Add a link to an external style file.
            Also turns of the embedding of styles in the HTML
        """
        self.use_internal_css = False
        self.stylefilename = stylefilename
        if media:
            self.metatags.append('<link rel="stylesheet" type="text/css" href="%s" media="%s"/>\n' % (stylefilename,media))
        else:
            self.metatags.append('<link rel="stylesheet" type="text/css" href="%s"/>\n' % (stylefilename))

    def _resetfootnotes(self):
        # Footnotes and endnotes
        self.notedict = {}
        self.currentnote = 0
        self.notebody = ''

    def _resetobject(self):
        self.lines = []
        self._wfunc = self._wlines
        self.xmlfile = ''
        self.title = ''
        self.language = ''
        self.creator = ''
        self.data = []
        self.tagstack = TagStack()
        self.htmlstack = []
        self.pstack = []
        self.processelem = True
        self.processcont = True
        self.listtypes = {}
        self.headinglevels = [0, 0,0,0,0,0, 0,0,0,0,0] # level 0 to 10
        self.use_internal_css = True
        self.cs = StyleToCSS()
        self.anchors = {}

        # Style declarations
        self.stylestack = []
        self.styledict = {}
        self.currentstyle = None

        self._resetfootnotes()

        # Tags from meta.xml
        self.metatags = []


    def writeout(self, s):
        if s != '':
            self._wfunc(s)

    def writedata(self):
        d = ''.join(self.data)
        if d != '':
            self.writeout(escape(d))

    def opentag(self, tag, attrs={}, block=False):
        """ Create an open HTML tag """
        self.htmlstack.append((tag,attrs,block))
        a = []
        for key,val in list(attrs.items()):
            a.append('''%s=%s''' % (key, quoteattr(val)))
        if len(a) == 0:
            self.writeout("<%s>" % tag)
        else:
            self.writeout("<%s %s>" % (tag, " ".join(a)))
        if block == True:
            self.writeout("\n")

    def closetag(self, tag, block=True):
        """ Close an open HTML tag """
        self.htmlstack.pop()
        self.writeout("</%s>" % tag)
        if block == True:
            self.writeout("\n")

    def emptytag(self, tag, attrs={}):
        a = []
        for key,val in list(attrs.items()):
            a.append('''%s=%s''' % (key, quoteattr(val)))
        self.writeout("<%s %s/>\n" % (tag, " ".join(a)))

#--------------------------------------------------
# Interface to parser
#--------------------------------------------------
    def characters(self, data):
        if self.processelem and self.processcont:
            self.data.append(data)

    def startElementNS(self, tag, qname, attrs):
        self.pstack.append( (self.processelem, self.processcont) )
        if self.processelem:
            method = self.elements.get(tag, (None, None) )[0]
            if method:
                self.handle_starttag(tag, method, attrs)
            else:
                self.unknown_starttag(tag,attrs)
        self.tagstack.push( tag, attrs )

    def endElementNS(self, tag, qname):
        stag, attrs = self.tagstack.pop()
        if self.processelem:
            method = self.elements.get(tag, (None, None) )[1]
            if method:
                self.handle_endtag(tag, attrs, method)
            else:
                self.unknown_endtag(tag, attrs)
        self.processelem, self.processcont = self.pstack.pop()

#--------------------------------------------------
    def handle_starttag(self, tag, method, attrs):
        method(tag,attrs)

    def handle_endtag(self, tag, attrs, method):
        method(tag, attrs)

    def unknown_starttag(self, tag, attrs):
        pass

    def unknown_endtag(self, tag, attrs):
        pass

    def s_ignorexml(self, tag, attrs):
        """ Ignore this xml element and all children of it
            It will automatically stop ignoring
        """
        self.processelem = False

    def s_ignorecont(self, tag, attrs):
        """ Stop processing the text nodes """
        self.processcont = False

    def s_processcont(self, tag, attrs):
        """ Start processing the text nodes """
        self.processcont = True

    def classname(self, attrs):
        """ Generate a class name from a style name """
        c = attrs.get((TEXTNS,'style-name'),'')
        c = c.replace(".","_")
        return c

    def get_anchor(self, name):
        """ Create a unique anchor id for a href name """
        if name not in self.anchors:
            self.anchors[name] = "anchor%03d" % (len(self.anchors) + 1)
        return self.anchors.get(name)


#--------------------------------------------------

    def purgedata(self):
        self.data = []

#-----------------------------------------------------------------------------
#
# Handle meta data
#
#-----------------------------------------------------------------------------
    def e_dc_title(self, tag, attrs):
        """ Get the title from the meta data and create a HTML <title>
        """
        self.title = ''.join(self.data)
        #self.metatags.append('<title>%s</title>\n' % escape(self.title))
        self.data = []

    def e_dc_metatag(self, tag, attrs):
        """ Any other meta data is added as a <meta> element
        """
        self.metatags.append('<meta name="%s" content=%s/>\n' % (tag[1], quoteattr(''.join(self.data))))
        self.data = []

    def e_dc_contentlanguage(self, tag, attrs):
        """ Set the content language. Identifies the targeted audience
        """
        self.language = ''.join(self.data)
        self.metatags.append('<meta http-equiv="content-language" content="%s"/>\n' % escape(self.language))
        self.data = []

    def e_dc_creator(self, tag, attrs):
        """ Set the content creator. Identifies the targeted audience
        """
        self.creator = ''.join(self.data)
        self.metatags.append('<meta http-equiv="creator" content="%s"/>\n' % escape(self.creator))
        self.data = []

    def s_custom_shape(self, tag, attrs):
        """ A <draw:custom-shape> is made into a <div> in HTML which is then styled
        """
        anchor_type = attrs.get((TEXTNS,'anchor-type'),'notfound')
        htmltag = 'div'
        name = "G-" + attrs.get( (DRAWNS,'style-name'), "")
        if name == 'G-':
            name = "PR-" + attrs.get( (PRESENTATIONNS,'style-name'), "")
        name = name.replace(".","_")
        if anchor_type == "paragraph":
            style = 'position:absolute;'
        elif anchor_type == 'char':
            style = "position:absolute;"
        elif anchor_type == 'as-char':
            htmltag = 'div'
            style = ''
        else:
            style = "position: absolute;"
        if (SVGNS,"width") in attrs:
            style = style + "width:" + attrs[(SVGNS,"width")] + ";"
        if (SVGNS,"height") in attrs:
            style = style + "height:" +  attrs[(SVGNS,"height")] + ";"
        if (SVGNS,"x") in attrs:
            style = style + "left:" +  attrs[(SVGNS,"x")] + ";"
        if (SVGNS,"y") in attrs:
            style = style + "top:" +  attrs[(SVGNS,"y")] + ";"
        if self.generate_css:
            self.opentag(htmltag, {'class': name, 'style': style})
        else:
            self.opentag(htmltag)

    def e_custom_shape(self, tag, attrs):
        """ End the <draw:frame>
        """
        self.closetag('div')

    def s_draw_frame(self, tag, attrs):
        """ A <draw:frame> is made into a <div> in HTML which is then styled
        """
        anchor_type = attrs.get((TEXTNS,'anchor-type'),'notfound')
        htmltag = 'div'
        name = "G-" + attrs.get( (DRAWNS,'style-name'), "")
        if name == 'G-':
            name = "PR-" + attrs.get( (PRESENTATIONNS,'style-name'), "")
        name = name.replace(".","_")
        if anchor_type == "paragraph":
            style = 'position:relative;'
        elif anchor_type == 'char':
            style = "position:relative;"
        elif anchor_type == 'as-char':
            htmltag = 'div'
            style = ''
        else:
            style = "position:absolute;"
        if (SVGNS,"width") in attrs:
            style = style + "width:" + attrs[(SVGNS,"width")] + ";"
        if (SVGNS,"height") in attrs:
            style = style + "height:" +  attrs[(SVGNS,"height")] + ";"
        if (SVGNS,"x") in attrs:
            style = style + "left:" +  attrs[(SVGNS,"x")] + ";"
        if (SVGNS,"y") in attrs:
            style = style + "top:" +  attrs[(SVGNS,"y")] + ";"
        if self.generate_css:
            self.opentag(htmltag, {'class': name, 'style': style})
        else:
            self.opentag(htmltag)

    def e_draw_frame(self, tag, attrs):
        """ End the <draw:frame>
        """
        self.closetag('div')

    def s_draw_fill_image(self, tag, attrs):
        name = attrs.get( (DRAWNS,'name'), "NoName")
        imghref = attrs[(XLINKNS,"href")]
        imghref = self.rewritelink(imghref)
        self.cs.fillimages[name] = imghref

    def rewritelink(self, imghref):
        """ Intended to be overloaded if you don't store your pictures
            in a Pictures subfolder
        """
        return imghref

    def s_draw_image(self, tag, attrs):
        """ A <draw:image> becomes an <img/> element
        """
        parent = self.tagstack.stackparent()
        anchor_type = parent.get((TEXTNS,'anchor-type'))
        imghref = attrs[(XLINKNS,"href")]
        imghref = self.rewritelink(imghref)
        htmlattrs = {'alt':"", 'src':imghref }
        if self.generate_css:
            if anchor_type != "char":
                htmlattrs['style'] = "display: block;"
        self.emptytag('img', htmlattrs)

    def s_draw_object(self, tag, attrs):
        """ A <draw:object> is embedded object in the document (e.g. spreadsheet in presentation).
        """
        objhref = attrs[(XLINKNS,"href")]
        # Remove leading "./": from "./Object 1" to "Object 1"
#       objhref = objhref [2:]
       
        # Not using os.path.join since it fails to find the file on Windows.
#       objcontentpath = '/'.join([objhref, 'content.xml'])

        for c in self.document.childnodes:
            if c.folder == objhref:
                self._walknode(c.topnode)

    def s_draw_object_ole(self, tag, attrs):
        """ A <draw:object-ole> is embedded OLE object in the document (e.g. MS Graph).
        """
        class_id = attrs[(DRAWNS,"class-id")]
        if class_id and class_id.lower() == "00020803-0000-0000-c000-000000000046": ## Microsoft Graph 97 Chart
            tagattrs = { 'name':'object_ole_graph', 'class':'ole-graph' }
            self.opentag('a', tagattrs)
            self.closetag('a', tagattrs)

    def s_draw_page(self, tag, attrs):
        """ A <draw:page> is a slide in a presentation. We use a <fieldset> element in HTML.
            Therefore if you convert a ODP file, you get a series of <fieldset>s.
            Override this for your own purpose.
        """
        name = attrs.get( (DRAWNS,'name'), "NoName")
        stylename = attrs.get( (DRAWNS,'style-name'), "")
        stylename = stylename.replace(".","_")
        masterpage = attrs.get( (DRAWNS,'master-page-name'),"")
        masterpage = masterpage.replace(".","_")
        if self.generate_css:
            self.opentag('fieldset', {'class':"DP-%s MP-%s" % (stylename, masterpage) })
        else:
            self.opentag('fieldset')
        self.opentag('legend')
        self.writeout(escape(name))
        self.closetag('legend')

    def e_draw_page(self, tag, attrs):
        self.closetag('fieldset')

    def s_draw_textbox(self, tag, attrs):
        style = ''
        if (FONS,"min-height") in attrs:
            style = style + "min-height:" +  attrs[(FONS,"min-height")] + ";"
        self.opentag('div')
#       self.opentag('div', {'style': style})

    def e_draw_textbox(self, tag, attrs):
        """ End the <draw:text-box>
        """
        self.closetag('div')

    def html_body(self, tag, attrs):
        self.writedata()
        if self.generate_css and self.use_internal_css:
            self.opentag('style', {'type':"text/css"}, True)
            self.writeout('/*<![CDATA[*/\n')
            self.generate_stylesheet()
            self.writeout('/*]]>*/\n')
            self.closetag('style')
        self.purgedata()
        self.closetag('head')
        self.opentag('body', block=True)

    default_styles = """
img { width: 100%; height: 100%; }
* { padding: 0; margin: 0;  background-color:white; }
body { margin: 0 1em; }
ol, ul { padding-left: 2em; }
"""

    def generate_stylesheet(self):
        for name in self.stylestack:
            styles = self.styledict.get(name)
            # Preload with the family's default style
            if '__style-family' in styles and styles['__style-family'] in self.styledict:
                familystyle = self.styledict[styles['__style-family']].copy()
                del styles['__style-family']
                for style, val in list(styles.items()):
                    familystyle[style] = val
                styles = familystyle
            # Resolve the remaining parent styles
            while '__parent-style-name' in styles and styles['__parent-style-name'] in self.styledict:
                parentstyle = self.styledict[styles['__parent-style-name']].copy()
                del styles['__parent-style-name']
                for style, val in list(styles.items()):
                    parentstyle[style] = val
                styles = parentstyle
            self.styledict[name] = styles
        # Write the styles to HTML
        self.writeout(self.default_styles)
        for name in self.stylestack:
            styles = self.styledict.get(name)
            css2 = self.cs.convert_styles(styles)
            self.writeout("%s {\n" % name)
            for style, val in list(css2.items()):
                self.writeout("\t%s: %s;\n" % (style, val) )
            self.writeout("}\n")

    def generate_footnotes(self):
        if self.currentnote == 0:
            return
        if self.generate_css:
            self.opentag('ol', {'style':'border-top: 1px solid black'}, True)
        else:
            self.opentag('ol')
        for key in range(1,self.currentnote+1):
            note = self.notedict[key]
#       for key,note in self.notedict.items():
            self.opentag('li', { 'id':"footnote-%d" % key })
#           self.opentag('sup')
#           self.writeout(escape(note['citation']))
#           self.closetag('sup', False)
            self.writeout(note['body'])
            self.closetag('li')
        self.closetag('ol')

    def s_office_automatic_styles(self, tag, attrs):
        if self.xmlfile == 'styles.xml':
            self.autoprefix = "A"
        else:
            self.autoprefix = ""

    def s_office_document_content(self, tag, attrs):
        """ First tag in the content.xml file"""
        self.writeout('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" ')
        self.writeout('"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">\n')
        self.opentag('html', {'xmlns':"http://www.w3.org/1999/xhtml"}, True)
        self.opentag('head', block=True)
        self.emptytag('meta', { 'http-equiv':"Content-Type", 'content':"text/html;charset=UTF-8"})
        for metaline in self.metatags:
            self.writeout(metaline)
        self.writeout('<title>%s</title>\n' % escape(self.title))

    def e_office_document_content(self, tag, attrs):
        """ Last tag """
        self.closetag('html')

    def s_office_master_styles(self, tag, attrs):
        """ """

    def s_office_presentation(self, tag, attrs):
        """ For some odd reason, OpenOffice Impress doesn't define a default-style
            for the 'paragraph'. We therefore force a standard when we see
            it is a presentation
        """
        self.styledict['p'] = {(FONS,'font-size'): "24pt" }
        self.styledict['presentation'] = {(FONS,'font-size'): "24pt" }
        self.html_body(tag, attrs)

    def e_office_presentation(self, tag, attrs):
        self.generate_footnotes()
        self.closetag('body')

    def s_office_spreadsheet(self, tag, attrs):
        self.html_body(tag, attrs)

    def e_office_spreadsheet(self, tag, attrs):
        self.generate_footnotes()
        self.closetag('body')

    def s_office_styles(self, tag, attrs):
        self.autoprefix = ""

    def s_office_text(self, tag, attrs):
        """ OpenDocument text """
        self.styledict['frame'] = { (STYLENS,'wrap'): 'parallel'}
        self.html_body(tag, attrs)

    def e_office_text(self, tag, attrs):
        self.generate_footnotes()
        self.closetag('body')

    def s_style_handle_properties(self, tag, attrs):
        """ Copy all attributes to a struct.
            We will later convert them to CSS2
        """
        for key,attr in list(attrs.items()):
            self.styledict[self.currentstyle][key] = attr


    familymap = {'frame':'frame', 'paragraph':'p', 'presentation':'presentation',
        'text':'span','section':'div',
        'table':'table','table-cell':'td','table-column':'col',
        'table-row':'tr','graphic':'graphic' }

    def s_style_default_style(self, tag, attrs):
        """ A default style is like a style on an HTML tag
        """
        family = attrs[(STYLENS,'family')]
        htmlfamily = self.familymap.get(family,'unknown')
        self.currentstyle = htmlfamily
#       self.stylestack.append(self.currentstyle)
        self.styledict[self.currentstyle] = {}

    def e_style_default_style(self, tag, attrs):
        self.currentstyle = None

    def s_style_font_face(self, tag, attrs):
        """ It is possible that the HTML browser doesn't know how to
            show a particular font. Luckily ODF provides generic fallbacks
            Unfortunately they are not the same as CSS2.
            CSS2: serif, sans-serif, cursive, fantasy, monospace
            ODF: roman, swiss, modern, decorative, script, system
        """
        name = attrs[(STYLENS,"name")]
        family = attrs[(SVGNS,"font-family")]
        generic = attrs.get( (STYLENS,'font-family-generic'),"" )
        self.cs.save_font(name, family, generic)

    def s_style_footer(self, tag, attrs):
        self.opentag('div', { 'id':"footer" })
        self.purgedata()

    def e_style_footer(self, tag, attrs):
        self.writedata()
        self.closetag('div')
        self.purgedata()

    def s_style_footer_style(self, tag, attrs):
        self.currentstyle = "@print #footer"
        self.stylestack.append(self.currentstyle)
        self.styledict[self.currentstyle] = {}

    def s_style_header(self, tag, attrs):
        self.opentag('div', { 'id':"header" })
        self.purgedata()

    def e_style_header(self, tag, attrs):
        self.writedata()
        self.closetag('div')
        self.purgedata()

    def s_style_header_style(self, tag, attrs):
        self.currentstyle = "@print #header"
        self.stylestack.append(self.currentstyle)
        self.styledict[self.currentstyle] = {}

    def s_style_default_page_layout(self, tag, attrs):
        """ Collect the formatting for the default page layout style.
        """
        self.currentstyle = "@page"
        self.stylestack.append(self.currentstyle)
        self.styledict[self.currentstyle] = {}

    def s_style_page_layout(self, tag, attrs):
        """ Collect the formatting for the page layout style.
            This won't work in CSS 2.1, as page identifiers are not allowed.
            It is legal in CSS3, but the rest of the application doesn't specify when to use what page layout
        """
        name = attrs[(STYLENS,'name')]
        name = name.replace(".","_")
        self.currentstyle = ".PL-" + name
        self.stylestack.append(self.currentstyle)
        self.styledict[self.currentstyle] = {}

    def e_style_page_layout(self, tag, attrs):
        """ End this style
        """
        self.currentstyle = None

    def s_style_master_page(self, tag, attrs):
        """ Collect the formatting for the page layout style.
        """
        name = attrs[(STYLENS,'name')]
        name = name.replace(".","_")

        self.currentstyle = ".MP-" + name
        self.stylestack.append(self.currentstyle)
        self.styledict[self.currentstyle] = {('','position'):'relative'}
        # Then load the pagelayout style if we find it
        pagelayout = attrs.get( (STYLENS,'page-layout-name'), None)
        if pagelayout:
            pagelayout = ".PL-" + pagelayout
            if pagelayout in self.styledict:
                styles = self.styledict[pagelayout]
                for style, val in list(styles.items()):
                    self.styledict[self.currentstyle][style] = val
            else:
                self.styledict[self.currentstyle]['__parent-style-name'] = pagelayout
        self.s_ignorexml(tag, attrs)

    # Short prefixes for class selectors
    _familyshort = {'drawing-page':'DP', 'paragraph':'P', 'presentation':'PR',
        'text':'S', 'section':'D',
         'table':'T', 'table-cell':'TD', 'table-column':'TC',
         'table-row':'TR', 'graphic':'G' }

    def s_style_style(self, tag, attrs):
        """ Collect the formatting for the style.
            Styles have scope. The same name can be used for both paragraph and
            character styles Since CSS has no scope we use a prefix. (Not elegant)
            In ODF a style can have a parent, these parents can be chained.
            We may not have encountered the parent yet, but if we have, we resolve it.
        """
        name = attrs[(STYLENS,'name')]
        name = name.replace(".","_")
        family = attrs[(STYLENS,'family')]
        htmlfamily = self.familymap.get(family,'unknown')
        sfamily = self._familyshort.get(family,'X')
        name = "%s%s-%s" % (self.autoprefix, sfamily, name)
        parent = attrs.get( (STYLENS,'parent-style-name') )
        self.currentstyle = special_styles.get(name,"."+name)
        self.stylestack.append(self.currentstyle)
        if self.currentstyle not in self.styledict:
            self.styledict[self.currentstyle] = {}

        self.styledict[self.currentstyle]['__style-family'] = htmlfamily

        # Then load the parent style if we find it
        if parent:
            parent = "%s-%s" % (sfamily, parent)
            parent = special_styles.get(parent, "."+parent)
            if parent in self.styledict:
                styles = self.styledict[parent]
                for style, val in list(styles.items()):
                    self.styledict[self.currentstyle][style] = val
            else:
                self.styledict[self.currentstyle]['__parent-style-name'] = parent

    def e_style_style(self, tag, attrs):
        """ End this style
        """
        self.currentstyle = None

    def s_table_table(self, tag, attrs):
        """ Start a table
        """
        c = attrs.get( (TABLENS,'style-name'), None)
        if c and self.generate_css:
            c = c.replace(".","_")
            self.opentag('table',{ 'class': "T-%s" % c })
        else:
            self.opentag('table')
        self.purgedata()

    def e_table_table(self, tag, attrs):
        """ End a table
        """
        self.writedata()
        self.closetag('table')
        self.purgedata()

    def s_table_table_cell(self, tag, attrs):
        """ Start a table cell """
        #FIXME: number-columns-repeated  8.1.3
        #repeated = int(attrs.get( (TABLENS,'number-columns-repeated'), 1))
        htmlattrs = {}
        rowspan = attrs.get( (TABLENS,'number-rows-spanned') )
        if rowspan:
            htmlattrs['rowspan'] = rowspan
        colspan = attrs.get( (TABLENS,'number-columns-spanned') )
        if colspan:
            htmlattrs['colspan'] = colspan

        c = attrs.get( (TABLENS,'style-name') )
        if c:
            htmlattrs['class'] = 'TD-%s' % c.replace(".","_")
        self.opentag('td', htmlattrs)
        self.purgedata()

    def e_table_table_cell(self, tag, attrs):
        """ End a table cell """
        self.writedata()
        self.closetag('td')
        self.purgedata()

    def s_table_table_column(self, tag, attrs):
        """ Start a table column """
        c = attrs.get( (TABLENS,'style-name'), None)
        repeated = int(attrs.get( (TABLENS,'number-columns-repeated'), 1))
        htmlattrs = {}
        if c:
            htmlattrs['class'] = "TC-%s" % c.replace(".","_")
        for x in range(repeated):
            self.emptytag('col', htmlattrs)
        self.purgedata()

    def s_table_table_row(self, tag, attrs):
        """ Start a table row """
        #FIXME: table:number-rows-repeated
        c = attrs.get( (TABLENS,'style-name'), None)
        htmlattrs = {}
        if c:
            htmlattrs['class'] = "TR-%s" % c.replace(".","_")
        self.opentag('tr', htmlattrs)
        self.purgedata()

    def e_table_table_row(self, tag, attrs):
        """ End a table row """
        self.writedata()
        self.closetag('tr')
        self.purgedata()

    def s_text_a(self, tag, attrs):
        """ Anchors start """
        self.writedata()
        href = attrs[(XLINKNS,"href")].split("|")[0]
        if href[0] == "#":
            href = "#" + self.get_anchor(href[1:])
        self.opentag('a', {'href':href})
        self.purgedata()

    def e_text_a(self, tag, attrs):
        """ End an anchor or bookmark reference """
        self.writedata()
        self.closetag('a', False)
        self.purgedata()

    def s_text_bookmark(self, tag, attrs):
        """ Bookmark definition """
        name = attrs[(TEXTNS,'name')]
        html_id = self.get_anchor(name)
        self.writedata()
        self.opentag('span', {'id':html_id})
        self.closetag('span', False)
        self.purgedata()

    def s_text_bookmark_ref(self, tag, attrs):
        """ Bookmark reference """
        name = attrs[(TEXTNS,'ref-name')]
        html_id = "#" + self.get_anchor(name)
        self.writedata()
        self.opentag('a', {'href':html_id})
        self.purgedata()

    def s_text_h(self, tag, attrs):
        """ Headings start """
        level = int(attrs[(TEXTNS,'outline-level')])
        if level > 6: level = 6 # Heading levels go only to 6 in XHTML
        if level < 1: level = 1
        self.headinglevels[level] = self.headinglevels[level] + 1
        name = self.classname(attrs)
        for x in range(level + 1,10):
            self.headinglevels[x] = 0
        special = special_styles.get("P-"+name)
        if special or not self.generate_css:
            self.opentag('h%s' % level)
        else:
            self.opentag('h%s' % level, {'class':"P-%s" % name })
        self.purgedata()

    def e_text_h(self, tag, attrs):
        """ Headings end
            Side-effect: If there is no title in the metadata, then it is taken
            from the first heading of any level.
        """
        self.writedata()
        level = int(attrs[(TEXTNS,'outline-level')])
        if level > 6: level = 6 # Heading levels go only to 6 in XHTML
        if level < 1: level = 1
        lev = self.headinglevels[1:level+1]
        outline = '.'.join(map(str,lev) )
        heading = ''.join(self.data)
        if self.title == '': self.title = heading
        anchor = self.get_anchor("%s.%s" % ( outline, heading))
        self.opentag('a', {'id': anchor} )
        self.closetag('a', False)
        self.closetag('h%s' % level)
        self.purgedata()

    def s_text_line_break(self, tag, attrs):
        """ Force a line break (<br/>) """
        self.writedata()
        self.emptytag('br')
        self.purgedata()

    def s_text_list(self, tag, attrs):
        """ Start a list (<ul> or <ol>)
            To know which level we're at, we have to count the number
            of <text:list> elements on the tagstack.
        """
        name = attrs.get( (TEXTNS,'style-name') )
        level = self.tagstack.count_tags(tag) + 1
        if name:
            name = name.replace(".","_")
        else:
            # FIXME: If a list is contained in a table cell or text box,
            # the list level must return to 1, even though the table or
            # textbox itself may be nested within another list.
            name = self.tagstack.rfindattr( (TEXTNS,'style-name') )
        list_class = "%s_%d" % (name, level)
        if self.generate_css:
            self.opentag('%s' % self.listtypes.get(list_class,'ul'), {'class': list_class })
        else:
            self.opentag('%s' % self.listtypes.get(list_class,'ul'))
        self.purgedata()

    def e_text_list(self, tag, attrs):
        """ End a list """
        self.writedata()
        name = attrs.get( (TEXTNS,'style-name') )
        level = self.tagstack.count_tags(tag) + 1
        if name:
            name = name.replace(".","_")
        else:
            # FIXME: If a list is contained in a table cell or text box,
            # the list level must return to 1, even though the table or
            # textbox itself may be nested within another list.
            name = self.tagstack.rfindattr( (TEXTNS,'style-name') )
        list_class = "%s_%d" % (name, level)
        self.closetag(self.listtypes.get(list_class,'ul'))
        self.purgedata()

    def s_text_list_item(self, tag, attrs):
        """ Start list item """
        self.opentag('li')
        self.purgedata()

    def e_text_list_item(self, tag, attrs):
        """ End list item """
        self.writedata()
        self.closetag('li')
        self.purgedata()

    def s_text_list_level_style_bullet(self, tag, attrs):
        """ CSS doesn't have the ability to set the glyph
            to a particular character, so we just go through
            the available glyphs
        """
        name = self.tagstack.rfindattr( (STYLENS,'name') )
        level = attrs[(TEXTNS,'level')]
        self.prevstyle = self.currentstyle
        list_class = "%s_%s" % (name, level)
        self.listtypes[list_class] = 'ul'
        self.currentstyle = ".%s_%s" % ( name.replace(".","_"), level)
        self.stylestack.append(self.currentstyle)
        self.styledict[self.currentstyle] = {}

        level = int(level)
        listtype = ("square", "disc", "circle")[level % 3]
        self.styledict[self.currentstyle][('','list-style-type')] = listtype

    def e_text_list_level_style_bullet(self, tag, attrs):
        self.currentstyle = self.prevstyle
        del self.prevstyle

    def s_text_list_level_style_number(self, tag, attrs):
        name = self.tagstack.stackparent()[(STYLENS,'name')]
        level = attrs[(TEXTNS,'level')]
        num_format = attrs.get( (STYLENS,'name'),"1")
        list_class = "%s_%s" % (name, level)
        self.prevstyle = self.currentstyle
        self.currentstyle = ".%s_%s" % ( name.replace(".","_"), level)
        self.listtypes[list_class] = 'ol'
        self.stylestack.append(self.currentstyle)
        self.styledict[self.currentstyle] = {}
        if   num_format == "1": listtype = "decimal"
        elif num_format == "I": listtype = "upper-roman"
        elif num_format == "i": listtype = "lower-roman"
        elif num_format == "A": listtype = "upper-alpha"
        elif num_format == "a": listtype = "lower-alpha"
        else: listtype = "decimal"
        self.styledict[self.currentstyle][('','list-style-type')] = listtype

    def e_text_list_level_style_number(self, tag, attrs):
        self.currentstyle = self.prevstyle
        del self.prevstyle

    def s_text_note(self, tag, attrs):
        self.writedata()
        self.purgedata()
        self.currentnote = self.currentnote + 1
        self.notedict[self.currentnote] = {}
        self.notebody = []

    def e_text_note(self, tag, attrs):
        pass

    def collectnote(self,s):
        if s != '':
            self.notebody.append(s)

    def s_text_note_body(self, tag, attrs):
        self._orgwfunc = self._wfunc
        self._wfunc = self.collectnote

    def e_text_note_body(self, tag, attrs):
        self._wfunc = self._orgwfunc
        self.notedict[self.currentnote]['body'] = ''.join(self.notebody)
        self.notebody = ''
        del self._orgwfunc

    def e_text_note_citation(self, tag, attrs):
        mark = ''.join(self.data)
        self.notedict[self.currentnote]['citation'] = mark
        self.opentag('a',{ 'href': "#footnote-%s" % self.currentnote })
        self.opentag('sup')
#        self.writeout( escape(mark) )
        # Since HTML only knows about endnotes, there is too much risk that the
        # marker is reused in the source. Therefore we force numeric markers
        self.writeout(str(self.currentnote))
        self.closetag('sup')
        self.closetag('a')

    def s_text_p(self, tag, attrs):
        """ Paragraph
        """
        htmlattrs = {}
        specialtag = "p"
        c = attrs.get( (TEXTNS,'style-name'), None)
        if c:
            c = c.replace(".","_")
            specialtag = special_styles.get("P-"+c)
            if specialtag is None:
                specialtag = 'p'
                if self.generate_css:
                    htmlattrs['class'] = "P-%s" % c
        self.opentag(specialtag, htmlattrs)
        self.purgedata()

    def e_text_p(self, tag, attrs):
        """ End Paragraph
        """
        specialtag = "p"
        c = attrs.get( (TEXTNS,'style-name'), None)
        if c:
            c = c.replace(".","_")
            specialtag = special_styles.get("P-"+c)
            if specialtag is None:
                specialtag = 'p'
        self.writedata()
        self.closetag(specialtag)
        self.purgedata()

    def s_text_s(self, tag, attrs):
        """ Generate a number of spaces. ODF has an element; HTML uses &nbsp;
            We use &#160; so we can send the output through an XML parser if we desire to
        """
        c = attrs.get( (TEXTNS,'c'),"1")
        for x in range(int(c)):
            self.writeout('&#160;')

    def s_text_span(self, tag, attrs):
        """ The <text:span> element matches the <span> element in HTML. It is
            typically used to properties of the text.
        """
        self.writedata()
        c = attrs.get( (TEXTNS,'style-name'), None)
        htmlattrs = {}
        if c:
            c = c.replace(".","_")
            special = special_styles.get("S-"+c)
            if special is None and self.generate_css:
                htmlattrs['class'] = "S-%s" % c
        self.opentag('span', htmlattrs)
        self.purgedata()

    def e_text_span(self, tag, attrs):
        """ End the <text:span> """
        self.writedata()
        self.closetag('span', False)
        self.purgedata()

    def s_text_tab(self, tag, attrs):
        """ Move to the next tabstop. We ignore this in HTML
        """
        self.writedata()
        self.writeout(' ')
        self.purgedata()

    def s_text_x_source(self, tag, attrs):
        """ Various indexes and tables of contents. We ignore those.
        """
        self.writedata()
        self.purgedata()
        self.s_ignorexml(tag, attrs)

    def e_text_x_source(self, tag, attrs):
        """ Various indexes and tables of contents. We ignore those.
        """
        self.writedata()
        self.purgedata()


#-----------------------------------------------------------------------------
#
# Reading the file
#
#-----------------------------------------------------------------------------

    def load(self, odffile):
        """ Loads a document into the parser and parses it.
            The argument can either be a filename or a document in memory.
        """
        self.lines = []
        self._wfunc = self._wlines
        if isinstance(odffile, str):
            self.document = load(odffile)
        else:
            self.document = odffile
        self._walknode(self.document.topnode)

    def _walknode(self, node):
        if node.nodeType == Node.ELEMENT_NODE:
            self.startElementNS(node.qname, node.tagName, node.attributes)
            for c in node.childNodes:
                self._walknode(c)
            self.endElementNS(node.qname, node.tagName)
        if node.nodeType == Node.TEXT_NODE or node.nodeType == Node.CDATA_SECTION_NODE:
            self.characters(str(node))


    def odf2xhtml(self, odffile):
        """ Load a file and return the XHTML
        """
        self.load(odffile)
        return self.xhtml()

    def _wlines(self,s):
        if s != '': self.lines.append(s)

    def xhtml(self):
        """ Returns the xhtml
        """
        return ''.join(self.lines)

    def _writecss(self, s):
        if s != '': self._csslines.append(s)

    def _writenothing(self, s):
        pass

    def css(self):
        """ Returns the CSS content """
        self._csslines = []
        self._wfunc = self._writecss
        self.generate_stylesheet()
        res = ''.join(self._csslines)
        self._wfunc = self._wlines
        del self._csslines
        return res

    def save(self, outputfile, addsuffix=False):
        """ Save the HTML under the filename.
            If the filename is '-' then save to stdout
            We have the last style filename in self.stylefilename
        """
        if outputfile == '-':
            outputfp = sys.stdout
        else:
            if addsuffix:
                outputfile = outputfile + ".html"
            outputfp = file(outputfile, "w")
        outputfp.write(self.xhtml().encode('us-ascii','xmlcharrefreplace'))
        outputfp.close()


class ODF2XHTMLembedded(ODF2XHTML):
    """ The ODF2XHTML parses an ODF file and produces XHTML"""

    def __init__(self, lines, generate_css=True, embedable=False):
        self._resetobject()
        self.lines = lines

        # Tags
        self.generate_css = generate_css
        self.elements = {
#        (DCNS, 'title'): (self.s_processcont, self.e_dc_title),
#        (DCNS, 'language'): (self.s_processcont, self.e_dc_contentlanguage),
#        (DCNS, 'creator'): (self.s_processcont, self.e_dc_metatag),
#        (DCNS, 'description'): (self.s_processcont, self.e_dc_metatag),
#        (DCNS, 'date'): (self.s_processcont, self.e_dc_metatag),
        (DRAWNS, 'frame'): (self.s_draw_frame, self.e_draw_frame),
        (DRAWNS, 'image'): (self.s_draw_image, None),
        (DRAWNS, 'fill-image'): (self.s_draw_fill_image, None),
        (DRAWNS, "layer-set"):(self.s_ignorexml, None),
        (DRAWNS, 'page'): (self.s_draw_page, self.e_draw_page),
        (DRAWNS, 'object'): (self.s_draw_object, None),
        (DRAWNS, 'object-ole'): (self.s_draw_object_ole, None),
        (DRAWNS, 'text-box'): (self.s_draw_textbox, self.e_draw_textbox),
#        (METANS, 'creation-date'):(self.s_processcont, self.e_dc_metatag),
#        (METANS, 'generator'):(self.s_processcont, self.e_dc_metatag),
#        (METANS, 'initial-creator'): (self.s_processcont, self.e_dc_metatag),
#        (METANS, 'keyword'): (self.s_processcont, self.e_dc_metatag),
        (NUMBERNS, "boolean-style"):(self.s_ignorexml, None),
        (NUMBERNS, "currency-style"):(self.s_ignorexml, None),
        (NUMBERNS, "date-style"):(self.s_ignorexml, None),
        (NUMBERNS, "number-style"):(self.s_ignorexml, None),
        (NUMBERNS, "text-style"):(self.s_ignorexml, None),
#        (OFFICENS, "automatic-styles"):(self.s_office_automatic_styles, None),
#        (OFFICENS, "document-content"):(self.s_office_document_content, self.e_office_document_content),
        (OFFICENS, "forms"):(self.s_ignorexml, None),
#        (OFFICENS, "master-styles"):(self.s_office_master_styles, None),
        (OFFICENS, "meta"):(self.s_ignorecont, None),
#        (OFFICENS, "presentation"):(self.s_office_presentation, self.e_office_presentation),
#        (OFFICENS, "spreadsheet"):(self.s_office_spreadsheet, self.e_office_spreadsheet),
#        (OFFICENS, "styles"):(self.s_office_styles, None),
#        (OFFICENS, "text"):(self.s_office_text, self.e_office_text),
        (OFFICENS, "scripts"):(self.s_ignorexml, None),
        (PRESENTATIONNS, "notes"):(self.s_ignorexml, None),
##       (STYLENS, "default-page-layout"):(self.s_style_default_page_layout, self.e_style_page_layout),
#        (STYLENS, "default-page-layout"):(self.s_ignorexml, None),
#        (STYLENS, "default-style"):(self.s_style_default_style, self.e_style_default_style),
#        (STYLENS, "drawing-page-properties"):(self.s_style_handle_properties, None),
#        (STYLENS, "font-face"):(self.s_style_font_face, None),
##       (STYLENS, "footer"):(self.s_style_footer, self.e_style_footer),
##       (STYLENS, "footer-style"):(self.s_style_footer_style, None),
#        (STYLENS, "graphic-properties"):(self.s_style_handle_properties, None),
#        (STYLENS, "handout-master"):(self.s_ignorexml, None),
##       (STYLENS, "header"):(self.s_style_header, self.e_style_header),
##       (STYLENS, "header-footer-properties"):(self.s_style_handle_properties, None),
##       (STYLENS, "header-style"):(self.s_style_header_style, None),
#        (STYLENS, "master-page"):(self.s_style_master_page, None),
#        (STYLENS, "page-layout-properties"):(self.s_style_handle_properties, None),
##       (STYLENS, "page-layout"):(self.s_style_page_layout, self.e_style_page_layout),
#        (STYLENS, "page-layout"):(self.s_ignorexml, None),
#        (STYLENS, "paragraph-properties"):(self.s_style_handle_properties, None),
#        (STYLENS, "style"):(self.s_style_style, self.e_style_style),
#        (STYLENS, "table-cell-properties"):(self.s_style_handle_properties, None),
#        (STYLENS, "table-column-properties"):(self.s_style_handle_properties, None),
#        (STYLENS, "table-properties"):(self.s_style_handle_properties, None),
#        (STYLENS, "text-properties"):(self.s_style_handle_properties, None),
        (SVGNS, 'desc'): (self.s_ignorexml, None),
        (TABLENS, 'covered-table-cell'): (self.s_ignorexml, None),
        (TABLENS, 'table-cell'): (self.s_table_table_cell, self.e_table_table_cell),
        (TABLENS, 'table-column'): (self.s_table_table_column, None),
        (TABLENS, 'table-row'): (self.s_table_table_row, self.e_table_table_row),
        (TABLENS, 'table'): (self.s_table_table, self.e_table_table),
        (TEXTNS, 'a'): (self.s_text_a, self.e_text_a),
        (TEXTNS, "alphabetical-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, "bibliography-configuration"):(self.s_ignorexml, None),
        (TEXTNS, "bibliography-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, 'h'): (self.s_text_h, self.e_text_h),
        (TEXTNS, "illustration-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, 'line-break'):(self.s_text_line_break, None),
        (TEXTNS, "linenumbering-configuration"):(self.s_ignorexml, None),
        (TEXTNS, "list"):(self.s_text_list, self.e_text_list),
        (TEXTNS, "list-item"):(self.s_text_list_item, self.e_text_list_item),
        (TEXTNS, "list-level-style-bullet"):(self.s_text_list_level_style_bullet, self.e_text_list_level_style_bullet),
        (TEXTNS, "list-level-style-number"):(self.s_text_list_level_style_number, self.e_text_list_level_style_number),
        (TEXTNS, "list-style"):(None, None),
        (TEXTNS, "note"):(self.s_text_note, None),
        (TEXTNS, "note-body"):(self.s_text_note_body, self.e_text_note_body),
        (TEXTNS, "note-citation"):(None, self.e_text_note_citation),
        (TEXTNS, "notes-configuration"):(self.s_ignorexml, None),
        (TEXTNS, "object-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, 'p'): (self.s_text_p, self.e_text_p),
        (TEXTNS, 's'): (self.s_text_s, None),
        (TEXTNS, 'span'): (self.s_text_span, self.e_text_span),
        (TEXTNS, 'tab'): (self.s_text_tab, None),
        (TEXTNS, "table-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, "table-of-content-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, "user-index-source"):(self.s_text_x_source, self.e_text_x_source),
        (TEXTNS, "page-number"):(None, None),
        }


########NEW FILE########
__FILENAME__ = odfmanifest
#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

# This script lists the content of the manifest.xml file
import zipfile
from xml.sax import make_parser,handler
from xml.sax.xmlreader import InputSource
import xml.sax.saxutils
from io import StringIO

MANIFESTNS="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0"

#-----------------------------------------------------------------------------
#
# ODFMANIFESTHANDLER
#
#-----------------------------------------------------------------------------

class ODFManifestHandler(handler.ContentHandler):
    """ The ODFManifestHandler parses a manifest file and produces a list of
        content """

    def __init__(self):
        self.manifest = {}

        # Tags
        # FIXME: Also handle encryption data
        self.elements = {
        (MANIFESTNS, 'file-entry'): (self.s_file_entry, self.donothing),
        }

    def handle_starttag(self, tag, method, attrs):
        method(tag,attrs)

    def handle_endtag(self, tag, method):
        method(tag)

    def startElementNS(self, tag, qname, attrs):
        method = self.elements.get(tag, (None, None))[0]
        if method:
            self.handle_starttag(tag, method, attrs)
        else:
            self.unknown_starttag(tag,attrs)

    def endElementNS(self, tag, qname):
        method = self.elements.get(tag, (None, None))[1]
        if method:
            self.handle_endtag(tag, method)
        else:
            self.unknown_endtag(tag)

    def unknown_starttag(self, tag, attrs):
        pass

    def unknown_endtag(self, tag):
        pass

    def donothing(self, tag, attrs=None):
        pass

    def s_file_entry(self, tag, attrs):
        m = attrs.get((MANIFESTNS, 'media-type'),"application/octet-stream")
        p = attrs.get((MANIFESTNS, 'full-path'))
        self.manifest[p] = { 'media-type':m, 'full-path':p }


#-----------------------------------------------------------------------------
#
# Reading the file
#
#-----------------------------------------------------------------------------

def manifestlist(manifestxml):
    odhandler = ODFManifestHandler()
    parser = make_parser()
    parser.setFeature(handler.feature_namespaces, 1)
    parser.setContentHandler(odhandler)
    parser.setErrorHandler(handler.ErrorHandler())

    inpsrc = InputSource()
    inpsrc.setByteStream(StringIO(manifestxml))
    parser.parse(inpsrc)

    return odhandler.manifest

def odfmanifest(odtfile):
    z = zipfile.ZipFile(odtfile)
    manifest = z.read('META-INF/manifest.xml')
    z.close()
    return manifestlist(manifest)

if __name__ == "__main__":
    import sys
    result = odfmanifest(sys.argv[1])
    for file in list(result.values()):
        print("%-40s %-40s" % (file['media-type'], file['full-path']))


########NEW FILE########
__FILENAME__ = office
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import OFFICENS
from .element import Element
from .draw import StyleRefElement

# Autogenerated
def Annotation(**args):
    return StyleRefElement(qname = (OFFICENS,'annotation'), **args)

def AutomaticStyles(**args):
    return Element(qname = (OFFICENS, 'automatic-styles'), **args)

def BinaryData(**args):
    return Element(qname = (OFFICENS,'binary-data'), **args)

def Body(**args):
    return Element(qname = (OFFICENS, 'body'), **args)

def ChangeInfo(**args):
    return Element(qname = (OFFICENS,'change-info'), **args)

def Chart(**args):
    return Element(qname = (OFFICENS,'chart'), **args)

def DdeSource(**args):
    return Element(qname = (OFFICENS,'dde-source'), **args)

def Document(version="1.1", **args):
    return Element(qname = (OFFICENS,'document'), version=version, **args)

def DocumentContent(version="1.1", **args):
    return Element(qname = (OFFICENS, 'document-content'), version=version, **args)

def DocumentMeta(version="1.1", **args):
    return Element(qname = (OFFICENS, 'document-meta'), version=version, **args)

def DocumentSettings(version="1.1", **args):
    return Element(qname = (OFFICENS, 'document-settings'), version=version, **args)

def DocumentStyles(version="1.1", **args):
    return Element(qname = (OFFICENS, 'document-styles'), version=version, **args)

def Drawing(**args):
    return Element(qname = (OFFICENS,'drawing'), **args)

def EventListeners(**args):
    return Element(qname = (OFFICENS,'event-listeners'), **args)

def FontFaceDecls(**args):
    return Element(qname = (OFFICENS, 'font-face-decls'), **args)

def Forms(**args):
    return Element(qname = (OFFICENS,'forms'), **args)

def Image(**args):
    return Element(qname = (OFFICENS,'image'), **args)

def MasterStyles(**args):
    return Element(qname = (OFFICENS, 'master-styles'), **args)

def Meta(**args):
    return Element(qname = (OFFICENS, 'meta'), **args)

def Presentation(**args):
    return Element(qname = (OFFICENS,'presentation'), **args)

def Script(**args):
    return Element(qname = (OFFICENS, 'script'), **args)

def Scripts(**args):
    return Element(qname = (OFFICENS, 'scripts'), **args)

def Settings(**args):
    return Element(qname = (OFFICENS, 'settings'), **args)

def Spreadsheet(**args):
    return Element(qname = (OFFICENS, 'spreadsheet'), **args)

def Styles(**args):
    return Element(qname = (OFFICENS, 'styles'), **args)

def Text(**args):
    return Element(qname = (OFFICENS, 'text'), **args)

# Autogenerated end

########NEW FILE########
__FILENAME__ = opendocument
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2010 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
#
# Contributor(s):
#

__doc__="""Use OpenDocument to generate your documents."""

import zipfile, time, sys, mimetypes, copy
from io import StringIO
from .namespaces import *
from . import manifest, meta
from .office import *
from . import element
from .attrconverters import make_NCName
from xml.sax.xmlreader import InputSource
from .odfmanifest import manifestlist

__version__= TOOLSVERSION

_XMLPROLOGUE = "<?xml version='1.0' encoding='UTF-8'?>\n"

UNIXPERMS = 0o100644 << 16  # -rw-r--r--

IS_FILENAME = 0
IS_IMAGE = 1
# We need at least Python 2.2
assert sys.version_info[0]>=2

#sys.setrecursionlimit(100)
#The recursion limit is set conservative so mistakes like
# s=content() s.addElement(s) won't eat up too much processor time.

odmimetypes = {
 'application/vnd.oasis.opendocument.text':                  '.odt',
 'application/vnd.oasis.opendocument.text-template':         '.ott',
 'application/vnd.oasis.opendocument.graphics':              '.odg',
 'application/vnd.oasis.opendocument.graphics-template':     '.otg',
 'application/vnd.oasis.opendocument.presentation':          '.odp',
 'application/vnd.oasis.opendocument.presentation-template': '.otp',
 'application/vnd.oasis.opendocument.spreadsheet':           '.ods',
 'application/vnd.oasis.opendocument.spreadsheet-template':  '.ots',
 'application/vnd.oasis.opendocument.chart':                 '.odc',
 'application/vnd.oasis.opendocument.chart-template':        '.otc',
 'application/vnd.oasis.opendocument.image':                 '.odi',
 'application/vnd.oasis.opendocument.image-template':        '.oti',
 'application/vnd.oasis.opendocument.formula':               '.odf',
 'application/vnd.oasis.opendocument.formula-template':      '.otf',
 'application/vnd.oasis.opendocument.text-master':           '.odm',
 'application/vnd.oasis.opendocument.text-web':              '.oth',
}

class OpaqueObject:
    def __init__(self, filename, mediatype, content=None):
       self.mediatype = mediatype
       self.filename = filename
       self.content = content

class OpenDocument:
    """ A class to hold the content of an OpenDocument document
        Use the xml method to write the XML
        source to the screen or to a file
        d = OpenDocument(mimetype)
        fd.write(d.xml())
    """
    thumbnail = None

    def __init__(self, mimetype, add_generator=True):
        self.mimetype = mimetype
        self.childobjects = []
        self._extra = []
        self.folder = "" # Always empty for toplevel documents
        self.topnode = Document(mimetype=self.mimetype)
        self.topnode.ownerDocument = self

        self.clear_caches()

        self.Pictures = {}
        self.meta = Meta()
        self.topnode.addElement(self.meta)
        if add_generator:
            self.meta.addElement(meta.Generator(text=TOOLSVERSION))
        self.scripts = Scripts()
        self.topnode.addElement(self.scripts)
        self.fontfacedecls = FontFaceDecls()
        self.topnode.addElement(self.fontfacedecls)
        self.settings = Settings()
        self.topnode.addElement(self.settings)
        self.styles = Styles()
        self.topnode.addElement(self.styles)
        self.automaticstyles = AutomaticStyles()
        self.topnode.addElement(self.automaticstyles)
        self.masterstyles = MasterStyles()
        self.topnode.addElement(self.masterstyles)
        self.body = Body()
        self.topnode.addElement(self.body)

    def rebuild_caches(self, node=None):
        if node is None: node = self.topnode
        self.build_caches(node)
        for e in node.childNodes:
            if e.nodeType == element.Node.ELEMENT_NODE:
                self.rebuild_caches(e)

    def clear_caches(self):
        self.element_dict = {}
        self._styles_dict = {}
        self._styles_ooo_fix = {}

    def build_caches(self, element):
        """ Called from element.py
        """
        if element.qname not in self.element_dict:
            self.element_dict[element.qname] = []
        self.element_dict[element.qname].append(element)
        if element.qname == (STYLENS, 'style'):
            self.__register_stylename(element) # Add to style dictionary
        styleref = element.getAttrNS(TEXTNS,'style-name')
        if styleref is not None and styleref in self._styles_ooo_fix:
            element.setAttrNS(TEXTNS,'style-name', self._styles_ooo_fix[styleref])

    def __register_stylename(self, element):
        ''' Register a style. But there are three style dictionaries:
            office:styles, office:automatic-styles and office:master-styles
            Chapter 14
        '''
        name = element.getAttrNS(STYLENS, 'name')
        if name is None:
            return
        if element.parentNode.qname in ((OFFICENS,'styles'), (OFFICENS,'automatic-styles')):
            if name in self._styles_dict:
                newname = 'M'+name # Rename style
                self._styles_ooo_fix[name] = newname
                # From here on all references to the old name will refer to the new one
                name = newname
                element.setAttrNS(STYLENS, 'name', name)
            self._styles_dict[name] = element

    def toXml(self, filename=''):
        xml=StringIO()
        xml.write(_XMLPROLOGUE)
        self.body.toXml(0, xml)
        if not filename:
            return xml.getvalue()
        else:
            f=file(filename,'w')
            f.write(xml.getvalue())
            f.close()

    def xml(self):
        """ Generates the full document as an XML file
            Always written as a bytestream in UTF-8 encoding
        """
        self.__replaceGenerator()
        xml=StringIO()
        xml.write(_XMLPROLOGUE)
        self.topnode.toXml(0, xml)
        return xml.getvalue()


    def contentxml(self):
        """ Generates the content.xml file
            Always written as a bytestream in UTF-8 encoding
        """
        xml=StringIO()
        xml.write(_XMLPROLOGUE)
        x = DocumentContent()
        x.write_open_tag(0, xml)
        if self.scripts.hasChildNodes():
            self.scripts.toXml(1, xml)
        if self.fontfacedecls.hasChildNodes():
            self.fontfacedecls.toXml(1, xml)
        a = AutomaticStyles()
        stylelist = self._used_auto_styles([self.styles, self.automaticstyles, self.body])
        if len(stylelist) > 0:
            a.write_open_tag(1, xml)
            for s in stylelist:
                s.toXml(2, xml)
            a.write_close_tag(1, xml)
        else:
            a.toXml(1, xml)
        self.body.toXml(1, xml)
        x.write_close_tag(0, xml)
        return xml.getvalue()

    def __manifestxml(self):
        """ Generates the manifest.xml file
            The self.manifest isn't avaible unless the document is being saved
        """
        xml=StringIO()
        xml.write(_XMLPROLOGUE)
        self.manifest.toXml(0,xml)
        return xml.getvalue()

    def metaxml(self):
        """ Generates the meta.xml file """
        self.__replaceGenerator()
        x = DocumentMeta()
        x.addElement(self.meta)
        xml=StringIO()
        xml.write(_XMLPROLOGUE)
        x.toXml(0,xml)
        return xml.getvalue()

    def settingsxml(self):
        """ Generates the settings.xml file """
        x = DocumentSettings()
        x.addElement(self.settings)
        xml=StringIO()
        xml.write(_XMLPROLOGUE)
        x.toXml(0,xml)
        return xml.getvalue()

    def _parseoneelement(self, top, stylenamelist):
        """ Finds references to style objects in master-styles
            and add the style name to the style list if not already there.
            Recursive
        """
        for e in top.childNodes:
            if e.nodeType == element.Node.ELEMENT_NODE:
                for styleref in ( (DRAWNS,'style-name'),
                        (DRAWNS,'text-style-name'),
                        (PRESENTATIONNS,'style-name'),
                        (STYLENS,'data-style-name'),
                        (STYLENS,'list-style-name'),
                        (STYLENS,'page-layout-name'),
                        (STYLENS,'style-name'),
                        (TABLENS,'default-cell-style-name'),
                        (TABLENS,'style-name'),
                        (TEXTNS,'style-name') ):
                    if e.getAttrNS(styleref[0],styleref[1]):
                        stylename = e.getAttrNS(styleref[0],styleref[1])
                        if stylename not in stylenamelist:
                            stylenamelist.append(stylename)
                stylenamelist = self._parseoneelement(e, stylenamelist)
        return stylenamelist

    def _used_auto_styles(self, segments):
        """ Loop through the masterstyles elements, and find the automatic
            styles that are used. These will be added to the automatic-styles
            element in styles.xml
        """
        stylenamelist = []
        for top in segments:
            stylenamelist = self._parseoneelement(top, stylenamelist)
        stylelist = []
        for e in self.automaticstyles.childNodes:
            if e.getAttrNS(STYLENS,'name') in stylenamelist:
                stylelist.append(e)
        return stylelist

    def stylesxml(self):
        """ Generates the styles.xml file """
        xml=StringIO()
        xml.write(_XMLPROLOGUE)
        x = DocumentStyles()
        x.write_open_tag(0, xml)
        if self.fontfacedecls.hasChildNodes():
            self.fontfacedecls.toXml(1, xml)
        self.styles.toXml(1, xml)
        a = AutomaticStyles()
        a.write_open_tag(1, xml)
        for s in self._used_auto_styles([self.masterstyles]):
            s.toXml(2, xml)
        a.write_close_tag(1, xml)
        if self.masterstyles.hasChildNodes():
            self.masterstyles.toXml(1, xml)
        x.write_close_tag(0, xml)
        return xml.getvalue()

    def addPicture(self, filename, mediatype=None, content=None):
        """ Add a picture
            It uses the same convention as OOo, in that it saves the picture in
            the zipfile in the subdirectory 'Pictures'
            If passed a file ptr, mediatype must be set
        """
        if content is None:
            if mediatype is None:
                mediatype, encoding = mimetypes.guess_type(filename)
            if mediatype is None:
                mediatype = ''
                try: ext = filename[filename.rindex('.'):]
                except: ext=''
            else:
                ext = mimetypes.guess_extension(mediatype)
            manifestfn = "Pictures/%0.0f%s" % ((time.time()*10000000000), ext)
            self.Pictures[manifestfn] = (IS_FILENAME, filename, mediatype)
        else:
            manifestfn = filename
            self.Pictures[manifestfn] = (IS_IMAGE, content, mediatype)
        return manifestfn

    def addPictureFromFile(self, filename, mediatype=None):
        """ Add a picture
            It uses the same convention as OOo, in that it saves the picture in
            the zipfile in the subdirectory 'Pictures'.
            If mediatype is not given, it will be guessed from the filename
            extension.
        """
        if mediatype is None:
            mediatype, encoding = mimetypes.guess_type(filename)
        if mediatype is None:
            mediatype = ''
            try: ext = filename[filename.rindex('.'):]
            except ValueError: ext=''
        else:
            ext = mimetypes.guess_extension(mediatype)
        manifestfn = "Pictures/%0.0f%s" % ((time.time()*10000000000), ext)
        self.Pictures[manifestfn] = (IS_FILENAME, filename, mediatype)
        return manifestfn

    def addPictureFromString(self, content, mediatype):
        """ Add a picture
            It uses the same convention as OOo, in that it saves the picture in
            the zipfile in the subdirectory 'Pictures'. The content variable
            is a string that contains the binary image data. The mediatype
            indicates the image format.
        """
        ext = mimetypes.guess_extension(mediatype)
        manifestfn = "Pictures/%0.0f%s" % ((time.time()*10000000000), ext)
        self.Pictures[manifestfn] = (IS_IMAGE, content, mediatype)
        return manifestfn

    def addThumbnail(self, filecontent=None):
        """ Add a fixed thumbnail
            The thumbnail in the library is big, so this is pretty useless.
        """
        if filecontent is None:
            from . import thumbnail
            self.thumbnail = thumbnail.thumbnail()
        else:
            self.thumbnail = filecontent

    def addObject(self, document, objectname=None):
        """ Adds an object (subdocument). The object must be an OpenDocument class
            The return value will be the folder in the zipfile the object is stored in
        """
        self.childobjects.append(document)
        if objectname is None:
            document.folder = "%s/Object %d" % (self.folder, len(self.childobjects))
        else:
            document.folder = objectname
        return ".%s" % document.folder

    def _savePictures(self, object, folder):
        hasPictures = False
        for arcname, picturerec in list(object.Pictures.items()):
            what_it_is, fileobj, mediatype = picturerec
            self.manifest.addElement(manifest.FileEntry(fullpath="%s%s" % ( folder ,arcname), mediatype=mediatype))
            hasPictures = True
            if what_it_is == IS_FILENAME:
                self._z.write(fileobj, arcname, zipfile.ZIP_STORED)
            else:
                zi = zipfile.ZipInfo(str(arcname), self._now)
                zi.compress_type = zipfile.ZIP_STORED
                zi.external_attr = UNIXPERMS
                self._z.writestr(zi, fileobj)
        # According to section 17.7.3 in ODF 1.1, the pictures folder should not have a manifest entry
#       if hasPictures:
#           self.manifest.addElement(manifest.FileEntry(fullpath="%sPictures/" % folder, mediatype=""))
        # Look in subobjects
        subobjectnum = 1
        for subobject in object.childobjects:
            self._savePictures(subobject,'%sObject %d/' % (folder, subobjectnum))
            subobjectnum += 1

    def __replaceGenerator(self):
        """ Section 3.1.1: The application MUST NOT export the original identifier
            belonging to the application that created the document.
        """
        for m in self.meta.childNodes[:]:
            if m.qname == (METANS, 'generator'):
                self.meta.removeChild(m)
        self.meta.addElement(meta.Generator(text=TOOLSVERSION))

    def save(self, outputfile, addsuffix=False):
        """ Save the document under the filename.
            If the filename is '-' then save to stdout
        """
        if outputfile == '-':
            outputfp = zipfile.ZipFile(sys.stdout,"w")
        else:
            if addsuffix:
                outputfile = outputfile + odmimetypes.get(self.mimetype,'.xxx')
            outputfp = zipfile.ZipFile(outputfile, "w")
        self.__zipwrite(outputfp)
        outputfp.close()

    def write(self, outputfp):
        """ User API to write the ODF file to an open file descriptor
            Writes the ZIP format
        """
        zipoutputfp = zipfile.ZipFile(outputfp,"w")
        self.__zipwrite(zipoutputfp)

    def __zipwrite(self, outputfp):
        """ Write the document to an open file pointer
            This is where the real work is done
        """
        self._z = outputfp
        self._now = time.localtime()[:6]
        self.manifest = manifest.Manifest()

        # Write mimetype
        zi = zipfile.ZipInfo('mimetype', self._now)
        zi.compress_type = zipfile.ZIP_STORED
        zi.external_attr = UNIXPERMS
        self._z.writestr(zi, self.mimetype)

        self._saveXmlObjects(self,"")

        # Write pictures
        self._savePictures(self,"")

        # Write the thumbnail
        if self.thumbnail is not None:
            self.manifest.addElement(manifest.FileEntry(fullpath="Thumbnails/", mediatype=''))
            self.manifest.addElement(manifest.FileEntry(fullpath="Thumbnails/thumbnail.png", mediatype=''))
            zi = zipfile.ZipInfo("Thumbnails/thumbnail.png", self._now)
            zi.compress_type = zipfile.ZIP_DEFLATED
            zi.external_attr = UNIXPERMS
            self._z.writestr(zi, self.thumbnail)

        # Write any extra files
        for op in self._extra:
            if op.filename == "META-INF/documentsignatures.xml": continue # Don't save signatures
            self.manifest.addElement(manifest.FileEntry(fullpath=op.filename, mediatype=op.mediatype))
            zi = zipfile.ZipInfo(op.filename.encode('utf-8'), self._now)
            zi.compress_type = zipfile.ZIP_DEFLATED
            zi.external_attr = UNIXPERMS
            if op.content is not None:
                self._z.writestr(zi, op.content)
        # Write manifest
        zi = zipfile.ZipInfo("META-INF/manifest.xml", self._now)
        zi.compress_type = zipfile.ZIP_DEFLATED
        zi.external_attr = UNIXPERMS
        self._z.writestr(zi, self.__manifestxml() )
        del self._z
        del self._now
        del self.manifest


    def _saveXmlObjects(self, object, folder):
        if self == object:
            self.manifest.addElement(manifest.FileEntry(fullpath="/", mediatype=object.mimetype))
        else:
            self.manifest.addElement(manifest.FileEntry(fullpath=folder, mediatype=object.mimetype))
        # Write styles
        self.manifest.addElement(manifest.FileEntry(fullpath="%sstyles.xml" % folder, mediatype="text/xml"))
        zi = zipfile.ZipInfo("%sstyles.xml" % folder, self._now)
        zi.compress_type = zipfile.ZIP_DEFLATED
        zi.external_attr = UNIXPERMS
        self._z.writestr(zi, object.stylesxml() )

        # Write content
        self.manifest.addElement(manifest.FileEntry(fullpath="%scontent.xml" % folder, mediatype="text/xml"))
        zi = zipfile.ZipInfo("%scontent.xml" % folder, self._now)
        zi.compress_type = zipfile.ZIP_DEFLATED
        zi.external_attr = UNIXPERMS
        self._z.writestr(zi, object.contentxml() )

        # Write settings
        if object.settings.hasChildNodes():
            self.manifest.addElement(manifest.FileEntry(fullpath="%ssettings.xml" % folder, mediatype="text/xml"))
            zi = zipfile.ZipInfo("%ssettings.xml" % folder, self._now)
            zi.compress_type = zipfile.ZIP_DEFLATED
            zi.external_attr = UNIXPERMS
            self._z.writestr(zi, object.settingsxml() )

        # Write meta
        if self == object:
            self.manifest.addElement(manifest.FileEntry(fullpath="meta.xml", mediatype="text/xml"))
            zi = zipfile.ZipInfo("meta.xml", self._now)
            zi.compress_type = zipfile.ZIP_DEFLATED
            zi.external_attr = UNIXPERMS
            self._z.writestr(zi, object.metaxml() )

        # Write subobjects
        subobjectnum = 1
        for subobject in object.childobjects:
            self._saveXmlObjects(subobject, '%sObject %d/' % (folder, subobjectnum))
            subobjectnum += 1

# Document's DOM methods
    def createElement(self, element):
        """ Inconvenient interface to create an element, but follows XML-DOM.
            Does not allow attributes as argument, therefore can't check grammar.
        """
        return element(check_grammar=False)

    def createTextNode(self, data):
        """ Method to create a text node """
        return element.Text(data)

    def createCDATASection(self, data):
        """ Method to create a CDATA section """
        return element.CDATASection(cdata)

    def getMediaType(self):
        """ Returns the media type """
        return self.mimetype

    def getStyleByName(self, name):
        """ Finds a style object based on the name """
        ncname = make_NCName(name)
        if self._styles_dict == {}:
            self.rebuild_caches()
        return self._styles_dict.get(ncname, None)

    def getElementsByType(self, element):
        """ Gets elements based on the type, which is function from text.py, draw.py etc. """
        obj = element(check_grammar=False)
        if self.element_dict == {}:
            self.rebuild_caches()
        return self.element_dict.get(obj.qname, [])

# Convenience functions
def OpenDocumentChart():
    """ Creates a chart document """
    doc = OpenDocument('application/vnd.oasis.opendocument.chart')
    doc.chart = Chart()
    doc.body.addElement(doc.chart)
    return doc

def OpenDocumentDrawing():
    """ Creates a drawing document """
    doc = OpenDocument('application/vnd.oasis.opendocument.graphics')
    doc.drawing = Drawing()
    doc.body.addElement(doc.drawing)
    return doc

def OpenDocumentImage():
    """ Creates an image document """
    doc = OpenDocument('application/vnd.oasis.opendocument.image')
    doc.image = Image()
    doc.body.addElement(doc.image)
    return doc

def OpenDocumentPresentation():
    """ Creates a presentation document """
    doc = OpenDocument('application/vnd.oasis.opendocument.presentation')
    doc.presentation = Presentation()
    doc.body.addElement(doc.presentation)
    return doc

def OpenDocumentSpreadsheet():
    """ Creates a spreadsheet document """
    doc = OpenDocument('application/vnd.oasis.opendocument.spreadsheet')
    doc.spreadsheet = Spreadsheet()
    doc.body.addElement(doc.spreadsheet)
    return doc

def OpenDocumentText():
    """ Creates a text document """
    doc = OpenDocument('application/vnd.oasis.opendocument.text')
    doc.text = Text()
    doc.body.addElement(doc.text)
    return doc

def OpenDocumentTextMaster():
    """ Creates a text master document """
    doc = OpenDocument('application/vnd.oasis.opendocument.text-master')
    doc.text = Text()
    doc.body.addElement(doc.text)
    return doc

def __loadxmlparts(z, manifest, doc, objectpath):
    from .load import LoadParser
    from xml.sax import make_parser, handler

    for xmlfile in (objectpath+'settings.xml', objectpath+'meta.xml', objectpath+'content.xml', objectpath+'styles.xml'):
        if xmlfile not in manifest:
            continue
        try:
            xmlpart = z.read(xmlfile)
            doc._parsing = xmlfile

            parser = make_parser()
            parser.setFeature(handler.feature_namespaces, 1)
            parser.setContentHandler(LoadParser(doc))
            parser.setErrorHandler(handler.ErrorHandler())

            inpsrc = InputSource()
            inpsrc.setByteStream(StringIO(xmlpart))
            parser.parse(inpsrc)
            del doc._parsing
        except KeyError as v: pass

def load(odffile):
    """ Load an ODF file into memory
        Returns a reference to the structure
    """
    z = zipfile.ZipFile(odffile)
    mimetype = z.read('mimetype')
    doc = OpenDocument(mimetype, add_generator=False)

    # Look in the manifest file to see if which of the four files there are
    manifestpart = z.read('META-INF/manifest.xml')
    manifest =  manifestlist(manifestpart)
    __loadxmlparts(z, manifest, doc, '')
    for mentry,mvalue in list(manifest.items()):
        if mentry[:9] == "Pictures/" and len(mentry) > 9:
            doc.addPicture(mvalue['full-path'], mvalue['media-type'], z.read(mentry))
        elif mentry == "Thumbnails/thumbnail.png":
            doc.addThumbnail(z.read(mentry))
        elif mentry in ('settings.xml', 'meta.xml', 'content.xml', 'styles.xml'):
            pass
        # Load subobjects into structure
        elif mentry[:7] == "Object " and len(mentry) < 11 and mentry[-1] == "/":
            subdoc = OpenDocument(mvalue['media-type'], add_generator=False)
            doc.addObject(subdoc, "/" + mentry[:-1])
            __loadxmlparts(z, manifest, subdoc, mentry)
        elif mentry[:7] == "Object ":
            pass # Don't load subobjects as opaque objects
        else:
            if mvalue['full-path'][-1] == '/':
                doc._extra.append(OpaqueObject(mvalue['full-path'], mvalue['media-type'], None))
            else:
                doc._extra.append(OpaqueObject(mvalue['full-path'], mvalue['media-type'], z.read(mentry)))
            # Add the SUN junk here to the struct somewhere
            # It is cached data, so it can be out-of-date
    z.close()
    b = doc.getElementsByType(Body)
    if mimetype[:39] == 'application/vnd.oasis.opendocument.text':
        doc.text = b[0].firstChild
    elif mimetype[:43] == 'application/vnd.oasis.opendocument.graphics':
        doc.graphics = b[0].firstChild
    elif mimetype[:47] == 'application/vnd.oasis.opendocument.presentation':
        doc.presentation = b[0].firstChild
    elif mimetype[:46] == 'application/vnd.oasis.opendocument.spreadsheet':
        doc.spreadsheet = b[0].firstChild
    elif mimetype[:40] == 'application/vnd.oasis.opendocument.chart':
        doc.chart = b[0].firstChild
    elif mimetype[:40] == 'application/vnd.oasis.opendocument.image':
        doc.image = b[0].firstChild
    elif mimetype[:42] == 'application/vnd.oasis.opendocument.formula':
        doc.formula = b[0].firstChild
    return doc

# vim: set expandtab sw=4 :

########NEW FILE########
__FILENAME__ = presentation
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import PRESENTATIONNS
from .element import Element

# ODF 1.0 section 9.6 and 9.7
# Autogenerated
def AnimationGroup(**args):
    return Element(qname = (PRESENTATIONNS,'animation-group'), **args)

def Animations(**args):
    return Element(qname = (PRESENTATIONNS,'animations'), **args)

def DateTime(**args):
    return Element(qname = (PRESENTATIONNS,'date-time'), **args)

def DateTimeDecl(**args):
    return Element(qname = (PRESENTATIONNS,'date-time-decl'), **args)

def Dim(**args):
    return Element(qname = (PRESENTATIONNS,'dim'), **args)

def EventListener(**args):
    return Element(qname = (PRESENTATIONNS,'event-listener'), **args)

def Footer(**args):
    return Element(qname = (PRESENTATIONNS,'footer'), **args)

def FooterDecl(**args):
    return Element(qname = (PRESENTATIONNS,'footer-decl'), **args)

def Header(**args):
    return Element(qname = (PRESENTATIONNS,'header'), **args)

def HeaderDecl(**args):
    return Element(qname = (PRESENTATIONNS,'header-decl'), **args)

def HideShape(**args):
    return Element(qname = (PRESENTATIONNS,'hide-shape'), **args)

def HideText(**args):
    return Element(qname = (PRESENTATIONNS,'hide-text'), **args)

def Notes(**args):
    return Element(qname = (PRESENTATIONNS,'notes'), **args)

def Placeholder(**args):
    return Element(qname = (PRESENTATIONNS,'placeholder'), **args)

def Play(**args):
    return Element(qname = (PRESENTATIONNS,'play'), **args)

def Settings(**args):
    return Element(qname = (PRESENTATIONNS,'settings'), **args)

def Show(**args):
    return Element(qname = (PRESENTATIONNS,'show'), **args)

def ShowShape(**args):
    return Element(qname = (PRESENTATIONNS,'show-shape'), **args)

def ShowText(**args):
    return Element(qname = (PRESENTATIONNS,'show-text'), **args)

def Sound(**args):
    return Element(qname = (PRESENTATIONNS,'sound'), **args)


########NEW FILE########
__FILENAME__ = script
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import SCRIPTNS
from .element import Element

# ODF 1.0 section 12.4.1
# The <script:event-listener> element binds an event to a macro.

# Autogenerated
def EventListener(**args):
    return Element(qname = (SCRIPTNS,'event-listener'), **args)


########NEW FILE########
__FILENAME__ = style
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import STYLENS
from .element import Element

def StyleElement(**args):
    e = Element(**args)
    if args.get('check_grammar', True) == True:
        if 'displayname' not in args:
            e.setAttrNS(STYLENS,'display-name', args.get('name'))
    return e

# Autogenerated
def BackgroundImage(**args):
    return Element(qname = (STYLENS,'background-image'), **args)

def ChartProperties(**args):
    return Element(qname = (STYLENS,'chart-properties'), **args)

def Column(**args):
    return Element(qname = (STYLENS,'column'), **args)

def ColumnSep(**args):
    return Element(qname = (STYLENS,'column-sep'), **args)

def Columns(**args):
    return Element(qname = (STYLENS,'columns'), **args)

def DefaultStyle(**args):
    return Element(qname = (STYLENS,'default-style'), **args)

def DrawingPageProperties(**args):
    return Element(qname = (STYLENS,'drawing-page-properties'), **args)

def DropCap(**args):
    return Element(qname = (STYLENS,'drop-cap'), **args)

def FontFace(**args):
    return Element(qname = (STYLENS,'font-face'), **args)

def Footer(**args):
    return Element(qname = (STYLENS,'footer'), **args)

def FooterLeft(**args):
    return Element(qname = (STYLENS,'footer-left'), **args)

def FooterStyle(**args):
    return Element(qname = (STYLENS,'footer-style'), **args)

def FootnoteSep(**args):
    return Element(qname = (STYLENS,'footnote-sep'), **args)

def GraphicProperties(**args):
    return Element(qname = (STYLENS,'graphic-properties'), **args)

def HandoutMaster(**args):
    return Element(qname = (STYLENS,'handout-master'), **args)

def Header(**args):
    return Element(qname = (STYLENS,'header'), **args)

def HeaderFooterProperties(**args):
    return Element(qname = (STYLENS,'header-footer-properties'), **args)

def HeaderLeft(**args):
    return Element(qname = (STYLENS,'header-left'), **args)

def HeaderStyle(**args):
    return Element(qname = (STYLENS,'header-style'), **args)

def ListLevelProperties(**args):
    return Element(qname = (STYLENS,'list-level-properties'), **args)

def Map(**args):
    return Element(qname = (STYLENS,'map'), **args)

def MasterPage(**args):
    return StyleElement(qname = (STYLENS,'master-page'), **args)

def PageLayout(**args):
    return Element(qname = (STYLENS,'page-layout'), **args)

def PageLayoutProperties(**args):
    return Element(qname = (STYLENS,'page-layout-properties'), **args)

def ParagraphProperties(**args):
    return Element(qname = (STYLENS,'paragraph-properties'), **args)

def PresentationPageLayout(**args):
    return StyleElement(qname = (STYLENS,'presentation-page-layout'), **args)

def RegionCenter(**args):
    return Element(qname = (STYLENS,'region-center'), **args)

def RegionLeft(**args):
    return Element(qname = (STYLENS,'region-left'), **args)

def RegionRight(**args):
    return Element(qname = (STYLENS,'region-right'), **args)

def RubyProperties(**args):
    return Element(qname = (STYLENS,'ruby-properties'), **args)

def SectionProperties(**args):
    return Element(qname = (STYLENS,'section-properties'), **args)

def Style(**args):
    return StyleElement(qname = (STYLENS,'style'), **args)

def TabStop(**args):
    return Element(qname = (STYLENS,'tab-stop'), **args)

def TabStops(**args):
    return Element(qname = (STYLENS,'tab-stops'), **args)

def TableCellProperties(**args):
    return Element(qname = (STYLENS,'table-cell-properties'), **args)

def TableColumnProperties(**args):
    return Element(qname = (STYLENS,'table-column-properties'), **args)

def TableProperties(**args):
    return Element(qname = (STYLENS,'table-properties'), **args)

def TableRowProperties(**args):
    return Element(qname = (STYLENS,'table-row-properties'), **args)

def TextProperties(**args):
    return Element(qname = (STYLENS,'text-properties'), **args)


########NEW FILE########
__FILENAME__ = svg
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import SVGNS
from .element import Element
from .draw import DrawElement

# Autogenerated
def DefinitionSrc(**args):
    return Element(qname = (SVGNS,'definition-src'), **args)

def Desc(**args):
    return Element(qname = (SVGNS,'desc'), **args)

def FontFaceFormat(**args):
    return Element(qname = (SVGNS,'font-face-format'), **args)

def FontFaceName(**args):
    return Element(qname = (SVGNS,'font-face-name'), **args)

def FontFaceSrc(**args):
    return Element(qname = (SVGNS,'font-face-src'), **args)

def FontFaceUri(**args):
    return Element(qname = (SVGNS,'font-face-uri'), **args)

def Lineargradient(**args):
    return DrawElement(qname = (SVGNS,'linearGradient'), **args)

def Radialgradient(**args):
    return DrawElement(qname = (SVGNS,'radialGradient'), **args)

def Stop(**args):
    return Element(qname = (SVGNS,'stop'), **args)

def Title(**args):
    return Element(qname = (SVGNS,'title'), **args)

########NEW FILE########
__FILENAME__ = table
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import TABLENS
from .element import Element


# Autogenerated
def Body(**args):
    return Element(qname = (TABLENS,'body'), **args)

def CalculationSettings(**args):
    return Element(qname = (TABLENS,'calculation-settings'), **args)

def CellAddress(**args):
    return Element(qname = (TABLENS,'cell-address'), **args)

def CellContentChange(**args):
    return Element(qname = (TABLENS,'cell-content-change'), **args)

def CellContentDeletion(**args):
    return Element(qname = (TABLENS,'cell-content-deletion'), **args)

def CellRangeSource(**args):
    return Element(qname = (TABLENS,'cell-range-source'), **args)

def ChangeDeletion(**args):
    return Element(qname = (TABLENS,'change-deletion'), **args)

def ChangeTrackTableCell(**args):
    return Element(qname = (TABLENS,'change-track-table-cell'), **args)

def Consolidation(**args):
    return Element(qname = (TABLENS,'consolidation'), **args)

def ContentValidation(**args):
    return Element(qname = (TABLENS,'content-validation'), **args)

def ContentValidations(**args):
    return Element(qname = (TABLENS,'content-validations'), **args)

def CoveredTableCell(**args):
    return Element(qname = (TABLENS,'covered-table-cell'), **args)

def CutOffs(**args):
    return Element(qname = (TABLENS,'cut-offs'), **args)

def DataPilotDisplayInfo(**args):
    return Element(qname = (TABLENS,'data-pilot-display-info'), **args)

def DataPilotField(**args):
    return Element(qname = (TABLENS,'data-pilot-field'), **args)

def DataPilotFieldReference(**args):
    return Element(qname = (TABLENS,'data-pilot-field-reference'), **args)

def DataPilotGroup(**args):
    return Element(qname = (TABLENS,'data-pilot-group'), **args)

def DataPilotGroupMember(**args):
    return Element(qname = (TABLENS,'data-pilot-group-member'), **args)

def DataPilotGroups(**args):
    return Element(qname = (TABLENS,'data-pilot-groups'), **args)

def DataPilotLayoutInfo(**args):
    return Element(qname = (TABLENS,'data-pilot-layout-info'), **args)

def DataPilotLevel(**args):
    return Element(qname = (TABLENS,'data-pilot-level'), **args)

def DataPilotMember(**args):
    return Element(qname = (TABLENS,'data-pilot-member'), **args)

def DataPilotMembers(**args):
    return Element(qname = (TABLENS,'data-pilot-members'), **args)

def DataPilotSortInfo(**args):
    return Element(qname = (TABLENS,'data-pilot-sort-info'), **args)

def DataPilotSubtotal(**args):
    return Element(qname = (TABLENS,'data-pilot-subtotal'), **args)

def DataPilotSubtotals(**args):
    return Element(qname = (TABLENS,'data-pilot-subtotals'), **args)

def DataPilotTable(**args):
    return Element(qname = (TABLENS,'data-pilot-table'), **args)

def DataPilotTables(**args):
    return Element(qname = (TABLENS,'data-pilot-tables'), **args)

def DatabaseRange(**args):
    return Element(qname = (TABLENS,'database-range'), **args)

def DatabaseRanges(**args):
    return Element(qname = (TABLENS,'database-ranges'), **args)

def DatabaseSourceQuery(**args):
    return Element(qname = (TABLENS,'database-source-query'), **args)

def DatabaseSourceSql(**args):
    return Element(qname = (TABLENS,'database-source-sql'), **args)

def DatabaseSourceTable(**args):
    return Element(qname = (TABLENS,'database-source-table'), **args)

def DdeLink(**args):
    return Element(qname = (TABLENS,'dde-link'), **args)

def DdeLinks(**args):
    return Element(qname = (TABLENS,'dde-links'), **args)

def Deletion(**args):
    return Element(qname = (TABLENS,'deletion'), **args)

def Deletions(**args):
    return Element(qname = (TABLENS,'deletions'), **args)

def Dependencies(**args):
    return Element(qname = (TABLENS,'dependencies'), **args)

def Dependency(**args):
    return Element(qname = (TABLENS,'dependency'), **args)

def Detective(**args):
    return Element(qname = (TABLENS,'detective'), **args)

def ErrorMacro(**args):
    return Element(qname = (TABLENS,'error-macro'), **args)

def ErrorMessage(**args):
    return Element(qname = (TABLENS,'error-message'), **args)

def EvenColumns(**args):
    return Element(qname = (TABLENS,'even-columns'), **args)

def EvenRows(**args):
    return Element(qname = (TABLENS,'even-rows'), **args)

def Filter(**args):
    return Element(qname = (TABLENS,'filter'), **args)

def FilterAnd(**args):
    return Element(qname = (TABLENS,'filter-and'), **args)

def FilterCondition(**args):
    return Element(qname = (TABLENS,'filter-condition'), **args)

def FilterOr(**args):
    return Element(qname = (TABLENS,'filter-or'), **args)

def FirstColumn(**args):
    return Element(qname = (TABLENS,'first-column'), **args)

def FirstRow(**args):
    return Element(qname = (TABLENS,'first-row'), **args)

def HelpMessage(**args):
    return Element(qname = (TABLENS,'help-message'), **args)

def HighlightedRange(**args):
    return Element(qname = (TABLENS,'highlighted-range'), **args)

def Insertion(**args):
    return Element(qname = (TABLENS,'insertion'), **args)

def InsertionCutOff(**args):
    return Element(qname = (TABLENS,'insertion-cut-off'), **args)

def Iteration(**args):
    return Element(qname = (TABLENS,'iteration'), **args)

def LabelRange(**args):
    return Element(qname = (TABLENS,'label-range'), **args)

def LabelRanges(**args):
    return Element(qname = (TABLENS,'label-ranges'), **args)

def LastColumn(**args):
    return Element(qname = (TABLENS,'last-column'), **args)

def LastRow(**args):
    return Element(qname = (TABLENS,'last-row'), **args)

def Movement(**args):
    return Element(qname = (TABLENS,'movement'), **args)

def MovementCutOff(**args):
    return Element(qname = (TABLENS,'movement-cut-off'), **args)

def NamedExpression(**args):
    return Element(qname = (TABLENS,'named-expression'), **args)

def NamedExpressions(**args):
    return Element(qname = (TABLENS,'named-expressions'), **args)

def NamedRange(**args):
    return Element(qname = (TABLENS,'named-range'), **args)

def NullDate(**args):
    return Element(qname = (TABLENS,'null-date'), **args)

def OddColumns(**args):
    return Element(qname = (TABLENS,'odd-columns'), **args)

def OddRows(**args):
    return Element(qname = (TABLENS,'odd-rows'), **args)

def Operation(**args):
    return Element(qname = (TABLENS,'operation'), **args)

def Previous(**args):
    return Element(qname = (TABLENS,'previous'), **args)

def Scenario(**args):
    return Element(qname = (TABLENS,'scenario'), **args)

def Shapes(**args):
    return Element(qname = (TABLENS,'shapes'), **args)

def Sort(**args):
    return Element(qname = (TABLENS,'sort'), **args)

def SortBy(**args):
    return Element(qname = (TABLENS,'sort-by'), **args)

def SortGroups(**args):
    return Element(qname = (TABLENS,'sort-groups'), **args)

def SourceCellRange(**args):
    return Element(qname = (TABLENS,'source-cell-range'), **args)

def SourceRangeAddress(**args):
    return Element(qname = (TABLENS,'source-range-address'), **args)

def SourceService(**args):
    return Element(qname = (TABLENS,'source-service'), **args)

def SubtotalField(**args):
    return Element(qname = (TABLENS,'subtotal-field'), **args)

def SubtotalRule(**args):
    return Element(qname = (TABLENS,'subtotal-rule'), **args)

def SubtotalRules(**args):
    return Element(qname = (TABLENS,'subtotal-rules'), **args)

def Table(**args):
    return Element(qname = (TABLENS,'table'), **args)

def TableCell(**args):
    return Element(qname = (TABLENS,'table-cell'), **args)

def TableColumn(**args):
    return Element(qname = (TABLENS,'table-column'), **args)

def TableColumnGroup(**args):
    return Element(qname = (TABLENS,'table-column-group'), **args)

def TableColumns(**args):
    return Element(qname = (TABLENS,'table-columns'), **args)

def TableHeaderColumns(**args):
    return Element(qname = (TABLENS,'table-header-columns'), **args)

def TableHeaderRows(**args):
    return Element(qname = (TABLENS,'table-header-rows'), **args)

def TableRow(**args):
    return Element(qname = (TABLENS,'table-row'), **args)

def TableRowGroup(**args):
    return Element(qname = (TABLENS,'table-row-group'), **args)

def TableRows(**args):
    return Element(qname = (TABLENS,'table-rows'), **args)

def TableSource(**args):
    return Element(qname = (TABLENS,'table-source'), **args)

def TableTemplate(**args):
    return Element(qname = (TABLENS,'table-template'), **args)

def TargetRangeAddress(**args):
    return Element(qname = (TABLENS,'target-range-address'), **args)

def TrackedChanges(**args):
    return Element(qname = (TABLENS,'tracked-changes'), **args)


########NEW FILE########
__FILENAME__ = teletype
# -*- coding: utf-8 -*-
#
#   Create and extract text from ODF, handling whitespace correctly.
#   Copyright (C) 2008 J. David Eisenberg
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program; if not, write to the Free Software Foundation, Inc.,
#   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.


"""
Class for handling whitespace properly in OpenDocument.

While it is possible to use getTextContent() and setTextContent()
to extract or create ODF content, these won't extract or create
the appropriate <text:s>, <text:tab>, or <text:line-break>
elements.  This module takes care of that problem.
"""

from odf.element import Node
import odf.opendocument
from odf.text import S,LineBreak,Tab

class WhitespaceText(object):

    def __init__(self):
        self.textBuffer = []
        self.spaceCount = 0

    def addTextToElement(self, odfElement, s):
        """ Process an input string, inserting
            <text:tab> elements for '\t',
            <text:line-break> elements for '\n', and
            <text:s> elements for runs of more than one blank.
            These will be added to the given element.
        """
        i = 0
        ch = ' '

        # When we encounter a tab or newline, we can immediately
        # dump any accumulated text and then emit the appropriate
        # ODF element.
        #
        # When we encounter a space, we add it to the text buffer,
        # and then collect more spaces.  If there are more spaces
        # after the first one, we dump the text buffer and then
        # then emit the appropriate <text:s> element.

        while i < len(s):
            ch = s[i]
            if ch == '\t':
                self._emitTextBuffer(odfElement)
                odfElement.addElement(Tab())
                i += 1
            elif ch == '\n':
                self._emitTextBuffer(odfElement);
                odfElement.addElement(LineBreak())
                i += 1
            elif ch == ' ':
                self.textBuffer.append(' ')
                i += 1
                self.spaceCount = 0
                while i < len(s) and (s[i] == ' '):
                    self.spaceCount += 1
                    i += 1
                if self.spaceCount > 0:
                    self._emitTextBuffer(odfElement)
                    self._emitSpaces(odfElement)
            else:
                self.textBuffer.append(ch)
                i += 1

        self._emitTextBuffer(odfElement)

    def _emitTextBuffer(self, odfElement):
        """ Creates a Text Node whose contents are the current textBuffer.
            Side effect: clears the text buffer.
        """
        if len(self.textBuffer) > 0:
            odfElement.addText(''.join(self.textBuffer))
        self.textBuffer = []


    def _emitSpaces(self, odfElement):
        """ Creates a <text:s> element for the current spaceCount.
            Side effect: sets spaceCount back to zero
        """
        if self.spaceCount > 0:
            spaceElement = S(c=self.spaceCount)
            odfElement.addElement(spaceElement)
        self.spaceCount = 0

def addTextToElement(odfElement, s):
    wst = WhitespaceText()
    wst.addTextToElement(odfElement, s)

def extractText(odfElement):
    """ Extract text content from an Element, with whitespace represented
        properly. Returns the text, with tabs, spaces, and newlines
        correctly evaluated. This method recursively descends through the
        children of the given element, accumulating text and "unwrapping"
        <text:s>, <text:tab>, and <text:line-break> elements along the way.
    """
    result = [];

    if len(odfElement.childNodes) != 0:
        for child in odfElement.childNodes:
            if child.nodeType == Node.TEXT_NODE:
                result.append(child.data)
            elif child.nodeType == Node.ELEMENT_NODE:
                subElement = child
                tagName = subElement.qname;
                if tagName == ("urn:oasis:names:tc:opendocument:xmlns:text:1.0", "line-break"):
                    result.append("\n")
                elif tagName == ("urn:oasis:names:tc:opendocument:xmlns:text:1.0", "tab"):
                    result.append("\t")
                elif tagName == ("urn:oasis:names:tc:opendocument:xmlns:text:1.0", "s"):
                    c = subElement.getAttribute('c')
                    if c:
                        spaceCount =  int(c)
                    else:
                        spaceCount = 1

                    result.append(" " * spaceCount)
                else:
                    result.append(extractText(subElement))
    return ''.join(result)

########NEW FILE########
__FILENAME__ = text
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import TEXTNS
from .element import Element
from .style import StyleElement

# Autogenerated
def A(**args):
    return Element(qname = (TEXTNS,'a'), **args)

def AlphabeticalIndex(**args):
    return Element(qname = (TEXTNS,'alphabetical-index'), **args)

def AlphabeticalIndexAutoMarkFile(**args):
    return Element(qname = (TEXTNS,'alphabetical-index-auto-mark-file'), **args)

def AlphabeticalIndexEntryTemplate(**args):
    return Element(qname = (TEXTNS,'alphabetical-index-entry-template'), **args)

def AlphabeticalIndexMark(**args):
    return Element(qname = (TEXTNS,'alphabetical-index-mark'), **args)

def AlphabeticalIndexMarkEnd(**args):
    return Element(qname = (TEXTNS,'alphabetical-index-mark-end'), **args)

def AlphabeticalIndexMarkStart(**args):
    return Element(qname = (TEXTNS,'alphabetical-index-mark-start'), **args)

def AlphabeticalIndexSource(**args):
    return Element(qname = (TEXTNS,'alphabetical-index-source'), **args)

def AuthorInitials(**args):
    return Element(qname = (TEXTNS,'author-initials'), **args)

def AuthorName(**args):
    return Element(qname = (TEXTNS,'author-name'), **args)

def Bibliography(**args):
    return Element(qname = (TEXTNS,'bibliography'), **args)

def BibliographyConfiguration(**args):
    return Element(qname = (TEXTNS,'bibliography-configuration'), **args)

def BibliographyEntryTemplate(**args):
    return Element(qname = (TEXTNS,'bibliography-entry-template'), **args)

def BibliographyMark(**args):
    return Element(qname = (TEXTNS,'bibliography-mark'), **args)

def BibliographySource(**args):
    return Element(qname = (TEXTNS,'bibliography-source'), **args)

def Bookmark(**args):
    return Element(qname = (TEXTNS,'bookmark'), **args)

def BookmarkEnd(**args):
    return Element(qname = (TEXTNS,'bookmark-end'), **args)

def BookmarkRef(**args):
    return Element(qname = (TEXTNS,'bookmark-ref'), **args)

def BookmarkStart(**args):
    return Element(qname = (TEXTNS,'bookmark-start'), **args)

def Change(**args):
    return Element(qname = (TEXTNS,'change'), **args)

def ChangeEnd(**args):
    return Element(qname = (TEXTNS,'change-end'), **args)

def ChangeStart(**args):
    return Element(qname = (TEXTNS,'change-start'), **args)

def ChangedRegion(**args):
    return Element(qname = (TEXTNS,'changed-region'), **args)

def Chapter(**args):
    return Element(qname = (TEXTNS,'chapter'), **args)

def CharacterCount(**args):
    return Element(qname = (TEXTNS,'character-count'), **args)

def ConditionalText(**args):
    return Element(qname = (TEXTNS,'conditional-text'), **args)

def CreationDate(**args):
    return Element(qname = (TEXTNS,'creation-date'), **args)

def CreationTime(**args):
    return Element(qname = (TEXTNS,'creation-time'), **args)

def Creator(**args):
    return Element(qname = (TEXTNS,'creator'), **args)

def DatabaseDisplay(**args):
    return Element(qname = (TEXTNS,'database-display'), **args)

def DatabaseName(**args):
    return Element(qname = (TEXTNS,'database-name'), **args)

def DatabaseNext(**args):
    return Element(qname = (TEXTNS,'database-next'), **args)

def DatabaseRowNumber(**args):
    return Element(qname = (TEXTNS,'database-row-number'), **args)

def DatabaseRowSelect(**args):
    return Element(qname = (TEXTNS,'database-row-select'), **args)

def Date(**args):
    return Element(qname = (TEXTNS,'date'), **args)

def DdeConnection(**args):
    return Element(qname = (TEXTNS,'dde-connection'), **args)

def DdeConnectionDecl(**args):
    return Element(qname = (TEXTNS,'dde-connection-decl'), **args)

def DdeConnectionDecls(**args):
    return Element(qname = (TEXTNS,'dde-connection-decls'), **args)

def Deletion(**args):
    return Element(qname = (TEXTNS,'deletion'), **args)

def Description(**args):
    return Element(qname = (TEXTNS,'description'), **args)

def EditingCycles(**args):
    return Element(qname = (TEXTNS,'editing-cycles'), **args)

def EditingDuration(**args):
    return Element(qname = (TEXTNS,'editing-duration'), **args)

def ExecuteMacro(**args):
    return Element(qname = (TEXTNS,'execute-macro'), **args)

def Expression(**args):
    return Element(qname = (TEXTNS,'expression'), **args)

def FileName(**args):
    return Element(qname = (TEXTNS,'file-name'), **args)

def FormatChange(**args):
    return Element(qname = (TEXTNS,'format-change'), **args)

def H(**args):
    return Element(qname = (TEXTNS, 'h'), **args)

def HiddenParagraph(**args):
    return Element(qname = (TEXTNS,'hidden-paragraph'), **args)

def HiddenText(**args):
    return Element(qname = (TEXTNS,'hidden-text'), **args)

def IllustrationIndex(**args):
    return Element(qname = (TEXTNS,'illustration-index'), **args)

def IllustrationIndexEntryTemplate(**args):
    return Element(qname = (TEXTNS,'illustration-index-entry-template'), **args)

def IllustrationIndexSource(**args):
    return Element(qname = (TEXTNS,'illustration-index-source'), **args)

def ImageCount(**args):
    return Element(qname = (TEXTNS,'image-count'), **args)

def IndexBody(**args):
    return Element(qname = (TEXTNS,'index-body'), **args)

def IndexEntryBibliography(**args):
    return Element(qname = (TEXTNS,'index-entry-bibliography'), **args)

def IndexEntryChapter(**args):
    return Element(qname = (TEXTNS,'index-entry-chapter'), **args)

def IndexEntryLinkEnd(**args):
    return Element(qname = (TEXTNS,'index-entry-link-end'), **args)

def IndexEntryLinkStart(**args):
    return Element(qname = (TEXTNS,'index-entry-link-start'), **args)

def IndexEntryPageNumber(**args):
    return Element(qname = (TEXTNS,'index-entry-page-number'), **args)

def IndexEntrySpan(**args):
    return Element(qname = (TEXTNS,'index-entry-span'), **args)

def IndexEntryTabStop(**args):
    return Element(qname = (TEXTNS,'index-entry-tab-stop'), **args)

def IndexEntryText(**args):
    return Element(qname = (TEXTNS,'index-entry-text'), **args)

def IndexSourceStyle(**args):
    return Element(qname = (TEXTNS,'index-source-style'), **args)

def IndexSourceStyles(**args):
    return Element(qname = (TEXTNS,'index-source-styles'), **args)

def IndexTitle(**args):
    return Element(qname = (TEXTNS,'index-title'), **args)

def IndexTitleTemplate(**args):
    return Element(qname = (TEXTNS,'index-title-template'), **args)

def InitialCreator(**args):
    return Element(qname = (TEXTNS,'initial-creator'), **args)

def Insertion(**args):
    return Element(qname = (TEXTNS,'insertion'), **args)

def Keywords(**args):
    return Element(qname = (TEXTNS,'keywords'), **args)

def LineBreak(**args):
    return Element(qname = (TEXTNS,'line-break'), **args)

def LinenumberingConfiguration(**args):
    return Element(qname = (TEXTNS,'linenumbering-configuration'), **args)

def LinenumberingSeparator(**args):
    return Element(qname = (TEXTNS,'linenumbering-separator'), **args)

def List(**args):
    return Element(qname = (TEXTNS,'list'), **args)

def ListHeader(**args):
    return Element(qname = (TEXTNS,'list-header'), **args)

def ListItem(**args):
    return Element(qname = (TEXTNS,'list-item'), **args)

def ListLevelStyleBullet(**args):
    return Element(qname = (TEXTNS,'list-level-style-bullet'), **args)

def ListLevelStyleImage(**args):
    return Element(qname = (TEXTNS,'list-level-style-image'), **args)

def ListLevelStyleNumber(**args):
    return Element(qname = (TEXTNS,'list-level-style-number'), **args)

def ListStyle(**args):
    return StyleElement(qname = (TEXTNS,'list-style'), **args)

def Measure(**args):
    return Element(qname = (TEXTNS,'measure'), **args)

def ModificationDate(**args):
    return Element(qname = (TEXTNS,'modification-date'), **args)

def ModificationTime(**args):
    return Element(qname = (TEXTNS,'modification-time'), **args)

def Note(**args):
    return Element(qname = (TEXTNS,'note'), **args)

def NoteBody(**args):
    return Element(qname = (TEXTNS,'note-body'), **args)

def NoteCitation(**args):
    return Element(qname = (TEXTNS,'note-citation'), **args)

def NoteContinuationNoticeBackward(**args):
    return Element(qname = (TEXTNS,'note-continuation-notice-backward'), **args)

def NoteContinuationNoticeForward(**args):
    return Element(qname = (TEXTNS,'note-continuation-notice-forward'), **args)

def NoteRef(**args):
    return Element(qname = (TEXTNS,'note-ref'), **args)

def NotesConfiguration(**args):
    return Element(qname = (TEXTNS,'notes-configuration'), **args)

def Number(**args):
    return Element(qname = (TEXTNS,'number'), **args)

def NumberedParagraph(**args):
    return Element(qname = (TEXTNS,'numbered-paragraph'), **args)

def ObjectCount(**args):
    return Element(qname = (TEXTNS,'object-count'), **args)

def ObjectIndex(**args):
    return Element(qname = (TEXTNS,'object-index'), **args)

def ObjectIndexEntryTemplate(**args):
    return Element(qname = (TEXTNS,'object-index-entry-template'), **args)

def ObjectIndexSource(**args):
    return Element(qname = (TEXTNS,'object-index-source'), **args)

def OutlineLevelStyle(**args):
    return Element(qname = (TEXTNS,'outline-level-style'), **args)

def OutlineStyle(**args):
    return Element(qname = (TEXTNS,'outline-style'), **args)

def P(**args):
    return Element(qname = (TEXTNS, 'p'), **args)

def Page(**args):
    return Element(qname = (TEXTNS,'page'), **args)

def PageContinuation(**args):
    return Element(qname = (TEXTNS,'page-continuation'), **args)

def PageCount(**args):
    return Element(qname = (TEXTNS,'page-count'), **args)

def PageNumber(**args):
    return Element(qname = (TEXTNS,'page-number'), **args)

def PageSequence(**args):
    return Element(qname = (TEXTNS,'page-sequence'), **args)

def PageVariableGet(**args):
    return Element(qname = (TEXTNS,'page-variable-get'), **args)

def PageVariableSet(**args):
    return Element(qname = (TEXTNS,'page-variable-set'), **args)

def ParagraphCount(**args):
    return Element(qname = (TEXTNS,'paragraph-count'), **args)

def Placeholder(**args):
    return Element(qname = (TEXTNS,'placeholder'), **args)

def PrintDate(**args):
    return Element(qname = (TEXTNS,'print-date'), **args)

def PrintTime(**args):
    return Element(qname = (TEXTNS,'print-time'), **args)

def PrintedBy(**args):
    return Element(qname = (TEXTNS,'printed-by'), **args)

def ReferenceMark(**args):
    return Element(qname = (TEXTNS,'reference-mark'), **args)

def ReferenceMarkEnd(**args):
    return Element(qname = (TEXTNS,'reference-mark-end'), **args)

def ReferenceMarkStart(**args):
    return Element(qname = (TEXTNS,'reference-mark-start'), **args)

def ReferenceRef(**args):
    return Element(qname = (TEXTNS,'reference-ref'), **args)

def Ruby(**args):
    return Element(qname = (TEXTNS,'ruby'), **args)

def RubyBase(**args):
    return Element(qname = (TEXTNS,'ruby-base'), **args)

def RubyText(**args):
    return Element(qname = (TEXTNS,'ruby-text'), **args)

def S(**args):
    return Element(qname = (TEXTNS,'s'), **args)

def Script(**args):
    return Element(qname = (TEXTNS,'script'), **args)

def Section(**args):
    return Element(qname = (TEXTNS,'section'), **args)

def SectionSource(**args):
    return Element(qname = (TEXTNS,'section-source'), **args)

def SenderCity(**args):
    return Element(qname = (TEXTNS,'sender-city'), **args)

def SenderCompany(**args):
    return Element(qname = (TEXTNS,'sender-company'), **args)

def SenderCountry(**args):
    return Element(qname = (TEXTNS,'sender-country'), **args)

def SenderEmail(**args):
    return Element(qname = (TEXTNS,'sender-email'), **args)

def SenderFax(**args):
    return Element(qname = (TEXTNS,'sender-fax'), **args)

def SenderFirstname(**args):
    return Element(qname = (TEXTNS,'sender-firstname'), **args)

def SenderInitials(**args):
    return Element(qname = (TEXTNS,'sender-initials'), **args)

def SenderLastname(**args):
    return Element(qname = (TEXTNS,'sender-lastname'), **args)

def SenderPhonePrivate(**args):
    return Element(qname = (TEXTNS,'sender-phone-private'), **args)

def SenderPhoneWork(**args):
    return Element(qname = (TEXTNS,'sender-phone-work'), **args)

def SenderPosition(**args):
    return Element(qname = (TEXTNS,'sender-position'), **args)

def SenderPostalCode(**args):
    return Element(qname = (TEXTNS,'sender-postal-code'), **args)

def SenderStateOrProvince(**args):
    return Element(qname = (TEXTNS,'sender-state-or-province'), **args)

def SenderStreet(**args):
    return Element(qname = (TEXTNS,'sender-street'), **args)

def SenderTitle(**args):
    return Element(qname = (TEXTNS,'sender-title'), **args)

def Sequence(**args):
    return Element(qname = (TEXTNS,'sequence'), **args)

def SequenceDecl(**args):
    return Element(qname = (TEXTNS,'sequence-decl'), **args)

def SequenceDecls(**args):
    return Element(qname = (TEXTNS,'sequence-decls'), **args)

def SequenceRef(**args):
    return Element(qname = (TEXTNS,'sequence-ref'), **args)

def SheetName(**args):
    return Element(qname = (TEXTNS,'sheet-name'), **args)

def SoftPageBreak(**args):
    return Element(qname = (TEXTNS,'soft-page-break'), **args)

def SortKey(**args):
    return Element(qname = (TEXTNS,'sort-key'), **args)

def Span(**args):
    return Element(qname = (TEXTNS,'span'), **args)

def Subject(**args):
    return Element(qname = (TEXTNS,'subject'), **args)

def Tab(**args):
    return Element(qname = (TEXTNS,'tab'), **args)

def TableCount(**args):
    return Element(qname = (TEXTNS,'table-count'), **args)

def TableFormula(**args):
    return Element(qname = (TEXTNS,'table-formula'), **args)

def TableIndex(**args):
    return Element(qname = (TEXTNS,'table-index'), **args)

def TableIndexEntryTemplate(**args):
    return Element(qname = (TEXTNS,'table-index-entry-template'), **args)

def TableIndexSource(**args):
    return Element(qname = (TEXTNS,'table-index-source'), **args)

def TableOfContent(**args):
    return Element(qname = (TEXTNS,'table-of-content'), **args)

def TableOfContentEntryTemplate(**args):
    return Element(qname = (TEXTNS,'table-of-content-entry-template'), **args)

def TableOfContentSource(**args):
    return Element(qname = (TEXTNS,'table-of-content-source'), **args)

def TemplateName(**args):
    return Element(qname = (TEXTNS,'template-name'), **args)

def TextInput(**args):
    return Element(qname = (TEXTNS,'text-input'), **args)

def Time(**args):
    return Element(qname = (TEXTNS,'time'), **args)

def Title(**args):
    return Element(qname = (TEXTNS,'title'), **args)

def TocMark(**args):
    return Element(qname = (TEXTNS,'toc-mark'), **args)

def TocMarkEnd(**args):
    return Element(qname = (TEXTNS,'toc-mark-end'), **args)

def TocMarkStart(**args):
    return Element(qname = (TEXTNS,'toc-mark-start'), **args)

def TrackedChanges(**args):
    return Element(qname = (TEXTNS,'tracked-changes'), **args)

def UserDefined(**args):
    return Element(qname = (TEXTNS,'user-defined'), **args)

def UserFieldDecl(**args):
    return Element(qname = (TEXTNS,'user-field-decl'), **args)

def UserFieldDecls(**args):
    return Element(qname = (TEXTNS,'user-field-decls'), **args)

def UserFieldGet(**args):
    return Element(qname = (TEXTNS,'user-field-get'), **args)

def UserFieldInput(**args):
    return Element(qname = (TEXTNS,'user-field-input'), **args)

def UserIndex(**args):
    return Element(qname = (TEXTNS,'user-index'), **args)

def UserIndexEntryTemplate(**args):
    return Element(qname = (TEXTNS,'user-index-entry-template'), **args)

def UserIndexMark(**args):
    return Element(qname = (TEXTNS,'user-index-mark'), **args)

def UserIndexMarkEnd(**args):
    return Element(qname = (TEXTNS,'user-index-mark-end'), **args)

def UserIndexMarkStart(**args):
    return Element(qname = (TEXTNS,'user-index-mark-start'), **args)

def UserIndexSource(**args):
    return Element(qname = (TEXTNS,'user-index-source'), **args)

def VariableDecl(**args):
    return Element(qname = (TEXTNS,'variable-decl'), **args)

def VariableDecls(**args):
    return Element(qname = (TEXTNS,'variable-decls'), **args)

def VariableGet(**args):
    return Element(qname = (TEXTNS,'variable-get'), **args)

def VariableInput(**args):
    return Element(qname = (TEXTNS,'variable-input'), **args)

def VariableSet(**args):
    return Element(qname = (TEXTNS,'variable-set'), **args)

def WordCount(**args):
    return Element(qname = (TEXTNS,'word-count'), **args)


########NEW FILE########
__FILENAME__ = thumbnail
#!/usr/bin/python
# -*- coding: utf-8 -*-
# This contains a 128x128 px thumbnail in PNG format
# Taken from http://www.zwahlendesign.ch/en/node/20
# openoffice_icons/openoffice_icons_linux/openoffice11.png
# License: Freeware
import base64

iconstr = """\
iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAAG0OVFdAAAABGdBTUEAANbY1E9YMgAAABl0RVh0
U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAFoHSURBVHjaYvz//z8DJQAggFhu3LiBU1JI
SOiPmJgYM7IYUD0jMh8ggFhAhKamJuOHDx/+8fPz4zQsMTGRYf78+RjiAAHEBCJOnTr1HZvmN2/e
MDAyQiycOXMmw5MnTxhmzZoViqwGIIAYrl+/DqKM/6OBNWvWgOmvX7/+37Rp0/8jR478//fv3/+f
P3/+h+phPHHixH+AAIK75D8WMGnSpP8vXrz4//v37/9///6Fi4MMALruf3Bw8H+AAAJp5rQrOoeh
edmyZWAbgd77f/bsWTAbBoB6JOpbmkF0OkAAgcLgO8gUYCCCnSIlJQWmw8LCGA4cOAAOAyMjI3hY
gMDvP7+f3791+weQuQAggGBi7FPmrvnf3NwMtgnkt/Xr1//fuXMn2EaQ5TB89+nX/wUlJSDbPUFe
AQgguKleiY2/QIpBTv727TuKJhB+//nf/xtP/4ANrK6tBRnAATIAIICQEwUjUCHIoyjOBYGbz/8y
8HMwMXCzfmcoLC1kMDH3YNDU1mGQ4PvLCBBALEjq/t958Zfh0dt/DL/+MDD8BdkBNIeXnYFBhIeR
4efffwybNqxgEOEXZLjw25Xh2QMWhmi9BwwAAYRsAMO5268ZZMREGGSEGBmYgcEL1MMAcgwo3D9/
+sIwf84cBhHLGoYAVVYGxi/3wDYABBCKU6dPn37s1vM//3/+/v//20+gn5/9+b/7yq//iw++/6+o
qAhy0zUg1gH5HYYBAgg99Srsvvzz//6Tt//beSf+V/doBGkqheaFL0CKF1kzCAMEECOWfAMSY3Yq
PvF7X68FKCcCPcLAA8QqQHwB3VaAAGKktDwACCCc5QETE5ODjIzMfi4uLoRtjIwiQBe8RVYHEEDg
WODh4dkBTMLuQE1YDdPR0WG4cuUKw6tXr968ffsWxdsAAQTWAbQJq+aenh5wogJpBpUNzMzMGGoA
AggckshZFRmA8sXz58/BeQKY2WA5kRmkp7Oz8z8vL+8WgAACG3Lv3j0Mze/fvwcpBuaLb/9//foF
FweG2U9dXV2RixcvguTNAAKIAVQWaPt2oGgGlT4gzSBDNm/e/P/jx48o8n/+/PlraWkJil5OgAAC
OUDEKvsgWOLdu3f/k5KSwOxPnz79nzt3LrgIQwY/fvz4X1FbDbIgAOQVgAACxcIbFnZesFcEBQXB
AbdhwwYGNjY2BmdnZzANSypffvxn4OFgY/j5+TvI9i0gMYAAgkUJI7Dc+/flyxeGly9fMaipqWEE
9m1gTv329RvDjAmVDE52dgx6enpgvQABBIu7//fvPwCmB14Mze+//geXBwKcTAwn9q9kEOIXYNC2
8IfLAwQQcqIIOHPv9/o3X/4z/PkLzABAR7KyQMoCPi5Ghm9fvjJM7i5lUDbwYXjI4sIwK41LHBgG
rwACCLk82Pvq038GaQEmBi52iAEwK/4BDbx7cTeDEB8/w42/TgwhRt8ZzNeeeAHyAUAAoSTL15/+
/f/++z+DrBATw/P3/xgeAkunt5//MSzYcpOhJYyNQUNDowGorA9o82eYHoAAQjFgw6kv/yV4/zLc
v3WRoaRxBoOEtj/D2cXhPECNAcAExAbUiFE5AgQQenkAis/PrkWH/u/us3MGsvdBxYOAeD3QAIy8
DxBAjNiKJXIAqIZ//PjxYT4+PmtgHmEAJjiGhw8fMhLSBxBALIQUcHBw1AINbAIZCkqUuABywQZM
kwzAnMBw//79TcCy2A+f+QABBA4BoOuZHj169FdWVpYs3wPzKoOAgACKI0BsYCnDwMrKyg204xsu
vQABxAQtkv6FhISUEmuho6Mjw9OnT+F8UNsIWHQxAMsChtOnT4PaSwzAVglYDBgNX9H129raci8C
AhAbIICQkTCoACEWgAoVDw8PcKl17Nix/ydPnvx//vz5/9jMAKqRh9Vi9fX1YLHe3l6QuD1AAMEs
ZwUVi6s37CTK8t27d4MtBrW7QPj169f/79y58x+YCDFKP1jJCIruurq6VyC+t4/Pf2DUgAozSYAA
Atvu4Wm5D+QA47hVoLIWwwBQsVpaWgq2FIRVVVX/gxp427dv/79kyZL/Fy5cAIcIPrBh/QZwtZOS
mvoXmLDngDIOKEQAAgg5CmLsis7+v3XrFlgDyAJIWoIAkM+A8Q5ufYEqidmzZ4Md8PnzZxzVGQSD
wN79+8F0ekb6X2C92AyqRmFRAhBA6PnUVtuv99CVjUXwlAysicEKQZUuKJcAm/7AlM0GrmyBwYi9
ogWa+hYY6m+AxeDPt9cY9PV0GSoqKxjef/jGMGvGZGmgec9gSgECCFtBofvu3ftLoJQNjFuwI0RF
RRlwNRkQbQ4Ghmfv/jF8BlZaoKDjAzYnb1w4wHDx+lWG98A66s27zwwVZUUM8vJyakAH3IbpAwgg
rCXVxo2bnvr5+Ur9+w+pFX78+s/w8w+kvQnyMCsQs7GAeIwM91//A6r5z8DLAQwRFmDVwwnUA1R6
4uhBhl0H9jG8efacgZldgCE4Pp+BiUuc4fTNLwyVwUJMsGIZIIBwFZUam89+u84GrND+QZMeKQ04
acYbDGs3bWR4B/T5kbtcDLouWQycvKLgqp0FGJBGghdu2mgLaoDUAgQQrqL4BjOw/augogGuXNnZ
GBn4OUG+Y2RgY4W2l7//Bwb3P2BpB2oGMjKwMDMy3ARW+5nRbgwB7hYMTk5ODIVdWxmiQp0Yvj5b
9qy1uHIn0NyroH4dyHxYDgAIIHyVhdvzd392vvj4nwGYdhi+AKOBGdpY//vvDwPr348MX94+BVed
fTPXMry4tm02qMbLzs7eBmynrwOWgsuA/G1Ai77jCy2AAMLnAM75S1a/SIwJ3QTqpoAEzFO3N7Nx
CTEwMrMycN8qvLB9y8FAoPADmFna2tp/rl69mglyCKh9QExNCxBAjCTWOxKg+h6Iv2KRAzXDxYD4
ORD/ROoG4wUAAURx/4BSABBAeMcbSAHA4jUF2M2YDWo3sLOzM0ybNi0SmBBXENIHEEAkt4hALR9g
FTsX2PJJBFrIwMKCPSMB2xcMwI4BwSgGCCC8LSJgBSMtLi5+AGiRCsgyUPFLTJRt3bqVwdXVFRQS
oK7MX3xqAQII7gCgTyKBrZplIIuAwUlyFADbAwwWFhZgB3p7e8OEZYD4IT59AAEEGzKyBuVb9CEC
YsHy5csZysvLUUIH1Bq6du3aLdBACD69AAEEC4GXwHYAuHYjFqxevZph3bp1DCtWrACH2Pfv38EO
AHWQgFU0OLqEhYXZQM00fAAggGBV3DPYeA8hAEq0SkpKDKGhoWCfgywFWQ7shTLcvXuXAdjzBLeI
QVEpIiICCl1hdDMWLFiwCtirBdsNEEDwEQdgcBFsih08eBCFD2qOgTqloEYMaIwJmPjATTPkLvG2
bds2IY9sAHt/6rDhNFAAAAQQ3FWtra1biW2Qgjrvly5dAteTwP422HJQo/TBgwcYTTpgg+Y/zHIX
FxdWYGj9P3fu3H9g6LwHNYQBAgil8kEel8NneXp6OthyUF8e1H8HNddAoYGtPQlSD+3LM2ZmZoLF
Nm7c+B86XMcLEEBgmw10JazMUrYSbFiC23VQy0EhABreACa6/8BCBxz0oEEFbJ4ANmiDgXoEQOyG
1tb/VlZWIDNAvWxGgABiSSqseXiHMUju359fDEADGCQkJHAmwJUrV4LbiKDEBeyxgjodDLdv3wY3
19TV1Rm4ubkZsGXlnJycNdpa2vfAQwXAtAbsP2wEMu+AWkUAAQQSkwU1yUH4ypUrGK4HKQImJHiT
HIRBiezy5cvgJjko4b18+fI/vugDhdK/P//+VTfU/09ISACNliaCogWULgACCJQVHp+aYtQEToiz
9qK4fP/+/aBsBC5WQdkNVLiAshtoCBqU3Tg5ORmMjY3BjVZ8hdiZM2eBbQhGxhdPnv4DOrofZDSs
oQIQQOC8+OMXQw+IvvaSB16axcTEMJiYmID5oKY3KG/fvHmTAZjwwMUuyCGgQTRcloOMAeFPX34A
+4I2DKWVlUA9P38DE+oRoDS8YwkQQLCS8POhPiNfi/Rdm0H9ehUVFXjnE2QRsMvFAExkDF+/fgWX
lqAmu4KCArifAIp/XPXTm8//GW5dPs9gbW3JwAxUtGL5ik7ooOVvmBqAAEKuDXfwcLIwvH37Fm45
MHuBfQ2MY3DilJSUZIDUikxgi5EHsVC668DAffcF2Ef4/BVseU5hAYMwjyBo3ABUN7xEVgsQQMi9
jT97JjgZvHkDGc8E9e1BdfqPHz8Z9PUNGLS1QcEtBox3LnDZj2uw4hWwEfvyw1+G38B+BOsviEcE
efkYXgNzGLC/0Qn0/R9k9QABhN7duTRn/pyPIF/9/PkLWJ9zAC3WBscz1i4YUsPy0zfIAPuHb//A
vSRulh8MZ8+dY4iMjWX49/cfg6OjHYORiYU0ul6AAMKWdAP+/v23HpT4YAmQEHj05h/Dj9//wRYL
8zCBHXTs4DaG81cuM7x98YLh229mhqjEPAZpaRkGNSkWPuRhMoAAwtbhOwmKe2ZmYDwDLf8G7A98
+g7qG/wHxi2w5gPy//6HWPYOmMhuPvsL7raJAC2WFmQGdlCAXTfGbwzPgenm0YMHQHNYGGxsHRg+
M4kz3H71jyGlbGoOsmUAAYStSfbm3M3XDAIiUkAL/zF8+8nI8PM3pMMJshSMQcPGTJA+IiewCcEJ
7Dm9AAYzGzNktuHZrdMMt+7eYeAA9qKffGBmEPinx3DkNNDRTH8Yfoh4tAHzVjvMMoAAwhYCv6/f
f/Xv6XtgKgam5j/AugTUMQZZyMSImKwAWfQdmJnefQM1Jv6D50zuAH14/fFnBhU1VYY3r18y8PHx
M3zms2F4/EUEaDmk06ogKw4q3OAeBwggrI3SnprEqgnLz3aAesCgXi8fEIPLGuiEDIyJngVBFZ+l
jgLDbWCZIcgrwLDj4l8GbSdDBi52JgZ3/f8M74FZ/O2rZ7C2IrhHBRBAWB1w89rlAwrC0PAGdXlY
GRmE+BjBQQ0S+v7zP8MvoO+/AtPDDyAN6jPyczEyHLryHjyC9ub1awZhUQkGHVZRBnOJ2wzt5Zbb
Jj55AuqYngXlNOSSECCAcBXgou8/fnn16RcneGxAQpAJHBKgIASNmoMGgD8AE+QXYBR9A6aPP7//
MGw69prh8e1zDOZCFxiAjRSGkJCQbaD5JKilr9HzPwwABBAuBzBdu3n/LwuvLDCOgTng639wnP+D
TFcC8Q+Gv19fMnx5/5yhu386w9kDK0CWzAE269k3bdo0wc7ODlTkggai7mIbH0YGAAGEq2Py7/jl
J98klKW5+Dj+MvAxfWJ4+/opw707VxnaJq1g4BRUYOCT1GWQF3z9G2i5JdSXjOvXr/8HtXwZMZaD
AEAA4esIRLu7e+bu3Ln9JJB9xSh2+SwOPikG2AQHsPIKh3bDwRULsGiWB9aeB48dOxYH5B4FZRRi
un0AAYTPAWxQ+Z9Qvg2w0XIYaDGo6gb58g2aen0gVgXiXaCSmdjuOUAAkdIVAqlVBjWlcMhLgio0
qMP+E+sAgACi2nwBLQGoRw7se7gCO7uJwHZnBLBNyobcpqAEAAQQy0B6DNjkUAR6KAnYvIgFpWFQ
EwM0tgEackBu5SH3eUHNlNOnT98GBgpovPMXpW4ACCAWWsQWsPUYB/RIPNBjjjBPgVqShAZ7iQGg
1omysrK8lpaWJpB7kVLzAAKI6CwA9IAlECcBPRMDxBwgj4EwrgEiagDQnHdRURHD4sWLGbq7uxlK
Skrgcvfv3weNEaA0rcgBAAEEDwBQzC1cuNDO39//AB8fHwO5QzUUZgmG3t5ehoqKCnCyB3UPQHMT
2ABoQGTt2rU9sbGxZcTUN7gAQACxII26/AcGwndQgIACgB4A5MEHwDbrt2/fGC5cuMCQl5cHbkb8
g89aI8oAkBhoCAuEQWxQdrK1tQUlCVA38xm5bgAIIPRMeX/Xrl0HQQ6iNgD1Ljdu3Ahf2hQVFQVO
xvr6+iCPMOTm5oI9eunSJUgHDehR0Fjb8+fPwaMP165dA9MgPkgclFrExMRAXeRjwIhjJdddAAGE
UgYADQL1f1yBsbJdTk6OKtkAlH+zs7PBMY0rOYNiFIRBngIFFMiDoNQBKgNAM+CgIRfQcAxIP6hX
DCp7YAUqaDjHxsbGAJgdLuIrmC0tLa+tXLlSA2Tew4cP/8bFxXE9efLkH0AAYRSCQMWKBw8ePG9h
YcGPb5qeGIBtZRhsNh00/gByfG1tLcPSpUvBMd7f389gaGgIlgOpA2VF0HAAqFMMWo6Eq3967949
UM2AtUD08vLiAeK7QHvEQOtjgCmcAeh50Ey/FjDQHwIEEDbzuCQlJVNB403UBKCRPNDYZEZGxn9g
coePc7W0tPwHDc6C1iEBYwS8aAlkN2jgFbT+CNuQIzoAqQOmtG5YioZGKouTk9NP0FgodNnR/zlz
5vzfsWPHf2Dq6QOldCAWAQggbM1NXv9Q/9OggTpcq6tIBaAx1Pz8/P8bNmyAexxkPmjFJmzBJciB
oOFR0BQ4aMUWSA/IYyB5YsZtQdPpoKk0qOfZHBwcnoNGob/+/P5/2owZ/1tbW/8fPXoUZn8CA2Rp
HStAADFCPS0UXTbt3uM/FuDi/8+PTwzavNcYeqqiKa4ROjo6wENtoDF9cHe7p4ehsLAQnMRBox+g
/A5aeAIa+wMlfVAyB+VzUHIF2Q0agCSmrQHKVsCa5AGwR6QBbKeI37x585S8vLz49bt3GKrLKxiE
geYBszaoIAWtGQCtKboIDKz3AAEEMhlUglrCPA9OOxy8DCfvsYCn7EFTb8QWhiALlixZAsqP4NId
BCorK1GW9IAKO1DeB40zg0p0EBvkeJA9oPwuLi4OXoUDaj0SMyaF3EJUVFRUAJZhFgcOHlwtBiw4
rty6yVBXVc1gaW7+e+bMmX/v3r3bC+0qgpZ1fgTpAwggRqT2gI1D0en9/xgglv78/JIhy/kPQ5i/
C96JM1DVBmrmIk2OMVhbWzP4+vqCqylQTIPqeGDeZ5CWlmZ49uwZeGAdFLigwACV7KAaB7QaGDTo
CjKLnNoHZA9oDJWNg51BSECQ4cLVqwz1wALWztr61+zZs/8CU0QtdLIe5Pn3oNVKIH0AAcSI1iYw
DClZfOLVP22Wf39/Mby7e4hh98xo+FJlGAAtS9q5cydDQkICQ1JSEsPcuXMxqjVQqQ6q0kDJHJS0
QUkd5GlQAIDm0UClOmh0GTTKDKriQDFOnsch9j14cB8YgIJAs4QYTl04z9Bc38BgbWnxa+HCRb9u
3LhRCvU8qCv9GbnlCBBAjFgKQZXo9MwDj7lTpb69vccwr1gNPEkAyoegUAbFKmhcHjR5gJ4HQR4F
5WVQsgZNEILYoCYrKOmD5EGBAqveQLEOzKPgFIArqROaFgbJv//yl+E2MKmrK0sByw0BhqOnTjK0
tbQymJub/dm6ecvXUydPlgGVnoZ6/gt6sxkggHAFuZStrfb0f/oz/ER/n2GY1x4PLpSAfQWG+Ph4
lGQHimVQIQZqtIBiGDSHAAKgGAU1YEAxDcpCIE+CYhjUgIHI8eCt23EtDQItGP/4DTRI9h/o+X8M
j+9fY7AxVgWaxcmw/8gRhq72dgYfbx+GbVu3MWzbtiULmudB81NfsfUZAAIIX5oDNdviDCLm969s
tGJQVVVFSaIgj4Nmd0GFGSjGQYEBKshAMcrLCym9YV1gSlqUIK0/gb3+Lz//M4DWp3798R+ezR7e
vshgZ64N9vzOffsYJgA7UmGh4cDGzg4GNQ19hlUrFmfcuH51KS7PgwBAABFyGTdotqp76vIZWQl+
DLDF4aA5E5CnQRjkEJDHQSU3SJ4a3WOQp0EDvp+BMf3l5z8wm4kRkez//vvL8PzueQZBXlaGA0eP
APM+L8OqlasZEmPjGLZs3sygq2/IYGRmy8DPx8NgYaIjBKrucNkFEEDERA1oPX7Z06fPakEzVKCY
BuVpUOEGHY2k2mDHT6BHQTMhn779g+yLgI3GM0JWwoGG6n//Bub5GxeAofCDYdf+feAIuHDmLIOn
pwfDWSCtpaPHYGRqzSAjr8bwl4GN4cal4/uC/ZxdYaU+OgAIIGKiC7SbYQ0wf9eCCkBQnoUNhmAL
TZiDiVmKBFL3DZi8P4Cm84Aeh818gD3MCfEwaECcA9hS4WJnZPj2/Q/DjZvnGVgY/zFs2buH4dfv
XwwXz55jcHJwZLh46QaDpJIeg4qOLYOEHNDzzFwMX4Fm/+RRd4LORTzC5gaAACI2c/L7+fnX9U+Z
W8TOLcjw4w+ou/of4mFGREiCVheCkuq//4jQ+AddrffnH2Q66ecfyLJDYIUAXob4H+pvUALi4WAE
eg6Y74CeZwZng/8MXGyM4MV77z7/YTh/9igDO8tfhv2HD4Gr1XvA7rGRgSHDk2cvGIRkdBgUtKwY
FJWUGV594WC49OgfUA/QTqb/DNy/b3+fmGcgCEwFP9E9BhBApJROVnM3Xz0qLq0CXiXIiJQn/xNZ
bRGq0hiQZp1AAQlis4Irib8MX5+cAmaDfwyHjh4GN3hePX/BoKWpxXDl9nMGRkEDBhZxCwZeEQUG
VnYuFHMFuBgZXr37yHB6frD1mmVzjqHbCxBApJRYd989vnRDSFRagxVY2KE7GBTTyEkfFOuw/QxM
0Lk1ZmhJxsQEmnAEBiJUzz/QfA+QAZoLBPFBMQ5SCp4P+veHYd/ayQyeThYMf5mYwY2mA3v3MTjY
2TOsP/yYQVDWhEFc0pyBT0SRgZmVA6wXZIacMCODtjwzMACAfY5ffAy2SvOOamqqg1IBysIkgAAi
JQWAAstj54n7m+VlpRkYgWkWFDl//6PGPCz1w1begqZsQetLQROczEAT/v+DrEVlBq3EBQYEKIBA
+kFiIDlQVmAH5oPfQPY3YPE/d/kOhsnNmQx1dXVg80FtClC12j5nP4OIgjmDsLwZg7aaNIOGFNCQ
318Yvnz9zPDtyycG1l8vv+/duvzaxg3rQas+QbUAaHpwKzAAUMoCgAAiJQWAZl1u/Pr8+g8zgySL
IBczMK8ygh0LCvHfwJAANVJAc9pfvjFA5rGheZyXG6IOtCKNm50RkufBSZwRHDi//oECCVHPP3r3
n+HOiz8MB84+Z1hbG85QX18H7iGCWqCgwY/mrml/OX99eHp40XzwXOcGYOucAbJi9DFopQJ0dgg0
PQVqlf3CN2gKEECkVtrPw/0ds05cuDdLUkiUgYMFMl0MSqqgCdsvPyHzp8CaiuEbkA2a0P/5F5Sk
/4HV/IUmedA8J0iM4T+wifz7BzDGvjB8+/aJ4dzNTwzs/94zPDm/+sW61YtBnvsI7G+EgjwOnnzT
198DigRo6w7UvH1M6eQIQACRGgBfv337eu78rZcMz77xAz3EBE7qoOQNbqBAS3w2pn/A0vwPA/P/
XwzMwGT5++snhi/AfsGfH58ZDhw6yrB+x3Fgl5uPgZVTgIGVS5iB+/3Gu5cu3JwH9RhoNQson7J2
dnbeBdXzISEhi4HtjtfQadhz0Jj+RslwOAwABBA5zbYH146t26wYmuoL9D445j59+szw68fn/6eO
7Hy6ceMG4R9cepwsQM+BVlqz80owsHELAz0rCB5nYGb1YNDx8WDY32cFmmXdDp2yfwdJF4iZ2ebm
5sfAzpNQbW1tFTAQQJ6/AO3QgJL2P2rNaQIEECOZekBp0hwaU8+hee49NM8JGBrId/E6rY9Cnbo9
9mtlX04xkAlarXWbAfsKcGjjkq0F2NfwgY75g8y/Ah37/4U0j0GVAAAIIFpN/4A6UmG+gS6pm9fv
6YT2xZ/CJvMJuIcX2nKTgMb2I2gKQVljQa0AAAgg+s9/EZctWaBu+w1uBWHZQkKtAAAIoAHfPzDQ
ACCAqLZ/gZYA2PsUAbYDkoGNoOi/f/+elJWVTaNGDQACAAHEMtg8C+xtGgMLQdCiiRggzQcaPUKe
hn/06JEukCqE9lIpBgABNGABAJqvu3v3biDQcwlAT/rCutggjG+YDDTSxABZ8U6VAAAIILoEwMeP
H/nExMSSgZ6LA8asAciToAFUEE3qcBmoSbx48eIcYACWUSMbAAQQ1QOAiYlJFxijoJUksUAsDPIk
aGaIWitJQJ0hU1PTPCAT1Dv6Tql5AAHEQkkSvnPnjjfQk6AkHAwaFoPlV1JGeokFt27dAk+ogNbw
8/Lygoaj+KkRAAABxEJkEmYXFRVNAXouHpgHTSlJwqQA0CYl0KoRkB2ghROwgxdAg7DA7rEDkLmC
UjsAAgjbIil1oCfBSRjoQUlYrJKyu4oSAJo8aWxsZGhpaQHzQVsI0GemQJMs58+ffwjMCqqUrhcE
CCAWpCTNAUxi30GW0XLlFz6wY8cOhm3btjFMnjwZfMzSvHnzcFWVoBkqeSATNKH7lhI7AQII2aeg
c2zuiYuLKw1EAGzZsoVh1apV4CU1oO0xoAlW7GOHkAVToDkIYKTJUhoAAAGE7NPfu3fvPmphYaEE
Svb0SOqgPX+g6TRQeQKaaAWtCwJNnoLmH5ABbP0QSA+IBgFQluzs7GwGBkIgrsXoxACAAEJeJwjy
tT/QASvRHUBNcOLECXCBBtqLtGfPHlBehssdP34cvBcVOa8jzzCDAgB2lgGoOgTNUqurq/MD/fCJ
XPcABBByCgD1tV+AJjexLW6iFID6HKBtp9XV1eApcdBiSBCGrRwDeRQ22QKKcdDsE8gtoKl0EA3b
5gqbbAWxoatXBKHdZrIAQAAxIXUvQa2qt6CQhiUzagHQMlfQFDtkp9l/8PrA9PR0lGVzMM+D7AZN
qYNmm0H79EAYNgcJagaDWoKgQACpBwUAtFVIMLaAhWrUokWLDgL9aY4sDhBA6BN6H65evXoLFPrU
AqB1AKB1AiCPg2IcW6EGS+ogj4PUgiY+QB4H0aDkD/KwsLAwGIM8DZtuBwUItFWId+93dHS0eEBA
wJKmpiY7QUHBE8AI2QvN9kwAAYRe3H8BFoR73N3d1aCdDoqAoqIieAceNgAr1JDzOCibwM4mAk19
gWIZ5GnQuiHQ8hlQ4Yw8CQvKpoRahaBNUubm5mdiY2MZQakIlJ02bNjgAKxiQWXeL4AAQk8B3+fO
nbsXtsiBEgDyFCipowOQI0ByoJjetGkTfAuqm5sbOGa/gIfIv4E9C5qMBRXIoKwCksM2Aw0KsNLS
UmtczfWqqqrslJQUGVD75syZM+B5BWCqew1tQzABBBC2ITJr0M5wYtbmkQpAawFBB/2ATjg0NDSE
rxlcunTpf2ANAN4MDtoUfvr0afDiSdCCSdAebXxuAZkJVP8AVDOiHebH6Ojo+AHoafiud9CJksAs
AFooCVrmAtrfww4QQOhZAFwQghYoApMoIzUbRKDkfvToUXBDB9S8BVV/oGwG2g8Mil3kTRWwKXhY
aY+vRsLWKgTFPDD7cTo5OfGDVp/DaiGQWba2tn+AKQ+U/ME9NoAAwubDj2fPnr2sqqqqR60AAOX3
9vZ2sOdA+5FB63VBHZu9e/eCCzjYNhnYchpYNUxsVQzKBlpaWjJIrUIWYEx/Bq1MBwUkyP5jx46B
p9aAnmeBDuGDlsT/BQggJiztAuH1R1/pggoiaoH6+npwPgYGLNjzoCoRdAoYKO+DCjdQSgB5HpRK
QDUBqAyANXyIGbQFLcbq6ekBtQqZQbEvIiIiYGVlxQQKmMvA7NDX1wcuT0CbMYABAjpXCzR/CFpY
/RcggFiQ8j5/aknt6Rt//FTu3z8CdgRoZRilDSLQSnBQSQ7y2Pr168GrQUHJH5a6QJ4EeRbmaVBs
geRAKQPkMWJSISiWgS1CXwbI0To/gO0GXmDT+j+wgGW8AWxunwQWfpcvXwY3xIDgALTh9BPU9gEI
IJDp7EH+phFvlGcuuAk6ahQ0t8clzECNmgA2fg/q2Hh5eYH5oPodFKiw2AbVBqDVZqDSH9bYAaUK
UN6GLa0jNhtAW4VvJ06cuFNbWxs01cYMOnOEA5j3QRsugI2obUB73kHHE8GNHYAAAmUBaZDnUfIB
Bx94Cz65LULQ5ghQzIMKPNCZlTDPg8RBHgJVg6DWHSgwQNUSqK0AW2oHinVQYweUAkhZfAVqIQJb
ernAVMsbHh7OCyxAmUELpa8A+x3A5P8PtBwf6HnQ/CJoiu0jdMKFASCAQKb/lf4w4S5KALDzMGw/
fBW+EozYer+hoQG8Ehy0aBpU74I6PKBDtkAAtBECtDQW1swFDW+B2gmgDg2oMQTyAKjBA8qroBQA
a+2RMlYITPJ5EydOOAEMBNAJUwwrli1nEOTn//fu3bs/wOy1kgFywM8TBshyWfBkLEAAgQLg+fJ5
i3JR2sesHAz7zr5kILYgBK0g3b59O7hkB7YkwV1bkMeBTU+4GlAfH2QeqMsLqglAGLScFhTDoGUv
MjIy4PIBFPsUDLWxOTu78gMDjvEysNq7dOECg6aGxl9gO+EfMOBBjQNQRIMaQfCYBQggFmgv8Pyz
DS6zpAL2pIEDgJmd4c03SKsMVHrjcgwoX4GWvIPorq4usBjIE5mZmaATVcHJGORh0EgPKDZh/X1Q
OwBkNii/g2Ic5HlQjQDikzugCuq/fPzwkUFdQ1UAHPvAvC8iJPQPWPiBlsnPYoCsOwC1yz8hrxkE
CCBYEfv6zr13C1UY36d9+w8s+ZmYGVi5BOEnJWELAFCMgo75ADYzwckX1MgBVj1YOzqgAAGtJwZ1
bkBJHtTFBeVvUMyDltCDaEo8D1sqr6yizMDMxMpw7vIlcOzb29r8mT17zl9g9gR5/h567IMAQADB
ShhQgXBtR69zFkyClYOf4cWrd+DSGh2A8jiwcwH2PGgrG8hDyJ6HrRwHeRoU6yBPg2IelFpAYqAA
BVWxoHY+yPOkLppG9Tyk/Ll29TqDsAjkAKmVK1YyiAMLvqtXroEKvwnQvA9aZ4CxZhgggJCLWFDJ
eEjm/x5w/cfMxg0sCG+ACyhkADpHy8HBgcHPzw8c8qBJD2SPg1INqFoDeRZ24hBoTB9U2oOGv0Dm
gTwMSvIgz4NKfWI9Dzsi5z/SyrT///8xXL/1kMHU3BQY+8wMJ4CNravAOl9ZSfnP8RPHvgMjELSc
5inUfxixCRBALGj9gPvL+ssS7YrOrQKtudt//jVDMbCBAkriIABqURUXF4M9BurnIydB2AgOyPOg
wg1UrYH4oNhB3vEJ8jyoXAF5HlR342vo4GsEgpfZAhPzu4/ArvOHVwyCupA5g1WrVgIbRSpANz74
//DhoxkMkPVEoKSPdU0RQACh2w5qH58SfFh56p1cq9kPBl5wCw12YhrI8+hNU1CsgzwJ2zMASvKg
LAEbVIHtG4DV56DqChT7sH1BsPKFlGUKoMWQn779B680u3HrDoO5oQHYnIPA9v6N6zcYXBwdGRYt
XPgVmA3vI8U+1kYNQABhC/5nG9furLIrat8DWtgEC4CAgACsngfJg2IctG8AFPuwsT1QXQ7yOKhw
Q97pCRvXA22YAJ2LRIrHQWEFOlEEVCyBzlB59/E7gxDXX1grkGHdmjUMOsB+xof3HxiuXr26HFrn
g2L/O66JVIAAwnqUDRBfvrnYsg/UInzw+BU4NkE9N3TPg5I4bPcXyPOwOh20FQa0cww0IgTZECUN
LPCkwBh0JhPoiBtS6nrwThGgq95+hhwm9OYr6Iyfvwyvnt6GT5ftPngAWN7cAtqpwHDrzi2GiKhY
FwbIAspPuGIfBAACCFc78+3L1z9XiLC//rfj6C2MghCUl0GFHSjmQUkeVOKDyglQlQYa8QUdmwTy
KD+/ADimQakAlPRh/X70EyLwl3yQWActp38P9DhoPwFI56+fPxhkRDmA9nKDlW1Yt57B2MgE2MZ4
wSAkLMVgaGyuDh0m+4FvGh0ggHAFACjEbm6bmph18OI7BuTd5LB9QqB8Dsr3oMAQEBAEexoUw4KC
QuCkT+kmCvDxLX8g55KB8vubL5DVprDU9+zBTQZFYGCDwLbdu8C1jaqyCrBtcoNBQU6KQUddEWYM
3g4NQADhcyGov3xY7P+5j7ByAGL5P/BpX9+//wB6kBnsYVC7H1SwgVIBufv+0D3/Hhjm7z//Y3gH
Su7Qw7pALgDvRfj7k4HpzzuGNevXMazZuJFhy6bNDJampuC+B6htISElx8AvJscwceLkIEJ2AQQQ
E/7Ex3Bvz+bV9aA9Qoj6F3LSGMijoJIc1JSFleiUbpuB7QoDndX0DohBB4jBAgTkcdDaZEHO/wwf
XtwB2ivOcA/Yuzx//hywN/kQmPUUge2N2wzSMrIMmmoKDGqKUgzWdk7VDJDzgHACgAAiNNoA6g2d
BvbZ/wGTHRMs78ImJUB8ap0jAj4DEJTXf/4H7xBjZEDsPwB5nIcTkqq+ASv/r5/fMVy78YiBA1i2
3Lt7l0FPW5fhDpCWkBRnkJFVYmDlFmf4+IMDWKfzgsb2QX2Dl7jsBQggYqLs/smTJ27Beoaw4/xA
+RxUqFHqefAOMWAZ+/LTf4ZXwFj/CvU8eA8B0OMivEwM3KCTvEBVKPM/hif3L4PPtr4PbIx9/gRs
agNbl5Cjyd8x8AnLMnAKyDL8ZeEHNvmYGPh4eBk8fYK08dkPEEDEBMCn/Pz86aBSHzYZARutwZXk
GdFoXB4HD0EDC7kXH4DJHZjX/0G334D2FIE8DtpDBB7t4WIEn5cGKndAVfI9YJJnBAbC08dPGJSA
SR80qvSHkZNBXFoR2BsVB3qcA1hjABsBn9kZotPK5iGfIIcOAAKImOgD+fwmrCBkgm57+Qvd3QGq
n3/9hZQN4H4T1GNMDBB5kEdBu0ZA2yQgZ7RDxL8CExSogANtkGCEbuIHJSbQ9jiYGlDMgzZn/QTW
/Rxs/xju3boMNucBMPa/f//G8ArYyVIwNWN4+OQlg6qaJugweYb3f/gYPr1hAqaW/wxvvzAzHLsn
CBoyB7XlsZ7hCxBAxAQAKPW9ffv+CwMb31+G33+ZgB7+D94OA9shBk4I/xHbZUD7BpihGynAaqDi
0L0S4MBhYERsjgKZwcsJ2jEG2VnCycYAPikRZAc7KyPDb2DA3n/2DVzt3n94H7xd7svnTwyyMjIM
n4DVMTsnL8NvLjmGrwzAzhUjO8P5+8DAevGPQYyfkeHHf3A/RhRXAAAEELEZ+M2TVx++cQn/5mJi
YQNvZwPV0d9/gUptSEkN2hYHa9b+Q/IYOCCQdoGBNleAT2UESjAz/gemCkbwJguQmSAZkOf/ADWA
jg/8/x+y2eoHMIk9un0B3Oh5/voVw3dganz98jV4y9yFG48ZZJR1GfiE5BhOPeIBFn7/wZuyQJEC
akCxsnMzVE7YMQWYDTyxbZ4ECCBiA+Dz0SOHD//h1XTn5mFBKaFh9SUjUqZnxkHDCjdwfQ4MOFCb
G+Tx/9CtNKAN0UyMsJ0nEFNBSfnPr+8MrAy/GK5cv8vw9dtX8F0+wP4+OEX8ZRFkePhNjuHtMyEG
Lj52BuSeNShSmJhZGR59l3GDDpljrC4FCCBiK+5v3S2VS379/A452hLN88g0uTUBAyx1MEK23cBM
/fkb2Od4fpHByMiYQUpWhuHLx88Mn4D9DkkJKYaDl94xvPkry8DGK8PAzsUL7lyhjx0oSTAzaCmA
F1IIYLMbIICITQGgOvDZD2Do//uHKAj/w/sGiC2zIDbIIyAOEzCJs4L2D4JikhGRD0AeBJcTwFj+
9x+0fxBC/2eA7CeEtDoh+wh/AmP/9+dnDEdPfAGP+LwGdr6kxCWA3fPPDP/YgP0NUXkGDl4RBmYW
drCHQQWyALD2V5dhYlARhxROHz9yMJRV1oFOjcG4wAgggIgNAJCL3v0COgYUAP8ZIHe2gU5VZQWm
bw5WUOEF3SzJAKEhSZ0RvgEStDHyP9QkRkbYRktGaEqCjQkwQrMSRBzY+mIwt5QDjzBPmTKFYc++
fcBW3wMGG0trhgVbrjAIyZkw8AjJMDCy8ALtYGJQFmNk0JAB1h5sv4F9lW8Mz55+Ae8h/A10t6GJ
RRKwHFiKvssMIIBIacW85f7/7r2UwB9BLtDmRQZEgYdcXcCqSPDuT1BMQ/cQM0PTOQsrKFVAPAra
LAkrI0ClP6g8ZWOGlAkgvadvfQMPxIDmC0BrB0FrCDrbOhhWrFjJwM4rycAhoMDAySvAYKr8l0GY
8w2wlfiF4cndjwys/78xPL5x7OmCOdMuALvqL6HjgfuxNU0AAoiUAPhyeM/6rRra+jHAJiB0Hz8D
tIUGSQnswBTBww6p70H7i1mQCiRQbQHaHg9K6qCzekF7C0E0qBAE6f3C8B+8hZaXiwl8aPCdFz8Z
7jz4AG5xgqa4QR0t0PgC6Hqlg1d/MEgr8TIYyf1iEBG4B+z1v/uxevuq6+vWrgbt/ngHHQR5Bh0Q
gW2kfMuAtOkKBgACiJRuG3gZ3ZHzj1cqyUuBW2mgqgrkSVAqAHViQB4CbZz8Br0h5e8/SMBwcUCy
BUg9JysjvO0AKi/AbYr/kOYw6BDblx//MTz98B9YwH0BtvNvMTzfUwjOAqBRaNC9evWds4F5/O+X
OzcvX3v58uVd6JDXS6hnn0E9C5v/+0FoDSFAAJGSAsDL6MR5fgA9D7l35jWw7Q5L6qCmKg/QgxIC
TPCNlKBTtsG7SH9B1IPO/PgBPRIYVEWBYh+8dfYvpCT9++83w5X7Xxku3vkMLPheMDy/vpPBztaW
wcDAADys3tPT8/Lq6ROg1SCgbXTHGSC7SGFzfQS3yWIDAAFESgCAC8L7z78x8IkAW1kCLPDqCpS0
wUNVn0FJ+h+4kQQ+9/gXxHOgghMUUKB2DbhQBLXy/oMkfjH8+Qls4X36zPD+/QeGs7c+Mwj/Pv/r
4vq512/evHFfVFTU0ts4Txw09L5ixYrXJ06cOMgA2T0K2gYP2gz9gdJNEwABRGpX7u339w8f//uj
Ivv8HSPDp++QZP/tNyQ2QdkA3A+AlvL/oS3Bf/+BFSEwdln+/2D49xtYlX7/zPDzG7Aa+/WJYee+
wwxb95xm4AU2V+7dvAHaGwyawQUdjfddR0fHH3Sjwfnz5790dnZuZoDsMgXtGb4JneKieMcIQACR
GgDfZsyas/KfiEUJOw8rOPkyQmMV3BZghJzYwMr0D9xyY/jzneHXj08MX4F1NqiEfvboHsPaLfsZ
7j5+ywDeWsspyMDHy/b/9c1ds4Gl1mGg+WegJfYPAQEB5cbGRsZp06b9XwEq9iGevgid4PxI6C4Z
YgFAAJE6dgXaNOC9aNeD9YIiUuDSn53lHwMHy18Gpr+/QPuHgc1U6F5iYCwfPX6cYe3WowxMrDzg
uUZWLiFgo0WCgZVbBDz19mZ/4pb7D94vgObnl0jjd+zd3d1P//79K1xVVdX379+/N9CkfxVawv+i
1sZJgAAiNQWAmu+v+FiAeZX1HTAZfwG3yF4Ae2QfXj/4smTBrKe33/Gpg3eFg2KYR4xBTCcQHNMs
QA8zs3ExMLNyMsh8nf96+ezp5VCP30ebsGRUUFAIAhZ8wgsWLHgD9Pwz6MzuTWgJ/4uBigAggMgZ
znnH9Ovjr80r1jyfMqnv3OfPn99CHQaKwe9WNiZ5v1VTtUCHgIM8zMTMBll3AxrYYHr+f2uPPWi9
LCi5X4OO2aPnYzbQjpXU1NR/Dx48aIZmidvQ+pyqngcBgAAiZ/gWtA7HEUrD5t3eQj0DSiGWDkWn
d8NOpYOB55vc1t6+82YBNCm/wjFcDXKPILD0f/r69esMaODcgKaAj8iBRa0sABBA5G6f54Y65gcW
j4iJi7KXq8ceB19kKP15Nr7kjg5AoQZa3qLHANmBDkpZ16EzPDTZPQ4QQORkgf8M+Hdtvnn5+udy
B6Yz2St70uoIJHdsgcsEbdR8g3r8HaHJDUoAQADRas8baPBBCuqRVyR4ABQhoJlOPqgeWAsPYySH
WikAIIBotTsKFHt3yND3F+rhn1D2b2yepyYACKAhcb/AUAdycnKijx49ej0Y3QYQQCyj0UM6AK3H
vnbtmjILC4sRKyurAZDWB2I9ZmZmGdicEQyDJtJfvXr1DKgHdO7MF2pdjEEtABBAoyUAUqSeO3dO
gIeHxwgYmYbAyDMAYm1QBKNHKjImtBAAlABAa+MuXLiw2MfHB3SI0FtcRzsOBAAIIJaRELG3bt0C
5VBDJiYmUMTqAyNVF0gLIkck7Exv0GwvNc4GhfedWVnBK7iA7ohNTExcNH/+/OMMuE+QojsACKAh
WQKAIvXSpUuyXFxcoAgF51ZQEQzEirANV6A1C8gRTOnRvpQA0AJR0EIy0GHv9vb2oEtAX1Cy2Zua
ACCABlUCePHiBbesrKwhMKJAOdYYGHF60IhlJbcIHiwAtJwSVBVs2rSpMD8/fwF0RG/AT/ACCCAW
euRWYMrXBOZAI2h9qg+NVDH03ApaV4pv0c1gBaDVkqB7aEFHzYNORgAtJAJdLADaJQUazIdt8QZV
BQ4ODqA1a6C77b8TGBWhCwAIILJKAFCkXr16VYyNjQ25waQHjGB1WKSiF8MDWQRTC4Dm60ERDTrk
ZNasWeBiHQRAuz7KysoYsrKy8N5FAlpODyoFzp8/v9TPzw90ENqbgS4FAAKIBUcEMwEdZgX0TBe0
e8MNikBYhMIaTEOpCCYXgJbdgnbAga4HAR3tA9rjCA0j8C455CtFCAHYwlJtbe1oYINwwWBoEAIE
ELYLpkDlL9CdfPLHjh07JSEhwYZvx9xwBKAtD6CDbUA5HHTQzbRp08DioP0dkyZNYkhOTh42DUKA
AMJW2YKPcv/06RPfoUOHzoACA3mR/HAFoJ0HoLr88OHD4MifPXs2+EIgUOSD1qWAdiGAGnLERD7s
jCvk01FgJ6SAxEElgbS0tFlvb28YKLMRc/YNrQBAAGFUAdDbFkFj2R/WrFmzzc7OzgpU5JO6g3mw
AVAEgLamwzYtgiIHtp0FtMIatOcXtBES+bQX0EKkAwcOoOwLxBXZyPcEwjCIj5xxYGMMoHAEhSew
BADdvQVa7AAK7x8DES4AAYS1EQhdUg46zVl33bp1U42MjBRBy9PIvQFqIABoExeo/gZFOqjeBh2b
AzqlDrSkFgZg13rBLnSD7YkE7X4D7XoH3XyJL8Jhm0BBy/ZBCQzGhsnDIh3WIIadxQhiw+5ZAzYq
lwUEBBQMVIMQIICwNgJBdRIwEYDmPF/vBQIgO4Uep2ZSCkCbVUFHkoAiG3RoBbCnAt6Z6+PjwxAT
EwNeYAra0kRO6x+2+R1WpIPCA4ZBRTss4kEAFOGgiIZFOPJBnKDIh+02Apmpo6MTBWwQzqd2g3Dt
2rWcoqKi7MCq5hOwe41z6BkggHB2A6EnCkoDsdHRo0cXKCgocIP2gVJ68ygtAOhIBlCdDToXBrRV
s6CgAHwIJ7nXQ8KKbVgRDsvZoMgG9fFBbQFQuwjEhm0DRz7uCdTnh20PhR0JBetBwbrDsKNjqN0g
BCb2TBMTkwZgqSICtBvUXf8PLOm+ysvL7wOGU0p8fPwbpJ7eP4AAwjcQBFqAA1rF8BLYGzgOTE0u
oAClxk5IagFQfzw8PJwhKCgIfOwsMNWTnKtx1eEwNqx4hx1uBDvgCLYdHnacJag9AcPIEY9vDASU
KEDVDzCCzCZOnBgCGiEERgzJI4TQRiSzoaHhNFNT04S0tDRW0FlFoARpbm7OePnyZV5glegPbNR7
Aruuuc+fP58DLf1/AQQQzgSA1Bh8O2/evA3u7u4uIM9TY28gpQCU86ZPnw66bIXo3glyRMOKcljO
BuVoUOMPVH2ADlkDHfEFakMA++vgfj6ozw/SB0oIsLOUQIEL6haCIhA0wgeikTeDEzvwRekIIbTb
zqaurj4TiKOAPRcW0PEloMQHWk8Nqg5B7gFWMaBRSmZgKQ6KPNCarp+ghAMQQIRcCFukpbts2bJ+
S0tLLVBjEHa501AYuUPvjoGOKwIN6IAwMEdgRAao8RcREQGOQFgVgNyaB+Vo2CEYoEiHnQkBuxSX
nBFP2AghMLIWBAYGgq5DfUtMKVBYWOgKtHtzZGQkE7AtwSIpKckIa+OAGr6ghAyK/BkzZoCOdfoH
jLsZwEQB2iUEWqYFag1/AwggQlkZtkTpNbD+2KOvr68FKv4Ge28AuZUOammDLgIGHfQDO10I1LVD
BqCtF6BhXNg5+MjTwrD6GnY7Kqw1D8LI9TslQ92wEUI9Pb0EYNtlKTC3HoN2DXEW90B1icASaFZU
VBT4wCLkk59BpRdoAAvU4wF1e4Hs/8CcvwMY+aCl5YLQOAUfJQEQQMRuFH6/aNGi/cAGRAzQoUKw
Ix8Ha44H5XSge8FHRoIOMwDlVFBggA43gwFQ9w90tT3oiEnk1jm2xho6Rk4c1JjjAOmHHZYILIFa
gQkgGBjRv9AbhNDinhWY42uA3dUaUMIFlsrgHWQwAGpUgo7wApUooAEs2CAUMOH/grbrQBjUgAGZ
/Q8ggIhJAH+hgxTf9+7ddUdGRsYMdizOYCoFQJEPyu2gIzJBI3pKSkoMLi4u4HvPQUd2woCWlha4
iwg63AU54tFzPKzIhyUqbA1HWDVBjURAqEEIOhoUSLED3T8Z2F5JAs2cnjt/Dlx9gA6rAw1agfwD
mo0ERT5oTxVo/gJ0zzuwRAB5AHTkD2j1PmiZ8WdonP4FCCAWPEPEoP4eb3SUY9J3ibjGx+/52bdc
uckQ/AXSBQLVewPdGEQexgWd3Adq9IC2E4HugwYV+6BzHGEAJgY6zgi5yIZFNnp7AUbDqhPIMQmI
kTzkrh1swIfSRICrQQiLfNCwMTBidUE7Bt3c3cEnBcDAnIXzGXZs28HwH+hufz8/8FZK0IWcoHMj
GSB3z7yGRv5HaPUCKmH+AQQQC1qDD3QcOV96VlTPE664yM//xBgfg5M+sJ/L/h6YJIQYdh+7wRDq
xQ926GCYDQSdXgg6px6UIzw9PcFFPbDHApcHRdTmzZvBp5gin0qMbSQPNl4P4sOuhocV0bC6H1T1
wc7GofbQOMhMUCkgJCQksnr16srQ0NBKYOSDimvQriye6OjoBGAjUR7ov19AdfABmWWrVzKcPH6S
4Sewd8QDrEZAp7aCzssFRj6oNzEJ2p0HRfwXaKICVQPgYg0ggFighvNlFOVvvc0YZv77Pyd4LwbK
anRGoGdZOMA7nvaeeczg4/gd3BWDtXwHCoBOZATduGJrawsu0svLyxnOnTsHlwctygDleuSiHHly
BuQHGIaN6sFyP6zBB/Ij7MZ45HO/kBt/1FzrAGsQAtsmKcB23kpgewB0KSMjsHuXAaz704ENcR7U
yF/NsH/vfnDjVglYDYAOcAMd0yssLPwNKDaXAbK95hU093+CFf2wqgUggECuBu3ikOHnZfA0Sz00
4ScDD/Y69t9fhl9f3zB8fX2LoTpWjcHKRAvc+KB1WwCUw0ErbUBHboP666ChXdAxvLBxfFBktbW1
YbTsZ86cyZCamgofwkUfyYNhUHUGy/WwuhgUwbBGGQzDunrIgzu0WrkEGyEERtIpR0fH6IKCgqT4
uPhYdQ01EU5OLvilEUtWrmQ4CAybN69egaq+v3///Pm7b98+UAJ4B9S/mgGycRx0bCjo0FjQLjvY
2el/YAkAIIBge5FAFzEoA7FVQMma/nf/lLD67M/Pzwzf3z9k0JP4xFCR6gzueoBSK7USACiiQBfK
gCIblENBkQ27OQPWvQEdQwqKbNDp+/hGCIODg+E3dIAiHnYvC2jmDzThA+LDjiyHHYIFq4NhGDni
kXM7PQDIraA2zbp168+7u7tJamioCXBxcXPAjnpYtGI5OPLfv3nLoK+n9xcEDh8+/P/OnTvPnjx5
soEBcnrAIyh+AY3878iRDwIAAcQCLexBRwmBtiD+2tATkhhd2Dv9MaMjF0YdxcIO3uh66tZzhvcf
P4NP6oKd9E0uAKV0UGSCIgY0IwdrdIFGrkCRTSoA3UYGGhqG3U4CimyQ2aC2AYgGBSzsOFdQZMKG
cUERDvIPKMFRY3CH0owAsvPmzVsMAUGBhlISEr+Bkc8Ki/yFy5YwHNh/kOHDu7cMBnr6f4DhBY58
YO/gLjDyQXUeaFMx7MzcV9D4/Y5c9MMAQAAxorFBZ8yBLunSi80unfaQPVIErSJg+P39A8O3t/cZ
fI2ZGeKDbMClACgRkBJAoFwJGnYF5UJQZIOOogZFHHK/GHTlA2gWz8PDA9yyB/XniRnbB0UsKIJB
RT0o0kELWkAYFPmg4h5U1IPMh43mgSIcNHoGinzki4oGIuKR7xXaC8zdoKFoSdDIKycHA/QQHYZ5
wAbeoQP7GT4Au7z6unp/gHr+AqtIUORffvr0KSzynzIgbr3+jF7vIwOAAMLmO1B5CxpW0guNDmx9
KV6Lcubevz/AxtLHpwxsP+4xzKzxArcDQDmXmC4hqH8KGmsHRcSaNWsY5syZAxYH5T7QGeOgG6ZA
/XdiBnuQu23I3TdY5INyPigBgDAo14NKA5A62A0VsIgHYViuJ3UcnxaR/+3bd4YdO7YzGBgaAds4
kgzcnJDMBTqAYu7ChQwHgdXfZ2CC1tXR+QN0Jyjn/wOG6Vlg428zNOKfMiC2FYNa/T/xHSgBEEDY
Yu0H1JDfq5euL7K1vZXNaLrYD55imIG5g52X4dNnbobj5+8wuNnxEuwSglqooBwPKupB9yyAgLq6
OngaF7nLhmtYFxY4sEiGdduQaeSLqWAte9iULayBB8rZoFwOyu2g9gUo8kFuh1VjtO7W4pq3giRm
0FHM34Fd1k0MVpaWDBKgkpWDE9xCA3Xk5wJ7O4cPHQAdl/bf0FD/79cv3/+ePHXiH7CRfOzli5c7
oXH2BGmw5wu0r493azZAALHgmQoGpaLfhw9f7VN56vJcLnBb+p//bOAz2ZhZucAHX+w5+YjBxkQd
5xWroGIX1E0DXWUCatiBWu2gC7RA3TNiFl8gT8fC6nQYBkUsSAw5ASAP4sDEQGbBJnBgK39gkQ/i
w7p4lDbuSF0yCTtg8Nfv/wxff/xl+PDpK8Pxg9sYbGxswYcBgop9kPyP/38ZFsybD2z4HmT4A/Sz
vr7e35/ff4HOz/h/7+69Y69fvd6JVN/DGnuwyCe4BxEggPCV23+gdciVO/feLbjTa/HAu2Rr2+d/
kozM4MYgH8OVR88ZHj97Db/2BXmxyNatW8F1OAjExcWBZ97wzR8gT+Ag52RYLobNw8O6bLAEAksw
yO0H5BE62KgdyH2g3I5c38OmtglFPrXWwzJCT46DHbf5+88/8JF4X4F+O3pgK4M1MOeLiokwwHp6
34D+nD8fmPMPHgKfKWhhYQlqzzCev3D+77lz53a+efPmKDDMnqDl/K/ERj4IAAQQMbOBoBQFGhv6
sbXH+1VYybwZLxj0WZnZeRjYuIUYth+5xaAoJwmOGNhiEdDRdqALkUGrdEDXbBAzXQuLdNiiC1gf
Hbb4AjYsCzu2F3ZgM6ENKOgDOrArOZHre1oteIY5A2T+j98Q/A96NvDPv/+A/vvD8PHLV4ZH148y
uLm6Aksnfngm+gRM9AsXLgBHPsggcxMTcHg9e/6c6ezZsweA7alj0JwPi3xYzv9Nyu5jgAAi9tRc
0AgS6MSLX6t6khKj8xqmPWRx42PhEGA4eOEWQ0IApM6FzQ+A7kjEt1ADFvGw4h15cAaW40HisEkY
WA6GDcXCpmOREwGs/sbMzYjZO8yJH9pEPiP0pEDQ6X/gIxL/wU4U/A8+Dfj3b9BheX8YfoCOPr53
msHezoaBm4cbHvnvgI3WRYsWMhw5dJiBCajRzNKMgYWZheHalcsM33/8YRQRFfsKTABvGBAnBcJy
/m9St54DBBAjiWpB3UTQ2S96EQkx3Q/Y45S+vr3LEO8kwBDkYQ7uEYASAa6GFPJwLKyIB0U67BJN
kBhs/B2Wa2Fr7GBj8LBIhyysZMKYxcM35YpMUz3SGSCRDiraYQcBgxMBMMJB9Tz85GRw++YPwzeg
v5/dPgFs8JmDqyYODkj1+PrjB4bFixYzHDl8mIGTg43B3sYe3Ja6desOw2+gefwCggw83FzfWptq
QRsULkO7e2SdlAgCAAFE6kD+b6hln65cuHRGT/qpxncea6lXL54xOJrKwxdCYgtkWB8dlLNBkQ0b
lQPRoIQAu0QQ1B0D1dNCQqA7dEWQWut8SMuuQPdssqHM3eObv0fG1MzlsMOTwcdhgs4J/QmJfNDx
9yD8/Tfk7G+YeuTI//DkAoOdnS3QT6C1FZCc//ztG4ZFCxcxHAW2lziACd3F0QnYTvjDcOPmbWAY
/WQQl5BkkJGRZZCRlmI1MTFh3rdv7y5oO+0XuUvKAQKI3BABDf2BBol0NdQls1g0SvwbknQZzI00
wddooDf2YPU8YnQOMQYPm09HXlGLXEcPto2lIGeAzjr9CT0zHcT+BT75Fpg7oPU7NqeCMwAw8n98
/cLw7M4J0A13DLygYXQWZgZxYWGG+0+egIewjx45wsAJTNzOzi4Mf//8Zrhw8SIw4/xlkJaWZJCT
lWOQkQVmNB5+0DUmf50dLE1AVTMw8r+Q6x+AAKIkVEHtB9DyImNWFobQjPLJSbnx7sBqQAKcU5Ej
DP2CeORVtbCiHrmIH5SRDj/iGMKGHIH8H3zOMy5Xwq5QAB2qyQwsPH///MZw/tR+BiUlZXBiOHnm
NMNnYPX3BZgoPn74wPD502fwnLwtsCsICi/QzCbo2HQxcSnw5JeCvAKDvLw0g7CQAMOf3+CdTmfs
7OxAYzSvyD09FCCAKA1hkP9A65GsgUV34PHjJ6JAq1NAfW1YNwx5QwX6PDusBQ9q5MH64oPhbABY
d+3PP8hBwKCGHOj6hp/QRhz0VHeMiIcc9s3IwAY6RRVYqrMxQY6C//3rN7DE+8pw8exhYOQJgi8I
uH7zOsMXYCkIvnkNiEG3IbABw0JPVw9s+K1bN8CXFcnISDPIy8kDc74cg5gE6IYmEQbQOZzfgI4C
jazu2Lwqpam+cjUwAXwix68AAURpaP+DTjZcBjbmDt27dw982xLyTciwljlshwzyxAtsxo3Y/jit
Ix3cev8LOt6ageEtsFB99ekf+BToN5//MXz4/g/coEPv3oEii42ZEXz3hygvE4MwDyP4PHEWYOSD
unygYvzPr68Ml88fAUaeADjSL127DOwh/GJ49+EdeE3DV2A7iBNY8oEi/y+wSnzy5DG4lBERl2YQ
EpNn4BKWZ2DmkWL4xSLM8PEPN8OPf6wMP/8D21qsPAy2Tt49oOoYupGHZAAQQNQI8b/QRHBtxYoV
20GtetgdpMh9ceTtUrB5dXoMvxIzGgfK6V++Q+4rewmMdNDB7W8+/wXfXQYq6hlhuR0pwvk4IXcb
ifBAIh90ODxIEYgGXfYkxM0ATAh/GP79/sJw6vgh8GAZqLdz4/ZNYCn4h+Hp86cMTx48YvgFDCte
8FpAefC8BehiiJfvvjFwC0oyCIorALE8A+hsZm5+YciFdMCeAeSKIdDN19wMn/7xCkyau6YWNKVC
zi5jgACiVsiDmrGgBWpmwGpgAbC+YgdtI8M1TYwS3/8xXfEfS0MKXQybGhSz/iNu80DhQ5WBDrMH
Fe+gbhuoLod11ZBzN0w9GyvkFi9WFkYUp4IOx2cHi0PYoIQEOigfVMT/Bub8Xz++MFw8f5aBm4sL
XNdfv3mTgRGoEDQ3Arr27BuwMcwPLAVBRTzILlDv4MXbb8CiXhKcIBTk5RkkJaUZePgEGX4zcTF8
/8PK8OUXpDriZmcEJs5/DN+/fmT48uHt31gvTV3Q4g9gVfCNlIgDCCBqreoEzR2A1pw9OXXq5Glh
YSEbXl4eBhZW0C5YRshFGv8gl+OAijbQlSiw2wL+/oXcRAKuLf8zgtWAAuM/9H4qBuigCuwseiZo
1wt2NRMT9Daif9A7msB3VcEqcQZIfQyrWVjAF/NArmT59RvSgkdOM7Dj30GRycHGBG28QYo4UAYH
JQA26A0p4ET0B2QeyC+QhAG+RAAo/wvYL/z44QvDpfPHwLkbVMzffvCAgR2Ye9++e8vwCHT7GTC3
CwG7t7LAbh24ewy6DhpY9ygBG3kikgoM3MKyDF9YJBmefONnYP/PCUyELODBpE/A7ubrj0D8CZT4
/jPcf8HO8P0LO3P5xP2LOvMd/YClwE9SGoQAAVg7gx6CYSiO/4sEkxEjNjvgS/gwvpOvIOLuzNXd
wVEiMTcO2AxLNMO0fR2uEocemiZNmn/z3vu/NP39M/bKByQdMbrT2WJYqdrMrFgiCuTeQLBUlu/u
mxQ6TiEk4oRSR+WmnsTXUUIn9B8/vsRn+kIkTC8yEovIbNLzE7tDYqrImol5hr2RFkponfdTpld6
UdT+6v//D/JK4nFojaGQT1DSeKv4Qc6AikUiTF6jC/beXNU3fhBguV7BKBrwjz48b43zKUTTbijw
Ib9xYSljbLYhypaLmtOG7bZg1R1kClWE3MDulBUpSdOg2AeyZIpaQ/Yf7jwCjw7gy0FvPOpPfikI
XwKImuu6f0CHJJ8+fXz/wR8mXsXfTDwMzMBQ/AfNdX//IW6bQekv/0esQWVEaoVjqMNeY0DrA9S6
AFFF/IcnOlAigJUW/xkQF7/Brv+B3W32FzpCxsyMsBtUt7Mywdo0kMTBBG0cgC6KAJU8v4Fds2/A
Bt2rB8DI5+ECXwVy/fYt8DD250+fQBc8M7wHJgJxUVFonf8JPMDz8M0vBmExaQZOIXmGL8wyDC9f
iTP8fsMPbO1zgOt6ZmgpxobWYgNFvpQgE8PTd5wMzL+B7QiTyBkMC3sMgaXAD/Q7knABgACidusL
tB9bxcTcxj+pdEqdsKgEsKUvAGzhM2EclI5SCqDX4wyUXUdG+8UbiITxF5q6/v35BayPPzNwfzkP
vujuNbBrd+XGVWDk84AHve7fuwe+8lBESBi8FgI0FvL563eG07eB+YZTioFdQI6BV1iOgUdAnIGD
W5CBhY0TGOks2EeVkNzBDE0UX779YPj77Q2DEtOJvtbyuDZQZiRmdBAggKi9swO8m/jMySNnU/+8
//zzBz8vByc3+GozYiP/PzHTskh9cNj9NOCSA6k9ALu2EXZzIUwvuJ6H5nKG/6hdQORr4KCFA+SW
M6g5DFA1sO4TI/RGwN+gCa2v7xj4v19lUFJWAq9aBk3u+P8PYti0eRP4mufHjx8ySAH78ZqaWuD7
L998/MFw5NoPBl4haQZeEXkGHiFZBi4+cWDDHphhQHdtMDJjRD6sBAUJg25aFONnAnY9GRjkREGT
WtwM/37+ZvjxxSQfqHQWNC6+E4owgACiRf8LdNWDenZhdam+fWSgELAU4OLmBde/yJEIrsuRingm
eEQwQu/Y/A9udIEaVsyMSA0+RsiVdCxMsMiFVAqM0DodcicXpEEJa9QxIl1kBBcDLXj4zwC92Q0S
o///wa61Q5q4+Q9xNxO0OgG1ARABB7rf7yfDlJ46hucPb4BXItvZ2QEjn5fh+YvnDAcOHWI4euwo
w7PHTxjkgInCxNgEvD7x8cuPDOcf/AdffccL7ONzC8owcPGLM7BzCTAwA3M+sKUCbNZArtAD9UD4
gd1KcX5GBlEg5mUHNUb/gy9j+gdeDgdZ/AIab/j1E9ie+PGNgf3Hw21x4V5JoLklQrODAAFEi71d
4FJgan/r6lk2gX6/fnxn5uHmAqZYFgZ2ZkhLmgXauobVoUxMiEiBRdR/2DJIRuyLMuANSgZGlJQM
0/sfaaQKXM//Q5QU/5mQruWGDdn+Q1IPbRWC3McCvdIT3EYA8llZGaFtDFDk/2J4/uwlw7wZ/eB6
HtSaBxX3sDGOH8Cu3/tXrxnMTM3AmzZA3b+bD14z3H7NgYh8YGufi1eMgY2THzwgJsjDxCAh8B+Y
s/8BI/sv+D61nz9+gRuKvz78ZHjx+yewxIFgJoY/DOwM3/68f/Xg04M7116fP3v6PrAXBrqUBrQ7
hgfaM8N7+BRAANEiAYC2I4GWIT///ebqVTEpPj0R3j9Az7GCh0n//8cs6sGlwX9E5CNyHFoxzAQd
V4eWAuAWMTP0qkKkRASyB3SRLKjUgVxmCb30khF+gxHYnj/QIogZGMvg3shfyAW2sCvPwJdc/4a0
vkFXG4ISL0ju3ee/DE/e/GR49e4Tw5YV88Dmgep10A4l0CAYqNsH2phqb2/P4O/vD96rD9qxu33/
GYY/PGoMXAKSwFwvxSAiIswgLcHBICX2i0GQ6y3QDX/AufjHO6DZb/8wfGT88ffTm8ef79+58vrC
udMvjh879hwaod+hGe0bdHb2CzSyQYtC3kIH5t4yoF20gw0ABBCthuBAqU9JRlbOccbCLRNExMQZ
eICNQSZQbP1H3C0NijjYXZOgVjUogEFKQGxYVwdl3Pk/JIJAd9SBIu8ftA/+9z9kfAHUJYPdZghK
JGB5aGMAfMcltBvIAG0rgIZrQXdeguz/D78Z9T+YD6vz/0LNff3pP8ODN//ALe+Pn38y3Hn6heHW
/dcMW3pcGfh52MF7EUBL5EEJABT5IDbotLGHwD4/GxsHQ3nbPAYuYNUgJirCICslBox0gX/MwM7b
8yf33ty4dvn5yRMnnv38+fM7lsj9zIDY2/eZAXGhEEztD+g0PQz/IWVqGCAAbWewgjAMg+EyC3pS
BnrydXw194bzsOMUEaZDRTdmm9YkbezAq556Lfz52yYh/f413ksbaw/7ulL9qcln89V6ucBcOHX4
nA+FFOJnykrERRFRHluTLKRgGu89zc5Wn2CZor11pr4iRWoF3oWikyCuYYS0JGGfjKxMxNcBAgzd
R6Kzxfv+ZRwH3QVdXx0tOt+oDo922595PsKZDp2/4TY4tbZpQJXKvvT5FnX0tkVx25XlFQAe8WQk
ZzYqQU3b6Nz7SHQReIiiykw//Bo28RZAtEoAf6HF0ps1q1esj0stSvv69yuwMQhausUEabAxQe4Q
B12UDrqLmA+YOFiYGbBGJCRRMIJzPijyQJH47wcoIv+Bb7IHzdD9/c8AH0kEJag/0NwPHkz6C6GR
hh3ACewvtG5hBDakgOUFuEH1B6j5/79fwAbWL4bHr38x3H7yneH1+x/gbh4z4y8GEa4f/7m/P/j5
8uGFj7dP7Gc2MTERAZ0IDlrHACryQQ0yUOSvWrXqxYoVKx5CI/0FdPkWiA+76BW2hu87tKj+MxA3
iQAEEC1nYWDHzBmePHlqmaysDBtsfgA0/PsbWrT+/ou4ffcndFEFePj4P0IOrB46nAzr4kE7Coiu
IAN6V/A/9Cpx8NgiOJKB2RW0swUoB4xgYGPq31/QTN1Pho9ffjB8+fETfOPnr69vwcX2nVs3GW5c
2PPx/r1H95Dq1jfQnAqKtP/Aer/Cx8eHE5QATE1NYUezvC8pKTkC1QO72Re2OfMlA2J//u/BcHUM
QADR8oQH2PzAqz37Dx0xsfF24nnPycDGzg0dj4dE7p9//+GLJv/C+/T/4d035L4+A3w+ADpDB6KB
EczE+JeB6T+o7Aa12H6B8e8/wJbyT9A28J/gSGYElqCf3r9luHv/IcOVG/cYrt1+zPDl22/wfkcQ
Bu114Gd+8efx9f1XP378Cbql9DE04p5Bi+wP0OIZ5BJuYMRnAxt4nKCt2KAEA8z5PwsKCtYDq4Ef
0ITyHJrrnzEgVu1+hYbL38FwWQQIAAQQredhwfMDHJyc5v2Lj8zjFRBn4BUQAq9wRYlc2OwadPiV
BdSCByUCYN+MmfEfPOf+h0bsH3A36DfDDyANajUzAiP/88d3DPfuP2C4fus+MHKfMLz/9B18cSkT
KwcwgjmBEcwBub2VjZuBhY0HTLMBO9kiP3a/37VxLWg3Leh2x3vQiH/JgNhQ+QdpvIqFiYmJz8/P
b0JKSko0sMvHdOzYsX9AfP4UsP8FVf8GKeJhW7Q+Q+vzP4Ml4mEAIIBofcYLeH7gx/fvj3+9v3vn
Hw+vCjsTDwMX9KZ5pv9/wZH3Dxi5oCVOf0B93O8/wf1r0PIxEP7/H7SO7hP4HL9rN+8zXL35iOHt
x2+QLWosHOAIBl3JC8agyGWXYmCVVmWQVOCCyEHVMDEDczow4fGyvv3PcHvipZ3rD69ggNxlirF3
HsdINDM3N7coMNfPiYmJ8fj48SPTyZMn/+7cuXMjMFIvI0U+LOJfQyMeloj+MQxCABBAtE4A/6DF
3tvVi6YsLavrq//74TvDuz+/oQtCgXXw98+/nzy6/f761cuvTp449uzmzZvvYMUkdJ2BhIZdotNf
NklgnIsxsEgqMkjIQSMcnLs5IMU4Myuw/geWLEwgmhmImeAFnCTDsV/nNjVsvn3nzQEg9wEDYjMF
/MQMAqUkyDBOaWnpCmAR73rgwAGmT58+/QFG/hxgwrwJa/BCzYSVHt8YEDd/DtqpDYAAYqRTIgOd
PK4FxAbQhiEb2iAGbCADdo4NrBsECnhRINYMzp3Y85LRnA09crFaCGyti39aCLq1eCG0aH8IzZmw
7dKkXMkKPqBJSkoqRFhYuB/Y0BN8+vTpdGBVcBOYGH5CzXsNjfg3aIkKI+IH2y1tAAFEr7VY7NCZ
QtAqYg5o4MPOyP8JzfF/YH1dpICDHWEDOrBfPyavevojlmCsx32DLif/d6Pr4vYtB5dDc/ljIot2
fIAJ6nbQhcZmQJwKxCsZIMviGdByPnJdjzNxDbYEABBAQ+Hwf0ZoogHvSIpMiut+KlCgDCnaTwCL
9jpyi3ZiSy/QbijQETrC0ATMA3XTD6SBnY9ILXy8JctgSwAAATSULgIC5UTQZhR5aJXCBA3852QW
7cSEDTM0AYBKIW4oZmVAHJ4Ji/gfxJYwgy0BAATQULo69ic0sl9DI+Y/NND/0qiR9R+amGAN0p/Q
CGeAjdwhVVv/GQb3GhacACCAWIbY1bGwCKEL0NTU/A+1jxGaABiRIvs/NEcP6du0AAIMANtMxR3x
N38FAAAAAElFTkSuQmCC\
"""

def thumbnail():
    icon = base64.decodestring(iconstr)
    return icon

if __name__ == "__main__":
    icon = thumbnail()
    f = file("thumbnail.png","wb")
    f.write(icon)
    f.close()

########NEW FILE########
__FILENAME__ = userfield
#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2009 Sren Roug, European Environment Agency
#
# This is free software.  You may redistribute it under the terms
# of the Apache license and the GNU General Public License Version
# 2 or at your option any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s): Michael Howitz, gocept gmbh & co. kg
#
# $Id: userfield.py 447 2008-07-10 20:01:30Z roug $

"""Class to show and manipulate user fields in odf documents."""

import sys
import zipfile

from odf.text import UserFieldDecl
from odf.namespaces import OFFICENS
from odf.opendocument import load

OUTENCODING = "utf-8"


# OpenDocument v.1.0 section 6.7.1
VALUE_TYPES = {
    'float': (OFFICENS, 'value'),
    'percentage': (OFFICENS, 'value'),
    'currency': (OFFICENS, 'value'),
    'date': (OFFICENS, 'date-value'),
    'time': (OFFICENS, 'time-value'),
    'boolean': (OFFICENS, 'boolean-value'),
    'string': (OFFICENS, 'string-value'),
    }


class UserFields(object):
    """List, view and manipulate user fields."""

    # these attributes can be a filename or a file like object
    src_file = None
    dest_file = None

    def __init__(self, src=None, dest=None):
        """Constructor

        src ... source document name, file like object or None for stdin
        dest ... destination document name, file like object or None for stdout

        """
        self.src_file = src
        self.dest_file = dest
        self.document = None

    def loaddoc(self):
        if isinstance(self.src_file, str):
            # src_file is a filename, check if it is a zip-file
            if not zipfile.is_zipfile(self.src_file):
                raise TypeError("%s is no odt file." % self.src_file)
        elif self.src_file is None:
            # use stdin if no file given
            self.src_file = sys.stdin

        self.document = load(self.src_file)

    def savedoc(self):
        # write output
        if self.dest_file is None:
            # use stdout if no filename given
            self.document.save('-')
        else:
            self.document.save(self.dest_file)

    def list_fields(self):
        """List (extract) all known user-fields.

        Returns list of user-field names.

        """
        return [x[0] for x in self.list_fields_and_values()]

    def list_fields_and_values(self, field_names=None):
        """List (extract) user-fields with type and value.

        field_names ... list of field names to show or None for all.

        Returns list of tuples (<field name>, <field type>, <value>).

        """
        self.loaddoc()
        found_fields = []
        all_fields = self.document.getElementsByType(UserFieldDecl)
        for f in all_fields:
            value_type = f.getAttribute('valuetype')
            if value_type == 'string':
                value = f.getAttribute('stringvalue')
            else:
                value = f.getAttribute('value')
            field_name = f.getAttribute('name')

            if field_names is None or field_name in field_names:
                found_fields.append((field_name.encode(OUTENCODING),
                                     value_type.encode(OUTENCODING),
                                     value.encode(OUTENCODING)))
        return found_fields

    def list_values(self, field_names):
        """Extract the contents of given field names from the file.

        field_names ... list of field names

        Returns list of field values.

        """
        return [x[2] for x in self.list_fields_and_values(field_names)]

    def get(self, field_name):
        """Extract the contents of this field from the file.

        Returns field value or None if field does not exist.

        """
        values = self.list_values([field_name])
        if not values:
            return None
        return values[0]

    def get_type_and_value(self, field_name):
        """Extract the type and contents of this field from the file.

        Returns tuple (<type>, <field-value>) or None if field does not exist.

        """
        fields = self.list_fields_and_values([field_name])
        if not fields:
            return None
        field_name, value_type, value = fields[0]
        return value_type, value

    def update(self, data):
        """Set the value of user fields. The field types will be the same.

        data ... dict, with field name as key, field value as value

        Returns None

        """
        self.loaddoc()
        all_fields = self.document.getElementsByType(UserFieldDecl)
        for f in all_fields:
            field_name = f.getAttribute('name')
            if field_name in data:
                value_type = f.getAttribute('valuetype')
                value = data.get(field_name)
                if value_type == 'string':
                    f.setAttribute('stringvalue', value)
                else:
                    f.setAttribute('value', value) 
        self.savedoc()


########NEW FILE########
__FILENAME__ = xforms
# -*- coding: utf-8 -*-
# Copyright (C) 2006-2007 Sren Roug, European Environment Agency
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contributor(s):
#

from .namespaces import XFORMSNS
from .element import Element

# ODF 1.0 section 11.2
# XForms is designed to be embedded in another XML format.
# Autogenerated
def Model(**args):
    return Element(qname = (XFORMSNS,'model'), **args)

def Instance(**args):
    return Element(qname = (XFORMSNS,'instance'), **args)

def Bind(**args):
    return Element(qname = (XFORMSNS,'bind'), **args)

########NEW FILE########
__FILENAME__ = core
# -*- coding: utf-8 -*-

"""
omijson.core
~~~~~~~~~~~~

This module provides the core omnijson functionality.

"""

import sys

engine = None
_engine = None


options = [
    ['ujson', 'loads', 'dumps', (ValueError,)],
    ['yajl', 'loads', 'dumps', (TypeError, ValueError)],
    ['jsonlib2', 'read', 'write', (ValueError,)],
    ['jsonlib', 'read', 'write', (ValueError,)],
    ['simplejson', 'loads', 'dumps', (TypeError, ValueError)],
    ['json', 'loads', 'dumps', (TypeError, ValueError)],
    ['simplejson_from_packages', 'loads', 'dumps', (ValueError,)],
]


def _import(engine):
    try:
        if '_from_' in engine:
            engine, package = engine.split('_from_')
            m = __import__(package, globals(), locals(), [engine], -1)
            return getattr(m, engine)

        return __import__(engine)

    except ImportError:
        return False


def loads(s, **kwargs):
    """Loads JSON object."""

    try:
        return _engine[0](s)

    except:
        # crazy 2/3 exception hack
        # http://www.voidspace.org.uk/python/weblog/arch_d7_2010_03_20.shtml

        ExceptionClass, why = sys.exc_info()[:2]

        if any([(issubclass(ExceptionClass, e)) for e in _engine[2]]):
            raise JSONError(why)
        else:
            raise why


def dumps(o, **kwargs):
    """Dumps JSON object."""

    try:
        return _engine[1](o)

    except:
        ExceptionClass, why = sys.exc_info()[:2]

        if any([(issubclass(ExceptionClass, e)) for e in _engine[2]]):
            raise JSONError(why)
        else:
            raise why


class JSONError(ValueError):
    """JSON Failed."""


# ------
# Magic!
# ------


for e in options:

    __engine = _import(e[0])

    if __engine:
        engine, _engine = e[0], e[1:4]

        for i in (0, 1):
            _engine[i] = getattr(__engine, _engine[i])

        break

########NEW FILE########
__FILENAME__ = decoder
"""Implementation of JSONDecoder
"""
import re
import sys
import struct

from .scanner import make_scanner
def _import_c_scanstring():
    try:
        from simplejson._speedups import scanstring
        return scanstring
    except ImportError:
        return None
c_scanstring = _import_c_scanstring()

__all__ = ['JSONDecoder']

FLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL

def _floatconstants():
    _BYTES = '7FF80000000000007FF0000000000000'.decode('hex')
    # The struct module in Python 2.4 would get frexp() out of range here
    # when an endian is specified in the format string. Fixed in Python 2.5+
    if sys.byteorder != 'big':
        _BYTES = _BYTES[:8][::-1] + _BYTES[8:][::-1]
    nan, inf = struct.unpack('dd', _BYTES)
    return nan, inf, -inf

NaN, PosInf, NegInf = _floatconstants()


class JSONDecodeError(ValueError):
    """Subclass of ValueError with the following additional properties:

    msg: The unformatted error message
    doc: The JSON document being parsed
    pos: The start index of doc where parsing failed
    end: The end index of doc where parsing failed (may be None)
    lineno: The line corresponding to pos
    colno: The column corresponding to pos
    endlineno: The line corresponding to end (may be None)
    endcolno: The column corresponding to end (may be None)

    """
    def __init__(self, msg, doc, pos, end=None):
        ValueError.__init__(self, errmsg(msg, doc, pos, end=end))
        self.msg = msg
        self.doc = doc
        self.pos = pos
        self.end = end
        self.lineno, self.colno = linecol(doc, pos)
        if end is not None:
            self.endlineno, self.endcolno = linecol(doc, end)
        else:
            self.endlineno, self.endcolno = None, None


def linecol(doc, pos):
    lineno = doc.count('\n', 0, pos) + 1
    if lineno == 1:
        colno = pos
    else:
        colno = pos - doc.rindex('\n', 0, pos)
    return lineno, colno


def errmsg(msg, doc, pos, end=None):
    # Note that this function is called from _speedups
    lineno, colno = linecol(doc, pos)
    if end is None:
        #fmt = '{0}: line {1} column {2} (char {3})'
        #return fmt.format(msg, lineno, colno, pos)
        fmt = '%s: line %d column %d (char %d)'
        return fmt % (msg, lineno, colno, pos)
    endlineno, endcolno = linecol(doc, end)
    #fmt = '{0}: line {1} column {2} - line {3} column {4} (char {5} - {6})'
    #return fmt.format(msg, lineno, colno, endlineno, endcolno, pos, end)
    fmt = '%s: line %d column %d - line %d column %d (char %d - %d)'
    return fmt % (msg, lineno, colno, endlineno, endcolno, pos, end)


_CONSTANTS = {
    '-Infinity': NegInf,
    'Infinity': PosInf,
    'NaN': NaN,
}

STRINGCHUNK = re.compile(r'(.*?)(["\\\x00-\x1f])', FLAGS)
BACKSLASH = {
    '"': u'"', '\\': u'\\', '/': u'/',
    'b': u'\b', 'f': u'\f', 'n': u'\n', 'r': u'\r', 't': u'\t',
}

DEFAULT_ENCODING = "utf-8"

def py_scanstring(s, end, encoding=None, strict=True,
        _b=BACKSLASH, _m=STRINGCHUNK.match):
    """Scan the string s for a JSON string. End is the index of the
    character in s after the quote that started the JSON string.
    Unescapes all valid JSON string escape sequences and raises ValueError
    on attempt to decode an invalid string. If strict is False then literal
    control characters are allowed in the string.

    Returns a tuple of the decoded string and the index of the character in s
    after the end quote."""
    if encoding is None:
        encoding = DEFAULT_ENCODING
    chunks = []
    _append = chunks.append
    begin = end - 1
    while 1:
        chunk = _m(s, end)
        if chunk is None:
            raise JSONDecodeError(
                "Unterminated string starting at", s, begin)
        end = chunk.end()
        content, terminator = chunk.groups()
        # Content is contains zero or more unescaped string characters
        if content:
            if not isinstance(content, unicode):
                content = unicode(content, encoding)
            _append(content)
        # Terminator is the end of string, a literal control character,
        # or a backslash denoting that an escape sequence follows
        if terminator == '"':
            break
        elif terminator != '\\':
            if strict:
                msg = "Invalid control character %r at" % (terminator,)
                #msg = "Invalid control character {0!r} at".format(terminator)
                raise JSONDecodeError(msg, s, end)
            else:
                _append(terminator)
                continue
        try:
            esc = s[end]
        except IndexError:
            raise JSONDecodeError(
                "Unterminated string starting at", s, begin)
        # If not a unicode escape sequence, must be in the lookup table
        if esc != 'u':
            try:
                char = _b[esc]
            except KeyError:
                msg = "Invalid \\escape: " + repr(esc)
                raise JSONDecodeError(msg, s, end)
            end += 1
        else:
            # Unicode escape sequence
            esc = s[end + 1:end + 5]
            next_end = end + 5
            if len(esc) != 4:
                msg = "Invalid \\uXXXX escape"
                raise JSONDecodeError(msg, s, end)
            uni = int(esc, 16)
            # Check for surrogate pair on UCS-4 systems
            if 0xd800 <= uni <= 0xdbff and sys.maxunicode > 65535:
                msg = "Invalid \\uXXXX\\uXXXX surrogate pair"
                if not s[end + 5:end + 7] == '\\u':
                    raise JSONDecodeError(msg, s, end)
                esc2 = s[end + 7:end + 11]
                if len(esc2) != 4:
                    raise JSONDecodeError(msg, s, end)
                uni2 = int(esc2, 16)
                uni = 0x10000 + (((uni - 0xd800) << 10) | (uni2 - 0xdc00))
                next_end += 6
            char = unichr(uni)
            end = next_end
        # Append the unescaped character
        _append(char)
    return u''.join(chunks), end


# Use speedup if available
scanstring = c_scanstring or py_scanstring

WHITESPACE = re.compile(r'[ \t\n\r]*', FLAGS)
WHITESPACE_STR = ' \t\n\r'

def JSONObject((s, end), encoding, strict, scan_once, object_hook,
        object_pairs_hook, memo=None,
        _w=WHITESPACE.match, _ws=WHITESPACE_STR):
    # Backwards compatibility
    if memo is None:
        memo = {}
    memo_get = memo.setdefault
    pairs = []
    # Use a slice to prevent IndexError from being raised, the following
    # check will raise a more specific ValueError if the string is empty
    nextchar = s[end:end + 1]
    # Normally we expect nextchar == '"'
    if nextchar != '"':
        if nextchar in _ws:
            end = _w(s, end).end()
            nextchar = s[end:end + 1]
        # Trivial empty object
        if nextchar == '}':
            if object_pairs_hook is not None:
                result = object_pairs_hook(pairs)
                return result, end + 1
            pairs = {}
            if object_hook is not None:
                pairs = object_hook(pairs)
            return pairs, end + 1
        elif nextchar != '"':
            raise JSONDecodeError("Expecting property name", s, end)
    end += 1
    while True:
        key, end = scanstring(s, end, encoding, strict)
        key = memo_get(key, key)

        # To skip some function call overhead we optimize the fast paths where
        # the JSON key separator is ": " or just ":".
        if s[end:end + 1] != ':':
            end = _w(s, end).end()
            if s[end:end + 1] != ':':
                raise JSONDecodeError("Expecting : delimiter", s, end)

        end += 1

        try:
            if s[end] in _ws:
                end += 1
                if s[end] in _ws:
                    end = _w(s, end + 1).end()
        except IndexError:
            pass

        try:
            value, end = scan_once(s, end)
        except StopIteration:
            raise JSONDecodeError("Expecting object", s, end)
        pairs.append((key, value))

        try:
            nextchar = s[end]
            if nextchar in _ws:
                end = _w(s, end + 1).end()
                nextchar = s[end]
        except IndexError:
            nextchar = ''
        end += 1

        if nextchar == '}':
            break
        elif nextchar != ',':
            raise JSONDecodeError("Expecting , delimiter", s, end - 1)

        try:
            nextchar = s[end]
            if nextchar in _ws:
                end += 1
                nextchar = s[end]
                if nextchar in _ws:
                    end = _w(s, end + 1).end()
                    nextchar = s[end]
        except IndexError:
            nextchar = ''

        end += 1
        if nextchar != '"':
            raise JSONDecodeError("Expecting property name", s, end - 1)

    if object_pairs_hook is not None:
        result = object_pairs_hook(pairs)
        return result, end
    pairs = dict(pairs)
    if object_hook is not None:
        pairs = object_hook(pairs)
    return pairs, end

def JSONArray((s, end), scan_once, _w=WHITESPACE.match, _ws=WHITESPACE_STR):
    values = []
    nextchar = s[end:end + 1]
    if nextchar in _ws:
        end = _w(s, end + 1).end()
        nextchar = s[end:end + 1]
    # Look-ahead for trivial empty array
    if nextchar == ']':
        return values, end + 1
    _append = values.append
    while True:
        try:
            value, end = scan_once(s, end)
        except StopIteration:
            raise JSONDecodeError("Expecting object", s, end)
        _append(value)
        nextchar = s[end:end + 1]
        if nextchar in _ws:
            end = _w(s, end + 1).end()
            nextchar = s[end:end + 1]
        end += 1
        if nextchar == ']':
            break
        elif nextchar != ',':
            raise JSONDecodeError("Expecting , delimiter", s, end)

        try:
            if s[end] in _ws:
                end += 1
                if s[end] in _ws:
                    end = _w(s, end + 1).end()
        except IndexError:
            pass

    return values, end

class JSONDecoder(object):
    """Simple JSON <http://json.org> decoder

    Performs the following translations in decoding by default:

    +---------------+-------------------+
    | JSON          | Python            |
    +===============+===================+
    | object        | dict              |
    +---------------+-------------------+
    | array         | list              |
    +---------------+-------------------+
    | string        | unicode           |
    +---------------+-------------------+
    | number (int)  | int, long         |
    +---------------+-------------------+
    | number (real) | float             |
    +---------------+-------------------+
    | true          | True              |
    +---------------+-------------------+
    | false         | False             |
    +---------------+-------------------+
    | null          | None              |
    +---------------+-------------------+

    It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as
    their corresponding ``float`` values, which is outside the JSON spec.

    """

    def __init__(self, encoding=None, object_hook=None, parse_float=None,
            parse_int=None, parse_constant=None, strict=True,
            object_pairs_hook=None):
        """
        *encoding* determines the encoding used to interpret any
        :class:`str` objects decoded by this instance (``'utf-8'`` by
        default).  It has no effect when decoding :class:`unicode` objects.

        Note that currently only encodings that are a superset of ASCII work,
        strings of other encodings should be passed in as :class:`unicode`.

        *object_hook*, if specified, will be called with the result of every
        JSON object decoded and its return value will be used in place of the
        given :class:`dict`.  This can be used to provide custom
        deserializations (e.g. to support JSON-RPC class hinting).

        *object_pairs_hook* is an optional function that will be called with
        the result of any object literal decode with an ordered list of pairs.
        The return value of *object_pairs_hook* will be used instead of the
        :class:`dict`.  This feature can be used to implement custom decoders
        that rely on the order that the key and value pairs are decoded (for
        example, :func:`collections.OrderedDict` will remember the order of
        insertion). If *object_hook* is also defined, the *object_pairs_hook*
        takes priority.

        *parse_float*, if specified, will be called with the string of every
        JSON float to be decoded.  By default, this is equivalent to
        ``float(num_str)``. This can be used to use another datatype or parser
        for JSON floats (e.g. :class:`decimal.Decimal`).

        *parse_int*, if specified, will be called with the string of every
        JSON int to be decoded.  By default, this is equivalent to
        ``int(num_str)``.  This can be used to use another datatype or parser
        for JSON integers (e.g. :class:`float`).

        *parse_constant*, if specified, will be called with one of the
        following strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  This
        can be used to raise an exception if invalid JSON numbers are
        encountered.

        *strict* controls the parser's behavior when it encounters an
        invalid control character in a string. The default setting of
        ``True`` means that unescaped control characters are parse errors, if
        ``False`` then control characters will be allowed in strings.

        """
        self.encoding = encoding
        self.object_hook = object_hook
        self.object_pairs_hook = object_pairs_hook
        self.parse_float = parse_float or float
        self.parse_int = parse_int or int
        self.parse_constant = parse_constant or _CONSTANTS.__getitem__
        self.strict = strict
        self.parse_object = JSONObject
        self.parse_array = JSONArray
        self.parse_string = scanstring
        self.memo = {}
        self.scan_once = make_scanner(self)

    def decode(self, s, _w=WHITESPACE.match):
        """Return the Python representation of ``s`` (a ``str`` or ``unicode``
        instance containing a JSON document)

        """
        obj, end = self.raw_decode(s, idx=_w(s, 0).end())
        end = _w(s, end).end()
        if end != len(s):
            raise JSONDecodeError("Extra data", s, end, len(s))
        return obj

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` or ``unicode``
        beginning with a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.

        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.

        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration:
            raise JSONDecodeError("No JSON object could be decoded", s, idx)
        return obj, end

########NEW FILE########
__FILENAME__ = encoder
"""Implementation of JSONEncoder
"""
import re
from decimal import Decimal

def _import_speedups():
    try:
        from simplejson import _speedups
        return _speedups.encode_basestring_ascii, _speedups.make_encoder
    except ImportError:
        return None, None
c_encode_basestring_ascii, c_make_encoder = _import_speedups()

from .decoder import PosInf

ESCAPE = re.compile(r'[\x00-\x1f\\"\b\f\n\r\t]')
ESCAPE_ASCII = re.compile(r'([\\"]|[^\ -~])')
HAS_UTF8 = re.compile(r'[\x80-\xff]')
ESCAPE_DCT = {
    '\\': '\\\\',
    '"': '\\"',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t',
}
for i in range(0x20):
    #ESCAPE_DCT.setdefault(chr(i), '\\u{0:04x}'.format(i))
    ESCAPE_DCT.setdefault(chr(i), '\\u%04x' % (i,))

FLOAT_REPR = repr

def encode_basestring(s):
    """Return a JSON representation of a Python string

    """
    if isinstance(s, str) and HAS_UTF8.search(s) is not None:
        s = s.decode('utf-8')
    def replace(match):
        return ESCAPE_DCT[match.group(0)]
    return u'"' + ESCAPE.sub(replace, s) + u'"'


def py_encode_basestring_ascii(s):
    """Return an ASCII-only JSON representation of a Python string

    """
    if isinstance(s, str) and HAS_UTF8.search(s) is not None:
        s = s.decode('utf-8')
    def replace(match):
        s = match.group(0)
        try:
            return ESCAPE_DCT[s]
        except KeyError:
            n = ord(s)
            if n < 0x10000:
                #return '\\u{0:04x}'.format(n)
                return '\\u%04x' % (n,)
            else:
                # surrogate pair
                n -= 0x10000
                s1 = 0xd800 | ((n >> 10) & 0x3ff)
                s2 = 0xdc00 | (n & 0x3ff)
                #return '\\u{0:04x}\\u{1:04x}'.format(s1, s2)
                return '\\u%04x\\u%04x' % (s1, s2)
    return '"' + str(ESCAPE_ASCII.sub(replace, s)) + '"'


encode_basestring_ascii = (
    c_encode_basestring_ascii or py_encode_basestring_ascii)

class JSONEncoder(object):
    """Extensible JSON <http://json.org> encoder for Python data structures.

    Supports the following objects and types by default:

    +-------------------+---------------+
    | Python            | JSON          |
    +===================+===============+
    | dict              | object        |
    +-------------------+---------------+
    | list, tuple       | array         |
    +-------------------+---------------+
    | str, unicode      | string        |
    +-------------------+---------------+
    | int, long, float  | number        |
    +-------------------+---------------+
    | True              | true          |
    +-------------------+---------------+
    | False             | false         |
    +-------------------+---------------+
    | None              | null          |
    +-------------------+---------------+

    To extend this to recognize other objects, subclass and implement a
    ``.default()`` method with another method that returns a serializable
    object for ``o`` if possible, otherwise it should call the superclass
    implementation (to raise ``TypeError``).

    """
    item_separator = ', '
    key_separator = ': '
    def __init__(self, skipkeys=False, ensure_ascii=True,
            check_circular=True, allow_nan=True, sort_keys=False,
            indent=None, separators=None, encoding='utf-8', default=None,
            use_decimal=False):
        """Constructor for JSONEncoder, with sensible defaults.

        If skipkeys is false, then it is a TypeError to attempt
        encoding of keys that are not str, int, long, float or None.  If
        skipkeys is True, such items are simply skipped.

        If ensure_ascii is true, the output is guaranteed to be str
        objects with all incoming unicode characters escaped.  If
        ensure_ascii is false, the output will be unicode object.

        If check_circular is true, then lists, dicts, and custom encoded
        objects will be checked for circular references during encoding to
        prevent an infinite recursion (which would cause an OverflowError).
        Otherwise, no such check takes place.

        If allow_nan is true, then NaN, Infinity, and -Infinity will be
        encoded as such.  This behavior is not JSON specification compliant,
        but is consistent with most JavaScript based encoders and decoders.
        Otherwise, it will be a ValueError to encode such floats.

        If sort_keys is true, then the output of dictionaries will be
        sorted by key; this is useful for regression tests to ensure
        that JSON serializations can be compared on a day-to-day basis.

        If indent is a string, then JSON array elements and object members
        will be pretty-printed with a newline followed by that string repeated
        for each level of nesting. ``None`` (the default) selects the most compact
        representation without any newlines. For backwards compatibility with
        versions of simplejson earlier than 2.1.0, an integer is also accepted
        and is converted to a string with that many spaces.

        If specified, separators should be a (item_separator, key_separator)
        tuple.  The default is (', ', ': ').  To get the most compact JSON
        representation you should specify (',', ':') to eliminate whitespace.

        If specified, default is a function that gets called for objects
        that can't otherwise be serialized.  It should return a JSON encodable
        version of the object or raise a ``TypeError``.

        If encoding is not None, then all input strings will be
        transformed into unicode using that encoding prior to JSON-encoding.
        The default is UTF-8.

        If use_decimal is true (not the default), ``decimal.Decimal`` will
        be supported directly by the encoder. For the inverse, decode JSON
        with ``parse_float=decimal.Decimal``.

        """

        self.skipkeys = skipkeys
        self.ensure_ascii = ensure_ascii
        self.check_circular = check_circular
        self.allow_nan = allow_nan
        self.sort_keys = sort_keys
        self.use_decimal = use_decimal
        if isinstance(indent, (int, long)):
            indent = ' ' * indent
        self.indent = indent
        if separators is not None:
            self.item_separator, self.key_separator = separators
        elif indent is not None:
            self.item_separator = ','
        if default is not None:
            self.default = default
        self.encoding = encoding

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).

        For example, to support arbitrary iterators, you could
        implement default like this::

            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                return JSONEncoder.default(self, o)

        """
        raise TypeError(repr(o) + " is not JSON serializable")

    def encode(self, o):
        """Return a JSON string representation of a Python data structure.

        >>> from simplejson import JSONEncoder
        >>> JSONEncoder().encode({"foo": ["bar", "baz"]})
        '{"foo": ["bar", "baz"]}'

        """
        # This is for extremely simple cases and benchmarks.
        if isinstance(o, basestring):
            if isinstance(o, str):
                _encoding = self.encoding
                if (_encoding is not None
                        and not (_encoding == 'utf-8')):
                    o = o.decode(_encoding)
            if self.ensure_ascii:
                return encode_basestring_ascii(o)
            else:
                return encode_basestring(o)
        # This doesn't pass the iterator directly to ''.join() because the
        # exceptions aren't as detailed.  The list call should be roughly
        # equivalent to the PySequence_Fast that ''.join() would do.
        chunks = self.iterencode(o, _one_shot=True)
        if not isinstance(chunks, (list, tuple)):
            chunks = list(chunks)
        if self.ensure_ascii:
            return ''.join(chunks)
        else:
            return u''.join(chunks)

    def iterencode(self, o, _one_shot=False):
        """Encode the given object and yield each string
        representation as available.

        For example::

            for chunk in JSONEncoder().iterencode(bigobject):
                mysocket.write(chunk)

        """
        if self.check_circular:
            markers = {}
        else:
            markers = None
        if self.ensure_ascii:
            _encoder = encode_basestring_ascii
        else:
            _encoder = encode_basestring
        if self.encoding != 'utf-8':
            def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):
                if isinstance(o, str):
                    o = o.decode(_encoding)
                return _orig_encoder(o)

        def floatstr(o, allow_nan=self.allow_nan,
                _repr=FLOAT_REPR, _inf=PosInf, _neginf=-PosInf):
            # Check for specials. Note that this type of test is processor
            # and/or platform-specific, so do tests which don't depend on
            # the internals.

            if o != o:
                text = 'NaN'
            elif o == _inf:
                text = 'Infinity'
            elif o == _neginf:
                text = '-Infinity'
            else:
                return _repr(o)

            if not allow_nan:
                raise ValueError(
                    "Out of range float values are not JSON compliant: " +
                    repr(o))

            return text


        key_memo = {}
        if (_one_shot and c_make_encoder is not None
                and self.indent is None):
            _iterencode = c_make_encoder(
                markers, self.default, _encoder, self.indent,
                self.key_separator, self.item_separator, self.sort_keys,
                self.skipkeys, self.allow_nan, key_memo, self.use_decimal)
        else:
            _iterencode = _make_iterencode(
                markers, self.default, _encoder, self.indent, floatstr,
                self.key_separator, self.item_separator, self.sort_keys,
                self.skipkeys, _one_shot, self.use_decimal)
        try:
            return _iterencode(o, 0)
        finally:
            key_memo.clear()


class JSONEncoderForHTML(JSONEncoder):
    """An encoder that produces JSON safe to embed in HTML.

    To embed JSON content in, say, a script tag on a web page, the
    characters &, < and > should be escaped. They cannot be escaped
    with the usual entities (e.g. &amp;) because they are not expanded
    within <script> tags.
    """

    def encode(self, o):
        # Override JSONEncoder.encode because it has hacks for
        # performance that make things more complicated.
        chunks = self.iterencode(o, True)
        if self.ensure_ascii:
            return ''.join(chunks)
        else:
            return u''.join(chunks)

    def iterencode(self, o, _one_shot=False):
        chunks = super(JSONEncoderForHTML, self).iterencode(o, _one_shot)
        for chunk in chunks:
            chunk = chunk.replace('&', '\\u0026')
            chunk = chunk.replace('<', '\\u003c')
            chunk = chunk.replace('>', '\\u003e')
            yield chunk


def _make_iterencode(markers, _default, _encoder, _indent, _floatstr,
        _key_separator, _item_separator, _sort_keys, _skipkeys, _one_shot,
        _use_decimal,
        ## HACK: hand-optimized bytecode; turn globals into locals
        False=False,
        True=True,
        ValueError=ValueError,
        basestring=basestring,
        Decimal=Decimal,
        dict=dict,
        float=float,
        id=id,
        int=int,
        isinstance=isinstance,
        list=list,
        long=long,
        str=str,
        tuple=tuple,
    ):

    def _iterencode_list(lst, _current_indent_level):
        if not lst:
            yield '[]'
            return
        if markers is not None:
            markerid = id(lst)
            if markerid in markers:
                raise ValueError("Circular reference detected")
            markers[markerid] = lst
        buf = '['
        if _indent is not None:
            _current_indent_level += 1
            newline_indent = '\n' + (_indent * _current_indent_level)
            separator = _item_separator + newline_indent
            buf += newline_indent
        else:
            newline_indent = None
            separator = _item_separator
        first = True
        for value in lst:
            if first:
                first = False
            else:
                buf = separator
            if isinstance(value, basestring):
                yield buf + _encoder(value)
            elif value is None:
                yield buf + 'null'
            elif value is True:
                yield buf + 'true'
            elif value is False:
                yield buf + 'false'
            elif isinstance(value, (int, long)):
                yield buf + str(value)
            elif isinstance(value, float):
                yield buf + _floatstr(value)
            elif _use_decimal and isinstance(value, Decimal):
                yield buf + str(value)
            else:
                yield buf
                if isinstance(value, (list, tuple)):
                    chunks = _iterencode_list(value, _current_indent_level)
                elif isinstance(value, dict):
                    chunks = _iterencode_dict(value, _current_indent_level)
                else:
                    chunks = _iterencode(value, _current_indent_level)
                for chunk in chunks:
                    yield chunk
        if newline_indent is not None:
            _current_indent_level -= 1
            yield '\n' + (_indent * _current_indent_level)
        yield ']'
        if markers is not None:
            del markers[markerid]

    def _iterencode_dict(dct, _current_indent_level):
        if not dct:
            yield '{}'
            return
        if markers is not None:
            markerid = id(dct)
            if markerid in markers:
                raise ValueError("Circular reference detected")
            markers[markerid] = dct
        yield '{'
        if _indent is not None:
            _current_indent_level += 1
            newline_indent = '\n' + (_indent * _current_indent_level)
            item_separator = _item_separator + newline_indent
            yield newline_indent
        else:
            newline_indent = None
            item_separator = _item_separator
        first = True
        if _sort_keys:
            items = dct.items()
            items.sort(key=lambda kv: kv[0])
        else:
            items = dct.iteritems()
        for key, value in items:
            if isinstance(key, basestring):
                pass
            # JavaScript is weakly typed for these, so it makes sense to
            # also allow them.  Many encoders seem to do something like this.
            elif isinstance(key, float):
                key = _floatstr(key)
            elif key is True:
                key = 'true'
            elif key is False:
                key = 'false'
            elif key is None:
                key = 'null'
            elif isinstance(key, (int, long)):
                key = str(key)
            elif _skipkeys:
                continue
            else:
                raise TypeError("key " + repr(key) + " is not a string")
            if first:
                first = False
            else:
                yield item_separator
            yield _encoder(key)
            yield _key_separator
            if isinstance(value, basestring):
                yield _encoder(value)
            elif value is None:
                yield 'null'
            elif value is True:
                yield 'true'
            elif value is False:
                yield 'false'
            elif isinstance(value, (int, long)):
                yield str(value)
            elif isinstance(value, float):
                yield _floatstr(value)
            elif _use_decimal and isinstance(value, Decimal):
                yield str(value)
            else:
                if isinstance(value, (list, tuple)):
                    chunks = _iterencode_list(value, _current_indent_level)
                elif isinstance(value, dict):
                    chunks = _iterencode_dict(value, _current_indent_level)
                else:
                    chunks = _iterencode(value, _current_indent_level)
                for chunk in chunks:
                    yield chunk
        if newline_indent is not None:
            _current_indent_level -= 1
            yield '\n' + (_indent * _current_indent_level)
        yield '}'
        if markers is not None:
            del markers[markerid]

    def _iterencode(o, _current_indent_level):
        if isinstance(o, basestring):
            yield _encoder(o)
        elif o is None:
            yield 'null'
        elif o is True:
            yield 'true'
        elif o is False:
            yield 'false'
        elif isinstance(o, (int, long)):
            yield str(o)
        elif isinstance(o, float):
            yield _floatstr(o)
        elif isinstance(o, (list, tuple)):
            for chunk in _iterencode_list(o, _current_indent_level):
                yield chunk
        elif isinstance(o, dict):
            for chunk in _iterencode_dict(o, _current_indent_level):
                yield chunk
        elif _use_decimal and isinstance(o, Decimal):
            yield str(o)
        else:
            if markers is not None:
                markerid = id(o)
                if markerid in markers:
                    raise ValueError("Circular reference detected")
                markers[markerid] = o
            o = _default(o)
            for chunk in _iterencode(o, _current_indent_level):
                yield chunk
            if markers is not None:
                del markers[markerid]

    return _iterencode

########NEW FILE########
__FILENAME__ = ordered_dict
"""Drop-in replacement for collections.OrderedDict by Raymond Hettinger

http://code.activestate.com/recipes/576693/

"""
from UserDict import DictMixin

# Modified from original to support Python 2.4, see
# http://code.google.com/p/simplejson/issues/detail?id=53
try:
    all
except NameError:
    def all(seq):
        for elem in seq:
            if not elem:
                return False
        return True

class OrderedDict(dict, DictMixin):

    def __init__(self, *args, **kwds):
        if len(args) > 1:
            raise TypeError('expected at most 1 arguments, got %d' % len(args))
        try:
            self.__end
        except AttributeError:
            self.clear()
        self.update(*args, **kwds)

    def clear(self):
        self.__end = end = []
        end += [None, end, end]         # sentinel node for doubly linked list
        self.__map = {}                 # key --> [key, prev, next]
        dict.clear(self)

    def __setitem__(self, key, value):
        if key not in self:
            end = self.__end
            curr = end[1]
            curr[2] = end[1] = self.__map[key] = [key, curr, end]
        dict.__setitem__(self, key, value)

    def __delitem__(self, key):
        dict.__delitem__(self, key)
        key, prev, next = self.__map.pop(key)
        prev[2] = next
        next[1] = prev

    def __iter__(self):
        end = self.__end
        curr = end[2]
        while curr is not end:
            yield curr[0]
            curr = curr[2]

    def __reversed__(self):
        end = self.__end
        curr = end[1]
        while curr is not end:
            yield curr[0]
            curr = curr[1]

    def popitem(self, last=True):
        if not self:
            raise KeyError('dictionary is empty')
        # Modified from original to support Python 2.4, see
        # http://code.google.com/p/simplejson/issues/detail?id=53
        if last:
            key = reversed(self).next()
        else:
            key = iter(self).next()
        value = self.pop(key)
        return key, value

    def __reduce__(self):
        items = [[k, self[k]] for k in self]
        tmp = self.__map, self.__end
        del self.__map, self.__end
        inst_dict = vars(self).copy()
        self.__map, self.__end = tmp
        if inst_dict:
            return (self.__class__, (items,), inst_dict)
        return self.__class__, (items,)

    def keys(self):
        return list(self)

    setdefault = DictMixin.setdefault
    update = DictMixin.update
    pop = DictMixin.pop
    values = DictMixin.values
    items = DictMixin.items
    iterkeys = DictMixin.iterkeys
    itervalues = DictMixin.itervalues
    iteritems = DictMixin.iteritems

    def __repr__(self):
        if not self:
            return '%s()' % (self.__class__.__name__,)
        return '%s(%r)' % (self.__class__.__name__, self.items())

    def copy(self):
        return self.__class__(self)

    @classmethod
    def fromkeys(cls, iterable, value=None):
        d = cls()
        for key in iterable:
            d[key] = value
        return d

    def __eq__(self, other):
        if isinstance(other, OrderedDict):
            return len(self)==len(other) and \
                   all(p==q for p, q in  zip(self.items(), other.items()))
        return dict.__eq__(self, other)

    def __ne__(self, other):
        return not self == other

########NEW FILE########
__FILENAME__ = scanner
"""JSON token scanner
"""
import re

__all__ = ['make_scanner']

NUMBER_RE = re.compile(
    r'(-?(?:0|[1-9]\d*))(\.\d+)?([eE][-+]?\d+)?',
    (re.VERBOSE | re.MULTILINE | re.DOTALL))

def py_make_scanner(context):
    parse_object = context.parse_object
    parse_array = context.parse_array
    parse_string = context.parse_string
    match_number = NUMBER_RE.match
    encoding = context.encoding
    strict = context.strict
    parse_float = context.parse_float
    parse_int = context.parse_int
    parse_constant = context.parse_constant
    object_hook = context.object_hook
    object_pairs_hook = context.object_pairs_hook
    memo = context.memo

    def _scan_once(string, idx):
        try:
            nextchar = string[idx]
        except IndexError:
            raise StopIteration

        if nextchar == '"':
            return parse_string(string, idx + 1, encoding, strict)
        elif nextchar == '{':
            return parse_object((string, idx + 1), encoding, strict,
                _scan_once, object_hook, object_pairs_hook, memo)
        elif nextchar == '[':
            return parse_array((string, idx + 1), _scan_once)
        elif nextchar == 'n' and string[idx:idx + 4] == 'null':
            return None, idx + 4
        elif nextchar == 't' and string[idx:idx + 4] == 'true':
            return True, idx + 4
        elif nextchar == 'f' and string[idx:idx + 5] == 'false':
            return False, idx + 5

        m = match_number(string, idx)
        if m is not None:
            integer, frac, exp = m.groups()
            if frac or exp:
                res = parse_float(integer + (frac or '') + (exp or ''))
            else:
                res = parse_int(integer)
            return res, m.end()
        elif nextchar == 'N' and string[idx:idx + 3] == 'NaN':
            return parse_constant('NaN'), idx + 3
        elif nextchar == 'I' and string[idx:idx + 8] == 'Infinity':
            return parse_constant('Infinity'), idx + 8
        elif nextchar == '-' and string[idx:idx + 9] == '-Infinity':
            return parse_constant('-Infinity'), idx + 9
        else:
            raise StopIteration

    def scan_once(string, idx):
        try:
            return _scan_once(string, idx)
        finally:
            memo.clear()

    return scan_once

make_scanner = py_make_scanner

########NEW FILE########
__FILENAME__ = cell
# file openpyxl/cell.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Manage individual cells in a spreadsheet.

The Cell class is required to know its value and type, display options,
and any other features of an Excel cell.  Utilities for referencing
cells using Excel's 'A1' column/row nomenclature are also provided.

"""

__docformat__ = "restructuredtext en"

# Python stdlib imports
import datetime
import re

# package imports
from .shared.date_time import SharedDate
from .shared.exc import CellCoordinatesException, \
        ColumnStringIndexException, DataTypeException
from .style import NumberFormat

# constants
COORD_RE = re.compile('^[$]?([A-Z]+)[$]?(\d+)$')

ABSOLUTE_RE = re.compile('^[$]?([A-Z]+)[$]?(\d+)(:[$]?([A-Z]+)[$]?(\d+))?$')

def coordinate_from_string(coord_string):
    """Convert a coordinate string like 'B12' to a tuple ('B', 12)"""
    match = COORD_RE.match(coord_string.upper())
    if not match:
        msg = 'Invalid cell coordinates (%s)' % coord_string
        raise CellCoordinatesException(msg)
    column, row = match.groups()
    return (column, int(row))


def absolute_coordinate(coord_string):
    """Convert a coordinate to an absolute coordinate string (B12 -> $B$12)"""
    parts = ABSOLUTE_RE.match(coord_string).groups()

    if all(parts[-2:]):
        return '$%s$%s:$%s$%s' % (parts[0], parts[1], parts[3], parts[4])
    else:
        return '$%s$%s' % (parts[0], parts[1])


def column_index_from_string(column, fast = False):
    """Convert a column letter into a column number (e.g. B -> 2)

    Excel only supports 1-3 letter column names from A -> ZZZ, so we
    restrict our column names to 1-3 characters, each in the range A-Z.

    .. note::

        Fast mode is faster but does not check that all letters are capitals between A and Z

    """
    column = column.upper()

    clen = len(column)

    if not fast and not all('A' <= char <= 'Z' for char in column):
        msg = 'Column string must contain only characters A-Z: got %s' % column
        raise ColumnStringIndexException(msg)

    if clen == 1:
        return ord(column[0]) - 64
    elif clen == 2:
        return ((1 + (ord(column[0]) - 65)) * 26) + (ord(column[1]) - 64)
    elif clen == 3:
        return ((1 + (ord(column[0]) - 65)) * 676) + ((1 + (ord(column[1]) - 65)) * 26) + (ord(column[2]) - 64)
    elif clen > 3:
        raise ColumnStringIndexException('Column string index can not be longer than 3 characters')
    else:
        raise ColumnStringIndexException('Column string index can not be empty')


def get_column_letter(col_idx):
    """Convert a column number into a column letter (3 -> 'C')

    Right shift the column col_idx by 26 to find column letters in reverse
    order.  These numbers are 1-based, and can be converted to ASCII
    ordinals by adding 64.

    """
    # these indicies corrospond to A -> ZZZ and include all allowed
    # columns
    if not 1 <= col_idx <= 18278:
        msg = 'Column index out of bounds: %s' % col_idx
        raise ColumnStringIndexException(msg)
    ordinals = []
    temp = col_idx
    while temp:
        quotient, remainder = divmod(temp, 26)
        # check for exact division and borrow if needed
        if remainder == 0:
            quotient -= 1
            remainder = 26
        ordinals.append(remainder + 64)
        temp = quotient
    ordinals.reverse()
    return ''.join([chr(ordinal) for ordinal in ordinals])


class Cell(object):
    """Describes cell associated properties.

    Properties of interest include style, type, value, and address.

    """
    __slots__ = ('column',
                 'row',
                 '_value',
                 '_data_type',
                 'parent',
                 'xf_index',
                 '_hyperlink_rel')

    ERROR_CODES = {'#NULL!': 0,
                   '#DIV/0!': 1,
                   '#VALUE!': 2,
                   '#REF!': 3,
                   '#NAME?': 4,
                   '#NUM!': 5,
                   '#N/A': 6}

    TYPE_STRING = 's'
    TYPE_FORMULA = 'f'
    TYPE_NUMERIC = 'n'
    TYPE_BOOL = 'b'
    TYPE_NULL = 's'
    TYPE_INLINE = 'inlineStr'
    TYPE_ERROR = 'e'

    VALID_TYPES = [TYPE_STRING, TYPE_FORMULA, TYPE_NUMERIC, TYPE_BOOL,
                   TYPE_NULL, TYPE_INLINE, TYPE_ERROR]

    RE_PATTERNS = {
        'percentage': re.compile('^\-?[0-9]*\.?[0-9]*\s?\%$'),
        'time': re.compile('^(\d|[0-1]\d|2[0-3]):[0-5]\d(:[0-5]\d)?$'),
        'numeric': re.compile('^\-?([0-9]+\\.?[0-9]*|[0-9]*\\.?[0-9]+)((E|e)\-?[0-9]+)?$'), }

    def __init__(self, worksheet, column, row, value = None):
        self.column = column.upper()
        self.row = row
        # _value is the stored value, while value is the displayed value
        self._value = None
        self._hyperlink_rel = None
        self._data_type = self.TYPE_NULL
        if value:
            self.value = value
        self.parent = worksheet
        self.xf_index = 0

    def __repr__(self):
        return "<Cell %s.%s>" % (self.parent.title, self.get_coordinate())

    def check_string(self, value):
        """Check string coding, length, and line break character"""
        # convert to unicode string
        value = unicode(value)
        # string must never be longer than 32,767 characters
        # truncate if necessary
        value = value[:32767]
        # we require that newline is represented as "\n" in core,
        # not as "\r\n" or "\r"
        value = value.replace('\r\n', '\n')
        return value

    def check_numeric(self, value):
        """Cast value to int or float if necessary"""
        if not isinstance(value, (int, float)):
            try:
                value = int(value)
            except ValueError:
                value = float(value)
        return value

    def set_value_explicit(self, value = None, data_type = TYPE_STRING):
        """Coerce values according to their explicit type"""
        type_coercion_map = {
            self.TYPE_INLINE: self.check_string,
            self.TYPE_STRING: self.check_string,
            self.TYPE_FORMULA: unicode,
            self.TYPE_NUMERIC: self.check_numeric,
            self.TYPE_BOOL: bool, }
        try:
            self._value = type_coercion_map[data_type](value)
        except KeyError:
            if data_type not in self.VALID_TYPES:
                msg = 'Invalid data type: %s' % data_type
                raise DataTypeException(msg)
        self._data_type = data_type

    def data_type_for_value(self, value):
        """Given a value, infer the correct data type"""
        if value is None:
            data_type = self.TYPE_NULL
        elif value is True or value is False:
            data_type = self.TYPE_BOOL
        elif isinstance(value, (int, float)):
            data_type = self.TYPE_NUMERIC
        elif not value:
            data_type = self.TYPE_STRING
        elif isinstance(value, (datetime.datetime, datetime.date)):
            data_type = self.TYPE_NUMERIC
        elif isinstance(value, basestring) and value[0] == '=':
            data_type = self.TYPE_FORMULA
        elif self.RE_PATTERNS['numeric'].match(value):
            data_type = self.TYPE_NUMERIC
        elif value.strip() in self.ERROR_CODES:
            data_type = self.TYPE_ERROR
        else:
            data_type = self.TYPE_STRING
        return data_type

    def bind_value(self, value):
        """Given a value, infer type and display options."""
        self._data_type = self.data_type_for_value(value)
        if value is None:
            self.set_value_explicit('', self.TYPE_NULL)
            return True
        elif self._data_type == self.TYPE_STRING:
            # percentage detection
            percentage_search = self.RE_PATTERNS['percentage'].match(value)
            if percentage_search and value.strip() != '%':
                value = float(value.replace('%', '')) / 100.0
                self.set_value_explicit(value, self.TYPE_NUMERIC)
                self._set_number_format(NumberFormat.FORMAT_PERCENTAGE)
                return True
            # time detection
            time_search = self.RE_PATTERNS['time'].match(value)
            if time_search:
                sep_count = value.count(':') #pylint: disable-msg=E1103
                if sep_count == 1:
                    hours, minutes = [int(bit) for bit in value.split(':')] #pylint: disable-msg=E1103
                    seconds = 0
                elif sep_count == 2:
                    hours, minutes, seconds = \
                            [int(bit) for bit in value.split(':')] #pylint: disable-msg=E1103
                days = (hours / 24.0) + (minutes / 1440.0) + \
                        (seconds / 86400.0)
                self.set_value_explicit(days, self.TYPE_NUMERIC)
                self._set_number_format(NumberFormat.FORMAT_DATE_TIME3)
                return True
        if self._data_type == self.TYPE_NUMERIC:
            # date detection
            # if the value is a date, but not a date time, make it a
            # datetime, and set the time part to 0
            if isinstance(value, datetime.date) and not \
                    isinstance(value, datetime.datetime):
                value = datetime.datetime.combine(value, datetime.time())
            if isinstance(value, datetime.datetime):
                value = SharedDate().datetime_to_julian(date = value)
                self.set_value_explicit(value, self.TYPE_NUMERIC)
                self._set_number_format(NumberFormat.FORMAT_DATE_YYYYMMDD2)
                return True
        self.set_value_explicit(value, self._data_type)

    def _get_value(self):
        """Return the value, formatted as a date if needed"""
        value = self._value
        if self.is_date():
            value = SharedDate().from_julian(value)
        return value

    def _set_value(self, value):
        """Set the value and infer type and display options."""
        self.bind_value(value)

    value = property(_get_value, _set_value,
            doc = 'Get or set the value held in the cell.\n\n'
            ':rtype: depends on the value (string, float, int or '
            ':class:`datetime.datetime`)')

    def _set_hyperlink(self, val):
        """Set value and display for hyperlinks in a cell"""
        if self._hyperlink_rel is None:
            self._hyperlink_rel = self.parent.create_relationship("hyperlink")
        self._hyperlink_rel.target = val
        self._hyperlink_rel.target_mode = "External"
        if self._value is None:
            self.value = val

    def _get_hyperlink(self):
        """Return the hyperlink target or an empty string"""
        return self._hyperlink_rel is not None and \
                self._hyperlink_rel.target or ''

    hyperlink = property(_get_hyperlink, _set_hyperlink,
            doc = 'Get or set the hyperlink held in the cell.  '
            'Automatically sets the `value` of the cell with link text, '
            'but you can modify it afterwards by setting the '
            '`value` property, and the hyperlink will remain.\n\n'
            ':rtype: string')

    @property
    def hyperlink_rel_id(self):
        """Return the id pointed to by the hyperlink, or None"""
        return self._hyperlink_rel is not None and \
                self._hyperlink_rel.id or None

    def _set_number_format(self, format_code):
        """Set a new formatting code for numeric values"""
        self.style.number_format.format_code = format_code

    @property
    def has_style(self):
        """Check if the parent worksheet has a style for this cell"""
        return self.get_coordinate() in self.parent._styles #pylint: disable-msg=W0212

    @property
    def style(self):
        """Returns the :class:`openpyxl.style.Style` object for this cell"""
        return self.parent.get_style(self.get_coordinate())

    @property
    def data_type(self):
        """Return the data type represented by this cell"""
        return self._data_type

    def get_coordinate(self):
        """Return the coordinate string for this cell (e.g. 'B12')

        :rtype: string
        """
        return '%s%s' % (self.column, self.row)

    @property
    def address(self):
        """Return the coordinate string for this cell (e.g. 'B12')

        :rtype: string
        """
        return self.get_coordinate()

    def offset(self, row = 0, column = 0):
        """Returns a cell location relative to this cell.

        :param row: number of rows to offset
        :type row: int

        :param column: number of columns to offset
        :type column: int

        :rtype: :class:`openpyxl.cell.Cell`
        """
        offset_column = get_column_letter(column_index_from_string(
                column = self.column) + column)
        offset_row = self.row + row
        return self.parent.cell('%s%s' % (offset_column, offset_row))

    def is_date(self):
        """Returns whether the value is *probably* a date or not

        :rtype: bool
        """
        return (self.has_style
                and self.style.number_format.is_date_format()
                and isinstance(self._value, (int, float)))

########NEW FILE########
__FILENAME__ = chart
'''
Copyright (c) 2010 openpyxl

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license: http://www.opensource.org/licenses/mit-license.php
@author: Eric Gazoni
'''

import math

from .style import NumberFormat
from .drawing import Drawing, Shape
from .shared.units import pixels_to_EMU, short_color
from .cell import get_column_letter

class Axis(object):

    POSITION_BOTTOM = 'b'
    POSITION_LEFT = 'l'

    ORIENTATION_MIN_MAX = "minMax"

    def __init__(self):

        self.orientation = self.ORIENTATION_MIN_MAX
        self.number_format = NumberFormat()
        for attr in ('position','tick_label_position','crosses',
            'auto','label_align','label_offset','cross_between'):
            setattr(self, attr, None)
        self.min = 0
        self.max = None
        self.unit = None

    @classmethod
    def default_category(cls):
        """ default values for category axes """

        ax = Axis()
        ax.id = 60871424
        ax.cross = 60873344
        ax.position = Axis.POSITION_BOTTOM
        ax.tick_label_position = 'nextTo'
        ax.crosses = "autoZero"
        ax.auto = True
        ax.label_align = 'ctr'
        ax.label_offset = 100
        return ax

    @classmethod
    def default_value(cls):
        """ default values for value axes """

        ax = Axis()
        ax.id = 60873344
        ax.cross = 60871424
        ax.position = Axis.POSITION_LEFT
        ax.major_gridlines = None
        ax.tick_label_position = 'nextTo'
        ax.crosses = 'autoZero'
        ax.auto = False
        ax.cross_between = 'between'
        return ax

class Reference(object):
    """ a simple wrapper around a serie of reference data """

    def __init__(self, sheet, pos1, pos2=None):

        self.sheet = sheet
        self.pos1 = pos1
        self.pos2 = pos2

    def get_type(self):

        if isinstance(self.cache[0], basestring):
            return 'str'
        else:
            return 'num'

    def _get_ref(self):
        """ format excel reference notation """

        if self.pos2:
            return '%s!$%s$%s:$%s$%s' % (self.sheet.title,
                get_column_letter(self.pos1[1]+1), self.pos1[0]+1,
                get_column_letter(self.pos2[1]+1), self.pos2[0]+1)
        else:
            return '%s!$%s$%s' % (self.sheet.title,
                get_column_letter(self.pos1[1]+1), self.pos1[0]+1)


    def _get_cache(self):
        """ read data in sheet - to be used at writing time """

        cache = []
        if self.pos2:
            for row in range(self.pos1[0], self.pos2[0]+1):
                for col in range(self.pos1[1], self.pos2[1]+1):
                    cache.append(self.sheet.cell(row=row, column=col).value)
        else:
            cell = self.sheet.cell(row=self.pos1[0], column=self.pos1[1])
            cache.append(cell.value)
        return cache


class Serie(object):
    """ a serie of data and possibly associated labels """

    MARKER_NONE = 'none'

    def __init__(self, values, labels=None, legend=None, color=None, xvalues=None):

        self.marker = Serie.MARKER_NONE
        self.values = values
        self.xvalues = xvalues
        self.labels = labels
        self.legend = legend
        self.error_bar = None
        self._color = color

    def _get_color(self):
        return self._color

    def _set_color(self, color):
        self._color = short_color(color)

    color = property(_get_color, _set_color)

    def get_min_max(self):

        if self.error_bar:
            err_cache = self.error_bar.values._get_cache()
            vals = [v + err_cache[i] \
                for i,v in enumerate(self.values._get_cache())]
        else:
            vals = self.values._get_cache()
        return min(vals), max(vals)

    def __len__(self):

        return len(self.values.cache)

class Legend(object):

    def __init__(self):

        self.position = 'r'
        self.layout = None

class ErrorBar(object):

    PLUS = 1
    MINUS = 2
    PLUS_MINUS = 3

    def __init__(self, _type, values):

        self.type = _type
        self.values = values

class Chart(object):
    """ raw chart class """

    GROUPING_CLUSTERED = 'clustered'
    GROUPING_STANDARD = 'standard'

    BAR_CHART = 1
    LINE_CHART = 2
    SCATTER_CHART = 3

    def __init__(self, _type, grouping):

        self._series = []

        # public api
        self.type = _type
        self.grouping = grouping
        self.x_axis = Axis.default_category()
        self.y_axis = Axis.default_value()
        self.legend = Legend()
        self.lang = 'fr-FR'
        self.title = ''
        self.print_margins = dict(b=.75, l=.7, r=.7, t=.75, header=0.3, footer=.3)

        # the containing drawing
        self.drawing = Drawing()

        # the offset for the plot part in percentage of the drawing size
        self.width = .6
        self.height = .6
        self.margin_top = self._get_max_margin_top()
        self.margin_left = 0

        # the user defined shapes
        self._shapes = []

    def add_serie(self, serie):

        serie.id = len(self._series)
        self._series.append(serie)
        self._compute_min_max()
        if not None in [s.xvalues for s in self._series]:
            self._compute_xmin_xmax()

    def add_shape(self, shape):

        shape._chart = self
        self._shapes.append(shape)

    def get_x_units(self):
        """ calculate one unit for x axis in EMU """

        return max([len(s.values._get_cache()) for s in self._series])

    def get_y_units(self):
        """ calculate one unit for y axis in EMU """

        dh = pixels_to_EMU(self.drawing.height)
        return (dh * self.height) / self.y_axis.max

    def get_y_chars(self):
        """ estimate nb of chars for y axis """

        _max = max([max(s.values._get_cache()) for s in self._series])
        return len(str(int(_max)))

    def _compute_min_max(self):
        """ compute y axis limits and units """

        maxi = max([max(s.values._get_cache()) for s in self._series])

        mul = None
        if maxi < 1:
            s = str(maxi).split('.')[1]
            mul = 10
            for x in s:
                if x == '0':
                    mul *= 10
                else:
                    break
            maxi = maxi * mul

        maxi = math.ceil(maxi * 1.1)
        sz =  len(str(int(maxi))) - 1
        unit = math.ceil(math.ceil(maxi / pow(10, sz)) * pow(10, sz-1))
        maxi = math.ceil(maxi/unit) * unit

        if mul is not None:
            maxi = maxi/mul
            unit = unit/mul

        if maxi / unit > 9:
            # no more that 10 ticks
            unit *= 2

        self.y_axis.max = maxi
        self.y_axis.unit = unit

    def _compute_xmin_xmax(self):
        """ compute x axis limits and units """

        maxi = max([max(s.xvalues._get_cache()) for s in self._series])

        mul = None
        if maxi < 1:
            s = str(maxi).split('.')[1]
            mul = 10
            for x in s:
                if x == '0':
                    mul *= 10
                else:
                    break
            maxi = maxi * mul

        maxi = math.ceil(maxi * 1.1)
        sz =  len(str(int(maxi))) - 1
        unit = math.ceil(math.ceil(maxi / pow(10, sz)) * pow(10, sz-1))
        maxi = math.ceil(maxi/unit) * unit

        if mul is not None:
            maxi = maxi/mul
            unit = unit/mul

        if maxi / unit > 9:
            # no more that 10 ticks
            unit *= 2

        self.x_axis.max = maxi
        self.x_axis.unit = unit

    def _get_max_margin_top(self):

        mb = Shape.FONT_HEIGHT + Shape.MARGIN_BOTTOM
        plot_height = self.drawing.height * self.height
        return float(self.drawing.height - plot_height - mb)/self.drawing.height

    def _get_min_margin_left(self):

        ml = (self.get_y_chars() * Shape.FONT_WIDTH) + Shape.MARGIN_LEFT
        return float(ml)/self.drawing.width

    def _get_margin_top(self):
        """ get margin in percent """

        return min(self.margin_top, self._get_max_margin_top())

    def _get_margin_left(self):

        return max(self._get_min_margin_left(), self.margin_left)

class BarChart(Chart):
    def __init__(self):
        super(BarChart, self).__init__(Chart.BAR_CHART, Chart.GROUPING_CLUSTERED)

class LineChart(Chart):
    def __init__(self):
        super(LineChart, self).__init__(Chart.LINE_CHART, Chart.GROUPING_STANDARD)

class ScatterChart(Chart):
    def __init__(self):
        super(ScatterChart, self).__init__(Chart.SCATTER_CHART, Chart.GROUPING_STANDARD)



########NEW FILE########
__FILENAME__ = drawing
'''
Copyright (c) 2010 openpyxl

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license: http://www.opensource.org/licenses/mit-license.php
@author: Eric Gazoni
'''

import math
from .style import Color
from .shared.units import pixels_to_EMU, EMU_to_pixels, short_color

class Shadow(object):

    SHADOW_BOTTOM = 'b'
    SHADOW_BOTTOM_LEFT = 'bl'
    SHADOW_BOTTOM_RIGHT = 'br'
    SHADOW_CENTER = 'ctr'
    SHADOW_LEFT = 'l'
    SHADOW_TOP = 't'
    SHADOW_TOP_LEFT = 'tl'
    SHADOW_TOP_RIGHT = 'tr'

    def __init__(self):
    	self.visible = False
    	self.blurRadius = 6
    	self.distance = 2
    	self.direction = 0
    	self.alignment = self.SHADOW_BOTTOM_RIGHT
    	self.color = Color(Color.BLACK)
    	self.alpha = 50

class Drawing(object):
    """ a drawing object - eg container for shapes or charts
        we assume user specifies dimensions in pixels; units are
        converted to EMU in the drawing part
    """

    count = 0

    def __init__(self):

        self.name = ''
        self.description = ''
        self.coordinates = ((1,2), (16,8))
        self.left = 0
        self.top = 0
        self._width = EMU_to_pixels(200000)
        self._height = EMU_to_pixels(1828800)
        self.resize_proportional = False
        self.rotation = 0
#        self.shadow = Shadow()

    def _set_width(self, w):

        if self.resize_proportional and w:
            ratio = self._height / self._width
            self._height = round(ratio * w)
        self._width = w

    def _get_width(self):

        return self._width

    width = property(_get_width, _set_width)

    def _set_height(self, h):

        if self.resize_proportional and h:
            ratio = self._width / self._height
            self._width = round(ratio * h)
        self._height = h

    def _get_height(self):

        return self._height

    height = property(_get_height, _set_height)

    def set_dimension(self, w=0, h=0):

        xratio = w / self._width
        yratio = h / self._height

        if self.resize_proportional and w and h:
            if (xratio * self._height) < h:
                self._height = math.ceil(xratio * self._height)
                self._width = width
            else:
                self._width	= math.ceil(yratio * self._width)
                self._height = height

    def get_emu_dimensions(self):
        """ return (x, y, w, h) in EMU """

        return (pixels_to_EMU(self.left), pixels_to_EMU(self.top),
            pixels_to_EMU(self._width), pixels_to_EMU(self._height))


class Shape(object):
    """ a drawing inside a chart
        coordiantes are specified by the user in the axis units
    """

    MARGIN_LEFT = 6 + 13 + 1
    MARGIN_BOTTOM = 17 + 11

    FONT_WIDTH = 7
    FONT_HEIGHT = 8

    ROUND_RECT = 'roundRect'
    RECT = 'rect'

    # other shapes to define :
    '''
    "line"
    "lineInv"
    "triangle"
    "rtTriangle"
    "diamond"
    "parallelogram"
    "trapezoid"
    "nonIsoscelesTrapezoid"
    "pentagon"
    "hexagon"
    "heptagon"
    "octagon"
    "decagon"
    "dodecagon"
    "star4"
    "star5"
    "star6"
    "star7"
    "star8"
    "star10"
    "star12"
    "star16"
    "star24"
    "star32"
    "roundRect"
    "round1Rect"
    "round2SameRect"
    "round2DiagRect"
    "snipRoundRect"
    "snip1Rect"
    "snip2SameRect"
    "snip2DiagRect"
    "plaque"
    "ellipse"
    "teardrop"
    "homePlate"
    "chevron"
    "pieWedge"
    "pie"
    "blockArc"
    "donut"
    "noSmoking"
    "rightArrow"
    "leftArrow"
    "upArrow"
    "downArrow"
    "stripedRightArrow"
    "notchedRightArrow"
    "bentUpArrow"
    "leftRightArrow"
    "upDownArrow"
    "leftUpArrow"
    "leftRightUpArrow"
    "quadArrow"
    "leftArrowCallout"
    "rightArrowCallout"
    "upArrowCallout"
    "downArrowCallout"
    "leftRightArrowCallout"
    "upDownArrowCallout"
    "quadArrowCallout"
    "bentArrow"
    "uturnArrow"
    "circularArrow"
    "leftCircularArrow"
    "leftRightCircularArrow"
    "curvedRightArrow"
    "curvedLeftArrow"
    "curvedUpArrow"
    "curvedDownArrow"
    "swooshArrow"
    "cube"
    "can"
    "lightningBolt"
    "heart"
    "sun"
    "moon"
    "smileyFace"
    "irregularSeal1"
    "irregularSeal2"
    "foldedCorner"
    "bevel"
    "frame"
    "halfFrame"
    "corner"
    "diagStripe"
    "chord"
    "arc"
    "leftBracket"
    "rightBracket"
    "leftBrace"
    "rightBrace"
    "bracketPair"
    "bracePair"
    "straightConnector1"
    "bentConnector2"
    "bentConnector3"
    "bentConnector4"
    "bentConnector5"
    "curvedConnector2"
    "curvedConnector3"
    "curvedConnector4"
    "curvedConnector5"
    "callout1"
    "callout2"
    "callout3"
    "accentCallout1"
    "accentCallout2"
    "accentCallout3"
    "borderCallout1"
    "borderCallout2"
    "borderCallout3"
    "accentBorderCallout1"
    "accentBorderCallout2"
    "accentBorderCallout3"
    "wedgeRectCallout"
    "wedgeRoundRectCallout"
    "wedgeEllipseCallout"
    "cloudCallout"
    "cloud"
    "ribbon"
    "ribbon2"
    "ellipseRibbon"
    "ellipseRibbon2"
    "leftRightRibbon"
    "verticalScroll"
    "horizontalScroll"
    "wave"
    "doubleWave"
    "plus"
    "flowChartProcess"
    "flowChartDecision"
    "flowChartInputOutput"
    "flowChartPredefinedProcess"
    "flowChartInternalStorage"
    "flowChartDocument"
    "flowChartMultidocument"
    "flowChartTerminator"
    "flowChartPreparation"
    "flowChartManualInput"
    "flowChartManualOperation"
    "flowChartConnector"
    "flowChartPunchedCard"
    "flowChartPunchedTape"
    "flowChartSummingJunction"
    "flowChartOr"
    "flowChartCollate"
    "flowChartSort"
    "flowChartExtract"
    "flowChartMerge"
    "flowChartOfflineStorage"
    "flowChartOnlineStorage"
    "flowChartMagneticTape"
    "flowChartMagneticDisk"
    "flowChartMagneticDrum"
    "flowChartDisplay"
    "flowChartDelay"
    "flowChartAlternateProcess"
    "flowChartOffpageConnector"
    "actionButtonBlank"
    "actionButtonHome"
    "actionButtonHelp"
    "actionButtonInformation"
    "actionButtonForwardNext"
    "actionButtonBackPrevious"
    "actionButtonEnd"
    "actionButtonBeginning"
    "actionButtonReturn"
    "actionButtonDocument"
    "actionButtonSound"
    "actionButtonMovie"
    "gear6"
    "gear9"
    "funnel"
    "mathPlus"
    "mathMinus"
    "mathMultiply"
    "mathDivide"
    "mathEqual"
    "mathNotEqual"
    "cornerTabs"
    "squareTabs"
    "plaqueTabs"
    "chartX"
    "chartStar"
    "chartPlus"
    '''

    def __init__(self, coordinates=((0,0), (1,1)), text=None, scheme="accent1"):

        self.coordinates = coordinates # in axis unit
        self.text = text
        self.scheme = scheme
        self.style = Shape.RECT
        self._border_width = 3175 # in EMU
        self._border_color = Color.BLACK[2:] #"F3B3C5"
        self._color = Color.WHITE[2:]
        self._text_color = Color.BLACK[2:]

    def _get_border_color(self):
        return self._border_color

    def _set_border_color(self, color):
        self._border_color = short_color(color)

    border_color = property(_get_border_color, _set_border_color)

    def _get_color(self):
        return self._color

    def _set_color(self, color):
        self._color = short_color(color)

    color = property(_get_color, _set_color)

    def _get_text_color(self):
        return self._text_color

    def _set_text_color(self, color):
        self._text_color = short_color(color)

    text_color = property(_get_text_color, _set_text_color)

    def _get_border_width(self):

        return EMU_to_pixels(self._border_width)

    def _set_border_width(self, w):

        self._border_width = pixels_to_EMU(w)
        # print self._border_width

    border_width = property(_get_border_width, _set_border_width)

    def get_coordinates(self):
        """ return shape coordinates in percentages (left, top, right, bottom) """

        (x1, y1), (x2, y2) = self.coordinates

        drawing_width = pixels_to_EMU(self._chart.drawing.width)
        drawing_height = pixels_to_EMU(self._chart.drawing.height)
        plot_width = drawing_width * self._chart.width
        plot_height = drawing_height * self._chart.height

        margin_left = self._chart._get_margin_left() * drawing_width
        xunit = plot_width / self._chart.get_x_units()

        margin_top = self._chart._get_margin_top() * drawing_height
        yunit = self._chart.get_y_units()

        x_start = (margin_left + (float(x1) * xunit)) / drawing_width
        y_start = (margin_top + plot_height - (float(y1) * yunit)) / drawing_height

        x_end = (margin_left + (float(x2) * xunit)) / drawing_width
        y_end = (margin_top + plot_height - (float(y2) * yunit)) / drawing_height

        def _norm_pct(pct):
            """ force shapes to appear by truncating too large sizes """
            if pct>1: pct = 1
            elif pct<0: pct = 0
            return pct

        # allow user to specify y's in whatever order
        # excel expect y_end to be lower
        if y_end < y_start:
            y_end, y_start = y_start, y_end

        return (_norm_pct(x_start), _norm_pct(y_start),
            _norm_pct(x_end), _norm_pct(y_end))

########NEW FILE########
__FILENAME__ = namedrange
# file openpyxl/namedrange.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Track named groups of cells in a worksheet"""

# Python stdlib imports
import re

# package imports
from .shared.exc import NamedRangeException

# constants
NAMED_RANGE_RE = re.compile("'?([^']*)'?!((\$([A-Za-z]+))?\$([0-9]+)(:(\$([A-Za-z]+))?(\$([0-9]+)))?)$")

class NamedRange(object):
    """A named group of cells"""
    __slots__ = ('name', 'destinations', 'local_only')

    def __init__(self, name, destinations):
        self.name = name
        self.destinations = destinations
        self.local_only = False

    def __str__(self):
        return  ','.join(['%s!%s' % (sheet, name) for sheet, name in self.destinations])

    def __repr__(self):

        return '<%s "%s">' % (self.__class__.__name__, str(self))


def split_named_range(range_string):
    """Separate a named range into its component parts"""

    destinations = []

    for range_string in range_string.split(','):

        match = NAMED_RANGE_RE.match(range_string)
        if not match:
            raise NamedRangeException('Invalid named range string: "%s"' % range_string)
        else:
            sheet_name, xlrange = match.groups()[:2]
            destinations.append((sheet_name, xlrange))

    return destinations

########NEW FILE########
__FILENAME__ = excel
# file openpyxl/reader/excel.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Read an xlsx file into Python"""

# Python stdlib imports
from zipfile import ZipFile, ZIP_DEFLATED, BadZipfile

# package imports
from ..shared.exc import OpenModeError, InvalidFileException
from ..shared.ooxml import ARC_SHARED_STRINGS, ARC_CORE, ARC_APP, \
        ARC_WORKBOOK, PACKAGE_WORKSHEETS, ARC_STYLE
from ..workbook import Workbook
from ..reader.strings import read_string_table
from ..reader.style import read_style_table
from ..reader.workbook import read_sheets_titles, read_named_ranges, \
        read_properties_core, get_sheet_ids
from ..reader.worksheet import read_worksheet
from ..reader.iter_worksheet import unpack_worksheet

def load_workbook(filename, use_iterators = False):
    """Open the given filename and return the workbook

    :param filename: the path to open
    :type filename: string

    :param use_iterators: use lazy load for cells
    :type use_iterators: bool

    :rtype: :class:`openpyxl.workbook.Workbook`

    .. note::

        When using lazy load, all worksheets will be :class:`openpyxl.reader.iter_worksheet.IterableWorksheet`
        and the returned workbook will be read-only.

    """

    if isinstance(filename, file):
        # fileobject must have been opened with 'rb' flag
        # it is required by zipfile
        if 'b' not in filename.mode:
            raise OpenModeError("File-object must be opened in binary mode")

    try:
        archive = ZipFile(filename, 'r', ZIP_DEFLATED)
    except (BadZipfile, RuntimeError, IOError, ValueError):
        raise InvalidFileException()
    wb = Workbook()

    if use_iterators:
        wb._set_optimized_read()

    try:
        _load_workbook(wb, archive, filename, use_iterators)
    except KeyError:
        raise InvalidFileException()
    finally:
        archive.close()
    return wb

def _load_workbook(wb, archive, filename, use_iterators):

    # get workbook-level information
    wb.properties = read_properties_core(archive.read(ARC_CORE))
    try:
        string_table = read_string_table(archive.read(ARC_SHARED_STRINGS))
    except KeyError:
        string_table = {}
    style_table = read_style_table(archive.read(ARC_STYLE))

    # get worksheets
    wb.worksheets = []  # remove preset worksheet
    sheet_names = read_sheets_titles(archive.read(ARC_APP))
    for i, sheet_name in enumerate(sheet_names):
        sheet_codename = 'sheet%d.xml' % (i + 1)
        worksheet_path = '%s/%s' % (PACKAGE_WORKSHEETS, sheet_codename)

        if not use_iterators:
            new_ws = read_worksheet(archive.read(worksheet_path), wb, sheet_name, string_table, style_table)
        else:
            xml_source = unpack_worksheet(archive, worksheet_path)
            new_ws = read_worksheet(xml_source, wb, sheet_name, string_table, style_table, filename, sheet_codename)
            #new_ws = read_worksheet(archive.read(worksheet_path), wb, sheet_name, string_table, style_table, filename, sheet_codename)
        wb.add_sheet(new_ws, index = i)

    wb._named_ranges = read_named_ranges(archive.read(ARC_WORKBOOK), wb)

########NEW FILE########
__FILENAME__ = iter_worksheet
# file openpyxl/reader/iter_worksheet.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

""" Iterators-based worksheet reader
*Still very raw*
"""

from ....compat import BytesIO as StringIO
import warnings
import operator
from functools import partial
from itertools import groupby, ifilter
from ..worksheet import Worksheet
from ..cell import coordinate_from_string, get_column_letter, Cell
from ..reader.excel import get_sheet_ids
from ..reader.strings import read_string_table
from ..reader.style import read_style_table, NumberFormat
from ..shared.date_time import SharedDate
from ..reader.worksheet import read_dimension
from ..shared.ooxml import (MIN_COLUMN, MAX_COLUMN, PACKAGE_WORKSHEETS,
    MAX_ROW, MIN_ROW, ARC_SHARED_STRINGS, ARC_APP, ARC_STYLE)
try:
    from xml.etree.cElementTree import iterparse
except ImportError:
    from xml.etree.ElementTree import iterparse


from zipfile import ZipFile
from .. import cell
import re
import tempfile
import zlib
import zipfile
import struct

TYPE_NULL = Cell.TYPE_NULL
MISSING_VALUE = None

RE_COORDINATE = re.compile('^([A-Z]+)([0-9]+)$')

SHARED_DATE = SharedDate()

_COL_CONVERSION_CACHE = dict((get_column_letter(i), i) for i in xrange(1, 18279))
def column_index_from_string(str_col, _col_conversion_cache=_COL_CONVERSION_CACHE):
    # we use a function argument to get indexed name lookup
    return _col_conversion_cache[str_col]
del _COL_CONVERSION_CACHE

RAW_ATTRIBUTES = ['row', 'column', 'coordinate', 'internal_value', 'data_type', 'style_id', 'number_format']

try:
    from collections import namedtuple
    BaseRawCell = namedtuple('RawCell', RAW_ATTRIBUTES)
except ImportError:

    # warnings.warn("""Unable to import 'namedtuple' module, this may cause  memory issues when using optimized reader. Please upgrade your Python installation to 2.6+""")

    class BaseRawCell(object):

        def __init__(self, *args):
            assert len(args)==len(RAW_ATTRIBUTES)

            for attr, val in zip(RAW_ATTRIBUTES, args):
                setattr(self, attr, val)

        def _replace(self, **kwargs):

            self.__dict__.update(kwargs)

            return self


class RawCell(BaseRawCell):
    """Optimized version of the :class:`openpyxl.cell.Cell`, using named tuples.

    Useful attributes are:

    * row
    * column
    * coordinate
    * internal_value

    You can also access if needed:

    * data_type
    * number_format

    """

    @property
    def is_date(self):
        res = (self.data_type == Cell.TYPE_NUMERIC
               and self.number_format is not None
               and ('d' in self.number_format
                    or 'm' in self.number_format
                    or 'y' in self.number_format
                    or 'h' in self.number_format
                    or 's' in self.number_format
                   ))

        return res

def iter_rows(workbook_name, sheet_name, xml_source, range_string = '', row_offset = 0, column_offset = 0):

    archive = get_archive_file(workbook_name)

    source = xml_source

    if range_string:
        min_col, min_row, max_col, max_row = get_range_boundaries(range_string, row_offset, column_offset)
    else:
        min_col, min_row, max_col, max_row = read_dimension(xml_source = source)
        min_col = column_index_from_string(min_col)
        max_col = column_index_from_string(max_col) + 1
        max_row += 6

    try:
        string_table = read_string_table(archive.read(ARC_SHARED_STRINGS))
    except KeyError:
        string_table = {}

    style_table = read_style_table(archive.read(ARC_STYLE))

    source.seek(0)
    p = iterparse(source)

    return get_squared_range(p, min_col, min_row, max_col, max_row, string_table, style_table)


def get_rows(p, min_column = MIN_COLUMN, min_row = MIN_ROW, max_column = MAX_COLUMN, max_row = MAX_ROW):

    return groupby(get_cells(p, min_row, min_column, max_row, max_column), operator.attrgetter('row'))

def get_cells(p, min_row, min_col, max_row, max_col, _re_coordinate=RE_COORDINATE):

    for _event, element in p:

        if element.tag == '{http://schemas.openxmlformats.org/spreadsheetml/2006/main}c':
            coord = element.get('r')
            column_str, row = _re_coordinate.match(coord).groups()

            row = int(row)
            column = column_index_from_string(column_str)

            if min_col <= column <= max_col and min_row <= row <= max_row:
                data_type = element.get('t', 'n')
                style_id = element.get('s')
                value = element.findtext('{http://schemas.openxmlformats.org/spreadsheetml/2006/main}v')
                yield RawCell(row, column_str, coord, value, data_type, style_id, None)

        if element.tag == '{http://schemas.openxmlformats.org/spreadsheetml/2006/main}v':
            continue
        element.clear()



def get_range_boundaries(range_string, row = 0, column = 0):

    if ':' in range_string:
        min_range, max_range = range_string.split(':')
        min_col, min_row = coordinate_from_string(min_range)
        max_col, max_row = coordinate_from_string(max_range)

        min_col = column_index_from_string(min_col) + column
        max_col = column_index_from_string(max_col) + column
        min_row += row
        max_row += row

    else:
        min_col, min_row = coordinate_from_string(range_string)
        min_col = column_index_from_string(min_col)
        max_col = min_col + 1
        max_row = min_row

    return (min_col, min_row, max_col, max_row)

def get_archive_file(archive_name):

    return ZipFile(archive_name, 'r')

def get_xml_source(archive_file, sheet_name):

    return archive_file.read('%s/%s' % (PACKAGE_WORKSHEETS, sheet_name))

def get_missing_cells(row, columns):

    return dict([(column, RawCell(row, column, '%s%s' % (column, row), MISSING_VALUE, TYPE_NULL, None, None)) for column in columns])

def get_squared_range(p, min_col, min_row, max_col, max_row, string_table, style_table):

    expected_columns = [get_column_letter(ci) for ci in xrange(min_col, max_col)]

    current_row = min_row
    for row, cells in get_rows(p, min_row = min_row, max_row = max_row, min_column = min_col, max_column = max_col):
        full_row = []
        if current_row < row:

            for gap_row in xrange(current_row, row):

                dummy_cells = get_missing_cells(gap_row, expected_columns)

                yield tuple([dummy_cells[column] for column in expected_columns])

                current_row = row

        temp_cells = list(cells)

        retrieved_columns = dict([(c.column, c) for c in temp_cells])

        missing_columns = list(set(expected_columns) - set(retrieved_columns.keys()))

        replacement_columns = get_missing_cells(row, missing_columns)

        for column in expected_columns:

            if column in retrieved_columns:
                cell = retrieved_columns[column]

                if cell.style_id is not None:
                    style = style_table[int(cell.style_id)]
                    cell = cell._replace(number_format = style.number_format.format_code) #pylint: disable-msg=W0212
                if cell.internal_value is not None:
                    if cell.data_type == Cell.TYPE_STRING:
                        cell = cell._replace(internal_value = string_table[int(cell.internal_value)]) #pylint: disable-msg=W0212
                    elif cell.data_type == Cell.TYPE_BOOL:
                        cell = cell._replace(internal_value = cell.internal_value == 'True')
                    elif cell.is_date:
                        cell = cell._replace(internal_value = SHARED_DATE.from_julian(float(cell.internal_value)))
                    elif cell.data_type == Cell.TYPE_NUMERIC:
                        cell = cell._replace(internal_value = float(cell.internal_value))
                full_row.append(cell)

            else:
                full_row.append(replacement_columns[column])

        current_row = row + 1

        yield tuple(full_row)

#------------------------------------------------------------------------------

class IterableWorksheet(Worksheet):

    def __init__(self, parent_workbook, title, workbook_name,
            sheet_codename, xml_source):

        Worksheet.__init__(self, parent_workbook, title)
        self._workbook_name = workbook_name
        self._sheet_codename = sheet_codename
        self._xml_source = xml_source

    def iter_rows(self, range_string = '', row_offset = 0, column_offset = 0):
        """ Returns a squared range based on the `range_string` parameter,
        using generators.

        :param range_string: range of cells (e.g. 'A1:C4')
        :type range_string: string

        :param row: row index of the cell (e.g. 4)
        :type row: int

        :param column: column index of the cell (e.g. 3)
        :type column: int

        :rtype: generator

        """

        return iter_rows(workbook_name = self._workbook_name,
                         sheet_name = self._sheet_codename,
                         xml_source = self._xml_source,
                         range_string = range_string,
                         row_offset = row_offset,
                         column_offset = column_offset)

    def cell(self, *args, **kwargs):

        raise NotImplementedError("use 'iter_rows()' instead")

    def range(self, *args, **kwargs):

        raise NotImplementedError("use 'iter_rows()' instead")

def unpack_worksheet(archive, filename):

    temp_file = tempfile.TemporaryFile(mode='r+', prefix='openpyxl.', suffix='.unpack.temp')

    zinfo = archive.getinfo(filename)

    if zinfo.compress_type == zipfile.ZIP_STORED:
        decoder = None
    elif zinfo.compress_type == zipfile.ZIP_DEFLATED:
        decoder = zlib.decompressobj(-zlib.MAX_WBITS)
    else:
        raise zipfile.BadZipFile("Unrecognized compression method")

    archive.fp.seek(_get_file_offset(archive, zinfo))
    bytes_to_read = zinfo.compress_size

    while True:
        buff = archive.fp.read(min(bytes_to_read, 102400))
        if not buff:
            break
        bytes_to_read -= len(buff)
        if decoder:
            buff = decoder.decompress(buff)
        temp_file.write(buff)

    if decoder:
        temp_file.write(decoder.decompress('Z'))

    return temp_file

def _get_file_offset(archive, zinfo):

    try:
        return zinfo.file_offset
    except AttributeError:
        # From http://stackoverflow.com/questions/3781261/how-to-simulate-zipfile-open-in-python-2-5

        # Seek over the fixed size fields to the "file name length" field in
        # the file header (26 bytes). Unpack this and the "extra field length"
        # field ourselves as info.extra doesn't seem to be the correct length.
        archive.fp.seek(zinfo.header_offset + 26)
        file_name_len, extra_len = struct.unpack("<HH", archive.fp.read(4))
        return zinfo.header_offset + 30 + file_name_len + extra_len

########NEW FILE########
__FILENAME__ = strings
# file openpyxl/reader/strings.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Read the shared strings table."""

# package imports
from ..shared.xmltools import fromstring, QName
from ..shared.ooxml import NAMESPACES


def read_string_table(xml_source):
    """Read in all shared strings in the table"""
    table = {}
    xmlns = 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'
    root = fromstring(text=xml_source)
    string_index_nodes = root.findall(QName(xmlns, 'si').text)
    for index, string_index_node in enumerate(string_index_nodes):
        table[index] = get_string(xmlns, string_index_node)
    return table


def get_string(xmlns, string_index_node):
    """Read the contents of a specific string index"""
    rich_nodes = string_index_node.findall(QName(xmlns, 'r').text)
    if rich_nodes:
        reconstructed_text = []
        for rich_node in rich_nodes:
            partial_text = get_text(xmlns, rich_node)
            reconstructed_text.append(partial_text)
        return ''.join(reconstructed_text)
    else:
        return get_text(xmlns, string_index_node)


def get_text(xmlns, rich_node):
    """Read rich text, discarding formatting if not disallowed"""
    text_node = rich_node.find(QName(xmlns, 't').text)
    partial_text = text_node.text  or ''

    if text_node.get(QName(NAMESPACES['xml'], 'space').text) != 'preserve':
        partial_text = partial_text.strip()
    return unicode(partial_text)

########NEW FILE########
__FILENAME__ = style
# file openpyxl/reader/style.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Read shared style definitions"""

# package imports
from ..shared.xmltools import fromstring, QName
from ..shared.exc import MissingNumberFormat
from ..style import Style, NumberFormat


def read_style_table(xml_source):
    """Read styles from the shared style table"""
    table = {}
    xmlns = 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'
    root = fromstring(xml_source)
    custom_num_formats = parse_custom_num_formats(root, xmlns)
    builtin_formats = NumberFormat._BUILTIN_FORMATS
    cell_xfs = root.find(QName(xmlns, 'cellXfs').text)
    cell_xfs_nodes = cell_xfs.findall(QName(xmlns, 'xf').text)
    for index, cell_xfs_node in enumerate(cell_xfs_nodes):
        new_style = Style()
        number_format_id = int(cell_xfs_node.get('numFmtId'))
        if number_format_id < 164:
            new_style.number_format.format_code = \
                    builtin_formats.get(number_format_id, 'General')
        else:

            if number_format_id in custom_num_formats:
                new_style.number_format.format_code = \
                        custom_num_formats[number_format_id]
            else:
                raise MissingNumberFormat('%s' % number_format_id)
        table[index] = new_style
    return table


def parse_custom_num_formats(root, xmlns):
    """Read in custom numeric formatting rules from the shared style table"""
    custom_formats = {}
    num_fmts = root.find(QName(xmlns, 'numFmts').text)
    if num_fmts is not None:
        num_fmt_nodes = num_fmts.findall(QName(xmlns, 'numFmt').text)
        for num_fmt_node in num_fmt_nodes:
            custom_formats[int(num_fmt_node.get('numFmtId'))] = \
                    num_fmt_node.get('formatCode')
    return custom_formats

########NEW FILE########
__FILENAME__ = workbook
# file openpyxl/reader/workbook.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Read in global settings to be maintained by the workbook object."""

# package imports
from ..shared.xmltools import fromstring, QName
from ..shared.ooxml import NAMESPACES
from ..workbook import DocumentProperties
from ..shared.date_time import W3CDTF_to_datetime
from ..namedrange import NamedRange, split_named_range

import datetime

# constants
BUGGY_NAMED_RANGES = ['NA()', '#REF!']
DISCARDED_RANGES = ['Excel_BuiltIn', 'Print_Area']

def get_sheet_ids(xml_source):

    sheet_names = read_sheets_titles(xml_source)

    return dict((sheet, 'sheet%d.xml' % (i + 1)) for i, sheet in enumerate(sheet_names))


def read_properties_core(xml_source):
    """Read assorted file properties."""
    properties = DocumentProperties()
    root = fromstring(xml_source)
    creator_node = root.find(QName(NAMESPACES['dc'], 'creator').text)
    if creator_node is not None:
        properties.creator = creator_node.text
    else:
        properties.creator = ''
    last_modified_by_node = root.find(
            QName(NAMESPACES['cp'], 'lastModifiedBy').text)
    if last_modified_by_node is not None:
        properties.last_modified_by = last_modified_by_node.text
    else:
        properties.last_modified_by = ''

    created_node = root.find(QName(NAMESPACES['dcterms'], 'created').text)
    if created_node is not None:
        properties.created = W3CDTF_to_datetime(created_node.text)
    else:
        properties.created = datetime.datetime.now()

    modified_node = root.find(QName(NAMESPACES['dcterms'], 'modified').text)
    if modified_node is not None:
        properties.modified = W3CDTF_to_datetime(modified_node.text)
    else:
        properties.modified = properties.created

    return properties


def get_number_of_parts(xml_source):
    """Get a list of contents of the workbook."""
    parts_size = {}
    parts_names = []
    root = fromstring(xml_source)
    heading_pairs = root.find(QName('http://schemas.openxmlformats.org/officeDocument/2006/extended-properties',
            'HeadingPairs').text)
    vector = heading_pairs.find(QName(NAMESPACES['vt'], 'vector').text)
    children = vector.getchildren()
    for child_id in range(0, len(children), 2):
        part_name = children[child_id].find(QName(NAMESPACES['vt'],
                'lpstr').text).text
        if not part_name in parts_names:
            parts_names.append(part_name)
        part_size = int(children[child_id + 1].find(QName(
                NAMESPACES['vt'], 'i4').text).text)
        parts_size[part_name] = part_size
    return parts_size, parts_names


def read_sheets_titles(xml_source):
    """Read titles for all sheets."""
    root = fromstring(xml_source)
    titles_root = root.find(QName('http://schemas.openxmlformats.org/officeDocument/2006/extended-properties',
            'TitlesOfParts').text)
    vector = titles_root.find(QName(NAMESPACES['vt'], 'vector').text)
    parts, names = get_number_of_parts(xml_source)

    # we can't assume 'Worksheets' to be written in english,
    # but it's always the first item of the parts list (see bug #22)
    size = parts[names[0]]
    children = [c.text for c in vector.getchildren()]
    return children[:size]


def read_named_ranges(xml_source, workbook):
    """Read named ranges, excluding poorly defined ranges."""
    named_ranges = []
    root = fromstring(xml_source)
    names_root = root.find(QName('http://schemas.openxmlformats.org/spreadsheetml/2006/main',
            'definedNames').text)
    if names_root is not None:

        for name_node in names_root.getchildren():
            range_name = name_node.get('name')

            if name_node.get("hidden", '0') == '1':
                continue

            valid = True

            for discarded_range in DISCARDED_RANGES:
                if discarded_range in range_name:
                    valid = False

            for bad_range in BUGGY_NAMED_RANGES:
                if bad_range in name_node.text:
                    valid = False

            if valid:
                destinations = split_named_range(name_node.text)

                new_destinations = []
                for worksheet, cells_range in destinations:

                    # it can happen that a valid named range references
                    # a missing worksheet, when Excel didn't properly maintain
                    # the named range list
                    #
                    # we just ignore them here
                    worksheet = workbook.get_sheet_by_name(worksheet)
                    if worksheet:
                        new_destinations.append((worksheet, cells_range))

                named_range = NamedRange(range_name, new_destinations)
                named_ranges.append(named_range)

    return named_ranges

########NEW FILE########
__FILENAME__ = worksheet
# file openpyxl/reader/worksheet.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Reader for a single worksheet."""

# Python stdlib imports
try:
    from xml.etree.cElementTree import iterparse
except ImportError:
    from xml.etree.ElementTree import iterparse

from ....compat import ifilter
from ....compat import BytesIO as StringIO

# package imports
from ..cell import Cell, coordinate_from_string
from ..worksheet import Worksheet

def _get_xml_iter(xml_source):

    if not hasattr(xml_source, 'name'):
        return StringIO(xml_source)
    else:
        xml_source.seek(0)
        return xml_source

def read_dimension(xml_source):

    source = _get_xml_iter(xml_source)

    it = iterparse(source)

    for event, element in it:

        if element.tag == '{http://schemas.openxmlformats.org/spreadsheetml/2006/main}dimension':
            ref = element.get('ref')

            min_range, max_range = ref.split(':')
            min_col, min_row = coordinate_from_string(min_range)
            max_col, max_row = coordinate_from_string(max_range)

            return min_col, min_row, max_col, max_row

        else:
            element.clear()

    return None

def filter_cells(x):
    (event, element) = x

    return element.tag == '{http://schemas.openxmlformats.org/spreadsheetml/2006/main}c'

def fast_parse(ws, xml_source, string_table, style_table):

    source = _get_xml_iter(xml_source)

    it = iterparse(source)

    for event, element in ifilter(filter_cells, it):

        value = element.findtext('{http://schemas.openxmlformats.org/spreadsheetml/2006/main}v')

        if value is not None:

            coordinate = element.get('r')
            data_type = element.get('t', 'n')
            style_id = element.get('s')

            if data_type == Cell.TYPE_STRING:
                value = string_table.get(int(value))

            ws.cell(coordinate).value = value

            if style_id is not None:
                ws._styles[coordinate] = style_table.get(int(style_id))

        # to avoid memory exhaustion, clear the item after use
        element.clear()

from ..reader.iter_worksheet import IterableWorksheet

def read_worksheet(xml_source, parent, preset_title, string_table,
                   style_table, workbook_name = None, sheet_codename = None):
    """Read an xml worksheet"""
    if workbook_name and sheet_codename:
        ws = IterableWorksheet(parent, preset_title, workbook_name,
                sheet_codename, xml_source)
    else:
        ws = Worksheet(parent, preset_title)
        fast_parse(ws, xml_source, string_table, style_table)
    return ws

########NEW FILE########
__FILENAME__ = date_time
# file openpyxl/shared/date_time.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Manage Excel date weirdness."""

# Python stdlib imports
from __future__ import division
from math import floor
import calendar
import datetime
import time
import re

# constants
W3CDTF_FORMAT = '%Y-%m-%dT%H:%M:%SZ'

RE_W3CDTF = '(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(.(\d{2}))?Z'

EPOCH = datetime.datetime.utcfromtimestamp(0)

def datetime_to_W3CDTF(dt):
    """Convert from a datetime to a timestamp string."""
    return datetime.datetime.strftime(dt, W3CDTF_FORMAT)


def W3CDTF_to_datetime(formatted_string):
    """Convert from a timestamp string to a datetime object."""
    match = re.match(RE_W3CDTF,formatted_string)
    digits = map(int, match.groups()[:6])
    return datetime.datetime(*digits)


class SharedDate(object):
    """Date formatting utilities for Excel with shared state.

    Excel has a two primary date tracking schemes:
      Windows - Day 1 == 1900-01-01
      Mac - Day 1 == 1904-01-01

    SharedDate stores which system we are using and converts dates between
    Python and Excel accordingly.

    """
    CALENDAR_WINDOWS_1900 = 1900
    CALENDAR_MAC_1904 = 1904
    datetime_object_type = 'DateTime'

    def __init__(self):
        self.excel_base_date = self.CALENDAR_WINDOWS_1900

    def datetime_to_julian(self, date):
        """Convert from python datetime to excel julian date representation."""

        if isinstance(date, datetime.datetime):
            return self.to_julian(date.year, date.month, date.day, \
                hours=date.hour, minutes=date.minute, seconds=date.second)
        elif isinstance(date, datetime.date):
            return self.to_julian(date.year, date.month, date.day)

    def to_julian(self, year, month, day, hours=0, minutes=0, seconds=0):
        """Convert from Python date to Excel JD."""
        # explicitly disallow bad years
        # Excel 2000 treats JD=0 as 1/0/1900 (buggy, disallow)
        # Excel 2000 treats JD=2958466 as a bad date (Y10K bug!)
        if year < 1900 or year > 10000:
            msg = 'Year not supported by Excel: %s' % year
            raise ValueError(msg)
        if self.excel_base_date == self.CALENDAR_WINDOWS_1900:
            # Fudge factor for the erroneous fact that the year 1900 is
            # treated as a Leap Year in MS Excel.  This affects every date
            # following 28th February 1900
            if year == 1900 and month <= 2:
                excel_1900_leap_year = False
            else:
                excel_1900_leap_year = True
            excel_base_date = 2415020
        else:
            raise NotImplementedError('Mac dates are not yet supported.')
            #excel_base_date = 2416481
            #excel_1900_leap_year = False

        # Julian base date adjustment
        if month > 2:
            month = month - 3
        else:
            month = month + 9
            year -= 1

        # Calculate the Julian Date, then subtract the Excel base date
        # JD 2415020 = 31 - Dec - 1899 -> Excel Date of 0
        century, decade = int(str(year)[:2]), int(str(year)[2:])
        excel_date = floor(146097 * century / 4) + \
                floor((1461 * decade) / 4) + floor((153 * month + 2) / 5) + \
                day + 1721119 - excel_base_date
        if excel_1900_leap_year:
            excel_date += 1

        # check to ensure that we exclude 2/29/1900 as a possible value
        if self.excel_base_date == self.CALENDAR_WINDOWS_1900 \
                and excel_date == 60:
            msg = 'Error: Excel believes 1900 was a leap year'
            raise ValueError(msg)
        excel_time = ((hours * 3600) + (minutes * 60) + seconds) / 86400
        return excel_date + excel_time

    def from_julian(self, value=0):
        """Convert from the Excel JD back to a date"""
        if self.excel_base_date == self.CALENDAR_WINDOWS_1900:
            excel_base_date = 25569
            if value < 60:
                excel_base_date -= 1
            elif value == 60:
                msg = 'Error: Excel believes 1900 was a leap year'
                raise ValueError(msg)
        else:
            raise NotImplementedError('Mac dates are not yet supported.')
            #excel_base_date = 24107

        if value >= 1:
            utc_days = value - excel_base_date

            return EPOCH + datetime.timedelta(days=utc_days)

        elif value >= 0:
            hours = floor(value * 24)
            mins = floor(value * 24 * 60) - floor(hours * 60)
            secs = floor(value * 24 * 60 * 60) - floor(hours * 60 * 60) - \
                    floor(mins * 60)
            return datetime.time(int(hours), int(mins), int(secs))
        else:
            msg = 'Negative dates (%s) are not supported' % value
            raise ValueError(msg)

########NEW FILE########
__FILENAME__ = exc
# file openpyxl/shared/exc.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Definitions for openpyxl shared exception classes."""


class CellCoordinatesException(Exception):
    """Error for converting between numeric and A1-style cell references."""

class ColumnStringIndexException(Exception):
    """Error for bad column names in A1-style cell references."""

class DataTypeException(Exception):
    """Error for any data type inconsistencies."""

class NamedRangeException(Exception):
    """Error for badly formatted named ranges."""

class SheetTitleException(Exception):
    """Error for bad sheet names."""

class InsufficientCoordinatesException(Exception):
    """Error for partially specified cell coordinates."""

class OpenModeError(Exception):
    """Error for fileobj opened in non-binary mode."""

class InvalidFileException(Exception):
    """Error for trying to open a non-ooxml file."""

class ReadOnlyWorkbookException(Exception):
    """Error for trying to modify a read-only workbook"""

class MissingNumberFormat(Exception):
    """Error when a referenced number format is not in the stylesheet"""



########NEW FILE########
__FILENAME__ = ooxml
# file openpyxl/shared/ooxml.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Constants for fixed paths in a file and xml namespace urls."""

MIN_ROW = 0
MIN_COLUMN = 0
MAX_COLUMN = 16384
MAX_ROW = 1048576

# constants
PACKAGE_PROPS = 'docProps'
PACKAGE_XL = 'xl'
PACKAGE_RELS = '_rels'
PACKAGE_THEME = PACKAGE_XL + '/' + 'theme'
PACKAGE_WORKSHEETS = PACKAGE_XL + '/' + 'worksheets'
PACKAGE_DRAWINGS = PACKAGE_XL + '/' + 'drawings'
PACKAGE_CHARTS = PACKAGE_XL + '/' + 'charts'

ARC_CONTENT_TYPES = '[Content_Types].xml'
ARC_ROOT_RELS = PACKAGE_RELS + '/.rels'
ARC_WORKBOOK_RELS = PACKAGE_XL + '/' + PACKAGE_RELS + '/workbook.xml.rels'
ARC_CORE = PACKAGE_PROPS + '/core.xml'
ARC_APP = PACKAGE_PROPS + '/app.xml'
ARC_WORKBOOK = PACKAGE_XL + '/workbook.xml'
ARC_STYLE = PACKAGE_XL + '/styles.xml'
ARC_THEME = PACKAGE_THEME + '/theme1.xml'
ARC_SHARED_STRINGS = PACKAGE_XL + '/sharedStrings.xml'

NAMESPACES = {
    'cp': 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties',
    'dc': 'http://purl.org/dc/elements/1.1/',
    'dcterms': 'http://purl.org/dc/terms/',
    'dcmitype': 'http://purl.org/dc/dcmitype/',
    'xsi': 'http://www.w3.org/2001/XMLSchema-instance',
    'vt': 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes',
    'xml': 'http://www.w3.org/XML/1998/namespace'
}

########NEW FILE########
__FILENAME__ = password_hasher
# file openpyxl/shared/password_hasher.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Basic password hashing."""


def hash_password(plaintext_password=''):
    """Create a password hash from a given string.

    This method is based on the algorithm provided by
    Daniel Rentz of OpenOffice and the PEAR package
    Spreadsheet_Excel_Writer by Xavier Noguer <xnoguer@rezebra.com>.

    """
    password = 0x0000
    i = 1
    for char in plaintext_password:
        value = ord(char) << i
        rotated_bits = value >> 15
        value &= 0x7fff
        password ^= (value | rotated_bits)
        i += 1
    password ^= len(plaintext_password)
    password ^= 0xCE4B
    return str(hex(password)).upper()[2:]

########NEW FILE########
__FILENAME__ = units
# file openpyxl/shared/units.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

import math

def pixels_to_EMU(value):
    return int(round(value * 9525))

def EMU_to_pixels(value):
    if not value:
        return 0
    else:
        return round(value / 9525.) 

def EMU_to_cm(value):
    if not value:
        return 0
    else:
        return (EMU_to_pixels(value) * 2.57 / 96) 

def pixels_to_points(value):
    return value * 0.67777777

def points_to_pixels(value):
    if not value:
        return 0
    else:
        return int(math.ceil(value * 1.333333333)) 

def degrees_to_angle(value):
    return int(round(value * 60000))

def angle_to_degrees(value):
    if not value:
        return 0
    else:
        return round(value / 60000.) 

def short_color(color):
    """ format a color to its short size """

    if len(color) > 6:
        return color[2:]
    else:
        return color

########NEW FILE########
__FILENAME__ = xmltools
# file openpyxl/shared/xmltools.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Shared xml tools.

Shortcut functions taken from:
    http://lethain.com/entry/2009/jan/22/handling-very-large-csv-and-xml-files-in-python/

"""

# Python stdlib imports
from xml.sax.xmlreader import AttributesNSImpl
from xml.sax.saxutils import XMLGenerator
try:
    from xml.etree.ElementTree import ElementTree, Element, SubElement, \
            QName, fromstring, tostring
except ImportError:
    from cElementTree import ElementTree, Element, SubElement, \
            QName, fromstring, tostring

# package imports
from .. import __name__ as prefix


def get_document_content(xml_node):
    """Print nicely formatted xml to a string."""
    pretty_indent(xml_node)
    return tostring(xml_node, 'utf-8')


def pretty_indent(elem, level=0):
    """Format xml with nice indents and line breaks."""
    i = "\n" + level * "  "
    if len(elem):
        if not elem.text or not elem.text.strip():
            elem.text = i + "  "
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
        for elem in elem:
            pretty_indent(elem, level + 1)
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i


def start_tag(doc, name, attr=None, body=None, namespace=None):
    """Wrapper to start an xml tag."""
    if attr is None:
        attr = {}


    # name = bytes(name, 'utf-8')
    
    # if namespace is not None:
        # namespace = bytes(namespace, 'utf-8')


    attr_vals = {}
    attr_keys = {}
    for key, val in attr.items():

            
        # if key is not None:
            # key = bytes(key, 'utf-8')
            
        # if val is not None:
            # val = bytes(val, 'utf-8')
        
        key_tuple = (namespace, key)
        
        attr_vals[key_tuple] = val
        attr_keys[key_tuple] = key
        
    attr2 = AttributesNSImpl(attr_vals, attr_keys)
    doc.startElementNS((namespace, name), name, attr2)
    if body:
        doc.characters(body)


def end_tag(doc, name, namespace=None):
    """Wrapper to close an xml tag."""
    doc.endElementNS((namespace, name), name)


def tag(doc, name, attr=None, body=None, namespace=None):
    """Wrapper to print xml tags and comments."""
    if attr is None:
        attr = {}
    start_tag(doc, name, attr, body, namespace)
    end_tag(doc, name, namespace)

########NEW FILE########
__FILENAME__ = style
# file openpyxl/style.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Style and formatting option tracking."""

# Python stdlib imports
import re
try:
    from hashlib import md5
except ImportError:
    from md5 import md5


class HashableObject(object):
    """Define how to hash property classes."""
    __fields__ = None
    __leaf__ = False

    def __repr__(self):

        return ':'.join([repr(getattr(self, x)) for x in self.__fields__])

    def __hash__(self):

#        return int(md5(repr(self)).hexdigest(), 16)
        return hash(repr(self))

class Color(HashableObject):
    """Named colors for use in styles."""
    BLACK = 'FF000000'
    WHITE = 'FFFFFFFF'
    RED = 'FFFF0000'
    DARKRED = 'FF800000'
    BLUE = 'FF0000FF'
    DARKBLUE = 'FF000080'
    GREEN = 'FF00FF00'
    DARKGREEN = 'FF008000'
    YELLOW = 'FFFFFF00'
    DARKYELLOW = 'FF808000'

    __fields__ = ('index',)
    __slots__ = __fields__
    __leaf__ = True

    def __init__(self, index):
        super(Color, self).__init__()
        self.index = index


class Font(HashableObject):
    """Font options used in styles."""
    UNDERLINE_NONE = 'none'
    UNDERLINE_DOUBLE = 'double'
    UNDERLINE_DOUBLE_ACCOUNTING = 'doubleAccounting'
    UNDERLINE_SINGLE = 'single'
    UNDERLINE_SINGLE_ACCOUNTING = 'singleAccounting'

    __fields__ = ('name',
                  'size',
                  'bold',
                  'italic',
                  'superscript',
                  'subscript',
                  'underline',
                  'strikethrough',
                  'color')
    __slots__ = __fields__

    def __init__(self):
        super(Font, self).__init__()
        self.name = 'Calibri'
        self.size = 11
        self.bold = False
        self.italic = False
        self.superscript = False
        self.subscript = False
        self.underline = self.UNDERLINE_NONE
        self.strikethrough = False
        self.color = Color(Color.BLACK)


class Fill(HashableObject):
    """Area fill patterns for use in styles."""
    FILL_NONE = 'none'
    FILL_SOLID = 'solid'
    FILL_GRADIENT_LINEAR = 'linear'
    FILL_GRADIENT_PATH = 'path'
    FILL_PATTERN_DARKDOWN = 'darkDown'
    FILL_PATTERN_DARKGRAY = 'darkGray'
    FILL_PATTERN_DARKGRID = 'darkGrid'
    FILL_PATTERN_DARKHORIZONTAL = 'darkHorizontal'
    FILL_PATTERN_DARKTRELLIS = 'darkTrellis'
    FILL_PATTERN_DARKUP = 'darkUp'
    FILL_PATTERN_DARKVERTICAL = 'darkVertical'
    FILL_PATTERN_GRAY0625 = 'gray0625'
    FILL_PATTERN_GRAY125 = 'gray125'
    FILL_PATTERN_LIGHTDOWN = 'lightDown'
    FILL_PATTERN_LIGHTGRAY = 'lightGray'
    FILL_PATTERN_LIGHTGRID = 'lightGrid'
    FILL_PATTERN_LIGHTHORIZONTAL = 'lightHorizontal'
    FILL_PATTERN_LIGHTTRELLIS = 'lightTrellis'
    FILL_PATTERN_LIGHTUP = 'lightUp'
    FILL_PATTERN_LIGHTVERTICAL = 'lightVertical'
    FILL_PATTERN_MEDIUMGRAY = 'mediumGray'

    __fields__ = ('fill_type',
                  'rotation',
                  'start_color',
                  'end_color')
    __slots__ = __fields__

    def __init__(self):
        super(Fill, self).__init__()
        self.fill_type = self.FILL_NONE
        self.rotation = 0
        self.start_color = Color(Color.WHITE)
        self.end_color = Color(Color.BLACK)


class Border(HashableObject):
    """Border options for use in styles."""
    BORDER_NONE = 'none'
    BORDER_DASHDOT = 'dashDot'
    BORDER_DASHDOTDOT = 'dashDotDot'
    BORDER_DASHED = 'dashed'
    BORDER_DOTTED = 'dotted'
    BORDER_DOUBLE = 'double'
    BORDER_HAIR = 'hair'
    BORDER_MEDIUM = 'medium'
    BORDER_MEDIUMDASHDOT = 'mediumDashDot'
    BORDER_MEDIUMDASHDOTDOT = 'mediumDashDotDot'
    BORDER_MEDIUMDASHED = 'mediumDashed'
    BORDER_SLANTDASHDOT = 'slantDashDot'
    BORDER_THICK = 'thick'
    BORDER_THIN = 'thin'

    __fields__ = ('border_style',
                  'color')
    __slots__ = __fields__

    def __init__(self):
        super(Border, self).__init__()
        self.border_style = self.BORDER_NONE
        self.color = Color(Color.BLACK)


class Borders(HashableObject):
    """Border positioning for use in styles."""
    DIAGONAL_NONE = 0
    DIAGONAL_UP = 1
    DIAGONAL_DOWN = 2
    DIAGONAL_BOTH = 3

    __fields__ = ('left',
                  'right',
                  'top',
                  'bottom',
                  'diagonal',
                  'diagonal_direction',
                  'all_borders',
                  'outline',
                  'inside',
                  'vertical',
                  'horizontal')
    __slots__ = __fields__

    def __init__(self):
        super(Borders, self).__init__()
        self.left = Border()
        self.right = Border()
        self.top = Border()
        self.bottom = Border()
        self.diagonal = Border()
        self.diagonal_direction = self.DIAGONAL_NONE

        self.all_borders = Border()
        self.outline = Border()
        self.inside = Border()
        self.vertical = Border()
        self.horizontal = Border()


class Alignment(HashableObject):
    """Alignment options for use in styles."""
    HORIZONTAL_GENERAL = 'general'
    HORIZONTAL_LEFT = 'left'
    HORIZONTAL_RIGHT = 'right'
    HORIZONTAL_CENTER = 'center'
    HORIZONTAL_CENTER_CONTINUOUS = 'centerContinuous'
    HORIZONTAL_JUSTIFY = 'justify'
    VERTICAL_BOTTOM = 'bottom'
    VERTICAL_TOP = 'top'
    VERTICAL_CENTER = 'center'
    VERTICAL_JUSTIFY = 'justify'

    __fields__ = ('horizontal',
                  'vertical',
                  'text_rotation',
                  'wrap_text',
                  'shrink_to_fit',
                  'indent')
    __slots__ = __fields__
    __leaf__ = True

    def __init__(self):
        super(Alignment, self).__init__()
        self.horizontal = self.HORIZONTAL_GENERAL
        self.vertical = self.VERTICAL_BOTTOM
        self.text_rotation = 0
        self.wrap_text = False
        self.shrink_to_fit = False
        self.indent = 0


class NumberFormat(HashableObject):
    """Numer formatting for use in styles."""
    FORMAT_GENERAL = 'General'
    FORMAT_TEXT = '@'
    FORMAT_NUMBER = '0'
    FORMAT_NUMBER_00 = '0.00'
    FORMAT_NUMBER_COMMA_SEPARATED1 = '#,##0.00'
    FORMAT_NUMBER_COMMA_SEPARATED2 = '#,##0.00_-'
    FORMAT_PERCENTAGE = '0%'
    FORMAT_PERCENTAGE_00 = '0.00%'
    FORMAT_DATE_YYYYMMDD2 = 'yyyy-mm-dd'
    FORMAT_DATE_YYYYMMDD = 'yy-mm-dd'
    FORMAT_DATE_DDMMYYYY = 'dd/mm/yy'
    FORMAT_DATE_DMYSLASH = 'd/m/y'
    FORMAT_DATE_DMYMINUS = 'd-m-y'
    FORMAT_DATE_DMMINUS = 'd-m'
    FORMAT_DATE_MYMINUS = 'm-y'
    FORMAT_DATE_XLSX14 = 'mm-dd-yy'
    FORMAT_DATE_XLSX15 = 'd-mmm-yy'
    FORMAT_DATE_XLSX16 = 'd-mmm'
    FORMAT_DATE_XLSX17 = 'mmm-yy'
    FORMAT_DATE_XLSX22 = 'm/d/yy h:mm'
    FORMAT_DATE_DATETIME = 'd/m/y h:mm'
    FORMAT_DATE_TIME1 = 'h:mm AM/PM'
    FORMAT_DATE_TIME2 = 'h:mm:ss AM/PM'
    FORMAT_DATE_TIME3 = 'h:mm'
    FORMAT_DATE_TIME4 = 'h:mm:ss'
    FORMAT_DATE_TIME5 = 'mm:ss'
    FORMAT_DATE_TIME6 = 'h:mm:ss'
    FORMAT_DATE_TIME7 = 'i:s.S'
    FORMAT_DATE_TIME8 = 'h:mm:ss@'
    FORMAT_DATE_YYYYMMDDSLASH = 'yy/mm/dd@'
    FORMAT_CURRENCY_USD_SIMPLE = '"$"#,##0.00_-'
    FORMAT_CURRENCY_USD = '$#,##0_-'
    FORMAT_CURRENCY_EUR_SIMPLE = '[$EUR ]#,##0.00_-'
    _BUILTIN_FORMATS = {
        0: 'General',
        1: '0',
        2: '0.00',
        3: '#,##0',
        4: '#,##0.00',

        9: '0%',
        10: '0.00%',
        11: '0.00E+00',
        12: '# ?/?',
        13: '# ??/??',
        14: 'mm-dd-yy',
        15: 'd-mmm-yy',
        16: 'd-mmm',
        17: 'mmm-yy',
        18: 'h:mm AM/PM',
        19: 'h:mm:ss AM/PM',
        20: 'h:mm',
        21: 'h:mm:ss',
        22: 'm/d/yy h:mm',

        37: '#,##0 (#,##0)',
        38: '#,##0 [Red](#,##0)',
        39: '#,##0.00(#,##0.00)',
        40: '#,##0.00[Red](#,##0.00)',

        41: '_(* #,##0_);_(* \(#,##0\);_(* "-"_);_(@_)',
        42: '_("$"* #,##0_);_("$"* \(#,##0\);_("$"* "-"_);_(@_)',
        43: '_(* #,##0.00_);_(* \(#,##0.00\);_(* "-"??_);_(@_)',

        44: '_("$"* #,##0.00_)_("$"* \(#,##0.00\)_("$"* "-"??_)_(@_)',
        45: 'mm:ss',
        46: '[h]:mm:ss',
        47: 'mmss.0',
        48: '##0.0E+0',
        49: '@', }
    _BUILTIN_FORMATS_REVERSE = dict(
            [(value, key) for key, value in _BUILTIN_FORMATS.items()])

    __fields__ = ('_format_code',
                  '_format_index')
    __slots__ = __fields__
    __leaf__ = True

    DATE_INDICATORS = 'dmyhs'

    def __init__(self):
        super(NumberFormat, self).__init__()
        self._format_code = self.FORMAT_GENERAL
        self._format_index = 0

    def _set_format_code(self, format_code = FORMAT_GENERAL):
        """Setter for the format_code property."""
        self._format_code = format_code
        self._format_index = self.builtin_format_id(format = format_code)

    def _get_format_code(self):
        """Getter for the format_code property."""
        return self._format_code

    format_code = property(_get_format_code, _set_format_code)

    def builtin_format_code(self, index):
        """Return one of the standard format codes by index."""
        return self._BUILTIN_FORMATS[index]

    def is_builtin(self, format = None):
        """Check if a format code is a standard format code."""
        if format is None:
            format = self._format_code
        return format in self._BUILTIN_FORMATS.values()

    def builtin_format_id(self, format):
        """Return the id of a standard style."""
        return self._BUILTIN_FORMATS_REVERSE.get(format, None)

    def is_date_format(self, format = None):
        """Check if the number format is actually representing a date."""
        if format is None:
            format = self._format_code

        return any([x in format for x in self.DATE_INDICATORS])

class Protection(HashableObject):
    """Protection options for use in styles."""
    PROTECTION_INHERIT = 'inherit'
    PROTECTION_PROTECTED = 'protected'
    PROTECTION_UNPROTECTED = 'unprotected'

    __fields__ = ('locked',
                  'hidden')
    __slots__ = __fields__
    __leaf__ = True

    def __init__(self):
        super(Protection, self).__init__()
        self.locked = self.PROTECTION_INHERIT
        self.hidden = self.PROTECTION_INHERIT


class Style(HashableObject):
    """Style object containing all formatting details."""
    __fields__ = ('font',
                  'fill',
                  'borders',
                  'alignment',
                  'number_format',
                  'protection')
    __slots__ = __fields__

    def __init__(self):
        super(Style, self).__init__()
        self.font = Font()
        self.fill = Fill()
        self.borders = Borders()
        self.alignment = Alignment()
        self.number_format = NumberFormat()
        self.protection = Protection()

DEFAULTS = Style()

########NEW FILE########
__FILENAME__ = workbook
# file openpyxl/workbook.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Workbook is the top-level container for all document information."""

__docformat__ = "restructuredtext en"

# Python stdlib imports
import datetime
import os

# package imports
from .worksheet import Worksheet
from .writer.dump_worksheet import DumpWorksheet, save_dump
from .writer.strings import StringTableBuilder
from .namedrange import NamedRange
from .style import Style
from .writer.excel import save_workbook
from .shared.exc import ReadOnlyWorkbookException


class DocumentProperties(object):
    """High-level properties of the document."""

    def __init__(self):
        self.creator = 'Unknown'
        self.last_modified_by = self.creator
        self.created = datetime.datetime.now()
        self.modified = datetime.datetime.now()
        self.title = 'Untitled'
        self.subject = ''
        self.description = ''
        self.keywords = ''
        self.category = ''
        self.company = 'Microsoft Corporation'


class DocumentSecurity(object):
    """Security information about the document."""

    def __init__(self):
        self.lock_revision = False
        self.lock_structure = False
        self.lock_windows = False
        self.revision_password = ''
        self.workbook_password = ''


class Workbook(object):
    """Workbook is the container for all other parts of the document."""

    def __init__(self, optimized_write = False):
        self.worksheets = []
        self._active_sheet_index = 0
        self._named_ranges = []
        self.properties = DocumentProperties()
        self.style = Style()
        self.security = DocumentSecurity()
        self.__optimized_write = optimized_write
        self.__optimized_read = False
        self.strings_table_builder = StringTableBuilder()

        if not optimized_write:
            self.worksheets.append(Worksheet(self))

    def _set_optimized_read(self):
        self.__optimized_read = True

    def get_active_sheet(self):
        """Returns the current active sheet."""
        return self.worksheets[self._active_sheet_index]

    def create_sheet(self, index = None):
        """Create a worksheet (at an optional index).

        :param index: optional position at which the sheet will be inserted
        :type index: int

        """

        if self.__optimized_read:
            raise ReadOnlyWorkbookException('Cannot create new sheet in a read-only workbook')

        if self.__optimized_write :
            new_ws = DumpWorksheet(parent_workbook = self)
        else:
            new_ws = Worksheet(parent_workbook = self)

        self.add_sheet(worksheet = new_ws, index = index)
        return new_ws

    def add_sheet(self, worksheet, index = None):
        """Add an existing worksheet (at an optional index)."""
        if index is None:
            index = len(self.worksheets)
        self.worksheets.insert(index, worksheet)

    def remove_sheet(self, worksheet):
        """Remove a worksheet from this workbook."""
        self.worksheets.remove(worksheet)

    def get_sheet_by_name(self, name):
        """Returns a worksheet by its name.

        Returns None if no worksheet has the name specified.

        :param name: the name of the worksheet to look for
        :type name: string

        """
        requested_sheet = None
        for sheet in self.worksheets:
            if sheet.title == name:
                requested_sheet = sheet
                break
        return requested_sheet

    def get_index(self, worksheet):
        """Return the index of the worksheet."""
        return self.worksheets.index(worksheet)

    def get_sheet_names(self):
        """Returns the list of the names of worksheets in the workbook.

        Names are returned in the worksheets order.

        :rtype: list of strings

        """
        return [s.title for s in self.worksheets]

    def create_named_range(self, name, worksheet, range):
        """Create a new named_range on a worksheet"""
        assert isinstance(worksheet, Worksheet)
        named_range = NamedRange(name, [(worksheet, range)])
        self.add_named_range(named_range)

    def get_named_ranges(self):
        """Return all named ranges"""
        return self._named_ranges

    def add_named_range(self, named_range):
        """Add an existing named_range to the list of named_ranges."""
        self._named_ranges.append(named_range)

    def get_named_range(self, name):
        """Return the range specified by name."""
        requested_range = None
        for named_range in self._named_ranges:
            if named_range.name == name:
                requested_range = named_range
                break
        return requested_range

    def remove_named_range(self, named_range):
        """Remove a named_range from this workbook."""
        self._named_ranges.remove(named_range)

    def save(self, filename):
        """ shortcut """
        if self.__optimized_write:
            save_dump(self, filename)
        else:
            save_workbook(self, filename)

########NEW FILE########
__FILENAME__ = worksheet
# file openpyxl/worksheet.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Worksheet is the 2nd-level container in Excel."""

# Python stdlib imports
import re

# package imports
from . import cell
from .cell import coordinate_from_string, \
    column_index_from_string, get_column_letter
from .shared.exc import SheetTitleException, \
    InsufficientCoordinatesException, CellCoordinatesException, \
    NamedRangeException
from .shared.password_hasher import hash_password
from .style import Style, DEFAULTS as DEFAULTS_STYLE
from .drawing import Drawing

_DEFAULTS_STYLE_HASH = hash(DEFAULTS_STYLE)

def flatten(results):

    rows = []

    for row in results:

        cells = []

        for cell in row:

            cells.append(cell.value)

        rows.append(tuple(cells))

    return tuple(rows)


class Relationship(object):
    """Represents many kinds of relationships."""
    # TODO: Use this object for workbook relationships as well as
    # worksheet relationships
    TYPES = {
        'hyperlink': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink',
        'drawing':'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',
        #'worksheet': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',
        #'sharedStrings': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',
        #'styles': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',
        #'theme': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme',
    }

    def __init__(self, rel_type):
        if rel_type not in self.TYPES:
            raise ValueError("Invalid relationship type %s" % rel_type)
        self.type = self.TYPES[rel_type]
        self.target = ""
        self.target_mode = ""
        self.id = ""


class PageSetup(object):
    """Information about page layout for this sheet"""
    pass


class HeaderFooter(object):
    """Information about the header/footer for this sheet."""
    pass


class SheetView(object):
    """Information about the visible portions of this sheet."""
    pass


class RowDimension(object):
    """Information about the display properties of a row."""
    __slots__ = ('row_index',
                 'height',
                 'visible',
                 'outline_level',
                 'collapsed',
                 'style_index',)

    def __init__(self, index = 0):
        self.row_index = index
        self.height = -1
        self.visible = True
        self.outline_level = 0
        self.collapsed = False
        self.style_index = None


class ColumnDimension(object):
    """Information about the display properties of a column."""
    __slots__ = ('column_index',
                 'width',
                 'auto_size',
                 'visible',
                 'outline_level',
                 'collapsed',
                 'style_index',)

    def __init__(self, index = 'A'):
        self.column_index = index
        self.width = -1
        self.auto_size = False
        self.visible = True
        self.outline_level = 0
        self.collapsed = False
        self.style_index = 0


class PageMargins(object):
    """Information about page margins for view/print layouts."""

    def __init__(self):
        self.left = self.right = 0.7
        self.top = self.bottom = 0.75
        self.header = self.footer = 0.3


class SheetProtection(object):
    """Information about protection of various aspects of a sheet."""

    def __init__(self):
        self.sheet = False
        self.objects = False
        self.scenarios = False
        self.format_cells = False
        self.format_columns = False
        self.format_rows = False
        self.insert_columns = False
        self.insert_rows = False
        self.insert_hyperlinks = False
        self.delete_columns = False
        self.delete_rows = False
        self.select_locked_cells = False
        self.sort = False
        self.auto_filter = False
        self.pivot_tables = False
        self.select_unlocked_cells = False
        self._password = ''

    def set_password(self, value = '', already_hashed = False):
        """Set a password on this sheet."""
        if not already_hashed:
            value = hash_password(value)
        self._password = value

    def _set_raw_password(self, value):
        """Set a password directly, forcing a hash step."""
        self.set_password(value, already_hashed = False)

    def _get_raw_password(self):
        """Return the password value, regardless of hash."""
        return self._password

    password = property(_get_raw_password, _set_raw_password,
            'get/set the password (if already hashed, '
            'use set_password() instead)')


class Worksheet(object):
    """Represents a worksheet.

    Do not create worksheets yourself,
    use :func:`openpyxl.workbook.Workbook.create_sheet` instead

    """
    BREAK_NONE = 0
    BREAK_ROW = 1
    BREAK_COLUMN = 2

    SHEETSTATE_VISIBLE = 'visible'
    SHEETSTATE_HIDDEN = 'hidden'
    SHEETSTATE_VERYHIDDEN = 'veryHidden'

    def __init__(self, parent_workbook, title = 'Sheet'):
        self._parent = parent_workbook
        self._title = ''
        if not title:
            self.title = 'Sheet%d' % (1 + len(self._parent.worksheets))
        else:
            self.title = title
        self.row_dimensions = {}
        self.column_dimensions = {}
        self._cells = {}
        self._styles = {}
        self._charts = []
        self.relationships = []
        self.selected_cell = 'A1'
        self.active_cell = 'A1'
        self.sheet_state = self.SHEETSTATE_VISIBLE
        self.page_setup = PageSetup()
        self.page_margins = PageMargins()
        self.header_footer = HeaderFooter()
        self.sheet_view = SheetView()
        self.protection = SheetProtection()
        self.show_gridlines = True
        self.print_gridlines = False
        self.show_summary_below = True
        self.show_summary_right = True
        self.default_row_dimension = RowDimension()
        self.default_column_dimension = ColumnDimension()
        self._auto_filter = None
        self._freeze_panes = None

    def __repr__(self):
        return '<Worksheet "%s">' % self.title

    def garbage_collect(self):
        """Delete cells that are not storing a value."""
        delete_list = [coordinate for coordinate, cell in \
            self._cells.items() if (cell.value in ('', None) and \
            hash(cell.style) == _DEFAULTS_STYLE_HASH)]
        for coordinate in delete_list:
            del self._cells[coordinate]

    def get_cell_collection(self):
        """Return an unordered list of the cells in this worksheet."""
        return self._cells.values()

    def _set_title(self, value):
        """Set a sheet title, ensuring it is valid."""
        bad_title_char_re = re.compile(r'[\\*?:/\[\]]')
        if bad_title_char_re.search(value):
            msg = 'Invalid character found in sheet title'
            raise SheetTitleException(msg)

        # check if sheet_name already exists
        # do this *before* length check
        if self._parent.get_sheet_by_name(value):
            # use name, but append with lowest possible integer
            i = 1
            while self._parent.get_sheet_by_name('%s%d' % (value, i)):
                i += 1
            value = '%s%d' % (value, i)
        if len(value) > 31:
            msg = 'Maximum 31 characters allowed in sheet title'
            raise SheetTitleException(msg)
        self._title = value

    def _get_title(self):
        """Return the title for this sheet."""
        return self._title

    title = property(_get_title, _set_title, doc =
                     'Get or set the title of the worksheet. '
                     'Limited to 31 characters, no special characters.')

    def _set_auto_filter(self, range):
        # Normalize range to a str or None
        if not range:
            range = None
        elif isinstance(range, str):
            range = range.upper()
        else: # Assume a range
            range = range[0][0].address + ':' + range[-1][-1].address
        self._auto_filter = range

    def _get_auto_filter(self):
        return self._auto_filter

    auto_filter = property(_get_auto_filter, _set_auto_filter, doc =
                           'get or set auto filtering on columns')
    def _set_freeze_panes(self, topLeftCell):
        if not topLeftCell:
            topLeftCell = None
        elif isinstance(topLeftCell, str):
            topLeftCell = topLeftCell.upper()
        else: # Assume a cell
            topLeftCell = topLeftCell.address
        if topLeftCell == 'A1':
            topLeftCell = None
        self._freeze_panes = topLeftCell

    def _get_freeze_panes(self):
        return self._freeze_panes

    freeze_panes = property(_get_freeze_panes,_set_freeze_panes, doc =
                           "Get or set frozen panes")

    def cell(self, coordinate = None, row = None, column = None):
        """Returns a cell object based on the given coordinates.

        Usage: cell(coodinate='A15') **or** cell(row=15, column=1)

        If `coordinates` are not given, then row *and* column must be given.

        Cells are kept in a dictionary which is empty at the worksheet
        creation.  Calling `cell` creates the cell in memory when they
        are first accessed, to reduce memory usage.

        :param coordinate: coordinates of the cell (e.g. 'B12')
        :type coordinate: string

        :param row: row index of the cell (e.g. 4)
        :type row: int

        :param column: column index of the cell (e.g. 3)
        :type column: int

        :raise: InsufficientCoordinatesException when coordinate or (row and column) are not given

        :rtype: :class:`openpyxl.cell.Cell`

        """
        if not coordinate:
            if  (row is None or column is None):
                msg = "You have to provide a value either for " \
                        "'coordinate' or for 'row' *and* 'column'"
                raise InsufficientCoordinatesException(msg)
            else:
                coordinate = '%s%s' % (get_column_letter(column + 1), row + 1)
        else:
            coordinate = coordinate.replace('$', '')

        return self._get_cell(coordinate)

    def _get_cell(self, coordinate):

        if not coordinate in self._cells:
            column, row = coordinate_from_string(coordinate)
            new_cell = cell.Cell(self, column, row)
            self._cells[coordinate] = new_cell
            if column not in self.column_dimensions:
                self.column_dimensions[column] = ColumnDimension(column)
            if row not in self.row_dimensions:
                self.row_dimensions[row] = RowDimension(row)
        return self._cells[coordinate]

    def get_highest_row(self):
        """Returns the maximum row index containing data

        :rtype: int
        """
        if self.row_dimensions:
            return max(self.row_dimensions.keys())
        else:
            return 1

    def get_highest_column(self):
        """Get the largest value for column currently stored.

        :rtype: int
        """
        if self.column_dimensions:
            return max([column_index_from_string(column_index)
                            for column_index in self.column_dimensions])
        else:
            return 1

    def calculate_dimension(self):
        """Return the minimum bounding range for all cells containing data."""
        return 'A1:%s%d' % (get_column_letter(self.get_highest_column()),
                            self.get_highest_row())

    def range(self, range_string, row = 0, column = 0):
        """Returns a 2D array of cells, with optional row and column offsets.

        :param range_string: cell range string or `named range` name
        :type range_string: string

        :param row: number of rows to offset
        :type row: int

        :param column: number of columns to offset
        :type column: int

        :rtype: tuples of tuples of :class:`openpyxl.cell.Cell`

        """
        if ':' in range_string:
            # R1C1 range
            result = []
            min_range, max_range = range_string.split(':')
            min_col, min_row = coordinate_from_string(min_range)
            max_col, max_row = coordinate_from_string(max_range)
            if column:
                min_col = get_column_letter(
                        column_index_from_string(min_col) + column)
                max_col = get_column_letter(
                        column_index_from_string(max_col) + column)
            min_col = column_index_from_string(min_col)
            max_col = column_index_from_string(max_col)
            cache_cols = {}
            for col in xrange(min_col, max_col + 1):
                cache_cols[col] = get_column_letter(col)
            rows = xrange(min_row + row, max_row + row + 1)
            cols = xrange(min_col, max_col + 1)
            for row in rows:
                new_row = []
                for col in cols:
                    new_row.append(self.cell('%s%s' % (cache_cols[col], row)))
                result.append(tuple(new_row))
            return tuple(result)
        else:
            try:
                return self.cell(coordinate = range_string, row = row,
                        column = column)
            except CellCoordinatesException:
                pass

            # named range
            named_range = self._parent.get_named_range(range_string)
            if named_range is None:
                msg = '%s is not a valid range name' % range_string
                raise NamedRangeException(msg)

            result = []
            for destination in named_range.destinations:

                worksheet, cells_range = destination

                if worksheet is not self:
                    msg = 'Range %s is not defined on worksheet %s' % \
                            (cells_range, self.title)
                    raise NamedRangeException(msg)

                content = self.range(cells_range)

                if isinstance(content, tuple):
                    for cells in content:
                        result.extend(cells)
                else:
                    result.append(content)

            if len(result) == 1:
                return result[0]
            else:
                return tuple(result)

    def get_style(self, coordinate):
        """Return the style object for the specified cell."""
        if not coordinate in self._styles:
            self._styles[coordinate] = Style()
        return self._styles[coordinate]

    def create_relationship(self, rel_type):
        """Add a relationship for this sheet."""
        rel = Relationship(rel_type)
        self.relationships.append(rel)
        rel_id = self.relationships.index(rel)
        rel.id = 'rId' + str(rel_id + 1)
        return self.relationships[rel_id]

    def add_chart(self, chart):
        """ Add a chart to the sheet """

        chart._sheet = self
        self._charts.append(chart)

    def append(self, list_or_dict):
        """Appends a group of values at the bottom of the current sheet.

        * If it's a list: all values are added in order, starting from the first column
        * If it's a dict: values are assigned to the columns indicated by the keys (numbers or letters)

        :param list_or_dict: list or dict containing values to append
        :type list_or_dict: list/tuple or dict

        Usage:

        * append(['This is A1', 'This is B1', 'This is C1'])
        * **or** append({'A' : 'This is A1', 'C' : 'This is C1'})
        * **or** append({0 : 'This is A1', 2 : 'This is C1'})

        :raise: TypeError when list_or_dict is neither a list/tuple nor a dict

        """

        row_idx = len(self.row_dimensions)

        if isinstance(list_or_dict, (list, tuple)):

            for col_idx, content in enumerate(list_or_dict):

                self.cell(row = row_idx, column = col_idx).value = content

        elif isinstance(list_or_dict, dict):

            for col_idx, content in list_or_dict.items():

                if isinstance(col_idx, basestring):
                    col_idx = column_index_from_string(col_idx) - 1

                self.cell(row = row_idx, column = col_idx).value = content

        else:
            raise TypeError('list_or_dict must be a list or a dict')

    @property
    def rows(self):

        return self.range(self.calculate_dimension())

    @property
    def columns(self):

        max_row = self.get_highest_row()

        cols = []

        for col_idx in range(self.get_highest_column()):
            col = get_column_letter(col_idx+1)
            res = self.range('%s1:%s%d' % (col, col, max_row))
            cols.append(tuple([x[0] for x in res]))


        return tuple(cols)


########NEW FILE########
__FILENAME__ = charts
# coding=UTF-8
'''
Copyright (c) 2010 openpyxl

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license: http://www.opensource.org/licenses/mit-license.php
@author: Eric Gazoni
'''

from ..shared.xmltools import Element, SubElement, get_document_content
from ..chart import Chart, ErrorBar

class ChartWriter(object):

    def __init__(self, chart):
        self.chart = chart

    def write(self):
        """ write a chart """

        root = Element('c:chartSpace',
            {'xmlns:c':"http://schemas.openxmlformats.org/drawingml/2006/chart",
             'xmlns:a':"http://schemas.openxmlformats.org/drawingml/2006/main",
             'xmlns:r':"http://schemas.openxmlformats.org/officeDocument/2006/relationships"})

        SubElement(root, 'c:lang', {'val':self.chart.lang})
        self._write_chart(root)
        self._write_print_settings(root)
        self._write_shapes(root)

        return get_document_content(root)

    def _write_chart(self, root):

        chart = self.chart

        ch = SubElement(root, 'c:chart')
        self._write_title(ch)
        plot_area = SubElement(ch, 'c:plotArea')
        layout = SubElement(plot_area, 'c:layout')
        mlayout = SubElement(layout, 'c:manualLayout')
        SubElement(mlayout, 'c:layoutTarget', {'val':'inner'})
        SubElement(mlayout, 'c:xMode', {'val':'edge'})
        SubElement(mlayout, 'c:yMode', {'val':'edge'})
        SubElement(mlayout, 'c:x', {'val':str(chart._get_margin_left())})
        SubElement(mlayout, 'c:y', {'val':str(chart._get_margin_top())})
        SubElement(mlayout, 'c:w', {'val':str(chart.width)})
        SubElement(mlayout, 'c:h', {'val':str(chart.height)})

        if chart.type == Chart.SCATTER_CHART:
            subchart = SubElement(plot_area, 'c:scatterChart')
            SubElement(subchart, 'c:scatterStyle', {'val':str('lineMarker')})
        else:
            if chart.type == Chart.BAR_CHART:
                subchart = SubElement(plot_area, 'c:barChart')
                SubElement(subchart, 'c:barDir', {'val':'col'})
            else:
                subchart = SubElement(plot_area, 'c:lineChart')

            SubElement(subchart, 'c:grouping', {'val':chart.grouping})

        self._write_series(subchart)

        SubElement(subchart, 'c:marker', {'val':'1'})
        SubElement(subchart, 'c:axId', {'val':str(chart.x_axis.id)})
        SubElement(subchart, 'c:axId', {'val':str(chart.y_axis.id)})

        if chart.type == Chart.SCATTER_CHART:
            self._write_axis(plot_area, chart.x_axis, 'c:valAx')
        else:
            self._write_axis(plot_area, chart.x_axis, 'c:catAx')
        self._write_axis(plot_area, chart.y_axis, 'c:valAx')

        self._write_legend(ch)

        SubElement(ch, 'c:plotVisOnly', {'val':'1'})

    def _write_title(self, chart):
        if self.chart.title != '':
            title = SubElement(chart, 'c:title')
            tx = SubElement(title, 'c:tx')
            rich = SubElement(tx, 'c:rich')
            SubElement(rich, 'a:bodyPr')
            SubElement(rich, 'a:lstStyle')
            p = SubElement(rich, 'a:p')
            pPr = SubElement(p, 'a:pPr')
            SubElement(pPr, 'a:defRPr')
            r = SubElement(p, 'a:r')
            SubElement(r, 'a:rPr', {'lang':self.chart.lang})
            t = SubElement(r, 'a:t').text = self.chart.title
            SubElement(title, 'c:layout')

    def _write_axis(self, plot_area, axis, label):

        ax = SubElement(plot_area, label)
        SubElement(ax, 'c:axId', {'val':str(axis.id)})

        scaling = SubElement(ax, 'c:scaling')
        SubElement(scaling, 'c:orientation', {'val':axis.orientation})
        if label == 'c:valAx':
            SubElement(scaling, 'c:max', {'val':str(axis.max)})
            SubElement(scaling, 'c:min', {'val':str(axis.min)})

        SubElement(ax, 'c:axPos', {'val':axis.position})
        if label == 'c:valAx':
            SubElement(ax, 'c:majorGridlines')
            SubElement(ax, 'c:numFmt', {'formatCode':"General", 'sourceLinked':'1'})
        SubElement(ax, 'c:tickLblPos', {'val':axis.tick_label_position})
        SubElement(ax, 'c:crossAx', {'val':str(axis.cross)})
        SubElement(ax, 'c:crosses', {'val':axis.crosses})
        if axis.auto:
            SubElement(ax, 'c:auto', {'val':'1'})
        if axis.label_align:
            SubElement(ax, 'c:lblAlgn', {'val':axis.label_align})
        if axis.label_offset:
            SubElement(ax, 'c:lblOffset', {'val':str(axis.label_offset)})
        if label == 'c:valAx':
            if self.chart.type == Chart.SCATTER_CHART:
                SubElement(ax, 'c:crossBetween', {'val':'midCat'})
            else:
                SubElement(ax, 'c:crossBetween', {'val':'between'})
            SubElement(ax, 'c:majorUnit', {'val':str(axis.unit)})

    def _write_series(self, subchart):

        for i, serie in enumerate(self.chart._series):
            ser = SubElement(subchart, 'c:ser')
            SubElement(ser, 'c:idx', {'val':str(i)})
            SubElement(ser, 'c:order', {'val':str(i)})

            if serie.legend:
                tx = SubElement(ser, 'c:tx')
                self._write_serial(tx, serie.legend)

            if serie.color:
                sppr = SubElement(ser, 'c:spPr')
                if self.chart.type == Chart.BAR_CHART:
                    # fill color
                    fillc = SubElement(sppr, 'a:solidFill')
                    SubElement(fillc, 'a:srgbClr', {'val':serie.color})
                # edge color
                ln = SubElement(sppr, 'a:ln')
                fill = SubElement(ln, 'a:solidFill')
                SubElement(fill, 'a:srgbClr', {'val':serie.color})

            if serie.error_bar:
                self._write_error_bar(ser, serie)

            marker = SubElement(ser, 'c:marker')
            SubElement(marker, 'c:symbol', {'val':serie.marker})

            if serie.labels:
                cat = SubElement(ser, 'c:cat')
                self._write_serial(cat, serie.labels)

            if self.chart.type == Chart.SCATTER_CHART:
                if serie.xvalues:
                    xval = SubElement(ser, 'c:xVal')
                    self._write_serial(xval, serie.xvalues)

                yval = SubElement(ser, 'c:yVal')
                self._write_serial(yval, serie.values)
            else:
                val = SubElement(ser, 'c:val')
                self._write_serial(val, serie.values)

    def _write_serial(self, node, serie, literal=False):

        cache = serie._get_cache()
        if isinstance(cache[0], basestring):
            typ = 'str'
        else:
            typ = 'num'

        if not literal:
            if typ == 'num':
                ref = SubElement(node, 'c:numRef')
            else:
                ref = SubElement(node, 'c:strRef')
            SubElement(ref, 'c:f').text = serie._get_ref()
            if typ == 'num':
                data = SubElement(ref, 'c:numCache')
            else:
                data = SubElement(ref, 'c:strCache')
        else:
            data = SubElement(node, 'c:numLit')

        if typ == 'num':
            SubElement(data, 'c:formatCode').text = 'General'
        if literal:
            values = (1,)
        else:
            values = cache

        SubElement(data, 'c:ptCount', {'val':str(len(values))})
        for j, val in enumerate(values):
            point = SubElement(data, 'c:pt', {'idx':str(j)})
            SubElement(point, 'c:v').text = str(val)

    def _write_error_bar(self, node, serie):

        flag = {ErrorBar.PLUS_MINUS:'both',
                ErrorBar.PLUS:'plus',
                ErrorBar.MINUS:'minus'}

        eb = SubElement(node, 'c:errBars')
        SubElement(eb, 'c:errBarType', {'val':flag[serie.error_bar.type]})
        SubElement(eb, 'c:errValType', {'val':'cust'})

        plus = SubElement(eb, 'c:plus')
        self._write_serial(plus, serie.error_bar.values,
            literal=(serie.error_bar.type==ErrorBar.MINUS))

        minus = SubElement(eb, 'c:minus')
        self._write_serial(minus, serie.error_bar.values,
            literal=(serie.error_bar.type==ErrorBar.PLUS))

    def _write_legend(self, chart):

        legend = SubElement(chart, 'c:legend')
        SubElement(legend, 'c:legendPos', {'val':self.chart.legend.position})
        SubElement(legend, 'c:layout')

    def _write_print_settings(self, root):

        settings = SubElement(root, 'c:printSettings')
        SubElement(settings, 'c:headerFooter')
        margins = dict([(k, str(v)) for (k,v) in self.chart.print_margins.items()])
        SubElement(settings, 'c:pageMargins', margins)
        SubElement(settings, 'c:pageSetup')

    def _write_shapes(self, root):

        if self.chart._shapes:
            SubElement(root, 'c:userShapes', {'r:id':'rId1'})

    def write_rels(self, drawing_id):

        root = Element('Relationships', {'xmlns' : 'http://schemas.openxmlformats.org/package/2006/relationships'})
        attrs = {'Id' : 'rId1',
            'Type' : 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartUserShapes',
            'Target' : '../drawings/drawing%s.xml' % drawing_id }
        SubElement(root, 'Relationship', attrs)
        return get_document_content(root)

########NEW FILE########
__FILENAME__ = drawings
# coding=UTF-8
'''
Copyright (c) 2010 openpyxl

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license: http://www.opensource.org/licenses/mit-license.php
@author: Eric Gazoni
'''

from ..shared.xmltools import Element, SubElement, get_document_content


class DrawingWriter(object):
    """ one main drawing file per sheet """

    def __init__(self, sheet):
        self._sheet = sheet

    def write(self):
        """ write drawings for one sheet in one file """

        root = Element('xdr:wsDr',
            {'xmlns:xdr' : "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing",
            'xmlns:a' : "http://schemas.openxmlformats.org/drawingml/2006/main"})

        for i, chart in enumerate(self._sheet._charts):

            drawing = chart.drawing

#            anchor = SubElement(root, 'xdr:twoCellAnchor')
#            (start_row, start_col), (end_row, end_col) = drawing.coordinates
#            # anchor coordinates
#            _from = SubElement(anchor, 'xdr:from')
#            x = SubElement(_from, 'xdr:col').text = str(start_col)
#            x = SubElement(_from, 'xdr:colOff').text = '0'
#            x = SubElement(_from, 'xdr:row').text = str(start_row)
#            x = SubElement(_from, 'xdr:rowOff').text = '0'

#            _to = SubElement(anchor, 'xdr:to')
#            x = SubElement(_to, 'xdr:col').text = str(end_col)
#            x = SubElement(_to, 'xdr:colOff').text = '0'
#            x = SubElement(_to, 'xdr:row').text = str(end_row)
#            x = SubElement(_to, 'xdr:rowOff').text = '0'

            # we only support absolute anchor atm (TODO: oneCellAnchor, twoCellAnchor
            x, y, w, h = drawing.get_emu_dimensions()
            anchor = SubElement(root, 'xdr:absoluteAnchor')
            SubElement(anchor, 'xdr:pos', {'x':str(x), 'y':str(y)})
            SubElement(anchor, 'xdr:ext', {'cx':str(w), 'cy':str(h)})

            # graph frame
            frame = SubElement(anchor, 'xdr:graphicFrame', {'macro':''})

            name = SubElement(frame, 'xdr:nvGraphicFramePr')
            SubElement(name, 'xdr:cNvPr', {'id':'%s' % i, 'name':'Graphique %s' % i})
            SubElement(name, 'xdr:cNvGraphicFramePr')

            frm = SubElement(frame, 'xdr:xfrm')
            # no transformation
            SubElement(frm, 'a:off', {'x':'0', 'y':'0'})
            SubElement(frm, 'a:ext', {'cx':'0', 'cy':'0'})

            graph = SubElement(frame, 'a:graphic')
            data = SubElement(graph, 'a:graphicData',
                {'uri':'http://schemas.openxmlformats.org/drawingml/2006/chart'})
            SubElement(data, 'c:chart',
                {   'xmlns:c':'http://schemas.openxmlformats.org/drawingml/2006/chart',
                    'xmlns:r':'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
                    'r:id':'rId%s' % (i + 1)})

            SubElement(anchor, 'xdr:clientData')

        return get_document_content(root)

    def write_rels(self, chart_id):

        root = Element('Relationships',
            {'xmlns' : 'http://schemas.openxmlformats.org/package/2006/relationships'})
        for i, chart in enumerate(self._sheet._charts):
            attrs = {'Id' : 'rId%s' % (i + 1),
                'Type' : 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart',
                'Target' : '../charts/chart%s.xml' % (chart_id + i) }
            SubElement(root, 'Relationship', attrs)
        return get_document_content(root)

class ShapeWriter(object):
    """ one file per shape """

    schema = "http://schemas.openxmlformats.org/drawingml/2006/main"

    def __init__(self, shapes):

        self._shapes = shapes

    def write(self, shape_id):

        root = Element('c:userShapes', {'xmlns:c' : 'http://schemas.openxmlformats.org/drawingml/2006/chart'})

        for shape in self._shapes:
            anchor = SubElement(root, 'cdr:relSizeAnchor',
                {'xmlns:cdr' : "http://schemas.openxmlformats.org/drawingml/2006/chartDrawing"})

            xstart, ystart, xend, yend = shape.get_coordinates()

            _from = SubElement(anchor, 'cdr:from')
            SubElement(_from, 'cdr:x').text = str(xstart)
            SubElement(_from, 'cdr:y').text = str(ystart)

            _to = SubElement(anchor, 'cdr:to')
            SubElement(_to, 'cdr:x').text = str(xend)
            SubElement(_to, 'cdr:y').text = str(yend)

            sp = SubElement(anchor, 'cdr:sp', {'macro':'', 'textlink':''})
            nvspr = SubElement(sp, 'cdr:nvSpPr')
            SubElement(nvspr, 'cdr:cNvPr', {'id':str(shape_id), 'name':'shape %s' % shape_id})
            SubElement(nvspr, 'cdr:cNvSpPr')

            sppr = SubElement(sp, 'cdr:spPr')
            frm = SubElement(sppr, 'a:xfrm', {'xmlns:a':self.schema})
            # no transformation
            SubElement(frm, 'a:off', {'x':'0', 'y':'0'})
            SubElement(frm, 'a:ext', {'cx':'0', 'cy':'0'})

            prstgeom = SubElement(sppr, 'a:prstGeom', {'xmlns:a':self.schema, 'prst':str(shape.style)})
            SubElement(prstgeom, 'a:avLst')

            fill = SubElement(sppr, 'a:solidFill', {'xmlns:a':self.schema})
            SubElement(fill, 'a:srgbClr', {'val':shape.color})

            border = SubElement(sppr, 'a:ln', {'xmlns:a':self.schema, 'w':str(shape._border_width)})
            sf = SubElement(border, 'a:solidFill')
            SubElement(sf, 'a:srgbClr', {'val':shape.border_color})

            self._write_style(sp)
            self._write_text(sp, shape)

            shape_id += 1

        return get_document_content(root)

    def _write_text(self, node, shape):
        """ write text in the shape """

        tx_body = SubElement(node, 'cdr:txBody')
        SubElement(tx_body, 'a:bodyPr', {'xmlns:a':self.schema, 'vertOverflow':'clip'})
        SubElement(tx_body, 'a:lstStyle',
            {'xmlns:a':self.schema})
        p = SubElement(tx_body, 'a:p', {'xmlns:a':self.schema})
        if shape.text:
            r = SubElement(p, 'a:r')
            rpr = SubElement(r, 'a:rPr', {'lang':'en-US'})
            fill = SubElement(rpr, 'a:solidFill')
            SubElement(fill, 'a:srgbClr', {'val':shape.text_color})

            SubElement(r, 'a:t').text = shape.text
        else:
            SubElement(p, 'a:endParaRPr', {'lang':'en-US'})

    def _write_style(self, node):
        """ write style theme """

        style = SubElement(node, 'cdr:style')

        ln_ref = SubElement(style, 'a:lnRef', {'xmlns:a':self.schema, 'idx':'2'})
        scheme_clr = SubElement(ln_ref, 'a:schemeClr', {'val':'accent1'})
        SubElement(scheme_clr, 'a:shade', {'val':'50000'})

        fill_ref = SubElement(style, 'a:fillRef', {'xmlns:a':self.schema, 'idx':'1'})
        SubElement(fill_ref, 'a:schemeClr', {'val':'accent1'})

        effect_ref = SubElement(style, 'a:effectRef', {'xmlns:a':self.schema, 'idx':'0'})
        SubElement(effect_ref, 'a:schemeClr', {'val':'accent1'})

        font_ref = SubElement(style, 'a:fontRef', {'xmlns:a':self.schema, 'idx':'minor'})
        SubElement(font_ref, 'a:schemeClr', {'val':'lt1'})

########NEW FILE########
__FILENAME__ = dump_worksheet
# file openpyxl/writer/straight_worksheet.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Write worksheets to xml representations in an optimized way"""

import datetime
import os

from ..cell import column_index_from_string, get_column_letter, Cell
from ..worksheet import Worksheet
from ..shared.xmltools import XMLGenerator, get_document_content, \
        start_tag, end_tag, tag
from ..shared.date_time import SharedDate
from ..shared.ooxml import MAX_COLUMN, MAX_ROW
from tempfile import NamedTemporaryFile
from ..writer.excel import ExcelWriter
from ..writer.strings import write_string_table
from ..writer.styles import StyleWriter
from ..style import Style, NumberFormat

from ..shared.ooxml import ARC_SHARED_STRINGS, ARC_CONTENT_TYPES, \
        ARC_ROOT_RELS, ARC_WORKBOOK_RELS, ARC_APP, ARC_CORE, ARC_THEME, \
        ARC_STYLE, ARC_WORKBOOK, \
        PACKAGE_WORKSHEETS, PACKAGE_DRAWINGS, PACKAGE_CHARTS

STYLES = {'datetime' : {'type':Cell.TYPE_NUMERIC,
                        'style':'1'},
          'string':{'type':Cell.TYPE_STRING,
                    'style':'0'},
          'numeric':{'type':Cell.TYPE_NUMERIC,
                     'style':'0'},
          'formula':{'type':Cell.TYPE_FORMULA,
                    'style':'0'},
          'boolean':{'type':Cell.TYPE_BOOL,
                    'style':'0'},
        }

DATETIME_STYLE = Style()
DATETIME_STYLE.number_format.format_code = NumberFormat.FORMAT_DATE_YYYYMMDD2
BOUNDING_BOX_PLACEHOLDER = 'A1:%s%d' % (get_column_letter(MAX_COLUMN), MAX_ROW)

class DumpWorksheet(Worksheet):

    """
    .. warning::

        You shouldn't initialize this yourself, use :class:`openpyxl.workbook.Workbook` constructor instead,
        with `optimized_write = True`.
    """

    def __init__(self, parent_workbook):

        Worksheet.__init__(self, parent_workbook)

        self._max_col = 0
        self._max_row = 0
        self._parent = parent_workbook
        self._fileobj_header = NamedTemporaryFile(mode='r+', prefix='openpyxl.', suffix='.header', delete=False)
        self._fileobj_content = NamedTemporaryFile(mode='r+', prefix='openpyxl.', suffix='.content', delete=False)
        self._fileobj = NamedTemporaryFile(mode='w', prefix='openpyxl.', delete=False)
        self.doc = XMLGenerator(self._fileobj_content, 'utf-8')
        self.header = XMLGenerator(self._fileobj_header, 'utf-8')
        self.title = 'Sheet'

        self._shared_date = SharedDate()
        self._string_builder = self._parent.strings_table_builder

    @property
    def filename(self):
        return self._fileobj.name

    def write_header(self):

        doc = self.header

        start_tag(doc, 'worksheet',
                {'xml:space': 'preserve',
                'xmlns': 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
                'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'})
        start_tag(doc, 'sheetPr')
        tag(doc, 'outlinePr',
                {'summaryBelow': '1',
                'summaryRight': '1'})
        end_tag(doc, 'sheetPr')
        tag(doc, 'dimension', {'ref': 'A1:%s' % (self.get_dimensions())})
        start_tag(doc, 'sheetViews')
        start_tag(doc, 'sheetView', {'workbookViewId': '0'})
        tag(doc, 'selection', {'activeCell': 'A1',
                'sqref': 'A1'})
        end_tag(doc, 'sheetView')
        end_tag(doc, 'sheetViews')
        tag(doc, 'sheetFormatPr', {'defaultRowHeight': '15'})
        start_tag(doc, 'sheetData')

    def close(self):

        self._close_content()
        self._close_header()

        self._write_fileobj(self._fileobj_header)
        self._write_fileobj(self._fileobj_content)

        self._fileobj.close()

    def _write_fileobj(self, fobj):

        fobj.flush()
        fobj.seek(0)

        while True:
            chunk = fobj.read(4096)
            if not chunk:
                break
            self._fileobj.write(chunk)

        fobj.close()
        os.remove(fobj.name)

        self._fileobj.flush()

    def _close_header(self):

        doc = self.header
        #doc.endDocument()

    def _close_content(self):

        doc = self.doc
        end_tag(doc, 'sheetData')

        end_tag(doc, 'worksheet')
        #doc.endDocument()

    def get_dimensions(self):

        if not self._max_col or not self._max_row:
            return 'A1'
        else:
            return '%s%d' % (get_column_letter(self._max_col), (self._max_row))

    def append(self, row):

        """
        :param row: iterable containing values to append
        :type row: iterable
        """

        doc = self.doc

        self._max_row += 1
        span = len(row)
        self._max_col = max(self._max_col, span)

        row_idx = self._max_row

        attrs = {'r': '%d' % row_idx,
                 'spans': '1:%d' % span}

        start_tag(doc, 'row', attrs)

        for col_idx, cell in enumerate(row):

            if cell is None:
                continue

            coordinate = '%s%d' % (get_column_letter(col_idx+1), row_idx)
            attributes = {'r': coordinate}

            if isinstance(cell, bool):
                dtype = 'boolean'
            elif isinstance(cell, (int, float)):
                dtype = 'numeric'
            elif isinstance(cell, (datetime.datetime, datetime.date)):
                dtype = 'datetime'
                cell = self._shared_date.datetime_to_julian(cell)
                attributes['s'] = STYLES[dtype]['style']
            elif cell and cell[0] == '=':
                dtype = 'formula'
            else:
                dtype = 'string'
                cell = self._string_builder.add(cell)

            attributes['t'] = STYLES[dtype]['type']

            start_tag(doc, 'c', attributes)

            if dtype == 'formula':
                tag(doc, 'f', body = '%s' % cell[1:])
                tag(doc, 'v')
            else:
                tag(doc, 'v', body = '%s' % cell)

            end_tag(doc, 'c')


        end_tag(doc, 'row')


def save_dump(workbook, filename):

    writer = ExcelDumpWriter(workbook)
    writer.save(filename)
    return True

class ExcelDumpWriter(ExcelWriter):

    def __init__(self, workbook):

        self.workbook = workbook
        self.style_writer = StyleDumpWriter(workbook)
        self.style_writer._style_list.append(DATETIME_STYLE)

    def _write_string_table(self, archive):

        shared_string_table = self.workbook.strings_table_builder.get_table()
        archive.writestr(ARC_SHARED_STRINGS,
                write_string_table(shared_string_table))

        return shared_string_table

    def _write_worksheets(self, archive, shared_string_table, style_writer):

        for i, sheet in enumerate(self.workbook.worksheets):
            sheet.write_header()
            sheet.close()
            archive.write(sheet.filename, PACKAGE_WORKSHEETS + '/sheet%d.xml' % (i + 1))
            os.remove(sheet.filename)


class StyleDumpWriter(StyleWriter):

    def _get_style_list(self, workbook):
        return []


########NEW FILE########
__FILENAME__ = excel
# file openpyxl/writer/excel.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Write a .xlsx file."""

# Python stdlib imports
from zipfile import ZipFile, ZIP_DEFLATED
from ....compat import BytesIO as StringIO

# package imports
from ..shared.ooxml import ARC_SHARED_STRINGS, ARC_CONTENT_TYPES, \
        ARC_ROOT_RELS, ARC_WORKBOOK_RELS, ARC_APP, ARC_CORE, ARC_THEME, \
        ARC_STYLE, ARC_WORKBOOK, \
        PACKAGE_WORKSHEETS, PACKAGE_DRAWINGS, PACKAGE_CHARTS
from ..writer.strings import create_string_table, write_string_table
from ..writer.workbook import write_content_types, write_root_rels, \
        write_workbook_rels, write_properties_app, write_properties_core, \
        write_workbook
from ..writer.theme import write_theme
from ..writer.styles import StyleWriter
from ..writer.drawings import DrawingWriter, ShapeWriter
from ..writer.charts import ChartWriter
from ..writer.worksheet import write_worksheet, write_worksheet_rels


class ExcelWriter(object):
    """Write a workbook object to an Excel file."""

    def __init__(self, workbook):
        self.workbook = workbook
        self.style_writer = StyleWriter(self.workbook)

    def write_data(self, archive):
        """Write the various xml files into the zip archive."""
        # cleanup all worksheets
        shared_string_table = self._write_string_table(archive)

        archive.writestr(ARC_CONTENT_TYPES, write_content_types(self.workbook))
        archive.writestr(ARC_ROOT_RELS, write_root_rels(self.workbook))
        archive.writestr(ARC_WORKBOOK_RELS, write_workbook_rels(self.workbook))
        archive.writestr(ARC_APP, write_properties_app(self.workbook))
        archive.writestr(ARC_CORE,
                write_properties_core(self.workbook.properties))
        archive.writestr(ARC_THEME, write_theme())
        archive.writestr(ARC_STYLE, self.style_writer.write_table())
        archive.writestr(ARC_WORKBOOK, write_workbook(self.workbook))

        self._write_worksheets(archive, shared_string_table, self.style_writer)

    def _write_string_table(self, archive):

        for ws in self.workbook.worksheets:
            ws.garbage_collect()
        shared_string_table = create_string_table(self.workbook)

            
        archive.writestr(ARC_SHARED_STRINGS,
                write_string_table(shared_string_table))

        for k, v in shared_string_table.items():
            shared_string_table[k] = bytes(v)
            
        return shared_string_table

    def _write_worksheets(self, archive, shared_string_table, style_writer):

        drawing_id = 1
        chart_id = 1
        shape_id = 1

        for i, sheet in enumerate(self.workbook.worksheets):
            archive.writestr(PACKAGE_WORKSHEETS + '/sheet%d.xml' % (i + 1),
                    write_worksheet(sheet, shared_string_table,
                            style_writer.get_style_by_hash()))
            if sheet._charts or sheet.relationships:
                archive.writestr(PACKAGE_WORKSHEETS +
                        '/_rels/sheet%d.xml.rels' % (i + 1),
                        write_worksheet_rels(sheet, drawing_id))
            if sheet._charts:
                dw = DrawingWriter(sheet)
                archive.writestr(PACKAGE_DRAWINGS + '/drawing%d.xml' % drawing_id,
                    dw.write())
                archive.writestr(PACKAGE_DRAWINGS + '/_rels/drawing%d.xml.rels' % drawing_id,
                    dw.write_rels(chart_id))
                drawing_id += 1

                for chart in sheet._charts:
                    cw = ChartWriter(chart)
                    archive.writestr(PACKAGE_CHARTS + '/chart%d.xml' % chart_id,
                        cw.write())

                    if chart._shapes:
                        archive.writestr(PACKAGE_CHARTS + '/_rels/chart%d.xml.rels' % chart_id,
                            cw.write_rels(drawing_id))
                        sw = ShapeWriter(chart._shapes)
                        archive.writestr(PACKAGE_DRAWINGS + '/drawing%d.xml' % drawing_id,
                            sw.write(shape_id))
                        shape_id += len(chart._shapes)
                        drawing_id += 1

                    chart_id += 1


    def save(self, filename):
        """Write data into the archive."""
        archive = ZipFile(filename, 'w', ZIP_DEFLATED)
        self.write_data(archive)
        archive.close()


def save_workbook(workbook, filename):
    """Save the given workbook on the filesystem under the name filename.

    :param workbook: the workbook to save
    :type workbook: :class:`openpyxl.workbook.Workbook`

    :param filename: the path to which save the workbook
    :type filename: string

    :rtype: bool

    """
    writer = ExcelWriter(workbook)
    writer.save(filename)
    return True


def save_virtual_workbook(workbook):
    """Return an in-memory workbook, suitable for a Django response."""
    writer = ExcelWriter(workbook)
    temp_buffer = StringIO()
    try:
        archive = ZipFile(temp_buffer, 'w', ZIP_DEFLATED)
        writer.write_data(archive)
    finally:
        archive.close()
    virtual_workbook = temp_buffer.getvalue()
    temp_buffer.close()
    return virtual_workbook

########NEW FILE########
__FILENAME__ = strings
# file openpyxl/writer/strings.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Write the shared string table."""

# Python stdlib imports
from ....compat import BytesIO as StringIO

# package imports
from ..shared.xmltools import start_tag, end_tag, tag, XMLGenerator


def create_string_table(workbook):
    """Compile the string table for a workbook."""
    strings = set()
    for sheet in workbook.worksheets:
        for cell in sheet.get_cell_collection():
            if cell.data_type == cell.TYPE_STRING and cell._value is not None:
                strings.add(cell.value)
    return dict((key, i) for i, key in enumerate(strings))


def write_string_table(string_table):
    """Write the string table xml."""
    temp_buffer = StringIO()
    doc = XMLGenerator(temp_buffer, 'utf-8')
    start_tag(doc, 'sst', {'xmlns':
            'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
            'uniqueCount': '%d' % len(string_table)})
    strings_to_write = sorted(string_table.items(),
            key=lambda pair: pair[1])
    for key in [pair[0] for pair in strings_to_write]:
        start_tag(doc, 'si')
        if key.strip() != key:
            attr = {'xml:space': 'preserve'}
        else:
            attr = {}
        tag(doc, 't', attr, key)
        end_tag(doc, 'si')
    end_tag(doc, 'sst')
    string_table_xml = temp_buffer.getvalue()
    temp_buffer.close()
    return string_table_xml

class StringTableBuilder(object):

    def __init__(self):

        self.counter = 0
        self.dct = {}

    def add(self, key):

        key = key.strip()
        try:
            return self.dct[key]
        except KeyError:
            res = self.dct[key] = self.counter
            self.counter += 1
            return res

    def get_table(self):

        return self.dct

########NEW FILE########
__FILENAME__ = styles
# file openpyxl/writer/styles.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Write the shared style table."""

# package imports
from ..shared.xmltools import Element, SubElement
from ..shared.xmltools import get_document_content
from .. import style

class StyleWriter(object):

    def __init__(self, workbook):
        self._style_list = self._get_style_list(workbook)
        self._root = Element('styleSheet',
            {'xmlns':'http://schemas.openxmlformats.org/spreadsheetml/2006/main'})

    def _get_style_list(self, workbook):
        crc = {}
        for worksheet in workbook.worksheets:
            for style in worksheet._styles.values():
                crc[hash(style)] = style
        self.style_table = dict([(style, i+1) \
            for i, style in enumerate(crc.values())])
        sorted_styles = sorted(self.style_table.items(), \
            key = lambda pair:pair[1])
        return [s[0] for s in sorted_styles]

    def get_style_by_hash(self):
        return dict([(hash(style), id) \
            for style, id in self.style_table.items()])

    def write_table(self):
        number_format_table = self._write_number_formats()
        fonts_table = self._write_fonts()
        fills_table = self._write_fills()
        borders_table = self._write_borders()
        self._write_cell_style_xfs()
        self._write_cell_xfs(number_format_table, fonts_table, fills_table, borders_table)
        self._write_cell_style()
        self._write_dxfs()
        self._write_table_styles()

        return get_document_content(xml_node=self._root)

    def _write_fonts(self):
        """ add fonts part to root
            return {font.crc => index}
        """

        fonts = SubElement(self._root, 'fonts')

        # default
        font_node = SubElement(fonts, 'font')
        SubElement(font_node, 'sz', {'val':'11'})
        SubElement(font_node, 'color', {'theme':'1'})
        SubElement(font_node, 'name', {'val':'Calibri'})
        SubElement(font_node, 'family', {'val':'2'})
        SubElement(font_node, 'scheme', {'val':'minor'})

        # others
        table = {}
        index = 1
        for st in self._style_list:
            if hash(st.font) != hash(style.DEFAULTS.font) and hash(st.font) not in table:
                table[hash(st.font)] = str(index)
                font_node = SubElement(fonts, 'font')
                SubElement(font_node, 'sz', {'val':str(st.font.size)})
                SubElement(font_node, 'color', {'rgb':str(st.font.color.index)})
                SubElement(font_node, 'name', {'val':st.font.name})
                SubElement(font_node, 'family', {'val':'2'})
                SubElement(font_node, 'scheme', {'val':'minor'})
                if st.font.bold:
                    SubElement(font_node, 'b')
                if st.font.italic:
                    SubElement(font_node, 'i')
                index += 1

        fonts.attrib["count"] = str(index)
        return table

    def _write_fills(self):
        fills = SubElement(self._root, 'fills', {'count':'2'})
        fill = SubElement(fills, 'fill')
        SubElement(fill, 'patternFill', {'patternType':'none'})
        fill = SubElement(fills, 'fill')
        SubElement(fill, 'patternFill', {'patternType':'gray125'})

        table = {}
        index = 2
        for st in self._style_list:
            if hash(st.fill) != hash(style.DEFAULTS.fill) and hash(st.fill) not in table:
                table[hash(st.fill)] = str(index)
                fill = SubElement(fills, 'fill')
                if hash(st.fill.fill_type) != hash(style.DEFAULTS.fill.fill_type):
                    node = SubElement(fill,'patternFill', {'patternType':st.fill.fill_type})
                    if hash(st.fill.start_color) != hash(style.DEFAULTS.fill.start_color):

                        SubElement(node, 'fgColor', {'rgb':str(st.fill.start_color.index)})
                    if hash(st.fill.end_color) != hash(style.DEFAULTS.fill.end_color):
                        SubElement(node, 'bgColor', {'rgb':str(st.fill.start_color.index)})
                index += 1

        fills.attrib["count"] = str(index)
        return table

    def _write_borders(self):
        borders = SubElement(self._root, 'borders')

        # default
        border = SubElement(borders, 'border')
        SubElement(border, 'left')
        SubElement(border, 'right')
        SubElement(border, 'top')
        SubElement(border, 'bottom')
        SubElement(border, 'diagonal')

        # others
        table = {}
        index = 1
        for st in self._style_list:
            if hash(st.borders) != hash(style.DEFAULTS.borders) and hash(st.borders) not in table:
                table[hash(st.borders)] = str(index)
                border = SubElement(borders, 'border')
                # caution: respect this order
                for side in ('left','right','top','bottom','diagonal'):
                    obj = getattr(st.borders, side)
                    node = SubElement(border, side, {'style':obj.border_style})
                    SubElement(node, 'color', {'rgb':str(obj.color.index)})
                index += 1

        borders.attrib["count"] = str(index)
        return table

    def _write_cell_style_xfs(self):
        cell_style_xfs = SubElement(self._root, 'cellStyleXfs', {'count':'1'})
        xf = SubElement(cell_style_xfs, 'xf',
            {'numFmtId':"0", 'fontId':"0", 'fillId':"0", 'borderId':"0"})

    def _write_cell_xfs(self, number_format_table, fonts_table, fills_table, borders_table):
        """ write styles combinations based on ids found in tables """

        # writing the cellXfs
        cell_xfs = SubElement(self._root, 'cellXfs',
            {'count':'%d' % (len(self._style_list) + 1)})

        # default
        def _get_default_vals():
            return dict(numFmtId='0', fontId='0', fillId='0',
                xfId='0', borderId='0')

        SubElement(cell_xfs, 'xf', _get_default_vals())

        for st in self._style_list:
            vals = _get_default_vals()

            if hash(st.font) != hash(style.DEFAULTS.font):
                vals['fontId'] = fonts_table[hash(st.font)]
                vals['applyFont'] = '1'

            if hash(st.borders) != hash(style.DEFAULTS.borders):
                vals['borderId'] = borders_table[hash(st.borders)]
                vals['applyBorder'] = '1'

            if hash(st.fill) != hash(style.DEFAULTS.fill):
                vals['fillId'] = fills_table[hash(st.fill)]
                vals['applyFillId'] = '1'

            if st.number_format != style.DEFAULTS.number_format:
                vals['numFmtId'] = '%d' % number_format_table[st.number_format]
                vals['applyNumberFormat'] = '1'

            if hash(st.alignment) != hash(style.DEFAULTS.alignment):
                vals['applyAlignment'] = '1'

            node = SubElement(cell_xfs, 'xf', vals)

            if hash(st.alignment) != hash(style.DEFAULTS.alignment):
                alignments = {}

                for align_attr in ['horizontal','vertical']:
                    if hash(getattr(st.alignment, align_attr)) != hash(getattr(style.DEFAULTS.alignment, align_attr)):
                        alignments[align_attr] = getattr(st.alignment, align_attr)

                SubElement(node, 'alignment', alignments)


    def _write_cell_style(self):
        cell_styles = SubElement(self._root, 'cellStyles', {'count':'1'})
        cell_style = SubElement(cell_styles, 'cellStyle',
            {'name':"Normal", 'xfId':"0", 'builtinId':"0"})

    def _write_dxfs(self):
        dxfs = SubElement(self._root, 'dxfs', {'count':'0'})

    def _write_table_styles(self):

        table_styles = SubElement(self._root, 'tableStyles',
            {'count':'0', 'defaultTableStyle':'TableStyleMedium9',
            'defaultPivotStyle':'PivotStyleLight16'})

    def _write_number_formats(self):

        number_format_table = {}

        number_format_list = []
        exceptions_list = []
        num_fmt_id = 165 # start at a greatly higher value as any builtin can go
        num_fmt_offset = 0

        for style in self._style_list:

            if not style.number_format in number_format_list  :
                number_format_list.append(style.number_format)

        for number_format in number_format_list:

            if number_format.is_builtin():
                btin = number_format.builtin_format_id(number_format.format_code)
                number_format_table[number_format] = btin
            else:
                number_format_table[number_format] = num_fmt_id + num_fmt_offset
                num_fmt_offset += 1
                exceptions_list.append(number_format)

        num_fmts = SubElement(self._root, 'numFmts',
            {'count':'%d' % len(exceptions_list)})

        for number_format in exceptions_list :
            SubElement(num_fmts, 'numFmt',
                {'numFmtId':'%d' % number_format_table[number_format],
                'formatCode':'%s' % number_format.format_code})

        return number_format_table

########NEW FILE########
__FILENAME__ = theme
# -*- coding: utf-8 -*-
# file openpyxl/writer/theme.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Write the theme xml based on a fixed string."""

# package imports
from ..shared.xmltools import fromstring, get_document_content


def write_theme():
    """Write the theme xml."""
    xml_node = fromstring(
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n'

            '<a:theme xmlns:a="http://schemas.openxmlformats.org/'
                'drawingml/2006/main" name="Office Theme">'
            '<a:themeElements>'

            '<a:clrScheme name="Office">'
            '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>'
            '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>'
            '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>'
            '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>'
            '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>'
            '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>'
            '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>'
            '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>'
            '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>'
            '<a:accent6><a:srgbClr val="F79646"/></a:accent6>'
            '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>'
            '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>'
            '</a:clrScheme>'

            '<a:fontScheme name="Office">'
            '<a:majorFont>'
            '<a:latin typeface="Cambria"/>'
            '<a:ea typeface=""/>'
            '<a:cs typeface=""/>'
            '<a:font script="Jpan" typeface=" "/>'
            '<a:font script="Hang" typeface=" "/>'
            '<a:font script="Hans" typeface=""/>'
            '<a:font script="Hant" typeface=""/>'
            '<a:font script="Arab" typeface="Times New Roman"/>'
            '<a:font script="Hebr" typeface="Times New Roman"/>'
            '<a:font script="Thai" typeface="Tahoma"/>'
            '<a:font script="Ethi" typeface="Nyala"/>'
            '<a:font script="Beng" typeface="Vrinda"/>'
            '<a:font script="Gujr" typeface="Shruti"/>'
            '<a:font script="Khmr" typeface="MoolBoran"/>'
            '<a:font script="Knda" typeface="Tunga"/>'
            '<a:font script="Guru" typeface="Raavi"/>'
            '<a:font script="Cans" typeface="Euphemia"/>'
            '<a:font script="Cher" typeface="Plantagenet Cherokee"/>'
            '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>'
            '<a:font script="Tibt" typeface="Microsoft Himalaya"/>'
            '<a:font script="Thaa" typeface="MV Boli"/>'
            '<a:font script="Deva" typeface="Mangal"/>'
            '<a:font script="Telu" typeface="Gautami"/>'
            '<a:font script="Taml" typeface="Latha"/>'
            '<a:font script="Syrc" typeface="Estrangelo Edessa"/>'
            '<a:font script="Orya" typeface="Kalinga"/>'
            '<a:font script="Mlym" typeface="Kartika"/>'
            '<a:font script="Laoo" typeface="DokChampa"/>'
            '<a:font script="Sinh" typeface="Iskoola Pota"/>'
            '<a:font script="Mong" typeface="Mongolian Baiti"/>'
            '<a:font script="Viet" typeface="Times New Roman"/>'
            '<a:font script="Uigh" typeface="Microsoft Uighur"/>'
            '</a:majorFont>'
            '<a:minorFont>'
            '<a:latin typeface="Calibri"/>'
            '<a:ea typeface=""/>'
            '<a:cs typeface=""/>'
            '<a:font script="Jpan" typeface=" "/>'
            '<a:font script="Hang" typeface=" "/>'
            '<a:font script="Hans" typeface=""/>'
            '<a:font script="Hant" typeface=""/>'
            '<a:font script="Arab" typeface="Arial"/>'
            '<a:font script="Hebr" typeface="Arial"/>'
            '<a:font script="Thai" typeface="Tahoma"/>'
            '<a:font script="Ethi" typeface="Nyala"/>'
            '<a:font script="Beng" typeface="Vrinda"/>'
            '<a:font script="Gujr" typeface="Shruti"/>'
            '<a:font script="Khmr" typeface="DaunPenh"/>'
            '<a:font script="Knda" typeface="Tunga"/>'
            '<a:font script="Guru" typeface="Raavi"/>'
            '<a:font script="Cans" typeface="Euphemia"/>'
            '<a:font script="Cher" typeface="Plantagenet Cherokee"/>'
            '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>'
            '<a:font script="Tibt" typeface="Microsoft Himalaya"/>'
            '<a:font script="Thaa" typeface="MV Boli"/>'
            '<a:font script="Deva" typeface="Mangal"/>'
            '<a:font script="Telu" typeface="Gautami"/>'
            '<a:font script="Taml" typeface="Latha"/>'
            '<a:font script="Syrc" typeface="Estrangelo Edessa"/>'
            '<a:font script="Orya" typeface="Kalinga"/>'
            '<a:font script="Mlym" typeface="Kartika"/>'
            '<a:font script="Laoo" typeface="DokChampa"/>'
            '<a:font script="Sinh" typeface="Iskoola Pota"/>'
            '<a:font script="Mong" typeface="Mongolian Baiti"/>'
            '<a:font script="Viet" typeface="Arial"/>'
            '<a:font script="Uigh" typeface="Microsoft Uighur"/>'
            '</a:minorFont>'
            '</a:fontScheme>'

            '<a:fmtScheme name="Office">'
            '<a:fillStyleLst>'
            '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>'
            '<a:gradFill rotWithShape="1"><a:gsLst>'
            '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/>'
            '<a:satMod val="300000"/></a:schemeClr></a:gs>'
            '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/>'
            '<a:satMod val="300000"/></a:schemeClr></a:gs>'
            '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/>'
            '<a:satMod val="350000"/></a:schemeClr></a:gs></a:gsLst>'
            '<a:lin ang="16200000" scaled="1"/></a:gradFill>'
            '<a:gradFill rotWithShape="1"><a:gsLst>'
            '<a:gs pos="0"><a:schemeClr val="phClr"><a:shade val="51000"/>'
            '<a:satMod val="130000"/></a:schemeClr></a:gs>'
            '<a:gs pos="80000"><a:schemeClr val="phClr"><a:shade val="93000"/>'
            '<a:satMod val="130000"/></a:schemeClr></a:gs>'
            '<a:gs pos="100000"><a:schemeClr val="phClr">'
            '<a:shade val="94000"/>'
            '<a:satMod val="135000"/></a:schemeClr></a:gs></a:gsLst>'
            '<a:lin ang="16200000" scaled="0"/></a:gradFill></a:fillStyleLst>'
            '<a:lnStyleLst>'
            '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr">'
            '<a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/>'
            '<a:satMod val="105000"/></a:schemeClr></a:solidFill>'
            '<a:prstDash val="solid"/></a:ln>'
            '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill>'
            '<a:schemeClr val="phClr"/></a:solidFill>'
            '<a:prstDash val="solid"/></a:ln>'
            '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill>'
            '<a:schemeClr val="phClr"/></a:solidFill>'
            '<a:prstDash val="solid"/></a:ln></a:lnStyleLst>'
            '<a:effectStyleLst><a:effectStyle><a:effectLst>'
            '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" '
                'rotWithShape="0"><a:srgbClr val="000000">'
            '<a:alpha val="38000"/></a:srgbClr></a:outerShdw></a:effectLst>'
            '</a:effectStyle><a:effectStyle><a:effectLst>'
            '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" '
                'rotWithShape="0"><a:srgbClr val="000000">'
            '<a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst>'
            '</a:effectStyle><a:effectStyle><a:effectLst>'
            '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" '
                'rotWithShape="0"><a:srgbClr val="000000">'
            '<a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst>'
            '<a:scene3d><a:camera prst="orthographicFront">'
            '<a:rot lat="0" lon="0" rev="0"/></a:camera>'
            '<a:lightRig rig="threePt" dir="t">'
            '<a:rot lat="0" lon="0" rev="1200000"/></a:lightRig>'
            '</a:scene3d><a:sp3d><a:bevelT w="63500" h="25400"/>'
            '</a:sp3d></a:effectStyle></a:effectStyleLst>'
            '<a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/>'
            '</a:solidFill><a:gradFill rotWithShape="1"><a:gsLst>'
            '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/>'
            '<a:satMod val="350000"/></a:schemeClr></a:gs>'
            '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/>'
            '<a:shade val="99000"/><a:satMod val="350000"/>'
            '</a:schemeClr></a:gs>'
            '<a:gs pos="100000"><a:schemeClr val="phClr">'
            '<a:shade val="20000"/><a:satMod val="255000"/>'
            '</a:schemeClr></a:gs></a:gsLst>'
            '<a:path path="circle">'
            '<a:fillToRect l="50000" t="-80000" r="50000" b="180000"/>'
            '</a:path>'
            '</a:gradFill><a:gradFill rotWithShape="1"><a:gsLst>'
            '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/>'
            '<a:satMod val="300000"/></a:schemeClr></a:gs>'
            '<a:gs pos="100000"><a:schemeClr val="phClr">'
            '<a:shade val="30000"/><a:satMod val="200000"/>'
            '</a:schemeClr></a:gs></a:gsLst>'
            '<a:path path="circle">'
            '<a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>'
            '</a:gradFill></a:bgFillStyleLst></a:fmtScheme>'
            '</a:themeElements>'
            '<a:objectDefaults/><a:extraClrSchemeLst/>'
            '</a:theme>')
    return get_document_content(xml_node)

########NEW FILE########
__FILENAME__ = workbook
# file openpyxl/writer/workbook.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Write the workbook global settings to the archive."""

# package imports
from ..shared.xmltools import Element, SubElement
from ..cell import absolute_coordinate
from ..shared.xmltools import get_document_content
from ..shared.ooxml import NAMESPACES, ARC_CORE, ARC_WORKBOOK, \
       ARC_APP, ARC_THEME, ARC_STYLE, ARC_SHARED_STRINGS
from ..shared.date_time import datetime_to_W3CDTF


def write_properties_core(properties):
    """Write the core properties to xml."""
    root = Element('cp:coreProperties', {'xmlns:cp': NAMESPACES['cp'],
            'xmlns:xsi': NAMESPACES['xsi'], 'xmlns:dc': NAMESPACES['dc'],
            'xmlns:dcterms': NAMESPACES['dcterms'],
            'xmlns:dcmitype': NAMESPACES['dcmitype'], })
    SubElement(root, 'dc:creator').text = properties.creator
    SubElement(root, 'cp:lastModifiedBy').text = properties.last_modified_by
    SubElement(root, 'dcterms:created', \
            {'xsi:type': 'dcterms:W3CDTF'}).text = \
            datetime_to_W3CDTF(properties.created)
    SubElement(root, 'dcterms:modified',
            {'xsi:type': 'dcterms:W3CDTF'}).text = \
            datetime_to_W3CDTF(properties.modified)
    return get_document_content(root)


def write_content_types(workbook):
    """Write the content-types xml."""
    root = Element('Types', {'xmlns': 'http://schemas.openxmlformats.org/package/2006/content-types'})
    SubElement(root, 'Override', {'PartName': '/' + ARC_THEME, 'ContentType': 'application/vnd.openxmlformats-officedocument.theme+xml'})
    SubElement(root, 'Override', {'PartName': '/' + ARC_STYLE, 'ContentType': 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml'})
    SubElement(root, 'Default', {'Extension': 'rels', 'ContentType': 'application/vnd.openxmlformats-package.relationships+xml'})
    SubElement(root, 'Default', {'Extension': 'xml', 'ContentType': 'application/xml'})
    SubElement(root, 'Override', {'PartName': '/' + ARC_WORKBOOK, 'ContentType': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml'})
    SubElement(root, 'Override', {'PartName': '/' + ARC_APP, 'ContentType': 'application/vnd.openxmlformats-officedocument.extended-properties+xml'})
    SubElement(root, 'Override', {'PartName': '/' + ARC_CORE, 'ContentType': 'application/vnd.openxmlformats-package.core-properties+xml'})
    SubElement(root, 'Override', {'PartName': '/' + ARC_SHARED_STRINGS, 'ContentType': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml'})

    drawing_id = 1
    chart_id = 1

    for sheet_id, sheet in enumerate(workbook.worksheets):
        SubElement(root, 'Override',
                {'PartName': '/xl/worksheets/sheet%d.xml' % (sheet_id + 1),
                'ContentType': 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml'})
        if sheet._charts:
            SubElement(root, 'Override',
                {'PartName' : '/xl/drawings/drawing%d.xml' % (sheet_id + 1),
                'ContentType' : 'application/vnd.openxmlformats-officedocument.drawing+xml'})
            drawing_id += 1

            for chart in sheet._charts:
                SubElement(root, 'Override',
                    {'PartName' : '/xl/charts/chart%d.xml' % chart_id,
                    'ContentType' : 'application/vnd.openxmlformats-officedocument.drawingml.chart+xml'})
                chart_id += 1
                if chart._shapes:
                    SubElement(root, 'Override',
                        {'PartName' : '/xl/drawings/drawing%d.xml' % drawing_id,
                        'ContentType' : 'application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml'})
                    drawing_id += 1

    return get_document_content(root)


def write_properties_app(workbook):
    """Write the properties xml."""
    worksheets_count = len(workbook.worksheets)
    root = Element('Properties', {'xmlns': 'http://schemas.openxmlformats.org/officeDocument/2006/extended-properties',
            'xmlns:vt': 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes'})
    SubElement(root, 'Application').text = 'Microsoft Excel'
    SubElement(root, 'DocSecurity').text = '0'
    SubElement(root, 'ScaleCrop').text = 'false'
    SubElement(root, 'Company')
    SubElement(root, 'LinksUpToDate').text = 'false'
    SubElement(root, 'SharedDoc').text = 'false'
    SubElement(root, 'HyperlinksChanged').text = 'false'
    SubElement(root, 'AppVersion').text = '12.0000'

    # heading pairs part
    heading_pairs = SubElement(root, 'HeadingPairs')
    vector = SubElement(heading_pairs, 'vt:vector',
            {'size': '2', 'baseType': 'variant'})
    variant = SubElement(vector, 'vt:variant')
    SubElement(variant, 'vt:lpstr').text = 'Worksheets'
    variant = SubElement(vector, 'vt:variant')
    SubElement(variant, 'vt:i4').text = '%d' % worksheets_count

    # title of parts
    title_of_parts = SubElement(root, 'TitlesOfParts')
    vector = SubElement(title_of_parts, 'vt:vector',
            {'size': '%d' % worksheets_count, 'baseType': 'lpstr'})
    for ws in workbook.worksheets:
        SubElement(vector, 'vt:lpstr').text = '%s' % ws.title
    return get_document_content(root)


def write_root_rels(workbook):
    """Write the relationships xml."""
    root = Element('Relationships', {'xmlns':
            'http://schemas.openxmlformats.org/package/2006/relationships'})
    SubElement(root, 'Relationship', {'Id': 'rId1', 'Target': ARC_WORKBOOK,
            'Type': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument'})
    SubElement(root, 'Relationship', {'Id': 'rId2', 'Target': ARC_CORE,
            'Type': 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties'})
    SubElement(root, 'Relationship', {'Id': 'rId3', 'Target': ARC_APP,
            'Type': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties'})
    return get_document_content(root)


def write_workbook(workbook):
    """Write the core workbook xml."""
    root = Element('workbook', {'xmlns': 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
            'xml:space': 'preserve', 'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'})
    SubElement(root, 'fileVersion', {'appName': 'xl', 'lastEdited': '4',
            'lowestEdited': '4', 'rupBuild': '4505'})
    SubElement(root, 'workbookPr', {'defaultThemeVersion': '124226',
            'codeName': 'ThisWorkbook'})
    book_views = SubElement(root, 'bookViews')
    SubElement(book_views, 'workbookView', {'activeTab': '%d' % workbook.get_index(workbook.get_active_sheet()),
            'autoFilterDateGrouping': '1', 'firstSheet': '0', 'minimized': '0',
            'showHorizontalScroll': '1', 'showSheetTabs': '1',
            'showVerticalScroll': '1', 'tabRatio': '600',
            'visibility': 'visible'})
    # worksheets
    sheets = SubElement(root, 'sheets')
    for i, sheet in enumerate(workbook.worksheets):
        sheet_node = SubElement(sheets, 'sheet', {'name': sheet.title,
                'sheetId': '%d' % (i + 1), 'r:id': 'rId%d' % (i + 1)})
        if not sheet.sheet_state == sheet.SHEETSTATE_VISIBLE:
            sheet_node.set('state', sheet.sheet_state)
    # named ranges
    defined_names = SubElement(root, 'definedNames')
    for named_range in workbook.get_named_ranges():
        name = SubElement(defined_names, 'definedName',
                {'name': named_range.name})

        # as there can be many cells in one range, generate the list of ranges
        dest_cells = []
        cell_ids = []
        for worksheet, range_name in named_range.destinations:
            cell_ids.append(workbook.get_index(worksheet))
            dest_cells.append("'%s'!%s" % (worksheet.title.replace("'", "''"),
                                           absolute_coordinate(range_name)))

        # for local ranges, we must check all the cells belong to the same sheet
        base_id = cell_ids[0]
        if named_range.local_only and all([x == base_id for x in cell_ids]):
            name.set('localSheetId', '%s' % base_id)

        # finally write the cells list
        name.text = ','.join(dest_cells)

    SubElement(root, 'calcPr', {'calcId': '124519', 'calcMode': 'auto',
            'fullCalcOnLoad': '1'})
    return get_document_content(root)


def write_workbook_rels(workbook):
    """Write the workbook relationships xml."""
    root = Element('Relationships', {'xmlns':
            'http://schemas.openxmlformats.org/package/2006/relationships'})
    for i in range(len(workbook.worksheets)):
        SubElement(root, 'Relationship', {'Id': 'rId%d' % (i + 1),
                'Type': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',
                'Target': 'worksheets/sheet%s.xml' % (i + 1)})
    rid = len(workbook.worksheets) + 1
    SubElement(root, 'Relationship',
            {'Id': 'rId%d' % rid, 'Target': 'sharedStrings.xml',
            'Type': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings'})
    SubElement(root, 'Relationship',
            {'Id': 'rId%d' % (rid + 1), 'Target': 'styles.xml',
            'Type': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles'})
    SubElement(root, 'Relationship',
            {'Id': 'rId%d' % (rid + 2), 'Target': 'theme/theme1.xml',
            'Type': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme'})
    return get_document_content(root)

########NEW FILE########
__FILENAME__ = worksheet
# file openpyxl/writer/worksheet.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Write worksheets to xml representations."""

# Python stdlib imports
from ....compat import BytesIO as StringIO  # cStringIO doesn't handle unicode

# package imports
from ..cell import coordinate_from_string, column_index_from_string
from ..shared.xmltools import Element, SubElement, XMLGenerator, \
        get_document_content, start_tag, end_tag, tag


def row_sort(cell):
    """Translate column names for sorting."""
    return column_index_from_string(cell.column)


def write_worksheet(worksheet, string_table, style_table):
    """Write a worksheet to an xml file."""
    xml_file = StringIO()
    doc = XMLGenerator(xml_file, 'utf-8')
    start_tag(doc, 'worksheet',
            {'xml:space': 'preserve',
            'xmlns': 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
            'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'})
    start_tag(doc, 'sheetPr')
    tag(doc, 'outlinePr',
            {'summaryBelow': '%d' % (worksheet.show_summary_below),
            'summaryRight': '%d' % (worksheet.show_summary_right)})
    end_tag(doc, 'sheetPr')
    tag(doc, 'dimension', {'ref': '%s' % worksheet.calculate_dimension()})
    write_worksheet_sheetviews(doc, worksheet)
    tag(doc, 'sheetFormatPr', {'defaultRowHeight': '15'})
    write_worksheet_cols(doc, worksheet)
    write_worksheet_data(doc, worksheet, string_table, style_table)
    if worksheet.auto_filter:
        tag(doc, 'autoFilter', {'ref': worksheet.auto_filter})
    write_worksheet_hyperlinks(doc, worksheet)
    if worksheet._charts:
        tag(doc, 'drawing', {'r:id':'rId1'})
    end_tag(doc, 'worksheet')
    doc.endDocument()
    xml_string = xml_file.getvalue()
    xml_file.close()
    return xml_string

def write_worksheet_sheetviews(doc, worksheet):
    start_tag(doc, 'sheetViews')
    start_tag(doc, 'sheetView', {'workbookViewId': '0'})
    selectionAttrs = {}
    topLeftCell = worksheet.freeze_panes
    if topLeftCell:
        colName, row = coordinate_from_string(topLeftCell)
        column = column_index_from_string(colName)
        pane = 'topRight'
        paneAttrs = {}
        if column > 1:
            paneAttrs['xSplit'] = str(column - 1)
        if row > 1:
            paneAttrs['ySplit'] = str(row - 1)
            pane = 'bottomLeft'
            if column > 1:
                pane = 'bottomRight'
        paneAttrs.update(dict(topLeftCell=topLeftCell,
                              activePane=pane,
                              state='frozen'))
        tag(doc, 'pane', paneAttrs)
        selectionAttrs['pane'] = pane
        if row > 1 and column > 1:
            tag(doc, 'selection', {'pane': 'topRight'})
            tag(doc, 'selection', {'pane': 'bottomLeft'})

    selectionAttrs.update({'activeCell': worksheet.active_cell,
                           'sqref': worksheet.selected_cell})

    tag(doc, 'selection', selectionAttrs)
    end_tag(doc, 'sheetView')
    end_tag(doc, 'sheetViews')


def write_worksheet_cols(doc, worksheet):
    """Write worksheet columns to xml."""
    if worksheet.column_dimensions:
        start_tag(doc, 'cols')
        for column_string, columndimension in \
                worksheet.column_dimensions.items():
            col_index = column_index_from_string(column_string)
            col_def = {}
            col_def['collapsed'] = str(columndimension.style_index)
            col_def['min'] = str(col_index)
            col_def['max'] = str(col_index)
            if columndimension.width != \
                    worksheet.default_column_dimension.width:
                col_def['customWidth'] = 'true'
            if not columndimension.visible:
                col_def['hidden'] = 'true'
            if columndimension.outline_level > 0:
                col_def['outlineLevel'] = str(columndimension.outline_level)
            if columndimension.collapsed:
                col_def['collapsed'] = 'true'
            if columndimension.auto_size:
                col_def['bestFit'] = 'true'
            if columndimension.width > 0:
                col_def['width'] = str(columndimension.width)
            else:
                col_def['width'] = '9.10'
            tag(doc, 'col', col_def)
        end_tag(doc, 'cols')


def write_worksheet_data(doc, worksheet, string_table, style_table):
    """Write worksheet data to xml."""
    start_tag(doc, 'sheetData')
    max_column = worksheet.get_highest_column()
    style_id_by_hash = style_table
    cells_by_row = {}
    for cell in worksheet.get_cell_collection():
        cells_by_row.setdefault(cell.row, []).append(cell)
    for row_idx in sorted(cells_by_row):
        row_dimension = worksheet.row_dimensions[row_idx]
        attrs = {'r': '%d' % row_idx,
                 'spans': '1:%d' % max_column}
        if row_dimension.height > 0:
            attrs['ht'] = str(row_dimension.height)
            attrs['customHeight'] = '1'
        start_tag(doc, 'row', attrs)
        row_cells = cells_by_row[row_idx]
        sorted_cells = sorted(row_cells, key = row_sort)
        for cell in sorted_cells:
            value = cell._value
            coordinate = cell.get_coordinate()
            attributes = {'r': coordinate}
            attributes['t'] = cell.data_type
            if coordinate in worksheet._styles:
                attributes['s'] = '%d' % style_id_by_hash[
                        hash(worksheet._styles[coordinate])]
            start_tag(doc, 'c', attributes)
            if value is None:
                tag(doc, 'v', body='')
            elif cell.data_type == cell.TYPE_STRING:
                tag(doc, 'v', body = '%s' % string_table[value])
            elif cell.data_type == cell.TYPE_FORMULA:
                tag(doc, 'f', body = '%s' % value[1:])
                tag(doc, 'v')
            elif cell.data_type == cell.TYPE_NUMERIC:
                tag(doc, 'v', body = '%s' % value)
            else:
                tag(doc, 'v', body = '%s' % value)
            end_tag(doc, 'c')
        end_tag(doc, 'row')
    end_tag(doc, 'sheetData')


def write_worksheet_hyperlinks(doc, worksheet):
    """Write worksheet hyperlinks to xml."""
    write_hyperlinks = False
    for cell in worksheet.get_cell_collection():
        if cell.hyperlink_rel_id is not None:
            write_hyperlinks = True
            break
    if write_hyperlinks:
        start_tag(doc, 'hyperlinks')
        for cell in worksheet.get_cell_collection():
            if cell.hyperlink_rel_id is not None:
                attrs = {'display': cell.hyperlink,
                        'ref': cell.get_coordinate(),
                        'r:id': cell.hyperlink_rel_id}
                tag(doc, 'hyperlink', attrs)
        end_tag(doc, 'hyperlinks')


def write_worksheet_rels(worksheet, idx):
    """Write relationships for the worksheet to xml."""
    root = Element('Relationships', {'xmlns': 'http://schemas.openxmlformats.org/package/2006/relationships'})
    for rel in worksheet.relationships:
        attrs = {'Id': rel.id, 'Type': rel.type, 'Target': rel.target}
        if rel.target_mode:
            attrs['TargetMode'] = rel.target_mode
        SubElement(root, 'Relationship', attrs)
    if worksheet._charts:
        attrs = {'Id' : 'rId1',
            'Type' : 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',
            'Target' : '../drawings/drawing%s.xml' % idx }
        SubElement(root, 'Relationship', attrs)
    return get_document_content(root)

########NEW FILE########
__FILENAME__ = cell
# file openpyxl/cell.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Manage individual cells in a spreadsheet.

The Cell class is required to know its value and type, display options,
and any other features of an Excel cell.  Utilities for referencing
cells using Excel's 'A1' column/row nomenclature are also provided.

"""

__docformat__ = "restructuredtext en"

# Python stdlib imports
import datetime
import re

# package imports
from .shared.date_time import SharedDate
from .shared.exc import CellCoordinatesException, \
        ColumnStringIndexException, DataTypeException
from .style import NumberFormat

# constants
COORD_RE = re.compile('^[$]?([A-Z]+)[$]?(\d+)$')

ABSOLUTE_RE = re.compile('^[$]?([A-Z]+)[$]?(\d+)(:[$]?([A-Z]+)[$]?(\d+))?$')

def coordinate_from_string(coord_string):
    """Convert a coordinate string like 'B12' to a tuple ('B', 12)"""
    match = COORD_RE.match(coord_string.upper())
    if not match:
        msg = 'Invalid cell coordinates (%s)' % coord_string
        raise CellCoordinatesException(msg)
    column, row = match.groups()
    return (column, int(row))


def absolute_coordinate(coord_string):
    """Convert a coordinate to an absolute coordinate string (B12 -> $B$12)"""
    parts = ABSOLUTE_RE.match(coord_string).groups()

    if all(parts[-2:]):
        return '$%s$%s:$%s$%s' % (parts[0], parts[1], parts[3], parts[4])
    else:
        return '$%s$%s' % (parts[0], parts[1])


def column_index_from_string(column, fast = False):
    """Convert a column letter into a column number (e.g. B -> 2)
    
    Excel only supports 1-3 letter column names from A -> ZZZ, so we
    restrict our column names to 1-3 characters, each in the range A-Z.
    
    .. note::
    
        Fast mode is faster but does not check that all letters are capitals between A and Z

    """
    column = column.upper()

    clen = len(column)

    if not fast and not all('A' <= char <= 'Z' for char in column):
        msg = 'Column string must contain only characters A-Z: got %s' % column
        raise ColumnStringIndexException(msg)

    if clen == 1:
        return ord(column[0]) - 64
    elif clen == 2:
        return ((1 + (ord(column[0]) - 65)) * 26) + (ord(column[1]) - 64)
    elif clen == 3:
        return ((1 + (ord(column[0]) - 65)) * 676) + ((1 + (ord(column[1]) - 65)) * 26) + (ord(column[2]) - 64)
    elif clen > 3:
        raise ColumnStringIndexException('Column string index can not be longer than 3 characters')
    else:
        raise ColumnStringIndexException('Column string index can not be empty')


def get_column_letter(col_idx):
    """Convert a column number into a column letter (3 -> 'C')

    Right shift the column col_idx by 26 to find column letters in reverse
    order.  These numbers are 1-based, and can be converted to ASCII
    ordinals by adding 64.

    """
    # these indicies corrospond to A -> ZZZ and include all allowed
    # columns
    if not 1 <= col_idx <= 18278:
        msg = 'Column index out of bounds: %s' % col_idx
        raise ColumnStringIndexException(msg)
    ordinals = []
    temp = col_idx
    while temp:
        quotient, remainder = divmod(temp, 26)
        # check for exact division and borrow if needed
        if remainder == 0:
            quotient -= 1
            remainder = 26
        ordinals.append(remainder + 64)
        temp = quotient
    ordinals.reverse()
    return ''.join([chr(ordinal) for ordinal in ordinals])


class Cell(object):
    """Describes cell associated properties.

    Properties of interest include style, type, value, and address.

    """
    __slots__ = ('column',
                 'row',
                 '_value',
                 '_data_type',
                 'parent',
                 'xf_index',
                 '_hyperlink_rel')

    ERROR_CODES = {'#NULL!': 0,
                   '#DIV/0!': 1,
                   '#VALUE!': 2,
                   '#REF!': 3,
                   '#NAME?': 4,
                   '#NUM!': 5,
                   '#N/A': 6}

    TYPE_STRING = 's'
    TYPE_FORMULA = 'f'
    TYPE_NUMERIC = 'n'
    TYPE_BOOL = 'b'
    TYPE_NULL = 's'
    TYPE_INLINE = 'inlineStr'
    TYPE_ERROR = 'e'

    VALID_TYPES = [TYPE_STRING, TYPE_FORMULA, TYPE_NUMERIC, TYPE_BOOL,
                   TYPE_NULL, TYPE_INLINE, TYPE_ERROR]

    RE_PATTERNS = {
        'percentage': re.compile('^\-?[0-9]*\.?[0-9]*\s?\%$'),
        'time': re.compile('^(\d|[0-1]\d|2[0-3]):[0-5]\d(:[0-5]\d)?$'),
        'numeric': re.compile('^\-?([0-9]+\\.?[0-9]*|[0-9]*\\.?[0-9]+)((E|e)\-?[0-9]+)?$'), }

    def __init__(self, worksheet, column, row, value = None):
        self.column = column.upper()
        self.row = row
        # _value is the stored value, while value is the displayed value
        self._value = None
        self._hyperlink_rel = None
        self._data_type = self.TYPE_NULL
        if value:
            self.value = value
        self.parent = worksheet
        self.xf_index = 0

    def __repr__(self):
        return "<Cell %s.%s>" % (self.parent.title, self.get_coordinate())

    def check_string(self, value):
        """Check string coding, length, and line break character"""
        # convert to unicode string
        value = str(value)
        # string must never be longer than 32,767 characters
        # truncate if necessary
        value = value[:32767]
        # we require that newline is represented as "\n" in core,
        # not as "\r\n" or "\r"
        value = value.replace('\r\n', '\n')
        return value

    def check_numeric(self, value):
        """Cast value to int or float if necessary"""
        if not isinstance(value, (int, float)):
            try:
                value = int(value)
            except ValueError:
                value = float(value)
        return value

    def set_value_explicit(self, value = None, data_type = TYPE_STRING):
        """Coerce values according to their explicit type"""
        type_coercion_map = {
            self.TYPE_INLINE: self.check_string,
            self.TYPE_STRING: self.check_string,
            self.TYPE_FORMULA: str,
            self.TYPE_NUMERIC: self.check_numeric,
            self.TYPE_BOOL: bool, }
        try:
            self._value = type_coercion_map[data_type](value)
        except KeyError:
            if data_type not in self.VALID_TYPES:
                msg = 'Invalid data type: %s' % data_type
                raise DataTypeException(msg)
        self._data_type = data_type

    def data_type_for_value(self, value):
        """Given a value, infer the correct data type"""
        if value is None:
            data_type = self.TYPE_NULL
        elif value is True or value is False:
            data_type = self.TYPE_BOOL
        elif isinstance(value, (int, float)):
            data_type = self.TYPE_NUMERIC
        elif not value:
            data_type = self.TYPE_STRING
        elif isinstance(value, (datetime.datetime, datetime.date)):
            data_type = self.TYPE_NUMERIC
        elif isinstance(value, str) and value[0] == '=':
            data_type = self.TYPE_FORMULA
        elif self.RE_PATTERNS['numeric'].match(value):
            data_type = self.TYPE_NUMERIC
        elif value.strip() in self.ERROR_CODES:
            data_type = self.TYPE_ERROR
        else:
            data_type = self.TYPE_STRING
        return data_type

    def bind_value(self, value):
        """Given a value, infer type and display options."""
        self._data_type = self.data_type_for_value(value)
        if value is None:
            self.set_value_explicit('', self.TYPE_NULL)
            return True
        elif self._data_type == self.TYPE_STRING:
            # percentage detection
            percentage_search = self.RE_PATTERNS['percentage'].match(value)
            if percentage_search and value.strip() != '%':
                value = float(value.replace('%', '')) / 100.0
                self.set_value_explicit(value, self.TYPE_NUMERIC)
                self._set_number_format(NumberFormat.FORMAT_PERCENTAGE)
                return True
            # time detection
            time_search = self.RE_PATTERNS['time'].match(value)
            if time_search:
                sep_count = value.count(':') #pylint: disable-msg=E1103
                if sep_count == 1:
                    hours, minutes = [int(bit) for bit in value.split(':')] #pylint: disable-msg=E1103
                    seconds = 0
                elif sep_count == 2:
                    hours, minutes, seconds = \
                            [int(bit) for bit in value.split(':')] #pylint: disable-msg=E1103
                days = (hours / 24.0) + (minutes / 1440.0) + \
                        (seconds / 86400.0)
                self.set_value_explicit(days, self.TYPE_NUMERIC)
                self._set_number_format(NumberFormat.FORMAT_DATE_TIME3)
                return True
        if self._data_type == self.TYPE_NUMERIC:
            # date detection
            # if the value is a date, but not a date time, make it a
            # datetime, and set the time part to 0
            if isinstance(value, datetime.date) and not \
                    isinstance(value, datetime.datetime):
                value = datetime.datetime.combine(value, datetime.time())
            if isinstance(value, datetime.datetime):
                value = SharedDate().datetime_to_julian(date = value)
                self.set_value_explicit(value, self.TYPE_NUMERIC)
                self._set_number_format(NumberFormat.FORMAT_DATE_YYYYMMDD2)
                return True
        self.set_value_explicit(value, self._data_type)

    def _get_value(self):
        """Return the value, formatted as a date if needed"""
        value = self._value
        if self.is_date():
            value = SharedDate().from_julian(value)
        return value

    def _set_value(self, value):
        """Set the value and infer type and display options."""
        self.bind_value(value)

    value = property(_get_value, _set_value,
            doc = 'Get or set the value held in the cell.\n\n'
            ':rtype: depends on the value (string, float, int or '
            ':class:`datetime.datetime`)')

    def _set_hyperlink(self, val):
        """Set value and display for hyperlinks in a cell"""
        if self._hyperlink_rel is None:
            self._hyperlink_rel = self.parent.create_relationship("hyperlink")
        self._hyperlink_rel.target = val
        self._hyperlink_rel.target_mode = "External"
        if self._value is None:
            self.value = val

    def _get_hyperlink(self):
        """Return the hyperlink target or an empty string"""
        return self._hyperlink_rel is not None and \
                self._hyperlink_rel.target or ''

    hyperlink = property(_get_hyperlink, _set_hyperlink,
            doc = 'Get or set the hyperlink held in the cell.  '
            'Automatically sets the `value` of the cell with link text, '
            'but you can modify it afterwards by setting the '
            '`value` property, and the hyperlink will remain.\n\n'
            ':rtype: string')

    @property
    def hyperlink_rel_id(self):
        """Return the id pointed to by the hyperlink, or None"""
        return self._hyperlink_rel is not None and \
                self._hyperlink_rel.id or None

    def _set_number_format(self, format_code):
        """Set a new formatting code for numeric values"""
        self.style.number_format.format_code = format_code

    @property
    def has_style(self):
        """Check if the parent worksheet has a style for this cell"""
        return self.get_coordinate() in self.parent._styles #pylint: disable-msg=W0212

    @property
    def style(self):
        """Returns the :class:`.style.Style` object for this cell"""
        return self.parent.get_style(self.get_coordinate())

    @property
    def data_type(self):
        """Return the data type represented by this cell"""
        return self._data_type

    def get_coordinate(self):
        """Return the coordinate string for this cell (e.g. 'B12')

        :rtype: string
        """
        return '%s%s' % (self.column, self.row)
    
    @property
    def address(self):
        """Return the coordinate string for this cell (e.g. 'B12')

        :rtype: string
        """
        return self.get_coordinate()

    def offset(self, row = 0, column = 0):
        """Returns a cell location relative to this cell.

        :param row: number of rows to offset
        :type row: int

        :param column: number of columns to offset
        :type column: int

        :rtype: :class:`.cell.Cell`
        """
        offset_column = get_column_letter(column_index_from_string(
                column = self.column) + column)
        offset_row = self.row + row
        return self.parent.cell('%s%s' % (offset_column, offset_row))

    def is_date(self):
        """Returns whether the value is *probably* a date or not
        
        :rtype: bool
        """
        return (self.has_style
                and self.style.number_format.is_date_format()
                and isinstance(self._value, (int, float)))

########NEW FILE########
__FILENAME__ = chart
'''
Copyright (c) 2010 openpyxl

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license: http://www.opensource.org/licenses/mit-license.php
@author: Eric Gazoni
'''

import math

from .style import NumberFormat
from .drawing import Drawing, Shape
from .shared.units import pixels_to_EMU, short_color
from .cell import get_column_letter

class Axis(object):
    
    POSITION_BOTTOM = 'b'
    POSITION_LEFT = 'l'
    
    ORIENTATION_MIN_MAX = "minMax"
    
    def __init__(self):
        
        self.orientation = self.ORIENTATION_MIN_MAX
        self.number_format = NumberFormat()
        for attr in ('position','tick_label_position','crosses',
            'auto','label_align','label_offset','cross_between'):
            setattr(self, attr, None)
        self.min = 0
        self.max = None
        self.unit = None
        
    @classmethod
    def default_category(cls):
        """ default values for category axes """
        
        ax = Axis()
        ax.id = 60871424
        ax.cross = 60873344
        ax.position = Axis.POSITION_BOTTOM
        ax.tick_label_position = 'nextTo'
        ax.crosses = "autoZero"
        ax.auto = True
        ax.label_align = 'ctr'
        ax.label_offset = 100
        return ax
    
    @classmethod
    def default_value(cls):
        """ default values for value axes """
        
        ax = Axis()
        ax.id = 60873344
        ax.cross = 60871424
        ax.position = Axis.POSITION_LEFT
        ax.major_gridlines = None
        ax.tick_label_position = 'nextTo'
        ax.crosses = 'autoZero'
        ax.auto = False
        ax.cross_between = 'between'
        return ax

class Reference(object):
    """ a simple wrapper around a serie of reference data """

    def __init__(self, sheet, pos1, pos2=None):
        
        self.sheet = sheet
        self.pos1 = pos1
        self.pos2 = pos2

    def get_type(self):

        if isinstance(self.cache[0], str):
            return 'str'
        else:
            return 'num'
        
    def _get_ref(self):
        """ format excel reference notation """
        
        if self.pos2:
            return '%s!$%s$%s:$%s$%s' % (self.sheet.title,
                get_column_letter(self.pos1[1]+1), self.pos1[0]+1,
                get_column_letter(self.pos2[1]+1), self.pos2[0]+1)
        else:
            return '%s!$%s$%s' % (self.sheet.title,
                get_column_letter(self.pos1[1]+1), self.pos1[0]+1)
        
        
    def _get_cache(self):
        """ read data in sheet - to be used at writing time """
        
        cache = []
        if self.pos2:
            for row in range(self.pos1[0], self.pos2[0]+1):
                for col in range(self.pos1[1], self.pos2[1]+1):
                    cache.append(self.sheet.cell(row=row, column=col).value)
        else:
            cell = self.sheet.cell(row=self.pos1[0], column=self.pos1[1])
            cache.append(cell.value)
        return cache
        

class Serie(object):
    """ a serie of data and possibly associated labels """
    
    MARKER_NONE = 'none'
    
    def __init__(self, values, labels=None, legend=None, color=None, xvalues=None):
        
        self.marker = Serie.MARKER_NONE
        self.values = values
        self.xvalues = xvalues
        self.labels = labels
        self.legend = legend
        self.error_bar = None
        self._color = color
        
    def _get_color(self):
        return self._color
    
    def _set_color(self, color):
        self._color = short_color(color)
            
    color = property(_get_color, _set_color)

    def get_min_max(self):

        if self.error_bar:
            err_cache = self.error_bar.values._get_cache()
            vals = [v + err_cache[i] \
                for i,v in enumerate(self.values._get_cache())]
        else:
            vals = self.values._get_cache()
        return min(vals), max(vals)
        
    def __len__(self):

        return len(self.values.cache)
        
class Legend(object):
    
    def __init__(self):
        
        self.position = 'r'
        self.layout = None
        
class ErrorBar(object):
    
    PLUS = 1
    MINUS = 2
    PLUS_MINUS = 3
    
    def __init__(self, _type, values):
        
        self.type = _type
        self.values = values
        
class Chart(object):
    """ raw chart class """
    
    GROUPING_CLUSTERED = 'clustered'
    GROUPING_STANDARD = 'standard'
    
    BAR_CHART = 1
    LINE_CHART = 2
    SCATTER_CHART = 3
    
    def __init__(self, _type, grouping):
        
        self._series = []
        
        # public api
        self.type = _type
        self.grouping = grouping
        self.x_axis = Axis.default_category()
        self.y_axis = Axis.default_value()
        self.legend = Legend()
        self.lang = 'fr-FR'
        self.title = ''
        self.print_margins = dict(b=.75, l=.7, r=.7, t=.75, header=0.3, footer=.3)
        
        # the containing drawing
        self.drawing = Drawing()
        
        # the offset for the plot part in percentage of the drawing size
        self.width = .6
        self.height = .6
        self.margin_top = self._get_max_margin_top()
        self.margin_left = 0
        
        # the user defined shapes
        self._shapes = []
            
    def add_serie(self, serie):
        
        serie.id = len(self._series)
        self._series.append(serie)
        self._compute_min_max()
        if not None in [s.xvalues for s in self._series]:
            self._compute_xmin_xmax()
        
    def add_shape(self, shape):
        
        shape._chart = self
        self._shapes.append(shape)
        
    def get_x_units(self):
        """ calculate one unit for x axis in EMU """

        return max([len(s.values._get_cache()) for s in self._series])
    
    def get_y_units(self):
        """ calculate one unit for y axis in EMU """

        dh = pixels_to_EMU(self.drawing.height)
        return (dh * self.height) / self.y_axis.max
    
    def get_y_chars(self):
        """ estimate nb of chars for y axis """
        
        _max = max([max(s.values._get_cache()) for s in self._series])
        return len(str(int(_max)))

    def _compute_min_max(self):
        """ compute y axis limits and units """

        maxi = max([max(s.values._get_cache()) for s in self._series])

        mul = None
        if maxi < 1:
            s = str(maxi).split('.')[1]
            mul = 10
            for x in s:
                if x == '0':
                    mul *= 10
                else:
                    break
            maxi = maxi * mul

        maxi = math.ceil(maxi * 1.1)
        sz =  len(str(int(maxi))) - 1
        unit = math.ceil(math.ceil(maxi / pow(10, sz)) * pow(10, sz-1))
        maxi = math.ceil(maxi/unit) * unit

        if mul is not None:
            maxi = maxi/mul
            unit = unit/mul
        
        if maxi / unit > 9:
            # no more that 10 ticks
            unit *= 2
            
        self.y_axis.max = maxi
        self.y_axis.unit = unit
        
    def _compute_xmin_xmax(self):
        """ compute x axis limits and units """

        maxi = max([max(s.xvalues._get_cache()) for s in self._series])

        mul = None
        if maxi < 1:
            s = str(maxi).split('.')[1]
            mul = 10
            for x in s:
                if x == '0':
                    mul *= 10
                else:
                    break
            maxi = maxi * mul

        maxi = math.ceil(maxi * 1.1)
        sz =  len(str(int(maxi))) - 1
        unit = math.ceil(math.ceil(maxi / pow(10, sz)) * pow(10, sz-1))
        maxi = math.ceil(maxi/unit) * unit

        if mul is not None:
            maxi = maxi/mul
            unit = unit/mul
        
        if maxi / unit > 9:
            # no more that 10 ticks
            unit *= 2
            
        self.x_axis.max = maxi
        self.x_axis.unit = unit
        
    def _get_max_margin_top(self):
        
        mb = Shape.FONT_HEIGHT + Shape.MARGIN_BOTTOM
        plot_height = self.drawing.height * self.height
        return float(self.drawing.height - plot_height - mb)/self.drawing.height
    
    def _get_min_margin_left(self):
        
        ml = (self.get_y_chars() * Shape.FONT_WIDTH) + Shape.MARGIN_LEFT
        return float(ml)/self.drawing.width

    def _get_margin_top(self):
        """ get margin in percent """
        
        return min(self.margin_top, self._get_max_margin_top())
        
    def _get_margin_left(self):
        
        return max(self._get_min_margin_left(), self.margin_left)

class BarChart(Chart):
    def __init__(self):
        super(BarChart, self).__init__(Chart.BAR_CHART, Chart.GROUPING_CLUSTERED)
        
class LineChart(Chart):
    def __init__(self):
        super(LineChart, self).__init__(Chart.LINE_CHART, Chart.GROUPING_STANDARD)
        
class ScatterChart(Chart):
    def __init__(self):
        super(ScatterChart, self).__init__(Chart.SCATTER_CHART, Chart.GROUPING_STANDARD)
        
        

########NEW FILE########
__FILENAME__ = drawing
'''
Copyright (c) 2010 openpyxl

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license: http://www.opensource.org/licenses/mit-license.php
@author: Eric Gazoni
'''

import math
from .style import Color
from .shared.units import pixels_to_EMU, EMU_to_pixels, short_color

class Shadow(object):
    
    SHADOW_BOTTOM = 'b'
    SHADOW_BOTTOM_LEFT = 'bl'
    SHADOW_BOTTOM_RIGHT = 'br'
    SHADOW_CENTER = 'ctr'
    SHADOW_LEFT = 'l'
    SHADOW_TOP = 't'
    SHADOW_TOP_LEFT = 'tl'
    SHADOW_TOP_RIGHT = 'tr'

    def __init__(self):
    	self.visible = False
    	self.blurRadius = 6
    	self.distance = 2
    	self.direction = 0
    	self.alignment = self.SHADOW_BOTTOM_RIGHT
    	self.color = Color(Color.BLACK)
    	self.alpha = 50
    
class Drawing(object):
    """ a drawing object - eg container for shapes or charts 
        we assume user specifies dimensions in pixels; units are 
        converted to EMU in the drawing part
    """

    count = 0

    def __init__(self):
        
        self.name = ''
        self.description = ''
        self.coordinates = ((1,2), (16,8))
        self.left = 0
        self.top = 0
        self._width = EMU_to_pixels(200000)
        self._height = EMU_to_pixels(1828800)
        self.resize_proportional = False
        self.rotation = 0
#        self.shadow = Shadow()
        
    def _set_width(self, w):
        
        if self.resize_proportional and w:
            ratio = self._height / self._width
            self._height = round(ratio * w)
        self._width = w
        
    def _get_width(self):
        
        return self._width
    
    width = property(_get_width, _set_width)
        
    def _set_height(self, h):
        
        if self.resize_proportional and h:
            ratio = self._width / self._height
            self._width = round(ratio * h)
        self._height = h
        
    def _get_height(self):
        
        return self._height
    
    height = property(_get_height, _set_height)
    
    def set_dimension(self, w=0, h=0):

        xratio = w / self._width
        yratio = h / self._height
        
        if self.resize_proportional and w and h:
            if (xratio * self._height) < h:
                self._height = math.ceil(xratio * self._height)
                self._width = width
            else:
                self._width	= math.ceil(yratio * self._width)
                self._height = height
                
    def get_emu_dimensions(self):
        """ return (x, y, w, h) in EMU """
        
        return (pixels_to_EMU(self.left), pixels_to_EMU(self.top),
            pixels_to_EMU(self._width), pixels_to_EMU(self._height))
        

class Shape(object):
    """ a drawing inside a chart
        coordiantes are specified by the user in the axis units
    """
    
    MARGIN_LEFT = 6 + 13 + 1
    MARGIN_BOTTOM = 17 + 11
    
    FONT_WIDTH = 7
    FONT_HEIGHT = 8
    
    ROUND_RECT = 'roundRect'
    RECT = 'rect'
    
    # other shapes to define :
    '''
    "line"
    "lineInv"
    "triangle"
    "rtTriangle"
    "diamond"
    "parallelogram"
    "trapezoid"
    "nonIsoscelesTrapezoid"
    "pentagon"
    "hexagon"
    "heptagon"
    "octagon"
    "decagon"
    "dodecagon"
    "star4"
    "star5"
    "star6"
    "star7"
    "star8"
    "star10"
    "star12"
    "star16"
    "star24"
    "star32"
    "roundRect"
    "round1Rect"
    "round2SameRect"
    "round2DiagRect"
    "snipRoundRect"
    "snip1Rect"
    "snip2SameRect"
    "snip2DiagRect"
    "plaque"
    "ellipse"
    "teardrop"
    "homePlate"
    "chevron"
    "pieWedge"
    "pie"
    "blockArc"
    "donut"
    "noSmoking"
    "rightArrow"
    "leftArrow"
    "upArrow"
    "downArrow"
    "stripedRightArrow"
    "notchedRightArrow"
    "bentUpArrow"
    "leftRightArrow"
    "upDownArrow"
    "leftUpArrow"
    "leftRightUpArrow"
    "quadArrow"
    "leftArrowCallout"
    "rightArrowCallout"
    "upArrowCallout"
    "downArrowCallout"
    "leftRightArrowCallout"
    "upDownArrowCallout"
    "quadArrowCallout"
    "bentArrow"
    "uturnArrow"
    "circularArrow"
    "leftCircularArrow"
    "leftRightCircularArrow"
    "curvedRightArrow"
    "curvedLeftArrow"
    "curvedUpArrow"
    "curvedDownArrow"
    "swooshArrow"
    "cube"
    "can"
    "lightningBolt"
    "heart"
    "sun"
    "moon"
    "smileyFace"
    "irregularSeal1"
    "irregularSeal2"
    "foldedCorner"
    "bevel"
    "frame"
    "halfFrame"
    "corner"
    "diagStripe"
    "chord"
    "arc"
    "leftBracket"
    "rightBracket"
    "leftBrace"
    "rightBrace"
    "bracketPair"
    "bracePair"
    "straightConnector1"
    "bentConnector2"
    "bentConnector3"
    "bentConnector4"
    "bentConnector5"
    "curvedConnector2"
    "curvedConnector3"
    "curvedConnector4"
    "curvedConnector5"
    "callout1"
    "callout2"
    "callout3"
    "accentCallout1"
    "accentCallout2"
    "accentCallout3"
    "borderCallout1"
    "borderCallout2"
    "borderCallout3"
    "accentBorderCallout1"
    "accentBorderCallout2"
    "accentBorderCallout3"
    "wedgeRectCallout"
    "wedgeRoundRectCallout"
    "wedgeEllipseCallout"
    "cloudCallout"
    "cloud"
    "ribbon"
    "ribbon2"
    "ellipseRibbon"
    "ellipseRibbon2"
    "leftRightRibbon"
    "verticalScroll"
    "horizontalScroll"
    "wave"
    "doubleWave"
    "plus"
    "flowChartProcess"
    "flowChartDecision"
    "flowChartInputOutput"
    "flowChartPredefinedProcess"
    "flowChartInternalStorage"
    "flowChartDocument"
    "flowChartMultidocument"
    "flowChartTerminator"
    "flowChartPreparation"
    "flowChartManualInput"
    "flowChartManualOperation"
    "flowChartConnector"
    "flowChartPunchedCard"
    "flowChartPunchedTape"
    "flowChartSummingJunction"
    "flowChartOr"
    "flowChartCollate"
    "flowChartSort"
    "flowChartExtract"
    "flowChartMerge"
    "flowChartOfflineStorage"
    "flowChartOnlineStorage"
    "flowChartMagneticTape"
    "flowChartMagneticDisk"
    "flowChartMagneticDrum"
    "flowChartDisplay"
    "flowChartDelay"
    "flowChartAlternateProcess"
    "flowChartOffpageConnector"
    "actionButtonBlank"
    "actionButtonHome"
    "actionButtonHelp"
    "actionButtonInformation"
    "actionButtonForwardNext"
    "actionButtonBackPrevious"
    "actionButtonEnd"
    "actionButtonBeginning"
    "actionButtonReturn"
    "actionButtonDocument"
    "actionButtonSound"
    "actionButtonMovie"
    "gear6"
    "gear9"
    "funnel"
    "mathPlus"
    "mathMinus"
    "mathMultiply"
    "mathDivide"
    "mathEqual"
    "mathNotEqual"
    "cornerTabs"
    "squareTabs"
    "plaqueTabs"
    "chartX"
    "chartStar"
    "chartPlus"
    '''
    
    def __init__(self, coordinates=((0,0), (1,1)), text=None, scheme="accent1"):
        
        self.coordinates = coordinates # in axis unit
        self.text = text
        self.scheme = scheme
        self.style = Shape.RECT
        self._border_width = 3175 # in EMU
        self._border_color = Color.BLACK[2:] #"F3B3C5"
        self._color = Color.WHITE[2:]
        self._text_color = Color.BLACK[2:]
            
    def _get_border_color(self):
        return self._border_color
    
    def _set_border_color(self, color):
        self._border_color = short_color(color)
        
    border_color = property(_get_border_color, _set_border_color)
    
    def _get_color(self):
        return self._color
    
    def _set_color(self, color):
        self._color = short_color(color)
            
    color = property(_get_color, _set_color)
    
    def _get_text_color(self):
        return self._text_color
    
    def _set_text_color(self, color):
        self._text_color = short_color(color)
            
    text_color = property(_get_text_color, _set_text_color)
    
    def _get_border_width(self):
        
        return EMU_to_pixels(self._border_width)
    
    def _set_border_width(self, w):
        
        self._border_width = pixels_to_EMU(w)
        print(self._border_width)
        
    border_width = property(_get_border_width, _set_border_width)
        
    def get_coordinates(self):
        """ return shape coordinates in percentages (left, top, right, bottom) """

        (x1, y1), (x2, y2) = self.coordinates
        
        drawing_width = pixels_to_EMU(self._chart.drawing.width)
        drawing_height = pixels_to_EMU(self._chart.drawing.height)
        plot_width = drawing_width * self._chart.width
        plot_height = drawing_height * self._chart.height

        margin_left = self._chart._get_margin_left() * drawing_width
        xunit = plot_width / self._chart.get_x_units()
        
        margin_top = self._chart._get_margin_top() * drawing_height
        yunit = self._chart.get_y_units()
        
        x_start = (margin_left + (float(x1) * xunit)) / drawing_width
        y_start = (margin_top + plot_height - (float(y1) * yunit)) / drawing_height

        x_end = (margin_left + (float(x2) * xunit)) / drawing_width
        y_end = (margin_top + plot_height - (float(y2) * yunit)) / drawing_height
        
        def _norm_pct(pct):
            """ force shapes to appear by truncating too large sizes """
            if pct>1: pct = 1
            elif pct<0: pct = 0
            return pct
        
        # allow user to specify y's in whatever order
        # excel expect y_end to be lower
        if y_end < y_start:
            y_end, y_start = y_start, y_end
        
        return (_norm_pct(x_start), _norm_pct(y_start), 
            _norm_pct(x_end), _norm_pct(y_end))
    
########NEW FILE########
__FILENAME__ = namedrange
# file openpyxl/namedrange.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Track named groups of cells in a worksheet"""

# Python stdlib imports
import re

# package imports
from .shared.exc import NamedRangeException

# constants
NAMED_RANGE_RE = re.compile("'?([^']*)'?!((\$([A-Za-z]+))?\$([0-9]+)(:(\$([A-Za-z]+))?(\$([0-9]+)))?)$")

class NamedRange(object):
    """A named group of cells"""
    __slots__ = ('name', 'destinations', 'local_only')

    def __init__(self, name, destinations):
        self.name = name
        self.destinations = destinations
        self.local_only = False

    def __str__(self):
        return  ','.join(['%s!%s' % (sheet, name) for sheet, name in self.destinations])

    def __repr__(self):

        return '<%s "%s">' % (self.__class__.__name__, str(self))


def split_named_range(range_string):
    """Separate a named range into its component parts"""

    destinations = []

    for range_string in range_string.split(','):

        match = NAMED_RANGE_RE.match(range_string)
        if not match:
            raise NamedRangeException('Invalid named range string: "%s"' % range_string)
        else:
            sheet_name, xlrange = match.groups()[:2]
            destinations.append((sheet_name, xlrange))

    return destinations

########NEW FILE########
__FILENAME__ = excel
# file openpyxl/reader/excel.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Read an xlsx file into Python"""

# Python stdlib imports
from zipfile import ZipFile, ZIP_DEFLATED, BadZipfile

# package imports
from ..shared.exc import OpenModeError, InvalidFileException
from ..shared.ooxml import ARC_SHARED_STRINGS, ARC_CORE, ARC_APP, \
        ARC_WORKBOOK, PACKAGE_WORKSHEETS, ARC_STYLE
from ..workbook import Workbook
from .strings import read_string_table
from .style import read_style_table
from .workbook import read_sheets_titles, read_named_ranges, \
        read_properties_core, get_sheet_ids
from .worksheet import read_worksheet
from .iter_worksheet import unpack_worksheet

def load_workbook(filename, use_iterators = False):
    """Open the given filename and return the workbook

    :param filename: the path to open
    :type filename: string
    
    :param use_iterators: use lazy load for cells
    :type use_iterators: bool

    :rtype: :class:`..workbook.Workbook`
    
    .. note::
        
        When using lazy load, all worksheets will be :class:`.iter_worksheet.IterableWorksheet`
        and the returned workbook will be read-only. 

    """

    try:
        # fileobject must have been opened with 'rb' flag
        # it is required by zipfile
        if 'b' not in filename.mode:
            raise OpenModeError("File-object must be opened in binary mode")
    except AttributeError:
        # filename is not an object
        # it doesn't have mode attribute
        pass

    try:
        archive = ZipFile(filename, 'r', ZIP_DEFLATED)
    except (BadZipfile, RuntimeError, IOError, ValueError) as e:
        raise InvalidFileException(str(e))
    wb = Workbook()

    if use_iterators:
        wb._set_optimized_read()

    try:
        _load_workbook(wb, archive, filename, use_iterators)
    except KeyError as e:
        raise InvalidFileException(str(e))
    except Exception as e:
        raise e
    finally:
        archive.close()
    return wb

def _load_workbook(wb, archive, filename, use_iterators):

    valid_files = archive.namelist()

    # get workbook-level information
    wb.properties = read_properties_core(archive.read(ARC_CORE))
    try:
        string_table = read_string_table(archive.read(ARC_SHARED_STRINGS))
    except KeyError:
        string_table = {}
    style_table = read_style_table(archive.read(ARC_STYLE))

    # get worksheets
    wb.worksheets = []  # remove preset worksheet
    sheet_names = read_sheets_titles(archive.read(ARC_APP))
    for i, sheet_name in enumerate(sheet_names):

        sheet_codename = 'sheet%d.xml' % (i + 1)
        worksheet_path = '%s/%s' % (PACKAGE_WORKSHEETS, sheet_codename)

        if not worksheet_path in valid_files:
            continue

        if not use_iterators:
            new_ws = read_worksheet(archive.read(worksheet_path), wb, sheet_name, string_table, style_table)
        else:
            xml_source = unpack_worksheet(archive, worksheet_path)
            new_ws = read_worksheet(xml_source, wb, sheet_name, string_table, style_table, filename, sheet_codename)
            #new_ws = read_worksheet(archive.read(worksheet_path), wb, sheet_name, string_table, style_table, filename, sheet_codename)
        wb.add_sheet(new_ws, index = i)

    wb._named_ranges = read_named_ranges(archive.read(ARC_WORKBOOK), wb)

########NEW FILE########
__FILENAME__ = iter_worksheet
# file openpyxl/reader/iter_worksheet.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

""" Iterators-based worksheet reader 
*Still very raw*
"""

from io import StringIO
import warnings
import operator
from functools import partial
from itertools import groupby
from ..worksheet import Worksheet
from ..cell import coordinate_from_string, get_column_letter, Cell
from .excel import get_sheet_ids
from .strings import read_string_table
from .style import read_style_table, NumberFormat
from ..shared.date_time import SharedDate
from .worksheet import read_dimension
from ..shared.ooxml import (MIN_COLUMN, MAX_COLUMN, PACKAGE_WORKSHEETS,
    MAX_ROW, MIN_ROW, ARC_SHARED_STRINGS, ARC_APP, ARC_STYLE)
from xml.etree.cElementTree import iterparse
from zipfile import ZipFile
from .. import cell
import re
import tempfile
import zlib
import zipfile
import struct

TYPE_NULL = Cell.TYPE_NULL
MISSING_VALUE = None 

RE_COORDINATE = re.compile('^([A-Z]+)([0-9]+)$')

SHARED_DATE = SharedDate()

_COL_CONVERSION_CACHE = dict((get_column_letter(i), i) for i in range(1, 18279))
def column_index_from_string(str_col, _col_conversion_cache=_COL_CONVERSION_CACHE):
    # we use a function argument to get indexed name lookup
    return _col_conversion_cache[str_col]
del _COL_CONVERSION_CACHE

RAW_ATTRIBUTES = ['row', 'column', 'coordinate', 'internal_value', 'data_type', 'style_id', 'number_format']

try:
    from collections import namedtuple
    BaseRawCell = namedtuple('RawCell', RAW_ATTRIBUTES)
except ImportError:

    warnings.warn("""Unable to import 'namedtuple' module, this may cause  memory issues when using optimized reader. Please upgrade your Python installation to 2.6+""")

    class BaseRawCell(object):

        def __init__(self, *args):
            assert len(args)==len(RAW_ATTRIBUTES)

            for attr, val in zip(RAW_ATTRIBUTES, args):
                setattr(self, attr, val)

        def _replace(self, **kwargs):

            self.__dict__.update(kwargs)

            return self


class RawCell(BaseRawCell):
    """Optimized version of the :class:`..cell.Cell`, using named tuples.

    Useful attributes are:

    * row
    * column
    * coordinate
    * internal_value

    You can also access if needed:

    * data_type
    * number_format

    """

    @property
    def is_date(self):
        res = (self.data_type == Cell.TYPE_NUMERIC
               and self.number_format is not None
               and ('d' in self.number_format 
                    or 'm' in self.number_format
                    or 'y' in self.number_format
                    or 'h' in self.number_format
                    or 's' in self.number_format 
                   ))

        return res

def iter_rows(workbook_name, sheet_name, xml_source, range_string = '', row_offset = 0, column_offset = 0):

    archive = get_archive_file(workbook_name)

    source = xml_source 

    if range_string:
        min_col, min_row, max_col, max_row = get_range_boundaries(range_string, row_offset, column_offset)
    else:
        min_col, min_row, max_col, max_row = read_dimension(xml_source = source)
        min_col = column_index_from_string(min_col)
        max_col = column_index_from_string(max_col) + 1
        max_row += 6

    try:
        string_table = read_string_table(archive.read(ARC_SHARED_STRINGS))
    except KeyError:
        string_table = {}

    style_table = read_style_table(archive.read(ARC_STYLE))

    source.seek(0)
    p = iterparse(source)

    return get_squared_range(p, min_col, min_row, max_col, max_row, string_table, style_table)


def get_rows(p, min_column = MIN_COLUMN, min_row = MIN_ROW, max_column = MAX_COLUMN, max_row = MAX_ROW):

    return groupby(get_cells(p, min_row, min_column, max_row, max_column), operator.attrgetter('row'))

def get_cells(p, min_row, min_col, max_row, max_col, _re_coordinate=RE_COORDINATE):

    for _event, element in p:

        if element.tag == '{http://schemas.openxmlformats.org/spreadsheetml/2006/main}c':
            coord = element.get('r')
            column_str, row = _re_coordinate.match(coord).groups()

            row = int(row)
            column = column_index_from_string(column_str)

            if min_col <= column <= max_col and min_row <= row <= max_row:
                data_type = element.get('t', 'n')
                style_id = element.get('s')
                value = element.findtext('{http://schemas.openxmlformats.org/spreadsheetml/2006/main}v')
                yield RawCell(row, column_str, coord, value, data_type, style_id, None)

        if element.tag == '{http://schemas.openxmlformats.org/spreadsheetml/2006/main}v':
            continue
        element.clear()



def get_range_boundaries(range_string, row = 0, column = 0):

    if ':' in range_string:
        min_range, max_range = range_string.split(':')
        min_col, min_row = coordinate_from_string(min_range)
        max_col, max_row = coordinate_from_string(max_range)

        min_col = column_index_from_string(min_col) + column
        max_col = column_index_from_string(max_col) + column
        min_row += row
        max_row += row

    else:
        min_col, min_row = coordinate_from_string(range_string)
        min_col = column_index_from_string(min_col)
        max_col = min_col + 1
        max_row = min_row 

    return (min_col, min_row, max_col, max_row)

def get_archive_file(archive_name):

    return ZipFile(archive_name, 'r')

def get_xml_source(archive_file, sheet_name):

    return archive_file.read('%s/%s' % (PACKAGE_WORKSHEETS, sheet_name))

def get_missing_cells(row, columns):

    return dict([(column, RawCell(row, column, '%s%s' % (column, row), MISSING_VALUE, TYPE_NULL, None, None)) for column in columns])

def get_squared_range(p, min_col, min_row, max_col, max_row, string_table, style_table):

    expected_columns = [get_column_letter(ci) for ci in range(min_col, max_col)]

    current_row = min_row
    for row, cells in get_rows(p, min_row = min_row, max_row = max_row, min_column = min_col, max_column = max_col):
        full_row = []
        if current_row < row:

            for gap_row in range(current_row, row):

                dummy_cells = get_missing_cells(gap_row, expected_columns)
                
                yield tuple([dummy_cells[column] for column in expected_columns])

                current_row = row

        temp_cells = list(cells)

        retrieved_columns = dict([(c.column, c) for c in temp_cells])

        missing_columns = list(set(expected_columns) - set(retrieved_columns.keys()))

        replacement_columns = get_missing_cells(row, missing_columns)

        for column in expected_columns:

            if column in retrieved_columns:
                cell = retrieved_columns[column]

                if cell.style_id is not None:
                    style = style_table[int(cell.style_id)]
                    cell = cell._replace(number_format = style.number_format.format_code) #pylint: disable-msg=W0212
                if cell.internal_value is not None:
                    if cell.data_type == Cell.TYPE_STRING:
                        cell = cell._replace(internal_value = string_table[int(cell.internal_value)]) #pylint: disable-msg=W0212
                    elif cell.data_type == Cell.TYPE_BOOL:
                        cell = cell._replace(internal_value = cell.internal_value == 'True')
                    elif cell.is_date:
                        cell = cell._replace(internal_value = SHARED_DATE.from_julian(float(cell.internal_value)))
                    elif cell.data_type == Cell.TYPE_NUMERIC:
                        cell = cell._replace(internal_value = float(cell.internal_value))
                full_row.append(cell)

            else:
                full_row.append(replacement_columns[column])

        current_row = row + 1

        yield tuple(full_row)

#------------------------------------------------------------------------------ 

class IterableWorksheet(Worksheet):

    def __init__(self, parent_workbook, title, workbook_name, 
            sheet_codename, xml_source):

        Worksheet.__init__(self, parent_workbook, title)
        self._workbook_name = workbook_name
        self._sheet_codename = sheet_codename
        self._xml_source = xml_source

    def iter_rows(self, range_string = '', row_offset = 0, column_offset = 0):
        """ Returns a squared range based on the `range_string` parameter, 
        using generators.
        
        :param range_string: range of cells (e.g. 'A1:C4')
        :type range_string: string
        
        :param row: row index of the cell (e.g. 4)
        :type row: int

        :param column: column index of the cell (e.g. 3)
        :type column: int
        
        :rtype: generator
        
        """

        return iter_rows(workbook_name = self._workbook_name,
                         sheet_name = self._sheet_codename,
                         xml_source = self._xml_source,
                         range_string = range_string,
                         row_offset = row_offset,
                         column_offset = column_offset)

    def cell(self, *args, **kwargs):

        raise NotImplementedError("use 'iter_rows()' instead")

    def range(self, *args, **kwargs):

        raise NotImplementedError("use 'iter_rows()' instead")

def unpack_worksheet(archive, filename):

    temp_file = tempfile.TemporaryFile(mode='r+', prefix='openpyxl.', suffix='.unpack.temp')

    zinfo = archive.getinfo(filename)

    if zinfo.compress_type == zipfile.ZIP_STORED:
        decoder = None
    elif zinfo.compress_type == zipfile.ZIP_DEFLATED:
        decoder = zlib.decompressobj(-zlib.MAX_WBITS)
    else:
        raise zipfile.BadZipFile("Unrecognized compression method")

    archive.fp.seek(_get_file_offset(archive, zinfo))
    bytes_to_read = zinfo.compress_size

    while True:
        buff = archive.fp.read(min(bytes_to_read, 102400))
        if not buff:
            break
        bytes_to_read -= len(buff)
        if decoder:
            buff = decoder.decompress(buff)
        temp_file.write(buff)

    if decoder:
        temp_file.write(decoder.decompress('Z'))

    return temp_file

def _get_file_offset(archive, zinfo):

    try:
        return zinfo.file_offset
    except AttributeError:
        # From http://stackoverflow.com/questions/3781261/how-to-simulate-zipfile-open-in-python-2-5

        # Seek over the fixed size fields to the "file name length" field in
        # the file header (26 bytes). Unpack this and the "extra field length"
        # field ourselves as info.extra doesn't seem to be the correct length.
        archive.fp.seek(zinfo.header_offset + 26)
        file_name_len, extra_len = struct.unpack("<HH", archive.fp.read(4))
        return zinfo.header_offset + 30 + file_name_len + extra_len

########NEW FILE########
__FILENAME__ = strings
# file openpyxl/reader/strings.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Read the shared strings table."""

# package imports
from ..shared.xmltools import fromstring, QName
from ..shared.ooxml import NAMESPACES


def read_string_table(xml_source):
    """Read in all shared strings in the table"""
    table = {}
    xmlns = 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'
    root = fromstring(text=xml_source)
    string_index_nodes = root.findall(QName(xmlns, 'si').text)
    for index, string_index_node in enumerate(string_index_nodes):
        table[index] = get_string(xmlns, string_index_node)
    return table


def get_string(xmlns, string_index_node):
    """Read the contents of a specific string index"""
    rich_nodes = string_index_node.findall(QName(xmlns, 'r').text)
    if rich_nodes:
        reconstructed_text = []
        for rich_node in rich_nodes:
            partial_text = get_text(xmlns, rich_node)
            reconstructed_text.append(partial_text)
        return ''.join(reconstructed_text)
    else:
        return get_text(xmlns, string_index_node)


def get_text(xmlns, rich_node):
    """Read rich text, discarding formatting if not disallowed"""
    text_node = rich_node.find(QName(xmlns, 't').text)
    partial_text = text_node.text  or ''

    if text_node.get(QName(NAMESPACES['xml'], 'space').text) != 'preserve':
        partial_text = partial_text.strip()
    return str(partial_text)

########NEW FILE########
__FILENAME__ = style
# file openpyxl/reader/style.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Read shared style definitions"""

# package imports
from ..shared.xmltools import fromstring, QName
from ..shared.exc import MissingNumberFormat
from ..style import Style, NumberFormat


def read_style_table(xml_source):
    """Read styles from the shared style table"""
    table = {}
    xmlns = 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'
    root = fromstring(xml_source)
    custom_num_formats = parse_custom_num_formats(root, xmlns)
    builtin_formats = NumberFormat._BUILTIN_FORMATS
    cell_xfs = root.find(QName(xmlns, 'cellXfs').text)
    cell_xfs_nodes = cell_xfs.findall(QName(xmlns, 'xf').text)
    for index, cell_xfs_node in enumerate(cell_xfs_nodes):
        new_style = Style()
        number_format_id = int(cell_xfs_node.get('numFmtId'))
        if number_format_id < 164:
            new_style.number_format.format_code = \
                    builtin_formats.get(number_format_id, 'General')
        else:

            if number_format_id in custom_num_formats:
                new_style.number_format.format_code = \
                        custom_num_formats[number_format_id]
            else:
                raise MissingNumberFormat('%s' % number_format_id)
        table[index] = new_style
    return table


def parse_custom_num_formats(root, xmlns):
    """Read in custom numeric formatting rules from the shared style table"""
    custom_formats = {}
    num_fmts = root.find(QName(xmlns, 'numFmts').text)
    if num_fmts is not None:
        num_fmt_nodes = num_fmts.findall(QName(xmlns, 'numFmt').text)
        for num_fmt_node in num_fmt_nodes:
            custom_formats[int(num_fmt_node.get('numFmtId'))] = \
                    num_fmt_node.get('formatCode')
    return custom_formats

########NEW FILE########
__FILENAME__ = workbook
# file openpyxl/reader/workbook.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Read in global settings to be maintained by the workbook object."""

# package imports
from ..shared.xmltools import fromstring, QName
from ..shared.ooxml import NAMESPACES
from ..workbook import DocumentProperties
from ..shared.date_time import W3CDTF_to_datetime
from ..namedrange import NamedRange, split_named_range

import datetime

# constants
BUGGY_NAMED_RANGES = ['NA()', '#REF!']
DISCARDED_RANGES = ['Excel_BuiltIn', 'Print_Area']

def get_sheet_ids(xml_source):

    sheet_names = read_sheets_titles(xml_source)

    return dict((sheet, 'sheet%d.xml' % (i + 1)) for i, sheet in enumerate(sheet_names))


def read_properties_core(xml_source):
    """Read assorted file properties."""
    properties = DocumentProperties()
    root = fromstring(xml_source)
    creator_node = root.find(QName(NAMESPACES['dc'], 'creator').text)
    if creator_node is not None:
        properties.creator = creator_node.text
    else:
        properties.creator = ''
    last_modified_by_node = root.find(
            QName(NAMESPACES['cp'], 'lastModifiedBy').text)
    if last_modified_by_node is not None:
        properties.last_modified_by = last_modified_by_node.text
    else:
        properties.last_modified_by = ''

    created_node = root.find(QName(NAMESPACES['dcterms'], 'created').text)
    if created_node is not None:
        properties.created = W3CDTF_to_datetime(created_node.text)
    else:
        properties.created = datetime.datetime.now()

    modified_node = root.find(QName(NAMESPACES['dcterms'], 'modified').text)
    if modified_node is not None:
        properties.modified = W3CDTF_to_datetime(modified_node.text)
    else:
        properties.modified = properties.created

    return properties


def get_number_of_parts(xml_source):
    """Get a list of contents of the workbook."""
    parts_size = {}
    parts_names = []
    root = fromstring(xml_source)
    heading_pairs = root.find(QName('http://schemas.openxmlformats.org/officeDocument/2006/extended-properties',
            'HeadingPairs').text)
    vector = heading_pairs.find(QName(NAMESPACES['vt'], 'vector').text)
    children = vector.getchildren()
    for child_id in range(0, len(children), 2):
        part_name = children[child_id].find(QName(NAMESPACES['vt'],
                'lpstr').text).text
        if not part_name in parts_names:
            parts_names.append(part_name)
        part_size = int(children[child_id + 1].find(QName(
                NAMESPACES['vt'], 'i4').text).text)
        parts_size[part_name] = part_size
    return parts_size, parts_names


def read_sheets_titles(xml_source):
    """Read titles for all sheets."""
    root = fromstring(xml_source)
    titles_root = root.find(QName('http://schemas.openxmlformats.org/officeDocument/2006/extended-properties',
            'TitlesOfParts').text)
    vector = titles_root.find(QName(NAMESPACES['vt'], 'vector').text)
    parts, names = get_number_of_parts(xml_source)

    # we can't assume 'Worksheets' to be written in english,
    # but it's always the first item of the parts list (see bug #22)
    size = parts[names[0]]
    children = [c.text for c in vector.getchildren()]
    return children[:size]


def read_named_ranges(xml_source, workbook):
    """Read named ranges, excluding poorly defined ranges."""
    named_ranges = []
    root = fromstring(xml_source)
    names_root = root.find(QName('http://schemas.openxmlformats.org/spreadsheetml/2006/main',
            'definedNames').text)
    if names_root is not None:

        for name_node in names_root.getchildren():
            range_name = name_node.get('name')

            if name_node.get("hidden", '0') == '1':
                continue

            valid = True

            for discarded_range in DISCARDED_RANGES:
                if discarded_range in range_name:
                    valid = False

            for bad_range in BUGGY_NAMED_RANGES:
                if bad_range in name_node.text:
                    valid = False

            if valid:
                destinations = split_named_range(name_node.text)

                new_destinations = []
                for worksheet, cells_range in destinations:

                    # it can happen that a valid named range references
                    # a missing worksheet, when Excel didn't properly maintain
                    # the named range list
                    #
                    # we just ignore them here
                    worksheet = workbook.get_sheet_by_name(worksheet)
                    if worksheet:
                        new_destinations.append((worksheet, cells_range))

                named_range = NamedRange(range_name, new_destinations)
                named_ranges.append(named_range)

    return named_ranges

########NEW FILE########
__FILENAME__ = worksheet
# file openpyxl/reader/worksheet.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Reader for a single worksheet."""

# Python stdlib imports
try:
    from xml.etree.cElementTree import iterparse
except ImportError:
    from xml.etree.ElementTree import iterparse

from io import StringIO

# package imports
from ..cell import Cell, coordinate_from_string
from ..worksheet import Worksheet

def _get_xml_iter(xml_source):

    if not hasattr(xml_source, 'name'): 
        return StringIO(xml_source)
    else:
        xml_source.seek(0)
        return xml_source

def read_dimension(xml_source):

    source = _get_xml_iter(xml_source) 

    it = iterparse(source)

    for event, element in it:

        if element.tag == '{http://schemas.openxmlformats.org/spreadsheetml/2006/main}dimension':
            ref = element.get('ref')
            
            if ':' in ref:
                min_range, max_range = ref.split(':')
            else:
                min_range = max_range = ref

            min_col, min_row = coordinate_from_string(min_range)
            max_col, max_row = coordinate_from_string(max_range)

            return min_col, min_row, max_col, max_row

        else:
            element.clear()

    return None

def filter_cells(xxx_todo_changeme):

    (event, element) = xxx_todo_changeme
    return element.tag == '{http://schemas.openxmlformats.org/spreadsheetml/2006/main}c'

def fast_parse(ws, xml_source, string_table, style_table):

    source = _get_xml_iter(xml_source) 

    it = iterparse(source)

    for event, element in filter(filter_cells, it):

        value = element.findtext('{http://schemas.openxmlformats.org/spreadsheetml/2006/main}v')

        if value is not None:

            coordinate = element.get('r')
            data_type = element.get('t', 'n')
            style_id = element.get('s')

            if data_type == Cell.TYPE_STRING:
                value = string_table.get(int(value))

            ws.cell(coordinate).value = value

            if style_id is not None:
                ws._styles[coordinate] = style_table.get(int(style_id))

        # to avoid memory exhaustion, clear the item after use
        element.clear()

from ..reader.iter_worksheet import IterableWorksheet

def read_worksheet(xml_source, parent, preset_title, string_table,
                   style_table, workbook_name = None, sheet_codename = None):
    """Read an xml worksheet"""
    if workbook_name and sheet_codename:
        ws = IterableWorksheet(parent, preset_title, workbook_name, 
                sheet_codename, xml_source)
    else:
        ws = Worksheet(parent, preset_title)
        fast_parse(ws, xml_source, string_table, style_table)
    return ws

########NEW FILE########
__FILENAME__ = date_time
# file openpyxl/shared/date_time.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Manage Excel date weirdness."""

# Python stdlib imports

from math import floor
import calendar
import datetime
import time
import re

# constants
W3CDTF_FORMAT = '%Y-%m-%dT%H:%M:%SZ'

RE_W3CDTF = '(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(.(\d{2}))?Z'

EPOCH = datetime.datetime.utcfromtimestamp(0)

def datetime_to_W3CDTF(dt):
    """Convert from a datetime to a timestamp string."""
    return datetime.datetime.strftime(dt, W3CDTF_FORMAT)


def W3CDTF_to_datetime(formatted_string):
    """Convert from a timestamp string to a datetime object."""
    match = re.match(RE_W3CDTF,formatted_string)
    digits = list(map(int, match.groups()[:6]))
    return datetime.datetime(*digits)


class SharedDate(object):
    """Date formatting utilities for Excel with shared state.

    Excel has a two primary date tracking schemes:
      Windows - Day 1 == 1900-01-01
      Mac - Day 1 == 1904-01-01

    SharedDate stores which system we are using and converts dates between
    Python and Excel accordingly.

    """
    CALENDAR_WINDOWS_1900 = 1900
    CALENDAR_MAC_1904 = 1904
    datetime_object_type = 'DateTime'

    def __init__(self):
        self.excel_base_date = self.CALENDAR_WINDOWS_1900

    def datetime_to_julian(self, date):
        """Convert from python datetime to excel julian date representation."""

        if isinstance(date, datetime.datetime):
            return self.to_julian(date.year, date.month, date.day, \
                hours=date.hour, minutes=date.minute, seconds=date.second)
        elif isinstance(date, datetime.date):
            return self.to_julian(date.year, date.month, date.day)

    def to_julian(self, year, month, day, hours=0, minutes=0, seconds=0):
        """Convert from Python date to Excel JD."""
        # explicitly disallow bad years
        # Excel 2000 treats JD=0 as 1/0/1900 (buggy, disallow)
        # Excel 2000 treats JD=2958466 as a bad date (Y10K bug!)
        if year < 1900 or year > 10000:
            msg = 'Year not supported by Excel: %s' % year
            raise ValueError(msg)
        if self.excel_base_date == self.CALENDAR_WINDOWS_1900:
            # Fudge factor for the erroneous fact that the year 1900 is
            # treated as a Leap Year in MS Excel.  This affects every date
            # following 28th February 1900
            if year == 1900 and month <= 2:
                excel_1900_leap_year = False
            else:
                excel_1900_leap_year = True
            excel_base_date = 2415020
        else:
            raise NotImplementedError('Mac dates are not yet supported.')
            #excel_base_date = 2416481
            #excel_1900_leap_year = False

        # Julian base date adjustment
        if month > 2:
            month = month - 3
        else:
            month = month + 9
            year -= 1

        # Calculate the Julian Date, then subtract the Excel base date
        # JD 2415020 = 31 - Dec - 1899 -> Excel Date of 0
        century, decade = int(str(year)[:2]), int(str(year)[2:])
        excel_date = floor(146097 * century / 4) + \
                floor((1461 * decade) / 4) + floor((153 * month + 2) / 5) + \
                day + 1721119 - excel_base_date
        if excel_1900_leap_year:
            excel_date += 1

        # check to ensure that we exclude 2/29/1900 as a possible value
        if self.excel_base_date == self.CALENDAR_WINDOWS_1900 \
                and excel_date == 60:
            msg = 'Error: Excel believes 1900 was a leap year'
            raise ValueError(msg)
        excel_time = ((hours * 3600) + (minutes * 60) + seconds) / 86400
        return excel_date + excel_time

    def from_julian(self, value=0):
        """Convert from the Excel JD back to a date"""
        if self.excel_base_date == self.CALENDAR_WINDOWS_1900:
            excel_base_date = 25569
            if value < 60:
                excel_base_date -= 1
            elif value == 60:
                msg = 'Error: Excel believes 1900 was a leap year'
                raise ValueError(msg)
        else:
            raise NotImplementedError('Mac dates are not yet supported.')
            #excel_base_date = 24107

        if value >= 1:
            utc_days = value - excel_base_date

            return EPOCH + datetime.timedelta(days=utc_days)

        elif value >= 0:
            hours = floor(value * 24)
            mins = floor(value * 24 * 60) - floor(hours * 60)
            secs = floor(value * 24 * 60 * 60) - floor(hours * 60 * 60) - \
                    floor(mins * 60)
            return datetime.time(int(hours), int(mins), int(secs))
        else:
            msg = 'Negative dates (%s) are not supported' % value
            raise ValueError(msg)

########NEW FILE########
__FILENAME__ = exc
# file openpyxl/shared/exc.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Definitions for openpyxl shared exception classes."""


class CellCoordinatesException(Exception):
    """Error for converting between numeric and A1-style cell references."""

class ColumnStringIndexException(Exception):
    """Error for bad column names in A1-style cell references."""

class DataTypeException(Exception):
    """Error for any data type inconsistencies."""

class NamedRangeException(Exception):
    """Error for badly formatted named ranges."""

class SheetTitleException(Exception):
    """Error for bad sheet names."""

class InsufficientCoordinatesException(Exception):
    """Error for partially specified cell coordinates."""

class OpenModeError(Exception):
    """Error for fileobj opened in non-binary mode."""

class InvalidFileException(Exception):
    """Error for trying to open a non-ooxml file."""

class ReadOnlyWorkbookException(Exception):
    """Error for trying to modify a read-only workbook"""

class MissingNumberFormat(Exception):
    """Error when a referenced number format is not in the stylesheet"""



########NEW FILE########
__FILENAME__ = ooxml
# file openpyxl/shared/ooxml.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Constants for fixed paths in a file and xml namespace urls."""

MIN_ROW = 0
MIN_COLUMN = 0
MAX_COLUMN = 16384
MAX_ROW = 1048576

# constants
PACKAGE_PROPS = 'docProps'
PACKAGE_XL = 'xl'
PACKAGE_RELS = '_rels'
PACKAGE_THEME = PACKAGE_XL + '/' + 'theme'
PACKAGE_WORKSHEETS = PACKAGE_XL + '/' + 'worksheets'
PACKAGE_DRAWINGS = PACKAGE_XL + '/' + 'drawings'
PACKAGE_CHARTS = PACKAGE_XL + '/' + 'charts'

ARC_CONTENT_TYPES = '[Content_Types].xml'
ARC_ROOT_RELS = PACKAGE_RELS + '/.rels'
ARC_WORKBOOK_RELS = PACKAGE_XL + '/' + PACKAGE_RELS + '/workbook.xml.rels'
ARC_CORE = PACKAGE_PROPS + '/core.xml'
ARC_APP = PACKAGE_PROPS + '/app.xml'
ARC_WORKBOOK = PACKAGE_XL + '/workbook.xml'
ARC_STYLE = PACKAGE_XL + '/styles.xml'
ARC_THEME = PACKAGE_THEME + '/theme1.xml'
ARC_SHARED_STRINGS = PACKAGE_XL + '/sharedStrings.xml'

NAMESPACES = {
    'cp': 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties',
    'dc': 'http://purl.org/dc/elements/1.1/',
    'dcterms': 'http://purl.org/dc/terms/',
    'dcmitype': 'http://purl.org/dc/dcmitype/',
    'xsi': 'http://www.w3.org/2001/XMLSchema-instance',
    'vt': 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes',
    'xml': 'http://www.w3.org/XML/1998/namespace'
}

########NEW FILE########
__FILENAME__ = password_hasher
# file openpyxl/shared/password_hasher.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Basic password hashing."""


def hash_password(plaintext_password=''):
    """Create a password hash from a given string.

    This method is based on the algorithm provided by
    Daniel Rentz of OpenOffice and the PEAR package
    Spreadsheet_Excel_Writer by Xavier Noguer <xnoguer@rezebra.com>.

    """
    password = 0x0000
    i = 1
    for char in plaintext_password:
        value = ord(char) << i
        rotated_bits = value >> 15
        value &= 0x7fff
        password ^= (value | rotated_bits)
        i += 1
    password ^= len(plaintext_password)
    password ^= 0xCE4B
    return str(hex(password)).upper()[2:]

########NEW FILE########
__FILENAME__ = units
# file openpyxl/shared/units.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

import math

def pixels_to_EMU(value):
    return int(round(value * 9525))

def EMU_to_pixels(value):
    if not value:
        return 0
    else:
        return round(value / 9525.) 

def EMU_to_cm(value):
    if not value:
        return 0
    else:
        return (EMU_to_pixels(value) * 2.57 / 96) 

def pixels_to_points(value):
    return value * 0.67777777

def points_to_pixels(value):
    if not value:
        return 0
    else:
        return int(math.ceil(value * 1.333333333)) 

def degrees_to_angle(value):
    return int(round(value * 60000))

def angle_to_degrees(value):
    if not value:
        return 0
    else:
        return round(value / 60000.) 

def short_color(color):
    """ format a color to its short size """

    if len(color) > 6:
        return color[2:]
    else:
        return color

########NEW FILE########
__FILENAME__ = xmltools
# file openpyxl/shared/xmltools.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Shared xml tools.

Shortcut functions taken from:
    http://lethain.com/entry/2009/jan/22/handling-very-large-csv-and-xml-files-in-python/

"""

# Python stdlib imports
from xml.sax.xmlreader import AttributesNSImpl
from xml.sax.saxutils import XMLGenerator
try:
    from xml.etree.ElementTree import ElementTree, Element, SubElement, \
            QName, fromstring, tostring
except ImportError:
    from cElementTree import ElementTree, Element, SubElement, \
            QName, fromstring, tostring

# package imports
from .. import __name__ as prefix


def get_document_content(xml_node):
    """Print nicely formatted xml to a string."""
    pretty_indent(xml_node)
    return tostring(xml_node, 'utf-8')


def pretty_indent(elem, level=0):
    """Format xml with nice indents and line breaks."""
    i = "\n" + level * "  "
    if len(elem):
        if not elem.text or not elem.text.strip():
            elem.text = i + "  "
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
        for elem in elem:
            pretty_indent(elem, level + 1)
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i


def start_tag(doc, name, attr=None, body=None, namespace=None):
    """Wrapper to start an xml tag."""
    if attr is None:
        attr = {}
    attr_vals = {}
    attr_keys = {}
    for key, val in attr.items():
        key_tuple = (namespace, key)
        attr_vals[key_tuple] = val
        attr_keys[key_tuple] = key
    attr2 = AttributesNSImpl(attr_vals, attr_keys)
    doc.startElementNS((namespace, name), name, attr2)
    if body:
        doc.characters(body)


def end_tag(doc, name, namespace=None):
    """Wrapper to close an xml tag."""
    doc.endElementNS((namespace, name), name)


def tag(doc, name, attr=None, body=None, namespace=None):
    """Wrapper to print xml tags and comments."""
    if attr is None:
        attr = {}
    start_tag(doc, name, attr, body, namespace)
    end_tag(doc, name, namespace)

########NEW FILE########
__FILENAME__ = style
# file openpyxl/style.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Style and formatting option tracking."""

# Python stdlib imports
import re
try:
    from hashlib import md5
except ImportError:
    from md5 import md5


class HashableObject(object):
    """Define how to hash property classes."""
    __fields__ = None
    __leaf__ = False

    def __repr__(self):

        return ':'.join([repr(getattr(self, x)) for x in self.__fields__])

    def __hash__(self):

#        return int(md5(repr(self)).hexdigest(), 16)
        return hash(repr(self))

class Color(HashableObject):
    """Named colors for use in styles."""
    BLACK = 'FF000000'
    WHITE = 'FFFFFFFF'
    RED = 'FFFF0000'
    DARKRED = 'FF800000'
    BLUE = 'FF0000FF'
    DARKBLUE = 'FF000080'
    GREEN = 'FF00FF00'
    DARKGREEN = 'FF008000'
    YELLOW = 'FFFFFF00'
    DARKYELLOW = 'FF808000'

    __fields__ = ('index',)
    __slots__ = __fields__
    __leaf__ = True

    def __init__(self, index):
        super(Color, self).__init__()
        self.index = index


class Font(HashableObject):
    """Font options used in styles."""
    UNDERLINE_NONE = 'none'
    UNDERLINE_DOUBLE = 'double'
    UNDERLINE_DOUBLE_ACCOUNTING = 'doubleAccounting'
    UNDERLINE_SINGLE = 'single'
    UNDERLINE_SINGLE_ACCOUNTING = 'singleAccounting'

    __fields__ = ('name',
                  'size',
                  'bold',
                  'italic',
                  'superscript',
                  'subscript',
                  'underline',
                  'strikethrough',
                  'color')
    __slots__ = __fields__

    def __init__(self):
        super(Font, self).__init__()
        self.name = 'Calibri'
        self.size = 11
        self.bold = False
        self.italic = False
        self.superscript = False
        self.subscript = False
        self.underline = self.UNDERLINE_NONE
        self.strikethrough = False
        self.color = Color(Color.BLACK)


class Fill(HashableObject):
    """Area fill patterns for use in styles."""
    FILL_NONE = 'none'
    FILL_SOLID = 'solid'
    FILL_GRADIENT_LINEAR = 'linear'
    FILL_GRADIENT_PATH = 'path'
    FILL_PATTERN_DARKDOWN = 'darkDown'
    FILL_PATTERN_DARKGRAY = 'darkGray'
    FILL_PATTERN_DARKGRID = 'darkGrid'
    FILL_PATTERN_DARKHORIZONTAL = 'darkHorizontal'
    FILL_PATTERN_DARKTRELLIS = 'darkTrellis'
    FILL_PATTERN_DARKUP = 'darkUp'
    FILL_PATTERN_DARKVERTICAL = 'darkVertical'
    FILL_PATTERN_GRAY0625 = 'gray0625'
    FILL_PATTERN_GRAY125 = 'gray125'
    FILL_PATTERN_LIGHTDOWN = 'lightDown'
    FILL_PATTERN_LIGHTGRAY = 'lightGray'
    FILL_PATTERN_LIGHTGRID = 'lightGrid'
    FILL_PATTERN_LIGHTHORIZONTAL = 'lightHorizontal'
    FILL_PATTERN_LIGHTTRELLIS = 'lightTrellis'
    FILL_PATTERN_LIGHTUP = 'lightUp'
    FILL_PATTERN_LIGHTVERTICAL = 'lightVertical'
    FILL_PATTERN_MEDIUMGRAY = 'mediumGray'

    __fields__ = ('fill_type',
                  'rotation',
                  'start_color',
                  'end_color')
    __slots__ = __fields__

    def __init__(self):
        super(Fill, self).__init__()
        self.fill_type = self.FILL_NONE
        self.rotation = 0
        self.start_color = Color(Color.WHITE)
        self.end_color = Color(Color.BLACK)


class Border(HashableObject):
    """Border options for use in styles."""
    BORDER_NONE = 'none'
    BORDER_DASHDOT = 'dashDot'
    BORDER_DASHDOTDOT = 'dashDotDot'
    BORDER_DASHED = 'dashed'
    BORDER_DOTTED = 'dotted'
    BORDER_DOUBLE = 'double'
    BORDER_HAIR = 'hair'
    BORDER_MEDIUM = 'medium'
    BORDER_MEDIUMDASHDOT = 'mediumDashDot'
    BORDER_MEDIUMDASHDOTDOT = 'mediumDashDotDot'
    BORDER_MEDIUMDASHED = 'mediumDashed'
    BORDER_SLANTDASHDOT = 'slantDashDot'
    BORDER_THICK = 'thick'
    BORDER_THIN = 'thin'

    __fields__ = ('border_style',
                  'color')
    __slots__ = __fields__

    def __init__(self):
        super(Border, self).__init__()
        self.border_style = self.BORDER_NONE
        self.color = Color(Color.BLACK)


class Borders(HashableObject):
    """Border positioning for use in styles."""
    DIAGONAL_NONE = 0
    DIAGONAL_UP = 1
    DIAGONAL_DOWN = 2
    DIAGONAL_BOTH = 3

    __fields__ = ('left',
                  'right',
                  'top',
                  'bottom',
                  'diagonal',
                  'diagonal_direction',
                  'all_borders',
                  'outline',
                  'inside',
                  'vertical',
                  'horizontal')
    __slots__ = __fields__

    def __init__(self):
        super(Borders, self).__init__()
        self.left = Border()
        self.right = Border()
        self.top = Border()
        self.bottom = Border()
        self.diagonal = Border()
        self.diagonal_direction = self.DIAGONAL_NONE

        self.all_borders = Border()
        self.outline = Border()
        self.inside = Border()
        self.vertical = Border()
        self.horizontal = Border()


class Alignment(HashableObject):
    """Alignment options for use in styles."""
    HORIZONTAL_GENERAL = 'general'
    HORIZONTAL_LEFT = 'left'
    HORIZONTAL_RIGHT = 'right'
    HORIZONTAL_CENTER = 'center'
    HORIZONTAL_CENTER_CONTINUOUS = 'centerContinuous'
    HORIZONTAL_JUSTIFY = 'justify'
    VERTICAL_BOTTOM = 'bottom'
    VERTICAL_TOP = 'top'
    VERTICAL_CENTER = 'center'
    VERTICAL_JUSTIFY = 'justify'

    __fields__ = ('horizontal',
                  'vertical',
                  'text_rotation',
                  'wrap_text',
                  'shrink_to_fit',
                  'indent')
    __slots__ = __fields__
    __leaf__ = True

    def __init__(self):
        super(Alignment, self).__init__()
        self.horizontal = self.HORIZONTAL_GENERAL
        self.vertical = self.VERTICAL_BOTTOM
        self.text_rotation = 0
        self.wrap_text = False
        self.shrink_to_fit = False
        self.indent = 0


class NumberFormat(HashableObject):
    """Numer formatting for use in styles."""
    FORMAT_GENERAL = 'General'
    FORMAT_TEXT = '@'
    FORMAT_NUMBER = '0'
    FORMAT_NUMBER_00 = '0.00'
    FORMAT_NUMBER_COMMA_SEPARATED1 = '#,##0.00'
    FORMAT_NUMBER_COMMA_SEPARATED2 = '#,##0.00_-'
    FORMAT_PERCENTAGE = '0%'
    FORMAT_PERCENTAGE_00 = '0.00%'
    FORMAT_DATE_YYYYMMDD2 = 'yyyy-mm-dd'
    FORMAT_DATE_YYYYMMDD = 'yy-mm-dd'
    FORMAT_DATE_DDMMYYYY = 'dd/mm/yy'
    FORMAT_DATE_DMYSLASH = 'd/m/y'
    FORMAT_DATE_DMYMINUS = 'd-m-y'
    FORMAT_DATE_DMMINUS = 'd-m'
    FORMAT_DATE_MYMINUS = 'm-y'
    FORMAT_DATE_XLSX14 = 'mm-dd-yy'
    FORMAT_DATE_XLSX15 = 'd-mmm-yy'
    FORMAT_DATE_XLSX16 = 'd-mmm'
    FORMAT_DATE_XLSX17 = 'mmm-yy'
    FORMAT_DATE_XLSX22 = 'm/d/yy h:mm'
    FORMAT_DATE_DATETIME = 'd/m/y h:mm'
    FORMAT_DATE_TIME1 = 'h:mm AM/PM'
    FORMAT_DATE_TIME2 = 'h:mm:ss AM/PM'
    FORMAT_DATE_TIME3 = 'h:mm'
    FORMAT_DATE_TIME4 = 'h:mm:ss'
    FORMAT_DATE_TIME5 = 'mm:ss'
    FORMAT_DATE_TIME6 = 'h:mm:ss'
    FORMAT_DATE_TIME7 = 'i:s.S'
    FORMAT_DATE_TIME8 = 'h:mm:ss@'
    FORMAT_DATE_YYYYMMDDSLASH = 'yy/mm/dd@'
    FORMAT_CURRENCY_USD_SIMPLE = '"$"#,##0.00_-'
    FORMAT_CURRENCY_USD = '$#,##0_-'
    FORMAT_CURRENCY_EUR_SIMPLE = '[$EUR ]#,##0.00_-'
    _BUILTIN_FORMATS = {
        0: 'General',
        1: '0',
        2: '0.00',
        3: '#,##0',
        4: '#,##0.00',

        9: '0%',
        10: '0.00%',
        11: '0.00E+00',
        12: '# ?/?',
        13: '# ??/??',
        14: 'mm-dd-yy',
        15: 'd-mmm-yy',
        16: 'd-mmm',
        17: 'mmm-yy',
        18: 'h:mm AM/PM',
        19: 'h:mm:ss AM/PM',
        20: 'h:mm',
        21: 'h:mm:ss',
        22: 'm/d/yy h:mm',

        37: '#,##0 (#,##0)',
        38: '#,##0 [Red](#,##0)',
        39: '#,##0.00(#,##0.00)',
        40: '#,##0.00[Red](#,##0.00)',

        41: '_(* #,##0_);_(* \(#,##0\);_(* "-"_);_(@_)',
        42: '_("$"* #,##0_);_("$"* \(#,##0\);_("$"* "-"_);_(@_)',
        43: '_(* #,##0.00_);_(* \(#,##0.00\);_(* "-"??_);_(@_)',

        44: '_("$"* #,##0.00_)_("$"* \(#,##0.00\)_("$"* "-"??_)_(@_)',
        45: 'mm:ss',
        46: '[h]:mm:ss',
        47: 'mmss.0',
        48: '##0.0E+0',
        49: '@', }
    _BUILTIN_FORMATS_REVERSE = dict(
            [(value, key) for key, value in _BUILTIN_FORMATS.items()])

    __fields__ = ('_format_code',
                  '_format_index')
    __slots__ = __fields__
    __leaf__ = True

    DATE_INDICATORS = 'dmyhs'

    def __init__(self):
        super(NumberFormat, self).__init__()
        self._format_code = self.FORMAT_GENERAL
        self._format_index = 0

    def _set_format_code(self, format_code = FORMAT_GENERAL):
        """Setter for the format_code property."""
        self._format_code = format_code
        self._format_index = self.builtin_format_id(format = format_code)

    def _get_format_code(self):
        """Getter for the format_code property."""
        return self._format_code

    format_code = property(_get_format_code, _set_format_code)

    def builtin_format_code(self, index):
        """Return one of the standard format codes by index."""
        return self._BUILTIN_FORMATS[index]

    def is_builtin(self, format = None):
        """Check if a format code is a standard format code."""
        if format is None:
            format = self._format_code
        return format in list(self._BUILTIN_FORMATS.values())

    def builtin_format_id(self, format):
        """Return the id of a standard style."""
        return self._BUILTIN_FORMATS_REVERSE.get(format, None)

    def is_date_format(self, format = None):
        """Check if the number format is actually representing a date."""
        if format is None:
            format = self._format_code

        return any([x in format for x in self.DATE_INDICATORS])

class Protection(HashableObject):
    """Protection options for use in styles."""
    PROTECTION_INHERIT = 'inherit'
    PROTECTION_PROTECTED = 'protected'
    PROTECTION_UNPROTECTED = 'unprotected'

    __fields__ = ('locked',
                  'hidden')
    __slots__ = __fields__
    __leaf__ = True

    def __init__(self):
        super(Protection, self).__init__()
        self.locked = self.PROTECTION_INHERIT
        self.hidden = self.PROTECTION_INHERIT


class Style(HashableObject):
    """Style object containing all formatting details."""
    __fields__ = ('font',
                  'fill',
                  'borders',
                  'alignment',
                  'number_format',
                  'protection')
    __slots__ = __fields__

    def __init__(self):
        super(Style, self).__init__()
        self.font = Font()
        self.fill = Fill()
        self.borders = Borders()
        self.alignment = Alignment()
        self.number_format = NumberFormat()
        self.protection = Protection()

DEFAULTS = Style()

########NEW FILE########
__FILENAME__ = workbook
# file openpyxl/workbook.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Workbook is the top-level container for all document information."""

__docformat__ = "restructuredtext en"

# Python stdlib imports
import datetime
import os

# package imports
from .worksheet import Worksheet
from .writer.dump_worksheet import DumpWorksheet, save_dump
from .writer.strings import StringTableBuilder
from .namedrange import NamedRange
from .style import Style
from .writer.excel import save_workbook
from .shared.exc import ReadOnlyWorkbookException


class DocumentProperties(object):
    """High-level properties of the document."""

    def __init__(self):
        self.creator = 'Unknown'
        self.last_modified_by = self.creator
        self.created = datetime.datetime.now()
        self.modified = datetime.datetime.now()
        self.title = 'Untitled'
        self.subject = ''
        self.description = ''
        self.keywords = ''
        self.category = ''
        self.company = 'Microsoft Corporation'


class DocumentSecurity(object):
    """Security information about the document."""

    def __init__(self):
        self.lock_revision = False
        self.lock_structure = False
        self.lock_windows = False
        self.revision_password = ''
        self.workbook_password = ''


class Workbook(object):
    """Workbook is the container for all other parts of the document."""

    def __init__(self, optimized_write = False):
        self.worksheets = []
        self._active_sheet_index = 0
        self._named_ranges = []
        self.properties = DocumentProperties()
        self.style = Style()
        self.security = DocumentSecurity()
        self.__optimized_write = optimized_write
        self.__optimized_read = False
        self.strings_table_builder = StringTableBuilder()

        if not optimized_write:
            self.worksheets.append(Worksheet(self))

    def _set_optimized_read(self):
        self.__optimized_read = True

    def get_active_sheet(self):
        """Returns the current active sheet."""
        return self.worksheets[self._active_sheet_index]

    def create_sheet(self, index = None):
        """Create a worksheet (at an optional index).

        :param index: optional position at which the sheet will be inserted
        :type index: int

        """

        if self.__optimized_read:
            raise ReadOnlyWorkbookException('Cannot create new sheet in a read-only workbook')

        if self.__optimized_write :
            new_ws = DumpWorksheet(parent_workbook = self)
        else:
            new_ws = Worksheet(parent_workbook = self)

        self.add_sheet(worksheet = new_ws, index = index)
        return new_ws

    def add_sheet(self, worksheet, index = None):
        """Add an existing worksheet (at an optional index)."""
        if index is None:
            index = len(self.worksheets)
        self.worksheets.insert(index, worksheet)

    def remove_sheet(self, worksheet):
        """Remove a worksheet from this workbook."""
        self.worksheets.remove(worksheet)

    def get_sheet_by_name(self, name):
        """Returns a worksheet by its name.

        Returns None if no worksheet has the name specified.

        :param name: the name of the worksheet to look for
        :type name: string

        """
        requested_sheet = None
        for sheet in self.worksheets:
            if sheet.title == name:
                requested_sheet = sheet
                break
        return requested_sheet

    def get_index(self, worksheet):
        """Return the index of the worksheet."""
        return self.worksheets.index(worksheet)

    def get_sheet_names(self):
        """Returns the list of the names of worksheets in the workbook.

        Names are returned in the worksheets order.

        :rtype: list of strings

        """
        return [s.title for s in self.worksheets]

    def create_named_range(self, name, worksheet, range):
        """Create a new named_range on a worksheet"""
        assert isinstance(worksheet, Worksheet)
        named_range = NamedRange(name, [(worksheet, range)])
        self.add_named_range(named_range)

    def get_named_ranges(self):
        """Return all named ranges"""
        return self._named_ranges

    def add_named_range(self, named_range):
        """Add an existing named_range to the list of named_ranges."""
        self._named_ranges.append(named_range)

    def get_named_range(self, name):
        """Return the range specified by name."""
        requested_range = None
        for named_range in self._named_ranges:
            if named_range.name == name:
                requested_range = named_range
                break
        return requested_range

    def remove_named_range(self, named_range):
        """Remove a named_range from this workbook."""
        self._named_ranges.remove(named_range)

    def save(self, filename):
        """ shortcut """
        if self.__optimized_write:
            save_dump(self, filename)
        else:
            save_workbook(self, filename)

########NEW FILE########
__FILENAME__ = worksheet
# file openpyxl/worksheet.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Worksheet is the 2nd-level container in Excel."""

# Python stdlib imports
import re

# package imports
from . import cell
from .cell import coordinate_from_string, \
    column_index_from_string, get_column_letter
from .shared.exc import SheetTitleException, \
    InsufficientCoordinatesException, CellCoordinatesException, \
    NamedRangeException
from .shared.password_hasher import hash_password
from .style import Style, DEFAULTS as DEFAULTS_STYLE
from .drawing import Drawing

_DEFAULTS_STYLE_HASH = hash(DEFAULTS_STYLE)

def flatten(results):

    rows = []

    for row in results:

        cells = []

        for cell in row:

            cells.append(cell.value)

        rows.append(tuple(cells))

    return tuple(rows)


class Relationship(object):
    """Represents many kinds of relationships."""
    # TODO: Use this object for workbook relationships as well as
    # worksheet relationships
    TYPES = {
        'hyperlink': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink',
        'drawing':'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',
        #'worksheet': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',
        #'sharedStrings': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',
        #'styles': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',
        #'theme': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme',
    }

    def __init__(self, rel_type):
        if rel_type not in self.TYPES:
            raise ValueError("Invalid relationship type %s" % rel_type)
        self.type = self.TYPES[rel_type]
        self.target = ""
        self.target_mode = ""
        self.id = ""


class PageSetup(object):
    """Information about page layout for this sheet"""
    pass


class HeaderFooter(object):
    """Information about the header/footer for this sheet."""
    pass


class SheetView(object):
    """Information about the visible portions of this sheet."""
    pass


class RowDimension(object):
    """Information about the display properties of a row."""
    __slots__ = ('row_index',
                 'height',
                 'visible',
                 'outline_level',
                 'collapsed',
                 'style_index',)

    def __init__(self, index = 0):
        self.row_index = index
        self.height = -1
        self.visible = True
        self.outline_level = 0
        self.collapsed = False
        self.style_index = None


class ColumnDimension(object):
    """Information about the display properties of a column."""
    __slots__ = ('column_index',
                 'width',
                 'auto_size',
                 'visible',
                 'outline_level',
                 'collapsed',
                 'style_index',)

    def __init__(self, index = 'A'):
        self.column_index = index
        self.width = -1
        self.auto_size = False
        self.visible = True
        self.outline_level = 0
        self.collapsed = False
        self.style_index = 0


class PageMargins(object):
    """Information about page margins for view/print layouts."""

    def __init__(self):
        self.left = self.right = 0.7
        self.top = self.bottom = 0.75
        self.header = self.footer = 0.3


class SheetProtection(object):
    """Information about protection of various aspects of a sheet."""

    def __init__(self):
        self.sheet = False
        self.objects = False
        self.scenarios = False
        self.format_cells = False
        self.format_columns = False
        self.format_rows = False
        self.insert_columns = False
        self.insert_rows = False
        self.insert_hyperlinks = False
        self.delete_columns = False
        self.delete_rows = False
        self.select_locked_cells = False
        self.sort = False
        self.auto_filter = False
        self.pivot_tables = False
        self.select_unlocked_cells = False
        self._password = ''

    def set_password(self, value = '', already_hashed = False):
        """Set a password on this sheet."""
        if not already_hashed:
            value = hash_password(value)
        self._password = value

    def _set_raw_password(self, value):
        """Set a password directly, forcing a hash step."""
        self.set_password(value, already_hashed = False)

    def _get_raw_password(self):
        """Return the password value, regardless of hash."""
        return self._password

    password = property(_get_raw_password, _set_raw_password,
            'get/set the password (if already hashed, '
            'use set_password() instead)')


class Worksheet(object):
    """Represents a worksheet.

    Do not create worksheets yourself,
    use :func:`.workbook.Workbook.create_sheet` instead

    """
    BREAK_NONE = 0
    BREAK_ROW = 1
    BREAK_COLUMN = 2

    SHEETSTATE_VISIBLE = 'visible'
    SHEETSTATE_HIDDEN = 'hidden'
    SHEETSTATE_VERYHIDDEN = 'veryHidden'

    def __init__(self, parent_workbook, title = 'Sheet'):
        self._parent = parent_workbook
        self._title = ''
        if not title:
            self.title = 'Sheet%d' % (1 + len(self._parent.worksheets))
        else:
            self.title = title
        self.row_dimensions = {}
        self.column_dimensions = {}
        self._cells = {}
        self._styles = {}
        self._charts = []
        self.relationships = []
        self.selected_cell = 'A1'
        self.active_cell = 'A1'
        self.sheet_state = self.SHEETSTATE_VISIBLE
        self.page_setup = PageSetup()
        self.page_margins = PageMargins()
        self.header_footer = HeaderFooter()
        self.sheet_view = SheetView()
        self.protection = SheetProtection()
        self.show_gridlines = True
        self.print_gridlines = False
        self.show_summary_below = True
        self.show_summary_right = True
        self.default_row_dimension = RowDimension()
        self.default_column_dimension = ColumnDimension()
        self._auto_filter = None
        self._freeze_panes = None

    def __repr__(self):
        return '<Worksheet "%s">' % self.title

    def garbage_collect(self):
        """Delete cells that are not storing a value."""
        delete_list = [coordinate for coordinate, cell in \
            self._cells.items() if (cell.value in ('', None) and \
            hash(cell.style) == _DEFAULTS_STYLE_HASH)]
        for coordinate in delete_list:
            del self._cells[coordinate]

    def get_cell_collection(self):
        """Return an unordered list of the cells in this worksheet."""
        return list(self._cells.values())

    def _set_title(self, value):
        """Set a sheet title, ensuring it is valid."""
        bad_title_char_re = re.compile(r'[\\*?:/\[\]]')
        if bad_title_char_re.search(value):
            msg = 'Invalid character found in sheet title'
            raise SheetTitleException(msg)

        # check if sheet_name already exists
        # do this *before* length check
        if self._parent.get_sheet_by_name(value):
            # use name, but append with lowest possible integer
            i = 1
            while self._parent.get_sheet_by_name('%s%d' % (value, i)):
                i += 1
            value = '%s%d' % (value, i)
        if len(value) > 31:
            msg = 'Maximum 31 characters allowed in sheet title'
            raise SheetTitleException(msg)
        self._title = value

    def _get_title(self):
        """Return the title for this sheet."""
        return self._title

    title = property(_get_title, _set_title, doc =
                     'Get or set the title of the worksheet. '
                     'Limited to 31 characters, no special characters.')

    def _set_auto_filter(self, range):
        # Normalize range to a str or None
        if not range:
            range = None
        elif isinstance(range, str):
            range = range.upper()
        else: # Assume a range
            range = range[0][0].address + ':' + range[-1][-1].address
        self._auto_filter = range

    def _get_auto_filter(self):
        return self._auto_filter

    auto_filter = property(_get_auto_filter, _set_auto_filter, doc =
                           'get or set auto filtering on columns')
    def _set_freeze_panes(self, topLeftCell):
        if not topLeftCell:
            topLeftCell = None
        elif isinstance(topLeftCell, str):
            topLeftCell = topLeftCell.upper()
        else: # Assume a cell
            topLeftCell = topLeftCell.address
        if topLeftCell == 'A1':
            topLeftCell = None
        self._freeze_panes = topLeftCell

    def _get_freeze_panes(self):
        return self._freeze_panes

    freeze_panes = property(_get_freeze_panes,_set_freeze_panes, doc =
                           "Get or set frozen panes")

    def cell(self, coordinate = None, row = None, column = None):
        """Returns a cell object based on the given coordinates.

        Usage: cell(coodinate='A15') **or** cell(row=15, column=1)

        If `coordinates` are not given, then row *and* column must be given.

        Cells are kept in a dictionary which is empty at the worksheet
        creation.  Calling `cell` creates the cell in memory when they
        are first accessed, to reduce memory usage.

        :param coordinate: coordinates of the cell (e.g. 'B12')
        :type coordinate: string

        :param row: row index of the cell (e.g. 4)
        :type row: int

        :param column: column index of the cell (e.g. 3)
        :type column: int

        :raise: InsufficientCoordinatesException when coordinate or (row and column) are not given

        :rtype: :class:`.cell.Cell`

        """
        if not coordinate:
            if  (row is None or column is None):
                msg = "You have to provide a value either for " \
                        "'coordinate' or for 'row' *and* 'column'"
                raise InsufficientCoordinatesException(msg)
            else:
                coordinate = '%s%s' % (get_column_letter(column + 1), row + 1)
        else:
            coordinate = coordinate.replace('$', '')

        return self._get_cell(coordinate)

    def _get_cell(self, coordinate):

        if not coordinate in self._cells:
            column, row = coordinate_from_string(coordinate)
            new_cell = cell.Cell(self, column, row)
            self._cells[coordinate] = new_cell
            if column not in self.column_dimensions:
                self.column_dimensions[column] = ColumnDimension(column)
            if row not in self.row_dimensions:
                self.row_dimensions[row] = RowDimension(row)
        return self._cells[coordinate]

    def get_highest_row(self):
        """Returns the maximum row index containing data
        
        :rtype: int
        """
        if self.row_dimensions:
            return max(self.row_dimensions.keys())
        else:
            return 1

    def get_highest_column(self):
        """Get the largest value for column currently stored.
        
        :rtype: int
        """
        if self.column_dimensions:
            return max([column_index_from_string(column_index)
                            for column_index in self.column_dimensions])
        else:
            return 1

    def calculate_dimension(self):
        """Return the minimum bounding range for all cells containing data."""
        return 'A1:%s%d' % (get_column_letter(self.get_highest_column()),
                            self.get_highest_row())

    def range(self, range_string, row = 0, column = 0):
        """Returns a 2D array of cells, with optional row and column offsets.

        :param range_string: cell range string or `named range` name
        :type range_string: string

        :param row: number of rows to offset
        :type row: int

        :param column: number of columns to offset
        :type column: int

        :rtype: tuples of tuples of :class:`.cell.Cell`

        """
        if ':' in range_string:
            # R1C1 range
            result = []
            min_range, max_range = range_string.split(':')
            min_col, min_row = coordinate_from_string(min_range)
            max_col, max_row = coordinate_from_string(max_range)
            if column:
                min_col = get_column_letter(
                        column_index_from_string(min_col) + column)
                max_col = get_column_letter(
                        column_index_from_string(max_col) + column)
            min_col = column_index_from_string(min_col)
            max_col = column_index_from_string(max_col)
            cache_cols = {}
            for col in range(min_col, max_col + 1):
                cache_cols[col] = get_column_letter(col)
            rows = range(min_row + row, max_row + row + 1)
            cols = range(min_col, max_col + 1)
            for row in rows:
                new_row = []
                for col in cols:
                    new_row.append(self.cell('%s%s' % (cache_cols[col], row)))
                result.append(tuple(new_row))
            return tuple(result)
        else:
            try:
                return self.cell(coordinate = range_string, row = row,
                        column = column)
            except CellCoordinatesException:
                pass

            # named range
            named_range = self._parent.get_named_range(range_string)
            if named_range is None:
                msg = '%s is not a valid range name' % range_string
                raise NamedRangeException(msg)

            result = []
            for destination in named_range.destinations:

                worksheet, cells_range = destination

                if worksheet is not self:
                    msg = 'Range %s is not defined on worksheet %s' % \
                            (cells_range, self.title)
                    raise NamedRangeException(msg)

                content = self.range(cells_range)

                if isinstance(content, tuple):
                    for cells in content:
                        result.extend(cells)
                else:
                    result.append(content)

            if len(result) == 1:
                return result[0]
            else:
                return tuple(result)

    def get_style(self, coordinate):
        """Return the style object for the specified cell."""
        if not coordinate in self._styles:
            self._styles[coordinate] = Style()
        return self._styles[coordinate]

    def create_relationship(self, rel_type):
        """Add a relationship for this sheet."""
        rel = Relationship(rel_type)
        self.relationships.append(rel)
        rel_id = self.relationships.index(rel)
        rel.id = 'rId' + str(rel_id + 1)
        return self.relationships[rel_id]

    def add_chart(self, chart):
        """ Add a chart to the sheet """

        chart._sheet = self
        self._charts.append(chart)

    def append(self, list_or_dict):
        """Appends a group of values at the bottom of the current sheet.
        
        * If it's a list: all values are added in order, starting from the first column
        * If it's a dict: values are assigned to the columns indicated by the keys (numbers or letters)
        
        :param list_or_dict: list or dict containing values to append
        :type list_or_dict: list/tuple or dict
        
        Usage:
        
        * append(['This is A1', 'This is B1', 'This is C1'])
        * **or** append({'A' : 'This is A1', 'C' : 'This is C1'})
        * **or** append({0 : 'This is A1', 2 : 'This is C1'})
        
        :raise: TypeError when list_or_dict is neither a list/tuple nor a dict
        
        """

        row_idx = len(self.row_dimensions)

        if isinstance(list_or_dict, (list, tuple)):

            for col_idx, content in enumerate(list_or_dict):

                self.cell(row = row_idx, column = col_idx).value = content

        elif isinstance(list_or_dict, dict):

            for col_idx, content in list_or_dict.items():

                if isinstance(col_idx, str):
                    col_idx = column_index_from_string(col_idx) - 1

                self.cell(row = row_idx, column = col_idx).value = content

        else:
            raise TypeError('list_or_dict must be a list or a dict')

    @property
    def rows(self):

        return self.range(self.calculate_dimension())

    @property
    def columns(self):

        max_row = self.get_highest_row()

        cols = []

        for col_idx in range(self.get_highest_column()):
            col = get_column_letter(col_idx+1)
            res = self.range('%s1:%s%d' % (col, col, max_row))
            cols.append(tuple([x[0] for x in res]))


        return tuple(cols)


########NEW FILE########
__FILENAME__ = charts
# coding=UTF-8
'''
Copyright (c) 2010 openpyxl

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license: http://www.opensource.org/licenses/mit-license.php
@author: Eric Gazoni
'''

from ..shared.xmltools import Element, SubElement, get_document_content
from ..chart import Chart, ErrorBar


class ChartWriter(object):
    
    def __init__(self, chart):
        self.chart = chart
        
    def write(self):
        """ write a chart """
        
        root = Element('c:chartSpace', 
            {'xmlns:c':"http://schemas.openxmlformats.org/drawingml/2006/chart",
             'xmlns:a':"http://schemas.openxmlformats.org/drawingml/2006/main",
             'xmlns:r':"http://schemas.openxmlformats.org/officeDocument/2006/relationships"})
        
        SubElement(root, 'c:lang', {'val':self.chart.lang})
        self._write_chart(root)
        self._write_print_settings(root)
        self._write_shapes(root)

        return get_document_content(root)
        
    def _write_chart(self, root):
        
        chart = self.chart
        
        ch = SubElement(root, 'c:chart')
        self._write_title(ch)
        plot_area = SubElement(ch, 'c:plotArea')
        layout = SubElement(plot_area, 'c:layout')
        mlayout = SubElement(layout, 'c:manualLayout')
        SubElement(mlayout, 'c:layoutTarget', {'val':'inner'})
        SubElement(mlayout, 'c:xMode', {'val':'edge'})
        SubElement(mlayout, 'c:yMode', {'val':'edge'})
        SubElement(mlayout, 'c:x', {'val':str(chart._get_margin_left())})
        SubElement(mlayout, 'c:y', {'val':str(chart._get_margin_top())})
        SubElement(mlayout, 'c:w', {'val':str(chart.width)})
        SubElement(mlayout, 'c:h', {'val':str(chart.height)})
        
        if chart.type == Chart.SCATTER_CHART:
            subchart = SubElement(plot_area, 'c:scatterChart')
            SubElement(subchart, 'c:scatterStyle', {'val':str('lineMarker')})
        else:
            if chart.type == Chart.BAR_CHART:
                subchart = SubElement(plot_area, 'c:barChart')
                SubElement(subchart, 'c:barDir', {'val':'col'})
            else:
                subchart = SubElement(plot_area, 'c:lineChart')
                
            SubElement(subchart, 'c:grouping', {'val':chart.grouping})
        
        self._write_series(subchart)
        
        SubElement(subchart, 'c:marker', {'val':'1'})
        SubElement(subchart, 'c:axId', {'val':str(chart.x_axis.id)})
        SubElement(subchart, 'c:axId', {'val':str(chart.y_axis.id)})
        
        if chart.type == Chart.SCATTER_CHART:
            self._write_axis(plot_area, chart.x_axis, 'c:valAx')
        else:
            self._write_axis(plot_area, chart.x_axis, 'c:catAx')
        self._write_axis(plot_area, chart.y_axis, 'c:valAx')
        
        self._write_legend(ch)
        
        SubElement(ch, 'c:plotVisOnly', {'val':'1'})

    def _write_title(self, chart):
        if self.chart.title != '':
            title = SubElement(chart, 'c:title')
            tx = SubElement(title, 'c:tx')
            rich = SubElement(tx, 'c:rich')
            SubElement(rich, 'a:bodyPr')
            SubElement(rich, 'a:lstStyle')
            p = SubElement(rich, 'a:p')
            pPr = SubElement(p, 'a:pPr')
            SubElement(pPr, 'a:defRPr')
            r = SubElement(p, 'a:r')
            SubElement(r, 'a:rPr', {'lang':self.chart.lang})
            t = SubElement(r, 'a:t').text = self.chart.title
            SubElement(title, 'c:layout')

    def _write_axis(self, plot_area, axis, label):
        
        ax = SubElement(plot_area, label)
        SubElement(ax, 'c:axId', {'val':str(axis.id)})
        
        scaling = SubElement(ax, 'c:scaling')
        SubElement(scaling, 'c:orientation', {'val':axis.orientation})
        if label == 'c:valAx':
            SubElement(scaling, 'c:max', {'val':str(axis.max)})
            SubElement(scaling, 'c:min', {'val':str(axis.min)})
        
        SubElement(ax, 'c:axPos', {'val':axis.position})
        if label == 'c:valAx':
            SubElement(ax, 'c:majorGridlines')
            SubElement(ax, 'c:numFmt', {'formatCode':"General", 'sourceLinked':'1'})
        SubElement(ax, 'c:tickLblPos', {'val':axis.tick_label_position})
        SubElement(ax, 'c:crossAx', {'val':str(axis.cross)})
        SubElement(ax, 'c:crosses', {'val':axis.crosses})
        if axis.auto:
            SubElement(ax, 'c:auto', {'val':'1'})
        if axis.label_align:
            SubElement(ax, 'c:lblAlgn', {'val':axis.label_align})
        if axis.label_offset:
            SubElement(ax, 'c:lblOffset', {'val':str(axis.label_offset)})
        if label == 'c:valAx':
            if self.chart.type == Chart.SCATTER_CHART:
                SubElement(ax, 'c:crossBetween', {'val':'midCat'})
            else:
                SubElement(ax, 'c:crossBetween', {'val':'between'})
            SubElement(ax, 'c:majorUnit', {'val':str(axis.unit)})
        
    def _write_series(self, subchart):
        
        for i, serie in enumerate(self.chart._series):
            ser = SubElement(subchart, 'c:ser')
            SubElement(ser, 'c:idx', {'val':str(i)})
            SubElement(ser, 'c:order', {'val':str(i)})
            
            if serie.legend:
                tx = SubElement(ser, 'c:tx')
                self._write_serial(tx, serie.legend)
            
            if serie.color:
                sppr = SubElement(ser, 'c:spPr')
                if self.chart.type == Chart.BAR_CHART:
                    # fill color
                    fillc = SubElement(sppr, 'a:solidFill')
                    SubElement(fillc, 'a:srgbClr', {'val':serie.color})
                # edge color
                ln = SubElement(sppr, 'a:ln')
                fill = SubElement(ln, 'a:solidFill')
                SubElement(fill, 'a:srgbClr', {'val':serie.color})
          
            if serie.error_bar:
                self._write_error_bar(ser, serie)
                
            marker = SubElement(ser, 'c:marker')
            SubElement(marker, 'c:symbol', {'val':serie.marker})

            if serie.labels:
                cat = SubElement(ser, 'c:cat')
                self._write_serial(cat, serie.labels)
            
            if self.chart.type == Chart.SCATTER_CHART:
                if serie.xvalues:
                    xval = SubElement(ser, 'c:xVal')
                    self._write_serial(xval, serie.xvalues)

                yval = SubElement(ser, 'c:yVal')
                self._write_serial(yval, serie.values)
            else:
                val = SubElement(ser, 'c:val')
                self._write_serial(val, serie.values)
                
    def _write_serial(self, node, serie, literal=False):

        cache = serie._get_cache()
        if isinstance(cache[0], str):
            typ = 'str'
        else:
            typ = 'num'
        
        if not literal:
            if typ == 'num':
                ref = SubElement(node, 'c:numRef')
            else:
                ref = SubElement(node, 'c:strRef')
            SubElement(ref, 'c:f').text = serie._get_ref()
            if typ == 'num':
                data = SubElement(ref, 'c:numCache')
            else:
                data = SubElement(ref, 'c:strCache')
        else:
            data = SubElement(node, 'c:numLit')

        if typ == 'num':
            SubElement(data, 'c:formatCode').text = 'General'
        if literal:
            values = (1,)
        else:
            values = cache
            
        SubElement(data, 'c:ptCount', {'val':str(len(values))})
        for j, val in enumerate(values):
            point = SubElement(data, 'c:pt', {'idx':str(j)})
            SubElement(point, 'c:v').text = str(val)

    def _write_error_bar(self, node, serie):
        
        flag = {ErrorBar.PLUS_MINUS:'both', 
                ErrorBar.PLUS:'plus', 
                ErrorBar.MINUS:'minus'}
                
        eb = SubElement(node, 'c:errBars')
        SubElement(eb, 'c:errBarType', {'val':flag[serie.error_bar.type]})
        SubElement(eb, 'c:errValType', {'val':'cust'})
        
        plus = SubElement(eb, 'c:plus')
        self._write_serial(plus, serie.error_bar.values,
            literal=(serie.error_bar.type==ErrorBar.MINUS))
        
        minus = SubElement(eb, 'c:minus')
        self._write_serial(minus, serie.error_bar.values,
            literal=(serie.error_bar.type==ErrorBar.PLUS))
        
    def _write_legend(self, chart):
        
        legend = SubElement(chart, 'c:legend')
        SubElement(legend, 'c:legendPos', {'val':self.chart.legend.position})
        SubElement(legend, 'c:layout')
        
    def _write_print_settings(self, root):
        
        settings = SubElement(root, 'c:printSettings')
        SubElement(settings, 'c:headerFooter')
        margins = dict([(k, str(v)) for (k,v) in self.chart.print_margins.items()])
        SubElement(settings, 'c:pageMargins', margins)
        SubElement(settings, 'c:pageSetup')
        
    def _write_shapes(self, root):
        
        if self.chart._shapes:
            SubElement(root, 'c:userShapes', {'r:id':'rId1'})
            
    def write_rels(self, drawing_id):
        
        root = Element('Relationships', {'xmlns' : 'http://schemas.openxmlformats.org/package/2006/relationships'})
        attrs = {'Id' : 'rId1',
            'Type' : 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartUserShapes',
            'Target' : '../drawings/drawing%s.xml' % drawing_id }
        SubElement(root, 'Relationship', attrs)
        return get_document_content(root)

########NEW FILE########
__FILENAME__ = drawings
# coding=UTF-8
'''
Copyright (c) 2010 openpyxl

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license: http://www.opensource.org/licenses/mit-license.php
@author: Eric Gazoni
'''

from ..shared.xmltools import Element, SubElement, get_document_content


class DrawingWriter(object):
    """ one main drawing file per sheet """

    def __init__(self, sheet):
        self._sheet = sheet

    def write(self):
        """ write drawings for one sheet in one file """

        root = Element('xdr:wsDr',
            {'xmlns:xdr' : "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing",
            'xmlns:a' : "http://schemas.openxmlformats.org/drawingml/2006/main"})

        for i, chart in enumerate(self._sheet._charts):

            drawing = chart.drawing

#            anchor = SubElement(root, 'xdr:twoCellAnchor')
#            (start_row, start_col), (end_row, end_col) = drawing.coordinates
#            # anchor coordinates
#            _from = SubElement(anchor, 'xdr:from')
#            x = SubElement(_from, 'xdr:col').text = str(start_col)
#            x = SubElement(_from, 'xdr:colOff').text = '0'
#            x = SubElement(_from, 'xdr:row').text = str(start_row)
#            x = SubElement(_from, 'xdr:rowOff').text = '0'

#            _to = SubElement(anchor, 'xdr:to')
#            x = SubElement(_to, 'xdr:col').text = str(end_col)
#            x = SubElement(_to, 'xdr:colOff').text = '0'
#            x = SubElement(_to, 'xdr:row').text = str(end_row)
#            x = SubElement(_to, 'xdr:rowOff').text = '0'

            # we only support absolute anchor atm (TODO: oneCellAnchor, twoCellAnchor
            x, y, w, h = drawing.get_emu_dimensions()
            anchor = SubElement(root, 'xdr:absoluteAnchor')
            SubElement(anchor, 'xdr:pos', {'x':str(x), 'y':str(y)})
            SubElement(anchor, 'xdr:ext', {'cx':str(w), 'cy':str(h)})

            # graph frame
            frame = SubElement(anchor, 'xdr:graphicFrame', {'macro':''})

            name = SubElement(frame, 'xdr:nvGraphicFramePr')
            SubElement(name, 'xdr:cNvPr', {'id':'%s' % i, 'name':'Graphique %s' % i})
            SubElement(name, 'xdr:cNvGraphicFramePr')

            frm = SubElement(frame, 'xdr:xfrm')
            # no transformation
            SubElement(frm, 'a:off', {'x':'0', 'y':'0'})
            SubElement(frm, 'a:ext', {'cx':'0', 'cy':'0'})

            graph = SubElement(frame, 'a:graphic')
            data = SubElement(graph, 'a:graphicData',
                {'uri':'http://schemas.openxmlformats.org/drawingml/2006/chart'})
            SubElement(data, 'c:chart',
                {   'xmlns:c':'http://schemas.openxmlformats.org/drawingml/2006/chart',
                    'xmlns:r':'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
                    'r:id':'rId%s' % (i + 1)})

            SubElement(anchor, 'xdr:clientData')

        return get_document_content(root)

    def write_rels(self, chart_id):

        root = Element('Relationships',
            {'xmlns' : 'http://schemas.openxmlformats.org/package/2006/relationships'})
        for i, chart in enumerate(self._sheet._charts):
            attrs = {'Id' : 'rId%s' % (i + 1),
                'Type' : 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart',
                'Target' : '../charts/chart%s.xml' % (chart_id + i) }
            SubElement(root, 'Relationship', attrs)
        return get_document_content(root)

class ShapeWriter(object):
    """ one file per shape """

    schema = "http://schemas.openxmlformats.org/drawingml/2006/main"

    def __init__(self, shapes):

        self._shapes = shapes

    def write(self, shape_id):

        root = Element('c:userShapes', {'xmlns:c' : 'http://schemas.openxmlformats.org/drawingml/2006/chart'})

        for shape in self._shapes:
            anchor = SubElement(root, 'cdr:relSizeAnchor',
                {'xmlns:cdr' : "http://schemas.openxmlformats.org/drawingml/2006/chartDrawing"})

            xstart, ystart, xend, yend = shape.get_coordinates()

            _from = SubElement(anchor, 'cdr:from')
            SubElement(_from, 'cdr:x').text = str(xstart)
            SubElement(_from, 'cdr:y').text = str(ystart)

            _to = SubElement(anchor, 'cdr:to')
            SubElement(_to, 'cdr:x').text = str(xend)
            SubElement(_to, 'cdr:y').text = str(yend)

            sp = SubElement(anchor, 'cdr:sp', {'macro':'', 'textlink':''})
            nvspr = SubElement(sp, 'cdr:nvSpPr')
            SubElement(nvspr, 'cdr:cNvPr', {'id':str(shape_id), 'name':'shape %s' % shape_id})
            SubElement(nvspr, 'cdr:cNvSpPr')

            sppr = SubElement(sp, 'cdr:spPr')
            frm = SubElement(sppr, 'a:xfrm', {'xmlns:a':self.schema})
            # no transformation
            SubElement(frm, 'a:off', {'x':'0', 'y':'0'})
            SubElement(frm, 'a:ext', {'cx':'0', 'cy':'0'})

            prstgeom = SubElement(sppr, 'a:prstGeom', {'xmlns:a':self.schema, 'prst':str(shape.style)})
            SubElement(prstgeom, 'a:avLst')

            fill = SubElement(sppr, 'a:solidFill', {'xmlns:a':self.schema})
            SubElement(fill, 'a:srgbClr', {'val':shape.color})

            border = SubElement(sppr, 'a:ln', {'xmlns:a':self.schema, 'w':str(shape._border_width)})
            sf = SubElement(border, 'a:solidFill')
            SubElement(sf, 'a:srgbClr', {'val':shape.border_color})

            self._write_style(sp)
            self._write_text(sp, shape)

            shape_id += 1

        return get_document_content(root)

    def _write_text(self, node, shape):
        """ write text in the shape """

        tx_body = SubElement(node, 'cdr:txBody')
        SubElement(tx_body, 'a:bodyPr', {'xmlns:a':self.schema, 'vertOverflow':'clip'})
        SubElement(tx_body, 'a:lstStyle',
            {'xmlns:a':self.schema})
        p = SubElement(tx_body, 'a:p', {'xmlns:a':self.schema})
        if shape.text:
            r = SubElement(p, 'a:r')
            rpr = SubElement(r, 'a:rPr', {'lang':'en-US'})
            fill = SubElement(rpr, 'a:solidFill')
            SubElement(fill, 'a:srgbClr', {'val':shape.text_color})

            SubElement(r, 'a:t').text = shape.text
        else:
            SubElement(p, 'a:endParaRPr', {'lang':'en-US'})

    def _write_style(self, node):
        """ write style theme """

        style = SubElement(node, 'cdr:style')

        ln_ref = SubElement(style, 'a:lnRef', {'xmlns:a':self.schema, 'idx':'2'})
        scheme_clr = SubElement(ln_ref, 'a:schemeClr', {'val':'accent1'})
        SubElement(scheme_clr, 'a:shade', {'val':'50000'})

        fill_ref = SubElement(style, 'a:fillRef', {'xmlns:a':self.schema, 'idx':'1'})
        SubElement(fill_ref, 'a:schemeClr', {'val':'accent1'})

        effect_ref = SubElement(style, 'a:effectRef', {'xmlns:a':self.schema, 'idx':'0'})
        SubElement(effect_ref, 'a:schemeClr', {'val':'accent1'})

        font_ref = SubElement(style, 'a:fontRef', {'xmlns:a':self.schema, 'idx':'minor'})
        SubElement(font_ref, 'a:schemeClr', {'val':'lt1'})

########NEW FILE########
__FILENAME__ = dump_worksheet
# file openpyxl/writer/straight_worksheet.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Write worksheets to xml representations in an optimized way"""

import datetime
import os

from ..cell import column_index_from_string, get_column_letter, Cell
from ..worksheet import Worksheet
from ..shared.xmltools import XMLGenerator, get_document_content, \
        start_tag, end_tag, tag
from ..shared.date_time import SharedDate
from ..shared.ooxml import MAX_COLUMN, MAX_ROW
from tempfile import NamedTemporaryFile
from ..writer.excel import ExcelWriter
from ..writer.strings import write_string_table
from ..writer.styles import StyleWriter
from ..style import Style, NumberFormat

from ..shared.ooxml import ARC_SHARED_STRINGS, ARC_CONTENT_TYPES, \
        ARC_ROOT_RELS, ARC_WORKBOOK_RELS, ARC_APP, ARC_CORE, ARC_THEME, \
        ARC_STYLE, ARC_WORKBOOK, \
        PACKAGE_WORKSHEETS, PACKAGE_DRAWINGS, PACKAGE_CHARTS

STYLES = {'datetime' : {'type':Cell.TYPE_NUMERIC,
                        'style':'1'},
          'string':{'type':Cell.TYPE_STRING,
                    'style':'0'},
          'numeric':{'type':Cell.TYPE_NUMERIC,
                     'style':'0'},
          'formula':{'type':Cell.TYPE_FORMULA,
                    'style':'0'},
          'boolean':{'type':Cell.TYPE_BOOL,
                    'style':'0'},
        }

DATETIME_STYLE = Style()
DATETIME_STYLE.number_format.format_code = NumberFormat.FORMAT_DATE_YYYYMMDD2 
BOUNDING_BOX_PLACEHOLDER = 'A1:%s%d' % (get_column_letter(MAX_COLUMN), MAX_ROW)

class DumpWorksheet(Worksheet):

    """
    .. warning::

        You shouldn't initialize this yourself, use :class:`..workbook.Workbook` constructor instead, 
        with `optimized_write = True`.
    """

    def __init__(self, parent_workbook):

        Worksheet.__init__(self, parent_workbook)

        self._max_col = 0
        self._max_row = 0
        self._parent = parent_workbook
        self._fileobj_header = NamedTemporaryFile(mode='r+', prefix='..', suffix='.header', delete=False)
        self._fileobj_content = NamedTemporaryFile(mode='r+', prefix='..', suffix='.content', delete=False)
        self._fileobj = NamedTemporaryFile(mode='w', prefix='..', delete=False)
        self.doc = XMLGenerator(self._fileobj_content, 'utf-8')
        self.header = XMLGenerator(self._fileobj_header, 'utf-8')
        self.title = 'Sheet'

        self._shared_date = SharedDate()
        self._string_builder = self._parent.strings_table_builder

    @property
    def filename(self):
        return self._fileobj.name

    def write_header(self):

        doc = self.header

        start_tag(doc, 'worksheet',
                {'xml:space': 'preserve',
                'xmlns': 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
                'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'})
        start_tag(doc, 'sheetPr')
        tag(doc, 'outlinePr',
                {'summaryBelow': '1', 
                'summaryRight': '1'})
        end_tag(doc, 'sheetPr')
        tag(doc, 'dimension', {'ref': 'A1:%s' % (self.get_dimensions())})
        start_tag(doc, 'sheetViews')
        start_tag(doc, 'sheetView', {'workbookViewId': '0'})
        tag(doc, 'selection', {'activeCell': 'A1',
                'sqref': 'A1'})
        end_tag(doc, 'sheetView')
        end_tag(doc, 'sheetViews')
        tag(doc, 'sheetFormatPr', {'defaultRowHeight': '15'})
        start_tag(doc, 'sheetData')

    def close(self):

        self._close_content()
        self._close_header()

        self._write_fileobj(self._fileobj_header)
        self._write_fileobj(self._fileobj_content)

        self._fileobj.close()

    def _write_fileobj(self, fobj):

        fobj.flush()
        fobj.seek(0)

        while True:
            chunk = fobj.read(4096)
            if not chunk:
                break
            self._fileobj.write(chunk)

        fobj.close()
        os.remove(fobj.name)

        self._fileobj.flush()

    def _close_header(self):
        
        doc = self.header
        #doc.endDocument()

    def _close_content(self):

        doc = self.doc
        end_tag(doc, 'sheetData')

        end_tag(doc, 'worksheet')
        #doc.endDocument()

    def get_dimensions(self):

        if not self._max_col or not self._max_row:
            return 'A1'
        else:
            return '%s%d' % (get_column_letter(self._max_col), (self._max_row))
            
    def append(self, row):

        """
        :param row: iterable containing values to append
        :type row: iterable
        """

        doc = self.doc

        self._max_row += 1
        span = len(row)
        self._max_col = max(self._max_col, span)

        row_idx = self._max_row

        attrs = {'r': '%d' % row_idx,
                 'spans': '1:%d' % span}

        start_tag(doc, 'row', attrs)

        for col_idx, cell in enumerate(row):

            if cell is None:
                continue

            coordinate = '%s%d' % (get_column_letter(col_idx+1), row_idx) 
            attributes = {'r': coordinate}

            if isinstance(cell, bool):
                dtype = 'boolean'
            elif isinstance(cell, (int, float)):
                dtype = 'numeric'
            elif isinstance(cell, (datetime.datetime, datetime.date)):
                dtype = 'datetime'
                cell = self._shared_date.datetime_to_julian(cell)
                attributes['s'] = STYLES[dtype]['style']
            elif cell and cell[0] == '=':
                dtype = 'formula'
            else:
                dtype = 'string'
                cell = self._string_builder.add(cell)

            attributes['t'] = STYLES[dtype]['type']

            start_tag(doc, 'c', attributes)

            if dtype == 'formula':
                tag(doc, 'f', body = '%s' % cell[1:])
                tag(doc, 'v')
            else:
                tag(doc, 'v', body = '%s' % cell)
            
            end_tag(doc, 'c')


        end_tag(doc, 'row')


def save_dump(workbook, filename):

    writer = ExcelDumpWriter(workbook)
    writer.save(filename)
    return True

class ExcelDumpWriter(ExcelWriter):

    def __init__(self, workbook):

        self.workbook = workbook
        self.style_writer = StyleDumpWriter(workbook)
        self.style_writer._style_list.append(DATETIME_STYLE)

    def _write_string_table(self, archive):

        shared_string_table = self.workbook.strings_table_builder.get_table()
        archive.writestr(ARC_SHARED_STRINGS,
                write_string_table(shared_string_table))

        return shared_string_table

    def _write_worksheets(self, archive, shared_string_table, style_writer):

        for i, sheet in enumerate(self.workbook.worksheets):
            sheet.write_header()
            sheet.close()
            archive.write(sheet.filename, PACKAGE_WORKSHEETS + '/sheet%d.xml' % (i + 1))
            os.remove(sheet.filename)


class StyleDumpWriter(StyleWriter):

    def _get_style_list(self, workbook):
        return []
        

########NEW FILE########
__FILENAME__ = excel
# file openpyxl/writer/excel.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Write a .xlsx file."""

# Python stdlib imports
from zipfile import ZipFile, ZIP_DEFLATED
from io import StringIO

# package imports
from ..shared.ooxml import ARC_SHARED_STRINGS, ARC_CONTENT_TYPES, \
        ARC_ROOT_RELS, ARC_WORKBOOK_RELS, ARC_APP, ARC_CORE, ARC_THEME, \
        ARC_STYLE, ARC_WORKBOOK, \
        PACKAGE_WORKSHEETS, PACKAGE_DRAWINGS, PACKAGE_CHARTS
from .strings import create_string_table, write_string_table
from .workbook import write_content_types, write_root_rels, \
        write_workbook_rels, write_properties_app, write_properties_core, \
        write_workbook
from .theme import write_theme
from .styles import StyleWriter
from .drawings import DrawingWriter, ShapeWriter
from .charts import ChartWriter
from .worksheet import write_worksheet, write_worksheet_rels


class ExcelWriter(object):
    """Write a workbook object to an Excel file."""

    def __init__(self, workbook):
        self.workbook = workbook
        self.style_writer = StyleWriter(self.workbook)

    def write_data(self, archive):
        """Write the various xml files into the zip archive."""
        # cleanup all worksheets
        shared_string_table = self._write_string_table(archive)
        
        archive.writestr(ARC_CONTENT_TYPES, write_content_types(self.workbook))
        archive.writestr(ARC_ROOT_RELS, write_root_rels(self.workbook))
        archive.writestr(ARC_WORKBOOK_RELS, write_workbook_rels(self.workbook))
        archive.writestr(ARC_APP, write_properties_app(self.workbook))
        archive.writestr(ARC_CORE,
                write_properties_core(self.workbook.properties))
        archive.writestr(ARC_THEME, write_theme())
        archive.writestr(ARC_STYLE, self.style_writer.write_table())
        archive.writestr(ARC_WORKBOOK, write_workbook(self.workbook))

        self._write_worksheets(archive, shared_string_table, self.style_writer)

    def _write_string_table(self, archive):

        for ws in self.workbook.worksheets:
            ws.garbage_collect()
        shared_string_table = create_string_table(self.workbook)
        archive.writestr(ARC_SHARED_STRINGS,
                write_string_table(shared_string_table))

        return shared_string_table

    def _write_worksheets(self, archive, shared_string_table, style_writer):

        drawing_id = 1
        chart_id = 1
        shape_id = 1

        for i, sheet in enumerate(self.workbook.worksheets):
            archive.writestr(PACKAGE_WORKSHEETS + '/sheet%d.xml' % (i + 1),
                    write_worksheet(sheet, shared_string_table,
                            style_writer.get_style_by_hash()))
            if sheet._charts or sheet.relationships:
                archive.writestr(PACKAGE_WORKSHEETS +
                        '/_rels/sheet%d.xml.rels' % (i + 1),
                        write_worksheet_rels(sheet, drawing_id))
            if sheet._charts:
                dw = DrawingWriter(sheet)
                archive.writestr(PACKAGE_DRAWINGS + '/drawing%d.xml' % drawing_id,
                    dw.write())
                archive.writestr(PACKAGE_DRAWINGS + '/_rels/drawing%d.xml.rels' % drawing_id,
                    dw.write_rels(chart_id))
                drawing_id += 1

                for chart in sheet._charts:
                    cw = ChartWriter(chart)
                    archive.writestr(PACKAGE_CHARTS + '/chart%d.xml' % chart_id,
                        cw.write())

                    if chart._shapes:
                        archive.writestr(PACKAGE_CHARTS + '/_rels/chart%d.xml.rels' % chart_id,
                            cw.write_rels(drawing_id))
                        sw = ShapeWriter(chart._shapes)
                        archive.writestr(PACKAGE_DRAWINGS + '/drawing%d.xml' % drawing_id,
                            sw.write(shape_id))
                        shape_id += len(chart._shapes)
                        drawing_id += 1

                    chart_id += 1


    def save(self, filename):
        """Write data into the archive."""
        archive = ZipFile(filename, 'w', ZIP_DEFLATED)
        self.write_data(archive)
        archive.close()


def save_workbook(workbook, filename):
    """Save the given workbook on the filesystem under the name filename.

    :param workbook: the workbook to save
    :type workbook: :class:`openpyxl.workbook.Workbook`

    :param filename: the path to which save the workbook
    :type filename: string

    :rtype: bool

    """
    writer = ExcelWriter(workbook)
    writer.save(filename)
    return True


def save_virtual_workbook(workbook):
    """Return an in-memory workbook, suitable for a Django response."""
    writer = ExcelWriter(workbook)
    temp_buffer = StringIO()
    try:
        archive = ZipFile(temp_buffer, 'w', ZIP_DEFLATED)
        writer.write_data(archive)
    finally:
        archive.close()
    virtual_workbook = temp_buffer.getvalue()
    temp_buffer.close()
    return virtual_workbook

########NEW FILE########
__FILENAME__ = strings
# file openpyxl/writer/strings.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Write the shared string table."""

# Python stdlib imports
from io import StringIO

# package imports
from ..shared.xmltools import start_tag, end_tag, tag, XMLGenerator


def create_string_table(workbook):
    """Compile the string table for a workbook."""
    strings = set()
    for sheet in workbook.worksheets:
        for cell in sheet.get_cell_collection():
            if cell.data_type == cell.TYPE_STRING and cell._value is not None:
                strings.add(cell.value)
    return dict((key, i) for i, key in enumerate(strings))


def write_string_table(string_table):
    """Write the string table xml."""
    temp_buffer = StringIO()
    doc = XMLGenerator(temp_buffer, 'utf-8')
    start_tag(doc, 'sst', {'xmlns':
            'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
            'uniqueCount': '%d' % len(string_table)})
    strings_to_write = sorted(iter(string_table.items()),
            key=lambda pair: pair[1])
    for key in [pair[0] for pair in strings_to_write]:
        start_tag(doc, 'si')
        if key.strip() != key:
            attr = {'xml:space': 'preserve'}
        else:
            attr = {}
        tag(doc, 't', attr, key)
        end_tag(doc, 'si')
    end_tag(doc, 'sst')
    string_table_xml = temp_buffer.getvalue()
    temp_buffer.close()
    return string_table_xml

class StringTableBuilder(object):

    def __init__(self):

        self.counter = 0
        self.dct = {}

    def add(self, key):

        key = key.strip()
        try:
            return self.dct[key]
        except KeyError:
            res = self.dct[key] = self.counter
            self.counter += 1
            return res

    def get_table(self):

        return self.dct

########NEW FILE########
__FILENAME__ = styles
# file openpyxl/writer/styles.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Write the shared style table."""

# package imports
from ..shared.xmltools import Element, SubElement
from ..shared.xmltools import get_document_content
from .. import style

class StyleWriter(object):
    
    def __init__(self, workbook):
        self._style_list = self._get_style_list(workbook)
        self._root = Element('styleSheet', 
            {'xmlns':'http://schemas.openxmlformats.org/spreadsheetml/2006/main'})
    
    def _get_style_list(self, workbook):
        crc = {}
        for worksheet in workbook.worksheets:
            for style in list(worksheet._styles.values()):
                crc[hash(style)] = style
        self.style_table = dict([(style, i+1) \
            for i, style in enumerate(list(crc.values()))])
        sorted_styles = sorted(iter(self.style_table.items()), \
            key = lambda pair:pair[1])
        return [s[0] for s in sorted_styles]

    def get_style_by_hash(self):
        return dict([(hash(style), id) \
            for style, id in self.style_table.items()])
        
    def write_table(self):
        number_format_table = self._write_number_formats()
        fonts_table = self._write_fonts()
        fills_table = self._write_fills()
        borders_table = self._write_borders()
        self._write_cell_style_xfs()
        self._write_cell_xfs(number_format_table, fonts_table, fills_table, borders_table)
        self._write_cell_style()
        self._write_dxfs()
        self._write_table_styles()

        return get_document_content(xml_node=self._root)

    def _write_fonts(self):
        """ add fonts part to root
            return {font.crc => index}
        """

        fonts = SubElement(self._root, 'fonts')
        
        # default
        font_node = SubElement(fonts, 'font')
        SubElement(font_node, 'sz', {'val':'11'})
        SubElement(font_node, 'color', {'theme':'1'})
        SubElement(font_node, 'name', {'val':'Calibri'})
        SubElement(font_node, 'family', {'val':'2'})
        SubElement(font_node, 'scheme', {'val':'minor'})
        
        # others
        table = {}
        index = 1
        for st in self._style_list:
            if hash(st.font) != hash(style.DEFAULTS.font) and hash(st.font) not in table:
                table[hash(st.font)] = str(index)
                font_node = SubElement(fonts, 'font')
                SubElement(font_node, 'sz', {'val':str(st.font.size)})
                SubElement(font_node, 'color', {'rgb':str(st.font.color.index)})
                SubElement(font_node, 'name', {'val':st.font.name})
                SubElement(font_node, 'family', {'val':'2'})
                SubElement(font_node, 'scheme', {'val':'minor'})
                if st.font.bold:
                    SubElement(font_node, 'b')
                if st.font.italic:
                    SubElement(font_node, 'i')
                index += 1
                
        fonts.attrib["count"] = str(index)
        return table

    def _write_fills(self):
        fills = SubElement(self._root, 'fills', {'count':'2'})
        fill = SubElement(fills, 'fill')
        SubElement(fill, 'patternFill', {'patternType':'none'})
        fill = SubElement(fills, 'fill')
        SubElement(fill, 'patternFill', {'patternType':'gray125'})

        table = {}
        index = 2
        for st in self._style_list:
            if hash(st.fill) != hash(style.DEFAULTS.fill) and hash(st.fill) not in table:
                table[hash(st.fill)] = str(index)
                fill = SubElement(fills, 'fill')
                if hash(st.fill.fill_type) != hash(style.DEFAULTS.fill.fill_type):
                    node = SubElement(fill,'patternFill', {'patternType':st.fill.fill_type})
                    if hash(st.fill.start_color) != hash(style.DEFAULTS.fill.start_color):

                        SubElement(node, 'fgColor', {'rgb':str(st.fill.start_color.index)})
                    if hash(st.fill.end_color) != hash(style.DEFAULTS.fill.end_color):
                        SubElement(node, 'bgColor', {'rgb':str(st.fill.start_color.index)})
                index += 1
        
        fills.attrib["count"] = str(index)
        return table

    def _write_borders(self):
        borders = SubElement(self._root, 'borders')

        # default
        border = SubElement(borders, 'border')
        SubElement(border, 'left')
        SubElement(border, 'right')
        SubElement(border, 'top')
        SubElement(border, 'bottom')
        SubElement(border, 'diagonal')
        
        # others
        table = {}
        index = 1
        for st in self._style_list:
            if hash(st.borders) != hash(style.DEFAULTS.borders) and hash(st.borders) not in table:
                table[hash(st.borders)] = str(index)
                border = SubElement(borders, 'border')
                # caution: respect this order
                for side in ('left','right','top','bottom','diagonal'):
                    obj = getattr(st.borders, side)
                    node = SubElement(border, side, {'style':obj.border_style})
                    SubElement(node, 'color', {'rgb':str(obj.color.index)})
                index += 1
        
        borders.attrib["count"] = str(index)
        return table

    def _write_cell_style_xfs(self):
        cell_style_xfs = SubElement(self._root, 'cellStyleXfs', {'count':'1'})
        xf = SubElement(cell_style_xfs, 'xf', 
            {'numFmtId':"0", 'fontId':"0", 'fillId':"0", 'borderId':"0"})
    
    def _write_cell_xfs(self, number_format_table, fonts_table, fills_table, borders_table):
        """ write styles combinations based on ids found in tables """
        
        # writing the cellXfs
        cell_xfs = SubElement(self._root, 'cellXfs', 
            {'count':'%d' % (len(self._style_list) + 1)})
        
        # default
        def _get_default_vals():
            return dict(numFmtId='0', fontId='0', fillId='0', 
                xfId='0', borderId='0')
        
        SubElement(cell_xfs, 'xf', _get_default_vals())
        
        for st in self._style_list:
            vals = _get_default_vals()
            
            if hash(st.font) != hash(style.DEFAULTS.font):
                vals['fontId'] = fonts_table[hash(st.font)]
                vals['applyFont'] = '1'
                
            if hash(st.borders) != hash(style.DEFAULTS.borders):
                vals['borderId'] = borders_table[hash(st.borders)]
                vals['applyBorder'] = '1'
                
            if hash(st.fill) != hash(style.DEFAULTS.fill):
                vals['fillId'] = fills_table[hash(st.fill)]
                vals['applyFillId'] = '1'

            if st.number_format != style.DEFAULTS.number_format:
                vals['numFmtId'] = '%d' % number_format_table[st.number_format]
                vals['applyNumberFormat'] = '1'
                
            if hash(st.alignment) != hash(style.DEFAULTS.alignment):
                vals['applyAlignment'] = '1'

            node = SubElement(cell_xfs, 'xf', vals)

            if hash(st.alignment) != hash(style.DEFAULTS.alignment):
                alignments = {}

                for align_attr in ['horizontal','vertical']:
                    if hash(getattr(st.alignment, align_attr)) != hash(getattr(style.DEFAULTS.alignment, align_attr)):
                        alignments[align_attr] = getattr(st.alignment, align_attr)

                SubElement(node, 'alignment', alignments)


    def _write_cell_style(self):
        cell_styles = SubElement(self._root, 'cellStyles', {'count':'1'})
        cell_style = SubElement(cell_styles, 'cellStyle', 
            {'name':"Normal", 'xfId':"0", 'builtinId':"0"})

    def _write_dxfs(self):
        dxfs = SubElement(self._root, 'dxfs', {'count':'0'})

    def _write_table_styles(self):

        table_styles = SubElement(self._root, 'tableStyles', 
            {'count':'0', 'defaultTableStyle':'TableStyleMedium9',
            'defaultPivotStyle':'PivotStyleLight16'})

    def _write_number_formats(self):

        number_format_table = {}

        number_format_list = []
        exceptions_list = []
        num_fmt_id = 165 # start at a greatly higher value as any builtin can go
        num_fmt_offset = 0

        for style in self._style_list:

            if not style.number_format in number_format_list  :
                number_format_list.append(style.number_format)

        for number_format in number_format_list:

            if number_format.is_builtin():
                btin = number_format.builtin_format_id(number_format.format_code)
                number_format_table[number_format] = btin
            else:
                number_format_table[number_format] = num_fmt_id + num_fmt_offset
                num_fmt_offset += 1
                exceptions_list.append(number_format)

        num_fmts = SubElement(self._root, 'numFmts', 
            {'count':'%d' % len(exceptions_list)})

        for number_format in exceptions_list :
            SubElement(num_fmts, 'numFmt', 
                {'numFmtId':'%d' % number_format_table[number_format],
                'formatCode':'%s' % number_format.format_code}) 
        
        return number_format_table

########NEW FILE########
__FILENAME__ = theme
# -*- coding: utf-8 -*-
# file openpyxl/writer/theme.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Write the theme xml based on a fixed string."""

# package imports
from ..shared.xmltools import fromstring, get_document_content


def write_theme():
    """Write the theme xml."""
    xml_node = fromstring(
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n'

            '<a:theme xmlns:a="http://schemas.openxmlformats.org/'
                'drawingml/2006/main" name="Office Theme">'
            '<a:themeElements>'

            '<a:clrScheme name="Office">'
            '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>'
            '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>'
            '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>'
            '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>'
            '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>'
            '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>'
            '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>'
            '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>'
            '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>'
            '<a:accent6><a:srgbClr val="F79646"/></a:accent6>'
            '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>'
            '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>'
            '</a:clrScheme>'

            '<a:fontScheme name="Office">'
            '<a:majorFont>'
            '<a:latin typeface="Cambria"/>'
            '<a:ea typeface=""/>'
            '<a:cs typeface=""/>'
            '<a:font script="Jpan" typeface=" "/>'
            '<a:font script="Hang" typeface=" "/>'
            '<a:font script="Hans" typeface=""/>'
            '<a:font script="Hant" typeface=""/>'
            '<a:font script="Arab" typeface="Times New Roman"/>'
            '<a:font script="Hebr" typeface="Times New Roman"/>'
            '<a:font script="Thai" typeface="Tahoma"/>'
            '<a:font script="Ethi" typeface="Nyala"/>'
            '<a:font script="Beng" typeface="Vrinda"/>'
            '<a:font script="Gujr" typeface="Shruti"/>'
            '<a:font script="Khmr" typeface="MoolBoran"/>'
            '<a:font script="Knda" typeface="Tunga"/>'
            '<a:font script="Guru" typeface="Raavi"/>'
            '<a:font script="Cans" typeface="Euphemia"/>'
            '<a:font script="Cher" typeface="Plantagenet Cherokee"/>'
            '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>'
            '<a:font script="Tibt" typeface="Microsoft Himalaya"/>'
            '<a:font script="Thaa" typeface="MV Boli"/>'
            '<a:font script="Deva" typeface="Mangal"/>'
            '<a:font script="Telu" typeface="Gautami"/>'
            '<a:font script="Taml" typeface="Latha"/>'
            '<a:font script="Syrc" typeface="Estrangelo Edessa"/>'
            '<a:font script="Orya" typeface="Kalinga"/>'
            '<a:font script="Mlym" typeface="Kartika"/>'
            '<a:font script="Laoo" typeface="DokChampa"/>'
            '<a:font script="Sinh" typeface="Iskoola Pota"/>'
            '<a:font script="Mong" typeface="Mongolian Baiti"/>'
            '<a:font script="Viet" typeface="Times New Roman"/>'
            '<a:font script="Uigh" typeface="Microsoft Uighur"/>'
            '</a:majorFont>'
            '<a:minorFont>'
            '<a:latin typeface="Calibri"/>'
            '<a:ea typeface=""/>'
            '<a:cs typeface=""/>'
            '<a:font script="Jpan" typeface=" "/>'
            '<a:font script="Hang" typeface=" "/>'
            '<a:font script="Hans" typeface=""/>'
            '<a:font script="Hant" typeface=""/>'
            '<a:font script="Arab" typeface="Arial"/>'
            '<a:font script="Hebr" typeface="Arial"/>'
            '<a:font script="Thai" typeface="Tahoma"/>'
            '<a:font script="Ethi" typeface="Nyala"/>'
            '<a:font script="Beng" typeface="Vrinda"/>'
            '<a:font script="Gujr" typeface="Shruti"/>'
            '<a:font script="Khmr" typeface="DaunPenh"/>'
            '<a:font script="Knda" typeface="Tunga"/>'
            '<a:font script="Guru" typeface="Raavi"/>'
            '<a:font script="Cans" typeface="Euphemia"/>'
            '<a:font script="Cher" typeface="Plantagenet Cherokee"/>'
            '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>'
            '<a:font script="Tibt" typeface="Microsoft Himalaya"/>'
            '<a:font script="Thaa" typeface="MV Boli"/>'
            '<a:font script="Deva" typeface="Mangal"/>'
            '<a:font script="Telu" typeface="Gautami"/>'
            '<a:font script="Taml" typeface="Latha"/>'
            '<a:font script="Syrc" typeface="Estrangelo Edessa"/>'
            '<a:font script="Orya" typeface="Kalinga"/>'
            '<a:font script="Mlym" typeface="Kartika"/>'
            '<a:font script="Laoo" typeface="DokChampa"/>'
            '<a:font script="Sinh" typeface="Iskoola Pota"/>'
            '<a:font script="Mong" typeface="Mongolian Baiti"/>'
            '<a:font script="Viet" typeface="Arial"/>'
            '<a:font script="Uigh" typeface="Microsoft Uighur"/>'
            '</a:minorFont>'
            '</a:fontScheme>'

            '<a:fmtScheme name="Office">'
            '<a:fillStyleLst>'
            '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>'
            '<a:gradFill rotWithShape="1"><a:gsLst>'
            '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/>'
            '<a:satMod val="300000"/></a:schemeClr></a:gs>'
            '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/>'
            '<a:satMod val="300000"/></a:schemeClr></a:gs>'
            '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/>'
            '<a:satMod val="350000"/></a:schemeClr></a:gs></a:gsLst>'
            '<a:lin ang="16200000" scaled="1"/></a:gradFill>'
            '<a:gradFill rotWithShape="1"><a:gsLst>'
            '<a:gs pos="0"><a:schemeClr val="phClr"><a:shade val="51000"/>'
            '<a:satMod val="130000"/></a:schemeClr></a:gs>'
            '<a:gs pos="80000"><a:schemeClr val="phClr"><a:shade val="93000"/>'
            '<a:satMod val="130000"/></a:schemeClr></a:gs>'
            '<a:gs pos="100000"><a:schemeClr val="phClr">'
            '<a:shade val="94000"/>'
            '<a:satMod val="135000"/></a:schemeClr></a:gs></a:gsLst>'
            '<a:lin ang="16200000" scaled="0"/></a:gradFill></a:fillStyleLst>'
            '<a:lnStyleLst>'
            '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr">'
            '<a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/>'
            '<a:satMod val="105000"/></a:schemeClr></a:solidFill>'
            '<a:prstDash val="solid"/></a:ln>'
            '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill>'
            '<a:schemeClr val="phClr"/></a:solidFill>'
            '<a:prstDash val="solid"/></a:ln>'
            '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill>'
            '<a:schemeClr val="phClr"/></a:solidFill>'
            '<a:prstDash val="solid"/></a:ln></a:lnStyleLst>'
            '<a:effectStyleLst><a:effectStyle><a:effectLst>'
            '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" '
                'rotWithShape="0"><a:srgbClr val="000000">'
            '<a:alpha val="38000"/></a:srgbClr></a:outerShdw></a:effectLst>'
            '</a:effectStyle><a:effectStyle><a:effectLst>'
            '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" '
                'rotWithShape="0"><a:srgbClr val="000000">'
            '<a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst>'
            '</a:effectStyle><a:effectStyle><a:effectLst>'
            '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" '
                'rotWithShape="0"><a:srgbClr val="000000">'
            '<a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst>'
            '<a:scene3d><a:camera prst="orthographicFront">'
            '<a:rot lat="0" lon="0" rev="0"/></a:camera>'
            '<a:lightRig rig="threePt" dir="t">'
            '<a:rot lat="0" lon="0" rev="1200000"/></a:lightRig>'
            '</a:scene3d><a:sp3d><a:bevelT w="63500" h="25400"/>'
            '</a:sp3d></a:effectStyle></a:effectStyleLst>'
            '<a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/>'
            '</a:solidFill><a:gradFill rotWithShape="1"><a:gsLst>'
            '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/>'
            '<a:satMod val="350000"/></a:schemeClr></a:gs>'
            '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/>'
            '<a:shade val="99000"/><a:satMod val="350000"/>'
            '</a:schemeClr></a:gs>'
            '<a:gs pos="100000"><a:schemeClr val="phClr">'
            '<a:shade val="20000"/><a:satMod val="255000"/>'
            '</a:schemeClr></a:gs></a:gsLst>'
            '<a:path path="circle">'
            '<a:fillToRect l="50000" t="-80000" r="50000" b="180000"/>'
            '</a:path>'
            '</a:gradFill><a:gradFill rotWithShape="1"><a:gsLst>'
            '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/>'
            '<a:satMod val="300000"/></a:schemeClr></a:gs>'
            '<a:gs pos="100000"><a:schemeClr val="phClr">'
            '<a:shade val="30000"/><a:satMod val="200000"/>'
            '</a:schemeClr></a:gs></a:gsLst>'
            '<a:path path="circle">'
            '<a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>'
            '</a:gradFill></a:bgFillStyleLst></a:fmtScheme>'
            '</a:themeElements>'
            '<a:objectDefaults/><a:extraClrSchemeLst/>'
            '</a:theme>')
    return get_document_content(xml_node)

########NEW FILE########
__FILENAME__ = workbook
# file openpyxl/writer/workbook.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Write the workbook global settings to the archive."""

# package imports
from ..shared.xmltools import Element, SubElement
from ..cell import absolute_coordinate
from ..shared.xmltools import get_document_content
from ..shared.ooxml import NAMESPACES, ARC_CORE, ARC_WORKBOOK, \
       ARC_APP, ARC_THEME, ARC_STYLE, ARC_SHARED_STRINGS
from ..shared.date_time import datetime_to_W3CDTF


def write_properties_core(properties):
    """Write the core properties to xml."""
    root = Element('cp:coreProperties', {'xmlns:cp': NAMESPACES['cp'],
            'xmlns:xsi': NAMESPACES['xsi'], 'xmlns:dc': NAMESPACES['dc'],
            'xmlns:dcterms': NAMESPACES['dcterms'],
            'xmlns:dcmitype': NAMESPACES['dcmitype'], })
    SubElement(root, 'dc:creator').text = properties.creator
    SubElement(root, 'cp:lastModifiedBy').text = properties.last_modified_by
    SubElement(root, 'dcterms:created', \
            {'xsi:type': 'dcterms:W3CDTF'}).text = \
            datetime_to_W3CDTF(properties.created)
    SubElement(root, 'dcterms:modified',
            {'xsi:type': 'dcterms:W3CDTF'}).text = \
            datetime_to_W3CDTF(properties.modified)
    return get_document_content(root)


def write_content_types(workbook):
    """Write the content-types xml."""
    root = Element('Types', {'xmlns': 'http://schemas.openxmlformats.org/package/2006/content-types'})
    SubElement(root, 'Override', {'PartName': '/' + ARC_THEME, 'ContentType': 'application/vnd.openxmlformats-officedocument.theme+xml'})
    SubElement(root, 'Override', {'PartName': '/' + ARC_STYLE, 'ContentType': 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml'})
    SubElement(root, 'Default', {'Extension': 'rels', 'ContentType': 'application/vnd.openxmlformats-package.relationships+xml'})
    SubElement(root, 'Default', {'Extension': 'xml', 'ContentType': 'application/xml'})
    SubElement(root, 'Override', {'PartName': '/' + ARC_WORKBOOK, 'ContentType': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml'})
    SubElement(root, 'Override', {'PartName': '/' + ARC_APP, 'ContentType': 'application/vnd.openxmlformats-officedocument.extended-properties+xml'})
    SubElement(root, 'Override', {'PartName': '/' + ARC_CORE, 'ContentType': 'application/vnd.openxmlformats-package.core-properties+xml'})
    SubElement(root, 'Override', {'PartName': '/' + ARC_SHARED_STRINGS, 'ContentType': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml'})

    drawing_id = 1
    chart_id = 1

    for sheet_id, sheet in enumerate(workbook.worksheets):
        SubElement(root, 'Override',
                {'PartName': '/xl/worksheets/sheet%d.xml' % (sheet_id + 1),
                'ContentType': 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml'})
        if sheet._charts:
            SubElement(root, 'Override',
                {'PartName' : '/xl/drawings/drawing%d.xml' % (sheet_id + 1),
                'ContentType' : 'application/vnd.openxmlformats-officedocument.drawing+xml'})
            drawing_id += 1

            for chart in sheet._charts:
                SubElement(root, 'Override',
                    {'PartName' : '/xl/charts/chart%d.xml' % chart_id,
                    'ContentType' : 'application/vnd.openxmlformats-officedocument.drawingml.chart+xml'})
                chart_id += 1
                if chart._shapes:
                    SubElement(root, 'Override',
                        {'PartName' : '/xl/drawings/drawing%d.xml' % drawing_id,
                        'ContentType' : 'application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml'})
                    drawing_id += 1

    return get_document_content(root)


def write_properties_app(workbook):
    """Write the properties xml."""
    worksheets_count = len(workbook.worksheets)
    root = Element('Properties', {'xmlns': 'http://schemas.openxmlformats.org/officeDocument/2006/extended-properties',
            'xmlns:vt': 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes'})
    SubElement(root, 'Application').text = 'Microsoft Excel'
    SubElement(root, 'DocSecurity').text = '0'
    SubElement(root, 'ScaleCrop').text = 'false'
    SubElement(root, 'Company')
    SubElement(root, 'LinksUpToDate').text = 'false'
    SubElement(root, 'SharedDoc').text = 'false'
    SubElement(root, 'HyperlinksChanged').text = 'false'
    SubElement(root, 'AppVersion').text = '12.0000'

    # heading pairs part
    heading_pairs = SubElement(root, 'HeadingPairs')
    vector = SubElement(heading_pairs, 'vt:vector',
            {'size': '2', 'baseType': 'variant'})
    variant = SubElement(vector, 'vt:variant')
    SubElement(variant, 'vt:lpstr').text = 'Worksheets'
    variant = SubElement(vector, 'vt:variant')
    SubElement(variant, 'vt:i4').text = '%d' % worksheets_count

    # title of parts
    title_of_parts = SubElement(root, 'TitlesOfParts')
    vector = SubElement(title_of_parts, 'vt:vector',
            {'size': '%d' % worksheets_count, 'baseType': 'lpstr'})
    for ws in workbook.worksheets:
        SubElement(vector, 'vt:lpstr').text = '%s' % ws.title
    return get_document_content(root)


def write_root_rels(workbook):
    """Write the relationships xml."""
    root = Element('Relationships', {'xmlns':
            'http://schemas.openxmlformats.org/package/2006/relationships'})
    SubElement(root, 'Relationship', {'Id': 'rId1', 'Target': ARC_WORKBOOK,
            'Type': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument'})
    SubElement(root, 'Relationship', {'Id': 'rId2', 'Target': ARC_CORE,
            'Type': 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties'})
    SubElement(root, 'Relationship', {'Id': 'rId3', 'Target': ARC_APP,
            'Type': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties'})
    return get_document_content(root)


def write_workbook(workbook):
    """Write the core workbook xml."""
    root = Element('workbook', {'xmlns': 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
            'xml:space': 'preserve', 'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'})
    SubElement(root, 'fileVersion', {'appName': 'xl', 'lastEdited': '4',
            'lowestEdited': '4', 'rupBuild': '4505'})
    SubElement(root, 'workbookPr', {'defaultThemeVersion': '124226',
            'codeName': 'ThisWorkbook'})
    book_views = SubElement(root, 'bookViews')
    SubElement(book_views, 'workbookView', {'activeTab': '%d' % workbook.get_index(workbook.get_active_sheet()),
            'autoFilterDateGrouping': '1', 'firstSheet': '0', 'minimized': '0',
            'showHorizontalScroll': '1', 'showSheetTabs': '1',
            'showVerticalScroll': '1', 'tabRatio': '600',
            'visibility': 'visible'})
    # worksheets
    sheets = SubElement(root, 'sheets')
    for i, sheet in enumerate(workbook.worksheets):
        sheet_node = SubElement(sheets, 'sheet', {'name': sheet.title,
                'sheetId': '%d' % (i + 1), 'r:id': 'rId%d' % (i + 1)})
        if not sheet.sheet_state == sheet.SHEETSTATE_VISIBLE:
            sheet_node.set('state', sheet.sheet_state)
    # named ranges
    defined_names = SubElement(root, 'definedNames')
    for named_range in workbook.get_named_ranges():
        name = SubElement(defined_names, 'definedName',
                {'name': named_range.name})

        # as there can be many cells in one range, generate the list of ranges
        dest_cells = []
        cell_ids = []
        for worksheet, range_name in named_range.destinations:
            cell_ids.append(workbook.get_index(worksheet))
            dest_cells.append("'%s'!%s" % (worksheet.title.replace("'", "''"),
                                           absolute_coordinate(range_name)))

        # for local ranges, we must check all the cells belong to the same sheet
        base_id = cell_ids[0]
        if named_range.local_only and all([x == base_id for x in cell_ids]):
            name.set('localSheetId', '%s' % base_id)

        # finally write the cells list
        name.text = ','.join(dest_cells)

    SubElement(root, 'calcPr', {'calcId': '124519', 'calcMode': 'auto',
            'fullCalcOnLoad': '1'})
    return get_document_content(root)


def write_workbook_rels(workbook):
    """Write the workbook relationships xml."""
    root = Element('Relationships', {'xmlns':
            'http://schemas.openxmlformats.org/package/2006/relationships'})
    for i in range(len(workbook.worksheets)):
        SubElement(root, 'Relationship', {'Id': 'rId%d' % (i + 1),
                'Type': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',
                'Target': 'worksheets/sheet%s.xml' % (i + 1)})
    rid = len(workbook.worksheets) + 1
    SubElement(root, 'Relationship',
            {'Id': 'rId%d' % rid, 'Target': 'sharedStrings.xml',
            'Type': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings'})
    SubElement(root, 'Relationship',
            {'Id': 'rId%d' % (rid + 1), 'Target': 'styles.xml',
            'Type': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles'})
    SubElement(root, 'Relationship',
            {'Id': 'rId%d' % (rid + 2), 'Target': 'theme/theme1.xml',
            'Type': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme'})
    return get_document_content(root)

########NEW FILE########
__FILENAME__ = worksheet
# file openpyxl/writer/worksheet.py

# Copyright (c) 2010 openpyxl
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# @license: http://www.opensource.org/licenses/mit-license.php
# @author: Eric Gazoni

"""Write worksheets to xml representations."""

# Python stdlib imports
from io import StringIO  # cStringIO doesn't handle unicode

# package imports
from ..cell import coordinate_from_string, column_index_from_string
from ..shared.xmltools import Element, SubElement, XMLGenerator, \
        get_document_content, start_tag, end_tag, tag


def row_sort(cell):
    """Translate column names for sorting."""
    return column_index_from_string(cell.column)


def write_worksheet(worksheet, string_table, style_table):
    """Write a worksheet to an xml file."""
    xml_file = StringIO()
    doc = XMLGenerator(xml_file, 'utf-8')
    start_tag(doc, 'worksheet',
            {'xml:space': 'preserve',
            'xmlns': 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
            'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'})
    start_tag(doc, 'sheetPr')
    tag(doc, 'outlinePr',
            {'summaryBelow': '%d' % (worksheet.show_summary_below),
            'summaryRight': '%d' % (worksheet.show_summary_right)})
    end_tag(doc, 'sheetPr')
    tag(doc, 'dimension', {'ref': '%s' % worksheet.calculate_dimension()})
    write_worksheet_sheetviews(doc, worksheet)
    tag(doc, 'sheetFormatPr', {'defaultRowHeight': '15'})
    write_worksheet_cols(doc, worksheet)
    write_worksheet_data(doc, worksheet, string_table, style_table)
    if worksheet.auto_filter:
        tag(doc, 'autoFilter', {'ref': worksheet.auto_filter})
    write_worksheet_hyperlinks(doc, worksheet)
    if worksheet._charts:
        tag(doc, 'drawing', {'r:id':'rId1'})
    end_tag(doc, 'worksheet')
    doc.endDocument()
    xml_string = xml_file.getvalue()
    xml_file.close()
    return xml_string

def write_worksheet_sheetviews(doc, worksheet):
    start_tag(doc, 'sheetViews')
    start_tag(doc, 'sheetView', {'workbookViewId': '0'})
    selectionAttrs = {}
    topLeftCell = worksheet.freeze_panes
    if topLeftCell:
        colName, row = coordinate_from_string(topLeftCell)
        column = column_index_from_string(colName)
        pane = 'topRight'
        paneAttrs = {}
        if column > 1:
            paneAttrs['xSplit'] = str(column - 1)
        if row > 1:
            paneAttrs['ySplit'] = str(row - 1)
            pane = 'bottomLeft'
            if column > 1:
                pane = 'bottomRight'
        paneAttrs.update(dict(topLeftCell=topLeftCell,
                              activePane=pane,
                              state='frozen'))
        tag(doc, 'pane', paneAttrs)
        selectionAttrs['pane'] = pane
        if row > 1 and column > 1:
            tag(doc, 'selection', {'pane': 'topRight'})
            tag(doc, 'selection', {'pane': 'bottomLeft'})

    selectionAttrs.update({'activeCell': worksheet.active_cell,
                           'sqref': worksheet.selected_cell})

    tag(doc, 'selection', selectionAttrs)
    end_tag(doc, 'sheetView')
    end_tag(doc, 'sheetViews')
    

def write_worksheet_cols(doc, worksheet):
    """Write worksheet columns to xml."""
    if worksheet.column_dimensions:
        start_tag(doc, 'cols')
        for column_string, columndimension in \
                worksheet.column_dimensions.items():
            col_index = column_index_from_string(column_string)
            col_def = {}
            col_def['collapsed'] = str(columndimension.style_index)
            col_def['min'] = str(col_index)
            col_def['max'] = str(col_index)
            if columndimension.width != \
                    worksheet.default_column_dimension.width:
                col_def['customWidth'] = 'true'
            if not columndimension.visible:
                col_def['hidden'] = 'true'
            if columndimension.outline_level > 0:
                col_def['outlineLevel'] = str(columndimension.outline_level)
            if columndimension.collapsed:
                col_def['collapsed'] = 'true'
            if columndimension.auto_size:
                col_def['bestFit'] = 'true'
            if columndimension.width > 0:
                col_def['width'] = str(columndimension.width)
            else:
                col_def['width'] = '9.10'
            tag(doc, 'col', col_def)
        end_tag(doc, 'cols')


def write_worksheet_data(doc, worksheet, string_table, style_table):
    """Write worksheet data to xml."""
    start_tag(doc, 'sheetData')
    max_column = worksheet.get_highest_column()
    style_id_by_hash = style_table
    cells_by_row = {}
    for cell in worksheet.get_cell_collection():
        cells_by_row.setdefault(cell.row, []).append(cell)
    for row_idx in sorted(cells_by_row):
        row_dimension = worksheet.row_dimensions[row_idx]
        attrs = {'r': '%d' % row_idx,
                 'spans': '1:%d' % max_column}
        if row_dimension.height > 0:
            attrs['ht'] = str(row_dimension.height)
            attrs['customHeight'] = '1'
        start_tag(doc, 'row', attrs)
        row_cells = cells_by_row[row_idx]
        sorted_cells = sorted(row_cells, key = row_sort)
        for cell in sorted_cells:
            value = cell._value
            coordinate = cell.get_coordinate()
            attributes = {'r': coordinate}
            attributes['t'] = cell.data_type
            if coordinate in worksheet._styles:
                attributes['s'] = '%d' % style_id_by_hash[
                        hash(worksheet._styles[coordinate])]
            start_tag(doc, 'c', attributes)
            if value is None:
                tag(doc, 'v', body='')
            elif cell.data_type == cell.TYPE_STRING:
                tag(doc, 'v', body = '%s' % string_table[value])
            elif cell.data_type == cell.TYPE_FORMULA:
                tag(doc, 'f', body = '%s' % value[1:])
                tag(doc, 'v')
            elif cell.data_type == cell.TYPE_NUMERIC:
                tag(doc, 'v', body = '%s' % value)
            else:
                tag(doc, 'v', body = '%s' % value)
            end_tag(doc, 'c')
        end_tag(doc, 'row')
    end_tag(doc, 'sheetData')


def write_worksheet_hyperlinks(doc, worksheet):
    """Write worksheet hyperlinks to xml."""
    write_hyperlinks = False
    for cell in worksheet.get_cell_collection():
        if cell.hyperlink_rel_id is not None:
            write_hyperlinks = True
            break
    if write_hyperlinks:
        start_tag(doc, 'hyperlinks')
        for cell in worksheet.get_cell_collection():
            if cell.hyperlink_rel_id is not None:
                attrs = {'display': cell.hyperlink,
                        'ref': cell.get_coordinate(),
                        'r:id': cell.hyperlink_rel_id}
                tag(doc, 'hyperlink', attrs)
        end_tag(doc, 'hyperlinks')


def write_worksheet_rels(worksheet, idx):
    """Write relationships for the worksheet to xml."""
    root = Element('Relationships', {'xmlns': 'http://schemas.openxmlformats.org/package/2006/relationships'})
    for rel in worksheet.relationships:
        attrs = {'Id': rel.id, 'Type': rel.type, 'Target': rel.target}
        if rel.target_mode:
            attrs['TargetMode'] = rel.target_mode
        SubElement(root, 'Relationship', attrs)
    if worksheet._charts:
        attrs = {'Id' : 'rId1',
            'Type' : 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',
            'Target' : '../drawings/drawing%s.xml' % idx }
        SubElement(root, 'Relationship', attrs)
    return get_document_content(root)

########NEW FILE########
__FILENAME__ = ordereddict
# Copyright (c) 2009 Raymond Hettinger
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
#     The above copyright notice and this permission notice shall be
#     included in all copies or substantial portions of the Software.
#
#     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
#     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
#     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
#     OTHER DEALINGS IN THE SOFTWARE.

from UserDict import DictMixin

class OrderedDict(dict, DictMixin):

    def __init__(self, *args, **kwds):
        if len(args) > 1:
            raise TypeError('expected at most 1 arguments, got %d' % len(args))
        try:
            self.__end
        except AttributeError:
            self.clear()
        self.update(*args, **kwds)

    def clear(self):
        self.__end = end = []
        end += [None, end, end]         # sentinel node for doubly linked list
        self.__map = {}                 # key --> [key, prev, next]
        dict.clear(self)

    def __setitem__(self, key, value):
        if key not in self:
            end = self.__end
            curr = end[1]
            curr[2] = end[1] = self.__map[key] = [key, curr, end]
        dict.__setitem__(self, key, value)

    def __delitem__(self, key):
        dict.__delitem__(self, key)
        key, prev, next = self.__map.pop(key)
        prev[2] = next
        next[1] = prev

    def __iter__(self):
        end = self.__end
        curr = end[2]
        while curr is not end:
            yield curr[0]
            curr = curr[2]

    def __reversed__(self):
        end = self.__end
        curr = end[1]
        while curr is not end:
            yield curr[0]
            curr = curr[1]

    def popitem(self, last=True):
        if not self:
            raise KeyError('dictionary is empty')
        if last:
            key = next(reversed(self))
        else:
            key = next(iter(self))
        value = self.pop(key)
        return key, value

    def __reduce__(self):
        items = [[k, self[k]] for k in self]
        tmp = self.__map, self.__end
        del self.__map, self.__end
        inst_dict = vars(self).copy()
        self.__map, self.__end = tmp
        if inst_dict:
            return (self.__class__, (items,), inst_dict)
        return self.__class__, (items,)

    def keys(self):
        return list(self)

    setdefault = DictMixin.setdefault
    update = DictMixin.update
    pop = DictMixin.pop
    values = DictMixin.values
    items = DictMixin.items
    iterkeys = DictMixin.iterkeys
    itervalues = DictMixin.itervalues
    iteritems = DictMixin.iteritems

    def __repr__(self):
        if not self:
            return '%s()' % (self.__class__.__name__,)
        return '%s(%r)' % (self.__class__.__name__, list(self.items()))

    def copy(self):
        return self.__class__(self)

    @classmethod
    def fromkeys(cls, iterable, value=None):
        d = cls()
        for key in iterable:
            d[key] = value
        return d

    def __eq__(self, other):
        if isinstance(other, OrderedDict):
            if len(self) != len(other):
                return False
            for p, q in  zip(list(self.items()), list(other.items())):
                if p != q:
                    return False
            return True
        return dict.__eq__(self, other)

    def __ne__(self, other):
        return not self == other

########NEW FILE########
__FILENAME__ = biffh
# -*- coding: cp1252 -*-

##
# Support module for the xlrd package.
#
# <p>Portions copyright  2005-2008 Stephen John Machin, Lingfo Pty Ltd</p>
# <p>This module is part of the xlrd package, which is released under a BSD-style licence.</p>
##

# 2008-02-10 SJM BIFF2 BLANK record
# 2008-02-08 SJM Preparation for Excel 2.0 support
# 2008-02-02 SJM Added suffixes (_B2, _B2_ONLY, etc) on record names for biff_dump & biff_count
# 2007-12-04 SJM Added support for Excel 2.x (BIFF2) files.
# 2007-09-08 SJM Avoid crash when zero-length Unicode string missing options byte.
# 2007-04-22 SJM Remove experimental "trimming" facility.

DEBUG = 0

from struct import unpack
import sys
from timemachine import *

class XLRDError(Exception):
    pass

##
# Parent of almost all other classes in the package. Defines a common "dump" method
# for debugging.

class BaseObject(object):

    _repr_these = []

    ##
    # @param f open file object, to which the dump is written
    # @param header text to write before the dump
    # @param footer text to write after the dump
    # @param indent number of leading spaces (for recursive calls)

    def dump(self, f=None, header=None, footer=None, indent=0):
        if f is None:
            f = sys.stderr
        alist = self.__dict__.items()
        alist.sort()
        pad = " " * indent
        if header is not None: print >> f, header
        list_type = type([])
        dict_type = type({})
        for attr, value in alist:
            if getattr(value, 'dump', None) and attr != 'book':
                value.dump(f,
                    header="%s%s (%s object):" % (pad, attr, value.__class__.__name__),
                    indent=indent+4)
            elif attr not in self._repr_these and (
                isinstance(value, list_type) or isinstance(value, dict_type)
                ):
                print >> f, "%s%s: %s, len = %d" % (pad, attr, type(value), len(value))
            else:
                print >> f, "%s%s: %r" % (pad, attr, value)
        if footer is not None: print >> f, footer

FUN, FDT, FNU, FGE, FTX = range(5) # unknown, date, number, general, text
DATEFORMAT = FDT
NUMBERFORMAT = FNU

(
    XL_CELL_EMPTY,
    XL_CELL_TEXT,
    XL_CELL_NUMBER,
    XL_CELL_DATE,
    XL_CELL_BOOLEAN,
    XL_CELL_ERROR,
    XL_CELL_BLANK, # for use in debugging, gathering stats, etc
) = range(7)

biff_text_from_num = {
    0:  "(not BIFF)",
    20: "2.0",
    21: "2.1",
    30: "3",
    40: "4S",
    45: "4W",
    50: "5",
    70: "7",
    80: "8",
    85: "8X",
    }

##
# <p>This dictionary can be used to produce a text version of the internal codes
# that Excel uses for error cells. Here are its contents:
# <pre>
# 0x00: '#NULL!',  # Intersection of two cell ranges is empty
# 0x07: '#DIV/0!', # Division by zero
# 0x0F: '#VALUE!', # Wrong type of operand
# 0x17: '#REF!',   # Illegal or deleted cell reference
# 0x1D: '#NAME?',  # Wrong function or range name
# 0x24: '#NUM!',   # Value range overflow
# 0x2A: '#N/A!',   # Argument or function not available
# </pre></p>

error_text_from_code = {
    0x00: '#NULL!',  # Intersection of two cell ranges is empty
    0x07: '#DIV/0!', # Division by zero
    0x0F: '#VALUE!', # Wrong type of operand
    0x17: '#REF!',   # Illegal or deleted cell reference
    0x1D: '#NAME?',  # Wrong function or range name
    0x24: '#NUM!',   # Value range overflow
    0x2A: '#N/A!',   # Argument or function not available
}

BIFF_FIRST_UNICODE = 80

XL_WORKBOOK_GLOBALS = WBKBLOBAL = 0x5
XL_WORKBOOK_GLOBALS_4W = 0x100
XL_WORKSHEET = WRKSHEET = 0x10

XL_BOUNDSHEET_WORKSHEET = 0x00
XL_BOUNDSHEET_CHART     = 0x02
XL_BOUNDSHEET_VB_MODULE = 0x06

# XL_RK2 = 0x7e
XL_ARRAY  = 0x0221
XL_ARRAY2 = 0x0021
XL_BLANK = 0x0201
XL_BLANK_B2 = 0x01
XL_BOF = 0x809
XL_BOOLERR = 0x205
XL_BOOLERR_B2 = 0x5
XL_BOUNDSHEET = 0x85
XL_BUILTINFMTCOUNT = 0x56
XL_CF = 0x01B1
XL_CODEPAGE = 0x42
XL_COLINFO = 0x7D
XL_COLUMNDEFAULT = 0x20 # BIFF2 only
XL_COLWIDTH = 0x24 # BIFF2 only
XL_CONDFMT = 0x01B0
XL_CONTINUE = 0x3c
XL_COUNTRY = 0x8C
XL_DATEMODE = 0x22
XL_DEFAULTROWHEIGHT = 0x0225
XL_DEFCOLWIDTH = 0x55
XL_DIMENSION = 0x200
XL_DIMENSION2 = 0x0
XL_EFONT = 0x45
XL_EOF = 0x0a
XL_EXTERNNAME = 0x23
XL_EXTERNSHEET = 0x17
XL_EXTSST = 0xff
XL_FEAT11 = 0x872
XL_FILEPASS = 0x2f
XL_FONT = 0x31
XL_FONT_B3B4 = 0x231
XL_FORMAT = 0x41e
XL_FORMAT2 = 0x1E # BIFF2, BIFF3
XL_FORMULA = 0x6
XL_FORMULA3 = 0x206
XL_FORMULA4 = 0x406
XL_GCW = 0xab
XL_INDEX = 0x20b
XL_INTEGER = 0x2 # BIFF2 only
XL_IXFE = 0x44 # BIFF2 only
XL_LABEL = 0x204
XL_LABEL_B2 = 0x04
XL_LABELRANGES = 0x15f
XL_LABELSST = 0xfd
XL_MERGEDCELLS = 0xE5
XL_MSO_DRAWING = 0x00EC
XL_MSO_DRAWING_GROUP = 0x00EB
XL_MSO_DRAWING_SELECTION = 0x00ED
XL_MULRK = 0xbd
XL_MULBLANK = 0xbe
XL_NAME = 0x18
XL_NOTE = 0x1c
XL_NUMBER = 0x203
XL_NUMBER_B2 = 0x3
XL_OBJ = 0x5D
XL_PALETTE = 0x92
XL_RK = 0x27e
XL_ROW = 0x208
XL_ROW_B2 = 0x08
XL_RSTRING = 0xd6
XL_SHEETHDR = 0x8F # BIFF4W only
XL_SHEETSOFFSET = 0x8E # BIFF4W only
XL_SHRFMLA = 0x04bc
XL_SST = 0xfc
XL_STANDARDWIDTH = 0x99
XL_STRING = 0x207
XL_STRING_B2 = 0x7
XL_STYLE = 0x293
XL_SUPBOOK = 0x1AE
XL_TABLEOP = 0x236
XL_TABLEOP2 = 0x37
XL_TABLEOP_B2 = 0x36
XL_TXO = 0x1b6
XL_UNCALCED = 0x5e
XL_UNKNOWN = 0xffff
XL_WINDOW2 = 0x023E
XL_WRITEACCESS = 0x5C
XL_XF = 0xe0
XL_XF2 = 0x0043 # BIFF2 version of XF record
XL_XF3 = 0x0243 # BIFF3 version of XF record
XL_XF4 = 0x0443 # BIFF4 version of XF record

boflen = {0x0809: 8, 0x0409: 6, 0x0209: 6, 0x0009: 4}
bofcodes = (0x0809, 0x0409, 0x0209, 0x0009)

XL_FORMULA_OPCODES = (0x0006, 0x0406, 0x0206)

_cell_opcode_list = [
    XL_BOOLERR,
    XL_FORMULA,
    XL_FORMULA3,
    XL_FORMULA4,
    XL_LABEL,
    XL_LABELSST,
    XL_MULRK,
    XL_NUMBER,
    XL_RK,
    XL_RSTRING,
    ]
_cell_opcode_dict = {}
for _cell_opcode in _cell_opcode_list:
    _cell_opcode_dict[_cell_opcode] = 1
is_cell_opcode = _cell_opcode_dict.has_key

# def fprintf(f, fmt, *vargs): f.write(fmt % vargs)

def fprintf(f, fmt, *vargs):
    if fmt.endswith('\n'):
        print >> f, fmt[:-1] % vargs
    else:
        print >> f, fmt % vargs,

def upkbits(tgt_obj, src, manifest, local_setattr=setattr):
    for n, mask, attr in manifest:
        local_setattr(tgt_obj, attr, (src & mask) >> n)

def upkbitsL(tgt_obj, src, manifest, local_setattr=setattr, local_int=int):
    for n, mask, attr in manifest:
        local_setattr(tgt_obj, attr, local_int((src & mask) >> n))

def unpack_string(data, pos, encoding, lenlen=1):
    nchars = unpack('<' + 'BH'[lenlen-1], data[pos:pos+lenlen])[0]
    pos += lenlen
    return unicode(data[pos:pos+nchars], encoding)

def unpack_string_update_pos(data, pos, encoding, lenlen=1, known_len=None):
    if known_len is not None:
        # On a NAME record, the length byte is detached from the front of the string.
        nchars = known_len
    else:
        nchars = unpack('<' + 'BH'[lenlen-1], data[pos:pos+lenlen])[0]
        pos += lenlen
    newpos = pos + nchars
    return (unicode(data[pos:newpos], encoding), newpos)

def unpack_unicode(data, pos, lenlen=2):
    "Return unicode_strg"
    nchars = unpack('<' + 'BH'[lenlen-1], data[pos:pos+lenlen])[0]
    if not nchars:
        # Ambiguous whether 0-length string should have an "options" byte.
        # Avoid crash if missing.
        return u""
    pos += lenlen
    options = ord(data[pos])
    pos += 1
    # phonetic = options & 0x04
    # richtext = options & 0x08
    if options & 0x08:
        # rt = unpack('<H', data[pos:pos+2])[0] # unused
        pos += 2
    if options & 0x04:
        # sz = unpack('<i', data[pos:pos+4])[0] # unused
        pos += 4
    if options & 0x01:
        # Uncompressed UTF-16-LE
        rawstrg = data[pos:pos+2*nchars]
        # if DEBUG: print "nchars=%d pos=%d rawstrg=%r" % (nchars, pos, rawstrg)
        strg = unicode(rawstrg, 'utf_16_le')
        # pos += 2*nchars
    else:
        # Note: this is COMPRESSED (not ASCII!) encoding!!!
        # Merely returning the raw bytes would work OK 99.99% of the time
        # if the local codepage was cp1252 -- however this would rapidly go pear-shaped
        # for other codepages so we grit our Anglocentric teeth and return Unicode :-)

        strg = unicode(data[pos:pos+nchars], "latin_1")
        # pos += nchars
    # if richtext:
    #     pos += 4 * rt
    # if phonetic:
    #     pos += sz
    # return (strg, pos)
    return strg

def unpack_unicode_update_pos(data, pos, lenlen=2, known_len=None):
    "Return (unicode_strg, updated value of pos)"
    if known_len is not None:
        # On a NAME record, the length byte is detached from the front of the string.
        nchars = known_len
    else:
        nchars = unpack('<' + 'BH'[lenlen-1], data[pos:pos+lenlen])[0]
        pos += lenlen
    if not nchars and not data[pos:]:
        # Zero-length string with no options byte
        return (u"", pos)
    options = ord(data[pos])
    pos += 1
    phonetic = options & 0x04
    richtext = options & 0x08
    if richtext:
        rt = unpack('<H', data[pos:pos+2])[0]
        pos += 2
    if phonetic:
        sz = unpack('<i', data[pos:pos+4])[0]
        pos += 4
    if options & 0x01:
        # Uncompressed UTF-16-LE
        strg = unicode(data[pos:pos+2*nchars], 'utf_16_le')
        pos += 2*nchars
    else:
        # Note: this is COMPRESSED (not ASCII!) encoding!!!
        strg = unicode(data[pos:pos+nchars], "latin_1")
        pos += nchars
    if richtext:
        pos += 4 * rt
    if phonetic:
        pos += sz
    return (strg, pos)

def unpack_cell_range_address_list_update_pos(
    output_list, data, pos, biff_version, addr_size=6):
    # output_list is updated in situ
    if biff_version < 80:
        assert addr_size == 6
    else:
        assert addr_size in (6, 8)
    n, = unpack("<H", data[pos:pos+2])
    pos += 2
    if n:
        if addr_size == 6:
            fmt = "<HHBB"
        else:
            fmt = "<HHHH"
        for _unused in xrange(n):
            ra, rb, ca, cb = unpack(fmt, data[pos:pos+addr_size])
            output_list.append((ra, rb+1, ca, cb+1))
            pos += addr_size
    return pos

_brecstrg = """\
0000 DIMENSIONS_B2
0001 BLANK_B2
0002 INTEGER_B2_ONLY
0003 NUMBER_B2
0004 LABEL_B2
0005 BOOLERR_B2
0006 FORMULA
0007 STRING_B2
0008 ROW_B2
0009 BOF_B2
000A EOF
000B INDEX_B2_ONLY
000C CALCCOUNT
000D CALCMODE
000E PRECISION
000F REFMODE
0010 DELTA
0011 ITERATION
0012 PROTECT
0013 PASSWORD
0014 HEADER
0015 FOOTER
0016 EXTERNCOUNT
0017 EXTERNSHEET
0018 NAME_B2,5+
0019 WINDOWPROTECT
001A VERTICALPAGEBREAKS
001B HORIZONTALPAGEBREAKS
001C NOTE
001D SELECTION
001E FORMAT_B2-3
001F BUILTINFMTCOUNT_B2
0020 COLUMNDEFAULT_B2_ONLY
0021 ARRAY_B2_ONLY
0022 DATEMODE
0023 EXTERNNAME
0024 COLWIDTH_B2_ONLY
0025 DEFAULTROWHEIGHT_B2_ONLY
0026 LEFTMARGIN
0027 RIGHTMARGIN
0028 TOPMARGIN
0029 BOTTOMMARGIN
002A PRINTHEADERS
002B PRINTGRIDLINES
002F FILEPASS
0031 FONT
0032 FONT2_B2_ONLY
0036 TABLEOP_B2
0037 TABLEOP2_B2
003C CONTINUE
003D WINDOW1
003E WINDOW2_B2
0040 BACKUP
0041 PANE
0042 CODEPAGE
0043 XF_B2
0044 IXFE_B2_ONLY
0045 EFONT_B2_ONLY
004D PLS
0051 DCONREF
0055 DEFCOLWIDTH
0056 BUILTINFMTCOUNT_B3-4
0059 XCT
005A CRN
005B FILESHARING
005C WRITEACCESS
005D OBJECT
005E UNCALCED
005F SAVERECALC
0063 OBJECTPROTECT
007D COLINFO
007E RK2_mythical_?
0080 GUTS
0081 WSBOOL
0082 GRIDSET
0083 HCENTER
0084 VCENTER
0085 BOUNDSHEET
0086 WRITEPROT
008C COUNTRY
008D HIDEOBJ
008E SHEETSOFFSET
008F SHEETHDR
0090 SORT
0092 PALETTE
0099 STANDARDWIDTH
009B FILTERMODE
009C FNGROUPCOUNT
009D AUTOFILTERINFO
009E AUTOFILTER
00A0 SCL
00A1 SETUP
00AB GCW
00BD MULRK
00BE MULBLANK
00C1 MMS
00D6 RSTRING
00D7 DBCELL
00DA BOOKBOOL
00DD SCENPROTECT
00E0 XF
00E1 INTERFACEHDR
00E2 INTERFACEEND
00E5 MERGEDCELLS
00E9 BITMAP
00EB MSO_DRAWING_GROUP
00EC MSO_DRAWING
00ED MSO_DRAWING_SELECTION
00EF PHONETIC
00FC SST
00FD LABELSST
00FF EXTSST
013D TABID
015F LABELRANGES
0160 USESELFS
0161 DSF
01AE SUPBOOK
01AF PROTECTIONREV4
01B0 CONDFMT
01B1 CF
01B2 DVAL
01B6 TXO
01B7 REFRESHALL
01B8 HLINK
01BC PASSWORDREV4
01BE DV
01C0 XL9FILE
01C1 RECALCID
0200 DIMENSIONS
0201 BLANK
0203 NUMBER
0204 LABEL
0205 BOOLERR
0206 FORMULA_B3
0207 STRING
0208 ROW
0209 BOF
020B INDEX_B3+
0218 NAME
0221 ARRAY
0223 EXTERNNAME_B3-4
0225 DEFAULTROWHEIGHT
0231 FONT_B3B4
0236 TABLEOP
023E WINDOW2
0243 XF_B3
027E RK
0293 STYLE
0406 FORMULA_B4
0409 BOF
041E FORMAT
0443 XF_B4
04BC SHRFMLA
0800 QUICKTIP
0809 BOF
0862 SHEETLAYOUT
0867 SHEETPROTECTION
0868 RANGEPROTECTION
"""

biff_rec_name_dict = {}
for _buff in _brecstrg.splitlines():
    _numh, _name = _buff.split()
    biff_rec_name_dict[int(_numh, 16)] = _name
del _buff, _name, _brecstrg

def hex_char_dump(strg, ofs, dlen, base=0, fout=sys.stdout, unnumbered=False):
    endpos = min(ofs + dlen, len(strg))
    pos = ofs
    numbered = not unnumbered
    num_prefix = ''
    while pos < endpos:
        endsub = min(pos + 16, endpos)
        substrg = strg[pos:endsub]
        lensub = endsub - pos
        if lensub <= 0 or lensub != len(substrg):
            fprintf(
                sys.stdout,
                '??? hex_char_dump: ofs=%d dlen=%d base=%d -> endpos=%d pos=%d endsub=%d substrg=%r\n',
                ofs, dlen, base, endpos, pos, endsub, substrg)
            break
        hexd = ''.join(["%02x " % ord(c) for c in substrg])
        chard = ''
        for c in substrg:
            if c == '\0':
                c = '~'
            elif not (' ' <= c <= '~'):
                c = '?'
            chard += c
        if numbered:
            num_prefix = "%5d: " %  (base+pos-ofs)
        fprintf(fout, "%s     %-48s %s\n", num_prefix, hexd, chard)
        pos = endsub

def biff_dump(mem, stream_offset, stream_len, base=0, fout=sys.stdout, unnumbered=False):
    pos = stream_offset
    stream_end = stream_offset + stream_len
    adj = base - stream_offset
    dummies = 0
    numbered = not unnumbered
    num_prefix = ''
    while stream_end - pos >= 4:
        rc, length = unpack('<HH', mem[pos:pos+4])
        if rc == 0 and length == 0:
            if mem[pos:] == '\0' * (stream_end - pos):
                dummies = stream_end - pos
                savpos = pos
                pos = stream_end
                break
            if dummies:
                dummies += 4
            else:
                savpos = pos
                dummies = 4
            pos += 4
        else:
            if dummies:
                if numbered:
                    num_prefix =  "%5d: " % (adj + savpos)
                fprintf(fout, "%s---- %d zero bytes skipped ----\n", num_prefix, dummies)
                dummies = 0
            recname = biff_rec_name_dict.get(rc, '<UNKNOWN>')
            if numbered:
                num_prefix = "%5d: " % (adj + pos)
            fprintf(fout, "%s%04x %s len = %04x (%d)\n", num_prefix, rc, recname, length, length)
            pos += 4
            hex_char_dump(mem, pos, length, adj+pos, fout, unnumbered)
            pos += length
    if dummies:
        if numbered:
            num_prefix =  "%5d: " % (adj + savpos)
        fprintf(fout, "%s---- %d zero bytes skipped ----\n", num_prefix, dummies)
    if pos < stream_end:
        if numbered:
            num_prefix = "%5d: " % (adj + pos)
        fprintf(fout, "%s---- Misc bytes at end ----\n", num_prefix)
        hex_char_dump(mem, pos, stream_end-pos, adj + pos, fout, unnumbered)
    elif pos > stream_end:
        fprintf(fout, "Last dumped record has length (%d) that is too large\n", length)

def biff_count_records(mem, stream_offset, stream_len, fout=sys.stdout):
    pos = stream_offset
    stream_end = stream_offset + stream_len
    tally = {}
    while stream_end - pos >= 4:
        rc, length = unpack('<HH', mem[pos:pos+4])
        if rc == 0 and length == 0:
            if mem[pos:] == '\0' * (stream_end - pos):
                break
            recname = "<Dummy (zero)>"
        else:
            recname = biff_rec_name_dict.get(rc, None)
            if recname is None:
                recname = "Unknown_0x%04X" % rc
        if tally.has_key(recname):
            tally[recname] += 1
        else:
            tally[recname] = 1
        pos += length + 4
    slist = tally.items()
    slist.sort()
    for recname, count in slist:
        print >> fout, "%8d %s" % (count, recname)

encoding_from_codepage = {
    1200 : 'utf_16_le',
    10000: 'mac_roman',
    10006: 'mac_greek', # guess
    10007: 'mac_cyrillic', # guess
    10029: 'mac_latin2', # guess
    10079: 'mac_iceland', # guess
    10081: 'mac_turkish', # guess
    32768: 'mac_roman',
    32769: 'cp1252',
    }
# some more guessing, for Indic scripts
# codepage 57000 range:
# 2 Devanagari [0]
# 3 Bengali [1]
# 4 Tamil [5]
# 5 Telegu [6]
# 6 Assamese [1] c.f. Bengali
# 7 Oriya [4]
# 8 Kannada [7]
# 9 Malayalam [8]
# 10 Gujarati [3]
# 11 Gurmukhi [2]

########NEW FILE########
__FILENAME__ = compdoc
# -*- coding: cp1252 -*-

##
# Implements the minimal functionality required
# to extract a "Workbook" or "Book" stream (as one big string)
# from an OLE2 Compound Document file.
# <p>Copyright  2005-2008 Stephen John Machin, Lingfo Pty Ltd</p>
# <p>This module is part of the xlrd package, which is released under a BSD-style licence.</p>
##

# No part of the content of this file was derived from the works of David Giffin.

# 2008-11-04 SJM Avoid assertion error when -1 used instead of -2 for first_SID of empty SCSS [Frank Hoffsuemmer]
# 2007-09-08 SJM Warning message if sector sizes are extremely large.
# 2007-05-07 SJM Meaningful exception instead of IndexError if a SAT (sector allocation table) is corrupted.
# 2007-04-22 SJM Missing "<" in a struct.unpack call => can't open files on bigendian platforms.


import sys
from struct import unpack
from timemachine import *

##
# Magic cookie that should appear in the first 8 bytes of the file.
SIGNATURE = "\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1"

EOCSID = -2
FREESID = -1
SATSID = -3
MSATSID = -4

class CompDocError(Exception):
    pass

class DirNode(object):

    def __init__(self, DID, dent, DEBUG=0):
        # dent is the 128-byte directory entry
        self.DID = DID
        # (cbufsize, self.etype, self.colour, self.left_DID, self.right_DID,
        # self.root_DID,
        # self.first_SID,
        # self.tot_size) = \
        #     unpack('<HBBiii16x4x8x8xii4x', dent[64:128])
        (cbufsize, self.etype, self.colour, self.left_DID, self.right_DID,
        self.root_DID) = \
            unpack('<HBBiii', dent[64:80])
        (self.first_SID, self.tot_size) = \
            unpack('<ii', dent[116:124])
        if cbufsize == 0:
            self.name = u''
        else:
            self.name = unicode(dent[0:cbufsize-2], 'utf_16_le') # omit the trailing U+0000
        self.children = [] # filled in later
        self.parent = -1 # indicates orphan; fixed up later
        self.tsinfo = unpack('<IIII', dent[100:116])
        if DEBUG:
            self.dump(DEBUG)

    def dump(self, DEBUG=1):
        print "DID=%d name=%r etype=%d DIDs(left=%d right=%d root=%d parent=%d kids=%r) first_SID=%d tot_size=%d" \
            % (self.DID, self.name, self.etype, self.left_DID,
            self.right_DID, self.root_DID, self.parent, self.children, self.first_SID, self.tot_size)
        if DEBUG == 2:
            # cre_lo, cre_hi, mod_lo, mod_hi = tsinfo
            print "timestamp info", self.tsinfo

def _build_family_tree(dirlist, parent_DID, child_DID):
    if child_DID < 0: return
    _build_family_tree(dirlist, parent_DID, dirlist[child_DID].left_DID)
    dirlist[parent_DID].children.append(child_DID)
    dirlist[child_DID].parent = parent_DID
    _build_family_tree(dirlist, parent_DID, dirlist[child_DID].right_DID)
    if dirlist[child_DID].etype == 1: # storage
        _build_family_tree(dirlist, child_DID, dirlist[child_DID].root_DID)

##
# Compound document handler.
# @param mem The raw contents of the file, as a string, or as an mmap.mmap() object. The
# only operation it needs to support is slicing.

class CompDoc(object):

    def __init__(self, mem, logfile=sys.stdout, DEBUG=0):
        self.logfile = logfile
        if mem[0:8] != SIGNATURE:
            raise CompDocError('Not an OLE2 compound document')
        if mem[28:30] != '\xFE\xFF':
            raise CompDocError('Expected "little-endian" marker, found %r' % mem[28:30])
        revision, version = unpack('<HH', mem[24:28])
        if DEBUG:
            print >> logfile, "\nCompDoc format: version=0x%04x revision=0x%04x" % (version, revision)
        self.mem = mem
        ssz, sssz = unpack('<HH', mem[30:34])
        if ssz > 20: # allows for 2**20 bytes i.e. 1MB
            print >> logfile, \
                "WARNING: sector size (2**%d) is preposterous; assuming 512 and continuing ..." \
                % ssz
            ssz = 9
        if sssz > ssz:
            print >> logfile, \
                "WARNING: short stream sector size (2**%d) is preposterous; assuming 64 and continuing ..." \
                % sssz
            sssz = 6
        self.sec_size = sec_size = 1 << ssz
        self.short_sec_size = 1 << sssz
        (
            SAT_tot_secs, self.dir_first_sec_sid, _unused, self.min_size_std_stream,
            SSAT_first_sec_sid, SSAT_tot_secs,
            MSAT_first_sec_sid, MSAT_tot_secs,
        # ) = unpack('<ii4xiiiii', mem[44:76])
        ) = unpack('<iiiiiiii', mem[44:76])
        mem_data_len = len(mem) - 512
        mem_data_secs, left_over = divmod(mem_data_len, sec_size)
        if left_over:
            #### raise CompDocError("Not a whole number of sectors")
            print >> logfile, \
                "WARNING *** file size (%d) not 512 + multiple of sector size (%d)" \
                % (len(mem), sec_size)
        if DEBUG:
            print >> logfile, 'sec sizes', ssz, sssz, sec_size, self.short_sec_size
            print >> logfile, "mem data: %d bytes == %d sectors" % (mem_data_len, mem_data_secs)
            print >> logfile, "SAT_tot_secs=%d, dir_first_sec_sid=%d, min_size_std_stream=%d" \
                % (SAT_tot_secs, self.dir_first_sec_sid, self.min_size_std_stream,)
            print >> logfile, "SSAT_first_sec_sid=%d, SSAT_tot_secs=%d" % (SSAT_first_sec_sid, SSAT_tot_secs,)
            print >> logfile, "MSAT_first_sec_sid=%d, MSAT_tot_secs=%d" % (MSAT_first_sec_sid, MSAT_tot_secs,)
        nent = int_floor_div(sec_size, 4) # number of SID entries in a sector
        fmt = "<%di" % nent
        trunc_warned = 0
        #
        # === build the MSAT ===
        #
        MSAT = list(unpack('<109i', mem[76:512]))
        sid = MSAT_first_sec_sid
        while sid >= 0:
            if sid >= mem_data_secs:
                raise CompDocError(
                    "MSAT extension: accessing sector %d but only %d in file" % (sid, mem_data_secs)
                    )
            offset = 512 + sec_size * sid
            news = list(unpack(fmt, mem[offset:offset+sec_size]))
            sid = news.pop()
            MSAT.extend(news)
        if DEBUG:
            print >> logfile, "MSAT: len =", len(MSAT)
            print >> logfile, MSAT
        #
        # === build the SAT ===
        #
        self.SAT = []
        for msid in MSAT:
            if msid == FREESID: continue
            if msid >= mem_data_secs:
                if not trunc_warned:
                    print >> logfile, "WARNING *** File is truncated, or OLE2 MSAT is corrupt!!"
                    print >> logfile, \
                        "INFO: Trying to access sector %d but only %d available" \
                        % (msid, mem_data_secs)
                    trunc_warned = 1
                continue
            offset = 512 + sec_size * msid
            news = list(unpack(fmt, mem[offset:offset+sec_size]))
            self.SAT.extend(news)
        if DEBUG:
            print >> logfile, "SAT: len =", len(self.SAT)
            print >> logfile, self.SAT
            # print >> logfile, "SAT ",
            # for i, s in enumerate(self.SAT):
                # print >> logfile, "entry: %4d offset: %6d, next entry: %4d" % (i, 512 + sec_size * i, s)
                # print >> logfile, "%d:%d " % (i, s),
            print

        # === build the directory ===
        #
        dbytes = self._get_stream(
            self.mem, 512, self.SAT, self.sec_size, self.dir_first_sec_sid,
            name="directory")
        dirlist = []
        did = -1
        for pos in xrange(0, len(dbytes), 128):
            did += 1
            dirlist.append(DirNode(did, dbytes[pos:pos+128], 0))
        self.dirlist = dirlist
        _build_family_tree(dirlist, 0, dirlist[0].root_DID) # and stand well back ...
        if DEBUG:
            for d in dirlist:
                d.dump(DEBUG)
        #
        # === get the SSCS ===
        #
        sscs_dir = self.dirlist[0]
        assert sscs_dir.etype == 5 # root entry
        if sscs_dir.first_SID < 0 and sscs_dir.tot_size == 0:
            # Problem reported by Frank Hoffsuemmer: some software was
            # writing -1 instead of -2 (EOCSID) for the first_SID
            # when the SCCS was empty. Not having EOCSID caused assertion
            # failure in _get_stream.
            # Solution: avoid calling _get_stream in any case when the
            # SCSS appears to be empty.
            self.SSCS = ""
        else:
            self.SSCS = self._get_stream(
                self.mem, 512, self.SAT, sec_size, sscs_dir.first_SID,
                sscs_dir.tot_size, name="SSCS")
        # if DEBUG: print >> logfile, "SSCS", repr(self.SSCS)
        #
        # === build the SSAT ===
        #
        self.SSAT = []
        if SSAT_tot_secs > 0 and sscs_dir.tot_size == 0:
            print >> logfile, \
                "WARNING *** OLE2 inconsistency: SSCS size is 0 but SSAT size is non-zero"
        if sscs_dir.tot_size > 0:
            sid = SSAT_first_sec_sid
            nsecs = SSAT_tot_secs
            while sid >= 0 and nsecs > 0:
                nsecs -= 1
                start_pos = 512 + sid * sec_size
                news = list(unpack(fmt, mem[start_pos:start_pos+sec_size]))
                self.SSAT.extend(news)
                sid = self.SAT[sid]
            # assert SSAT_tot_secs == 0 or sid == EOCSID
            if DEBUG: print >> logfile, "SSAT last sid %d; remaining sectors %d" % (sid, nsecs)
            assert nsecs == 0 and sid == EOCSID
        if DEBUG: print >> logfile, "SSAT", self.SSAT

    def _get_stream(self, mem, base, sat, sec_size, start_sid, size=None, name=''):
        # print >> self.logfile, "_get_stream", base, sec_size, start_sid, size
        sectors = []
        s = start_sid
        if size is None:
            # nothing to check against
            while s >= 0:
                start_pos = base + s * sec_size
                sectors.append(mem[start_pos:start_pos+sec_size])
                try:
                    s = sat[s]
                except IndexError:
                    raise CompDocError(
                        "OLE2 stream %r: sector allocation table invalid entry (%d)" %
                        (name, s)
                        )
            assert s == EOCSID
        else:
            todo = size
            while s >= 0:
                start_pos = base + s * sec_size
                grab = sec_size
                if grab > todo:
                    grab = todo
                todo -= grab
                sectors.append(mem[start_pos:start_pos+grab])
                try:
                    s = sat[s]
                except IndexError:
                    raise CompDocError(
                        "OLE2 stream %r: sector allocation table invalid entry (%d)" %
                        (name, s)
                        )
            assert s == EOCSID
            if todo != 0:
                print >> self.logfile, \
                    "WARNING *** OLE2 stream %r: expected size %d, actual size %d" \
                    % (name, size, size - todo)
        return ''.join(sectors)

    def _dir_search(self, path, storage_DID=0):
        # Return matching DirNode instance, or None
        head = path[0]
        tail = path[1:]
        dl = self.dirlist
        for child in dl[storage_DID].children:
            if dl[child].name.lower() == head.lower():
                et = dl[child].etype
                if et == 2:
                    return dl[child]
                if et == 1:
                    if not tail:
                        raise CompDocError("Requested component is a 'storage'")
                    return self._dir_search(tail, child)
                dl[child].dump(1)
                raise CompDocError("Requested stream is not a 'user stream'")
        return None

    ##
    # Interrogate the compound document's directory; return the stream as a string if found, otherwise
    # return None.
    # @param qname Name of the desired stream e.g. u'Workbook'. Should be in Unicode or convertible thereto.

    def get_named_stream(self, qname):
        d = self._dir_search(qname.split("/"))
        if d is None:
            return None
        if d.tot_size >= self.min_size_std_stream:
            return self._get_stream(
                self.mem, 512, self.SAT, self.sec_size, d.first_SID,
                d.tot_size, name=qname)
        else:
            return self._get_stream(
                self.SSCS, 0, self.SSAT, self.short_sec_size, d.first_SID,
                d.tot_size, name=qname + " (from SSCS)")

    ##
    # Interrogate the compound document's directory.
    # If the named stream is not found, (None, 0, 0) will be returned.
    # If the named stream is found and is contiguous within the original byte sequence ("mem")
    # used when the document was opened,
    # then (mem, offset_to_start_of_stream, length_of_stream) is returned.
    # Otherwise a new string is built from the fragments and (new_string, 0, length_of_stream) is returned.
    # @param qname Name of the desired stream e.g. u'Workbook'. Should be in Unicode or convertible thereto.

    def locate_named_stream(self, qname):
        d = self._dir_search(qname.split("/"))
        if d is None:
            return (None, 0, 0)
        if d.tot_size >= self.min_size_std_stream:
            return self._locate_stream(self.mem, 512, self.SAT, self.sec_size, d.first_SID, d.tot_size)
        else:
            return (
                self._get_stream(
                    self.SSCS, 0, self.SSAT, self.short_sec_size, d.first_SID,
                    d.tot_size, qname + " (from SSCS)"),
                0,
                d.tot_size
                )
        return (None, 0, 0) # not found

    def _locate_stream(self, mem, base, sat, sec_size, start_sid, size):
        # print >> self.logfile, "_locate_stream", base, sec_size, start_sid, size
        s = start_sid
        if s < 0:
            raise CompDocError("_locate_stream: start_sid (%d) is -ve" % start_sid)
        p = -99 # dummy previous SID
        start_pos = -9999
        end_pos = -8888
        slices = []
        while s >= 0:
            if s == p+1:
                # contiguous sectors
                end_pos += sec_size
            else:
                # start new slice
                if p >= 0:
                    # not first time
                    slices.append((start_pos, end_pos))
                start_pos = base + s * sec_size
                end_pos = start_pos + sec_size
            p = s
            s = sat[s]
        assert s == EOCSID
        # print >> self.logfile, len(slices) + 1, "slices"
        if not slices:
            # The stream is contiguous ... just what we like!
            return (mem, start_pos, size)
        slices.append((start_pos, end_pos))
        return (''.join([mem[start_pos:end_pos] for start_pos, end_pos in slices]), 0, size)

# ==========================================================================================

########NEW FILE########
__FILENAME__ = xlrdnameAPIdemo
# -*- coding: cp1252 -*-

##
# Module/script example of the xlrd API for extracting information
# about named references, named constants, etc.
#
# <p>Copyright  2006 Stephen John Machin, Lingfo Pty Ltd</p>
# <p>This module is part of the xlrd package, which is released under a BSD-style licence.</p>
##

import xlrd
import sys
import glob

def scope_as_string(book, scope):
    if 0 <= scope < book.nsheets:
        return "sheet #%d (%r)" % (scope, book.sheet_names()[scope])
    if scope == -1:
        return "Global"
    if scope == -2:
        return "Macro/VBA"
    return "Unknown scope value (%r)" % scope

def do_scope_query(book, scope_strg, show_contents=0, f=sys.stdout):
    try:
        qscope = int(scope_strg)
    except ValueError:
        if scope_strg == "*":
            qscope = None # means "all'
        else:
            # so assume it's a sheet name ...
            qscope = book.sheet_names().index(scope_strg)
            print >> f, "%r => %d" % (scope_strg, qscope)
    for nobj in book.name_obj_list:
        if qscope is None or nobj.scope == qscope:
            show_name_object(book, nobj, show_contents, f)

def show_name_details(book, name, show_contents=0, f=sys.stdout):
    """
    book -- Book object obtained from xlrd.open_workbook().
    name -- The name that's being investigated.
    show_contents -- 0: Don't; 1: Non-empty cells only; 2: All cells
    f -- Open output file handle.
    """
    name_lcase = name.lower() # Excel names are case-insensitive.
    nobj_list = book.name_map.get(name_lcase)
    if not nobj_list:
        print >> f, "%r: unknown name" % name
        return
    for nobj in nobj_list:
        show_name_object(book, nobj, show_contents, f)

def show_name_details_in_scope(
    book, name, scope_strg, show_contents=0, f=sys.stdout,
    ):
    try:
        scope = int(scope_strg)
    except ValueError:
        # so assume it's a sheet name ...
        scope = book.sheet_names().index(scope_strg)
        print >> f, "%r => %d" % (scope_strg, scope)
    name_lcase = name.lower() # Excel names are case-insensitive.
    while 1:
        nobj = book.name_and_scope_map.get((name_lcase, scope))
        if nobj:
            break
        print >> f, "Name %r not found in scope %d" % (name, scope)
        if scope == -1:
            return
        scope = -1 # Try again with global scope
    print >> f, "Name %r found in scope %d" % (name, scope)
    show_name_object(book, nobj, show_contents, f)

def showable_cell_value(celltype, cellvalue, datemode):
    if celltype == xlrd.XL_CELL_DATE:
        try:
            showval = xlrd.xldate_as_tuple(cellvalue, datemode)
        except xlrd.XLDateError:
            e1, e2 = sys.exc_info()[:2]
            showval = "%s:%s" % (e1.__name__, e2)
    elif celltype == xlrd.XL_CELL_ERROR:
        showval = xlrd.error_text_from_code.get(
            cellvalue, '<Unknown error code 0x%02x>' % cellvalue)
    else:
        showval = cellvalue
    return showval

def show_name_object(book, nobj, show_contents=0, f=sys.stdout):
    print >> f, "\nName: %r, scope: %r (%s)" \
        % (nobj.name, nobj.scope, scope_as_string(book, nobj.scope))
    res = nobj.result
    print >> f, "Formula eval result: %r" % res
    if res is None:
        return
    # result should be an instance of the Operand class
    kind = res.kind
    value = res.value
    if kind >= 0:
        # A scalar, or unknown ... you've seen all there is to see.
        pass
    elif kind == xlrd.oREL:
        # A list of Ref3D objects representing *relative* ranges
        for i in xrange(len(value)):
            ref3d = value[i]
            print >> f, "Range %d: %r ==> %s"% (i, ref3d.coords, xlrd.rangename3drel(book, ref3d))
    elif kind == xlrd.oREF:
        # A list of Ref3D objects
        for i in xrange(len(value)):
            ref3d = value[i]
            print >> f, "Range %d: %r ==> %s"% (i, ref3d.coords, xlrd.rangename3d(book, ref3d))
            if not show_contents:
                continue
            datemode = book.datemode
            for shx in xrange(ref3d.shtxlo, ref3d.shtxhi):
                sh = book.sheet_by_index(shx)
                print >> f, "   Sheet #%d (%s)" % (shx, sh.name)
                rowlim = min(ref3d.rowxhi, sh.nrows)
                collim = min(ref3d.colxhi, sh.ncols)
                for rowx in xrange(ref3d.rowxlo, rowlim):
                    for colx in xrange(ref3d.colxlo, collim):
                        cty = sh.cell_type(rowx, colx)
                        if cty == xlrd.XL_CELL_EMPTY and show_contents == 1:
                            continue
                        cval = sh.cell_value(rowx, colx)
                        sval = showable_cell_value(cty, cval, datemode)
                        print >> f, "      (%3d,%3d) %-5s: %r" \
                            % (rowx, colx, xlrd.cellname(rowx, colx), sval)

if __name__ == "__main__":
    def usage():
        text = """
usage: xlrdnameAIPdemo.py glob_pattern name scope show_contents

where:
    "glob_pattern" designates a set of files
    "name" is a name or '*' (all names)
    "scope" is -1 (global) or a sheet number
        or a sheet name or * (all scopes)
    "show_contents" is one of 0 (no show),
       1 (only non-empty cells), or 2 (all cells)

Examples (script name and glob_pattern arg omitted for brevity)
    [Searching through book.name_obj_list]
    * * 0 lists all names
    * * 1 lists all names, showing referenced non-empty cells
    * 1 0 lists all names local to the 2nd sheet
    * Northern 0 lists all names local to the 'Northern' sheet
    * -1 0 lists all names with global scope
    [Initial direct access through book.name_map]
    Sales * 0 lists all occurrences of "Sales" in any scope
    [Direct access through book.name_and_scope_map]
    Revenue -1 0 checks if "Revenue" exists in global scope

"""
        sys.stdout.write(text)
    
    if len(sys.argv) != 5:
        usage()
        sys.exit(0)
    arg_pattern = sys.argv[1] # glob pattern e.g. "foo*.xls"
    arg_name = sys.argv[2]    # see below
    arg_scope = sys.argv[3]   # see below
    arg_show_contents = int(sys.argv[4]) # 0: no show, 1: only non-empty cells,
                                         # 2: all cells
    for fname in glob.glob(arg_pattern):
        book = xlrd.open_workbook(fname)
        if arg_name == "*":
            # Examine book.name_obj_list to find all names
            # in a given scope ("*" => all scopes)
            do_scope_query(book, arg_scope, arg_show_contents)
        elif arg_scope == "*":
            # Using book.name_map to find all usage of a name.
            show_name_details(book, arg_name, arg_show_contents)
        else:
            # Using book.name_and_scope_map to find which if any instances
            # of a name are visible in the given scope, which can be supplied
            # as -1 (global) or a sheet number or a sheet name.
            show_name_details_in_scope(book, arg_name, arg_scope, arg_show_contents)

########NEW FILE########
__FILENAME__ = formatting
# -*- coding:cp1252 -*-

##
# Module for formatting information.
#
# <p>Copyright  2005-2008 Stephen John Machin, Lingfo Pty Ltd</p>
# <p>Copyright  2005-2009 Stephen John Machin, Lingfo Pty Ltd</p>
# <p>This module is part of the xlrd package, which is released under
# a BSD-style licence.</p>
##

# No part of the content of this file was derived from the works of David Giffin.

# 2009-05-31 SJM Fixed problem with non-zero reserved bits in some STYLE records in Mac Excel files
# 2008-08-03 SJM Ignore PALETTE record when Book.formatting_info is false
# 2008-08-03 SJM Tolerate up to 4 bytes trailing junk on PALETTE record
# 2008-05-10 SJM Do some XF checks only when Book.formatting_info is true
# 2008-02-08 SJM Preparation for Excel 2.0 support
# 2008-02-03 SJM Another tweak to is_date_format_string()
# 2007-12-04 SJM Added support for Excel 2.x (BIFF2) files.
# 2007-10-13 SJM Warning: style XF whose parent XF index != 0xFFF
# 2007-09-08 SJM Work around corrupt STYLE record
# 2007-07-11 SJM Allow for BIFF2/3-style FORMAT record in BIFF4/8 file

DEBUG = 0
import copy, re
from timemachine import *
from biffh import BaseObject, unpack_unicode, unpack_string, \
    upkbits, upkbitsL, fprintf, \
    FUN, FDT, FNU, FGE, FTX, XL_CELL_NUMBER, XL_CELL_DATE, \
    XL_FORMAT, XL_FORMAT2, \
    XLRDError
from struct import unpack

excel_default_palette_b5 = (
    (  0,   0,   0), (255, 255, 255), (255,   0,   0), (  0, 255,   0),
    (  0,   0, 255), (255, 255,   0), (255,   0, 255), (  0, 255, 255),
    (128,   0,   0), (  0, 128,   0), (  0,   0, 128), (128, 128,   0),
    (128,   0, 128), (  0, 128, 128), (192, 192, 192), (128, 128, 128),
    (153, 153, 255), (153,  51, 102), (255, 255, 204), (204, 255, 255),
    (102,   0, 102), (255, 128, 128), (  0, 102, 204), (204, 204, 255),
    (  0,   0, 128), (255,   0, 255), (255, 255,   0), (  0, 255, 255),
    (128,   0, 128), (128,   0,   0), (  0, 128, 128), (  0,   0, 255),
    (  0, 204, 255), (204, 255, 255), (204, 255, 204), (255, 255, 153),
    (153, 204, 255), (255, 153, 204), (204, 153, 255), (227, 227, 227),
    ( 51, 102, 255), ( 51, 204, 204), (153, 204,   0), (255, 204,   0),
    (255, 153,   0), (255, 102,   0), (102, 102, 153), (150, 150, 150),
    (  0,  51, 102), ( 51, 153, 102), (  0,  51,   0), ( 51,  51,   0),
    (153,  51,   0), (153,  51, 102), ( 51,  51, 153), ( 51,  51,  51),
    )

excel_default_palette_b2 = excel_default_palette_b5[:16]

# Following two tables borrowed from Gnumeric 1.4 source.
excel_default_palette_b5_gnumeric_14 = (
    #### dodgy; didn't match Excel results
    (  0,  0,  0), (255,255,255), (255,  0,  0), (  0,255,  0),
    (  0,  0,255), (255,255,  0), (255,  0,255), (  0,255,255),
    (128,  0,  0), (  0,128,  0), (  0,  0,128), (128,128,  0),
    (128,  0,128), (  0,128,128), (192,192,192), (128,128,128),
    (128,128,255), (128, 32, 96), (255,255,192), (160,224,224),
    ( 96,  0,128), (255,128,128), (  0,128,192), (192,192,255),
    (  0,  0,128), (255,  0,255), (255,255,  0), (  0,255,255),
    (128,  0,128), (128,  0,  0), (  0,128,128), (  0,  0,255),
    (  0,204,255), (105,255,255), (204,255,204), (255,255,153),
    (166,202,240), (204,156,204), (204,153,255), (227,227,227),
    ( 51,102,255), ( 51,204,204), ( 51,153, 51), (153,153, 51),
    (153,102, 51), (153,102,102), (102,102,153), (150,150,150),
    ( 51, 51,204), ( 51,102,102), (  0, 51,  0), ( 51, 51,  0),
    (102, 51,  0), (153, 51,102), ( 51, 51,153), ( 66, 66, 66),
    )
excel_default_palette_b8 = ( # (red, green, blue)
    (  0,  0,  0), (255,255,255), (255,  0,  0), (  0,255,  0),
    (  0,  0,255), (255,255,  0), (255,  0,255), (  0,255,255),
    (128,  0,  0), (  0,128,  0), (  0,  0,128), (128,128,  0),
    (128,  0,128), (  0,128,128), (192,192,192), (128,128,128),
    (153,153,255), (153, 51,102), (255,255,204), (204,255,255),
    (102,  0,102), (255,128,128), (  0,102,204), (204,204,255),
    (  0,  0,128), (255,  0,255), (255,255,  0), (  0,255,255),
    (128,  0,128), (128,  0,  0), (  0,128,128), (  0,  0,255),
    (  0,204,255), (204,255,255), (204,255,204), (255,255,153),
    (153,204,255), (255,153,204), (204,153,255), (255,204,153),
    ( 51,102,255), ( 51,204,204), (153,204,  0), (255,204,  0),
    (255,153,  0), (255,102,  0), (102,102,153), (150,150,150),
    (  0, 51,102), ( 51,153,102), (  0, 51,  0), ( 51, 51,  0),
    (153, 51,  0), (153, 51,102), ( 51, 51,153), ( 51, 51, 51),
    )

default_palette = {
    80: excel_default_palette_b8,
    70: excel_default_palette_b5,
    50: excel_default_palette_b5,
    45: excel_default_palette_b2,
    40: excel_default_palette_b2,
    30: excel_default_palette_b2,
    21: excel_default_palette_b2,
    20: excel_default_palette_b2,
    }

"""
00H = Normal
01H = RowLevel_lv (see next field)
02H = ColLevel_lv (see next field)
03H = Comma
04H = Currency
05H = Percent
06H = Comma [0] (BIFF4-BIFF8)
07H = Currency [0] (BIFF4-BIFF8)
08H = Hyperlink (BIFF8)
09H = Followed Hyperlink (BIFF8)
"""
built_in_style_names = [
    "Normal",
    "RowLevel_",
    "ColLevel_",
    "Comma",
    "Currency",
    "Percent",
    "Comma [0]",
    "Currency [0]",
    "Hyperlink",
    "Followed Hyperlink",
    ]

def initialise_colour_map(book):
    book.colour_map = {}
    book.colour_indexes_used = {}
    if not book.formatting_info:
        return
    # Add the 8 invariant colours
    for i in xrange(8):
        book.colour_map[i] = excel_default_palette_b8[i]
    # Add the default palette depending on the version
    dpal = default_palette[book.biff_version]
    ndpal = len(dpal)
    for i in xrange(ndpal):
        book.colour_map[i+8] = dpal[i]
    # Add the specials -- None means the RGB value is not known
    # System window text colour for border lines
    book.colour_map[ndpal+8] = None
    # System window background colour for pattern background
    book.colour_map[ndpal+8+1] = None #
    for ci in (
        0x51, # System ToolTip text colour (used in note objects)
        0x7FFF, # 32767, system window text colour for fonts
        ):
        book.colour_map[ci] = None

def nearest_colour_index(colour_map, rgb, debug=0):
    # General purpose function. Uses Euclidean distance.
    # So far used only for pre-BIFF8 WINDOW2 record.
    # Doesn't have to be fast.
    # Doesn't have to be fancy.
    best_metric = 3 * 256 * 256
    best_colourx = 0
    for colourx, cand_rgb in colour_map.items():
        if cand_rgb is None:
            continue
        metric = 0
        for v1, v2 in zip(rgb, cand_rgb):
            metric += (v1 - v2) * (v1 - v2)
        if metric < best_metric:
            best_metric = metric
            best_colourx = colourx
            if metric == 0:
                break
    if debug:
        print "nearest_colour_index for %r is %r -> %r; best_metric is %d" \
            % (rgb, best_colourx, colour_map[best_colourx], best_metric)
    return best_colourx

##
# This mixin class exists solely so that Format, Font, and XF.... objects
# can be compared by value of their attributes.
class EqNeAttrs(object):

    def __eq__(self, other):
        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        return self.__dict__ != other.__dict__

##
# An Excel "font" contains the details of not only what is normally
# considered a font, but also several other display attributes.
# Items correspond to those in the Excel UI's Format/Cells/Font tab.
# <br /> -- New in version 0.6.1
class Font(BaseObject, EqNeAttrs):
    ##
    # 1 = Characters are bold. Redundant; see "weight" attribute.
    bold = 0
    ##
    # Values: 0 = ANSI Latin, 1 = System default, 2 = Symbol,
    # 77 = Apple Roman,
    # 128 = ANSI Japanese Shift-JIS,
    # 129 = ANSI Korean (Hangul),
    # 130 = ANSI Korean (Johab),
    # 134 = ANSI Chinese Simplified GBK,
    # 136 = ANSI Chinese Traditional BIG5,
    # 161 = ANSI Greek,
    # 162 = ANSI Turkish,
    # 163 = ANSI Vietnamese,
    # 177 = ANSI Hebrew,
    # 178 = ANSI Arabic,
    # 186 = ANSI Baltic,
    # 204 = ANSI Cyrillic,
    # 222 = ANSI Thai,
    # 238 = ANSI Latin II (Central European),
    # 255 = OEM Latin I
    character_set = 0
    ##
    # An explanation of "colour index" is given in the Formatting
    # section at the start of this document.
    colour_index = 0
    ##
    # 1 = Superscript, 2 = Subscript.
    escapement = 0
    ##
    # 0 = None (unknown or don't care)<br />
    # 1 = Roman (variable width, serifed)<br />
    # 2 = Swiss (variable width, sans-serifed)<br />
    # 3 = Modern (fixed width, serifed or sans-serifed)<br />
    # 4 = Script (cursive)<br />
    # 5 = Decorative (specialised, for example Old English, Fraktur)
    family = 0
    ##
    # The 0-based index used to refer to this Font() instance.
    # Note that index 4 is never used; xlrd supplies a dummy place-holder.
    font_index = 0
    ##
    # Height of the font (in twips). A twip = 1/20 of a point.
    height = 0
    ##
    # 1 = Characters are italic.
    italic = 0
    ##
    # The name of the font. Example: u"Arial"
    name = u""
    ##
    # 1 = Characters are struck out.
    struck_out = 0
    ##
    # 0 = None<br />
    # 1 = Single;  0x21 (33) = Single accounting<br />
    # 2 = Double;  0x22 (34) = Double accounting
    underline_type = 0
    ##
    # 1 = Characters are underlined. Redundant; see "underline_type" attribute.
    underlined = 0
    ##
    # Font weight (100-1000). Standard values are 400 for normal text
    # and 700 for bold text.
    weight = 400
    ##
    # 1 = Font is outline style (Macintosh only)
    outline = 0
    ##
    # 1 = Font is shadow style (Macintosh only)
    shadow = 0

    # No methods ...

def handle_efont(book, data): # BIFF2 only
    if not book.formatting_info:
        return
    book.font_list[-1].colour_index = unpack('<H', data)[0]

def handle_font(book, data):
    if not book.formatting_info:
        return
    if not book.encoding:
        book.derive_encoding()
    blah = DEBUG or book.verbosity >= 2
    bv = book.biff_version
    k = len(book.font_list)
    if k == 4:
        f = Font()
        f.name = u'Dummy Font'
        f.font_index = k
        book.font_list.append(f)
        k += 1
    f = Font()
    f.font_index = k
    book.font_list.append(f)
    if bv >= 50:
        (
            f.height, option_flags, f.colour_index, f.weight,
            f.escapement_type, f.underline_type, f.family,
            f.character_set,
        ) = unpack('<HHHHHBBB', data[0:13])
        f.bold = option_flags & 1
        f.italic = (option_flags & 2) >> 1
        f.underlined = (option_flags & 4) >> 2
        f.struck_out = (option_flags & 8) >> 3
        f.outline = (option_flags & 16) >> 4
        f.shadow = (option_flags & 32) >> 5
        if bv >= 80:
            f.name = unpack_unicode(data, 14, lenlen=1)
        else:
            f.name = unpack_string(data, 14, book.encoding, lenlen=1)
    elif bv >= 30:
        f.height, option_flags, f.colour_index = unpack('<HHH', data[0:6])
        f.bold = option_flags & 1
        f.italic = (option_flags & 2) >> 1
        f.underlined = (option_flags & 4) >> 2
        f.struck_out = (option_flags & 8) >> 3
        f.outline = (option_flags & 16) >> 4
        f.shadow = (option_flags & 32) >> 5
        f.name = unpack_string(data, 6, book.encoding, lenlen=1)
        # Now cook up the remaining attributes ...
        f.weight = [400, 700][f.bold]
        f.escapement_type = 0 # None
        f.underline_type = f.underlined # None or Single
        f.family = 0 # Unknown / don't care
        f.character_set = 1 # System default (0 means "ANSI Latin")
    else: # BIFF2
        f.height, option_flags = unpack('<HH', data[0:4])
        f.colour_index = 0x7FFF # "system window text colour"
        f.bold = option_flags & 1
        f.italic = (option_flags & 2) >> 1
        f.underlined = (option_flags & 4) >> 2
        f.struck_out = (option_flags & 8) >> 3
        f.outline = 0
        f.shadow = 0
        f.name = unpack_string(data, 4, book.encoding, lenlen=1)
        # Now cook up the remaining attributes ...
        f.weight = [400, 700][f.bold]
        f.escapement_type = 0 # None
        f.underline_type = f.underlined # None or Single
        f.family = 0 # Unknown / don't care
        f.character_set = 1 # System default (0 means "ANSI Latin")
    if blah:
        f.dump(
            book.logfile,
            header="--- handle_font: font[%d] ---" % f.font_index,
            footer="-------------------",
            )

# === "Number formats" ===

##
# "Number format" information from a FORMAT record.
# <br /> -- New in version 0.6.1
class Format(BaseObject, EqNeAttrs):
    ##
    # The key into Book.format_map
    format_key = 0
    ##
    # A classification that has been inferred from the format string.
    # Currently, this is used only to distinguish between numbers and dates.
    # <br />Values:
    # <br />FUN = 0 # unknown
    # <br />FDT = 1 # date
    # <br />FNU = 2 # number
    # <br />FGE = 3 # general
    # <br />FTX = 4 # text
    type = FUN
    ##
    # The format string
    format_str = u''

    def __init__(self, format_key, ty, format_str):
        self.format_key = format_key
        self.type = ty
        self.format_str = format_str

std_format_strings = {
    # "std" == "standard for US English locale"
    # #### TODO ... a lot of work to tailor these to the user's locale.
    # See e.g. gnumeric-1.x.y/src/formats.c
    0x00: "General",
    0x01: "0",
    0x02: "0.00",
    0x03: "#,##0",
    0x04: "#,##0.00",
    0x05: "$#,##0_);($#,##0)",
    0x06: "$#,##0_);[Red]($#,##0)",
    0x07: "$#,##0.00_);($#,##0.00)",
    0x08: "$#,##0.00_);[Red]($#,##0.00)",
    0x09: "0%",
    0x0a: "0.00%",
    0x0b: "0.00E+00",
    0x0c: "# ?/?",
    0x0d: "# ??/??",
    0x0e: "m/d/yy",
    0x0f: "d-mmm-yy",
    0x10: "d-mmm",
    0x11: "mmm-yy",
    0x12: "h:mm AM/PM",
    0x13: "h:mm:ss AM/PM",
    0x14: "h:mm",
    0x15: "h:mm:ss",
    0x16: "m/d/yy h:mm",
    0x25: "#,##0_);(#,##0)",
    0x26: "#,##0_);[Red](#,##0)",
    0x27: "#,##0.00_);(#,##0.00)",
    0x28: "#,##0.00_);[Red](#,##0.00)",
    0x29: "_(* #,##0_);_(* (#,##0);_(* \"-\"_);_(@_)",
    0x2a: "_($* #,##0_);_($* (#,##0);_($* \"-\"_);_(@_)",
    0x2b: "_(* #,##0.00_);_(* (#,##0.00);_(* \"-\"??_);_(@_)",
    0x2c: "_($* #,##0.00_);_($* (#,##0.00);_($* \"-\"??_);_(@_)",
    0x2d: "mm:ss",
    0x2e: "[h]:mm:ss",
    0x2f: "mm:ss.0",
    0x30: "##0.0E+0",
    0x31: "@",
    }

fmt_code_ranges = [ # both-inclusive ranges of "standard" format codes
    # Source: the openoffice.org doc't
    ( 0,  0, FGE),
    ( 1, 13, FNU),
    (14, 22, FDT),
    #### (27, 36, FDT), # Japanese dates -- not sure of reliability of this
    (37, 44, FNU),
    (45, 47, FDT),
    (48, 48, FNU),
    (49, 49, FTX),
    ####(50, 58, FDT), # Japanese dates -- but Gnumeric assumes
                       # built-in formats finish at 49, not at 163
    ]

std_format_code_types = {}
for lo, hi, ty in fmt_code_ranges:
    for x in xrange(lo, hi+1):
        std_format_code_types[x] = ty
del lo, hi, ty, x

date_chars = u'ymdhs' # year, month/minute, day, hour, second
date_char_dict = {}
for _c in date_chars + date_chars.upper():
    date_char_dict[_c] = 5
del _c, date_chars

skip_char_dict = {}
for _c in u'$-+/(): ':
    skip_char_dict[_c] = 1

num_char_dict = {
    u'0': 5,
    u'#': 5,
    u'?': 5,
    }

non_date_formats = {
    u'0.00E+00':1,
    u'##0.0E+0':1,
    u'General' :1,
    u'GENERAL' :1, # OOo Calc 1.1.4 does this.
    u'general' :1,  # pyExcelerator 0.6.3 does this.
    u'@'       :1,
    }

fmt_bracketed_sub = re.compile(r'\[[^]]*\]').sub

# Boolean format strings (actual cases)
# u'"Yes";"Yes";"No"'
# u'"True";"True";"False"'
# u'"On";"On";"Off"'

def is_date_format_string(book, fmt):
    # Heuristics:
    # Ignore "text" and [stuff in square brackets (aarrgghh -- see below)].
    # Handle backslashed-escaped chars properly.
    # E.g. hh\hmm\mss\s should produce a display like 23h59m59s
    # Date formats have one or more of ymdhs (caseless) in them.
    # Numeric formats have # and 0.
    # N.B. u'General"."' hence get rid of "text" first.
    # TODO: Find where formats are interpreted in Gnumeric
    # TODO: u'[h]\\ \\h\\o\\u\\r\\s' ([h] means don't care about hours > 23)
    state = 0
    s = ''
    ignorable = skip_char_dict.has_key
    for c in fmt:
        if state == 0:
            if c == u'"':
                state = 1
            elif c in ur"\_*":
                state = 2
            elif ignorable(c):
                pass
            else:
                s += c
        elif state == 1:
            if c == u'"':
                state = 0
        elif state == 2:
            # Ignore char after backslash, underscore or asterisk
            state = 0
        assert 0 <= state <= 2
    if book.verbosity >= 4:
        print "is_date_format_string: reduced format is %r" % s
    s = fmt_bracketed_sub('', s)
    if non_date_formats.has_key(s):
        return False
    state = 0
    separator = ";"
    got_sep = 0
    date_count = num_count = 0
    for c in s:
        if date_char_dict.has_key(c):
            date_count += date_char_dict[c]
        elif num_char_dict.has_key(c):
            num_count += num_char_dict[c]
        elif c == separator:
            got_sep = 1
    # print num_count, date_count, repr(fmt)
    if date_count and not num_count:
        return True
    if num_count and not date_count:
        return False
    if date_count:
        fprintf(book.logfile,
            'WARNING *** is_date_format: ambiguous d=%d n=%d fmt=%r\n',
            date_count, num_count, fmt)
    elif not got_sep:
        fprintf(book.logfile,
            "WARNING *** format %r produces constant result\n",
            fmt)
    return date_count > num_count

def handle_format(self, data, rectype=XL_FORMAT):
    DEBUG = 0
    bv = self.biff_version
    if rectype == XL_FORMAT2:
        bv = min(bv, 30)
    if not self.encoding:
        self.derive_encoding()
    strpos = 2
    if bv >= 50:
        fmtkey = unpack('<H', data[0:2])[0]
    else:
        fmtkey = self.actualfmtcount
        if bv <= 30:
            strpos = 0
    self.actualfmtcount += 1
    if bv >= 80:
        unistrg = unpack_unicode(data, 2)
    else:
        unistrg = unpack_string(data, strpos, self.encoding, lenlen=1)
    blah = DEBUG or self.verbosity >= 3
    if blah:
        fprintf(self.logfile,
            "FORMAT: count=%d fmtkey=0x%04x (%d) s=%r\n",
            self.actualfmtcount, fmtkey, fmtkey, unistrg)
    is_date_s = self.is_date_format_string(unistrg)
    ty = [FGE, FDT][is_date_s]
    if not(fmtkey > 163 or bv < 50):
        # user_defined if fmtkey > 163
        # N.B. Gnumeric incorrectly starts these at 50 instead of 164 :-(
        # if earlier than BIFF 5, standard info is useless
        std_ty = std_format_code_types.get(fmtkey, FUN)
        # print "std ty", std_ty
        is_date_c = std_ty == FDT
        if 0 < fmtkey < 50 and (is_date_c ^ is_date_s):
            DEBUG = 2
            fprintf(self.logfile,
                "WARNING *** Conflict between "
                "std format key %d and its format string %r\n",
                fmtkey, unistrg)
    if DEBUG == 2:
        fprintf(self.logfile,
            "ty: %d; is_date_c: %r; is_date_s: %r; fmt_strg: %r",
            ty, is_date_c, is_date_s, unistrg)
    fmtobj = Format(fmtkey, ty, unistrg)
    if blah:
        fmtobj.dump(self.logfile,
            header="--- handle_format [%d] ---" % (self.actualfmtcount-1, ))
    self.format_map[fmtkey] = fmtobj
    self.format_list.append(fmtobj)

# =============================================================================

def handle_palette(book, data):
    if not book.formatting_info:
        return
    blah = DEBUG or book.verbosity >= 2
    n_colours, = unpack('<H', data[:2])
    expected_n_colours = (16, 56)[book.biff_version >= 50]
    if ((DEBUG or book.verbosity >= 1)
    and n_colours != expected_n_colours):
        fprintf(book.logfile,
            "NOTE *** Expected %d colours in PALETTE record, found %d\n",
            expected_n_colours, n_colours)
    elif blah:
        fprintf(book.logfile,
            "PALETTE record with %d colours\n", n_colours)
    fmt = '<xx%di' % n_colours # use i to avoid long integers
    expected_size = 4 * n_colours + 2
    actual_size = len(data)
    tolerance = 4
    if not expected_size <= actual_size <= expected_size + tolerance:
        raise XLRDError('PALETTE record: expected size %d, actual size %d' % (expected_size, actual_size))
    colours = unpack(fmt, data[:expected_size])
    assert book.palette_record == [] # There should be only 1 PALETTE record
    # a colour will be 0xbbggrr
    # IOW, red is at the little end
    for i in xrange(n_colours):
        c = colours[i]
        red   =  c        & 0xff
        green = (c >>  8) & 0xff
        blue  = (c >> 16) & 0xff
        old_rgb = book.colour_map[8+i]
        new_rgb = (red, green, blue)
        book.palette_record.append(new_rgb)
        book.colour_map[8+i] = new_rgb
        if blah:
            if new_rgb != old_rgb:
                print >> book.logfile, "%2d: %r -> %r" % (i, old_rgb, new_rgb)

def palette_epilogue(book):
    # Check colour indexes in fonts etc.
    # This must be done here as FONT records
    # come *before* the PALETTE record :-(
    for font in book.font_list:
        if font.font_index == 4: # the missing font record
            continue
        cx = font.colour_index
        if cx == 0x7fff: # system window text colour
            continue
        if book.colour_map.has_key(cx):
            book.colour_indexes_used[cx] = 1
        else:
            print "Size of colour table:", len(book.colour_map)
            print >> book.logfile, \
                "*** Font #%d (%r): colour index 0x%04x is unknown" \
                % (font.font_index, font.name, cx)
    if book.verbosity >= 1:
        used = book.colour_indexes_used.keys()
        used.sort()
        print >> book.logfile, "\nColour indexes used:\n%r\n" % used

def handle_style(book, data):
    blah = DEBUG or book.verbosity >= 2
    bv = book.biff_version
    flag_and_xfx, built_in_id, level = unpack('<HBB', data[:4])
    xf_index = flag_and_xfx & 0x0fff
    if (data == "\0\0\0\0"
    and "Normal" not in book.style_name_map):
        # Erroneous record (doesn't have built-in bit set).
        # Example file supplied by Jeff Bell.
        built_in = 1
        built_in_id = 0
        xf_index = 0
        name = "Normal"
        level = 255
    elif flag_and_xfx & 0x8000:
        # built-in style
        built_in = 1
        name = built_in_style_names[built_in_id]
        if 1 <= built_in_id <= 2:
            name += str(level + 1)
    else:
        # user-defined style
        if bv >= 80:
            name = unpack_unicode(data, 2, lenlen=2)
        else:
            name = unpack_string(data, 2, book.encoding, lenlen=1)
        if blah and not name:
            print >> book.logfile, \
                "WARNING *** A user-defined style has a zero-length name"
        built_in = 0
        built_in_id = 0
        level = 0
    book.style_name_map[name] = (built_in, xf_index)
    if blah:
        print >> book.logfile, \
            "STYLE: built_in=%d xf_index=%d built_in_id=%d level=%d name=%r" \
            % (built_in, xf_index, built_in_id, level, name)

def check_colour_indexes_in_obj(book, obj, orig_index):
    alist = obj.__dict__.items()
    alist.sort()
    for attr, nobj in alist:
        if hasattr(nobj, 'dump'):
            check_colour_indexes_in_obj(book, nobj, orig_index)
        elif attr.find('colour_index') >= 0:
            if book.colour_map.has_key(nobj):
                book.colour_indexes_used[nobj] = 1
                continue
            oname = obj.__class__.__name__
            print >> book.logfile, \
                "*** xf #%d : %s.%s =  0x%04x (unknown)" \
                % (orig_index, oname, attr, nobj)

def handle_xf(self, data):
    ### self is a Book instance
    # DEBUG = 0
    blah = DEBUG or self.verbosity >= 3
    bv = self.biff_version
    xf = XF()
    xf.alignment = XFAlignment()
    xf.alignment.indent_level = 0
    xf.alignment.shrink_to_fit = 0
    xf.alignment.text_direction = 0
    xf.border = XFBorder()
    xf.border.diag_up = 0
    xf.border.diag_down = 0
    xf.border.diag_colour_index = 0
    xf.border.diag_line_style = 0 # no line
    xf.background = XFBackground()
    xf.protection = XFProtection()
    # fill in the known standard formats
    if bv >= 50 and not self.xfcount:
        # i.e. do this once before we process the first XF record
        for x in std_format_code_types.keys():
            if not self.format_map.has_key(x):
                ty = std_format_code_types[x]
                fmt_str = std_format_strings[x]
                fmtobj = Format(x, ty, fmt_str)
                self.format_map[x] = fmtobj
    if bv >= 80:
        unpack_fmt = '<HHHBBBBIiH'
        (xf.font_index, xf.format_key, pkd_type_par,
        pkd_align1, xf.alignment.rotation, pkd_align2,
        pkd_used, pkd_brdbkg1, pkd_brdbkg2, pkd_brdbkg3,
        ) = unpack(unpack_fmt, data[0:20])
        upkbits(xf.protection, pkd_type_par, (
            (0, 0x01, 'cell_locked'),
            (1, 0x02, 'formula_hidden'),
            ))
        upkbits(xf, pkd_type_par, (
            (2, 0x0004, 'is_style'),
            # Following is not in OOo docs, but is mentioned
            # in Gnumeric source and also in (deep breath)
            # org.apache.poi.hssf.record.ExtendedFormatRecord.java
            (3, 0x0008, 'lotus_123_prefix'), # Meaning is not known.
            (4, 0xFFF0, 'parent_style_index'),
            ))
        upkbits(xf.alignment, pkd_align1, (
            (0, 0x07, 'hor_align'),
            (3, 0x08, 'text_wrapped'),
            (4, 0x70, 'vert_align'),
            ))
        upkbits(xf.alignment, pkd_align2, (
            (0, 0x0f, 'indent_level'),
            (4, 0x10, 'shrink_to_fit'),
            (6, 0xC0, 'text_direction'),
            ))
        reg = pkd_used >> 2
        for attr_stem in \
            "format font alignment border background protection".split():
            attr = "_" + attr_stem + "_flag"
            setattr(xf, attr, reg & 1)
            reg >>= 1
        upkbitsL(xf.border, pkd_brdbkg1, (
            (0,  0x0000000f,  'left_line_style'),
            (4,  0x000000f0,  'right_line_style'),
            (8,  0x00000f00,  'top_line_style'),
            (12, 0x0000f000,  'bottom_line_style'),
            (16, 0x007f0000,  'left_colour_index'),
            (23, 0x3f800000,  'right_colour_index'),
            (30, 0x40000000,  'diag_down'),
            (31, 0x80000000L, 'diag_up'),
            ))
        upkbits(xf.border, pkd_brdbkg2, (
            (0,  0x0000007F, 'top_colour_index'),
            (7,  0x00003F80, 'bottom_colour_index'),
            (14, 0x001FC000, 'diag_colour_index'),
            (21, 0x01E00000, 'diag_line_style'),
            ))
        upkbitsL(xf.background, pkd_brdbkg2, (
            (26, 0xFC000000L, 'fill_pattern'),
            ))
        upkbits(xf.background, pkd_brdbkg3, (
            (0, 0x007F, 'pattern_colour_index'),
            (7, 0x3F80, 'background_colour_index'),
            ))
    elif bv >= 50:
        unpack_fmt = '<HHHBBIi'
        (xf.font_index, xf.format_key, pkd_type_par,
        pkd_align1, pkd_orient_used,
        pkd_brdbkg1, pkd_brdbkg2,
        ) = unpack(unpack_fmt, data[0:16])
        upkbits(xf.protection, pkd_type_par, (
            (0, 0x01, 'cell_locked'),
            (1, 0x02, 'formula_hidden'),
            ))
        upkbits(xf, pkd_type_par, (
            (2, 0x0004, 'is_style'),
            (3, 0x0008, 'lotus_123_prefix'), # Meaning is not known.
            (4, 0xFFF0, 'parent_style_index'),
            ))
        upkbits(xf.alignment, pkd_align1, (
            (0, 0x07, 'hor_align'),
            (3, 0x08, 'text_wrapped'),
            (4, 0x70, 'vert_align'),
            ))
        orientation = pkd_orient_used & 0x03
        xf.alignment.rotation = [0, 255, 90, 180][orientation]
        reg = pkd_orient_used >> 2
        for attr_stem in \
            "format font alignment border background protection".split():
            attr = "_" + attr_stem + "_flag"
            setattr(xf, attr, reg & 1)
            reg >>= 1
        upkbitsL(xf.background, pkd_brdbkg1, (
            ( 0, 0x0000007F, 'pattern_colour_index'),
            ( 7, 0x00003F80, 'background_colour_index'),
            (16, 0x003F0000, 'fill_pattern'),
            ))
        upkbitsL(xf.border, pkd_brdbkg1, (
            (22, 0x01C00000,  'bottom_line_style'),
            (25, 0xFE000000L, 'bottom_colour_index'),
            ))
        upkbits(xf.border, pkd_brdbkg2, (
            ( 0, 0x00000007, 'top_line_style'),
            ( 3, 0x00000038, 'left_line_style'),
            ( 6, 0x000001C0, 'right_line_style'),
            ( 9, 0x0000FE00, 'top_colour_index'),
            (16, 0x007F0000, 'left_colour_index'),
            (23, 0x3F800000, 'right_colour_index'),
            ))
    elif bv >= 40:
        unpack_fmt = '<BBHBBHI'
        (xf.font_index, xf.format_key, pkd_type_par,
        pkd_align_orient, pkd_used,
        pkd_bkg_34, pkd_brd_34,
        ) = unpack(unpack_fmt, data[0:12])
        upkbits(xf.protection, pkd_type_par, (
            (0, 0x01, 'cell_locked'),
            (1, 0x02, 'formula_hidden'),
            ))
        upkbits(xf, pkd_type_par, (
            (2, 0x0004, 'is_style'),
            (3, 0x0008, 'lotus_123_prefix'), # Meaning is not known.
            (4, 0xFFF0, 'parent_style_index'),
            ))
        upkbits(xf.alignment, pkd_align_orient, (
            (0, 0x07, 'hor_align'),
            (3, 0x08, 'text_wrapped'),
            (4, 0x30, 'vert_align'),
            ))
        orientation = (pkd_align_orient & 0xC0) >> 6
        xf.alignment.rotation = [0, 255, 90, 180][orientation]
        reg = pkd_used >> 2
        for attr_stem in \
            "format font alignment border background protection".split():
            attr = "_" + attr_stem + "_flag"
            setattr(xf, attr, reg & 1)
            reg >>= 1
        upkbits(xf.background, pkd_bkg_34, (
            ( 0, 0x003F, 'fill_pattern'),
            ( 6, 0x07C0, 'pattern_colour_index'),
            (11, 0xF800, 'background_colour_index'),
            ))
        upkbitsL(xf.border, pkd_brd_34, (
            ( 0, 0x00000007,  'top_line_style'),
            ( 3, 0x000000F8,  'top_colour_index'),
            ( 8, 0x00000700,  'left_line_style'),
            (11, 0x0000F800,  'left_colour_index'),
            (16, 0x00070000,  'bottom_line_style'),
            (19, 0x00F80000,  'bottom_colour_index'),
            (24, 0x07000000,  'right_line_style'),
            (27, 0xF8000000L, 'right_colour_index'),
            ))
    elif bv == 30:
        unpack_fmt = '<BBBBHHI'
        (xf.font_index, xf.format_key, pkd_type_prot,
        pkd_used, pkd_align_par,
        pkd_bkg_34, pkd_brd_34,
        ) = unpack(unpack_fmt, data[0:12])
        upkbits(xf.protection, pkd_type_prot, (
            (0, 0x01, 'cell_locked'),
            (1, 0x02, 'formula_hidden'),
            ))
        upkbits(xf, pkd_type_prot, (
            (2, 0x0004, 'is_style'),
            (3, 0x0008, 'lotus_123_prefix'), # Meaning is not known.
            ))
        upkbits(xf.alignment, pkd_align_par, (
            (0, 0x07, 'hor_align'),
            (3, 0x08, 'text_wrapped'),
            ))
        upkbits(xf, pkd_align_par, (
            (4, 0xFFF0, 'parent_style_index'),
            ))
        reg = pkd_used >> 2
        for attr_stem in \
            "format font alignment border background protection".split():
            attr = "_" + attr_stem + "_flag"
            setattr(xf, attr, reg & 1)
            reg >>= 1
        upkbits(xf.background, pkd_bkg_34, (
            ( 0, 0x003F, 'fill_pattern'),
            ( 6, 0x07C0, 'pattern_colour_index'),
            (11, 0xF800, 'background_colour_index'),
            ))
        upkbitsL(xf.border, pkd_brd_34, (
            ( 0, 0x00000007,  'top_line_style'),
            ( 3, 0x000000F8,  'top_colour_index'),
            ( 8, 0x00000700,  'left_line_style'),
            (11, 0x0000F800,  'left_colour_index'),
            (16, 0x00070000,  'bottom_line_style'),
            (19, 0x00F80000,  'bottom_colour_index'),
            (24, 0x07000000,  'right_line_style'),
            (27, 0xF8000000L, 'right_colour_index'),
            ))
        xf.alignment.vert_align = 2 # bottom
        xf.alignment.rotation = 0
    elif bv == 21:
        #### Warning: incomplete treatment; formatting_info not fully supported.
        #### Probably need to offset incoming BIFF2 XF[n] to BIFF8-like XF[n+16],
        #### and create XF[0:16] like the standard ones in BIFF8
        #### *AND* add 16 to all XF references in cell records :-(
        (xf.font_index, format_etc, halign_etc) = unpack('<BxBB', data)
        xf.format_key = format_etc & 0x3F
        upkbits(xf.protection, format_etc, (
            (6, 0x40, 'cell_locked'),
            (7, 0x80, 'formula_hidden'),
            ))
        upkbits(xf.alignment, halign_etc, (
            (0, 0x07, 'hor_align'),
            ))
        for mask, side in ((0x08, 'left'), (0x10, 'right'), (0x20, 'top'), (0x40, 'bottom')):
            if halign_etc & mask:
                colour_index, line_style = 8, 1 # black, thin
            else:
                colour_index, line_style = 0, 0 # none, none
            setattr(xf.border, side + '_colour_index', colour_index)
            setattr(xf.border, side + '_line_style', line_style)
        bg = xf.background
        if halign_etc & 0x80:
            bg.fill_pattern = 17
        else:
            bg.fill_pattern = 0
        bg.background_colour_index = 9 # white
        bg.pattern_colour_index = 8 # black
        xf.parent_style_index = 0 # ???????????
        xf.alignment.vert_align = 2 # bottom
        xf.alignment.rotation = 0
        for attr_stem in \
            "format font alignment border background protection".split():
            attr = "_" + attr_stem + "_flag"
            setattr(xf, attr, 1)
    else:
        raise XLRDError('programmer stuff-up: bv=%d' % bv)

    xf.xf_index = len(self.xf_list)
    self.xf_list.append(xf)
    self.xfcount += 1
    if blah:
        xf.dump(
            self.logfile,
            header="--- handle_xf: xf[%d] ---" % xf.xf_index,
            footer=" ",
        )
    # Now for some assertions ...
    if self.formatting_info:
        if xf.is_style and xf.parent_style_index != 0x0FFF:
            msg = "WARNING *** XF[%d] is a style XF but parent_style_index is 0x%04x, not 0x0fff\n"
            fprintf(self.logfile, msg, xf.xf_index, xf.parent_style_index)
        check_colour_indexes_in_obj(self, xf, xf.xf_index)
    if not self.format_map.has_key(xf.format_key):
        msg = "WARNING *** XF[%d] unknown (raw) format key (%d, 0x%04x)\n"
        fprintf(self.logfile, msg,
                xf.xf_index, xf.format_key, xf.format_key)
        xf.format_key = 0

def xf_epilogue(self):
    # self is a Book instance.
    self._xf_epilogue_done = 1
    num_xfs = len(self.xf_list)
    blah = DEBUG or self.verbosity >= 3
    blah1 = DEBUG or self.verbosity >= 1
    if blah:
        fprintf(self.logfile, "xf_epilogue called ...\n")

    def check_same(book_arg, xf_arg, parent_arg, attr):
        # the _arg caper is to avoid a Warning msg from Python 2.1 :-(
        if getattr(xf_arg, attr) != getattr(parent_arg, attr):
            fprintf(book_arg.logfile,
                "NOTE !!! XF[%d] parent[%d] %s different\n",
                xf_arg.xf_index, parent_arg.xf_index, attr)

    for xfx in xrange(num_xfs):
        xf = self.xf_list[xfx]
        if not self.format_map.has_key(xf.format_key):
            msg = "ERROR *** XF[%d] unknown format key (%d, 0x%04x)\n"
            fprintf(self.logfile, msg,
                    xf.xf_index, xf.format_key, xf.format_key)
            xf.format_key = 0
        cellty_from_fmtty = {
            FNU: XL_CELL_NUMBER,
            FUN: XL_CELL_NUMBER,
            FGE: XL_CELL_NUMBER,
            FDT: XL_CELL_DATE,
            FTX: XL_CELL_NUMBER, # Yes, a number can be formatted as text.
            }
        fmt = self.format_map[xf.format_key]
        cellty = cellty_from_fmtty[fmt.type]
        self._xf_index_to_xl_type_map[xf.xf_index] = cellty
        # Now for some assertions etc
        if not self.formatting_info:
            continue
        if xf.is_style:
            continue
        if not(0 <= xf.parent_style_index < num_xfs):
            fprintf(self.logfile,
                "WARNING *** XF[%d]: is_style=%d but parent_style_index=%d\n",
                xf.xf_index, xf.is_style, xf.parent_style_index)
            # make it conform
            xf.parent_style_index = 0
        if self.biff_version >= 30:
            assert xf.parent_style_index != xf.xf_index
            assert self.xf_list[xf.parent_style_index].is_style
            if blah1 and xf.parent_style_index > xf.xf_index:
                fprintf(self.logfile,
                    "NOTE !!! XF[%d]: parent_style_index is %d; out of order?\n",
                    xf.xf_index, xf.parent_style_index)
            parent = self.xf_list[xf.parent_style_index]
            if not xf._alignment_flag and not parent._alignment_flag:
                if blah1: check_same(self, xf, parent, 'alignment')
            if not xf._background_flag and not parent._background_flag:
                if blah1: check_same(self, xf, parent, 'background')
            if not xf._border_flag and not parent._border_flag:
                if blah1: check_same(self, xf, parent, 'border')
            if not xf._protection_flag and not parent._protection_flag:
                if blah1: check_same(self, xf, parent, 'protection')
            if not xf._format_flag and not parent._format_flag:
                if blah1 and xf.format_key != parent.format_key:
                    fprintf(self.logfile,
                        "NOTE !!! XF[%d] fmtk=%d, parent[%d] fmtk=%r\n%r / %r\n",
                        xf.xf_index, xf.format_key, parent.xf_index, parent.format_key,
                        self.format_map[xf.format_key].format_str,
                        self.format_map[parent.format_key].format_str)
            if not xf._font_flag and not parent._font_flag:
                if blah1 and xf.font_index != parent.font_index:
                    fprintf(self.logfile,
                        "NOTE !!! XF[%d] fontx=%d, parent[%d] fontx=%r\n",
                        xf.xf_index, xf.font_index, parent.xf_index, parent.font_index)

def initialise_book(book):
    initialise_colour_map(book)
    book._xf_epilogue_done = 0
    methods = (
        handle_font,
        handle_efont,
        handle_format,
        is_date_format_string,
        handle_palette,
        palette_epilogue,
        handle_style,
        handle_xf,
        xf_epilogue,
        )
    for method in methods:
        setattr(book.__class__, method.__name__, method)

##
# <p>A collection of the border-related attributes of an XF record.
# Items correspond to those in the Excel UI's Format/Cells/Border tab.</p>
# <p> An explanations of "colour index" is given in the Formatting
# section at the start of this document.
# There are five line style attributes; possible values and the
# associated meanings are:
# 0&nbsp;=&nbsp;No line,
# 1&nbsp;=&nbsp;Thin,
# 2&nbsp;=&nbsp;Medium,
# 3&nbsp;=&nbsp;Dashed,
# 4&nbsp;=&nbsp;Dotted,
# 5&nbsp;=&nbsp;Thick,
# 6&nbsp;=&nbsp;Double,
# 7&nbsp;=&nbsp;Hair,
# 8&nbsp;=&nbsp;Medium dashed,
# 9&nbsp;=&nbsp;Thin dash-dotted,
# 10&nbsp;=&nbsp;Medium dash-dotted,
# 11&nbsp;=&nbsp;Thin dash-dot-dotted,
# 12&nbsp;=&nbsp;Medium dash-dot-dotted,
# 13&nbsp;=&nbsp;Slanted medium dash-dotted.
# The line styles 8 to 13 appear in BIFF8 files (Excel 97 and later) only.
# For pictures of the line styles, refer to OOo docs s3.10 (p22)
# "Line Styles for Cell Borders (BIFF3-BIFF8)".</p>
# <br /> -- New in version 0.6.1
class XFBorder(BaseObject, EqNeAttrs):

    ##
    # The colour index for the cell's top line
    top_colour_index = 0
    ##
    # The colour index for the cell's bottom line
    bottom_colour_index = 0
    ##
    # The colour index for the cell's left line
    left_colour_index = 0
    ##
    # The colour index for the cell's right line
    right_colour_index = 0
    ##
    # The colour index for the cell's diagonal lines, if any
    diag_colour_index = 0
    ##
    # The line style for the cell's top line
    top_line_style = 0
    ##
    # The line style for the cell's bottom line
    bottom_line_style = 0
    ##
    # The line style for the cell's left line
    left_line_style = 0
    ##
    # The line style for the cell's right line
    right_line_style = 0
    ##
    # The line style for the cell's diagonal lines, if any
    diag_line_style = 0
    ##
    # 1 = draw a diagonal from top left to bottom right
    diag_down = 0
    ##
    # 1 = draw a diagonal from bottom left to top right
    diag_up = 0

##
# A collection of the background-related attributes of an XF record.
# Items correspond to those in the Excel UI's Format/Cells/Patterns tab.
# An explanation of "colour index" is given in the Formatting
# section at the start of this document.
# <br /> -- New in version 0.6.1
class XFBackground(BaseObject, EqNeAttrs):

    ##
    # See section 3.11 of the OOo docs.
    fill_pattern = 0
    ##
    # See section 3.11 of the OOo docs.
    background_colour_index = 0
    ##
    # See section 3.11 of the OOo docs.
    pattern_colour_index = 0

##
# A collection of the alignment and similar attributes of an XF record.
# Items correspond to those in the Excel UI's Format/Cells/Alignment tab.
# <br /> -- New in version 0.6.1

class XFAlignment(BaseObject, EqNeAttrs):

    ##
    # Values: section 6.115 (p 214) of OOo docs
    hor_align = 0
    ##
    # Values: section 6.115 (p 215) of OOo docs
    vert_align = 0
    ##
    # Values: section 6.115 (p 215) of OOo docs.<br />
    # Note: file versions BIFF7 and earlier use the documented
    # "orientation" attribute; this will be mapped (without loss)
    # into "rotation".
    rotation = 0
    ##
    # 1 = text is wrapped at right margin
    text_wrapped = 0
    ##
    # A number in range(15).
    indent_level = 0
    ##
    # 1 = shrink font size to fit text into cell.
    shrink_to_fit = 0
    ##
    # 0 = according to context; 1 = left-to-right; 2 = right-to-left
    text_direction = 0

##
# A collection of the protection-related attributes of an XF record.
# Items correspond to those in the Excel UI's Format/Cells/Protection tab.
# Note the OOo docs include the "cell or style" bit
# in this bundle of attributes.
# This is incorrect; the bit is used in determining which bundles to use.
# <br /> -- New in version 0.6.1

class XFProtection(BaseObject, EqNeAttrs):

    ##
    # 1 = Cell is prevented from being changed, moved, resized, or deleted
    # (only if the sheet is protected).
    cell_locked = 0
    ##
    # 1 = Hide formula so that it doesn't appear in the formula bar when
    # the cell is selected (only if the sheet is protected).
    formula_hidden = 0

##
# eXtended Formatting information for cells, rows, columns and styles.
# <br /> -- New in version 0.6.1
#
# <p>Each of the 6 flags below describes the validity of
# a specific group of attributes.
# <br />
# In cell XFs, flag==0 means the attributes of the parent style XF are used,
# (but only if the attributes are valid there); flag==1 means the attributes
# of this XF are used.<br />
# In style XFs, flag==0 means the attribute setting is valid; flag==1 means
# the attribute should be ignored.<br />
# Note that the API
# provides both "raw" XFs and "computed" XFs -- in the latter case, cell XFs
# have had the above inheritance mechanism applied.
# </p>

class XF(BaseObject):

    ##
    # 0 = cell XF, 1 = style XF
    is_style = 0
    ##
    # cell XF: Index into Book.xf_list
    # of this XF's style XF<br />
    # style XF: 0xFFF
    parent_style_index = 0
    ##
    #
    _format_flag = 0
    ##
    #
    _font_flag = 0
    ##
    #
    _alignment_flag = 0
    ##
    #
    _border_flag = 0
    ##
    #
    _background_flag = 0
    ##
    # &nbsp;
    _protection_flag = 0
    ##
    # Index into Book.xf_list
    xf_index = 0
    ##
    # Index into Book.font_list
    font_index = 0
    ##
    # Key into Book.format_map
    # <p>
    # Warning: OOo docs on the XF record call this "Index to FORMAT record".
    # It is not an index in the Python sense. It is a key to a map.
    # It is true <i>only</i> for Excel 4.0 and earlier files
    # that the key into format_map from an XF instance
    # is the same as the index into format_list, and <i>only</i>
    # if the index is less than 164.
    # </p>
    format_key = 0
    ##
    # An instance of an XFProtection object.
    protection = None
    ##
    # An instance of an XFBackground object.
    background = None
    ##
    # An instance of an XFAlignment object.
    alignment = None
    ##
    # An instance of an XFBorder object.
    border = None

########NEW FILE########
__FILENAME__ = formula
# -*- coding: cp1252 -*-

##
# Module for parsing/evaluating Microsoft Excel formulas.
#
# <p>Copyright  2005-2009 Stephen John Machin, Lingfo Pty Ltd</p>
# <p>This module is part of the xlrd package, which is released under
# a BSD-style licence.</p>
##

# No part of the content of this file was derived from the works of David Giffin.

import copy
from struct import unpack
from timemachine import *
from biffh import unpack_unicode_update_pos, unpack_string_update_pos, \
    XLRDError, hex_char_dump, error_text_from_code, BaseObject

__all__ = [
    'oBOOL', 'oERR', 'oNUM', 'oREF', 'oREL', 'oSTRG', 'oUNK',
    'decompile_formula',
    'dump_formula',
    'evaluate_name_formula',
    'okind_dict',
    'rangename3d', 'rangename3drel', 'cellname', 'cellnameabs', 'colname',
    ]

# sztabN[opcode] -> the number of bytes to consume.
# -1 means variable
# -2 means this opcode not implemented in this version.
# Which N to use? Depends on biff_version; see szdict.
sztab0 = [-2, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -2, -1, 8, 4, 2, 2, 3, 9, 8, 2, 3, 8, 4, 7, 5, 5, 5, 2, 4, 7, 4, 7, 2, 2, -2, -2, -2, -2, -2, -2, -2, -2, 3, -2, -2, -2, -2, -2, -2, -2]
sztab1 = [-2, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -2, -1, 11, 5, 2, 2, 3, 9, 9, 2, 3, 11, 4, 7, 7, 7, 7, 3, 4, 7, 4, 7, 3, 3, -2, -2, -2, -2, -2, -2, -2, -2, 3, -2, -2, -2, -2, -2, -2, -2]
sztab2 = [-2, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -2, -1, 11, 5, 2, 2, 3, 9, 9, 3, 4, 11, 4, 7, 7, 7, 7, 3, 4, 7, 4, 7, 3, 3, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2]
sztab3 = [-2, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -2, -1, -2, -2, 2, 2, 3, 9, 9, 3, 4, 15, 4, 7, 7, 7, 7, 3, 4, 7, 4, 7, 3, 3, -2, -2, -2, -2, -2, -2, -2, -2, -2, 25, 18, 21, 18, 21, -2, -2]
sztab4 = [-2, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -2, -2, 2, 2, 3, 9, 9, 3, 4, 5, 5, 9, 7, 7, 7, 3, 5, 9, 5, 9, 3, 3, -2, -2, -2, -2, -2, -2, -2, -2, -2, 7, 7, 11, 7, 11, -2, -2]

szdict = {
    20 : sztab0,
    30 : sztab1,
    40 : sztab2,
    45 : sztab2,
    50 : sztab3,
    70 : sztab3,
    80 : sztab4,
    }

# For debugging purposes ... the name for each opcode
# (without the prefix "t" used on OOo docs)
onames = ['Unk00', 'Exp', 'Tbl', 'Add', 'Sub', 'Mul', 'Div', 'Power', 'Concat', 'LT', 'LE', 'EQ', 'GE', 'GT', 'NE', 'Isect', 'List', 'Range', 'Uplus', 'Uminus', 'Percent', 'Paren', 'MissArg', 'Str', 'Extended', 'Attr', 'Sheet', 'EndSheet', 'Err', 'Bool', 'Int', 'Num', 'Array', 'Func', 'FuncVar', 'Name', 'Ref', 'Area', 'MemArea', 'MemErr', 'MemNoMem', 'MemFunc', 'RefErr', 'AreaErr', 'RefN', 'AreaN', 'MemAreaN', 'MemNoMemN', '', '', '', '', '', '', '', '', 'FuncCE', 'NameX', 'Ref3d', 'Area3d', 'RefErr3d', 'AreaErr3d', '', '']

func_defs = {
    # index: (name, min#args, max#args, flags, #known_args, return_type, kargs)
    0  : ('COUNT',            0, 30, 0x04,  1, 'V', 'R'),
    1  : ('IF',               2,  3, 0x04,  3, 'V', 'VRR'),
    2  : ('ISNA',             1,  1, 0x02,  1, 'V', 'V'),
    3  : ('ISERROR',          1,  1, 0x02,  1, 'V', 'V'),
    4  : ('SUM',              0, 30, 0x04,  1, 'V', 'R'),
    5  : ('AVERAGE',          1, 30, 0x04,  1, 'V', 'R'),
    6  : ('MIN',              1, 30, 0x04,  1, 'V', 'R'),
    7  : ('MAX',              1, 30, 0x04,  1, 'V', 'R'),
    8  : ('ROW',              0,  1, 0x04,  1, 'V', 'R'),
    9  : ('COLUMN',           0,  1, 0x04,  1, 'V', 'R'),
    10 : ('NA',               0,  0, 0x02,  0, 'V', ''),
    11 : ('NPV',              2, 30, 0x04,  2, 'V', 'VR'),
    12 : ('STDEV',            1, 30, 0x04,  1, 'V', 'R'),
    13 : ('DOLLAR',           1,  2, 0x04,  1, 'V', 'V'),
    14 : ('FIXED',            2,  3, 0x04,  3, 'V', 'VVV'),
    15 : ('SIN',              1,  1, 0x02,  1, 'V', 'V'),
    16 : ('COS',              1,  1, 0x02,  1, 'V', 'V'),
    17 : ('TAN',              1,  1, 0x02,  1, 'V', 'V'),
    18 : ('ATAN',             1,  1, 0x02,  1, 'V', 'V'),
    19 : ('PI',               0,  0, 0x02,  0, 'V', ''),
    20 : ('SQRT',             1,  1, 0x02,  1, 'V', 'V'),
    21 : ('EXP',              1,  1, 0x02,  1, 'V', 'V'),
    22 : ('LN',               1,  1, 0x02,  1, 'V', 'V'),
    23 : ('LOG10',            1,  1, 0x02,  1, 'V', 'V'),
    24 : ('ABS',              1,  1, 0x02,  1, 'V', 'V'),
    25 : ('INT',              1,  1, 0x02,  1, 'V', 'V'),
    26 : ('SIGN',             1,  1, 0x02,  1, 'V', 'V'),
    27 : ('ROUND',            2,  2, 0x02,  2, 'V', 'VV'),
    28 : ('LOOKUP',           2,  3, 0x04,  2, 'V', 'VR'),
    29 : ('INDEX',            2,  4, 0x0c,  4, 'R', 'RVVV'),
    30 : ('REPT',             2,  2, 0x02,  2, 'V', 'VV'),
    31 : ('MID',              3,  3, 0x02,  3, 'V', 'VVV'),
    32 : ('LEN',              1,  1, 0x02,  1, 'V', 'V'),
    33 : ('VALUE',            1,  1, 0x02,  1, 'V', 'V'),
    34 : ('TRUE',             0,  0, 0x02,  0, 'V', ''),
    35 : ('FALSE',            0,  0, 0x02,  0, 'V', ''),
    36 : ('AND',              1, 30, 0x04,  1, 'V', 'R'),
    37 : ('OR',               1, 30, 0x04,  1, 'V', 'R'),
    38 : ('NOT',              1,  1, 0x02,  1, 'V', 'V'),
    39 : ('MOD',              2,  2, 0x02,  2, 'V', 'VV'),
    40 : ('DCOUNT',           3,  3, 0x02,  3, 'V', 'RRR'),
    41 : ('DSUM',             3,  3, 0x02,  3, 'V', 'RRR'),
    42 : ('DAVERAGE',         3,  3, 0x02,  3, 'V', 'RRR'),
    43 : ('DMIN',             3,  3, 0x02,  3, 'V', 'RRR'),
    44 : ('DMAX',             3,  3, 0x02,  3, 'V', 'RRR'),
    45 : ('DSTDEV',           3,  3, 0x02,  3, 'V', 'RRR'),
    46 : ('VAR',              1, 30, 0x04,  1, 'V', 'R'),
    47 : ('DVAR',             3,  3, 0x02,  3, 'V', 'RRR'),
    48 : ('TEXT',             2,  2, 0x02,  2, 'V', 'VV'),
    49 : ('LINEST',           1,  4, 0x04,  4, 'A', 'RRVV'),
    50 : ('TREND',            1,  4, 0x04,  4, 'A', 'RRRV'),
    51 : ('LOGEST',           1,  4, 0x04,  4, 'A', 'RRVV'),
    52 : ('GROWTH',           1,  4, 0x04,  4, 'A', 'RRRV'),
    56 : ('PV',               3,  5, 0x04,  5, 'V', 'VVVVV'),
    57 : ('FV',               3,  5, 0x04,  5, 'V', 'VVVVV'),
    58 : ('NPER',             3,  5, 0x04,  5, 'V', 'VVVVV'),
    59 : ('PMT',              3,  5, 0x04,  5, 'V', 'VVVVV'),
    60 : ('RATE',             3,  6, 0x04,  6, 'V', 'VVVVVV'),
    61 : ('MIRR',             3,  3, 0x02,  3, 'V', 'RVV'),
    62 : ('IRR',              1,  2, 0x04,  2, 'V', 'RV'),
    63 : ('RAND',             0,  0, 0x0a,  0, 'V', ''),
    64 : ('MATCH',            2,  3, 0x04,  3, 'V', 'VRR'),
    65 : ('DATE',             3,  3, 0x02,  3, 'V', 'VVV'),
    66 : ('TIME',             3,  3, 0x02,  3, 'V', 'VVV'),
    67 : ('DAY',              1,  1, 0x02,  1, 'V', 'V'),
    68 : ('MONTH',            1,  1, 0x02,  1, 'V', 'V'),
    69 : ('YEAR',             1,  1, 0x02,  1, 'V', 'V'),
    70 : ('WEEKDAY',          1,  2, 0x04,  2, 'V', 'VV'),
    71 : ('HOUR',             1,  1, 0x02,  1, 'V', 'V'),
    72 : ('MINUTE',           1,  1, 0x02,  1, 'V', 'V'),
    73 : ('SECOND',           1,  1, 0x02,  1, 'V', 'V'),
    74 : ('NOW',              0,  0, 0x0a,  0, 'V', ''),
    75 : ('AREAS',            1,  1, 0x02,  1, 'V', 'R'),
    76 : ('ROWS',             1,  1, 0x02,  1, 'V', 'R'),
    77 : ('COLUMNS',          1,  1, 0x02,  1, 'V', 'R'),
    78 : ('OFFSET',           3,  5, 0x04,  5, 'R', 'RVVVV'),
    82 : ('SEARCH',           2,  3, 0x04,  3, 'V', 'VVV'),
    83 : ('TRANSPOSE',        1,  1, 0x02,  1, 'A', 'A'),
    86 : ('TYPE',             1,  1, 0x02,  1, 'V', 'V'),
    92 : ('SERIESSUM',        4,  4, 0x02,  4, 'V', 'VVVA'),
    97 : ('ATAN2',            2,  2, 0x02,  2, 'V', 'VV'),
    98 : ('ASIN',             1,  1, 0x02,  1, 'V', 'V'),
    99 : ('ACOS',             1,  1, 0x02,  1, 'V', 'V'),
    100: ('CHOOSE',           2, 30, 0x04,  2, 'V', 'VR'),
    101: ('HLOOKUP',          3,  4, 0x04,  4, 'V', 'VRRV'),
    102: ('VLOOKUP',          3,  4, 0x04,  4, 'V', 'VRRV'),
    105: ('ISREF',            1,  1, 0x02,  1, 'V', 'R'),
    109: ('LOG',              1,  2, 0x04,  2, 'V', 'VV'),
    111: ('CHAR',             1,  1, 0x02,  1, 'V', 'V'),
    112: ('LOWER',            1,  1, 0x02,  1, 'V', 'V'),
    113: ('UPPER',            1,  1, 0x02,  1, 'V', 'V'),
    114: ('PROPER',           1,  1, 0x02,  1, 'V', 'V'),
    115: ('LEFT',             1,  2, 0x04,  2, 'V', 'VV'),
    116: ('RIGHT',            1,  2, 0x04,  2, 'V', 'VV'),
    117: ('EXACT',            2,  2, 0x02,  2, 'V', 'VV'),
    118: ('TRIM',             1,  1, 0x02,  1, 'V', 'V'),
    119: ('REPLACE',          4,  4, 0x02,  4, 'V', 'VVVV'),
    120: ('SUBSTITUTE',       3,  4, 0x04,  4, 'V', 'VVVV'),
    121: ('CODE',             1,  1, 0x02,  1, 'V', 'V'),
    124: ('FIND',             2,  3, 0x04,  3, 'V', 'VVV'),
    125: ('CELL',             1,  2, 0x0c,  2, 'V', 'VR'),
    126: ('ISERR',            1,  1, 0x02,  1, 'V', 'V'),
    127: ('ISTEXT',           1,  1, 0x02,  1, 'V', 'V'),
    128: ('ISNUMBER',         1,  1, 0x02,  1, 'V', 'V'),
    129: ('ISBLANK',          1,  1, 0x02,  1, 'V', 'V'),
    130: ('T',                1,  1, 0x02,  1, 'V', 'R'),
    131: ('N',                1,  1, 0x02,  1, 'V', 'R'),
    140: ('DATEVALUE',        1,  1, 0x02,  1, 'V', 'V'),
    141: ('TIMEVALUE',        1,  1, 0x02,  1, 'V', 'V'),
    142: ('SLN',              3,  3, 0x02,  3, 'V', 'VVV'),
    143: ('SYD',              4,  4, 0x02,  4, 'V', 'VVVV'),
    144: ('DDB',              4,  5, 0x04,  5, 'V', 'VVVVV'),
    148: ('INDIRECT',         1,  2, 0x0c,  2, 'R', 'VV'),
    162: ('CLEAN',            1,  1, 0x02,  1, 'V', 'V'),
    163: ('MDETERM',          1,  1, 0x02,  1, 'V', 'A'),
    164: ('MINVERSE',         1,  1, 0x02,  1, 'A', 'A'),
    165: ('MMULT',            2,  2, 0x02,  2, 'A', 'AA'),
    167: ('IPMT',             4,  6, 0x04,  6, 'V', 'VVVVVV'),
    168: ('PPMT',             4,  6, 0x04,  6, 'V', 'VVVVVV'),
    169: ('COUNTA',           0, 30, 0x04,  1, 'V', 'R'),
    183: ('PRODUCT',          0, 30, 0x04,  1, 'V', 'R'),
    184: ('FACT',             1,  1, 0x02,  1, 'V', 'V'),
    189: ('DPRODUCT',         3,  3, 0x02,  3, 'V', 'RRR'),
    190: ('ISNONTEXT',        1,  1, 0x02,  1, 'V', 'V'),
    193: ('STDEVP',           1, 30, 0x04,  1, 'V', 'R'),
    194: ('VARP',             1, 30, 0x04,  1, 'V', 'R'),
    195: ('DSTDEVP',          3,  3, 0x02,  3, 'V', 'RRR'),
    196: ('DVARP',            3,  3, 0x02,  3, 'V', 'RRR'),
    197: ('TRUNC',            1,  2, 0x04,  2, 'V', 'VV'),
    198: ('ISLOGICAL',        1,  1, 0x02,  1, 'V', 'V'),
    199: ('DCOUNTA',          3,  3, 0x02,  3, 'V', 'RRR'),
    204: ('USDOLLAR',         1,  2, 0x04,  2, 'V', 'VV'),
    205: ('FINDB',            2,  3, 0x04,  3, 'V', 'VVV'),
    206: ('SEARCHB',          2,  3, 0x04,  3, 'V', 'VVV'),
    207: ('REPLACEB',         4,  4, 0x02,  4, 'V', 'VVVV'),
    208: ('LEFTB',            1,  2, 0x04,  2, 'V', 'VV'),
    209: ('RIGHTB',           1,  2, 0x04,  2, 'V', 'VV'),
    210: ('MIDB',             3,  3, 0x02,  3, 'V', 'VVV'),
    211: ('LENB',             1,  1, 0x02,  1, 'V', 'V'),
    212: ('ROUNDUP',          2,  2, 0x02,  2, 'V', 'VV'),
    213: ('ROUNDDOWN',        2,  2, 0x02,  2, 'V', 'VV'),
    214: ('ASC',              1,  1, 0x02,  1, 'V', 'V'),
    215: ('DBCS',             1,  1, 0x02,  1, 'V', 'V'),
    216: ('RANK',             2,  3, 0x04,  3, 'V', 'VRV'),
    219: ('ADDRESS',          2,  5, 0x04,  5, 'V', 'VVVVV'),
    220: ('DAYS360',          2,  3, 0x04,  3, 'V', 'VVV'),
    221: ('TODAY',            0,  0, 0x0a,  0, 'V', ''),
    222: ('VDB',              5,  7, 0x04,  7, 'V', 'VVVVVVV'),
    227: ('MEDIAN',           1, 30, 0x04,  1, 'V', 'R'),
    228: ('SUMPRODUCT',       1, 30, 0x04,  1, 'V', 'A'),
    229: ('SINH',             1,  1, 0x02,  1, 'V', 'V'),
    230: ('COSH',             1,  1, 0x02,  1, 'V', 'V'),
    231: ('TANH',             1,  1, 0x02,  1, 'V', 'V'),
    232: ('ASINH',            1,  1, 0x02,  1, 'V', 'V'),
    233: ('ACOSH',            1,  1, 0x02,  1, 'V', 'V'),
    234: ('ATANH',            1,  1, 0x02,  1, 'V', 'V'),
    235: ('DGET',             3,  3, 0x02,  3, 'V', 'RRR'),
    244: ('INFO',             1,  1, 0x02,  1, 'V', 'V'),
    247: ('DB',               4,  5, 0x04,  5, 'V', 'VVVVV'),
    252: ('FREQUENCY',        2,  2, 0x02,  2, 'A', 'RR'),
    261: ('ERROR.TYPE',       1,  1, 0x02,  1, 'V', 'V'),
    269: ('AVEDEV',           1, 30, 0x04,  1, 'V', 'R'),
    270: ('BETADIST',         3,  5, 0x04,  1, 'V', 'V'),
    271: ('GAMMALN',          1,  1, 0x02,  1, 'V', 'V'),
    272: ('BETAINV',          3,  5, 0x04,  1, 'V', 'V'),
    273: ('BINOMDIST',        4,  4, 0x02,  4, 'V', 'VVVV'),
    274: ('CHIDIST',          2,  2, 0x02,  2, 'V', 'VV'),
    275: ('CHIINV',           2,  2, 0x02,  2, 'V', 'VV'),
    276: ('COMBIN',           2,  2, 0x02,  2, 'V', 'VV'),
    277: ('CONFIDENCE',       3,  3, 0x02,  3, 'V', 'VVV'),
    278: ('CRITBINOM',        3,  3, 0x02,  3, 'V', 'VVV'),
    279: ('EVEN',             1,  1, 0x02,  1, 'V', 'V'),
    280: ('EXPONDIST',        3,  3, 0x02,  3, 'V', 'VVV'),
    281: ('FDIST',            3,  3, 0x02,  3, 'V', 'VVV'),
    282: ('FINV',             3,  3, 0x02,  3, 'V', 'VVV'),
    283: ('FISHER',           1,  1, 0x02,  1, 'V', 'V'),
    284: ('FISHERINV',        1,  1, 0x02,  1, 'V', 'V'),
    285: ('FLOOR',            2,  2, 0x02,  2, 'V', 'VV'),
    286: ('GAMMADIST',        4,  4, 0x02,  4, 'V', 'VVVV'),
    287: ('GAMMAINV',         3,  3, 0x02,  3, 'V', 'VVV'),
    288: ('CEILING',          2,  2, 0x02,  2, 'V', 'VV'),
    289: ('HYPGEOMDIST',      4,  4, 0x02,  4, 'V', 'VVVV'),
    290: ('LOGNORMDIST',      3,  3, 0x02,  3, 'V', 'VVV'),
    291: ('LOGINV',           3,  3, 0x02,  3, 'V', 'VVV'),
    292: ('NEGBINOMDIST',     3,  3, 0x02,  3, 'V', 'VVV'),
    293: ('NORMDIST',         4,  4, 0x02,  4, 'V', 'VVVV'),
    294: ('NORMSDIST',        1,  1, 0x02,  1, 'V', 'V'),
    295: ('NORMINV',          3,  3, 0x02,  3, 'V', 'VVV'),
    296: ('NORMSINV',         1,  1, 0x02,  1, 'V', 'V'),
    297: ('STANDARDIZE',      3,  3, 0x02,  3, 'V', 'VVV'),
    298: ('ODD',              1,  1, 0x02,  1, 'V', 'V'),
    299: ('PERMUT',           2,  2, 0x02,  2, 'V', 'VV'),
    300: ('POISSON',          3,  3, 0x02,  3, 'V', 'VVV'),
    301: ('TDIST',            3,  3, 0x02,  3, 'V', 'VVV'),
    302: ('WEIBULL',          4,  4, 0x02,  4, 'V', 'VVVV'),
    303: ('SUMXMY2',          2,  2, 0x02,  2, 'V', 'AA'),
    304: ('SUMX2MY2',         2,  2, 0x02,  2, 'V', 'AA'),
    305: ('SUMX2PY2',         2,  2, 0x02,  2, 'V', 'AA'),
    306: ('CHITEST',          2,  2, 0x02,  2, 'V', 'AA'),
    307: ('CORREL',           2,  2, 0x02,  2, 'V', 'AA'),
    308: ('COVAR',            2,  2, 0x02,  2, 'V', 'AA'),
    309: ('FORECAST',         3,  3, 0x02,  3, 'V', 'VAA'),
    310: ('FTEST',            2,  2, 0x02,  2, 'V', 'AA'),
    311: ('INTERCEPT',        2,  2, 0x02,  2, 'V', 'AA'),
    312: ('PEARSON',          2,  2, 0x02,  2, 'V', 'AA'),
    313: ('RSQ',              2,  2, 0x02,  2, 'V', 'AA'),
    314: ('STEYX',            2,  2, 0x02,  2, 'V', 'AA'),
    315: ('SLOPE',            2,  2, 0x02,  2, 'V', 'AA'),
    316: ('TTEST',            4,  4, 0x02,  4, 'V', 'AAVV'),
    317: ('PROB',             3,  4, 0x04,  3, 'V', 'AAV'),
    318: ('DEVSQ',            1, 30, 0x04,  1, 'V', 'R'),
    319: ('GEOMEAN',          1, 30, 0x04,  1, 'V', 'R'),
    320: ('HARMEAN',          1, 30, 0x04,  1, 'V', 'R'),
    321: ('SUMSQ',            0, 30, 0x04,  1, 'V', 'R'),
    322: ('KURT',             1, 30, 0x04,  1, 'V', 'R'),
    323: ('SKEW',             1, 30, 0x04,  1, 'V', 'R'),
    324: ('ZTEST',            2,  3, 0x04,  2, 'V', 'RV'),
    325: ('LARGE',            2,  2, 0x02,  2, 'V', 'RV'),
    326: ('SMALL',            2,  2, 0x02,  2, 'V', 'RV'),
    327: ('QUARTILE',         2,  2, 0x02,  2, 'V', 'RV'),
    328: ('PERCENTILE',       2,  2, 0x02,  2, 'V', 'RV'),
    329: ('PERCENTRANK',      2,  3, 0x04,  2, 'V', 'RV'),
    330: ('MODE',             1, 30, 0x04,  1, 'V', 'A'),
    331: ('TRIMMEAN',         2,  2, 0x02,  2, 'V', 'RV'),
    332: ('TINV',             2,  2, 0x02,  2, 'V', 'VV'),
    336: ('CONCATENATE',      0, 30, 0x04,  1, 'V', 'V'),
    337: ('POWER',            2,  2, 0x02,  2, 'V', 'VV'),
    342: ('RADIANS',          1,  1, 0x02,  1, 'V', 'V'),
    343: ('DEGREES',          1,  1, 0x02,  1, 'V', 'V'),
    344: ('SUBTOTAL',         2, 30, 0x04,  2, 'V', 'VR'),
    345: ('SUMIF',            2,  3, 0x04,  3, 'V', 'RVR'),
    346: ('COUNTIF',          2,  2, 0x02,  2, 'V', 'RV'),
    347: ('COUNTBLANK',       1,  1, 0x02,  1, 'V', 'R'),
    350: ('ISPMT',            4,  4, 0x02,  4, 'V', 'VVVV'),
    351: ('DATEDIF',          3,  3, 0x02,  3, 'V', 'VVV'),
    352: ('DATESTRING',       1,  1, 0x02,  1, 'V', 'V'),
    353: ('NUMBERSTRING',     2,  2, 0x02,  2, 'V', 'VV'),
    354: ('ROMAN',            1,  2, 0x04,  2, 'V', 'VV'),
    358: ('GETPIVOTDATA',     2,  2, 0x02,  2, 'V', 'RV'),
    359: ('HYPERLINK',        1,  2, 0x04,  2, 'V', 'VV'),
    360: ('PHONETIC',         1,  1, 0x02,  1, 'V', 'V'),
    361: ('AVERAGEA',         1, 30, 0x04,  1, 'V', 'R'),
    362: ('MAXA',             1, 30, 0x04,  1, 'V', 'R'),
    363: ('MINA',             1, 30, 0x04,  1, 'V', 'R'),
    364: ('STDEVPA',          1, 30, 0x04,  1, 'V', 'R'),
    365: ('VARPA',            1, 30, 0x04,  1, 'V', 'R'),
    366: ('STDEVA',           1, 30, 0x04,  1, 'V', 'R'),
    367: ('VARA',             1, 30, 0x04,  1, 'V', 'R'),
    368: ('BAHTTEXT',         1,  1, 0x02,  1, 'V', 'V'),
    369: ('THAIDAYOFWEEK',    1,  1, 0x02,  1, 'V', 'V'),
    370: ('THAIDIGIT',        1,  1, 0x02,  1, 'V', 'V'),
    371: ('THAIMONTHOFYEAR',  1,  1, 0x02,  1, 'V', 'V'),
    372: ('THAINUMSOUND',     1,  1, 0x02,  1, 'V', 'V'),
    373: ('THAINUMSTRING',    1,  1, 0x02,  1, 'V', 'V'),
    374: ('THAISTRINGLENGTH', 1,  1, 0x02,  1, 'V', 'V'),
    375: ('ISTHAIDIGIT',      1,  1, 0x02,  1, 'V', 'V'),
    376: ('ROUNDBAHTDOWN',    1,  1, 0x02,  1, 'V', 'V'),
    377: ('ROUNDBAHTUP',      1,  1, 0x02,  1, 'V', 'V'),
    378: ('THAIYEAR',         1,  1, 0x02,  1, 'V', 'V'),
    379: ('RTD',              2,  5, 0x04,  1, 'V', 'V'),
    }

tAttrNames = {
    0x00: "Skip??", # seen in SAMPLES.XLS which shipped with Excel 5.0
    0x01: "Volatile",
    0x02: "If",
    0x04: "Choose",
    0x08: "Skip",
    0x10: "Sum",
    0x20: "Assign",
    0x40: "Space",
    0x41: "SpaceVolatile",
    }

_error_opcodes = {}
for _x in [0x07, 0x08, 0x0A, 0x0B, 0x1C, 0x1D, 0x2F]:
    _error_opcodes[_x] = 1
is_error_opcode = _error_opcodes.has_key

tRangeFuncs = (min, max, min, max, min, max)
tIsectFuncs = (max, min, max, min, max, min)

def do_box_funcs(box_funcs, boxa, boxb):
    return tuple([
        func(numa, numb)
        for func, numa, numb in zip(box_funcs, boxa.coords, boxb.coords)
        ])

def adjust_cell_addr_biff8(rowval, colval, reldelta, browx=None, bcolx=None):
    row_rel = (colval >> 15) & 1
    col_rel = (colval >> 14) & 1
    rowx = rowval
    colx = colval & 0xff
    if reldelta:
        if row_rel and rowx >= 32768:
            rowx -= 65536
        if col_rel and colx >= 128:
            colx -= 256
    else:
        if row_rel:
            rowx -= browx
        if col_rel:
            colx -= bcolx
    return rowx, colx, row_rel, col_rel

def adjust_cell_addr_biff_le7(
        rowval, colval, reldelta, browx=None, bcolx=None):
    row_rel = (rowval >> 15) & 1
    col_rel = (rowval >> 14) & 1
    rowx = rowval & 0x3fff
    colx = colval
    if reldelta:
        if row_rel and rowx >= 8192:
            rowx -= 16384
        if col_rel and colx >= 128:
            colx -= 256
    else:
        if row_rel:
            rowx -= browx
        if col_rel:
            colx -= bcolx
    return rowx, colx, row_rel, col_rel

def get_cell_addr(data, pos, bv, reldelta, browx=None, bcolx=None):
    if bv >= 80:
        rowval, colval = unpack("<HH", data[pos:pos+4])
        # print "    rv=%04xh cv=%04xh" % (rowval, colval)
        return adjust_cell_addr_biff8(rowval, colval, reldelta, browx, bcolx)
    else:
        rowval, colval = unpack("<HB", data[pos:pos+3])
        # print "    rv=%04xh cv=%04xh" % (rowval, colval)
        return adjust_cell_addr_biff_le7(
                    rowval, colval, reldelta, browx, bcolx)

def get_cell_range_addr(data, pos, bv, reldelta, browx=None, bcolx=None):
    if bv >= 80:
        row1val, row2val, col1val, col2val = unpack("<HHHH", data[pos:pos+8])
        # print "    rv=%04xh cv=%04xh" % (row1val, col1val)
        # print "    rv=%04xh cv=%04xh" % (row2val, col2val)
        res1 = adjust_cell_addr_biff8(row1val, col1val, reldelta, browx, bcolx)
        res2 = adjust_cell_addr_biff8(row2val, col2val, reldelta, browx, bcolx)
        return res1, res2
    else:
        row1val, row2val, col1val, col2val = unpack("<HHBB", data[pos:pos+6])
        # print "    rv=%04xh cv=%04xh" % (row1val, col1val)
        # print "    rv=%04xh cv=%04xh" % (row2val, col2val)
        res1 = adjust_cell_addr_biff_le7(
                    row1val, col1val, reldelta, browx, bcolx)
        res2 = adjust_cell_addr_biff_le7(
                    row2val, col2val, reldelta, browx, bcolx)
        return res1, res2

def get_externsheet_local_range(bk, refx, blah=0):
    try:
        info = bk._externsheet_info[refx]
    except IndexError:
        print "!!! get_externsheet_local_range: refx=%d, not in range(%d)" \
            % (refx, len(bk._externsheet_info))
        return (-101, -101)
    ref_recordx, ref_first_sheetx, ref_last_sheetx = info
    if ref_recordx == bk._supbook_addins_inx:
        if blah:
            print "/// get_externsheet_local_range(refx=%d) -> addins %r" % (refx, info)
        assert ref_first_sheetx == 0xFFFE == ref_last_sheetx
        return (-5, -5)
    if ref_recordx != bk._supbook_locals_inx:
        if blah:
            print "/// get_externsheet_local_range(refx=%d) -> external %r" % (refx, info)
        return (-4, -4) # external reference
    if ref_first_sheetx == 0xFFFE == ref_last_sheetx:
        if blah:
            print "/// get_externsheet_local_range(refx=%d) -> unspecified sheet %r" % (refx, info)
        return (-1, -1) # internal reference, any sheet
    if ref_first_sheetx == 0xFFFF == ref_last_sheetx:
        if blah:
            print "/// get_externsheet_local_range(refx=%d) -> deleted sheet(s)" % (refx, )
        return (-2, -2) # internal reference, deleted sheet(s)
    nsheets = len(bk._all_sheets_map)
    if not(0 <= ref_first_sheetx <= ref_last_sheetx < nsheets):
        if blah:
            print "/// get_externsheet_local_range(refx=%d) -> %r" % (refx, info)
            print "--- first/last sheet not in range(%d)" % nsheets
        return (-102, -102) # stuffed up somewhere :-(
    xlrd_sheetx1 = bk._all_sheets_map[ref_first_sheetx]
    xlrd_sheetx2 = bk._all_sheets_map[ref_last_sheetx]
    if not(0 <= xlrd_sheetx1 <= xlrd_sheetx2):
        return (-3, -3) # internal reference, but to a macro sheet
    return xlrd_sheetx1, xlrd_sheetx2

def get_externsheet_local_range_b57(
        bk, raw_extshtx, ref_first_sheetx, ref_last_sheetx, blah=0):
    if raw_extshtx > 0:
        if blah:
            print "/// get_externsheet_local_range_b57(raw_extshtx=%d) -> external" % raw_extshtx
        return (-4, -4) # external reference
    if ref_first_sheetx == -1 and ref_last_sheetx == -1:
        return (-2, -2) # internal reference, deleted sheet(s)
    nsheets = len(bk._all_sheets_map)
    if not(0 <= ref_first_sheetx <= ref_last_sheetx < nsheets):
        if blah:
            print "/// get_externsheet_local_range_b57(%d, %d, %d) -> ???" \
                % (raw_extshtx, ref_first_sheetx, ref_last_sheetx)
            print "--- first/last sheet not in range(%d)" % nsheets
        return (-103, -103) # stuffed up somewhere :-(
    xlrd_sheetx1 = bk._all_sheets_map[ref_first_sheetx]
    xlrd_sheetx2 = bk._all_sheets_map[ref_last_sheetx]
    if not(0 <= xlrd_sheetx1 <= xlrd_sheetx2):
        return (-3, -3) # internal reference, but to a macro sheet
    return xlrd_sheetx1, xlrd_sheetx2

class FormulaError(Exception):
    pass

oBOOL = 3
oERR =  4
oMSNG = 5 # tMissArg
oNUM =  2
oREF = -1
oREL = -2
oSTRG = 1
oUNK =  0

okind_dict = {
    -2: "oREL",
    -1: "oREF",
    0 : "oUNK",
    1 : "oSTRG",
    2 : "oNUM",
    3 : "oBOOL",
    4 : "oERR",
    5 : "oMSNG",
    }

listsep = ',' #### probably should depend on locale

##
# Used in evaluating formulas.
# The following table describes the kinds and how their values
# are represented.</p>
#
# <table border="1" cellpadding="7">
# <tr>
# <th>Kind symbol</th>
# <th>Kind number</th>
# <th>Value representation</th>
# </tr>
# <tr>
# <td>oBOOL</td>
# <td align="center">3</td>
# <td>integer: 0 => False; 1 => True</td>
# </tr>
# <tr>
# <td>oERR</td>
# <td align="center">4</td>
# <td>None, or an int error code (same as XL_CELL_ERROR in the Cell class).
# </td>
# </tr>
# <tr>
# <td>oMSNG</td>
# <td align="center">5</td>
# <td>Used by Excel as a placeholder for a missing (not supplied) function
# argument. Should *not* appear as a final formula result. Value is None.</td>
# </tr>
# <tr>
# <td>oNUM</td>
# <td align="center">2</td>
# <td>A float. Note that there is no way of distinguishing dates.</td>
# </tr>
# <tr>
# <td>oREF</td>
# <td align="center">-1</td>
# <td>The value is either None or a non-empty list of
# absolute Ref3D instances.<br>
# </td>
# </tr>
# <tr>
# <td>oREL</td>
# <td align="center">-2</td>
# <td>The value is None or a non-empty list of
# fully or partially relative Ref3D instances.
# </td>
# </tr>
# <tr>
# <td>oSTRG</td>
# <td align="center">1</td>
# <td>A Unicode string.</td>
# </tr>
# <tr>
# <td>oUNK</td>
# <td align="center">0</td>
# <td>The kind is unknown or ambiguous. The value is None</td>
# </tr>
# </table>
#<p></p>

class Operand(object):

    ##
    # None means that the actual value of the operand is a variable
    # (depends on cell data), not a constant.
    value = None
    ##
    # oUNK means that the kind of operand is not known unambiguously.
    kind = oUNK
    ##
    # The reconstituted text of the original formula. Function names will be
    # in English irrespective of the original language, which doesn't seem
    # to be recorded anywhere. The separator is ",", not ";" or whatever else
    # might be more appropriate for the end-user's locale; patches welcome.
    text = '?'

    def __init__(self, akind=None, avalue=None, arank=0, atext='?'):
        if akind is not None:
            self.kind = akind
        if avalue is not None:
            self.value = avalue
        self.rank = arank
        # rank is an internal gizmo (operator precedence);
        # it's used in reconstructing formula text.
        self.text = atext

    def __repr__(self):
        kind_text = okind_dict.get(self.kind, "?Unknown kind?")
        return "Operand(kind=%s, value=%r, text=%r)" \
            % (kind_text, self.value, self.text)

if CAN_SUBCLASS_BUILTIN:
    _ref3d_base = tuple
else:
    _ref3d_base = object

##
# <p>Represents an absolute or relative 3-dimensional reference to a box
# of one or more cells.<br />
# -- New in version 0.6.0
# </p>
#
# <p>The <i>coords</i> attribute is a tuple of the form:<br />
# (shtxlo, shtxhi, rowxlo, rowxhi, colxlo, colxhi)<br />
# where 0 <= thingxlo <= thingx < thingxhi.<br />
# Note that it is quite possible to have thingx > nthings; for example
# Print_Titles could have colxhi == 256 and/or rowxhi == 65536
# irrespective of how many columns/rows are actually used in the worksheet.
# The caller will need to decide how to handle this situation.
# Keyword: IndexError :-)
# </p>
#
# <p>The components of the coords attribute are also available as individual
# attributes: shtxlo, shtxhi, rowxlo, rowxhi, colxlo, and colxhi.</p>
#
# <p>The <i>relflags</i> attribute is a 6-tuple of flags which indicate whether
# the corresponding (sheet|row|col)(lo|hi) is relative (1) or absolute (0).<br>
# Note that there is necessarily no information available as to what cell(s)
# the reference could possibly be relative to. The caller must decide what if
# any use to make of oREL operands. Note also that a partially relative
# reference may well be a typo.
# For example, define name A1Z10 as $a$1:$z10 (missing $ after z)
# while the cursor is on cell Sheet3!A27.<br>
# The resulting Ref3D instance will have coords = (2, 3, 0, -16, 0, 26)
# and relflags = (0, 0, 0, 1, 0, 0).<br>
# So far, only one possibility of a sheet-relative component in
# a reference has been noticed: a 2D reference located in the "current sheet".
# <br /> This will appear as coords = (0, 1, ...) and relflags = (1, 1, ...).

class Ref3D(_ref3d_base):

    def __init__(self, atuple):
        self.coords = atuple[0:6]
        self.relflags = atuple[6:12]
        if not self.relflags:
            self.relflags = (0, 0, 0, 0, 0, 0)
        (self.shtxlo, self.shtxhi,
        self.rowxlo, self.rowxhi,
        self.colxlo, self.colxhi) = self.coords

    def __repr__(self):
        if not self.relflags or self.relflags == (0, 0, 0, 0, 0, 0):
            return "Ref3D(coords=%r)" % (self.coords, )
        else:
            return "Ref3D(coords=%r, relflags=%r)" \
                % (self.coords, self.relflags)

tAdd = 0x03
tSub = 0x04
tMul = 0x05
tDiv = 0x06
tPower = 0x07
tConcat = 0x08
tLT, tLE, tEQ, tGE, tGT, tNE = range(0x09, 0x0F)

import operator as opr

def nop(x):
    return x

def _opr_pow(x, y): return x ** y

def _opr_lt(x, y): return x <  y
def _opr_le(x, y): return x <= y
def _opr_eq(x, y): return x == y
def _opr_ge(x, y): return x >= y
def _opr_gt(x, y): return x >  y
def _opr_ne(x, y): return x != y

def num2strg(num):
    """Attempt to emulate Excel's default conversion
       from number to string.
    """
    s = str(num)
    if s.endswith(".0"):
        s = s[:-2]
    return s

_arith_argdict = {oNUM: nop,     oSTRG: float}
_cmp_argdict =   {oNUM: nop,     oSTRG: nop}
# Seems no conversions done on relops; in Excel, "1" > 9 produces TRUE.
_strg_argdict =  {oNUM:num2strg, oSTRG:nop}
binop_rules = {
    tAdd:   (_arith_argdict, oNUM, opr.add,  30, '+'),
    tSub:   (_arith_argdict, oNUM, opr.sub,  30, '-'),
    tMul:   (_arith_argdict, oNUM, opr.mul,  40, '*'),
    tDiv:   (_arith_argdict, oNUM, opr.div,  40, '/'),
    tPower: (_arith_argdict, oNUM, _opr_pow, 50, '^',),
    tConcat:(_strg_argdict, oSTRG, opr.add,  20, '&'),
    tLT:    (_cmp_argdict, oBOOL, _opr_lt,   10, '<'),
    tLE:    (_cmp_argdict, oBOOL, _opr_le,   10, '<='),
    tEQ:    (_cmp_argdict, oBOOL, _opr_eq,   10, '='),
    tGE:    (_cmp_argdict, oBOOL, _opr_ge,   10, '>='),
    tGT:    (_cmp_argdict, oBOOL, _opr_gt,   10, '>'),
    tNE:    (_cmp_argdict, oBOOL, _opr_ne,   10, '<>'),
    }

unop_rules = {
    0x13: (lambda x: -x,        70, '-', ''), # unary minus
    0x12: (lambda x: x,         70, '+', ''), # unary plus
    0x14: (lambda x: x / 100.0, 60, '',  '%'),# percent
    }

LEAF_RANK = 90
FUNC_RANK = 90

STACK_ALARM_LEVEL = 5
STACK_PANIC_LEVEL = 10

def evaluate_name_formula(bk, nobj, namex, blah=0, level=0):
    if level > STACK_ALARM_LEVEL:
        blah = 1
    data = nobj.raw_formula
    fmlalen = nobj.basic_formula_len
    bv = bk.biff_version
    reldelta = 1 # All defined name formulas use "Method B" [OOo docs]
    if blah:
        print "::: evaluate_name_formula %r %r %d %d %r level=%d" \
            % (namex, nobj.name, fmlalen, bv, data, level)
        hex_char_dump(data, 0, fmlalen)
    if level > STACK_PANIC_LEVEL:
        raise XLRDError("Excessive indirect references in NAME formula")
    sztab = szdict[bv]
    pos = 0
    stack = []
    any_rel = 0
    any_err = 0
    any_external = 0
    unk_opnd = Operand(oUNK, None)
    error_opnd = Operand(oERR, None)
    spush = stack.append

    def do_binop(opcd, stk):
        assert len(stk) >= 2
        bop = stk.pop()
        aop = stk.pop()
        argdict, result_kind, func, rank, sym = binop_rules[opcd]
        otext = ''.join([
            '('[:aop.rank < rank],
            aop.text,
            ')'[:aop.rank < rank],
            sym,
            '('[:bop.rank < rank],
            bop.text,
            ')'[:bop.rank < rank],
            ])
        resop = Operand(result_kind, None, rank, otext)
        try:
            bconv = argdict[bop.kind]
            aconv = argdict[aop.kind]
        except KeyError:
            stk.append(resop)
            return
        if bop.value is None or aop.value is None:
            stk.append(resop)
            return
        bval = bconv(bop.value)
        aval = aconv(aop.value)
        result = func(aval, bval)
        if result_kind == oBOOL:
            result = intbool(result) # -> 1 or 0
        resop.value = result
        stk.append(resop)

    def do_unaryop(opcode, arglist, result_kind, stk):
        assert len(stk) >= 1
        aop = stk.pop()
        assert aop.kind in arglist
        val = aop.value
        func, rank, sym1, sym2 = unop_rules[opcode]
        otext = ''.join([
            sym1,
            '('[:aop.rank < rank],
            aop.text,
            ')'[:aop.rank < rank],
            sym2,
            ])
        if val is not None:
            val = func(val)
        stk.append(Operand(result_kind, val, rank, otext))

    def not_in_name_formula(op_arg, oname_arg):
        msg = "ERROR *** Token 0x%02x (%s) found in NAME formula" \
              % (op_arg, oname_arg)
        raise FormulaError(msg)

    if fmlalen == 0:
        stack = [unk_opnd]

    while 0 <= pos < fmlalen:
        op = ord(data[pos])
        opcode = op & 0x1f
        optype = (op & 0x60) >> 5
        if optype:
            opx = opcode + 32
        else:
            opx = opcode
        oname = onames[opx] # + [" RVA"][optype]
        sz = sztab[opx]
        if blah:
            print "Pos:%d Op:0x%02x Name:t%s Sz:%d opcode:%02xh optype:%02xh" \
                % (pos, op, oname, sz, opcode, optype)
            print "Stack =", stack
        if sz == -2:
            msg = 'ERROR *** Unexpected token 0x%02x ("%s"); biff_version=%d' \
                % (op, oname, bv)
            raise FormulaError(msg)
        if not optype:
            if 0x00 <= opcode <= 0x02: # unk_opnd, tExp, tTbl
                not_in_name_formula(op, oname)
            elif 0x03 <= opcode <= 0x0E:
                # Add, Sub, Mul, Div, Power
                # tConcat
                # tLT, ..., tNE
                do_binop(opcode, stack)
            elif opcode == 0x0F: # tIsect
                if blah: print >> bk.logfile, "tIsect pre", stack
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                sym = ' '
                rank = 80 ########## check #######
                otext = ''.join([
                    '('[:aop.rank < rank],
                    aop.text,
                    ')'[:aop.rank < rank],
                    sym,
                    '('[:bop.rank < rank],
                    bop.text,
                    ')'[:bop.rank < rank],
                    ])
                res = Operand(oREF)
                res.text = otext
                if bop.kind == oERR or aop.kind == oERR:
                    res.kind = oERR
                elif bop.kind == oUNK or aop.kind == oUNK:
                    # This can happen with undefined
                    # (go search in the current sheet) labels.
                    # For example =Bob Sales
                    # Each label gets a NAME record with an empty formula (!)
                    # Evaluation of the tName token classifies it as oUNK
                    # res.kind = oREF
                    pass
                elif bop.kind == oREF == aop.kind:
                    if aop.value is not None and bop.value is not None:
                        assert len(aop.value) == 1
                        assert len(bop.value) == 1
                        coords = do_box_funcs(
                            tIsectFuncs, aop.value[0], bop.value[0])
                        res.value = [Ref3D(coords)]
                elif bop.kind == oREL == aop.kind:
                    res.kind = oREL
                    if aop.value is not None and bop.value is not None:
                        assert len(aop.value) == 1
                        assert len(bop.value) == 1
                        coords = do_box_funcs(
                            tIsectFuncs, aop.value[0], bop.value[0])
                        relfa = aop.value[0].relflags
                        relfb = bop.value[0].relflags
                        if relfa == relfb:
                            res.value = [Ref3D(coords + relfa)]
                else:
                    pass
                spush(res)
                if blah: print >> bk.logfile, "tIsect post", stack
            elif opcode == 0x10: # tList
                if blah: print >> bk.logfile, "tList pre", stack
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                sym = ','
                rank = 80 ########## check #######
                otext = ''.join([
                    '('[:aop.rank < rank],
                    aop.text,
                    ')'[:aop.rank < rank],
                    sym,
                    '('[:bop.rank < rank],
                    bop.text,
                    ')'[:bop.rank < rank],
                    ])
                res = Operand(oREF, None, rank, otext)
                if bop.kind == oERR or aop.kind == oERR:
                    res.kind = oERR
                elif bop.kind in (oREF, oREL) and aop.kind in (oREF, oREL):
                    res.kind = oREF
                    if aop.kind == oREL or bop.kind == oREL:
                        res.kind = oREL
                    if aop.value is not None and bop.value is not None:
                        assert len(aop.value) >= 1
                        assert len(bop.value) == 1
                        res.value = aop.value + bop.value
                else:
                    pass
                spush(res)
                if blah: print >> bk.logfile, "tList post", stack
            elif opcode == 0x11: # tRange
                if blah: print >> bk.logfile, "tRange pre", stack
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                sym = ':'
                rank = 80 ########## check #######
                otext = ''.join([
                    '('[:aop.rank < rank],
                    aop.text,
                    ')'[:aop.rank < rank],
                    sym,
                    '('[:bop.rank < rank],
                    bop.text,
                    ')'[:bop.rank < rank],
                    ])
                res = Operand(oREF, None, rank, otext)
                if bop.kind == oERR or aop.kind == oERR:
                    res = oERR
                elif bop.kind == oREF == aop.kind:
                    if aop.value is not None and bop.value is not None:
                        assert len(aop.value) == 1
                        assert len(bop.value) == 1
                        coords = do_box_funcs(
                            tRangeFuncs, aop.value[0], bop.value[0])
                        res.value = [Ref3D(coords)]
                elif bop.kind == oREL == aop.kind:
                    res.kind = oREL
                    if aop.value is not None and bop.value is not None:
                        assert len(aop.value) == 1
                        assert len(bop.value) == 1
                        coords = do_box_funcs(
                            tRangeFuncs, aop.value[0], bop.value[0])
                        relfa = aop.value[0].relflags
                        relfb = bop.value[0].relflags
                        if relfa == relfb:
                            res.value = [Ref3D(coords + relfa)]
                else:
                    pass
                spush(res)
                if blah: print >> bk.logfile, "tRange post", stack
            elif 0x12 <= opcode <= 0x14: # tUplus, tUminus, tPercent
                do_unaryop(opcode, (oUNK, oNUM,), oNUM, stack)
            elif opcode == 0x15: # tParen
                # source cosmetics
                pass
            elif opcode == 0x16: # tMissArg
                spush(Operand(oMSNG, None, LEAF_RANK, ''))
            elif opcode == 0x17: # tStr
                if bv <= 70:
                    strg, newpos = unpack_string_update_pos(
                                        data, pos+1, bk.encoding, lenlen=1)
                else:
                    strg, newpos = unpack_unicode_update_pos(
                                        data, pos+1, lenlen=1)
                sz = newpos - pos
                if blah: print >> bk.logfile, "   sz=%d strg=%r" % (sz, strg)
                text = '"' + strg.replace('"', '""') + '"'
                spush(Operand(oSTRG, strg, LEAF_RANK, text))
            elif opcode == 0x18: # tExtended
                # new with BIFF 8
                assert bv >= 80
                # not in OOo docs
                raise FormulaError("tExtended token not implemented")
            elif opcode == 0x19: # tAttr
                subop, nc = unpack("<BH", data[pos+1:pos+4])
                subname = tAttrNames.get(subop, "??Unknown??")
                if subop == 0x04: # Choose
                    sz = nc * 2 + 6
                elif subop == 0x10: # Sum (single arg)
                    sz = 4
                    if blah: print >> bk.logfile, "tAttrSum", stack
                    assert len(stack) >= 1
                    aop = stack[-1]
                    otext = 'SUM(%s)' % aop.text
                    stack[-1] = Operand(oNUM, None, FUNC_RANK, otext)
                else:
                    sz = 4
                if blah:
                    print "   subop=%02xh subname=t%s sz=%d nc=%02xh" \
                        % (subop, subname, sz, nc)
            elif 0x1A <= opcode <= 0x1B: # tSheet, tEndSheet
                assert bv < 50
                raise FormulaError("tSheet & tEndsheet tokens not implemented")
            elif 0x1C <= opcode <= 0x1F: # tErr, tBool, tInt, tNum
                inx = opcode - 0x1C
                nb = [1, 1, 2, 8][inx]
                kind = [oERR, oBOOL, oNUM, oNUM][inx]
                value, = unpack("<" + "BBHd"[inx], data[pos+1:pos+1+nb])
                if inx == 2: # tInt
                    value = float(value)
                    text = str(value)
                elif inx == 3: # tNum
                    text = str(value)
                elif inx == 1: # tBool
                    text = ('FALSE', 'TRUE')[value]
                else:
                    text = '"' +error_text_from_code[value] + '"'
                spush(Operand(kind, value, LEAF_RANK, text))
            else:
                raise FormulaError("Unhandled opcode: 0x%02x" % opcode)
            if sz <= 0:
                raise FormulaError("Size not set for opcode 0x%02x" % opcode)
            pos += sz
            continue
        if opcode == 0x00: # tArray
            spush(unk_opnd)
        elif opcode == 0x01: # tFunc
            nb = 1 + int(bv >= 40)
            funcx = unpack("<" + " BH"[nb], data[pos+1:pos+1+nb])[0]
            func_attrs = func_defs.get(funcx, None)
            if not func_attrs:
                print >> bk.logfile, "*** formula/tFunc unknown FuncID:%d" \
                      % funcx
                spush(unk_opnd)
            else:
                func_name, nargs = func_attrs[:2]
                if blah:
                    print "    FuncID=%d name=%s nargs=%d" \
                          % (funcx, func_name, nargs)
                assert len(stack) >= nargs
                argtext = listsep.join([arg.text for arg in stack[-nargs:]])
                otext = "%s(%s)" % (func_name, argtext)
                del stack[-nargs:]
                res = Operand(oUNK, None, FUNC_RANK, otext)
                spush(res)
        elif opcode == 0x02: #tFuncVar
            nb = 1 + int(bv >= 40)
            nargs, funcx = unpack("<B" + " BH"[nb], data[pos+1:pos+2+nb])
            prompt, nargs = divmod(nargs, 128)
            macro, funcx = divmod(funcx, 32768)
            if blah:
                print "   FuncID=%d nargs=%d macro=%d prompt=%d" \
                      % (funcx, nargs, macro, prompt)
            func_attrs = func_defs.get(funcx, None)
            if not func_attrs:
                print >> bk.logfile, "*** formula/tFuncVar unknown FuncID:%d" \
                      % funcx
                spush(unk_opnd)
            else:
                func_name, minargs, maxargs = func_attrs[:3]
                if blah:
                    print "    name: %r, min~max args: %d~%d" \
                        % (func_name, minargs, maxargs)
                assert minargs <= nargs <= maxargs
                assert len(stack) >= nargs
                assert len(stack) >= nargs
                argtext = listsep.join([arg.text for arg in stack[-nargs:]])
                otext = "%s(%s)" % (func_name, argtext)
                res = Operand(oUNK, None, FUNC_RANK, otext)
                if funcx == 1: # IF
                    testarg = stack[-nargs]
                    if testarg.kind not in (oNUM, oBOOL):
                        if blah and testarg.kind != oUNK:
                            print "IF testarg kind?"
                    elif testarg.value not in (0, 1):
                        if blah and testarg.value is not None:
                            print "IF testarg value?"
                    else:
                        if nargs == 2 and not testarg.value:
                            # IF(FALSE, tv) => FALSE
                            res.kind, res.value = oBOOL, 0
                        else:
                            respos = -nargs + 2 - int(testarg.value)
                            chosen = stack[respos]
                            if chosen.kind == oMSNG:
                                res.kind, res.value = oNUM, 0
                            else:
                                res.kind, res.value = chosen.kind, chosen.value
                        if blah:
                            print "$$$$$$ IF => constant"
                elif funcx == 100: # CHOOSE
                    testarg = stack[-nargs]
                    if testarg.kind == oNUM:
                        if 1 <= testarg.value < nargs:
                            chosen = stack[-nargs + int(testarg.value)]
                            if chosen.kind == oMSNG:
                                res.kind, res.value = oNUM, 0
                            else:
                                res.kind, res.value = chosen.kind, chosen.value
                del stack[-nargs:]
                spush(res)
        elif opcode == 0x03: #tName
            tgtnamex = unpack("<H", data[pos+1:pos+3])[0] - 1
            # Only change with BIFF version is number of trailing UNUSED bytes!
            if blah: print >> bk.logfile, "   tgtnamex=%d" % tgtnamex
            tgtobj = bk.name_obj_list[tgtnamex]
            if not tgtobj.evaluated:
                ### recursive ###
                evaluate_name_formula(bk, tgtobj, tgtnamex, blah, level+1)
            if tgtobj.macro or tgtobj.binary \
            or tgtobj.any_err:
                if blah:
                    tgtobj.dump(
                        bk.logfile,
                        header="!!! tgtobj has problems!!!",
                        footer="-----------       --------",
                        )
                res = Operand(oUNK, None)
                any_err = any_err or tgtobj.macro or tgtobj.binary or tgtobj.any_err
                any_rel = any_rel or tgtobj.any_rel
            else:
                assert len(tgtobj.stack) == 1
                res = copy.deepcopy(tgtobj.stack[0])
            res.rank = LEAF_RANK
            if tgtobj.scope == -1:
                res.text = tgtobj.name
            else:
                res.text = "%s!%s" \
                           % (bk._sheet_names[tgtobj.scope], tgtobj.name)
            if blah:
                print >> bk.logfile, "    tName: setting text to", repr(res.text)
            spush(res)
        elif opcode == 0x04: # tRef
            # not_in_name_formula(op, oname)
            res = get_cell_addr(data, pos+1, bv, reldelta)
            if blah: print >> bk.logfile, "  ", res
            rowx, colx, row_rel, col_rel = res
            shx1 = shx2 = 0 ####### N.B. relative to the CURRENT SHEET
            any_rel = 1
            coords = (shx1, shx2+1, rowx, rowx+1, colx, colx+1)
            if blah: print >> bk.logfile, "   ", coords
            res = Operand(oUNK, None)
            if optype == 1:
                relflags = (1, 1, row_rel, row_rel, col_rel, col_rel)
                res = Operand(oREL, [Ref3D(coords + relflags)])
            spush(res)
        elif opcode == 0x05: # tArea
            # not_in_name_formula(op, oname)
            res1, res2 = get_cell_range_addr(data, pos+1, bv, reldelta)
            if blah: print >> bk.logfile, "  ", res1, res2
            rowx1, colx1, row_rel1, col_rel1 = res1
            rowx2, colx2, row_rel2, col_rel2 = res2
            shx1 = shx2 = 0 ####### N.B. relative to the CURRENT SHEET
            any_rel = 1
            coords = (shx1, shx2+1, rowx1, rowx2+1, colx1, colx2+1)
            if blah: print >> bk.logfile, "   ", coords
            res = Operand(oUNK, None)
            if optype == 1:
                relflags = (1, 1, row_rel1, row_rel2, col_rel1, col_rel2)
                res = Operand(oREL, [Ref3D(coords + relflags)])
            spush(res)
        elif opcode == 0x06: # tMemArea
            not_in_name_formula(op, oname)
        elif opcode == 0x09: # tMemFunc
            nb = unpack("<H", data[pos+1:pos+3])[0]
            if blah: print >> bk.logfile, "  %d bytes of cell ref formula" % nb
            # no effect on stack
        elif opcode == 0x0C: #tRefN
            not_in_name_formula(op, oname)
            # res = get_cell_addr(data, pos+1, bv, reldelta=1)
            # # note *ALL* tRefN usage has signed offset for relative addresses
            # any_rel = 1
            # if blah: print >> bk.logfile, "   ", res
            # spush(res)
        elif opcode == 0x0D: #tAreaN
            not_in_name_formula(op, oname)
            # res = get_cell_range_addr(data, pos+1, bv, reldelta=1)
            # # note *ALL* tAreaN usage has signed offset for relative addresses
            # any_rel = 1
            # if blah: print >> bk.logfile, "   ", res
        elif opcode == 0x1A: # tRef3d
            if bv >= 80:
                res = get_cell_addr(data, pos+3, bv, reldelta)
                refx = unpack("<H", data[pos+1:pos+3])[0]
                shx1, shx2 = get_externsheet_local_range(bk, refx, blah)
            else:
                res = get_cell_addr(data, pos+15, bv, reldelta)
                raw_extshtx, raw_shx1, raw_shx2 = \
                             unpack("<hxxxxxxxxhh", data[pos+1:pos+15])
                if blah:
                    print >> bk.logfile, "tRef3d", raw_extshtx, raw_shx1, raw_shx2
                shx1, shx2 = get_externsheet_local_range_b57(
                                bk, raw_extshtx, raw_shx1, raw_shx2, blah)
            rowx, colx, row_rel, col_rel = res
            is_rel = row_rel or col_rel
            any_rel = any_rel or is_rel
            coords = (shx1, shx2+1, rowx, rowx+1, colx, colx+1)
            any_err |= shx1 < -1
            if blah: print >> bk.logfile, "   ", coords
            res = Operand(oUNK, None)
            if is_rel:
                relflags = (0, 0, row_rel, row_rel, col_rel, col_rel)
                ref3d = Ref3D(coords + relflags)
                res.kind = oREL
                res.text = rangename3drel(bk, ref3d)
            else:
                ref3d = Ref3D(coords)
                res.kind = oREF
                res.text = rangename3d(bk, ref3d)
            res.rank = LEAF_RANK
            if optype == 1:
                res.value = [ref3d]
            spush(res)
        elif opcode == 0x1B: # tArea3d
            if bv >= 80:
                res1, res2 = get_cell_range_addr(data, pos+3, bv, reldelta)
                refx = unpack("<H", data[pos+1:pos+3])[0]
                shx1, shx2 = get_externsheet_local_range(bk, refx, blah)
            else:
                res1, res2 = get_cell_range_addr(data, pos+15, bv, reldelta)
                raw_extshtx, raw_shx1, raw_shx2 = \
                             unpack("<hxxxxxxxxhh", data[pos+1:pos+15])
                if blah:
                    print >> bk.logfile, "tArea3d", raw_extshtx, raw_shx1, raw_shx2
                shx1, shx2 = get_externsheet_local_range_b57(
                                bk, raw_extshtx, raw_shx1, raw_shx2, blah)
            any_err |= shx1 < -1
            rowx1, colx1, row_rel1, col_rel1 = res1
            rowx2, colx2, row_rel2, col_rel2 = res2
            is_rel = row_rel1 or col_rel1 or row_rel2 or col_rel2
            any_rel = any_rel or is_rel
            coords = (shx1, shx2+1, rowx1, rowx2+1, colx1, colx2+1)
            if blah: print >> bk.logfile, "   ", coords
            res = Operand(oUNK, None)
            if is_rel:
                relflags = (0, 0, row_rel1, row_rel2, col_rel1, col_rel2)
                ref3d = Ref3D(coords + relflags)
                res.kind = oREL
                res.text = rangename3drel(bk, ref3d)
            else:
                ref3d = Ref3D(coords)
                res.kind = oREF
                res.text = rangename3d(bk, ref3d)
            res.rank = LEAF_RANK
            if optype == 1:
                res.value = [ref3d]

            spush(res)
        elif opcode == 0x19: # tNameX
            dodgy = 0
            res = Operand(oUNK, None)
            if bv >= 80:
                refx, tgtnamex = unpack("<HH", data[pos+1:pos+5])
                tgtnamex -= 1
                origrefx = refx
            else:
                refx, tgtnamex = unpack("<hxxxxxxxxH", data[pos+1:pos+13])
                tgtnamex -= 1
                origrefx = refx
                if refx > 0:
                    refx -= 1
                elif refx < 0:
                    refx = -refx - 1
                else:
                    dodgy = 1
            if blah:
                print >> bk.logfile, \
                    "   origrefx=%d refx=%d tgtnamex=%d dodgy=%d" \
                    % (origrefx, refx, tgtnamex, dodgy)
            if tgtnamex == namex:
                if blah: print >> bk.logfile, "!!!! Self-referential !!!!"
                dodgy = any_err = 1
            if not dodgy:
                if bv >= 80:
                    shx1, shx2 = get_externsheet_local_range(bk, refx, blah)
                elif origrefx > 0:
                    shx1, shx2 = (-4, -4) # external ref
                else:
                    exty = bk._externsheet_type_b57[refx]
                    if exty == 4: # non-specific sheet in own doc't
                        shx1, shx2 = (-1, -1) # internal, any sheet
                    else:
                        shx1, shx2 = (-666, -666)
            if dodgy or shx1 < -1:
                otext = "<<Name #%d in external(?) file #%d>>" \
                        % (tgtnamex, origrefx)
                res = Operand(oUNK, None, LEAF_RANK, otext)
            else:
                tgtobj = bk.name_obj_list[tgtnamex]
                if not tgtobj.evaluated:
                    ### recursive ###
                    evaluate_name_formula(bk, tgtobj, tgtnamex, blah, level+1)
                if tgtobj.macro or tgtobj.binary \
                or tgtobj.any_err:
                    if blah:
                        tgtobj.dump(
                            bk.logfile,
                            header="!!! bad tgtobj !!!",
                            footer="------------------",
                            )
                    res = Operand(oUNK, None)
                    any_err = any_err or tgtobj.macro or tgtobj.binary or tgtobj.any_err
                    any_rel = any_rel or tgtobj.any_rel
                else:
                    assert len(tgtobj.stack) == 1
                    res = copy.deepcopy(tgtobj.stack[0])
                res.rank = LEAF_RANK
                if tgtobj.scope == -1:
                    res.text = tgtobj.name
                else:
                    res.text = "%s!%s" \
                               % (bk._sheet_names[tgtobj.scope], tgtobj.name)
                if blah:
                    print >> bk.logfile, "    tNameX: setting text to", repr(res.text)
            spush(res)
        elif is_error_opcode(opcode):
            any_err = 1
            spush(error_opnd)
        else:
            if blah:
                print >> bk.logfile, "FORMULA: /// Not handled yet: t" + oname
            any_err = 1
        if sz <= 0:
            raise FormulaError("Fatal: token size is not positive")
        pos += sz
    any_rel = not not any_rel
    if blah:
        print "End of formula. level=%d any_rel=%d any_err=%d stack=%r" % \
            (level, not not any_rel, any_err, stack)
        if len(stack) >= 2:
            print "*** Stack has unprocessed args"
        print
    nobj.stack = stack
    if len(stack) != 1:
        nobj.result = None
    else:
        nobj.result = stack[0]
    nobj.any_rel = any_rel
    nobj.any_err = any_err
    nobj.any_external = any_external
    nobj.evaluated = 1

#### under construction ####
def decompile_formula(bk, fmla, fmlalen,
    reldelta, browx=None, bcolx=None,
    # browx & bcolx are required when reldelta == 0
    blah=0, level=0):
    if level > STACK_ALARM_LEVEL:
        blah = 1
    data = fmla
    bv = bk.biff_version
    if blah:
        print "::: decompile_formula len=%d reldelta=%d %r level=%d" \
            % (fmlalen, reldelta, data, level)
        hex_char_dump(data, 0, fmlalen)
    if level > STACK_PANIC_LEVEL:
        raise XLRDError("Excessive indirect references in formula")
    sztab = szdict[bv]
    pos = 0
    stack = []
    any_rel = 0
    any_err = 0
    any_external = 0
    unk_opnd = Operand(oUNK, None)
    error_opnd = Operand(oERR, None)
    spush = stack.append

    def do_binop(opcd, stk):
        assert len(stk) >= 2
        bop = stk.pop()
        aop = stk.pop()
        argdict, result_kind, func, rank, sym = binop_rules[opcd]
        otext = ''.join([
            '('[:aop.rank < rank],
            aop.text,
            ')'[:aop.rank < rank],
            sym,
            '('[:bop.rank < rank],
            bop.text,
            ')'[:bop.rank < rank],
            ])
        resop = Operand(result_kind, None, rank, otext)
        stk.append(resop)

    def do_unaryop(opcode, arglist, result_kind, stk):
        assert len(stk) >= 1
        aop = stk.pop()
        assert aop.kind in arglist
        func, rank, sym1, sym2 = unop_rules[opcode]
        otext = ''.join([
            sym1,
            '('[:aop.rank < rank],
            aop.text,
            ')'[:aop.rank < rank],
            sym2,
            ])
        stk.append(Operand(result_kind, None, rank, otext))

    def not_in_name_formula(op_arg, oname_arg):
        msg = "ERROR *** Unexpected token 0x%02x (%s) found in formula" \
              % (op_arg, oname_arg)
        # print msg
        raise FormulaError(msg)

    if fmlalen == 0:
        stack = [unk_opnd]

    while 0 <= pos < fmlalen:
        op = ord(data[pos])
        opcode = op & 0x1f
        optype = (op & 0x60) >> 5
        if optype:
            opx = opcode + 32
        else:
            opx = opcode
        oname = onames[opx] # + [" RVA"][optype]
        sz = sztab[opx]
        if blah:
            print "Pos:%d Op:0x%02x opname:t%s Sz:%d opcode:%02xh optype:%02xh" \
                % (pos, op, oname, sz, opcode, optype)
            print "Stack =", stack
        if sz == -2:
            msg = 'ERROR *** Unexpected token 0x%02x ("%s"); biff_version=%d' \
                % (op, oname, bv)
            raise FormulaError(msg)
        if not optype:
            if 0x00 <= opcode <= 0x02: # unk_opnd, tExp, tTbl
                not_in_name_formula(op, oname)
            elif 0x03 <= opcode <= 0x0E:
                # Add, Sub, Mul, Div, Power
                # tConcat
                # tLT, ..., tNE
                do_binop(opcode, stack)
            elif opcode == 0x0F: # tIsect
                if blah: print >> bk.logfile, "tIsect pre", stack
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                sym = ' '
                rank = 80 ########## check #######
                otext = ''.join([
                    '('[:aop.rank < rank],
                    aop.text,
                    ')'[:aop.rank < rank],
                    sym,
                    '('[:bop.rank < rank],
                    bop.text,
                    ')'[:bop.rank < rank],
                    ])
                res = Operand(oREF)
                res.text = otext
                if bop.kind == oERR or aop.kind == oERR:
                    res.kind = oERR
                elif bop.kind == oUNK or aop.kind == oUNK:
                    # This can happen with undefined
                    # (go search in the current sheet) labels.
                    # For example =Bob Sales
                    # Each label gets a NAME record with an empty formula (!)
                    # Evaluation of the tName token classifies it as oUNK
                    # res.kind = oREF
                    pass
                elif bop.kind == oREF == aop.kind:
                    pass
                elif bop.kind == oREL == aop.kind:
                    res.kind = oREL
                else:
                    pass
                spush(res)
                if blah: print >> bk.logfile, "tIsect post", stack
            elif opcode == 0x10: # tList
                if blah: print >> bk.logfile, "tList pre", stack
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                sym = ','
                rank = 80 ########## check #######
                otext = ''.join([
                    '('[:aop.rank < rank],
                    aop.text,
                    ')'[:aop.rank < rank],
                    sym,
                    '('[:bop.rank < rank],
                    bop.text,
                    ')'[:bop.rank < rank],
                    ])
                res = Operand(oREF, None, rank, otext)
                if bop.kind == oERR or aop.kind == oERR:
                    res.kind = oERR
                elif bop.kind in (oREF, oREL) and aop.kind in (oREF, oREL):
                    res.kind = oREF
                    if aop.kind == oREL or bop.kind == oREL:
                        res.kind = oREL
                else:
                    pass
                spush(res)
                if blah: print >> bk.logfile, "tList post", stack
            elif opcode == 0x11: # tRange
                if blah: print >> bk.logfile, "tRange pre", stack
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                sym = ':'
                rank = 80 ########## check #######
                otext = ''.join([
                    '('[:aop.rank < rank],
                    aop.text,
                    ')'[:aop.rank < rank],
                    sym,
                    '('[:bop.rank < rank],
                    bop.text,
                    ')'[:bop.rank < rank],
                    ])
                res = Operand(oREF, None, rank, otext)
                if bop.kind == oERR or aop.kind == oERR:
                    res = oERR
                elif bop.kind == oREF == aop.kind:
                    pass
                else:
                    pass
                spush(res)
                if blah: print >> bk.logfile, "tRange post", stack
            elif 0x12 <= opcode <= 0x14: # tUplus, tUminus, tPercent
                do_unaryop(opcode, (oUNK, oNUM,), oNUM, stack)
            elif opcode == 0x15: # tParen
                # source cosmetics
                pass
            elif opcode == 0x16: # tMissArg
                spush(Operand(oMSNG, None, LEAF_RANK, ''))
            elif opcode == 0x17: # tStr
                if bv <= 70:
                    strg, newpos = unpack_string_update_pos(
                                        data, pos+1, bk.encoding, lenlen=1)
                else:
                    strg, newpos = unpack_unicode_update_pos(
                                        data, pos+1, lenlen=1)
                sz = newpos - pos
                if blah: print >> bk.logfile, "   sz=%d strg=%r" % (sz, strg)
                text = '"' + strg.replace('"', '""') + '"'
                spush(Operand(oSTRG, None, LEAF_RANK, text))
            elif opcode == 0x18: # tExtended
                # new with BIFF 8
                assert bv >= 80
                # not in OOo docs
                raise FormulaError("tExtended token not implemented")
            elif opcode == 0x19: # tAttr
                subop, nc = unpack("<BH", data[pos+1:pos+4])
                subname = tAttrNames.get(subop, "??Unknown??")
                if subop == 0x04: # Choose
                    sz = nc * 2 + 6
                elif subop == 0x10: # Sum (single arg)
                    sz = 4
                    if blah: print >> bk.logfile, "tAttrSum", stack
                    assert len(stack) >= 1
                    aop = stack[-1]
                    otext = 'SUM(%s)' % aop.text
                    stack[-1] = Operand(oNUM, None, FUNC_RANK, otext)
                else:
                    sz = 4
                if blah:
                    print "   subop=%02xh subname=t%s sz=%d nc=%02xh" \
                        % (subop, subname, sz, nc)
            elif 0x1A <= opcode <= 0x1B: # tSheet, tEndSheet
                assert bv < 50
                raise FormulaError("tSheet & tEndsheet tokens not implemented")
            elif 0x1C <= opcode <= 0x1F: # tErr, tBool, tInt, tNum
                inx = opcode - 0x1C
                nb = [1, 1, 2, 8][inx]
                kind = [oERR, oBOOL, oNUM, oNUM][inx]
                value, = unpack("<" + "BBHd"[inx], data[pos+1:pos+1+nb])
                if inx == 2: # tInt
                    value = float(value)
                    text = str(value)
                elif inx == 3: # tNum
                    text = str(value)
                elif inx == 1: # tBool
                    text = ('FALSE', 'TRUE')[value]
                else:
                    text = '"' +error_text_from_code[value] + '"'
                spush(Operand(kind, None, LEAF_RANK, text))
            else:
                raise FormulaError("Unhandled opcode: 0x%02x" % opcode)
            if sz <= 0:
                raise FormulaError("Size not set for opcode 0x%02x" % opcode)
            pos += sz
            continue
        if opcode == 0x00: # tArray
            spush(unk_opnd)
        elif opcode == 0x01: # tFunc
            nb = 1 + int(bv >= 40)
            funcx = unpack("<" + " BH"[nb], data[pos+1:pos+1+nb])[0]
            func_attrs = func_defs.get(funcx, None)
            if not func_attrs:
                print >> bk.logfile, "*** formula/tFunc unknown FuncID:%d" % funcx
                spush(unk_opnd)
            else:
                func_name, nargs = func_attrs[:2]
                if blah:
                    print "    FuncID=%d name=%s nargs=%d" \
                          % (funcx, func_name, nargs)
                assert len(stack) >= nargs
                argtext = listsep.join([arg.text for arg in stack[-nargs:]])
                otext = "%s(%s)" % (func_name, argtext)
                del stack[-nargs:]
                res = Operand(oUNK, None, FUNC_RANK, otext)
                spush(res)
        elif opcode == 0x02: #tFuncVar
            nb = 1 + int(bv >= 40)
            nargs, funcx = unpack("<B" + " BH"[nb], data[pos+1:pos+2+nb])
            prompt, nargs = divmod(nargs, 128)
            macro, funcx = divmod(funcx, 32768)
            if blah:
                print "   FuncID=%d nargs=%d macro=%d prompt=%d" \
                      % (funcx, nargs, macro, prompt)
            #### TODO #### if funcx == 255: # call add-in function
            if funcx == 255:
                func_attrs = ("CALL_ADDIN", 1, 30)
            else:
                func_attrs = func_defs.get(funcx, None)
            if not func_attrs:
                print >> bk.logfile, "*** formula/tFuncVar unknown FuncID:%d" \
                      % funcx
                spush(unk_opnd)
            else:
                func_name, minargs, maxargs = func_attrs[:3]
                if blah:
                    print "    name: %r, min~max args: %d~%d" \
                        % (func_name, minargs, maxargs)
                assert minargs <= nargs <= maxargs
                assert len(stack) >= nargs
                assert len(stack) >= nargs
                argtext = listsep.join([arg.text for arg in stack[-nargs:]])
                otext = "%s(%s)" % (func_name, argtext)
                res = Operand(oUNK, None, FUNC_RANK, otext)
                del stack[-nargs:]
                spush(res)
        elif opcode == 0x03: #tName
            tgtnamex = unpack("<H", data[pos+1:pos+3])[0] - 1
            # Only change with BIFF version is number of trailing UNUSED bytes!
            if blah: print >> bk.logfile, "   tgtnamex=%d" % tgtnamex
            tgtobj = bk.name_obj_list[tgtnamex]
            if tgtobj.scope == -1:
                otext = tgtobj.name
            else:
                otext = "%s!%s" % (bk._sheet_names[tgtobj.scope], tgtobj.name)
            if blah:
                print >> bk.logfile, "    tName: setting text to", repr(otext)
            res = Operand(oUNK, None, LEAF_RANK, otext)
            spush(res)
        elif opcode == 0x04: # tRef
            res = get_cell_addr(data, pos+1, bv, reldelta, browx, bcolx)
            if blah: print >> bk.logfile, "  ", res
            rowx, colx, row_rel, col_rel = res
            is_rel = row_rel or col_rel
            if is_rel:
                okind = oREL
            else:
                okind = oREF
            otext = cellnamerel(rowx, colx, row_rel, col_rel)
            res = Operand(okind, None, LEAF_RANK, otext)
            spush(res)
        elif opcode == 0x05: # tArea
            res1, res2 = get_cell_range_addr(
                            data, pos+1, bv, reldelta, browx, bcolx)
            if blah: print >> bk.logfile, "  ", res1, res2
            rowx1, colx1, row_rel1, col_rel1 = res1
            rowx2, colx2, row_rel2, col_rel2 = res2
            coords = (rowx1, rowx2+1, colx1, colx2+1)
            relflags = (row_rel1, row_rel2, col_rel1, col_rel2)
            is_rel = intbool(sum(relflags))
            if is_rel:
                okind = oREL
            else:
                okind = oREF
            if blah: print >> bk.logfile, "   ", coords, relflags
            otext = rangename2drel(coords, relflags)
            res = Operand(okind, None, LEAF_RANK, otext)
            spush(res)
        elif opcode == 0x06: # tMemArea
            not_in_name_formula(op, oname)
        elif opcode == 0x09: # tMemFunc
            nb = unpack("<H", data[pos+1:pos+3])[0]
            if blah: print >> bk.logfile, "  %d bytes of cell ref formula" % nb
            # no effect on stack
        elif opcode == 0x0C: #tRefN
            not_in_name_formula(op, oname)
            # res = get_cell_addr(data, pos+1, bv, reldelta=1)
            # # note *ALL* tRefN usage has signed offset for relative addresses
            # any_rel = 1
            # if blah: print >> bk.logfile, "   ", res
            # spush(res)
        elif opcode == 0x0D: #tAreaN
            not_in_name_formula(op, oname)
            # res = get_cell_range_addr(data, pos+1, bv, reldelta=1)
            # # note *ALL* tAreaN usage has signed offset for relative addresses
            # any_rel = 1
            # if blah: print >> bk.logfile, "   ", res
        elif opcode == 0x1A: # tRef3d
            if bv >= 80:
                res = get_cell_addr(data, pos+3, bv, reldelta, browx, bcolx)
                refx = unpack("<H", data[pos+1:pos+3])[0]
                shx1, shx2 = get_externsheet_local_range(bk, refx, blah)
            else:
                res = get_cell_addr(data, pos+15, bv, reldelta, browx, bcolx)
                raw_extshtx, raw_shx1, raw_shx2 = \
                             unpack("<hxxxxxxxxhh", data[pos+1:pos+15])
                if blah:
                    print >> bk.logfile, "tRef3d", raw_extshtx, raw_shx1, raw_shx2
                shx1, shx2 = get_externsheet_local_range_b57(
                                bk, raw_extshtx, raw_shx1, raw_shx2, blah)
            rowx, colx, row_rel, col_rel = res
            is_rel = row_rel or col_rel
            any_rel = any_rel or is_rel
            coords = (shx1, shx2+1, rowx, rowx+1, colx, colx+1)
            any_err |= shx1 < -1
            if blah: print >> bk.logfile, "   ", coords
            res = Operand(oUNK, None)
            if is_rel:
                relflags = (0, 0, row_rel, row_rel, col_rel, col_rel)
                ref3d = Ref3D(coords + relflags)
                res.kind = oREL
                res.text = rangename3drel(bk, ref3d)
            else:
                ref3d = Ref3D(coords)
                res.kind = oREF
                res.text = rangename3d(bk, ref3d)
            res.rank = LEAF_RANK
            res.value = None
            spush(res)
        elif opcode == 0x1B: # tArea3d
            if bv >= 80:
                res1, res2 = get_cell_range_addr(data, pos+3, bv, reldelta)
                refx = unpack("<H", data[pos+1:pos+3])[0]
                shx1, shx2 = get_externsheet_local_range(bk, refx, blah)
            else:
                res1, res2 = get_cell_range_addr(data, pos+15, bv, reldelta)
                raw_extshtx, raw_shx1, raw_shx2 = \
                             unpack("<hxxxxxxxxhh", data[pos+1:pos+15])
                if blah:
                    print >> bk.logfile, "tArea3d", raw_extshtx, raw_shx1, raw_shx2
                shx1, shx2 = get_externsheet_local_range_b57(
                                bk, raw_extshtx, raw_shx1, raw_shx2, blah)
            any_err |= shx1 < -1
            rowx1, colx1, row_rel1, col_rel1 = res1
            rowx2, colx2, row_rel2, col_rel2 = res2
            is_rel = row_rel1 or col_rel1 or row_rel2 or col_rel2
            any_rel = any_rel or is_rel
            coords = (shx1, shx2+1, rowx1, rowx2+1, colx1, colx2+1)
            if blah: print >> bk.logfile, "   ", coords
            res = Operand(oUNK, None)
            if is_rel:
                relflags = (0, 0, row_rel1, row_rel2, col_rel1, col_rel2)
                ref3d = Ref3D(coords + relflags)
                res.kind = oREL
                res.text = rangename3drel(bk, ref3d)
            else:
                ref3d = Ref3D(coords)
                res.kind = oREF
                res.text = rangename3d(bk, ref3d)
            res.rank = LEAF_RANK
            spush(res)
        elif opcode == 0x19: # tNameX
            dodgy = 0
            res = Operand(oUNK, None)
            if bv >= 80:
                refx, tgtnamex = unpack("<HH", data[pos+1:pos+5])
                tgtnamex -= 1
                origrefx = refx
            else:
                refx, tgtnamex = unpack("<hxxxxxxxxH", data[pos+1:pos+13])
                tgtnamex -= 1
                origrefx = refx
                if refx > 0:
                    refx -= 1
                elif refx < 0:
                    refx = -refx - 1
                else:
                    dodgy = 1
            if blah:
                print >> bk.logfile, \
                    "   origrefx=%d refx=%d tgtnamex=%d dodgy=%d" \
                    % (origrefx, refx, tgtnamex, dodgy)
            # if tgtnamex == namex:
            #     if blah: print >> bk.logfile, "!!!! Self-referential !!!!"
            #     dodgy = any_err = 1
            if not dodgy:
                if bv >= 80:
                    shx1, shx2 = get_externsheet_local_range(bk, refx, blah)
                elif origrefx > 0:
                    shx1, shx2 = (-4, -4) # external ref
                else:
                    exty = bk._externsheet_type_b57[refx]
                    if exty == 4: # non-specific sheet in own doc't
                        shx1, shx2 = (-1, -1) # internal, any sheet
                    else:
                        shx1, shx2 = (-666, -666)
            okind = oUNK
            ovalue = None
            if shx1 == -5: # addin func name
                okind = oSTRG
                ovalue = bk.addin_func_names[tgtnamex]
                otext = '"' + ovalue.replace('"', '""') + '"'
            elif dodgy or shx1 < -1:
                otext = "<<Name #%d in external(?) file #%d>>" \
                        % (tgtnamex, origrefx)
            else:
                tgtobj = bk.name_obj_list[tgtnamex]
                if tgtobj.scope == -1:
                    otext = tgtobj.name
                else:
                    otext = "%s!%s" \
                            % (bk._sheet_names[tgtobj.scope], tgtobj.name)
                if blah:
                    print >> bk.logfile, "    tNameX: setting text to", repr(res.text)
            res = Operand(okind, ovalue, LEAF_RANK, otext)
            spush(res)
        elif is_error_opcode(opcode):
            any_err = 1
            spush(error_opnd)
        else:
            if blah:
                print >> bk.logfile, "FORMULA: /// Not handled yet: t" + oname
            any_err = 1
        if sz <= 0:
            raise FormulaError("Fatal: token size is not positive")
        pos += sz
    any_rel = not not any_rel
    if blah:
        print "End of formula. level=%d any_rel=%d any_err=%d stack=%r" % \
            (level, not not any_rel, any_err, stack)
        if len(stack) >= 2:
            print "*** Stack has unprocessed args"
        print

    if len(stack) != 1:
        result = None
    else:
        result = stack[0].text
    return result

#### under deconstruction ###
def dump_formula(bk, data, fmlalen, bv, reldelta, blah=0, isname=0):
    if blah:
        print "dump_formula", fmlalen, bv, len(data)
        hex_char_dump(data, 0, fmlalen)
    assert bv >= 80 #### this function needs updating ####
    sztab = szdict[bv]
    pos = 0
    stack = []
    any_rel = 0
    any_err = 0
    spush = stack.append
    while 0 <= pos < fmlalen:
        op = ord(data[pos])
        opcode = op & 0x1f
        optype = (op & 0x60) >> 5
        if optype:
            opx = opcode + 32
        else:
            opx = opcode
        oname = onames[opx] # + [" RVA"][optype]

        sz = sztab[opx]
        if blah:
            print "Pos:%d Op:0x%02x Name:t%s Sz:%d opcode:%02xh optype:%02xh" \
                % (pos, op, oname, sz, opcode, optype)
        if not optype:
            if 0x01 <= opcode <= 0x02: # tExp, tTbl
                # reference to a shared formula or table record
                rowx, colx = unpack("<HH", data[pos+1:pos+5])
                if blah: print >> bk.logfile, "  ", (rowx, colx)
            elif opcode == 0x10: # tList
                if blah: print >> bk.logfile, "tList pre", stack
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                spush(aop + bop)
                if blah: print >> bk.logfile, "tlist post", stack
            elif opcode == 0x11: # tRange
                if blah: print >> bk.logfile, "tRange pre", stack
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                assert len(aop) == 1
                assert len(bop) == 1
                result = do_box_funcs(tRangeFuncs, aop[0], bop[0])
                spush(result)
                if blah: print >> bk.logfile, "tRange post", stack
            elif opcode == 0x0F: # tIsect
                if blah: print >> bk.logfile, "tIsect pre", stack
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                assert len(aop) == 1
                assert len(bop) == 1
                result = do_box_funcs(tIsectFuncs, aop[0], bop[0])
                spush(result)
                if blah: print >> bk.logfile, "tIsect post", stack
            elif opcode == 0x19: # tAttr
                subop, nc = unpack("<BH", data[pos+1:pos+4])
                subname = tAttrNames.get(subop, "??Unknown??")
                if subop == 0x04: # Choose
                    sz = nc * 2 + 6
                else:
                    sz = 4
                if blah: print >> bk.logfile, "   subop=%02xh subname=t%s sz=%d nc=%02xh" % (subop, subname, sz, nc)
            elif opcode == 0x17: # tStr
                if bv <= 70:
                    nc = ord(data[pos+1])
                    strg = data[pos+2:pos+2+nc] # left in 8-bit encoding
                    sz = nc + 2
                else:
                    strg, newpos = unpack_unicode_update_pos(data, pos+1, lenlen=1)
                    sz = newpos - pos
                if blah: print >> bk.logfile, "   sz=%d strg=%r" % (sz, strg)
            else:
                if sz <= 0:
                    print "**** Dud size; exiting ****"
                    return
            pos += sz
            continue
        if opcode == 0x00: # tArray
            pass
        elif opcode == 0x01: # tFunc
            nb = 1 + int(bv >= 40)
            funcx = unpack("<" + " BH"[nb], data[pos+1:pos+1+nb])
            if blah: print >> bk.logfile, "   FuncID=%d" % funcx
        elif opcode == 0x02: #tFuncVar
            nb = 1 + int(bv >= 40)
            nargs, funcx = unpack("<B" + " BH"[nb], data[pos+1:pos+2+nb])
            prompt, nargs = divmod(nargs, 128)
            macro, funcx = divmod(funcx, 32768)
            if blah: print >> bk.logfile, "   FuncID=%d nargs=%d macro=%d prompt=%d" % (funcx, nargs, macro, prompt)
        elif opcode == 0x03: #tName
            namex = unpack("<H", data[pos+1:pos+3])
            # Only change with BIFF version is the number of trailing UNUSED bytes!!!
            if blah: print >> bk.logfile, "   namex=%d" % namex
        elif opcode == 0x04: # tRef
            res = get_cell_addr(data, pos+1, bv, reldelta)
            if blah: print >> bk.logfile, "  ", res
        elif opcode == 0x05: # tArea
            res = get_cell_range_addr(data, pos+1, bv, reldelta)
            if blah: print >> bk.logfile, "  ", res
        elif opcode == 0x09: # tMemFunc
            nb = unpack("<H", data[pos+1:pos+3])[0]
            if blah: print >> bk.logfile, "  %d bytes of cell ref formula" % nb
        elif opcode == 0x0C: #tRefN
            res = get_cell_addr(data, pos+1, bv, reldelta=1)
            # note *ALL* tRefN usage has signed offset for relative addresses
            any_rel = 1
            if blah: print >> bk.logfile, "   ", res
        elif opcode == 0x0D: #tAreaN
            res = get_cell_range_addr(data, pos+1, bv, reldelta=1)
            # note *ALL* tAreaN usage has signed offset for relative addresses
            any_rel = 1
            if blah: print >> bk.logfile, "   ", res
        elif opcode == 0x1A: # tRef3d
            refx = unpack("<H", data[pos+1:pos+3])[0]
            res = get_cell_addr(data, pos+3, bv, reldelta)
            if blah: print >> bk.logfile, "  ", refx, res
            rowx, colx, row_rel, col_rel = res
            any_rel = any_rel or row_rel or col_rel
            shx1, shx2 = get_externsheet_local_range(bk, refx, blah)
            any_err |= shx1 < -1
            coords = (shx1, shx2+1, rowx, rowx+1, colx, colx+1)
            if blah: print >> bk.logfile, "   ", coords
            if optype == 1: spush([coords])
        elif opcode == 0x1B: # tArea3d
            refx = unpack("<H", data[pos+1:pos+3])[0]
            res1, res2 = get_cell_range_addr(data, pos+3, bv, reldelta)
            if blah: print >> bk.logfile, "  ", refx, res1, res2
            rowx1, colx1, row_rel1, col_rel1 = res1
            rowx2, colx2, row_rel2, col_rel2 = res2
            any_rel = any_rel or row_rel1 or col_rel1 or row_rel2 or col_rel2
            shx1, shx2 = get_externsheet_local_range(bk, refx, blah)
            any_err |= shx1 < -1
            coords = (shx1, shx2+1, rowx1, rowx2+1, colx1, colx2+1)
            if blah: print >> bk.logfile, "   ", coords
            if optype == 1: spush([coords])
        elif opcode == 0x19: # tNameX
            refx, namex = unpack("<HH", data[pos+1:pos+5])
            if blah: print >> bk.logfile, "   refx=%d namex=%d" % (refx, namex)
        elif is_error_opcode(opcode):
            any_err = 1
        else:
            if blah: print >> bk.logfile, "FORMULA: /// Not handled yet: t" + oname
            any_err = 1
        if sz <= 0:
            print "**** Dud size; exiting ****"
            return
        pos += sz
    if blah:
        print >> bk.logfile, "End of formula. any_rel=%d any_err=%d stack=%r" % \
            (not not any_rel, any_err, stack)
        if len(stack) >= 2:
            print >> bk.logfile, "*** Stack has unprocessed args"

# === Some helper functions for displaying cell references ===

# Note that a "non-standard" syntax is used in row and column
# components in relative references.
# For example, consider a relative reference: up two rows, right 3 columns.
# On screen, with cursor in cell D10, this would appear as G8.
# On screen, with cursor in cell Z100, this would appear as AC98.
# On screen, with cursor in cell A1, this would appear as D65535.
# These functions will display such a reference as [@+3,#-2].
# "@" refers to the unknown base column.
# "#" refers to the unknown base row.
#
# I'm aware of only one possibility of a sheet-relative component in
# a reference: a 2D reference located in the "current sheet".
# xlrd stores this internally with bounds of (0, 1, ...) and
# relative flags of (1, 1, ...). These functions display the
# sheet component as empty, just like Excel etc.

def rownamerel(rowx, rowxrel):
    if not rowxrel:
        return "$%d" % rowx
    if rowx > 0:
        return "#+%d" % rowx
    if rowx < 0:
        return "#-%d" % (-rowx)
    return "#"

def colnamerel(colx, colxrel):
    if not colxrel:
        return "$" + colname(colx)
    if colx > 0:
        return "@+%d" % colx
    if colx < 0:
        return "@-%d" % (-colx)
    return "@"
##
# Utility function: (5, 7) => 'H6'
def cellname(rowx, colx):
    """ (5, 7) => 'H6' """
    return "%s%d" % (colname(colx), rowx+1)

##
# Utility function: (5, 7) => '$H$6'
def cellnameabs(rowx, colx):
    """ (5, 7) => '$H$6' """
    return "$%s$%d" % (colname(colx), rowx+1)

def cellnamerel(rowx, colx, rowxrel, colxrel):
    if not rowxrel and not colxrel:
        return cellnameabs(rowx, colx)
    return "[%s,%s]" % (
        colnamerel(colx, colxrel),
        rownamerel(rowx, rowxrel))
##
# Utility function: 7 => 'H', 27 => 'AB'
def colname(colx):
    """ 7 => 'H', 27 => 'AB' """
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    if colx <= 25:
        return alphabet[colx]
    else:
        xdiv26, xmod26 = divmod(colx, 26)
        return alphabet[xdiv26 - 1] + alphabet[xmod26]

def rangename2d(rlo, rhi, clo, chi):
    """ (5, 20, 7, 10) => '$H$6:$J$20' """
    if rhi == rlo+1 and chi == clo+1:
        return cellnameabs(rlo, clo)
    return "%s:%s" % (cellnameabs(rlo, clo), cellnameabs(rhi-1, chi-1))

def rangename2drel((rlo, rhi, clo, chi), (rlorel, rhirel, clorel, chirel)):
    return "%s:%s" % (
        cellnamerel(rlo, clo, rlorel, clorel),
        cellnamerel(rhi-1, chi-1, rhirel, chirel)
        )
##
# Utility function:
# <br /> Ref3D((1, 4, 5, 20, 7, 10)) => 'Sheet2:Sheet3!$H$6:$J$20'
def rangename3d(book, ref3d):
    """ Ref3D(1, 4, 5, 20, 7, 10) => 'Sheet2:Sheet3!$H$6:$J$20'
        (assuming Excel's default sheetnames) """
    coords = ref3d.coords
    return "%s!%s" % (
        sheetrange(book, *coords[:2]),
        rangename2d(*coords[2:6]))

##
# Utility function:
# <br /> Ref3D(coords=(0, 1, -32, -22, -13, 13), relflags=(0, 0, 1, 1, 1, 1))
# => 'Sheet1![@-13,#-32]:[@+12,#-23]'
# where '@' refers to the current or base column and '#'
# refers to the current or base row.
def rangename3drel(book, ref3d):
    coords = ref3d.coords
    relflags = ref3d.relflags
    shdesc = sheetrangerel(book, coords[:2], relflags[:2])
    rngdesc = rangename2drel(coords[2:6], relflags[2:6])
    if not shdesc:
        return rngdesc
    return "%s!%s" % (shdesc, rngdesc)

def quotedsheetname(shnames, shx):
    if shx >= 0:
        shname = shnames[shx]
    else:
        shname = {
            -1: "?internal; any sheet?",
            -2: "internal; deleted sheet",
            -3: "internal; macro sheet",
            -4: "<<external>>",
            }.get(shx, "?error %d?" % shx)
    if "'" in shname:
        return "'" + shname.replace("'", "''") + "'"
    if " " in shname:
        return "'" + shname + "'"
    return shname

def sheetrange(book, slo, shi):
    shnames = book.sheet_names()
    shdesc = quotedsheetname(shnames, slo)
    if slo != shi-1:
        shdesc += ":" + quotedsheetname(shnames, shi-1)
    return shdesc

def sheetrangerel(book, (slo, shi), (slorel, shirel)):
    if not slorel and not shirel:
        return sheetrange(book, slo, shi)
    assert (slo == 0 == shi-1) and slorel and shirel
    return ""

# ==============================================================

########NEW FILE########
__FILENAME__ = licences
# -*- coding: cp1252 -*-

"""
Portions copyright  2005-2009, Stephen John Machin, Lingfo Pty Ltd
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. None of the names of Stephen John Machin, Lingfo Pty Ltd and any
contributors may be used to endorse or promote products derived from this
software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
THE POSSIBILITY OF SUCH DAMAGE.
"""

"""
/*-
 * Copyright (c) 2001 David Giffin.
 * All rights reserved.
 *
 * Based on the the Java version: Andrew Khan Copyright (c) 2000.
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by
 *     David Giffin <david@giffin.org>."
 *
 * 4. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by
 *     David Giffin <david@giffin.org>."
 *
 * THIS SOFTWARE IS PROVIDED BY DAVID GIFFIN ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL DAVID GIFFIN OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
"""

########NEW FILE########
__FILENAME__ = sheet
# -*- coding: cp1252 -*-

##
# <p> Portions copyright  2005-2009 Stephen John Machin, Lingfo Pty Ltd</p>
# <p>This module is part of the xlrd package, which is released under a BSD-style licence.</p>
##

# 2009-05-31 SJM Fixed problem with no CODEPAGE record on extremely minimal BIFF2.x 3rd-party file
# 2009-04-27 SJM Integrated on_demand patch by Armando Serrano Lombillo
# 2008-02-09 SJM Excel 2.0: build XFs on the fly from cell attributes
# 2007-12-04 SJM Added support for Excel 2.x (BIFF2) files.
# 2007-10-11 SJM Added missing entry for blank cell type to ctype_text
# 2007-07-11 SJM Allow for BIFF2/3-style FORMAT record in BIFF4/8 file
# 2007-04-22 SJM Remove experimental "trimming" facility.

from biffh import *
from timemachine import *
from struct import unpack
from formula import dump_formula, decompile_formula, rangename2d
from formatting import nearest_colour_index, Format
import time

DEBUG = 0
OBJ_MSO_DEBUG = 0

_WINDOW2_options = (
    # Attribute names and initial values to use in case
    # a WINDOW2 record is not written.
    ("show_formulas", 0),
    ("show_grid_lines", 1),
    ("show_sheet_headers", 1),
    ("panes_are_frozen", 0),
    ("show_zero_values", 1),
    ("automatic_grid_line_colour", 1),
    ("columns_from_right_to_left", 0),
    ("show_outline_symbols", 1),
    ("remove_splits_if_pane_freeze_is_removed", 0),
    ("sheet_selected", 0),
    # "sheet_visible" appears to be merely a clone of "sheet_selected".
    # The real thing is the visibility attribute from the BOUNDSHEET record.
    ("sheet_visible", 0),
    ("show_in_page_break_preview", 0),
    )

##
# <p>Contains the data for one worksheet.</p>
#
# <p>In the cell access functions, "rowx" is a row index, counting from zero, and "colx" is a
# column index, counting from zero.
# Negative values for row/column indexes and slice positions are supported in the expected fashion.</p>
#
# <p>For information about cell types and cell values, refer to the documentation of the Cell class.</p>
#
# <p>WARNING: You don't call this class yourself. You access Sheet objects via the Book object that
# was returned when you called xlrd.open_workbook("myfile.xls").</p>


class Sheet(BaseObject):
    ##
    # Name of sheet.
    name = ''

    ##
    # Number of rows in sheet. A row index is in range(thesheet.nrows).
    nrows = 0

    ##
    # Number of columns in sheet. A column index is in range(thesheet.ncols).
    ncols = 0

    ##
    # The map from a column index to a Colinfo object. Often there is an entry
    # in COLINFO records for all column indexes in range(257).
    # Note that xlrd ignores the entry for the non-existent
    # 257th column. On the other hand, there may be no entry for unused columns.
    # <br /> -- New in version 0.6.1
    colinfo_map = {}

    ##
    # The map from a row index to a Rowinfo object. Note that it is possible
    # to have missing entries -- at least one source of XLS files doesn't
    # bother writing ROW records.
    # <br /> -- New in version 0.6.1
    rowinfo_map = {}

    ##
    # List of address ranges of cells containing column labels.
    # These are set up in Excel by Insert > Name > Labels > Columns.
    # <br> -- New in version 0.6.0
    # <br>How to deconstruct the list:
    # <pre>
    # for crange in thesheet.col_label_ranges:
    #     rlo, rhi, clo, chi = crange
    #     for rx in xrange(rlo, rhi):
    #         for cx in xrange(clo, chi):
    #             print "Column label at (rowx=%d, colx=%d) is %r" \
    #                 (rx, cx, thesheet.cell_value(rx, cx))
    # </pre>
    col_label_ranges = []

    ##
    # List of address ranges of cells containing row labels.
    # For more details, see <i>col_label_ranges</i> above.
    # <br> -- New in version 0.6.0
    row_label_ranges = []

    ##
    # List of address ranges of cells which have been merged.
    # These are set up in Excel by Format > Cells > Alignment, then ticking
    # the "Merge cells" box.
    # <br> -- New in version 0.6.1. Extracted only if open_workbook(..., formatting_info=True)
    # <br>How to deconstruct the list:
    # <pre>
    # for crange in thesheet.merged_cells:
    #     rlo, rhi, clo, chi = crange
    #     for rowx in xrange(rlo, rhi):
    #         for colx in xrange(clo, chi):
    #             # cell (rlo, clo) (the top left one) will carry the data
    #             # and formatting info; the remainder will be recorded as
    #             # blank cells, but a renderer will apply the formatting info
    #             # for the top left cell (e.g. border, pattern) to all cells in
    #             # the range.
    # </pre>
    merged_cells = []

    ##
    # Default column width from DEFCOLWIDTH record, else None.
    # From the OOo docs:<br />
    # """Column width in characters, using the width of the zero character
    # from default font (first FONT record in the file). Excel adds some
    # extra space to the default width, depending on the default font and
    # default font size. The algorithm how to exactly calculate the resulting
    # column width is not known.<br />
    # Example: The default width of 8 set in this record results in a column
    # width of 8.43 using Arial font with a size of 10 points."""<br />
    # For the default hierarchy, refer to the Colinfo class above.
    # <br /> -- New in version 0.6.1
    defcolwidth = None

    ##
    # Default column width from STANDARDWIDTH record, else None.
    # From the OOo docs:<br />
    # """Default width of the columns in 1/256 of the width of the zero
    # character, using default font (first FONT record in the file)."""<br />
    # For the default hierarchy, refer to the Colinfo class above.
    # <br /> -- New in version 0.6.1
    standardwidth = None

    ##
    # Default value to be used for a row if there is
    # no ROW record for that row.
    # From the <i>optional</i> DEFAULTROWHEIGHT record.
    default_row_height = None

    ##
    # Default value to be used for a row if there is
    # no ROW record for that row.
    # From the <i>optional</i> DEFAULTROWHEIGHT record.
    default_row_height_mismatch = None

    ##
    # Default value to be used for a row if there is
    # no ROW record for that row.
    # From the <i>optional</i> DEFAULTROWHEIGHT record.
    default_row_hidden = None

    ##
    # Default value to be used for a row if there is
    # no ROW record for that row.
    # From the <i>optional</i> DEFAULTROWHEIGHT record.
    default_additional_space_above = None

    ##
    # Default value to be used for a row if there is
    # no ROW record for that row.
    # From the <i>optional</i> DEFAULTROWHEIGHT record.
    default_additional_space_below = None

    ##
    # Visibility of the sheet. 0 = visible, 1 = hidden (can be unhidden
    # by user -- Format/Sheet/Unhide), 2 = "very hidden" (can be unhidden
    # only by VBA macro).
    visibility = 0

    ##
    # A 256-element tuple corresponding to the contents of the GCW record for this sheet.
    # If no such record, treat as all bits zero.
    # Applies to BIFF4-7 only. See docs of Colinfo class for discussion.
    gcw = (0, ) * 256

    def __init__(self, book, position, name, number):
        self.book = book
        self.biff_version = book.biff_version
        self._position = position
        self.logfile = book.logfile
        self.pickleable = book.pickleable
        self.dont_use_array = not(array_array and (CAN_PICKLE_ARRAY or not book.pickleable))
        self.name = name
        self.number = number
        self.verbosity = book.verbosity
        self.formatting_info = book.formatting_info
        self._xf_index_to_xl_type_map = book._xf_index_to_xl_type_map
        self.nrows = 0 # actual, including possibly empty cells
        self.ncols = 0
        self._maxdatarowx = -1 # highest rowx containing a non-empty cell
        self._maxdatacolx = -1 # highest colx containing a non-empty cell
        self._dimnrows = 0 # as per DIMENSIONS record
        self._dimncols = 0
        self._cell_values = []
        self._cell_types = []
        self._cell_xf_indexes = []
        self._need_fix_ragged_rows = 0
        self.defcolwidth = None
        self.standardwidth = None
        self.default_row_height = None
        self.default_row_height_mismatch = 0
        self.default_row_hidden = 0
        self.default_additional_space_above = 0
        self.default_additional_space_below = 0
        self.colinfo_map = {}
        self.rowinfo_map = {}
        self.col_label_ranges = []
        self.row_label_ranges = []
        self.merged_cells = []
        self._xf_index_stats = [0, 0, 0, 0]
        self.visibility = book._sheet_visibility[number] # from BOUNDSHEET record
        for attr, defval in _WINDOW2_options:
            setattr(self, attr, defval)
        self.first_visible_rowx = 0
        self.first_visible_colx = 0
        self.gridline_colour_index = 0x40
        self.gridline_colour_rgb = None # pre-BIFF8
        self.cached_page_break_preview_mag_factor = 0
        self.cached_normal_view_mag_factor = 0
        self._ixfe = None # BIFF2 only
        self._cell_attr_to_xfx = {} # BIFF2.0 only

        #### Don't initialise this here, use class attribute initialisation.
        #### self.gcw = (0, ) * 256 ####

        if self.biff_version >= 80:
            self.utter_max_rows = 65536
        else:
            self.utter_max_rows = 16384
        self.utter_max_cols = 256

    ##
    # Cell object in the given row and column.
    def cell(self, rowx, colx):
        if self.formatting_info:
            xfx = self.cell_xf_index(rowx, colx)
        else:
            xfx = None
        return Cell(
            self._cell_types[rowx][colx],
            self._cell_values[rowx][colx],
            xfx,
            )

    ##
    # Value of the cell in the given row and column.
    def cell_value(self, rowx, colx):
        return self._cell_values[rowx][colx]

    ##
    # Type of the cell in the given row and column.
    # Refer to the documentation of the Cell class.
    def cell_type(self, rowx, colx):
        return self._cell_types[rowx][colx]

    ##
    # XF index of the cell in the given row and column.
    # This is an index into Book.xf_list.
    # <br /> -- New in version 0.6.1
    def cell_xf_index(self, rowx, colx):
        self.req_fmt_info()
        xfx = self._cell_xf_indexes[rowx][colx]
        if xfx > -1:
            self._xf_index_stats[0] += 1
            return xfx
        # Check for a row xf_index
        try:
            xfx = self.rowinfo_map[rowx].xf_index
            if xfx > -1:
                self._xf_index_stats[1] += 1
                return xfx
        except KeyError:
            pass
        # Check for a column xf_index
        try:
            xfx = self.colinfo_map[colx].xf_index
            assert xfx > -1
            self._xf_index_stats[2] += 1
            return xfx
        except KeyError:
            # If all else fails, 15 is used as hardwired global default xf_index.
            self._xf_index_stats[3] += 1
            return 15

    ##
    # Returns a sequence of the Cell objects in the given row.
    def row(self, rowx):
        return [
            self.cell(rowx, colx)
            for colx in xrange(self.ncols)
            ]

    ##
    # Returns a slice of the types
    # of the cells in the given row.
    def row_types(self, rowx, start_colx=0, end_colx=None):
        if end_colx is None:
            return self._cell_types[rowx][start_colx:]
        return self._cell_types[rowx][start_colx:end_colx]

    ##
    # Returns a slice of the values
    # of the cells in the given row.
    def row_values(self, rowx, start_colx=0, end_colx=None):
        if end_colx is None:
            return self._cell_values[rowx][start_colx:]
        return self._cell_values[rowx][start_colx:end_colx]

    ##
    # Returns a slice of the Cell objects in the given row.
    def row_slice(self, rowx, start_colx=0, end_colx=None):
        nc = self.ncols
        if start_colx < 0:
            start_colx += nc
            if start_colx < 0:
                start_colx = 0
        if end_colx is None or end_colx > nc:
            end_colx = nc
        elif end_colx < 0:
            end_colx += nc
        return [
            self.cell(rowx, colx)
            for colx in xrange(start_colx, end_colx)
            ]

    ##
    # Returns a slice of the Cell objects in the given column.
    def col_slice(self, colx, start_rowx=0, end_rowx=None):
        nr = self.nrows
        if start_rowx < 0:
            start_rowx += nr
            if start_rowx < 0:
                start_rowx = 0
        if end_rowx is None or end_rowx > nr:
            end_rowx = nr
        elif end_rowx < 0:
            end_rowx += nr
        return [
            self.cell(rowx, colx)
            for rowx in xrange(start_rowx, end_rowx)
            ]

    ##
    # Returns a slice of the values of the cells in the given column.
    def col_values(self, colx, start_rowx=0, end_rowx=None):
        nr = self.nrows
        if start_rowx < 0:
            start_rowx += nr
            if start_rowx < 0:
                start_rowx = 0
        if end_rowx is None or end_rowx > nr:
            end_rowx = nr
        elif end_rowx < 0:
            end_rowx += nr
        return [
            self._cell_values[rowx][colx]
            for rowx in xrange(start_rowx, end_rowx)
            ]

    ##
    # Returns a slice of the types of the cells in the given column.
    def col_types(self, colx, start_rowx=0, end_rowx=None):
        nr = self.nrows
        if start_rowx < 0:
            start_rowx += nr
            if start_rowx < 0:
                start_rowx = 0
        if end_rowx is None or end_rowx > nr:
            end_rowx = nr
        elif end_rowx < 0:
            end_rowx += nr
        return [
            self._cell_types[rowx][colx]
            for rowx in xrange(start_rowx, end_rowx)
            ]

    ##
    # Returns a sequence of the Cell objects in the given column.
    def col(self, colx):
        return self.col_slice(colx)
    # Above two lines just for the docs. Here's the real McCoy:
    col = col_slice

    # === Following methods are used in building the worksheet.
    # === They are not part of the API.

    def extend_cells(self, nr, nc):
        # print "extend_cells_2", self.nrows, self.ncols, nr, nc
        assert 1 <= nc <= self.utter_max_cols
        assert 1 <= nr <= self.utter_max_rows
        if nr <= self.nrows:
            # New cell is in an existing row, so extend that row (if necessary).
            # Note that nr < self.nrows means that the cell data
            # is not in ascending row order!!
            self._need_fix_ragged_rows = 1
            nrx = nr - 1
            trow = self._cell_types[nrx]
            tlen = len(trow)
            nextra = max(nc, self.ncols) - tlen
            if nextra > 0:
                xce = XL_CELL_EMPTY
                if self.dont_use_array:
                    trow.extend([xce] * nextra)
                    if self.formatting_info:
                        self._cell_xf_indexes[nrx].extend([-1] * nextra)
                else:
                    aa = array_array
                    trow.extend(aa('B', [xce]) * nextra)
                    if self.formatting_info:
                        self._cell_xf_indexes[nrx].extend(aa('h', [-1]) * nextra)
                self._cell_values[nrx].extend([''] * nextra)
        if nc > self.ncols:
            self.ncols = nc
            self._need_fix_ragged_rows = 1
        if nr > self.nrows:
            scta = self._cell_types.append
            scva = self._cell_values.append
            scxa = self._cell_xf_indexes.append
            fmt_info = self.formatting_info
            xce = XL_CELL_EMPTY
            nc = self.ncols
            if self.dont_use_array:
                for _unused in xrange(self.nrows, nr):
                    scta([xce] * nc)
                    scva([''] * nc)
                    if fmt_info:
                        scxa([-1] * nc)
            else:
                aa = array_array
                for _unused in xrange(self.nrows, nr):
                    scta(aa('B', [xce]) * nc)
                    scva([''] * nc)
                    if fmt_info:
                        scxa(aa('h', [-1]) * nc)
            self.nrows = nr

    def fix_ragged_rows(self):
        t0 = time.time()
        ncols = self.ncols
        xce = XL_CELL_EMPTY
        aa = array_array
        s_cell_types = self._cell_types
        s_cell_values = self._cell_values
        s_cell_xf_indexes = self._cell_xf_indexes
        s_dont_use_array = self.dont_use_array
        s_fmt_info = self.formatting_info
        totrowlen = 0
        for rowx in xrange(self.nrows):
            trow = s_cell_types[rowx]
            rlen = len(trow)
            totrowlen += rlen
            nextra = ncols - rlen
            if nextra > 0:
                s_cell_values[rowx][rlen:] = [''] * nextra
                if s_dont_use_array:
                    trow[rlen:] = [xce] * nextra
                    if s_fmt_info:
                        s_cell_xf_indexes[rowx][rlen:] = [-1] * nextra
                else:
                    trow.extend(aa('B', [xce]) * nextra)
                    if s_fmt_info:
                        s_cell_xf_indexes[rowx][rlen:] = aa('h', [-1]) * nextra
        self._fix_ragged_rows_time = time.time() - t0
        if 0 and self.nrows:
            avgrowlen = float(totrowlen) / self.nrows
            print >> self.logfile, \
                "sheet %d: avg row len %.1f; max row len %d" \
                % (self.number, avgrowlen, self.ncols)

    def tidy_dimensions(self):
        if self.verbosity >= 3:
            fprintf(self.logfile,
                "tidy_dimensions: nrows=%d ncols=%d _need_fix_ragged_rows=%d\n",
                self.nrows, self.ncols, self._need_fix_ragged_rows,
                )
        if 1 and self.merged_cells:
            nr = nc = 0
            umaxrows = self.utter_max_rows
            umaxcols = self.utter_max_cols
            for crange in self.merged_cells:
                rlo, rhi, clo, chi = crange
                if not (0 <= rlo < rhi <= umaxrows) \
                or not (0 <= clo < chi <= umaxcols):
                    fprintf(self.logfile,
                        "*** WARNING: sheet #%d (%r), MERGEDCELLS bad range %r\n",
                        self.number, self.name, crange)
                if rhi > nr: nr = rhi
                if chi > nc: nc = chi
            self.extend_cells(nr, nc)
        if self.verbosity >= 1 \
        and (self.nrows != self._dimnrows or self.ncols != self._dimncols):
            fprintf(self.logfile,
                "NOTE *** sheet %d (%r): DIMENSIONS R,C = %d,%d should be %d,%d\n",
                self.number,
                self.name,
                self._dimnrows,
                self._dimncols,
                self.nrows,
                self.ncols,
                )
        if self._need_fix_ragged_rows:
            self.fix_ragged_rows()

    def put_cell(self, rowx, colx, ctype, value, xf_index):
        try:
            self._cell_types[rowx][colx] = ctype
            self._cell_values[rowx][colx] = value
            if self.formatting_info:
                self._cell_xf_indexes[rowx][colx] = xf_index
        except IndexError:
            # print >> self.logfile, "put_cell extending", rowx, colx
            self.extend_cells(rowx+1, colx+1)
            try:
                self._cell_types[rowx][colx] = ctype
                self._cell_values[rowx][colx] = value
                if self.formatting_info:
                    self._cell_xf_indexes[rowx][colx] = xf_index
            except:
                print >> self.logfile, "put_cell", rowx, colx
                raise
        except:
            print >> self.logfile, "put_cell", rowx, colx
            raise

    def put_blank_cell(self, rowx, colx, xf_index):
        # This is used for cells from BLANK and MULBLANK records
        ctype = XL_CELL_BLANK
        value = ''
        try:
            self._cell_types[rowx][colx] = ctype
            self._cell_values[rowx][colx] = value
            self._cell_xf_indexes[rowx][colx] = xf_index
        except IndexError:
            # print >> self.logfile, "put_cell extending", rowx, colx
            self.extend_cells(rowx+1, colx+1)
            try:
                self._cell_types[rowx][colx] = ctype
                self._cell_values[rowx][colx] = value
                self._cell_xf_indexes[rowx][colx] = xf_index
            except:
                print >> self.logfile, "put_cell", rowx, colx
                raise
        except:
            print >> self.logfile, "put_cell", rowx, colx
            raise

    def put_number_cell(self, rowx, colx, value, xf_index):
        ctype = self._xf_index_to_xl_type_map[xf_index]
        try:
            self._cell_types[rowx][colx] = ctype
            self._cell_values[rowx][colx] = value
            if self.formatting_info:
                self._cell_xf_indexes[rowx][colx] = xf_index
        except IndexError:
            # print >> self.logfile, "put_number_cell extending", rowx, colx
            self.extend_cells(rowx+1, colx+1)
            try:
                self._cell_types[rowx][colx] = ctype
                self._cell_values[rowx][colx] = value
                if self.formatting_info:
                    self._cell_xf_indexes[rowx][colx] = xf_index
            except:
                print >> self.logfile, "put_number_cell", rowx, colx
                raise
        except:
            print >> self.logfile, "put_number_cell", rowx, colx
            raise

    # === Methods after this line neither know nor care about how cells are stored.

    def read(self, bk):
        global rc_stats
        DEBUG = 0
        blah = DEBUG or self.verbosity >= 2
        blah_rows = DEBUG or self.verbosity >= 4
        blah_formulas = 1 and blah
        oldpos = bk._position
        bk._position = self._position
        XL_SHRFMLA_ETC_ETC = (
            XL_SHRFMLA, XL_ARRAY, XL_TABLEOP, XL_TABLEOP2,
            XL_ARRAY2, XL_TABLEOP_B2,
            )
        self_put_number_cell = self.put_number_cell
        self_put_cell = self.put_cell
        self_put_blank_cell = self.put_blank_cell
        local_unpack = unpack
        bk_get_record_parts = bk.get_record_parts
        bv = self.biff_version
        fmt_info = self.formatting_info
        eof_found = 0
        while 1:
            # if DEBUG: print "SHEET.READ: about to read from position %d" % bk._position
            rc, data_len, data = bk_get_record_parts()
            # if rc in rc_stats:
            #     rc_stats[rc] += 1
            # else:
            #     rc_stats[rc] = 1
            # if DEBUG: print "SHEET.READ: op 0x%04x, %d bytes %r" % (rc, data_len, data)
            if rc == XL_NUMBER:
                rowx, colx, xf_index, d = local_unpack('<HHHd', data)
                # if xf_index == 0:
                #     fprintf(self.logfile,
                #         "NUMBER: r=%d c=%d xfx=%d %f\n", rowx, colx, xf_index, d)
                self_put_number_cell(rowx, colx, d, xf_index)
            elif rc == XL_LABELSST:
                rowx, colx, xf_index, sstindex = local_unpack('<HHHi', data)
                # print "LABELSST", rowx, colx, sstindex, bk._sharedstrings[sstindex]
                self_put_cell(rowx, colx, XL_CELL_TEXT, bk._sharedstrings[sstindex], xf_index)
            elif rc == XL_LABEL or rc == XL_RSTRING:
                # RSTRING has extra richtext info at the end, but we ignore it.
                rowx, colx, xf_index = local_unpack('<HHH', data[0:6])
                if bv < BIFF_FIRST_UNICODE:
                    strg = unpack_string(data, 6, bk.encoding or bk.derive_encoding, lenlen=2)
                else:
                    strg = unpack_unicode(data, 6, lenlen=2)
                self_put_cell(rowx, colx, XL_CELL_TEXT, strg, xf_index)
            elif rc == XL_RK:
                rowx, colx, xf_index = local_unpack('<HHH', data[:6])
                d = unpack_RK(data[6:10])
                self_put_number_cell(rowx, colx, d, xf_index)
            elif rc == XL_MULRK:
                mulrk_row, mulrk_first = local_unpack('<HH', data[0:4])
                mulrk_last, = local_unpack('<H', data[-2:])
                pos = 4
                for colx in xrange(mulrk_first, mulrk_last+1):
                    xf_index, = local_unpack('<H', data[pos:pos+2])
                    d = unpack_RK(data[pos+2:pos+6])
                    pos += 6
                    self_put_number_cell(mulrk_row, colx, d, xf_index)
            elif rc == XL_ROW:
                # Version 0.6.0a3: ROW records are just not worth using (for memory allocation).
                # Version 0.6.1: now used for formatting info.
                if not fmt_info: continue
                rowx, bits1, bits2 = local_unpack('<H4xH4xi', data[0:16])
                if not(0 <= rowx < self.utter_max_rows):
                    print >> self.logfile, \
                        "*** NOTE: ROW record has row index %d; " \
                        "should have 0 <= rowx < %d -- record ignored!" \
                        % (rowx, self.utter_max_rows)
                    continue
                r = Rowinfo()
                # Using upkbits() is far too slow on a file
                # with 30 sheets each with 10K rows :-(
                #    upkbits(r, bits1, (
                #        ( 0, 0x7FFF, 'height'),
                #        (15, 0x8000, 'has_default_height'),
                #        ))
                #    upkbits(r, bits2, (
                #        ( 0, 0x00000007, 'outline_level'),
                #        ( 4, 0x00000010, 'outline_group_starts_ends'),
                #        ( 5, 0x00000020, 'hidden'),
                #        ( 6, 0x00000040, 'height_mismatch'),
                #        ( 7, 0x00000080, 'has_default_xf_index'),
                #        (16, 0x0FFF0000, 'xf_index'),
                #        (28, 0x10000000, 'additional_space_above'),
                #        (29, 0x20000000, 'additional_space_below'),
                #        ))
                # So:
                r.height = bits1 & 0x7fff
                r.has_default_height = (bits1 >> 15) & 1
                r.outline_level = bits2 & 7
                r.outline_group_starts_ends = (bits2 >> 4) & 1
                r.hidden = (bits2 >> 5) & 1
                r.height_mismatch = (bits2 >> 6) & 1
                r.has_default_xf_index = (bits2 >> 7) & 1
                r.xf_index = (bits2 >> 16) & 0xfff
                r.additional_space_above = (bits2 >> 28) & 1
                r.additional_space_below = (bits2 >> 29) & 1
                if not r.has_default_xf_index:
                    r.xf_index = -1
                self.rowinfo_map[rowx] = r
                if 0 and r.xf_index > -1:
                    fprintf(self.logfile,
                        "**ROW %d %d %d\n",
                        self.number, rowx, r.xf_index)
                if blah_rows:
                    print >> self.logfile, 'ROW', rowx, bits1, bits2
                    r.dump(self.logfile,
                        header="--- sh #%d, rowx=%d ---" % (self.number, rowx))
            elif rc in XL_FORMULA_OPCODES: # 06, 0206, 0406
                # DEBUG = 1
                # if DEBUG: print "FORMULA: rc: 0x%04x data: %r" % (rc, data)
                if bv >= 50:
                    rowx, colx, xf_index, result_str, flags = local_unpack('<HHH8sH', data[0:16])
                    lenlen = 2
                    tkarr_offset = 20
                elif bv >= 30:
                    rowx, colx, xf_index, result_str, flags = local_unpack('<HHH8sH', data[0:16])
                    lenlen = 2
                    tkarr_offset = 16
                else: # BIFF2
                    rowx, colx, cell_attr,  result_str, flags = local_unpack('<HH3s8sB', data[0:16])
                    xf_index =  self.fixed_BIFF2_xfindex(cell_attr, rowx, colx)
                    lenlen = 1
                    tkarr_offset = 16
                if blah_formulas: # testing formula dumper
                    #### XXXX FIXME
                    fprintf(self.logfile, "FORMULA: rowx=%d colx=%d\n", rowx, colx)
                    fmlalen = local_unpack("<H", data[20:22])[0]
                    decompile_formula(bk, data[22:], fmlalen,
                        reldelta=0, browx=rowx, bcolx=colx, blah=1)
                if result_str[6:8] == "\xFF\xFF":
                    if result_str[0]  == '\x00':
                        # need to read next record (STRING)
                        gotstring = 0
                        # if flags & 8:
                        if 1: # "flags & 8" applies only to SHRFMLA
                            # actually there's an optional SHRFMLA or ARRAY etc record to skip over
                            rc2, data2_len, data2 = bk.get_record_parts()
                            if rc2 == XL_STRING or rc2 == XL_STRING_B2:
                                gotstring = 1
                            elif rc2 == XL_ARRAY:
                                row1x, rownx, col1x, colnx, array_flags, tokslen = \
                                    local_unpack("<HHBBBxxxxxH", data2[:14])
                                if blah_formulas:
                                    fprintf(self.logfile, "ARRAY: %d %d %d %d %d\n",
                                        row1x, rownx, col1x, colnx, array_flags)
                                    dump_formula(bk, data2[14:], tokslen, bv, reldelta=0, blah=1)
                            elif rc2 == XL_SHRFMLA:
                                row1x, rownx, col1x, colnx, nfmlas, tokslen = \
                                    local_unpack("<HHBBxBH", data2[:10])
                                if blah_formulas:
                                    fprintf(self.logfile, "SHRFMLA (sub): %d %d %d %d %d\n",
                                        row1x, rownx, col1x, colnx, nfmlas)
                                    decompile_formula(bk, data2[10:], tokslen, reldelta=1, blah=1)
                            elif rc2 not in XL_SHRFMLA_ETC_ETC:
                                raise XLRDError(
                                    "Expected SHRFMLA, ARRAY, TABLEOP* or STRING record; found 0x%04x" % rc2)
                            # if DEBUG: print "gotstring:", gotstring
                        # now for the STRING record
                        if not gotstring:
                            rc2, _unused_len, data2 = bk.get_record_parts()
                            if rc2 not in (XL_STRING, XL_STRING_B2):
                                raise XLRDError("Expected STRING record; found 0x%04x" % rc2)
                        # if DEBUG: print "STRING: data=%r BIFF=%d cp=%d" % (data2, self.biff_version, bk.encoding)
                        if self.biff_version < BIFF_FIRST_UNICODE:
                            strg = unpack_string(data2, 0, bk.encoding or bk.derive_encoding, lenlen=1 + int(bv > 20))
                        else:
                            strg = unpack_unicode(data2, 0, lenlen=2)
                        self.put_cell(rowx, colx, XL_CELL_TEXT, strg, xf_index)
                        # if DEBUG: print "FORMULA strg %r" % strg
                    elif result_str[0] == '\x01':
                        # boolean formula result
                        value = ord(result_str[2])
                        self.put_cell(rowx, colx, XL_CELL_BOOLEAN, value, xf_index)
                    elif result_str[0] == '\x02':
                        # Error in cell
                        value = ord(result_str[2])
                        self.put_cell(rowx, colx, XL_CELL_ERROR, value, xf_index)
                    elif result_str[0] == '\x03':
                        # empty ... i.e. empty (zero-length) string, NOT an empty cell.
                        self.put_cell(rowx, colx, XL_CELL_TEXT, u"", xf_index)
                    else:
                        raise XLRDError("unexpected special case (0x%02x) in FORMULA" % ord(result_str[0]))
                else:
                    # it is a number
                    d = local_unpack('<d', result_str)[0]
                    self_put_number_cell(rowx, colx, d, xf_index)
            elif rc == XL_BOOLERR:
                rowx, colx, xf_index, value, is_err = local_unpack('<HHHBB', data[:8])
                # Note OOo Calc 2.0 writes 9-byte BOOLERR records.
                # OOo docs say 8. Excel writes 8.
                cellty = (XL_CELL_BOOLEAN, XL_CELL_ERROR)[is_err]
                # if DEBUG: print "XL_BOOLERR", rowx, colx, xf_index, value, is_err
                self.put_cell(rowx, colx, cellty, value, xf_index)
            elif rc == XL_COLINFO:
                if not fmt_info: continue
                c = Colinfo()
                first_colx, last_colx, c.width, c.xf_index, flags \
                    = local_unpack("<HHHHH", data[:10])
                #### Colinfo.width is denominated in 256ths of a character,
                #### *not* in characters.
                if not(0 <= first_colx <= last_colx <= 256):
                    # Note: 256 instead of 255 is a common mistake.
                    # We silently ignore the non-existing 257th column in that case.
                    print >> self.logfile, \
                        "*** NOTE: COLINFO record has first col index %d, last %d; " \
                        "should have 0 <= first <= last <= 255 -- record ignored!" \
                        % (first_colx, last_colx)
                    del c
                    continue
                upkbits(c, flags, (
                    ( 0, 0x0001, 'hidden'),
                    ( 1, 0x0002, 'bit1_flag'),
                    # *ALL* colinfos created by Excel in "default" cases are 0x0002!!
                    # Maybe it's "locked" by analogy with XFProtection data.
                    ( 8, 0x0700, 'outline_level'),
                    (12, 0x1000, 'collapsed'),
                    ))
                for colx in xrange(first_colx, last_colx+1):
                    if colx > 255: break # Excel does 0 to 256 inclusive
                    self.colinfo_map[colx] = c
                    if 0:
                        fprintf(self.logfile,
                            "**COL %d %d %d\n",
                            self.number, colx, c.xf_index)
                if blah:
                    fprintf(
                        self.logfile,
                        "COLINFO sheet #%d cols %d-%d: wid=%d xf_index=%d flags=0x%04x\n",
                        self.number, first_colx, last_colx, c.width, c.xf_index, flags,
                        )
                    c.dump(self.logfile, header='===')
            elif rc == XL_DEFCOLWIDTH:
                self.defcolwidth, = local_unpack("<H", data[:2])
                if 0: print >> self.logfile, 'DEFCOLWIDTH', self.defcolwidth
            elif rc == XL_STANDARDWIDTH:
                if data_len != 2:
                    print >> self.logfile, '*** ERROR *** STANDARDWIDTH', data_len, repr(data)
                self.standardwidth, = local_unpack("<H", data[:2])
                if 0: print >> self.logfile, 'STANDARDWIDTH', self.standardwidth
            elif rc == XL_GCW:
                if not fmt_info: continue # useless w/o COLINFO
                assert data_len == 34
                assert data[0:2] == "\x20\x00"
                iguff = unpack("<8i", data[2:34])
                gcw = []
                for bits in iguff:
                    for j in xrange(32):
                        gcw.append(bits & 1)
                        bits >>= 1
                self.gcw = tuple(gcw)
                if 0:
                    showgcw = "".join(map(lambda x: "F "[x], gcw)).rstrip().replace(' ', '.')
                    print "GCW:", showgcw
            elif rc == XL_BLANK:
                if not fmt_info: continue
                rowx, colx, xf_index = local_unpack('<HHH', data[:6])
                if 0: print >> self.logfile, "BLANK", rowx, colx, xf_index
                self_put_blank_cell(rowx, colx, xf_index)
            elif rc == XL_MULBLANK: # 00BE
                if not fmt_info: continue
                mul_row, mul_first = local_unpack('<HH', data[0:4])
                mul_last, = local_unpack('<H', data[-2:])
                if 0:
                    print >> self.logfile, "MULBLANK", mul_row, mul_first, mul_last
                pos = 4
                for colx in xrange(mul_first, mul_last+1):
                    xf_index, = local_unpack('<H', data[pos:pos+2])
                    pos += 2
                    self_put_blank_cell(mul_row, colx, xf_index)
            elif rc == XL_DIMENSION or rc == XL_DIMENSION2:
                # if data_len == 10:
                # Was crashing on BIFF 4.0 file w/o the two trailing unused bytes.
                # Reported by Ralph Heimburger.
                if bv < 80:
                    dim_tuple = local_unpack('<HxxH', data[2:8])
                else:
                    dim_tuple = local_unpack('<ixxH', data[4:12])
                self.nrows, self.ncols = 0, 0
                self._dimnrows, self._dimncols = dim_tuple
                if not self.book._xf_epilogue_done:
                    # Needed for bv <= 40
                    self.book.xf_epilogue()
                if blah:
                    fprintf(self.logfile,
                        "sheet %d(%r) DIMENSIONS: ncols=%d nrows=%d\n",
                        self.number, self.name, self._dimncols, self._dimnrows
                        )
            elif rc == XL_EOF:
                DEBUG = 0
                if DEBUG: print >> self.logfile, "SHEET.READ: EOF"
                eof_found = 1
                break
            elif rc == XL_OBJ:
                # handle SHEET-level objects; note there's a separate Book.handle_obj
                self.handle_obj(data)
            elif rc == XL_MSO_DRAWING:
                self.handle_msodrawingetc(rc, data_len, data)
            elif rc == XL_TXO:
                self.handle_txo(data)
            elif rc == XL_NOTE:
                self.handle_note(data)
            elif rc == XL_FEAT11:
                self.handle_feat11(data)
            elif rc in bofcodes: ##### EMBEDDED BOF #####
                version, boftype = local_unpack('<HH', data[0:4])
                if boftype != 0x20: # embedded chart
                    print >> self.logfile, \
                        "*** Unexpected embedded BOF (0x%04x) at offset %d: version=0x%04x type=0x%04x" \
                        % (rc, bk._position - data_len - 4, version, boftype)
                while 1:
                    code, data_len, data = bk.get_record_parts()
                    if code == XL_EOF:
                        break
                if DEBUG: print >> self.logfile, "---> found EOF"
            elif rc == XL_COUNTRY:
                bk.handle_country(data)
            elif rc == XL_LABELRANGES:
                pos = 0
                pos = unpack_cell_range_address_list_update_pos(
                        self.row_label_ranges, data, pos, bv, addr_size=8,
                        )
                pos = unpack_cell_range_address_list_update_pos(
                        self.col_label_ranges, data, pos, bv, addr_size=8,
                        )
                assert pos == data_len
            elif rc == XL_ARRAY:
                row1x, rownx, col1x, colnx, array_flags, tokslen = \
                    local_unpack("<HHBBBxxxxxH", data[:14])
                if blah_formulas:
                    print "ARRAY:", row1x, rownx, col1x, colnx, array_flags
                    dump_formula(bk, data[14:], tokslen, bv, reldelta=0, blah=1)
            elif rc == XL_SHRFMLA:
                row1x, rownx, col1x, colnx, nfmlas, tokslen = \
                    local_unpack("<HHBBxBH", data[:10])
                if blah_formulas:
                    print "SHRFMLA (main):", row1x, rownx, col1x, colnx, nfmlas
                    decompile_formula(bk, data[10:], tokslen, reldelta=0, blah=1)
            elif rc == XL_CONDFMT:
                if not fmt_info: continue
                assert bv >= 80
                num_CFs, needs_recalc, browx1, browx2, bcolx1, bcolx2 = \
                    unpack("<6H", data[0:12])
                if self.verbosity >= 1:
                    fprintf(self.logfile,
                        "\n*** WARNING: Ignoring CONDFMT (conditional formatting) record\n" \
                        "*** in Sheet %d (%r).\n" \
                        "*** %d CF record(s); needs_recalc_or_redraw = %d\n" \
                        "*** Bounding box is %s\n",
                        self.number, self.name, num_CFs, needs_recalc,
                        rangename2d(browx1, browx2+1, bcolx1, bcolx2+1),
                        )
                olist = [] # updated by the function
                pos = unpack_cell_range_address_list_update_pos(
                    olist, data, 12, bv, addr_size=8)
                # print >> self.logfile, repr(result), len(result)
                if self.verbosity >= 1:
                    fprintf(self.logfile,
                        "*** %d individual range(s):\n" \
                        "*** %s\n",
                        len(olist),
                        ", ".join([rangename2d(*coords) for coords in olist]),
                        )
            elif rc == XL_CF:
                if not fmt_info: continue
                cf_type, cmp_op, sz1, sz2, flags = unpack("<BBHHi", data[0:10])
                font_block = (flags >> 26) & 1
                bord_block = (flags >> 28) & 1
                patt_block = (flags >> 29) & 1
                if self.verbosity >= 1:
                    fprintf(self.logfile,
                        "\n*** WARNING: Ignoring CF (conditional formatting) sub-record.\n" \
                        "*** cf_type=%d, cmp_op=%d, sz1=%d, sz2=%d, flags=0x%08x\n" \
                        "*** optional data blocks: font=%d, border=%d, pattern=%d\n",
                        cf_type, cmp_op, sz1, sz2, flags,
                        font_block, bord_block, patt_block,
                        )
                # hex_char_dump(data, 0, data_len)
                pos = 12
                if font_block:
                    (font_height, font_options, weight, escapement, underline,
                    font_colour_index, two_bits, font_esc, font_underl) = \
                    unpack("<64x i i H H B 3x i 4x i i i 18x", data[pos:pos+118])
                    font_style = (two_bits > 1) & 1
                    posture = (font_options > 1) & 1
                    font_canc = (two_bits > 7) & 1
                    cancellation = (font_options > 7) & 1
                    if self.verbosity >= 1:
                        fprintf(self.logfile,
                            "*** Font info: height=%d, weight=%d, escapement=%d,\n" \
                            "*** underline=%d, colour_index=%d, esc=%d, underl=%d,\n" \
                            "*** style=%d, posture=%d, canc=%d, cancellation=%d\n",
                            font_height, weight, escapement, underline,
                            font_colour_index, font_esc, font_underl,
                            font_style, posture, font_canc, cancellation,
                            )
                    pos += 118
                if bord_block:
                    pos += 8
                if patt_block:
                    pos += 4
                fmla1 = data[pos:pos+sz1]
                pos += sz1
                if blah and sz1:
                    fprintf(self.logfile,
                        "*** formula 1:\n",
                        )
                    dump_formula(bk, fmla1, sz1, bv, reldelta=0, blah=1)
                fmla2 = data[pos:pos+sz2]
                pos += sz2
                assert pos == data_len
                if blah and sz2:
                    fprintf(self.logfile,
                        "*** formula 2:\n",
                        )
                    dump_formula(bk, fmla2, sz2, bv, reldelta=0, blah=1)
            elif rc == XL_DEFAULTROWHEIGHT:
                if data_len == 4:
                    bits, self.default_row_height = unpack("<HH", data[:4])
                elif data_len == 2:
                    self.default_row_height, = unpack("<H", data)
                    bits = 0
                    fprintf(self.logfile,
                        "*** WARNING: DEFAULTROWHEIGHT record len is 2, " \
                        "should be 4; assuming BIFF2 format\n")
                else:
                    bits = 0
                    fprintf(self.logfile,
                        "*** WARNING: DEFAULTROWHEIGHT record len is %d, " \
                        "should be 4; ignoring this record\n",
                        data_len)
                self.default_row_height_mismatch = bits & 1
                self.default_row_hidden = (bits >> 1) & 1
                self.default_additional_space_above = (bits >> 2) & 1
                self.default_additional_space_below = (bits >> 3) & 1
            elif rc == XL_MERGEDCELLS:
                if not fmt_info: continue
                pos = unpack_cell_range_address_list_update_pos(
                    self.merged_cells, data, 0, bv, addr_size=8)
                if blah:
                    fprintf(self.logfile,
                        "MERGEDCELLS: %d ranges\n", int_floor_div(pos - 2, 8))
                assert pos == data_len, \
                    "MERGEDCELLS: pos=%d data_len=%d" % (pos, data_len)
            elif rc == XL_WINDOW2:
                if bv >= 80:
                    (options,
                    self.first_visible_rowx, self.first_visible_colx,
                    self.gridline_colour_index,
                    self.cached_page_break_preview_mag_factor,
                    self.cached_normal_view_mag_factor
                    ) = unpack("<HHHHxxHH", data[:14])
                else: # BIFF3-7
                    (options,
                    self.first_visible_rowx, self.first_visible_colx,
                    ) = unpack("<HHH", data[:6])
                    self.gridline_colour_rgb = unpack("<BBB", data[6:9])
                    self.gridline_colour_index = \
                        nearest_colour_index(
                            self.book.colour_map,
                            self.gridline_colour_rgb,
                            debug=0)
                    self.cached_page_break_preview_mag_factor = 0 # default (60%)
                    self.cached_normal_view_mag_factor = 0 # default (100%)
                # options -- Bit, Mask, Contents:
                # 0 0001H 0 = Show formula results 1 = Show formulas
                # 1 0002H 0 = Do not show grid lines 1 = Show grid lines
                # 2 0004H 0 = Do not show sheet headers 1 = Show sheet headers
                # 3 0008H 0 = Panes are not frozen 1 = Panes are frozen (freeze)
                # 4 0010H 0 = Show zero values as empty cells 1 = Show zero values
                # 5 0020H 0 = Manual grid line colour 1 = Automatic grid line colour
                # 6 0040H 0 = Columns from left to right 1 = Columns from right to left
                # 7 0080H 0 = Do not show outline symbols 1 = Show outline symbols
                # 8 0100H 0 = Keep splits if pane freeze is removed 1 = Remove splits if pane freeze is removed
                # 9 0200H 0 = Sheet not selected 1 = Sheet selected (BIFF5-BIFF8)
                # 10 0400H 0 = Sheet not visible 1 = Sheet visible (BIFF5-BIFF8)
                # 11 0800H 0 = Show in normal view 1 = Show in page break preview (BIFF8)
                # The freeze flag specifies, if a following PANE record (6.71) describes unfrozen or frozen panes.
                for attr, _unused_defval in _WINDOW2_options:
                    setattr(self, attr, options & 1)
                    options >>= 1
                # print "WINDOW2: visible=%d selected=%d" \
                #     % (self.sheet_visible, self.sheet_selected)
            #### all of the following are for BIFF <= 4W
            elif bv <= 45:
                if rc == XL_FORMAT or rc == XL_FORMAT2:
                    bk.handle_format(data, rc)
                elif rc == XL_FONT or rc == XL_FONT_B3B4:
                    bk.handle_font(data)
                elif rc == XL_STYLE:
                    if not self.book._xf_epilogue_done:
                        self.book.xf_epilogue()
                    bk.handle_style(data)
                elif rc == XL_PALETTE:
                    bk.handle_palette(data)
                elif rc == XL_BUILTINFMTCOUNT:
                    bk.handle_builtinfmtcount(data)
                elif rc == XL_XF4 or rc == XL_XF3 or rc == XL_XF2: #### N.B. not XL_XF
                    bk.handle_xf(data)
                elif rc == XL_DATEMODE:
                    bk.handle_datemode(data)
                elif rc == XL_CODEPAGE:
                    bk.handle_codepage(data)
                elif rc == XL_FILEPASS:
                    bk.handle_filepass(data)
                elif rc == XL_WRITEACCESS:
                    bk.handle_writeaccess(data)
                elif rc == XL_IXFE:
                    self._ixfe = local_unpack('<H', data)[0]
                elif rc == XL_NUMBER_B2:
                    rowx, colx, cell_attr, d = local_unpack('<HH3sd', data)
                    self_put_number_cell(rowx, colx, d, self.fixed_BIFF2_xfindex(cell_attr, rowx, colx))
                elif rc == XL_INTEGER:
                    rowx, colx, cell_attr, d = local_unpack('<HH3sH', data)
                    self_put_number_cell(rowx, colx, float(d), self.fixed_BIFF2_xfindex(cell_attr, rowx, colx))
                elif rc == XL_LABEL_B2:
                    rowx, colx, cell_attr = local_unpack('<HH3s', data[0:7])
                    strg = unpack_string(data, 7, bk.encoding or bk.derive_encoding(), lenlen=1)
                    self_put_cell(rowx, colx, XL_CELL_TEXT, strg, self.fixed_BIFF2_xfindex(cell_attr, rowx, colx))
                elif rc == XL_BOOLERR_B2:
                    rowx, colx, cell_attr, value, is_err = local_unpack('<HH3sBB', data)
                    cellty = (XL_CELL_BOOLEAN, XL_CELL_ERROR)[is_err]
                    # if DEBUG: print "XL_BOOLERR_B2", rowx, colx, cell_attr, value, is_err
                    self.put_cell(rowx, colx, cellty, value, self.fixed_BIFF2_xfindex(cell_attr, rowx, colx))
                elif rc == XL_BLANK_B2:
                    if not fmt_info: continue
                    rowx, colx, cell_attr = local_unpack('<HH3s', data[:7])
                    self_put_blank_cell(rowx, colx, self.fixed_BIFF2_xfindex(cell_attr, rowx, colx))
                elif rc == XL_EFONT:
                    bk.handle_efont(data)
                elif rc == XL_ROW_B2:
                    if not fmt_info: continue
                    rowx, bits1, has_defaults = local_unpack('<H4xH2xB', data[0:11])
                    if not(0 <= rowx < self.utter_max_rows):
                        print >> self.logfile, \
                            "*** NOTE: ROW_B2 record has row index %d; " \
                            "should have 0 <= rowx < %d -- record ignored!" \
                            % (rowx, self.utter_max_rows)
                        continue
                    r = Rowinfo()
                    r.height = bits1 & 0x7fff
                    r.has_default_height = (bits1 >> 15) & 1
                    r.outline_level = 0
                    r.outline_group_starts_ends = 0
                    r.hidden = 0
                    r.height_mismatch = 0
                    r.has_default_xf_index = has_defaults & 1
                    r.additional_space_above = 0
                    r.additional_space_below = 0
                    if not r.has_default_xf_index:
                        r.xf_index = -1
                    elif data_len == 18:
                        # Seems the XF index in the cell_attr is dodgy
                         xfx = local_unpack('<H', data[16:18])[0]
                         r.xf_index = self.fixed_BIFF2_xfindex(cell_attr=None, rowx=rowx, colx=-1, true_xfx=xfx)
                    else:
                        cell_attr = data[13:16]
                        r.xf_index = self.fixed_BIFF2_xfindex(cell_attr, rowx, colx=-1)
                    self.rowinfo_map[rowx] = r
                    if 0 and r.xf_index > -1:
                        fprintf(self.logfile,
                            "**ROW %d %d %d\n",
                            self.number, rowx, r.xf_index)
                    if blah_rows:
                        print >> self.logfile, 'ROW_B2', rowx, bits1, has_defaults
                        r.dump(self.logfile,
                            header="--- sh #%d, rowx=%d ---" % (self.number, rowx))
                elif rc == XL_COLWIDTH: # BIFF2 only
                    if not fmt_info: continue
                    first_colx, last_colx, width\
                        = local_unpack("<BBH", data[:4])
                    if not(first_colx <= last_colx):
                        print >> self.logfile, \
                            "*** NOTE: COLWIDTH record has first col index %d, last %d; " \
                            "should have first <= last -- record ignored!" \
                            % (first_colx, last_colx)
                        continue
                    for colx in xrange(first_colx, last_colx+1):
                        if self.colinfo_map.has_key(colx):
                            c = self.colinfo_map[colx]
                        else:
                            c = Colinfo()
                            self.colinfo_map[colx] = c
                        c.width = width
                    if blah:
                        fprintf(
                            self.logfile,
                            "COLWIDTH sheet #%d cols %d-%d: wid=%d\n",
                            self.number, first_colx, last_colx, width
                            )
                elif rc == XL_COLUMNDEFAULT: # BIFF2 only
                    if not fmt_info: continue
                    first_colx, last_colx = local_unpack("<HH", data[:4])
                    #### Warning OOo docs wrong; first_colx <= colx < last_colx
                    if blah:
                        fprintf(
                            self.logfile,
                            "COLUMNDEFAULT sheet #%d cols in range(%d, %d)\n",
                            self.number, first_colx, last_colx
                            )
                    if not(0 <= first_colx < last_colx <= 256):
                        print >> self.logfile, \
                            "*** NOTE: COLUMNDEFAULT record has first col index %d, last %d; " \
                            "should have 0 <= first < last <= 256" \
                            % (first_colx, last_colx)
                        last_colx = min(last_colx, 256)
                    for colx in xrange(first_colx, last_colx):
                        offset = 4 + 3 * (colx - first_colx)
                        cell_attr = data[offset:offset+3]
                        xf_index = self.fixed_BIFF2_xfindex(cell_attr, rowx=-1, colx=colx)
                        if self.colinfo_map.has_key(colx):
                            c = self.colinfo_map[colx]
                        else:
                            c = Colinfo()
                            self.colinfo_map[colx] = c
                        c.xf_index = xf_index
            else:
                # if DEBUG: print "SHEET.READ: Unhandled record type %02x %d bytes %r" % (rc, data_len, data)
                pass
        if not eof_found:
            raise XLRDError("Sheet %d (%r) missing EOF record" \
                % (self.number, self.name))
        self.tidy_dimensions()
        bk._position = oldpos
        return 1

    def fixed_BIFF2_xfindex(self, cell_attr, rowx, colx, true_xfx=None):
        DEBUG = 0
        blah = DEBUG or self.verbosity >= 2
        if self.biff_version == 21:
            if self._xf_index_to_xl_type_map:
                if true_xfx is not None:
                    xfx = true_xfx
                else:
                    xfx = ord(cell_attr[0]) & 0x3F
                if xfx == 0x3F:
                    if self._ixfe is None:
                        raise XLRDError("BIFF2 cell record has XF index 63 but no preceding IXFE record.")
                    xfx = self._ixfe
                    # OOo docs are capable of interpretation that each
                    # cell record is preceded immediately by its own IXFE record.
                    # Empirical evidence is that (sensibly) an IXFE record applies to all
                    # following cell records until another IXFE comes along.
                return xfx
            # Have either Excel 2.0, or broken 2.1 w/o XF records -- same effect.
            self.biff_version = self.book.biff_version = 20
        #### check that XF slot in cell_attr is zero
        xfx_slot = ord(cell_attr[0]) & 0x3F
        assert xfx_slot == 0
        xfx = self._cell_attr_to_xfx.get(cell_attr)
        if xfx is not None:
            return xfx
        if blah:
            fprintf(self.logfile, "New cell_attr %r at (%r, %r)\n", cell_attr, rowx, colx)
        book = self.book
        xf = self.fake_XF_from_BIFF20_cell_attr(cell_attr)
        xfx = len(book.xf_list)
        xf.xf_index = xfx
        book.xf_list.append(xf)
        if blah:
            xf.dump(self.logfile, header="=== Faked XF %d ===" % xfx, footer="======")
        if not book.format_map.has_key(xf.format_key):
            msg = "ERROR *** XF[%d] unknown format key (%d, 0x%04x)\n"
            fprintf(self.logfile, msg,
                    xf.xf_index, xf.format_key, xf.format_key)
            fmt = Format(xf.format_key, FUN, u"General")
            book.format_map[xf.format_key] = fmt
            while len(book.format_list) <= xf.format_key:
                book.format_list.append(fmt)
        cellty_from_fmtty = {
            FNU: XL_CELL_NUMBER,
            FUN: XL_CELL_NUMBER,
            FGE: XL_CELL_NUMBER,
            FDT: XL_CELL_DATE,
            FTX: XL_CELL_NUMBER, # Yes, a number can be formatted as text.
            }
        fmt = book.format_map[xf.format_key]
        cellty = cellty_from_fmtty[fmt.type]
        self._xf_index_to_xl_type_map[xf.xf_index] = cellty
        self._cell_attr_to_xfx[cell_attr] = xfx
        return xfx

    def fake_XF_from_BIFF20_cell_attr(self, cell_attr):
        from formatting import XF, XFAlignment, XFBorder, XFBackground, XFProtection
        xf = XF()
        xf.alignment = XFAlignment()
        xf.alignment.indent_level = 0
        xf.alignment.shrink_to_fit = 0
        xf.alignment.text_direction = 0
        xf.border = XFBorder()
        xf.border.diag_up = 0
        xf.border.diag_down = 0
        xf.border.diag_colour_index = 0
        xf.border.diag_line_style = 0 # no line
        xf.background = XFBackground()
        xf.protection = XFProtection()
        (prot_bits, font_and_format, halign_etc) = unpack('<BBB', cell_attr)
        xf.format_key = font_and_format & 0x3F
        xf.font_index = (font_and_format & 0xC0) >> 6
        upkbits(xf.protection, prot_bits, (
            (6, 0x40, 'cell_locked'),
            (7, 0x80, 'formula_hidden'),
            ))
        xf.alignment.hor_align = halign_etc & 0x07
        for mask, side in ((0x08, 'left'), (0x10, 'right'), (0x20, 'top'), (0x40, 'bottom')):
            if halign_etc & mask:
                colour_index, line_style = 8, 1 # black, thin
            else:
                colour_index, line_style = 0, 0 # none, none
            setattr(xf.border, side + '_colour_index', colour_index)
            setattr(xf.border, side + '_line_style', line_style)
        bg = xf.background
        if halign_etc & 0x80:
            bg.fill_pattern = 17
        else:
            bg.fill_pattern = 0
        bg.background_colour_index = 9 # white
        bg.pattern_colour_index = 8 # black
        xf.parent_style_index = 0 # ???????????
        xf.alignment.vert_align = 2 # bottom
        xf.alignment.rotation = 0
        for attr_stem in \
            "format font alignment border background protection".split():
            attr = "_" + attr_stem + "_flag"
            setattr(xf, attr, 1)
        return xf

    def req_fmt_info(self):
        if not self.formatting_info:
            raise XLRDError("Feature requires open_workbook(..., formatting_info=True)")

    ##
    # Determine column display width.
    # <br /> -- New in version 0.6.1
    # <br />
    # @param colx Index of the queried column, range 0 to 255.
    # Note that it is possible to find out the width that will be used to display
    # columns with no cell information e.g. column IV (colx=255).
    # @return The column width that will be used for displaying
    # the given column by Excel, in units of 1/256th of the width of a
    # standard character (the digit zero in the first font).

    def computed_column_width(self, colx):
        self.req_fmt_info()
        if self.biff_version >= 80:
            colinfo = self.colinfo_map.get(colx, None)
            if colinfo is not None:
                return colinfo.width
            if self.standardwidth is not None:
                return self.standardwidth
        elif self.biff_version >= 40:
            if self.gcw[colx]:
                if self.standardwidth is not None:
                    return self.standardwidth
            else:
                colinfo = self.colinfo_map.get(colx, None)
                if colinfo is not None:
                    return colinfo.width
        elif self.biff_version == 30:
            colinfo = self.colinfo_map.get(colx, None)
            if colinfo is not None:
                return colinfo.width
        # All roads lead to Rome and the DEFCOLWIDTH ...
        if self.defcolwidth is not None:
            return self.defcolwidth * 256
        return 8 * 256 # 8 is what Excel puts in a DEFCOLWIDTH record

    def handle_msodrawingetc(self, recid, data_len, data):
        if not OBJ_MSO_DEBUG:
            return
        DEBUG = 1
        if self.biff_version < 80:
            return
        o = MSODrawing()
        pos = 0
        while pos < data_len:
            tmp, fbt, cb = unpack('<HHI', data[pos:pos+8])
            ver = tmp & 0xF
            inst = (tmp >> 4) & 0xFFF
            if ver == 0xF:
                ndb = 0 # container
            else:
                ndb = cb
            if DEBUG:
                hex_char_dump(data, pos, ndb + 8, base=0, fout=self.logfile)
                fprintf(self.logfile,
                    "fbt:0x%04X  inst:%d  ver:0x%X  cb:%d (0x%04X)\n",
                    fbt, inst, ver, cb, cb)
            if fbt == 0xF010: # Client Anchor
                assert ndb == 18
                (o.anchor_unk,
                o.anchor_colx_lo, o.anchor_rowx_lo,
                o.anchor_colx_hi, o.anchor_rowx_hi) = unpack('<Hiiii', data[pos+8:pos+8+ndb])
            elif fbt == 0xF011: # Client Data
                # must be followed by an OBJ record
                assert cb == 0
                assert pos + 8 == data_len
            else:
                pass
            pos += ndb + 8
        else:
            # didn't break out of while loop
            assert pos == data_len
        if DEBUG:
            o.dump(self.logfile, header="=== MSODrawing ===", footer= " ")


    def handle_obj(self, data):
        if not OBJ_MSO_DEBUG:
            return
        DEBUG = 1
        if self.biff_version < 80:
            return
        o = MSObj()
        data_len = len(data)
        pos = 0
        if DEBUG:
            fprintf(self.logfile, "... OBJ record ...\n")
        while pos < data_len:
            ft, cb = unpack('<HH', data[pos:pos+4])
            if DEBUG:
                hex_char_dump(data, pos, cb, base=0, fout=self.logfile)
            if ft == 0x15: # ftCmo ... s/b first
                assert pos == 0
                o.type, o.id, option_flags = unpack('<HHH', data[pos+4:pos+10])
                upkbits(o, option_flags, (
                    ( 0, 0x0001, 'locked'),
                    ( 4, 0x0010, 'printable'),
                    ( 8, 0x0100, 'autofilter'), # not documented in Excel 97 dev kit
                    ( 9, 0x0200, 'scrollbar_flag'), # not documented in Excel 97 dev kit
                    (13, 0x2000, 'autofill'),
                    (14, 0x4000, 'autoline'),
                    ))
            elif ft == 0x00:
                assert cb == 0
                assert pos + 4 == data_len
            elif ft == 0x0C: # Scrollbar
                values = unpack('<5H', data[pos+8:pos+18])
                for value, tag in zip(values, ('value', 'min', 'max', 'inc', 'page')):
                    setattr(o, 'scrollbar_' + tag, value)
            elif ft == 0x0D: # "Notes structure" [used for cell comments]
                pass ############## not documented in Excel 97 dev kit
            elif ft == 0x13: # list box data
                if o.autofilter: # non standard exit. NOT documented
                    break
            else:
                pass
            pos += cb + 4
        else:
            # didn't break out of while loop
            assert pos == data_len
        if DEBUG:
            o.dump(self.logfile, header="=== MSOBj ===", footer= " ")

    def handle_note(self, data):
        if not OBJ_MSO_DEBUG:
            return
        DEBUG = 1
        if self.biff_version < 80:
            return
        if DEBUG:
            fprintf(self.logfile, '... NOTE record ...\n')
            hex_char_dump(data, 0, len(data), base=0, fout=self.logfile)
        o = MSNote()
        data_len = len(data)
        o.rowx, o.colx, option_flags, o.object_id = unpack('<4H', data[:8])
        o.show = (option_flags >> 1) & 1
        # Docs say NULL [sic] bytes padding between string count and string data
        # to ensure that string is word-aligned. Appears to be nonsense.
        # There also seems to be a random(?) byte after the string (not counted in the
        # string length.
        o.original_author, endpos = unpack_unicode_update_pos(data, 8, lenlen=2)
        assert endpos == data_len - 1
        o.last_byte = data[-1]
        if DEBUG:
            o.dump(self.logfile, header="=== MSNote ===", footer= " ")

    def handle_txo(self, data):
        if not OBJ_MSO_DEBUG:
            return
        DEBUG = 1
        if self.biff_version < 80:
            return
        o = MSTxo()
        data_len = len(data)
        option_flags, o.rot, cchText, cbRuns = unpack('<HH6xHH4x', data)
        upkbits(o, option_flags, (
            (3, 0x000E, 'horz_align'),
            (6, 0x0070, 'vert_align'),
            (9, 0x0200, 'lock_text'),
            ))
        rc2, data2_len, data2 = self.book.get_record_parts()
        assert rc2 == XL_CONTINUE
        o.text, endpos = unpack_unicode_update_pos(data2, 0, known_len=cchText)
        assert endpos == data2_len
        rc3, data3_len, data3 = self.book.get_record_parts()
        assert rc3 == XL_CONTINUE
        # ignore the formatting runs for the moment
        if DEBUG:
            o.dump(self.logfile, header="=== MSTxo ===", footer= " ")

    def handle_feat11(self, data):
        if not OBJ_MSO_DEBUG:
            return
        # rt: Record type; this matches the BIFF rt in the first two bytes of the record; =0872h
        # grbitFrt: FRT cell reference flag (see table below for details)
        # Ref0: Range reference to a worksheet cell region if grbitFrt=1 (bitFrtRef). Otherwise blank.
        # isf: Shared feature type index =5 for Table
        # fHdr: =0 since this is for feat not feat header
        # reserved0: Reserved for future use =0 for Table
        # cref: Count of ref ranges this feature is on
        # cbFeatData: Count of byte for the current feature data.
        # reserved1: =0 currently not used
        # Ref1: Repeat of Ref0. UNDOCUMENTED
        rt, grbitFrt, Ref0, isf, fHdr, reserved0, cref, cbFeatData, reserved1, Ref1 = unpack('<HH8sHBiHiH8s', data[0:35])
        assert reserved0 == 0
        assert reserved1 == 0
        assert isf == 5
        assert rt == 0x872
        assert fHdr == 0
        assert Ref1 == Ref0
        print "FEAT11: grbitFrt=%d  Ref0=%r cref=%d cbFeatData=%d" % (grbitFrt, Ref0, cref, cbFeatData)
        # lt: Table data source type:
        #   =0 for Excel Worksheet Table =1 for read-write SharePoint linked List
        #   =2 for XML mapper Table =3 for Query Table
        # idList: The ID of the Table (unique per worksheet)
        # crwHeader: How many header/title rows the Table has at the top
        # crwTotals: How many total rows the Table has at the bottom
        # idFieldNext: Next id to try when assigning a unique id to a new field
        # cbFSData: The size of the Fixed Data portion of the Table data structure.
        # rupBuild: the rupBuild that generated the record
        # unusedShort: UNUSED short that can be used later. The value is reserved during round-tripping.
        # listFlags: Collection of bit flags: (see listFlags' bit setting table below for detail.)
        # lPosStmCache: Table data stream position of cached data
        # cbStmCache: Count of bytes of cached data
        # cchStmCache: Count of characters of uncompressed cached data in the stream
        # lem: Table edit mode (see List (Table) Editing Mode (lem) setting table below for details.)
        # rgbHashParam: Hash value for SharePoint Table
        # cchName: Count of characters in the Table name string rgbName
        (lt, idList, crwHeader, crwTotals, idFieldNext, cbFSData,
        rupBuild, unusedShort, listFlags, lPosStmCache, cbStmCache,
        cchStmCache, lem, rgbHashParam, cchName) = unpack('<iiiiiiHHiiiii16sH', data[35:35+66])
        print "lt=%d  idList=%d crwHeader=%d  crwTotals=%d  idFieldNext=%d cbFSData=%d\n"\
            "rupBuild=%d  unusedShort=%d listFlags=%04X  lPosStmCache=%d  cbStmCache=%d\n"\
            "cchStmCache=%d  lem=%d  rgbHashParam=%r  cchName=%d" % (
            lt, idList, crwHeader, crwTotals, idFieldNext, cbFSData,
            rupBuild, unusedShort,listFlags, lPosStmCache, cbStmCache,
            cchStmCache, lem, rgbHashParam, cchName)

class MSODrawing(BaseObject):
    pass

class MSObj(BaseObject):
    pass

class MSTxo(BaseObject):
    pass

class MSNote(BaseObject):
    pass

# === helpers ===

def unpack_RK(rk_str):
    flags = ord(rk_str[0])
    if flags & 2:
        # There's a SIGNED 30-bit integer in there!
        i,  = unpack('<i', rk_str)
        i >>= 2 # div by 4 to drop the 2 flag bits
        if flags & 1:
            return i / 100.0
        return float(i)
    else:
        # It's the most significant 30 bits of an IEEE 754 64-bit FP number
        d, = unpack('<d', '\0\0\0\0' + chr(flags & 252) + rk_str[1:4])
        if flags & 1:
            return d / 100.0
        return d

##### =============== Cell ======================================== #####

cellty_from_fmtty = {
    FNU: XL_CELL_NUMBER,
    FUN: XL_CELL_NUMBER,
    FGE: XL_CELL_NUMBER,
    FDT: XL_CELL_DATE,
    FTX: XL_CELL_NUMBER, # Yes, a number can be formatted as text.
    }

ctype_text = {
    XL_CELL_EMPTY: 'empty',
    XL_CELL_TEXT: 'text',
    XL_CELL_NUMBER: 'number',
    XL_CELL_DATE: 'xldate',
    XL_CELL_BOOLEAN: 'bool',
    XL_CELL_ERROR: 'error',
    XL_CELL_BLANK: 'blank',
    }

##
# <p>Contains the data for one cell.</p>
#
# <p>WARNING: You don't call this class yourself. You access Cell objects
# via methods of the Sheet object(s) that you found in the Book object that
# was returned when you called xlrd.open_workbook("myfile.xls").</p>
# <p> Cell objects have three attributes: <i>ctype</i> is an int, <i>value</i>
# (which depends on <i>ctype</i>) and <i>xf_index</i>.
# If "formatting_info" is not enabled when the workbook is opened, xf_index will be None.
# The following table describes the types of cells and how their values
# are represented in Python.</p>
#
# <table border="1" cellpadding="7">
# <tr>
# <th>Type symbol</th>
# <th>Type number</th>
# <th>Python value</th>
# </tr>
# <tr>
# <td>XL_CELL_EMPTY</td>
# <td align="center">0</td>
# <td>empty string u''</td>
# </tr>
# <tr>
# <td>XL_CELL_TEXT</td>
# <td align="center">1</td>
# <td>a Unicode string</td>
# </tr>
# <tr>
# <td>XL_CELL_NUMBER</td>
# <td align="center">2</td>
# <td>float</td>
# </tr>
# <tr>
# <td>XL_CELL_DATE</td>
# <td align="center">3</td>
# <td>float</td>
# </tr>
# <tr>
# <td>XL_CELL_BOOLEAN</td>
# <td align="center">4</td>
# <td>int; 1 means TRUE, 0 means FALSE</td>
# </tr>
# <tr>
# <td>XL_CELL_ERROR</td>
# <td align="center">5</td>
# <td>int representing internal Excel codes; for a text representation,
# refer to the supplied dictionary error_text_from_code</td>
# </tr>
# <tr>
# <td>XL_CELL_BLANK</td>
# <td align="center">6</td>
# <td>empty string u''. Note: this type will appear only when
# open_workbook(..., formatting_info=True) is used.</td>
# </tr>
# </table>
#<p></p>

class Cell(BaseObject):

    __slots__ = ['ctype', 'value', 'xf_index']

    def __init__(self, ctype, value, xf_index=None):
        self.ctype = ctype
        self.value = value
        self.xf_index = xf_index

    def __repr__(self):
        if self.xf_index is None:
            return "%s:%r" % (ctype_text[self.ctype], self.value)
        else:
            return "%s:%r (XF:%r)" % (ctype_text[self.ctype], self.value, self.xf_index)

##
# There is one and only one instance of an empty cell -- it's a singleton. This is it.
# You may use a test like "acell is empty_cell".
empty_cell = Cell(XL_CELL_EMPTY, '')

##### =============== Colinfo and Rowinfo ============================== #####

##
# Width and default formatting information that applies to one or
# more columns in a sheet. Derived from COLINFO records.
#
# <p> Here is the default hierarchy for width, according to the OOo docs:
#
# <br />"""In BIFF3, if a COLINFO record is missing for a column,
# the width specified in the record DEFCOLWIDTH is used instead.
#
# <br />In BIFF4-BIFF7, the width set in this [COLINFO] record is only used,
# if the corresponding bit for this column is cleared in the GCW
# record, otherwise the column width set in the DEFCOLWIDTH record
# is used (the STANDARDWIDTH record is always ignored in this case [see footnote!]).
#
# <br />In BIFF8, if a COLINFO record is missing for a column,
# the width specified in the record STANDARDWIDTH is used.
# If this [STANDARDWIDTH] record is also missing,
# the column width of the record DEFCOLWIDTH is used instead."""
# <br />
#
# Footnote:  The docs on the GCW record say this:
# """<br />
# If a bit is set, the corresponding column uses the width set in the STANDARDWIDTH
# record. If a bit is cleared, the corresponding column uses the width set in the
# COLINFO record for this column.
# <br />If a bit is set, and the worksheet does not contain the STANDARDWIDTH record, or if
# the bit is cleared, and the worksheet does not contain the COLINFO record, the DEFCOLWIDTH
# record of the worksheet will be used instead.
# <br />"""<br />
# At the moment (2007-01-17) xlrd is going with the GCW version of the story.
# Reference to the source may be useful: see the computed_column_width(colx) method
# of the Sheet class.
# <br />-- New in version 0.6.1
# </p>

class Colinfo(BaseObject):
    ##
    # Width of the column in 1/256 of the width of the zero character,
    # using default font (first FONT record in the file).
    width = 0
    ##
    # XF index to be used for formatting empty cells.
    xf_index = -1
    ##
    # 1 = column is hidden
    hidden = 0
    ##
    # Value of a 1-bit flag whose purpose is unknown
    # but is often seen set to 1
    bit1_flag = 0
    ##
    # Outline level of the column, in range(7).
    # (0 = no outline)
    outline_level = 0
    ##
    # 1 = column is collapsed
    collapsed = 0

##
# Height and default formatting information that applies to a row in a sheet.
# Derived from ROW records.
# <br /> -- New in version 0.6.1

class Rowinfo(BaseObject):
    ##
    # Height of the row, in twips. One twip == 1/20 of a point
    height = 0
    ##
    # 0 = Row has custom height; 1 = Row has default height
    has_default_height = 0
    ##
    # Outline level of the row
    outline_level = 0
    ##
    # 1 = Outline group starts or ends here (depending on where the
    # outline buttons are located, see WSBOOL record [TODO ??]),
    # <i>and</i> is collapsed
    outline_group_starts_ends = 0
    ##
    # 1 = Row is hidden (manually, or by a filter or outline group)
    hidden = 0
    ##
    # 1 = Row height and default font height do not match
    height_mismatch = 0
    ##
    # 1 = the xf_index attribute is usable; 0 = ignore it
    has_default_xf_index = 0
    ##
    # Index to default XF record for empty cells in this row.
    # Don't use this if has_default_xf_index == 0.
    xf_index = -9999
    ##
    # This flag is set, if the upper border of at least one cell in this row
    # or if the lower border of at least one cell in the row above is
    # formatted with a thick line style. Thin and medium line styles are not
    # taken into account.
    additional_space_above = 0
    ##
    # This flag is set, if the lower border of at least one cell in this row
    # or if the upper border of at least one cell in the row below is
    # formatted with a medium or thick line style. Thin line styles are not
    # taken into account.
    additional_space_below = 0

########NEW FILE########
__FILENAME__ = timemachine
# -*- coding: cp1252 -*-

##
# <p>Copyright  2006-2008 Stephen John Machin, Lingfo Pty Ltd</p>
# <p>This module is part of the xlrd package, which is released under a BSD-style licence.</p>
##

# timemachine.py -- adaptation for earlier Pythons e.g. 2.1
# usage: from timemachine import *

# 2008-02-08 SJM Generalised method of detecting IronPython

import sys

python_version = sys.version_info[:2] # e.g. version 2.4 -> (2, 4)

CAN_PICKLE_ARRAY = python_version >= (2, 5)
CAN_SUBCLASS_BUILTIN = python_version >= (2, 2)

if sys.version.find("IronPython") >= 0:
    array_array = None
else:
    from array import array as array_array

if python_version < (2, 2):
    class object:
        pass
    False = 0
    True = 1

def int_floor_div(x, y):
    return divmod(x, y)[0]

def intbool(x):
    if x:
        return 1
    return 0

if python_version < (2, 3):
    def sum(sequence, start=0):
        tot = start
        for item in aseq:
            tot += item
        return tot

########NEW FILE########
__FILENAME__ = xldate
# -*- coding: cp1252 -*-

# No part of the content of this file was derived from the works of David Giffin.

##
# <p>Copyright  2005-2008 Stephen John Machin, Lingfo Pty Ltd</p>
# <p>This module is part of the xlrd package, which is released under a BSD-style licence.</p>
#
# <p>Provides function(s) for dealing with Microsoft Excel  dates.</p>
##

# 2008-10-18 SJM Fix bug in xldate_from_date_tuple (affected some years after 2099)

# The conversion from days to (year, month, day) starts with
# an integral "julian day number" aka JDN.
# FWIW, JDN 0 corresponds to noon on Monday November 24 in Gregorian year -4713.
# More importantly:
#    Noon on Gregorian 1900-03-01 (day 61 in the 1900-based system) is JDN 2415080.0
#    Noon on Gregorian 1904-01-02 (day  1 in the 1904-based system) is JDN 2416482.0

from timemachine import int_floor_div as ifd

_JDN_delta = (2415080 - 61, 2416482 - 1)
assert _JDN_delta[1] - _JDN_delta[0] == 1462

class XLDateError(ValueError): pass

class XLDateNegative(XLDateError): pass
class XLDateAmbiguous(XLDateError): pass
class XLDateTooLarge(XLDateError): pass
class XLDateBadDatemode(XLDateError): pass
class XLDateBadTuple(XLDateError): pass

_XLDAYS_TOO_LARGE = (2958466, 2958466 - 1462) # This is equivalent to 10000-01-01

##
# Convert an Excel number (presumed to represent a date, a datetime or a time) into
# a tuple suitable for feeding to datetime or mx.DateTime constructors.
# @param xldate The Excel number
# @param datemode 0: 1900-based, 1: 1904-based.
# <br>WARNING: when using this function to
# interpret the contents of a workbook, you should pass in the Book.datemode
# attribute of that workbook. Whether
# the workbook has ever been anywhere near a Macintosh is irrelevant.
# @return Gregorian (year, month, day, hour, minute, nearest_second).
# <br>Special case: if 0.0 <= xldate < 1.0, it is assumed to represent a time;
# (0, 0, 0, hour, minute, second) will be returned.
# <br>Note: 1904-01-01 is not regarded as a valid date in the datemode 1 system; its "serial number"
# is zero.
# @throws XLDateNegative xldate < 0.00
# @throws XLDateAmbiguous The 1900 leap-year problem (datemode == 0 and 1.0 <= xldate < 61.0)
# @throws XLDateTooLarge Gregorian year 10000 or later
# @throws XLDateBadDatemode datemode arg is neither 0 nor 1
# @throws XLDateError Covers the 4 specific errors

def xldate_as_tuple(xldate, datemode):
    if datemode not in (0, 1):
        raise XLDateBadDatemode(datemode)
    if xldate == 0.00:
        return (0, 0, 0, 0, 0, 0)
    if xldate < 0.00:
        raise XLDateNegative(xldate)
    xldays = int(xldate)
    frac = xldate - xldays
    seconds = int(round(frac * 86400.0))
    assert 0 <= seconds <= 86400
    if seconds == 86400:
        hour = minute = second = 0
        xldays += 1
    else:
        # second = seconds % 60; minutes = seconds // 60
        minutes, second = divmod(seconds, 60)
        # minute = minutes % 60; hour    = minutes // 60
        hour, minute = divmod(minutes, 60)
    if xldays >= _XLDAYS_TOO_LARGE[datemode]:
        raise XLDateTooLarge(xldate)

    if xldays == 0:
        return (0, 0, 0, hour, minute, second)

    if xldays < 61 and datemode == 0:
        raise XLDateAmbiguous(xldate)

    jdn = xldays + _JDN_delta[datemode]
    yreg = (ifd(ifd(jdn * 4 + 274277, 146097) * 3, 4) + jdn + 1363) * 4 + 3
    mp = ifd(yreg % 1461, 4) * 535 + 333
    d = ifd(mp % 16384, 535) + 1
    # mp /= 16384
    mp >>= 14
    if mp >= 10:
        return (ifd(yreg, 1461) - 4715, mp - 9, d, hour, minute, second)
    else:
        return (ifd(yreg, 1461) - 4716, mp + 3, d, hour, minute, second)

# === conversions from date/time to xl numbers

def _leap(y):
    if y % 4: return 0
    if y % 100: return 1
    if y % 400: return 0
    return 1

_days_in_month = (None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)

##
# Convert a date tuple (year, month, day) to an Excel date.
# @param year Gregorian year.
# @param month 1 <= month <= 12
# @param day 1 <= day <= last day of that (year, month)
# @param datemode 0: 1900-based, 1: 1904-based.
# @throws XLDateAmbiguous The 1900 leap-year problem (datemode == 0 and 1.0 <= xldate < 61.0)
# @throws XLDateBadDatemode datemode arg is neither 0 nor 1
# @throws XLDateBadTuple (year, month, day) is too early/late or has invalid component(s)
# @throws XLDateError Covers the specific errors

def xldate_from_date_tuple((year, month, day), datemode):

    if datemode not in (0, 1):
        raise XLDateBadDatemode(datemode)

    if year == 0 and month == 0 and day == 0:
        return 0.00

    if not (1900 <= year <= 9999):
        raise XLDateBadTuple("Invalid year: %r" % ((year, month, day),))
    if not (1 <= month <= 12):
        raise XLDateBadTuple("Invalid month: %r" % ((year, month, day),))
    if  day < 1 \
    or (day > _days_in_month[month] and not(day == 29 and month == 2 and _leap(year))):
        raise XLDateBadTuple("Invalid day: %r" % ((year, month, day),))

    Yp = year + 4716
    M = month
    if M <= 2:
        Yp = Yp - 1
        Mp = M + 9
    else:
        Mp = M - 3
    jdn = ifd(1461 * Yp, 4) + ifd(979 * Mp + 16, 32) + \
        day - 1364 - ifd(ifd(Yp + 184, 100) * 3, 4)
    xldays = jdn - _JDN_delta[datemode]
    if xldays <= 0:
        raise XLDateBadTuple("Invalid (year, month, day): %r" % ((year, month, day),))
    if xldays < 61 and datemode == 0:
        raise XLDateAmbiguous("Before 1900-03-01: %r" % ((year, month, day),))
    return float(xldays)

##
# Convert a time tuple (hour, minute, second) to an Excel "date" value (fraction of a day).
# @param hour 0 <= hour < 24
# @param minute 0 <= minute < 60
# @param second 0 <= second < 60
# @throws XLDateBadTuple Out-of-range hour, minute, or second

def xldate_from_time_tuple((hour, minute, second)):
    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:
        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0
    raise XLDateBadTuple("Invalid (hour, minute, second): %r" % ((hour, minute, second),))

##
# Convert a datetime tuple (year, month, day, hour, minute, second) to an Excel date value.
# For more details, refer to other xldate_from_*_tuple functions.
# @param datetime_tuple (year, month, day, hour, minute, second)
# @param datemode 0: 1900-based, 1: 1904-based.

def xldate_from_datetime_tuple(datetime_tuple, datemode):
    return (
        xldate_from_date_tuple(datetime_tuple[:3], datemode)
        +
        xldate_from_time_tuple(datetime_tuple[3:])
        )

########NEW FILE########
__FILENAME__ = biffh
# Support module for the xlrd3 package.
#
# Portions copyright (c) 2005-2008 Stephen John Machin, Lingfo Pty Ltd
# This module is part of the xlrd package, which is released under a
# BSD-style licence.
#
# 2010-12-08 mozman refactoring for python 3
# 2008-02-10 SJM BIFF2 BLANK record
# 2008-02-08 SJM Preparation for Excel 2.0 support
# 2008-02-02 SJM Added suffixes (_B2, _B2_ONLY, etc) on record names for
#                biff_dump & biff_count
# 2007-12-04 SJM Added support for Excel 2.x (BIFF2) files.
# 2007-09-08 SJM Avoid crash when zero-length Unicode string missing options byte.
# 2007-04-22 SJM Remove experimental "trimming" facility.

import sys
from struct import unpack

encoding_from_codepage = {
    1200 : 'utf_16_le',
    10000: 'mac_roman',
    10006: 'mac_greek', # guess
    10007: 'mac_cyrillic', # guess
    10029: 'mac_latin2', # guess
    10079: 'mac_iceland', # guess
    10081: 'mac_turkish', # guess
    32768: 'mac_roman',
    32769: 'cp1252',
    }

# some more guessing, for Indic scripts
# codepage 57000 range:
# 2 Devanagari [0]
# 3 Bengali [1]
# 4 Tamil [5]
# 5 Telegu [6]
# 6 Assamese [1] c.f. Bengali
# 7 Oriya [4]
# 8 Kannada [7]
# 9 Malayalam [8]
# 10 Gujarati [3]
# 11 Gurmukhi [2]

FUN = 0 # unknown
FDT = 1 # date
FNU = 2 # number
FGE = 3 # general
FTX = 4 # text

DATEFORMAT = FDT
NUMBERFORMAT = FNU

XL_CELL_EMPTY = 0
XL_CELL_TEXT = 1
XL_CELL_NUMBER = 2
XL_CELL_DATE = 3
XL_CELL_BOOLEAN = 4
XL_CELL_ERROR = 5
XL_CELL_BLANK = 6 # for use in debugging, gathering stats, etc

biff_text_from_num = {
    0:  "(not BIFF)",
    20: "2.0",
    21: "2.1",
    30: "3",
    40: "4S",
    45: "4W",
    50: "5",
    70: "7",
    80: "8",
    85: "8X",
}

# This dictionary can be used to produce a text version of the internal codes
# that Excel uses for error cells. Here are its contents:
error_text_from_code = {
    0x00: '#NULL!',  # Intersection of two cell ranges is empty
    0x07: '#DIV/0!', # Division by zero
    0x0F: '#VALUE!', # Wrong type of operand
    0x17: '#REF!',   # Illegal or deleted cell reference
    0x1D: '#NAME?',  # Wrong function or range name
    0x24: '#NUM!',   # Value range overflow
    0x2A: '#N/A!',   # Argument or function not available
}

BIFF_FIRST_UNICODE = 80

XL_WORKBOOK_GLOBALS = WBKBLOBAL = 0x5
XL_WORKBOOK_GLOBALS_4W = 0x100
XL_WORKSHEET = WRKSHEET = 0x10

XL_BOUNDSHEET_WORKSHEET = 0x00
XL_BOUNDSHEET_CHART     = 0x02
XL_BOUNDSHEET_VB_MODULE = 0x06

# XL_RK2 = 0x7e
XL_ARRAY  = 0x0221
XL_ARRAY2 = 0x0021
XL_BLANK = 0x0201
XL_BLANK_B2 = 0x01
XL_BOF = 0x809
XL_BOOLERR = 0x205
XL_BOOLERR_B2 = 0x5
XL_BOUNDSHEET = 0x85
XL_BUILTINFMTCOUNT = 0x56
XL_CF = 0x01B1
XL_CODEPAGE = 0x42
XL_COLINFO = 0x7D
XL_COLUMNDEFAULT = 0x20 # BIFF2 only
XL_COLWIDTH = 0x24 # BIFF2 only
XL_CONDFMT = 0x01B0
XL_CONTINUE = 0x3c
XL_COUNTRY = 0x8C
XL_DATEMODE = 0x22
XL_DEFAULTROWHEIGHT = 0x0225
XL_DEFCOLWIDTH = 0x55
XL_DIMENSION = 0x200
XL_DIMENSION2 = 0x0
XL_EFONT = 0x45
XL_EOF = 0x0a
XL_EXTERNNAME = 0x23
XL_EXTERNSHEET = 0x17
XL_EXTSST = 0xff
XL_FEAT11 = 0x872
XL_FILEPASS = 0x2f
XL_FONT = 0x31
XL_FONT_B3B4 = 0x231
XL_FORMAT = 0x41e
XL_FORMAT2 = 0x1E # BIFF2, BIFF3
XL_FORMULA = 0x6
XL_FORMULA3 = 0x206
XL_FORMULA4 = 0x406
XL_GCW = 0xab
XL_INDEX = 0x20b
XL_INTEGER = 0x2 # BIFF2 only
XL_IXFE = 0x44 # BIFF2 only
XL_LABEL = 0x204
XL_LABEL_B2 = 0x04
XL_LABELRANGES = 0x15f
XL_LABELSST = 0xfd
XL_MERGEDCELLS = 0xE5
XL_MSO_DRAWING = 0x00EC
XL_MSO_DRAWING_GROUP = 0x00EB
XL_MSO_DRAWING_SELECTION = 0x00ED
XL_MULRK = 0xbd
XL_MULBLANK = 0xbe
XL_NAME = 0x18
XL_NOTE = 0x1c
XL_NUMBER = 0x203
XL_NUMBER_B2 = 0x3
XL_OBJ = 0x5D
XL_PALETTE = 0x92
XL_RK = 0x27e
XL_ROW = 0x208
XL_ROW_B2 = 0x08
XL_RSTRING = 0xd6
XL_SHEETHDR = 0x8F # BIFF4W only
XL_SHEETSOFFSET = 0x8E # BIFF4W only
XL_SHRFMLA = 0x04bc
XL_SST = 0xfc
XL_STANDARDWIDTH = 0x99
XL_STRING = 0x207
XL_STRING_B2 = 0x7
XL_STYLE = 0x293
XL_SUPBOOK = 0x1AE
XL_TABLEOP = 0x236
XL_TABLEOP2 = 0x37
XL_TABLEOP_B2 = 0x36
XL_TXO = 0x1b6
XL_UNCALCED = 0x5e
XL_UNKNOWN = 0xffff
XL_WINDOW2 = 0x023E
XL_WRITEACCESS = 0x5C
XL_XF = 0xe0
XL_XF2 = 0x0043 # BIFF2 version of XF record
XL_XF3 = 0x0243 # BIFF3 version of XF record
XL_XF4 = 0x0443 # BIFF4 version of XF record

boflen = {
    0x0809: 8,
    0x0409: 6,
    0x0209: 6,
    0x0009: 4,
}

bofcodes = (0x0809, 0x0409, 0x0209, 0x0009)

XL_FORMULA_OPCODES = (0x0006, 0x0406, 0x0206)

_cell_opcode_list = (
    XL_BOOLERR,
    XL_FORMULA,
    XL_FORMULA3,
    XL_FORMULA4,
    XL_LABEL,
    XL_LABELSST,
    XL_MULRK,
    XL_NUMBER,
    XL_RK,
    XL_RSTRING,
)

biff_rec_name_dict = {
    0x0000: 'DIMENSIONS_B2',
    0x0001: 'BLANK_B2',
    0x0002: 'INTEGER_B2_ONLY',
    0x0003: 'NUMBER_B2',
    0x0004: 'LABEL_B2',
    0x0005: 'BOOLERR_B2',
    0x0006: 'FORMULA',
    0x0007: 'STRING_B2',
    0x0008: 'ROW_B2',
    0x0009: 'BOF_B2',
    0x000A: 'EOF',
    0x000B: 'INDEX_B2_ONLY',
    0x000C: 'CALCCOUNT',
    0x000D: 'CALCMODE',
    0x000E: 'PRECISION',
    0x000F: 'REFMODE',
    0x0010: 'DELTA',
    0x0011: 'ITERATION',
    0x0012: 'PROTECT',
    0x0013: 'PASSWORD',
    0x0014: 'HEADER',
    0x0015: 'FOOTER',
    0x0016: 'EXTERNCOUNT',
    0x0017: 'EXTERNSHEET',
    0x0018: 'NAME_B2,5+',
    0x0019: 'WINDOWPROTECT',
    0x001A: 'VERTICALPAGEBREAKS',
    0x001B: 'HORIZONTALPAGEBREAKS',
    0x001C: 'NOTE',
    0x001D: 'SELECTION',
    0x001E: 'FORMAT_B2-3',
    0x001F: 'BUILTINFMTCOUNT_B2',
    0x0020: 'COLUMNDEFAULT_B2_ONLY',
    0x0021: 'ARRAY_B2_ONLY',
    0x0022: 'DATEMODE',
    0x0023: 'EXTERNNAME',
    0x0024: 'COLWIDTH_B2_ONLY',
    0x0025: 'DEFAULTROWHEIGHT_B2_ONLY',
    0x0026: 'LEFTMARGIN',
    0x0027: 'RIGHTMARGIN',
    0x0028: 'TOPMARGIN',
    0x0029: 'BOTTOMMARGIN',
    0x002A: 'PRINTHEADERS',
    0x002B: 'PRINTGRIDLINES',
    0x002F: 'FILEPASS',
    0x0031: 'FONT',
    0x0032: 'FONT2_B2_ONLY',
    0x0036: 'TABLEOP_B2',
    0x0037: 'TABLEOP2_B2',
    0x003C: 'CONTINUE',
    0x003D: 'WINDOW1',
    0x003E: 'WINDOW2_B2',
    0x0040: 'BACKUP',
    0x0041: 'PANE',
    0x0042: 'CODEPAGE',
    0x0043: 'XF_B2',
    0x0044: 'IXFE_B2_ONLY',
    0x0045: 'EFONT_B2_ONLY',
    0x004D: 'PLS',
    0x0051: 'DCONREF',
    0x0055: 'DEFCOLWIDTH',
    0x0056: 'BUILTINFMTCOUNT_B3-4',
    0x0059: 'XCT',
    0x005A: 'CRN',
    0x005B: 'FILESHARING',
    0x005C: 'WRITEACCESS',
    0x005D: 'OBJECT',
    0x005E: 'UNCALCED',
    0x005F: 'SAVERECALC',
    0x0063: 'OBJECTPROTECT',
    0x007D: 'COLINFO',
    0x007E: 'RK2_mythical_?',
    0x0080: 'GUTS',
    0x0081: 'WSBOOL',
    0x0082: 'GRIDSET',
    0x0083: 'HCENTER',
    0x0084: 'VCENTER',
    0x0085: 'BOUNDSHEET',
    0x0086: 'WRITEPROT',
    0x008C: 'COUNTRY',
    0x008D: 'HIDEOBJ',
    0x008E: 'SHEETSOFFSET',
    0x008F: 'SHEETHDR',
    0x0090: 'SORT',
    0x0092: 'PALETTE',
    0x0099: 'STANDARDWIDTH',
    0x009B: 'FILTERMODE',
    0x009C: 'FNGROUPCOUNT',
    0x009D: 'AUTOFILTERINFO',
    0x009E: 'AUTOFILTER',
    0x00A0: 'SCL',
    0x00A1: 'SETUP',
    0x00AB: 'GCW',
    0x00BD: 'MULRK',
    0x00BE: 'MULBLANK',
    0x00C1: 'MMS',
    0x00D6: 'RSTRING',
    0x00D7: 'DBCELL',
    0x00DA: 'BOOKBOOL',
    0x00DD: 'SCENPROTECT',
    0x00E0: 'XF',
    0x00E1: 'INTERFACEHDR',
    0x00E2: 'INTERFACEEND',
    0x00E5: 'MERGEDCELLS',
    0x00E9: 'BITMAP',
    0x00EB: 'MSO_DRAWING_GROUP',
    0x00EC: 'MSO_DRAWING',
    0x00ED: 'MSO_DRAWING_SELECTION',
    0x00EF: 'PHONETIC',
    0x00FC: 'SST',
    0x00FD: 'LABELSST',
    0x00FF: 'EXTSST',
    0x013D: 'TABID',
    0x015F: 'LABELRANGES',
    0x0160: 'USESELFS',
    0x0161: 'DSF',
    0x01AE: 'SUPBOOK',
    0x01AF: 'PROTECTIONREV4',
    0x01B0: 'CONDFMT',
    0x01B1: 'CF',
    0x01B2: 'DVAL',
    0x01B6: 'TXO',
    0x01B7: 'REFRESHALL',
    0x01B8: 'HLINK',
    0x01BC: 'PASSWORDREV4',
    0x01BE: 'DV',
    0x01C0: 'XL9FILE',
    0x01C1: 'RECALCID',
    0x0200: 'DIMENSIONS',
    0x0201: 'BLANK',
    0x0203: 'NUMBER',
    0x0204: 'LABEL',
    0x0205: 'BOOLERR',
    0x0206: 'FORMULA_B3',
    0x0207: 'STRING',
    0x0208: 'ROW',
    0x0209: 'BOF',
    0x020B: 'INDEX_B3+',
    0x0218: 'NAME',
    0x0221: 'ARRAY',
    0x0223: 'EXTERNNAME_B3-4',
    0x0225: 'DEFAULTROWHEIGHT',
    0x0231: 'FONT_B3B4',
    0x0236: 'TABLEOP',
    0x023E: 'WINDOW2',
    0x0243: 'XF_B3',
    0x027E: 'RK',
    0x0293: 'STYLE',
    0x0406: 'FORMULA_B4',
    0x0409: 'BOF',
    0x041E: 'FORMAT',
    0x0443: 'XF_B4',
    0x04BC: 'SHRFMLA',
    0x0800: 'QUICKTIP',
    0x0809: 'BOF',
    0x0862: 'SHEETLAYOUT',
    0x0867: 'SHEETPROTECTION',
    0x0868: 'RANGEPROTECTION',
}

class XLRDError(Exception):
    pass

class BaseObject:
    """
    Parent of almost all other classes in the package. Defines a common
    'dump' method for debugging.
    """
    _repr_these = []

    def dump(self, f=None, header=None, footer=None, indent=0):
        """
        :param f: open file object, to which the dump is written
        :param header: text to write before the dump
        :param footer: text to write after the dump
        :param indent: number of leading spaces (for recursive calls)
        """
        if f is None:
            f = sys.stderr
        pad = " " * indent

        if header is not None:
            print(header, file=f)

        for attr, value in sorted(self.__dict__.items()):
            if getattr(value, 'dump', None) and attr != 'book':
                value.dump(f,
                    header="%s%s (%s object):" % (pad, attr, value.__class__.__name__),
                    indent=indent+4)
            elif attr not in self._repr_these and \
                 (isinstance(value, list) or
                  isinstance(value, dict)):
                print("%s%s: %s, len = %d" % (pad, attr, type(value), len(value)), file=f)
            else:
                print("%s%s: %r" % (pad, attr, value), file=f)
        if footer is not None:
            print(footer, file=f)

def fprintf(f, fmt, *vargs):
    print(fmt.rstrip('\n') % vargs, file=f)

def upkbits(tgt_obj, src, manifest, local_setattr=setattr):
    for n, mask, attr in manifest:
        local_setattr(tgt_obj, attr, (src & mask) >> n)

def upkbitsL(tgt_obj, src, manifest, local_setattr=setattr, local_int=int):
    for n, mask, attr in manifest:
        local_setattr(tgt_obj, attr, local_int((src & mask) >> n))

def unpack_string(data, pos, encoding, lenlen=1):
    nchars = unpack('<' + 'BH'[lenlen-1], data[pos:pos+lenlen])[0]
    pos += lenlen
    return str(data[pos:pos+nchars], encoding)

def unpack_string_update_pos(data, pos, encoding, lenlen=1, known_len=None):
    if known_len is not None:
        # On a NAME record, the length byte is detached from the front of the string.
        nchars = known_len
    else:
        nchars = unpack('<' + 'BH'[lenlen-1], data[pos:pos+lenlen])[0]
        pos += lenlen

    newpos = pos + nchars
    return (str(data[pos:newpos], encoding), newpos)

def unpack_unicode(data, pos, lenlen=2):
    """ Return unicode_strg """
    nchars = unpack('<' + 'BH'[lenlen-1], data[pos:pos+lenlen])[0]
    if not nchars:
        # Ambiguous whether 0-length string should have an "options" byte.
        # Avoid crash if missing.
        return ""
    pos += lenlen
    options = data[pos]
    pos += 1

    if options & 0x08: # richtext
        pos += 2

    if options & 0x04: # phonetic
        pos += 4

    if options & 0x01:
        # Uncompressed UTF-16-LE
        rawstrg = data[pos:pos+2*nchars]
        strg = str(rawstrg, 'utf_16_le')
    else:
        # Note: this is COMPRESSED (not ASCII!) encoding!!!
        # Merely returning the raw bytes would work OK 99.99% of the time
        # if the local codepage was cp1252 -- however this would rapidly go pear-shaped
        # for other codepages so we grit our Anglocentric teeth and return Unicode :-)
        strg = str(data[pos:pos+nchars], "latin_1")
    return strg

def unpack_unicode_update_pos(data, pos, lenlen=2, known_len=None):
    """ Return (unicode_strg, updated value of pos) """
    if known_len is not None:
        # On a NAME record, the length byte is detached from the front of the string.
        nchars = known_len
    else:
        nchars = unpack('<' + 'BH'[lenlen-1], data[pos:pos+lenlen])[0]
        pos += lenlen

    if not nchars and not data[pos:]:
        # Zero-length string with no options byte
        return ("", pos)

    options = data[pos]
    pos += 1
    phonetic = options & 0x04
    richtext = options & 0x08

    if richtext:
        rt = unpack('<H', data[pos:pos+2])[0]
        pos += 2

    if phonetic:
        sz = unpack('<i', data[pos:pos+4])[0]
        pos += 4

    if options & 0x01:
        # Uncompressed UTF-16-LE
        strg = str(data[pos:pos+2*nchars], 'utf_16_le')
        pos += 2*nchars
    else:
        # Note: this is COMPRESSED (not ASCII!) encoding!!!
        strg = str(data[pos:pos+nchars], "latin_1")
        pos += nchars

    if richtext:
        pos += 4 * rt

    if phonetic:
        pos += sz

    return (strg, pos)

def unpack_cell_range_address_list_update_pos(
    output_list, data, pos, biff_version, addr_size=6):
    # output_list is updated in situ
    if biff_version < 80:
        assert addr_size == 6
    else:
        assert addr_size in (6, 8)
    n, = unpack("<H", data[pos:pos+2])
    pos += 2
    if n:
        fmt = "<HHBB" if addr_size == 6 else "<HHHH"
        for _unused in range(n):
            ra, rb, ca, cb = unpack(fmt, data[pos:pos+addr_size])
            output_list.append((ra, rb+1, ca, cb+1))
            pos += addr_size
    return pos

def hex_char_dump(strg, ofs, dlen, base=0, fout=sys.stdout, unnumbered=False):
    endpos = min(ofs + dlen, len(strg))
    pos = ofs
    numbered = not unnumbered
    num_prefix = ''
    while pos < endpos:
        endsub = min(pos + 16, endpos)
        substrg = strg[pos:endsub]
        lensub = endsub - pos
        if lensub <= 0 or lensub != len(substrg):
            fprintf(
                sys.stdout,
                '??? hex_char_dump: ofs=%d dlen=%d base=%d -> endpos=%d pos=%d endsub=%d substrg=%r\n',
                ofs, dlen, base, endpos, pos, endsub, substrg)
            break
        hexd = ''.join(["%02x " % c for c in substrg])
        chard = ''
        for c in substrg:
            if c == ord('\0'):
                c = '~'
            elif not (' ' <= chr(c) <= '~'):
                c = '?'
            if isinstance(c, int):
                c = chr(c)
            chard += c
        if numbered:
            num_prefix = "%5d: " %  (base+pos-ofs)
        fprintf(fout, "%s     %-48s %s\n", num_prefix, hexd, chard)
        pos = endsub

def biff_dump(mem, stream_offset, stream_len, base=0, fout=sys.stdout,
              unnumbered=False):
    pos = stream_offset
    stream_end = stream_offset + stream_len
    adj = base - stream_offset
    dummies = 0
    numbered = not unnumbered
    num_prefix = ''
    while stream_end - pos >= 4:
        rc, length = unpack('<HH', mem[pos:pos+4])
        if rc == 0 and length == 0:
            if mem[pos:] == '\0' * (stream_end - pos):
                dummies = stream_end - pos
                savpos = pos
                pos = stream_end
                break

            if dummies:
                dummies += 4
            else:
                savpos = pos
                dummies = 4
            pos += 4
        else:
            if dummies:
                if numbered:
                    num_prefix =  "%5d: " % (adj + savpos)
                fprintf(fout, "%s---- %d zero bytes skipped ----\n",
                        num_prefix, dummies)
                dummies = 0

            recname = biff_rec_name_dict.get(rc, '<UNKNOWN>')
            if numbered:
                num_prefix = "%5d: " % (adj + pos)
            fprintf(fout, "%s%04x %s len = %04x (%d)\n",
                    num_prefix, rc, recname, length, length)
            pos += 4
            hex_char_dump(mem, pos, length, adj+pos, fout, unnumbered)
            pos += length
    if dummies:
        if numbered:
            num_prefix =  "%5d: " % (adj + savpos)
        fprintf(fout, "%s---- %d zero bytes skipped ----\n", num_prefix, dummies)

    if pos < stream_end:
        if numbered:
            num_prefix = "%5d: " % (adj + pos)
        fprintf(fout, "%s---- Misc bytes at end ----\n", num_prefix)
        hex_char_dump(mem, pos, stream_end-pos, adj + pos, fout, unnumbered)
    elif pos > stream_end:
        fprintf(fout, "Last dumped record has length (%d) that is too large\n", length)

def biff_count_records(mem, stream_offset, stream_len, fout=sys.stdout):
    pos = stream_offset
    stream_end = stream_offset + stream_len
    tally = {}
    while stream_end - pos >= 4:
        rc, length = unpack('<HH', mem[pos:pos+4])
        if rc == 0 and length == 0:
            if mem[pos:] == '\0' * (stream_end - pos):
                break
            recname = "<Dummy (zero)>"
        else:
            recname = biff_rec_name_dict.get(rc, None)
            if recname is None:
                recname = "Unknown_0x%04X" % rc
        if recname in tally:
            tally[recname] += 1
        else:
            tally[recname] = 1
        pos += length + 4
    for recname, count in sorted(tally.items()):
        fprintf(fout, "%8d %s", count, recname)

########NEW FILE########
__FILENAME__ = compdoc
# Implements the minimal functionality required
# to extract a "Workbook" or "Book" stream (as one big string)
# from an OLE2 Compound Document file.
#
# Copyright  2005-2008 Stephen John Machin, Lingfo Pty Ltd
# This module is part of the xlrd3 package, which is released under a BSD-style licence.

# No part of the content of this file was derived from the works of David Giffin.

# 2008-11-04 SJM Avoid assertion error when -1 used instead of -2 for first_SID of empty SCSS [Frank Hoffsuemmer]
# 2007-09-08 SJM Warning message if sector sizes are extremely large.
# 2007-05-07 SJM Meaningful exception instead of IndexError if a SAT (sector allocation table) is corrupted.
# 2007-04-22 SJM Missing "<" in a struct.unpack call => can't open files on bigendian platforms.


import sys
from struct import unpack

# Magic cookie that should appear in the first 8 bytes of the file.
SIGNATURE = b"\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1"

EOCSID = -2
FREESID = -1
SATSID = -3
MSATSID = -4

def int_floor_div(x, y):
    return divmod(x, y)[0]

class CompDocError(Exception):
    pass

class DirNode(object):

    def __init__(self, DID, dent, DEBUG=0):
        # dent is the 128-byte directory entry
        self.DID = DID
        # (cbufsize, self.etype, self.colour, self.left_DID, self.right_DID,
        # self.root_DID,
        # self.first_SID,
        # self.tot_size) = \
        #     unpack('<HBBiii16x4x8x8xii4x', dent[64:128])
        (cbufsize, self.etype, self.colour, self.left_DID, self.right_DID,
        self.root_DID) = \
            unpack('<HBBiii', dent[64:80])
        (self.first_SID, self.tot_size) = \
            unpack('<ii', dent[116:124])
        if cbufsize == 0:
            self.name = ''
        else:
            self.name = str(dent[0:cbufsize-2], 'utf_16_le') # omit the trailing U+0000
        self.children = [] # filled in later
        self.parent = -1 # indicates orphan; fixed up later
        self.tsinfo = unpack('<IIII', dent[100:116])
        if DEBUG:
            self.dump(DEBUG)

    def dump(self, DEBUG=1):
        print("DID=%d name=%r etype=%d DIDs(left=%d right=%d root=%d parent=%d kids=%r) first_SID=%d tot_size=%d" \
            % (self.DID, self.name, self.etype, self.left_DID,
            self.right_DID, self.root_DID, self.parent, self.children, self.first_SID, self.tot_size))
        if DEBUG == 2:
            # cre_lo, cre_hi, mod_lo, mod_hi = tsinfo
            print("timestamp info", self.tsinfo)

def _build_family_tree(dirlist, parent_DID, child_DID):
    if child_DID < 0: return
    _build_family_tree(dirlist, parent_DID, dirlist[child_DID].left_DID)
    dirlist[parent_DID].children.append(child_DID)
    dirlist[child_DID].parent = parent_DID
    _build_family_tree(dirlist, parent_DID, dirlist[child_DID].right_DID)
    if dirlist[child_DID].etype == 1: # storage
        _build_family_tree(dirlist, child_DID, dirlist[child_DID].root_DID)

# Compound document handler.
# @param mem The raw contents of the file, as a string, or as an mmap.mmap() object. The
# only operation it needs to support is slicing.

class CompDoc(object):

    def __init__(self, mem, logfile=sys.stdout, DEBUG=0):
        self.logfile = logfile
        if mem[0:8] != SIGNATURE:
            raise CompDocError('Not an OLE2 compound document')
        if mem[28:30] != b'\xFE\xFF':
            raise CompDocError('Expected "little-endian" marker, found %r' % mem[28:30])
        revision, version = unpack('<HH', mem[24:28])
        if DEBUG:
            print("\nCompDoc format: version=0x%04x revision=0x%04x" % (version, revision), file=logfile)
        self.mem = mem
        ssz, sssz = unpack('<HH', mem[30:34])
        if ssz > 20: # allows for 2**20 bytes i.e. 1MB
            print("WARNING: sector size (2**%d) is preposterous; assuming 512 and continuing ..." \
                % ssz, file=logfile)
            ssz = 9
        if sssz > ssz:
            print("WARNING: short stream sector size (2**%d) is preposterous; assuming 64 and continuing ..." \
                % sssz, file=logfile)
            sssz = 6
        self.sec_size = sec_size = 1 << ssz
        self.short_sec_size = 1 << sssz
        (
            SAT_tot_secs, self.dir_first_sec_sid, _unused, self.min_size_std_stream,
            SSAT_first_sec_sid, SSAT_tot_secs,
            MSAT_first_sec_sid, MSAT_tot_secs,
        # ) = unpack('<ii4xiiiii', mem[44:76])
        ) = unpack('<iiiiiiii', mem[44:76])
        mem_data_len = len(mem) - 512
        mem_data_secs, left_over = divmod(mem_data_len, sec_size)
        if left_over:
            #### raise CompDocError("Not a whole number of sectors")
            print("WARNING *** file size (%d) not 512 + multiple of sector size (%d)" \
                % (len(mem), sec_size), file=logfile)
        if DEBUG:
            print('sec sizes', ssz, sssz, sec_size, self.short_sec_size, file=logfile)
            print("mem data: %d bytes == %d sectors" % (mem_data_len, mem_data_secs), file=logfile)
            print("SAT_tot_secs=%d, dir_first_sec_sid=%d, min_size_std_stream=%d" \
                % (SAT_tot_secs, self.dir_first_sec_sid, self.min_size_std_stream,), file=logfile)
            print("SSAT_first_sec_sid=%d, SSAT_tot_secs=%d" % (SSAT_first_sec_sid, SSAT_tot_secs,), file=logfile)
            print("MSAT_first_sec_sid=%d, MSAT_tot_secs=%d" % (MSAT_first_sec_sid, MSAT_tot_secs,), file=logfile)
        nent = int_floor_div(sec_size, 4) # number of SID entries in a sector
        fmt = "<%di" % nent
        trunc_warned = 0
        #
        # === build the MSAT ===
        #
        MSAT = list(unpack('<109i', mem[76:512]))
        sid = MSAT_first_sec_sid
        while sid >= 0:
            if sid >= mem_data_secs:
                raise CompDocError(
                    "MSAT extension: accessing sector %d but only %d in file" % (sid, mem_data_secs)
                    )
            offset = 512 + sec_size * sid
            news = list(unpack(fmt, mem[offset:offset+sec_size]))
            sid = news.pop()
            MSAT.extend(news)
        if DEBUG:
            print("MSAT: len =", len(MSAT), file=logfile)
            print(MSAT, file=logfile)
        #
        # === build the SAT ===
        #
        self.SAT = []
        for msid in MSAT:
            if msid == FREESID: continue
            if msid >= mem_data_secs:
                if not trunc_warned:
                    print("WARNING *** File is truncated, or OLE2 MSAT is corrupt!!", file=logfile)
                    print("INFO: Trying to access sector %d but only %d available" \
                        % (msid, mem_data_secs), file=logfile)
                    trunc_warned = 1
                continue
            offset = 512 + sec_size * msid
            news = list(unpack(fmt, mem[offset:offset+sec_size]))
            self.SAT.extend(news)
        if DEBUG:
            print("SAT: len =", len(self.SAT), file=logfile)
            print(self.SAT, file=logfile)
            # print >> logfile, "SAT ",
            # for i, s in enumerate(self.SAT):
                # print >> logfile, "entry: %4d offset: %6d, next entry: %4d" % (i, 512 + sec_size * i, s)
                # print >> logfile, "%d:%d " % (i, s),
            print()

        # === build the directory ===
        #
        dbytes = self._get_stream(
            self.mem, 512, self.SAT, self.sec_size, self.dir_first_sec_sid,
            name="directory")
        dirlist = []
        did = -1
        for pos in range(0, len(dbytes), 128):
            did += 1
            dirlist.append(DirNode(did, dbytes[pos:pos+128], 0))
        self.dirlist = dirlist
        _build_family_tree(dirlist, 0, dirlist[0].root_DID) # and stand well back ...
        if DEBUG:
            for d in dirlist:
                d.dump(DEBUG)
        #
        # === get the SSCS ===
        #
        sscs_dir = self.dirlist[0]
        assert sscs_dir.etype == 5 # root entry
        if sscs_dir.first_SID < 0 and sscs_dir.tot_size == 0:
            # Problem reported by Frank Hoffsuemmer: some software was
            # writing -1 instead of -2 (EOCSID) for the first_SID
            # when the SCCS was empty. Not having EOCSID caused assertion
            # failure in _get_stream.
            # Solution: avoid calling _get_stream in any case when the
            # SCSS appears to be empty.
            self.SSCS = ""
        else:
            self.SSCS = self._get_stream(
                self.mem, 512, self.SAT, sec_size, sscs_dir.first_SID,
                sscs_dir.tot_size, name="SSCS")
        # if DEBUG: print >> logfile, "SSCS", repr(self.SSCS)
        #
        # === build the SSAT ===
        #
        self.SSAT = []
        if SSAT_tot_secs > 0 and sscs_dir.tot_size == 0:
            print("WARNING *** OLE2 inconsistency: SSCS size is 0 but SSAT size is non-zero", file=logfile)
        if sscs_dir.tot_size > 0:
            sid = SSAT_first_sec_sid
            nsecs = SSAT_tot_secs
            while sid >= 0 and nsecs > 0:
                nsecs -= 1
                start_pos = 512 + sid * sec_size
                news = list(unpack(fmt, mem[start_pos:start_pos+sec_size]))
                self.SSAT.extend(news)
                sid = self.SAT[sid]
            # assert SSAT_tot_secs == 0 or sid == EOCSID
            if DEBUG: print("SSAT last sid %d; remaining sectors %d" % (sid, nsecs), file=logfile)
            assert nsecs == 0 and sid == EOCSID
        if DEBUG: print("SSAT", self.SSAT, file=logfile)

    def _get_stream(self, mem, base, sat, sec_size, start_sid, size=None, name=''):
        # print >> self.logfile, "_get_stream", base, sec_size, start_sid, size
        sectors = []
        s = start_sid
        if size is None:
            # nothing to check against
            while s >= 0:
                start_pos = base + s * sec_size
                sectors.append(mem[start_pos:start_pos+sec_size])
                try:
                    s = sat[s]
                except IndexError:
                    raise CompDocError(
                        "OLE2 stream %r: sector allocation table invalid entry (%d)" %
                        (name, s)
                        )
            assert s == EOCSID
        else:
            todo = size
            while s >= 0:
                start_pos = base + s * sec_size
                grab = sec_size
                if grab > todo:
                    grab = todo
                todo -= grab
                sectors.append(mem[start_pos:start_pos+grab])
                try:
                    s = sat[s]
                except IndexError:
                    raise CompDocError(
                        "OLE2 stream %r: sector allocation table invalid entry (%d)" %
                        (name, s)
                        )
            assert s == EOCSID
            if todo != 0:
                print("WARNING *** OLE2 stream %r: expected size %d, actual size %d" \
                    % (name, size, size - todo), file=self.logfile)
        return b''.join(sectors)

    def _dir_search(self, path, storage_DID=0):
        # Return matching DirNode instance, or None
        head = path[0]
        tail = path[1:]
        dl = self.dirlist
        for child in dl[storage_DID].children:
            if dl[child].name.lower() == head.lower():
                et = dl[child].etype
                if et == 2:
                    return dl[child]
                if et == 1:
                    if not tail:
                        raise CompDocError("Requested component is a 'storage'")
                    return self._dir_search(tail, child)
                dl[child].dump(1)
                raise CompDocError("Requested stream is not a 'user stream'")
        return None

    ##
    # Interrogate the compound document's directory; return the stream as a string if found, otherwise
    # return None.
    # @param qname Name of the desired stream e.g. u'Workbook'. Should be in Unicode or convertible thereto.

    def get_named_stream(self, qname):
        d = self._dir_search(qname.split("/"))
        if d is None:
            return None
        if d.tot_size >= self.min_size_std_stream:
            return self._get_stream(
                self.mem, 512, self.SAT, self.sec_size, d.first_SID,
                d.tot_size, name=qname)
        else:
            return self._get_stream(
                self.SSCS, 0, self.SSAT, self.short_sec_size, d.first_SID,
                d.tot_size, name=qname + " (from SSCS)")

    # Interrogate the compound document's directory.
    # If the named stream is not found, (None, 0, 0) will be returned.
    # If the named stream is found and is contiguous within the original byte sequence ("mem")
    # used when the document was opened,
    # then (mem, offset_to_start_of_stream, length_of_stream) is returned.
    # Otherwise a new string is built from the fragments and (new_string, 0, length_of_stream) is returned.
    # @param qname Name of the desired stream e.g. u'Workbook'. Should be in Unicode or convertible thereto.

    def locate_named_stream(self, qname):
        d = self._dir_search(qname.split("/"))
        if d is None:
            return (None, 0, 0)
        if d.tot_size >= self.min_size_std_stream:
            return self._locate_stream(self.mem, 512, self.SAT, self.sec_size, d.first_SID, d.tot_size)
        else:
            return (
                self._get_stream(
                    self.SSCS, 0, self.SSAT, self.short_sec_size, d.first_SID,
                    d.tot_size, qname + " (from SSCS)"),
                0,
                d.tot_size
                )
        return (None, 0, 0) # not found

    def _locate_stream(self, mem, base, sat, sec_size, start_sid, size):
        # print >> self.logfile, "_locate_stream", base, sec_size, start_sid, size
        s = start_sid
        if s < 0:
            raise CompDocError("_locate_stream: start_sid (%d) is -ve" % start_sid)
        p = -99 # dummy previous SID
        start_pos = -9999
        end_pos = -8888
        slices = []
        while s >= 0:
            if s == p+1:
                # contiguous sectors
                end_pos += sec_size
            else:
                # start new slice
                if p >= 0:
                    # not first time
                    slices.append((start_pos, end_pos))
                start_pos = base + s * sec_size
                end_pos = start_pos + sec_size
            p = s
            s = sat[s]
        assert s == EOCSID
        # print >> self.logfile, len(slices) + 1, "slices"
        if not slices:
            # The stream is contiguous ... just what we like!
            return (mem, start_pos, size)
        slices.append((start_pos, end_pos))
        return (b''.join([mem[start_pos:end_pos] for start_pos, end_pos in slices]), 0, size)

########NEW FILE########
__FILENAME__ = formatting
# Module for formatting information.
#
# Copyright  2005-2008 Stephen John Machin, Lingfo Pty Ltd
# Copyright  2005-2009 Stephen John Machin, Lingfo Pty Ltd
# This module is part of the xlrd3 package, which is released under
# a BSD-style licence.

# No part of the content of this file was derived from the works of David Giffin.

# 2009-05-31 SJM Fixed problem with non-zero reserved bits in some STYLE records in Mac Excel files
# 2008-08-03 SJM Ignore PALETTE record when Book.formatting_info is false
# 2008-08-03 SJM Tolerate up to 4 bytes trailing junk on PALETTE record
# 2008-05-10 SJM Do some XF checks only when Book.formatting_info is true
# 2008-02-08 SJM Preparation for Excel 2.0 support
# 2008-02-03 SJM Another tweak to is_date_format_string()
# 2007-12-04 SJM Added support for Excel 2.x (BIFF2) files.
# 2007-10-13 SJM Warning: style XF whose parent XF index != 0xFFF
# 2007-09-08 SJM Work around corrupt STYLE record
# 2007-07-11 SJM Allow for BIFF2/3-style FORMAT record in BIFF4/8 file

DEBUG = False
import copy
import re
from struct import unpack

from .biffh import BaseObject, unpack_unicode, unpack_string, \
    upkbits, upkbitsL, fprintf, \
    FUN, FDT, FNU, FGE, FTX, XL_CELL_NUMBER, XL_CELL_DATE, \
    XL_FORMAT, XL_FORMAT2, \
    XLRDError


excel_default_palette_b5 = (
    (  0,   0,   0), (255, 255, 255), (255,   0,   0), (  0, 255,   0),
    (  0,   0, 255), (255, 255,   0), (255,   0, 255), (  0, 255, 255),
    (128,   0,   0), (  0, 128,   0), (  0,   0, 128), (128, 128,   0),
    (128,   0, 128), (  0, 128, 128), (192, 192, 192), (128, 128, 128),
    (153, 153, 255), (153,  51, 102), (255, 255, 204), (204, 255, 255),
    (102,   0, 102), (255, 128, 128), (  0, 102, 204), (204, 204, 255),
    (  0,   0, 128), (255,   0, 255), (255, 255,   0), (  0, 255, 255),
    (128,   0, 128), (128,   0,   0), (  0, 128, 128), (  0,   0, 255),
    (  0, 204, 255), (204, 255, 255), (204, 255, 204), (255, 255, 153),
    (153, 204, 255), (255, 153, 204), (204, 153, 255), (227, 227, 227),
    ( 51, 102, 255), ( 51, 204, 204), (153, 204,   0), (255, 204,   0),
    (255, 153,   0), (255, 102,   0), (102, 102, 153), (150, 150, 150),
    (  0,  51, 102), ( 51, 153, 102), (  0,  51,   0), ( 51,  51,   0),
    (153,  51,   0), (153,  51, 102), ( 51,  51, 153), ( 51,  51,  51),
    )

excel_default_palette_b2 = excel_default_palette_b5[:16]

# Following two tables borrowed from Gnumeric 1.4 source.
excel_default_palette_b5_gnumeric_14 = (
    #### dodgy; didn't match Excel results
    (  0,  0,  0), (255,255,255), (255,  0,  0), (  0,255,  0),
    (  0,  0,255), (255,255,  0), (255,  0,255), (  0,255,255),
    (128,  0,  0), (  0,128,  0), (  0,  0,128), (128,128,  0),
    (128,  0,128), (  0,128,128), (192,192,192), (128,128,128),
    (128,128,255), (128, 32, 96), (255,255,192), (160,224,224),
    ( 96,  0,128), (255,128,128), (  0,128,192), (192,192,255),
    (  0,  0,128), (255,  0,255), (255,255,  0), (  0,255,255),
    (128,  0,128), (128,  0,  0), (  0,128,128), (  0,  0,255),
    (  0,204,255), (105,255,255), (204,255,204), (255,255,153),
    (166,202,240), (204,156,204), (204,153,255), (227,227,227),
    ( 51,102,255), ( 51,204,204), ( 51,153, 51), (153,153, 51),
    (153,102, 51), (153,102,102), (102,102,153), (150,150,150),
    ( 51, 51,204), ( 51,102,102), (  0, 51,  0), ( 51, 51,  0),
    (102, 51,  0), (153, 51,102), ( 51, 51,153), ( 66, 66, 66),
    )
excel_default_palette_b8 = ( # (red, green, blue)
    (  0,  0,  0), (255,255,255), (255,  0,  0), (  0,255,  0),
    (  0,  0,255), (255,255,  0), (255,  0,255), (  0,255,255),
    (128,  0,  0), (  0,128,  0), (  0,  0,128), (128,128,  0),
    (128,  0,128), (  0,128,128), (192,192,192), (128,128,128),
    (153,153,255), (153, 51,102), (255,255,204), (204,255,255),
    (102,  0,102), (255,128,128), (  0,102,204), (204,204,255),
    (  0,  0,128), (255,  0,255), (255,255,  0), (  0,255,255),
    (128,  0,128), (128,  0,  0), (  0,128,128), (  0,  0,255),
    (  0,204,255), (204,255,255), (204,255,204), (255,255,153),
    (153,204,255), (255,153,204), (204,153,255), (255,204,153),
    ( 51,102,255), ( 51,204,204), (153,204,  0), (255,204,  0),
    (255,153,  0), (255,102,  0), (102,102,153), (150,150,150),
    (  0, 51,102), ( 51,153,102), (  0, 51,  0), ( 51, 51,  0),
    (153, 51,  0), (153, 51,102), ( 51, 51,153), ( 51, 51, 51),
    )

default_palette = {
    80: excel_default_palette_b8,
    70: excel_default_palette_b5,
    50: excel_default_palette_b5,
    45: excel_default_palette_b2,
    40: excel_default_palette_b2,
    30: excel_default_palette_b2,
    21: excel_default_palette_b2,
    20: excel_default_palette_b2,
    }

"""
00H = Normal
01H = RowLevel_lv (see next field)
02H = ColLevel_lv (see next field)
03H = Comma
04H = Currency
05H = Percent
06H = Comma [0] (BIFF4-BIFF8)
07H = Currency [0] (BIFF4-BIFF8)
08H = Hyperlink (BIFF8)
09H = Followed Hyperlink (BIFF8)
"""
built_in_style_names = [
    "Normal",
    "RowLevel_",
    "ColLevel_",
    "Comma",
    "Currency",
    "Percent",
    "Comma [0]",
    "Currency [0]",
    "Hyperlink",
    "Followed Hyperlink",
    ]

def initialise_colour_map(book):
    book.colour_map = {}
    book.colour_indexes_used = {}
    if not book.formatting_info:
        return
    # Add the 8 invariant colours
    for i in range(8):
        book.colour_map[i] = excel_default_palette_b8[i]
    # Add the default palette depending on the version
    dpal = default_palette[book.biff_version]
    ndpal = len(dpal)
    for i in range(ndpal):
        book.colour_map[i+8] = dpal[i]
    # Add the specials -- None means the RGB value is not known
    # System window text colour for border lines
    book.colour_map[ndpal+8] = None
    # System window background colour for pattern background
    book.colour_map[ndpal+8+1] = None #
    for ci in (
        0x51, # System ToolTip text colour (used in note objects)
        0x7FFF, # 32767, system window text colour for fonts
        ):
        book.colour_map[ci] = None

def nearest_colour_index(colour_map, rgb, debug=0):
    # General purpose function. Uses Euclidean distance.
    # So far used only for pre-BIFF8 WINDOW2 record.
    # Doesn't have to be fast.
    # Doesn't have to be fancy.
    best_metric = 3 * 256 * 256
    best_colourx = 0
    for colourx, cand_rgb in list(colour_map.items()):
        if cand_rgb is None:
            continue
        metric = 0
        for v1, v2 in zip(rgb, cand_rgb):
            metric += (v1 - v2) * (v1 - v2)
        if metric < best_metric:
            best_metric = metric
            best_colourx = colourx
            if metric == 0:
                break
    if debug:
        print("nearest_colour_index for %r is %r -> %r; best_metric is %d" \
            % (rgb, best_colourx, colour_map[best_colourx], best_metric))
    return best_colourx

# This mixin class exists solely so that Format, Font, and XF.... objects
# can be compared by value of their attributes.
class EqNeAttrs(object):

    def __eq__(self, other):
        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        return self.__dict__ != other.__dict__

# An Excel "font" contains the details of not only what is normally
# considered a font, but also several other display attributes.
# Items correspond to those in the Excel UI's Format/Cells/Font tab.
# - New in version 0.6.1
class Font(BaseObject, EqNeAttrs):
    # 1 = Characters are bold. Redundant; see "weight" attribute.
    bold = 0

    # Values: 0 = ANSI Latin, 1 = System default, 2 = Symbol,
    # 77 = Apple Roman,
    # 128 = ANSI Japanese Shift-JIS,
    # 129 = ANSI Korean (Hangul),
    # 130 = ANSI Korean (Johab),
    # 134 = ANSI Chinese Simplified GBK,
    # 136 = ANSI Chinese Traditional BIG5,
    # 161 = ANSI Greek,
    # 162 = ANSI Turkish,
    # 163 = ANSI Vietnamese,
    # 177 = ANSI Hebrew,
    # 178 = ANSI Arabic,
    # 186 = ANSI Baltic,
    # 204 = ANSI Cyrillic,
    # 222 = ANSI Thai,
    # 238 = ANSI Latin II (Central European),
    # 255 = OEM Latin I
    character_set = 0
    # An explanation of "colour index" is given in the Formatting
    # section at the start of this document.
    colour_index = 0
    # 1 = Superscript, 2 = Subscript.
    escapement = 0
    # 0 = None (unknown or don't care)<br />
    # 1 = Roman (variable width, serifed)<br />
    # 2 = Swiss (variable width, sans-serifed)<br />
    # 3 = Modern (fixed width, serifed or sans-serifed)<br />
    # 4 = Script (cursive)<br />
    # 5 = Decorative (specialised, for example Old English, Fraktur)
    family = 0
    # The 0-based index used to refer to this Font() instance.
    # Note that index 4 is never used; xlrd supplies a dummy place-holder.
    font_index = 0
    # Height of the font (in twips). A twip = 1/20 of a point.
    height = 0
    # 1 = Characters are italic.
    italic = 0
    # The name of the font. Example: u"Arial"
    name = ""
    # 1 = Characters are struck out.
    struck_out = 0
    # 0 = None<br />
    # 1 = Single;  0x21 (33) = Single accounting<br />
    # 2 = Double;  0x22 (34) = Double accounting
    underline_type = 0
    # 1 = Characters are underlined. Redundant; see "underline_type" attribute.
    underlined = 0
    # Font weight (100-1000). Standard values are 400 for normal text
    # and 700 for bold text.
    weight = 400
    # 1 = Font is outline style (Macintosh only)
    outline = 0
    # 1 = Font is shadow style (Macintosh only)
    shadow = 0

    # No methods ...

def handle_efont(book, data): # BIFF2 only
    if not book.formatting_info:
        return
    book.font_list[-1].colour_index = unpack('<H', data)[0]

def handle_font(book, data):
    if not book.formatting_info:
        return
    if not book.encoding:
        book.derive_encoding()
    verbose = DEBUG or book.verbosity >= 2
    bv = book.biff_version
    k = len(book.font_list)
    if k == 4:
        f = Font()
        f.name = 'Dummy Font'
        f.font_index = k
        book.font_list.append(f)
        k += 1
    f = Font()
    f.font_index = k
    book.font_list.append(f)
    if bv >= 50:
        (
            f.height, option_flags, f.colour_index, f.weight,
            f.escapement_type, f.underline_type, f.family,
            f.character_set,
        ) = unpack('<HHHHHBBB', data[0:13])
        f.bold = option_flags & 1
        f.italic = (option_flags & 2) >> 1
        f.underlined = (option_flags & 4) >> 2
        f.struck_out = (option_flags & 8) >> 3
        f.outline = (option_flags & 16) >> 4
        f.shadow = (option_flags & 32) >> 5
        if bv >= 80:
            f.name = unpack_unicode(data, 14, lenlen=1)
        else:
            f.name = unpack_string(data, 14, book.encoding, lenlen=1)
    elif bv >= 30:
        f.height, option_flags, f.colour_index = unpack('<HHH', data[0:6])
        f.bold = option_flags & 1
        f.italic = (option_flags & 2) >> 1
        f.underlined = (option_flags & 4) >> 2
        f.struck_out = (option_flags & 8) >> 3
        f.outline = (option_flags & 16) >> 4
        f.shadow = (option_flags & 32) >> 5
        f.name = unpack_string(data, 6, book.encoding, lenlen=1)
        # Now cook up the remaining attributes ...
        f.weight = [400, 700][f.bold]
        f.escapement_type = 0 # None
        f.underline_type = f.underlined # None or Single
        f.family = 0 # Unknown / don't care
        f.character_set = 1 # System default (0 means "ANSI Latin")
    else: # BIFF2
        f.height, option_flags = unpack('<HH', data[0:4])
        f.colour_index = 0x7FFF # "system window text colour"
        f.bold = option_flags & 1
        f.italic = (option_flags & 2) >> 1
        f.underlined = (option_flags & 4) >> 2
        f.struck_out = (option_flags & 8) >> 3
        f.outline = 0
        f.shadow = 0
        f.name = unpack_string(data, 4, book.encoding, lenlen=1)
        # Now cook up the remaining attributes ...
        f.weight = [400, 700][f.bold]
        f.escapement_type = 0 # None
        f.underline_type = f.underlined # None or Single
        f.family = 0 # Unknown / don't care
        f.character_set = 1 # System default (0 means "ANSI Latin")
    if verbose:
        f.dump(
            book.logfile,
            header="--- handle_font: font[%d] ---" % f.font_index,
            footer="-------------------",
            )

# === "Number formats" ===

# "Number format" information from a FORMAT record.
# - New in version 0.6.1
class Format(BaseObject, EqNeAttrs):

    # The key into Book.format_map
    format_key = 0

    # A classification that has been inferred from the format string.
    # Currently, this is used only to distinguish between numbers and dates.
    # Values:
    # FUN = 0 # unknown
    # FDT = 1 # date
    # FNU = 2 # number
    # FGE = 3 # general
    # FTX = 4 # text
    type = FUN

    # The format string
    format_str = ''

    def __init__(self, format_key, ty, format_str):
        self.format_key = format_key
        self.type = ty
        self.format_str = format_str

std_format_strings = {
    # "std" == "standard for US English locale"
    # #### TODO ... a lot of work to tailor these to the user's locale.
    # See e.g. gnumeric-1.x.y/src/formats.c
    0x00: "General",
    0x01: "0",
    0x02: "0.00",
    0x03: "#,##0",
    0x04: "#,##0.00",
    0x05: "$#,##0_);($#,##0)",
    0x06: "$#,##0_);[Red]($#,##0)",
    0x07: "$#,##0.00_);($#,##0.00)",
    0x08: "$#,##0.00_);[Red]($#,##0.00)",
    0x09: "0%",
    0x0a: "0.00%",
    0x0b: "0.00E+00",
    0x0c: "# ?/?",
    0x0d: "# ??/??",
    0x0e: "m/d/yy",
    0x0f: "d-mmm-yy",
    0x10: "d-mmm",
    0x11: "mmm-yy",
    0x12: "h:mm AM/PM",
    0x13: "h:mm:ss AM/PM",
    0x14: "h:mm",
    0x15: "h:mm:ss",
    0x16: "m/d/yy h:mm",
    0x25: "#,##0_);(#,##0)",
    0x26: "#,##0_);[Red](#,##0)",
    0x27: "#,##0.00_);(#,##0.00)",
    0x28: "#,##0.00_);[Red](#,##0.00)",
    0x29: "_(* #,##0_);_(* (#,##0);_(* \"-\"_);_(@_)",
    0x2a: "_($* #,##0_);_($* (#,##0);_($* \"-\"_);_(@_)",
    0x2b: "_(* #,##0.00_);_(* (#,##0.00);_(* \"-\"??_);_(@_)",
    0x2c: "_($* #,##0.00_);_($* (#,##0.00);_($* \"-\"??_);_(@_)",
    0x2d: "mm:ss",
    0x2e: "[h]:mm:ss",
    0x2f: "mm:ss.0",
    0x30: "##0.0E+0",
    0x31: "@",
    }

fmt_code_ranges = [ # both-inclusive ranges of "standard" format codes
    # Source: the openoffice.org doc't
    ( 0,  0, FGE),
    ( 1, 13, FNU),
    (14, 22, FDT),
    #### (27, 36, FDT), # Japanese dates -- not sure of reliability of this
    (37, 44, FNU),
    (45, 47, FDT),
    (48, 48, FNU),
    (49, 49, FTX),
    ####(50, 58, FDT), # Japanese dates -- but Gnumeric assumes
                       # built-in formats finish at 49, not at 163
    ]

std_format_code_types = {}
for lo, hi, ty in fmt_code_ranges:
    for x in range(lo, hi+1):
        std_format_code_types[x] = ty
del lo, hi, ty, x

date_chars = 'ymdhs' # year, month/minute, day, hour, second
date_char_dict = {}
for _c in date_chars + date_chars.upper():
    date_char_dict[_c] = 5
del _c, date_chars

#(to_py3):
skip_char_dict = frozenset('$-+/(): ')

num_char_dict = {
    '0': 5,
    '#': 5,
    '?': 5,
    }

non_date_formats = {
    '0.00E+00':1,
    '##0.0E+0':1,
    'General' :1,
    'GENERAL' :1, # OOo Calc 1.1.4 does this.
    'general' :1,  # pyExcelerator 0.6.3 does this.
    '@'       :1,
    }

fmt_bracketed_sub = re.compile(r'\[[^]]*\]').sub

# Boolean format strings (actual cases)
# u'"Yes";"Yes";"No"'
# u'"True";"True";"False"'
# u'"On";"On";"Off"'

def is_date_format_string(book, fmt):
    # Heuristics:
    # Ignore "text" and [stuff in square brackets (aarrgghh -- see below)].
    # Handle backslashed-escaped chars properly.
    # E.g. hh\hmm\mss\s should produce a display like 23h59m59s
    # Date formats have one or more of ymdhs (caseless) in them.
    # Numeric formats have # and 0.
    # N.B. u'General"."' hence get rid of "text" first.
    # TODO: Find where formats are interpreted in Gnumeric
    # TODO: u'[h]\\ \\h\\o\\u\\r\\s' ([h] means don't care about hours > 23)
    state = 0
    s = ''
    # (to_py3): ignorable = skip_char_dict.has_key
    for c in fmt:
        if state == 0:
            if c == '"':
                state = 1
            elif c in r"\_*":
                state = 2
            elif c in skip_char_dict: # (to_py3):
                pass
            else:
                s += c
        elif state == 1:
            if c == '"':
                state = 0
        elif state == 2:
            # Ignore char after backslash, underscore or asterisk
            state = 0
        assert 0 <= state <= 2
    if book.verbosity >= 4:
        print("is_date_format_string: reduced format is %r" % s)
    s = fmt_bracketed_sub('', s)
    if s in non_date_formats:
        return False
    state = 0
    separator = ";"
    got_sep = 0
    date_count = num_count = 0
    for c in s:
        if c in date_char_dict:
            date_count += date_char_dict[c]
        elif c in num_char_dict:
            num_count += num_char_dict[c]
        elif c == separator:
            got_sep = 1
    # print num_count, date_count, repr(fmt)
    if date_count and not num_count:
        return True
    if num_count and not date_count:
        return False
    if date_count:
        fprintf(book.logfile,
            'WARNING *** is_date_format: ambiguous d=%d n=%d fmt=%r\n',
            date_count, num_count, fmt)
    elif not got_sep:
        fprintf(book.logfile,
            "WARNING *** format %r produces constant result\n",
            fmt)
    return date_count > num_count

def handle_format(self, data, rectype=XL_FORMAT):
    DEBUG = 0
    bv = self.biff_version
    if rectype == XL_FORMAT2:
        bv = min(bv, 30)
    if not self.encoding:
        self.derive_encoding()
    strpos = 2
    if bv >= 50:
        fmtkey = unpack('<H', data[0:2])[0]
    else:
        fmtkey = self.actualfmtcount
        if bv <= 30:
            strpos = 0
    self.actualfmtcount += 1
    if bv >= 80:
        unistrg = unpack_unicode(data, 2)
    else:
        unistrg = unpack_string(data, strpos, self.encoding, lenlen=1)
    verbose = DEBUG or self.verbosity >= 3
    if verbose:
        fprintf(self.logfile,
            "FORMAT: count=%d fmtkey=0x%04x (%d) s=%r\n",
            self.actualfmtcount, fmtkey, fmtkey, unistrg)
    is_date_s = self.is_date_format_string(unistrg)
    ty = [FGE, FDT][is_date_s]
    if not(fmtkey > 163 or bv < 50):
        # user_defined if fmtkey > 163
        # N.B. Gnumeric incorrectly starts these at 50 instead of 164 :-(
        # if earlier than BIFF 5, standard info is useless
        std_ty = std_format_code_types.get(fmtkey, FUN)
        # print "std ty", std_ty
        is_date_c = std_ty == FDT
        if 0 < fmtkey < 50 and (is_date_c ^ is_date_s):
            DEBUG = 2
            fprintf(self.logfile,
                "WARNING *** Conflict between "
                "std format key %d and its format string %r\n",
                fmtkey, unistrg)
    if DEBUG == 2:
        fprintf(self.logfile,
            "ty: %d; is_date_c: %r; is_date_s: %r; fmt_strg: %r",
            ty, is_date_c, is_date_s, unistrg)
    fmtobj = Format(fmtkey, ty, unistrg)
    if verbose:
        fmtobj.dump(self.logfile,
            header="--- handle_format [%d] ---" % (self.actualfmtcount-1, ))
    self.format_map[fmtkey] = fmtobj
    self.format_list.append(fmtobj)

# =============================================================================

def handle_palette(book, data):
    if not book.formatting_info:
        return
    verbose = DEBUG or book.verbosity >= 2
    n_colours, = unpack('<H', data[:2])
    expected_n_colours = (16, 56)[book.biff_version >= 50]
    if ((DEBUG or book.verbosity >= 1)
    and n_colours != expected_n_colours):
        fprintf(book.logfile,
            "NOTE *** Expected %d colours in PALETTE record, found %d\n",
            expected_n_colours, n_colours)
    elif verbose:
        fprintf(book.logfile,
            "PALETTE record with %d colours\n", n_colours)
    fmt = '<xx%di' % n_colours # use i to avoid long integers
    expected_size = 4 * n_colours + 2
    actual_size = len(data)
    tolerance = 4
    if not expected_size <= actual_size <= expected_size + tolerance:
        raise XLRDError('PALETTE record: expected size %d, actual size %d' % (expected_size, actual_size))
    colours = unpack(fmt, data[:expected_size])
    assert book.palette_record == [] # There should be only 1 PALETTE record
    # a colour will be 0xbbggrr
    # IOW, red is at the little end
    for i in range(n_colours):
        c = colours[i]
        red   =  c        & 0xff
        green = (c >>  8) & 0xff
        blue  = (c >> 16) & 0xff
        old_rgb = book.colour_map[8+i]
        new_rgb = (red, green, blue)
        book.palette_record.append(new_rgb)
        book.colour_map[8+i] = new_rgb
        if verbose:
            if new_rgb != old_rgb:
                print("%2d: %r -> %r" % (i, old_rgb, new_rgb), file=book.logfile)

def palette_epilogue(book):
    # Check colour indexes in fonts etc.
    # This must be done here as FONT records
    # come *before* the PALETTE record :-(
    for font in book.font_list:
        if font.font_index == 4: # the missing font record
            continue
        cx = font.colour_index
        if cx == 0x7fff: # system window text colour
            continue
        if cx in book.colour_map:
            book.colour_indexes_used[cx] = 1
        else:
            print("Size of colour table:", len(book.colour_map))
            print("*** Font #%d (%r): colour index 0x%04x is unknown" \
                % (font.font_index, font.name, cx), file=book.logfile)
    if book.verbosity >= 1:
        used = list(book.colour_indexes_used.keys())
        used.sort()
        print("\nColour indexes used:\n%r\n" % used, file=book.logfile)

def handle_style(book, data):
    verbose = DEBUG or book.verbosity >= 2
    bv = book.biff_version
    flag_and_xfx, built_in_id, level = unpack('<HBB', data[:4])
    xf_index = flag_and_xfx & 0x0fff
    if (data == "\0\0\0\0"
    and "Normal" not in book.style_name_map):
        # Erroneous record (doesn't have built-in bit set).
        # Example file supplied by Jeff Bell.
        built_in = 1
        built_in_id = 0
        xf_index = 0
        name = "Normal"
        level = 255
    elif flag_and_xfx & 0x8000:
        # built-in style
        built_in = 1
        name = built_in_style_names[built_in_id]
        if 1 <= built_in_id <= 2:
            name += str(level + 1)
    else:
        # user-defined style
        if bv >= 80:
            name = unpack_unicode(data, 2, lenlen=2)
        else:
            name = unpack_string(data, 2, book.encoding, lenlen=1)
        if verbose and not name:
            print("WARNING *** A user-defined style has a zero-length name", file=book.logfile)
        built_in = 0
        built_in_id = 0
        level = 0
    book.style_name_map[name] = (built_in, xf_index)
    if verbose:
        print("STYLE: built_in=%d xf_index=%d built_in_id=%d level=%d name=%r" \
            % (built_in, xf_index, built_in_id, level, name), file=book.logfile)

def check_colour_indexes_in_obj(book, obj, orig_index):
    alist = list(obj.__dict__.items())
    alist.sort()
    for attr, nobj in alist:
        if hasattr(nobj, 'dump'):
            check_colour_indexes_in_obj(book, nobj, orig_index)
        elif attr.find('colour_index') >= 0:
            if nobj in book.colour_map:
                book.colour_indexes_used[nobj] = 1
                continue
            oname = obj.__class__.__name__
            print("*** xf #%d : %s.%s =  0x%04x (unknown)" \
                % (orig_index, oname, attr, nobj), file=book.logfile)

def handle_xf(self, data):
    ### self is a Book instance
    # DEBUG = 0
    verbose = DEBUG or self.verbosity >= 3
    bv = self.biff_version
    xf = XF()
    xf.alignment = XFAlignment()
    xf.alignment.indent_level = 0
    xf.alignment.shrink_to_fit = 0
    xf.alignment.text_direction = 0
    xf.border = XFBorder()
    xf.border.diag_up = 0
    xf.border.diag_down = 0
    xf.border.diag_colour_index = 0
    xf.border.diag_line_style = 0 # no line
    xf.background = XFBackground()
    xf.protection = XFProtection()
    # fill in the known standard formats
    if bv >= 50 and not self.xfcount:
        # i.e. do this once before we process the first XF record
        for x in list(std_format_code_types.keys()):
            if x not in self.format_map:
                ty = std_format_code_types[x]
                fmt_str = std_format_strings[x]
                fmtobj = Format(x, ty, fmt_str)
                self.format_map[x] = fmtobj
    if bv >= 80:
        unpack_fmt = '<HHHBBBBIiH'
        (xf.font_index, xf.format_key, pkd_type_par,
        pkd_align1, xf.alignment.rotation, pkd_align2,
        pkd_used, pkd_brdbkg1, pkd_brdbkg2, pkd_brdbkg3,
        ) = unpack(unpack_fmt, data[0:20])
        upkbits(xf.protection, pkd_type_par, (
            (0, 0x01, 'cell_locked'),
            (1, 0x02, 'formula_hidden'),
            ))
        upkbits(xf, pkd_type_par, (
            (2, 0x0004, 'is_style'),
            # Following is not in OOo docs, but is mentioned
            # in Gnumeric source and also in (deep breath)
            # org.apache.poi.hssf.record.ExtendedFormatRecord.java
            (3, 0x0008, 'lotus_123_prefix'), # Meaning is not known.
            (4, 0xFFF0, 'parent_style_index'),
            ))
        upkbits(xf.alignment, pkd_align1, (
            (0, 0x07, 'hor_align'),
            (3, 0x08, 'text_wrapped'),
            (4, 0x70, 'vert_align'),
            ))
        upkbits(xf.alignment, pkd_align2, (
            (0, 0x0f, 'indent_level'),
            (4, 0x10, 'shrink_to_fit'),
            (6, 0xC0, 'text_direction'),
            ))
        reg = pkd_used >> 2
        for attr_stem in \
            "format font alignment border background protection".split():
            attr = "_" + attr_stem + "_flag"
            setattr(xf, attr, reg & 1)
            reg >>= 1
        upkbitsL(xf.border, pkd_brdbkg1, (
            (0,  0x0000000f,  'left_line_style'),
            (4,  0x000000f0,  'right_line_style'),
            (8,  0x00000f00,  'top_line_style'),
            (12, 0x0000f000,  'bottom_line_style'),
            (16, 0x007f0000,  'left_colour_index'),
            (23, 0x3f800000,  'right_colour_index'),
            (30, 0x40000000,  'diag_down'),
            (31, 0x80000000, 'diag_up'),
            ))
        upkbits(xf.border, pkd_brdbkg2, (
            (0,  0x0000007F, 'top_colour_index'),
            (7,  0x00003F80, 'bottom_colour_index'),
            (14, 0x001FC000, 'diag_colour_index'),
            (21, 0x01E00000, 'diag_line_style'),
            ))
        upkbitsL(xf.background, pkd_brdbkg2, (
            (26, 0xFC000000, 'fill_pattern'),
            ))
        upkbits(xf.background, pkd_brdbkg3, (
            (0, 0x007F, 'pattern_colour_index'),
            (7, 0x3F80, 'background_colour_index'),
            ))
    elif bv >= 50:
        unpack_fmt = '<HHHBBIi'
        (xf.font_index, xf.format_key, pkd_type_par,
        pkd_align1, pkd_orient_used,
        pkd_brdbkg1, pkd_brdbkg2,
        ) = unpack(unpack_fmt, data[0:16])
        upkbits(xf.protection, pkd_type_par, (
            (0, 0x01, 'cell_locked'),
            (1, 0x02, 'formula_hidden'),
            ))
        upkbits(xf, pkd_type_par, (
            (2, 0x0004, 'is_style'),
            (3, 0x0008, 'lotus_123_prefix'), # Meaning is not known.
            (4, 0xFFF0, 'parent_style_index'),
            ))
        upkbits(xf.alignment, pkd_align1, (
            (0, 0x07, 'hor_align'),
            (3, 0x08, 'text_wrapped'),
            (4, 0x70, 'vert_align'),
            ))
        orientation = pkd_orient_used & 0x03
        xf.alignment.rotation = [0, 255, 90, 180][orientation]
        reg = pkd_orient_used >> 2
        for attr_stem in \
            "format font alignment border background protection".split():
            attr = "_" + attr_stem + "_flag"
            setattr(xf, attr, reg & 1)
            reg >>= 1
        upkbitsL(xf.background, pkd_brdbkg1, (
            ( 0, 0x0000007F, 'pattern_colour_index'),
            ( 7, 0x00003F80, 'background_colour_index'),
            (16, 0x003F0000, 'fill_pattern'),
            ))
        upkbitsL(xf.border, pkd_brdbkg1, (
            (22, 0x01C00000,  'bottom_line_style'),
            (25, 0xFE000000, 'bottom_colour_index'),
            ))
        upkbits(xf.border, pkd_brdbkg2, (
            ( 0, 0x00000007, 'top_line_style'),
            ( 3, 0x00000038, 'left_line_style'),
            ( 6, 0x000001C0, 'right_line_style'),
            ( 9, 0x0000FE00, 'top_colour_index'),
            (16, 0x007F0000, 'left_colour_index'),
            (23, 0x3F800000, 'right_colour_index'),
            ))
    elif bv >= 40:
        unpack_fmt = '<BBHBBHI'
        (xf.font_index, xf.format_key, pkd_type_par,
        pkd_align_orient, pkd_used,
        pkd_bkg_34, pkd_brd_34,
        ) = unpack(unpack_fmt, data[0:12])
        upkbits(xf.protection, pkd_type_par, (
            (0, 0x01, 'cell_locked'),
            (1, 0x02, 'formula_hidden'),
            ))
        upkbits(xf, pkd_type_par, (
            (2, 0x0004, 'is_style'),
            (3, 0x0008, 'lotus_123_prefix'), # Meaning is not known.
            (4, 0xFFF0, 'parent_style_index'),
            ))
        upkbits(xf.alignment, pkd_align_orient, (
            (0, 0x07, 'hor_align'),
            (3, 0x08, 'text_wrapped'),
            (4, 0x30, 'vert_align'),
            ))
        orientation = (pkd_align_orient & 0xC0) >> 6
        xf.alignment.rotation = [0, 255, 90, 180][orientation]
        reg = pkd_used >> 2
        for attr_stem in \
            "format font alignment border background protection".split():
            attr = "_" + attr_stem + "_flag"
            setattr(xf, attr, reg & 1)
            reg >>= 1
        upkbits(xf.background, pkd_bkg_34, (
            ( 0, 0x003F, 'fill_pattern'),
            ( 6, 0x07C0, 'pattern_colour_index'),
            (11, 0xF800, 'background_colour_index'),
            ))
        upkbitsL(xf.border, pkd_brd_34, (
            ( 0, 0x00000007,  'top_line_style'),
            ( 3, 0x000000F8,  'top_colour_index'),
            ( 8, 0x00000700,  'left_line_style'),
            (11, 0x0000F800,  'left_colour_index'),
            (16, 0x00070000,  'bottom_line_style'),
            (19, 0x00F80000,  'bottom_colour_index'),
            (24, 0x07000000,  'right_line_style'),
            (27, 0xF8000000, 'right_colour_index'),
            ))
    elif bv == 30:
        unpack_fmt = '<BBBBHHI'
        (xf.font_index, xf.format_key, pkd_type_prot,
        pkd_used, pkd_align_par,
        pkd_bkg_34, pkd_brd_34,
        ) = unpack(unpack_fmt, data[0:12])
        upkbits(xf.protection, pkd_type_prot, (
            (0, 0x01, 'cell_locked'),
            (1, 0x02, 'formula_hidden'),
            ))
        upkbits(xf, pkd_type_prot, (
            (2, 0x0004, 'is_style'),
            (3, 0x0008, 'lotus_123_prefix'), # Meaning is not known.
            ))
        upkbits(xf.alignment, pkd_align_par, (
            (0, 0x07, 'hor_align'),
            (3, 0x08, 'text_wrapped'),
            ))
        upkbits(xf, pkd_align_par, (
            (4, 0xFFF0, 'parent_style_index'),
            ))
        reg = pkd_used >> 2
        for attr_stem in \
            "format font alignment border background protection".split():
            attr = "_" + attr_stem + "_flag"
            setattr(xf, attr, reg & 1)
            reg >>= 1
        upkbits(xf.background, pkd_bkg_34, (
            ( 0, 0x003F, 'fill_pattern'),
            ( 6, 0x07C0, 'pattern_colour_index'),
            (11, 0xF800, 'background_colour_index'),
            ))
        upkbitsL(xf.border, pkd_brd_34, (
            ( 0, 0x00000007,  'top_line_style'),
            ( 3, 0x000000F8,  'top_colour_index'),
            ( 8, 0x00000700,  'left_line_style'),
            (11, 0x0000F800,  'left_colour_index'),
            (16, 0x00070000,  'bottom_line_style'),
            (19, 0x00F80000,  'bottom_colour_index'),
            (24, 0x07000000,  'right_line_style'),
            (27, 0xF8000000, 'right_colour_index'),
            ))
        xf.alignment.vert_align = 2 # bottom
        xf.alignment.rotation = 0
    elif bv == 21:
        #### Warning: incomplete treatment; formatting_info not fully supported.
        #### Probably need to offset incoming BIFF2 XF[n] to BIFF8-like XF[n+16],
        #### and create XF[0:16] like the standard ones in BIFF8
        #### *AND* add 16 to all XF references in cell records :-(
        (xf.font_index, format_etc, halign_etc) = unpack('<BxBB', data)
        xf.format_key = format_etc & 0x3F
        upkbits(xf.protection, format_etc, (
            (6, 0x40, 'cell_locked'),
            (7, 0x80, 'formula_hidden'),
            ))
        upkbits(xf.alignment, halign_etc, (
            (0, 0x07, 'hor_align'),
            ))
        for mask, side in ((0x08, 'left'), (0x10, 'right'), (0x20, 'top'), (0x40, 'bottom')):
            if halign_etc & mask:
                colour_index, line_style = 8, 1 # black, thin
            else:
                colour_index, line_style = 0, 0 # none, none
            setattr(xf.border, side + '_colour_index', colour_index)
            setattr(xf.border, side + '_line_style', line_style)
        bg = xf.background
        if halign_etc & 0x80:
            bg.fill_pattern = 17
        else:
            bg.fill_pattern = 0
        bg.background_colour_index = 9 # white
        bg.pattern_colour_index = 8 # black
        xf.parent_style_index = 0 # ???????????
        xf.alignment.vert_align = 2 # bottom
        xf.alignment.rotation = 0
        for attr_stem in \
            "format font alignment border background protection".split():
            attr = "_" + attr_stem + "_flag"
            setattr(xf, attr, 1)
    else:
        raise XLRDError('programmer stuff-up: bv=%d' % bv)

    xf.xf_index = len(self.xf_list)
    self.xf_list.append(xf)
    self.xfcount += 1
    if verbose:
        xf.dump(
            self.logfile,
            header="--- handle_xf: xf[%d] ---" % xf.xf_index,
            footer=" ",
        )
    # Now for some assertions ...
    if self.formatting_info:
        if xf.is_style and xf.parent_style_index != 0x0FFF:
            msg = "WARNING *** XF[%d] is a style XF but parent_style_index is 0x%04x, not 0x0fff\n"
            fprintf(self.logfile, msg, xf.xf_index, xf.parent_style_index)
        check_colour_indexes_in_obj(self, xf, xf.xf_index)
    if xf.format_key not in self.format_map:
        msg = "WARNING *** XF[%d] unknown (raw) format key (%d, 0x%04x)\n"
        fprintf(self.logfile, msg,
                xf.xf_index, xf.format_key, xf.format_key)
        xf.format_key = 0

def xf_epilogue(self):
    # self is a Book instance.
    self._xf_epilogue_done = 1
    num_xfs = len(self.xf_list)
    verbose = DEBUG or self.verbosity >= 3
    verbose1 = DEBUG or self.verbosity >= 1
    if verbose:
        fprintf(self.logfile, "xf_epilogue called ...\n")

    def check_same(book_arg, xf_arg, parent_arg, attr):
        # the _arg caper is to avoid a Warning msg from Python 2.1 :-(
        if getattr(xf_arg, attr) != getattr(parent_arg, attr):
            fprintf(book_arg.logfile,
                "NOTE !!! XF[%d] parent[%d] %s different\n",
                xf_arg.xf_index, parent_arg.xf_index, attr)

    for xfx in range(num_xfs):
        xf = self.xf_list[xfx]
        if xf.format_key not in self.format_map:
            msg = "ERROR *** XF[%d] unknown format key (%d, 0x%04x)\n"
            fprintf(self.logfile, msg,
                    xf.xf_index, xf.format_key, xf.format_key)
            xf.format_key = 0
        cellty_from_fmtty = {
            FNU: XL_CELL_NUMBER,
            FUN: XL_CELL_NUMBER,
            FGE: XL_CELL_NUMBER,
            FDT: XL_CELL_DATE,
            FTX: XL_CELL_NUMBER, # Yes, a number can be formatted as text.
            }
        fmt = self.format_map[xf.format_key]
        cellty = cellty_from_fmtty[fmt.type]
        self._xf_index_to_xl_type_map[xf.xf_index] = cellty
        # Now for some assertions etc
        if not self.formatting_info:
            continue
        if xf.is_style:
            continue
        if not(0 <= xf.parent_style_index < num_xfs):
            fprintf(self.logfile,
                "WARNING *** XF[%d]: is_style=%d but parent_style_index=%d\n",
                xf.xf_index, xf.is_style, xf.parent_style_index)
            # make it conform
            xf.parent_style_index = 0
        if self.biff_version >= 30:
            assert xf.parent_style_index != xf.xf_index
            assert self.xf_list[xf.parent_style_index].is_style
            if verbose1 and xf.parent_style_index > xf.xf_index:
                fprintf(self.logfile,
                    "NOTE !!! XF[%d]: parent_style_index is %d; out of order?\n",
                    xf.xf_index, xf.parent_style_index)
            parent = self.xf_list[xf.parent_style_index]
            if not xf._alignment_flag and not parent._alignment_flag:
                if verbose1: check_same(self, xf, parent, 'alignment')
            if not xf._background_flag and not parent._background_flag:
                if verbose1: check_same(self, xf, parent, 'background')
            if not xf._border_flag and not parent._border_flag:
                if verbose1: check_same(self, xf, parent, 'border')
            if not xf._protection_flag and not parent._protection_flag:
                if verbose1: check_same(self, xf, parent, 'protection')
            if not xf._format_flag and not parent._format_flag:
                if verbose1 and xf.format_key != parent.format_key:
                    fprintf(self.logfile,
                        "NOTE !!! XF[%d] fmtk=%d, parent[%d] fmtk=%r\n%r / %r\n",
                        xf.xf_index, xf.format_key, parent.xf_index, parent.format_key,
                        self.format_map[xf.format_key].format_str,
                        self.format_map[parent.format_key].format_str)
            if not xf._font_flag and not parent._font_flag:
                if verbose1 and xf.font_index != parent.font_index:
                    fprintf(self.logfile,
                        "NOTE !!! XF[%d] fontx=%d, parent[%d] fontx=%r\n",
                        xf.xf_index, xf.font_index, parent.xf_index, parent.font_index)

def initialise_book(book):
    initialise_colour_map(book)
    book._xf_epilogue_done = 0
    methods = (
        handle_font,
        handle_efont,
        handle_format,
        is_date_format_string,
        handle_palette,
        palette_epilogue,
        handle_style,
        handle_xf,
        xf_epilogue,
        )
    for method in methods:
        setattr(book.__class__, method.__name__, method)

class XFBorder(BaseObject, EqNeAttrs):
    """ A collection of the border-related attributes of an XF record.

    Items correspond to those in the Excel UI's Format/Cells/Border tab.
    An explanations of "colour index" is given in the Formatting
    section at the start of this document.
    There are five line style attributes; possible values and the
    associated meanings are:

    0 = No line,
    1 = Thin,
    2 = Medium,
    3 = Dashed,
    4 = Dotted,
    5 = Thick,
    6 = Double,
    7 = Hair,
    8 = Medium dashed,
    9 = Thin dash-dotted,
    10 = Medium dash-dotted,
    11 = Thin dash-dot-dotted,
    12 = Medium dash-dot-dotted,
    13 = Slanted medium dash-dotted.
    The line styles 8 to 13 appear in BIFF8 files (Excel 97 and later) only.
    For pictures of the line styles, refer to OOo docs s3.10 (p22)
    "Line Styles for Cell Borders (BIFF3-BIFF8)".</p>
    - New in version 0.6.1
    """

    # The colour index for the cell's top line
    top_colour_index = 0
    # The colour index for the cell's bottom line
    bottom_colour_index = 0
    # The colour index for the cell's left line
    left_colour_index = 0
    # The colour index for the cell's right line
    right_colour_index = 0
    # The colour index for the cell's diagonal lines, if any
    diag_colour_index = 0
    # The line style for the cell's top line
    top_line_style = 0
    # The line style for the cell's bottom line
    bottom_line_style = 0
    # The line style for the cell's left line
    left_line_style = 0
    # The line style for the cell's right line
    right_line_style = 0
    # The line style for the cell's diagonal lines, if any
    diag_line_style = 0
    # 1 = draw a diagonal from top left to bottom right
    diag_down = 0
    # 1 = draw a diagonal from bottom left to top right
    diag_up = 0

# New in version 0.6.1
class XFBackground(BaseObject, EqNeAttrs):
    """ A collection of the background-related attributes of an XF record.

    Items correspond to those in the Excel UI's Format/Cells/Patterns tab.
    An explanation of "colour index" is given in the Formatting
    section at the start of this document.

    """
    # See section 3.11 of the OOo docs.
    fill_pattern = 0
    # See section 3.11 of the OOo docs.
    background_colour_index = 0
    # See section 3.11 of the OOo docs.
    pattern_colour_index = 0

# New in version 0.6.1
class XFAlignment(BaseObject, EqNeAttrs):
    """ A collection of the alignment and similar attributes of an XF record.

    Items correspond to those in the Excel UI's Format/Cells/Alignment tab.
    """
    # Values: section 5.115 (p 219) of OOo docs
    hor_align = 0
    # Values: section 5.115 (p 220) of OOo docs
    vert_align = 0
    # Values: section 5.115 (p 220) of OOo docs.
    # Note: file versions BIFF7 and earlier use the documented
    # "orientation" attribute; this will be mapped (without loss)
    # into "rotation".
    rotation = 0
    # 1 = text is wrapped at right margin
    text_wrapped = 0
    # A number in range(15).
    indent_level = 0
    # 1 = shrink font size to fit text into cell.
    shrink_to_fit = 0
    # 0 = according to context; 1 = left-to-right; 2 = right-to-left
    text_direction = 0

# New in version 0.6.1
class XFProtection(BaseObject, EqNeAttrs):
    """ A collection of the protection-related attributes of an XF record.

    Items correspond to those in the Excel UI's Format/Cells/Protection tab.
    Note the OOo docs include the "cell or style" bit
    in this bundle of attributes.
    This is incorrect; the bit is used in determining which bundles to use.

    """
    # 1 = Cell is prevented from being changed, moved, resized, or deleted
    # (only if the sheet is protected).
    cell_locked = 0
    # 1 = Hide formula so that it doesn't appear in the formula bar when
    # the cell is selected (only if the sheet is protected).
    formula_hidden = 0

# New in version 0.6.1
class XF(BaseObject):
    """ eXtended Formatting information for cells, rows, columns and styles.

    Each of the 6 flags below describes the validity of
    a specific group of attributes.

    In cell XFs, flag==0 means the attributes of the parent style XF are used,
    (but only if the attributes are valid there); flag==1 means the attributes
    of this XF are used.
    In style XFs, flag==0 means the attribute setting is valid; flag==1 means
    the attribute should be ignored.
    Note that the API
    provides both "raw" XFs and "computed" XFs -- in the latter case, cell XFs
    have had the above inheritance mechanism applied.
    """
    # 0 = cell XF, 1 = style XF
    is_style = 0
    # cell XF: Index into Book.xf_list
    # of this XF's style XF
    # style XF: 0xFFF
    parent_style_index = 0
    _format_flag = 0
    _font_flag = 0
    _alignment_flag = 0
    _border_flag = 0
    _background_flag = 0
    _protection_flag = 0
    # Index into Book.xf_list
    xf_index = 0
    # Index into Book.font_list
    font_index = 0
    # Key into Book.format_map
    #
    # Warning: OOo docs on the XF record call this "Index to FORMAT record".
    # It is not an index in the Python sense. It is a key to a map.
    # It is true **only** for Excel 4.0 and earlier files
    # that the key into format_map from an XF instance
    # is the same as the index into format_list, and **only**
    # if the index is less than 164.
    #
    format_key = 0
    # An instance of an XFProtection object.
    protection = None
    # An instance of an XFBackground object.
    background = None
    # An instance of an XFAlignment object.
    alignment = None
    # An instance of an XFBorder object.
    border = None

########NEW FILE########
__FILENAME__ = formula
# Module for parsing/evaluating Microsoft Excel formulas.
#
# Copyright  2005-2009 Stephen John Machin, Lingfo Pty Ltd
# This module is part of the xlrd3 package, which is released under
# a BSD-style licence.

# No part of the content of this file was derived from the works of David Giffin.

import copy
from struct import unpack

from .biffh import unpack_unicode_update_pos, unpack_string_update_pos, \
    XLRDError, hex_char_dump, error_text_from_code, BaseObject

__all__ = [
    'oBOOL', 'oERR', 'oNUM', 'oREF', 'oREL', 'oSTRG', 'oUNK',
    'decompile_formula',
    'dump_formula',
    'evaluate_name_formula',
    'okind_dict',
    'rangename3d', 'rangename3drel', 'cellname', 'cellnameabs', 'colname',
    ]

# sztabN[opcode] -> the number of bytes to consume.
# -1 means variable
# -2 means this opcode not implemented in this version.
# Which N to use? Depends on biff_version; see szdict.
sztab0 = [-2, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -2, -1, 8, 4, 2, 2, 3, 9, 8, 2, 3, 8, 4, 7, 5, 5, 5, 2, 4, 7, 4, 7, 2, 2, -2, -2, -2, -2, -2, -2, -2, -2, 3, -2, -2, -2, -2, -2, -2, -2]
sztab1 = [-2, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -2, -1, 11, 5, 2, 2, 3, 9, 9, 2, 3, 11, 4, 7, 7, 7, 7, 3, 4, 7, 4, 7, 3, 3, -2, -2, -2, -2, -2, -2, -2, -2, 3, -2, -2, -2, -2, -2, -2, -2]
sztab2 = [-2, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -2, -1, 11, 5, 2, 2, 3, 9, 9, 3, 4, 11, 4, 7, 7, 7, 7, 3, 4, 7, 4, 7, 3, 3, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2]
sztab3 = [-2, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -2, -1, -2, -2, 2, 2, 3, 9, 9, 3, 4, 15, 4, 7, 7, 7, 7, 3, 4, 7, 4, 7, 3, 3, -2, -2, -2, -2, -2, -2, -2, -2, -2, 25, 18, 21, 18, 21, -2, -2]
sztab4 = [-2, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -2, -2, 2, 2, 3, 9, 9, 3, 4, 5, 5, 9, 7, 7, 7, 3, 5, 9, 5, 9, 3, 3, -2, -2, -2, -2, -2, -2, -2, -2, -2, 7, 7, 11, 7, 11, -2, -2]

szdict = {
    20 : sztab0,
    21 : sztab0, # Suppose 21 is same as 20....
    30 : sztab1,
    40 : sztab2,
    45 : sztab2,
    50 : sztab3,
    70 : sztab3,
    80 : sztab4,
    }

# For debugging purposes ... the name for each opcode
# (without the prefix "t" used on OOo docs)
onames = ['Unk00', 'Exp', 'Tbl', 'Add', 'Sub', 'Mul', 'Div', 'Power', 'Concat', 'LT', 'LE', 'EQ', 'GE', 'GT', 'NE', 'Isect', 'List', 'Range', 'Uplus', 'Uminus', 'Percent', 'Paren', 'MissArg', 'Str', 'Extended', 'Attr', 'Sheet', 'EndSheet', 'Err', 'Bool', 'Int', 'Num', 'Array', 'Func', 'FuncVar', 'Name', 'Ref', 'Area', 'MemArea', 'MemErr', 'MemNoMem', 'MemFunc', 'RefErr', 'AreaErr', 'RefN', 'AreaN', 'MemAreaN', 'MemNoMemN', '', '', '', '', '', '', '', '', 'FuncCE', 'NameX', 'Ref3d', 'Area3d', 'RefErr3d', 'AreaErr3d', '', '']

func_defs = {
    # index: (name, min#args, max#args, flags, #known_args, return_type, kargs)
    0  : ('COUNT',            0, 30, 0x04,  1, 'V', 'R'),
    1  : ('IF',               2,  3, 0x04,  3, 'V', 'VRR'),
    2  : ('ISNA',             1,  1, 0x02,  1, 'V', 'V'),
    3  : ('ISERROR',          1,  1, 0x02,  1, 'V', 'V'),
    4  : ('SUM',              0, 30, 0x04,  1, 'V', 'R'),
    5  : ('AVERAGE',          1, 30, 0x04,  1, 'V', 'R'),
    6  : ('MIN',              1, 30, 0x04,  1, 'V', 'R'),
    7  : ('MAX',              1, 30, 0x04,  1, 'V', 'R'),
    8  : ('ROW',              0,  1, 0x04,  1, 'V', 'R'),
    9  : ('COLUMN',           0,  1, 0x04,  1, 'V', 'R'),
    10 : ('NA',               0,  0, 0x02,  0, 'V', ''),
    11 : ('NPV',              2, 30, 0x04,  2, 'V', 'VR'),
    12 : ('STDEV',            1, 30, 0x04,  1, 'V', 'R'),
    13 : ('DOLLAR',           1,  2, 0x04,  1, 'V', 'V'),
    14 : ('FIXED',            2,  3, 0x04,  3, 'V', 'VVV'),
    15 : ('SIN',              1,  1, 0x02,  1, 'V', 'V'),
    16 : ('COS',              1,  1, 0x02,  1, 'V', 'V'),
    17 : ('TAN',              1,  1, 0x02,  1, 'V', 'V'),
    18 : ('ATAN',             1,  1, 0x02,  1, 'V', 'V'),
    19 : ('PI',               0,  0, 0x02,  0, 'V', ''),
    20 : ('SQRT',             1,  1, 0x02,  1, 'V', 'V'),
    21 : ('EXP',              1,  1, 0x02,  1, 'V', 'V'),
    22 : ('LN',               1,  1, 0x02,  1, 'V', 'V'),
    23 : ('LOG10',            1,  1, 0x02,  1, 'V', 'V'),
    24 : ('ABS',              1,  1, 0x02,  1, 'V', 'V'),
    25 : ('INT',              1,  1, 0x02,  1, 'V', 'V'),
    26 : ('SIGN',             1,  1, 0x02,  1, 'V', 'V'),
    27 : ('ROUND',            2,  2, 0x02,  2, 'V', 'VV'),
    28 : ('LOOKUP',           2,  3, 0x04,  2, 'V', 'VR'),
    29 : ('INDEX',            2,  4, 0x0c,  4, 'R', 'RVVV'),
    30 : ('REPT',             2,  2, 0x02,  2, 'V', 'VV'),
    31 : ('MID',              3,  3, 0x02,  3, 'V', 'VVV'),
    32 : ('LEN',              1,  1, 0x02,  1, 'V', 'V'),
    33 : ('VALUE',            1,  1, 0x02,  1, 'V', 'V'),
    34 : ('TRUE',             0,  0, 0x02,  0, 'V', ''),
    35 : ('FALSE',            0,  0, 0x02,  0, 'V', ''),
    36 : ('AND',              1, 30, 0x04,  1, 'V', 'R'),
    37 : ('OR',               1, 30, 0x04,  1, 'V', 'R'),
    38 : ('NOT',              1,  1, 0x02,  1, 'V', 'V'),
    39 : ('MOD',              2,  2, 0x02,  2, 'V', 'VV'),
    40 : ('DCOUNT',           3,  3, 0x02,  3, 'V', 'RRR'),
    41 : ('DSUM',             3,  3, 0x02,  3, 'V', 'RRR'),
    42 : ('DAVERAGE',         3,  3, 0x02,  3, 'V', 'RRR'),
    43 : ('DMIN',             3,  3, 0x02,  3, 'V', 'RRR'),
    44 : ('DMAX',             3,  3, 0x02,  3, 'V', 'RRR'),
    45 : ('DSTDEV',           3,  3, 0x02,  3, 'V', 'RRR'),
    46 : ('VAR',              1, 30, 0x04,  1, 'V', 'R'),
    47 : ('DVAR',             3,  3, 0x02,  3, 'V', 'RRR'),
    48 : ('TEXT',             2,  2, 0x02,  2, 'V', 'VV'),
    49 : ('LINEST',           1,  4, 0x04,  4, 'A', 'RRVV'),
    50 : ('TREND',            1,  4, 0x04,  4, 'A', 'RRRV'),
    51 : ('LOGEST',           1,  4, 0x04,  4, 'A', 'RRVV'),
    52 : ('GROWTH',           1,  4, 0x04,  4, 'A', 'RRRV'),
    56 : ('PV',               3,  5, 0x04,  5, 'V', 'VVVVV'),
    57 : ('FV',               3,  5, 0x04,  5, 'V', 'VVVVV'),
    58 : ('NPER',             3,  5, 0x04,  5, 'V', 'VVVVV'),
    59 : ('PMT',              3,  5, 0x04,  5, 'V', 'VVVVV'),
    60 : ('RATE',             3,  6, 0x04,  6, 'V', 'VVVVVV'),
    61 : ('MIRR',             3,  3, 0x02,  3, 'V', 'RVV'),
    62 : ('IRR',              1,  2, 0x04,  2, 'V', 'RV'),
    63 : ('RAND',             0,  0, 0x0a,  0, 'V', ''),
    64 : ('MATCH',            2,  3, 0x04,  3, 'V', 'VRR'),
    65 : ('DATE',             3,  3, 0x02,  3, 'V', 'VVV'),
    66 : ('TIME',             3,  3, 0x02,  3, 'V', 'VVV'),
    67 : ('DAY',              1,  1, 0x02,  1, 'V', 'V'),
    68 : ('MONTH',            1,  1, 0x02,  1, 'V', 'V'),
    69 : ('YEAR',             1,  1, 0x02,  1, 'V', 'V'),
    70 : ('WEEKDAY',          1,  2, 0x04,  2, 'V', 'VV'),
    71 : ('HOUR',             1,  1, 0x02,  1, 'V', 'V'),
    72 : ('MINUTE',           1,  1, 0x02,  1, 'V', 'V'),
    73 : ('SECOND',           1,  1, 0x02,  1, 'V', 'V'),
    74 : ('NOW',              0,  0, 0x0a,  0, 'V', ''),
    75 : ('AREAS',            1,  1, 0x02,  1, 'V', 'R'),
    76 : ('ROWS',             1,  1, 0x02,  1, 'V', 'R'),
    77 : ('COLUMNS',          1,  1, 0x02,  1, 'V', 'R'),
    78 : ('OFFSET',           3,  5, 0x04,  5, 'R', 'RVVVV'),
    82 : ('SEARCH',           2,  3, 0x04,  3, 'V', 'VVV'),
    83 : ('TRANSPOSE',        1,  1, 0x02,  1, 'A', 'A'),
    86 : ('TYPE',             1,  1, 0x02,  1, 'V', 'V'),
    92 : ('SERIESSUM',        4,  4, 0x02,  4, 'V', 'VVVA'),
    97 : ('ATAN2',            2,  2, 0x02,  2, 'V', 'VV'),
    98 : ('ASIN',             1,  1, 0x02,  1, 'V', 'V'),
    99 : ('ACOS',             1,  1, 0x02,  1, 'V', 'V'),
    100: ('CHOOSE',           2, 30, 0x04,  2, 'V', 'VR'),
    101: ('HLOOKUP',          3,  4, 0x04,  4, 'V', 'VRRV'),
    102: ('VLOOKUP',          3,  4, 0x04,  4, 'V', 'VRRV'),
    105: ('ISREF',            1,  1, 0x02,  1, 'V', 'R'),
    109: ('LOG',              1,  2, 0x04,  2, 'V', 'VV'),
    111: ('CHAR',             1,  1, 0x02,  1, 'V', 'V'),
    112: ('LOWER',            1,  1, 0x02,  1, 'V', 'V'),
    113: ('UPPER',            1,  1, 0x02,  1, 'V', 'V'),
    114: ('PROPER',           1,  1, 0x02,  1, 'V', 'V'),
    115: ('LEFT',             1,  2, 0x04,  2, 'V', 'VV'),
    116: ('RIGHT',            1,  2, 0x04,  2, 'V', 'VV'),
    117: ('EXACT',            2,  2, 0x02,  2, 'V', 'VV'),
    118: ('TRIM',             1,  1, 0x02,  1, 'V', 'V'),
    119: ('REPLACE',          4,  4, 0x02,  4, 'V', 'VVVV'),
    120: ('SUBSTITUTE',       3,  4, 0x04,  4, 'V', 'VVVV'),
    121: ('CODE',             1,  1, 0x02,  1, 'V', 'V'),
    124: ('FIND',             2,  3, 0x04,  3, 'V', 'VVV'),
    125: ('CELL',             1,  2, 0x0c,  2, 'V', 'VR'),
    126: ('ISERR',            1,  1, 0x02,  1, 'V', 'V'),
    127: ('ISTEXT',           1,  1, 0x02,  1, 'V', 'V'),
    128: ('ISNUMBER',         1,  1, 0x02,  1, 'V', 'V'),
    129: ('ISBLANK',          1,  1, 0x02,  1, 'V', 'V'),
    130: ('T',                1,  1, 0x02,  1, 'V', 'R'),
    131: ('N',                1,  1, 0x02,  1, 'V', 'R'),
    140: ('DATEVALUE',        1,  1, 0x02,  1, 'V', 'V'),
    141: ('TIMEVALUE',        1,  1, 0x02,  1, 'V', 'V'),
    142: ('SLN',              3,  3, 0x02,  3, 'V', 'VVV'),
    143: ('SYD',              4,  4, 0x02,  4, 'V', 'VVVV'),
    144: ('DDB',              4,  5, 0x04,  5, 'V', 'VVVVV'),
    148: ('INDIRECT',         1,  2, 0x0c,  2, 'R', 'VV'),
    162: ('CLEAN',            1,  1, 0x02,  1, 'V', 'V'),
    163: ('MDETERM',          1,  1, 0x02,  1, 'V', 'A'),
    164: ('MINVERSE',         1,  1, 0x02,  1, 'A', 'A'),
    165: ('MMULT',            2,  2, 0x02,  2, 'A', 'AA'),
    167: ('IPMT',             4,  6, 0x04,  6, 'V', 'VVVVVV'),
    168: ('PPMT',             4,  6, 0x04,  6, 'V', 'VVVVVV'),
    169: ('COUNTA',           0, 30, 0x04,  1, 'V', 'R'),
    183: ('PRODUCT',          0, 30, 0x04,  1, 'V', 'R'),
    184: ('FACT',             1,  1, 0x02,  1, 'V', 'V'),
    189: ('DPRODUCT',         3,  3, 0x02,  3, 'V', 'RRR'),
    190: ('ISNONTEXT',        1,  1, 0x02,  1, 'V', 'V'),
    193: ('STDEVP',           1, 30, 0x04,  1, 'V', 'R'),
    194: ('VARP',             1, 30, 0x04,  1, 'V', 'R'),
    195: ('DSTDEVP',          3,  3, 0x02,  3, 'V', 'RRR'),
    196: ('DVARP',            3,  3, 0x02,  3, 'V', 'RRR'),
    197: ('TRUNC',            1,  2, 0x04,  2, 'V', 'VV'),
    198: ('ISLOGICAL',        1,  1, 0x02,  1, 'V', 'V'),
    199: ('DCOUNTA',          3,  3, 0x02,  3, 'V', 'RRR'),
    204: ('USDOLLAR',         1,  2, 0x04,  2, 'V', 'VV'),
    205: ('FINDB',            2,  3, 0x04,  3, 'V', 'VVV'),
    206: ('SEARCHB',          2,  3, 0x04,  3, 'V', 'VVV'),
    207: ('REPLACEB',         4,  4, 0x02,  4, 'V', 'VVVV'),
    208: ('LEFTB',            1,  2, 0x04,  2, 'V', 'VV'),
    209: ('RIGHTB',           1,  2, 0x04,  2, 'V', 'VV'),
    210: ('MIDB',             3,  3, 0x02,  3, 'V', 'VVV'),
    211: ('LENB',             1,  1, 0x02,  1, 'V', 'V'),
    212: ('ROUNDUP',          2,  2, 0x02,  2, 'V', 'VV'),
    213: ('ROUNDDOWN',        2,  2, 0x02,  2, 'V', 'VV'),
    214: ('ASC',              1,  1, 0x02,  1, 'V', 'V'),
    215: ('DBCS',             1,  1, 0x02,  1, 'V', 'V'),
    216: ('RANK',             2,  3, 0x04,  3, 'V', 'VRV'),
    219: ('ADDRESS',          2,  5, 0x04,  5, 'V', 'VVVVV'),
    220: ('DAYS360',          2,  3, 0x04,  3, 'V', 'VVV'),
    221: ('TODAY',            0,  0, 0x0a,  0, 'V', ''),
    222: ('VDB',              5,  7, 0x04,  7, 'V', 'VVVVVVV'),
    227: ('MEDIAN',           1, 30, 0x04,  1, 'V', 'R'),
    228: ('SUMPRODUCT',       1, 30, 0x04,  1, 'V', 'A'),
    229: ('SINH',             1,  1, 0x02,  1, 'V', 'V'),
    230: ('COSH',             1,  1, 0x02,  1, 'V', 'V'),
    231: ('TANH',             1,  1, 0x02,  1, 'V', 'V'),
    232: ('ASINH',            1,  1, 0x02,  1, 'V', 'V'),
    233: ('ACOSH',            1,  1, 0x02,  1, 'V', 'V'),
    234: ('ATANH',            1,  1, 0x02,  1, 'V', 'V'),
    235: ('DGET',             3,  3, 0x02,  3, 'V', 'RRR'),
    244: ('INFO',             1,  1, 0x02,  1, 'V', 'V'),
    247: ('DB',               4,  5, 0x04,  5, 'V', 'VVVVV'),
    252: ('FREQUENCY',        2,  2, 0x02,  2, 'A', 'RR'),
    261: ('ERROR.TYPE',       1,  1, 0x02,  1, 'V', 'V'),
    269: ('AVEDEV',           1, 30, 0x04,  1, 'V', 'R'),
    270: ('BETADIST',         3,  5, 0x04,  1, 'V', 'V'),
    271: ('GAMMALN',          1,  1, 0x02,  1, 'V', 'V'),
    272: ('BETAINV',          3,  5, 0x04,  1, 'V', 'V'),
    273: ('BINOMDIST',        4,  4, 0x02,  4, 'V', 'VVVV'),
    274: ('CHIDIST',          2,  2, 0x02,  2, 'V', 'VV'),
    275: ('CHIINV',           2,  2, 0x02,  2, 'V', 'VV'),
    276: ('COMBIN',           2,  2, 0x02,  2, 'V', 'VV'),
    277: ('CONFIDENCE',       3,  3, 0x02,  3, 'V', 'VVV'),
    278: ('CRITBINOM',        3,  3, 0x02,  3, 'V', 'VVV'),
    279: ('EVEN',             1,  1, 0x02,  1, 'V', 'V'),
    280: ('EXPONDIST',        3,  3, 0x02,  3, 'V', 'VVV'),
    281: ('FDIST',            3,  3, 0x02,  3, 'V', 'VVV'),
    282: ('FINV',             3,  3, 0x02,  3, 'V', 'VVV'),
    283: ('FISHER',           1,  1, 0x02,  1, 'V', 'V'),
    284: ('FISHERINV',        1,  1, 0x02,  1, 'V', 'V'),
    285: ('FLOOR',            2,  2, 0x02,  2, 'V', 'VV'),
    286: ('GAMMADIST',        4,  4, 0x02,  4, 'V', 'VVVV'),
    287: ('GAMMAINV',         3,  3, 0x02,  3, 'V', 'VVV'),
    288: ('CEILING',          2,  2, 0x02,  2, 'V', 'VV'),
    289: ('HYPGEOMDIST',      4,  4, 0x02,  4, 'V', 'VVVV'),
    290: ('LOGNORMDIST',      3,  3, 0x02,  3, 'V', 'VVV'),
    291: ('LOGINV',           3,  3, 0x02,  3, 'V', 'VVV'),
    292: ('NEGBINOMDIST',     3,  3, 0x02,  3, 'V', 'VVV'),
    293: ('NORMDIST',         4,  4, 0x02,  4, 'V', 'VVVV'),
    294: ('NORMSDIST',        1,  1, 0x02,  1, 'V', 'V'),
    295: ('NORMINV',          3,  3, 0x02,  3, 'V', 'VVV'),
    296: ('NORMSINV',         1,  1, 0x02,  1, 'V', 'V'),
    297: ('STANDARDIZE',      3,  3, 0x02,  3, 'V', 'VVV'),
    298: ('ODD',              1,  1, 0x02,  1, 'V', 'V'),
    299: ('PERMUT',           2,  2, 0x02,  2, 'V', 'VV'),
    300: ('POISSON',          3,  3, 0x02,  3, 'V', 'VVV'),
    301: ('TDIST',            3,  3, 0x02,  3, 'V', 'VVV'),
    302: ('WEIBULL',          4,  4, 0x02,  4, 'V', 'VVVV'),
    303: ('SUMXMY2',          2,  2, 0x02,  2, 'V', 'AA'),
    304: ('SUMX2MY2',         2,  2, 0x02,  2, 'V', 'AA'),
    305: ('SUMX2PY2',         2,  2, 0x02,  2, 'V', 'AA'),
    306: ('CHITEST',          2,  2, 0x02,  2, 'V', 'AA'),
    307: ('CORREL',           2,  2, 0x02,  2, 'V', 'AA'),
    308: ('COVAR',            2,  2, 0x02,  2, 'V', 'AA'),
    309: ('FORECAST',         3,  3, 0x02,  3, 'V', 'VAA'),
    310: ('FTEST',            2,  2, 0x02,  2, 'V', 'AA'),
    311: ('INTERCEPT',        2,  2, 0x02,  2, 'V', 'AA'),
    312: ('PEARSON',          2,  2, 0x02,  2, 'V', 'AA'),
    313: ('RSQ',              2,  2, 0x02,  2, 'V', 'AA'),
    314: ('STEYX',            2,  2, 0x02,  2, 'V', 'AA'),
    315: ('SLOPE',            2,  2, 0x02,  2, 'V', 'AA'),
    316: ('TTEST',            4,  4, 0x02,  4, 'V', 'AAVV'),
    317: ('PROB',             3,  4, 0x04,  3, 'V', 'AAV'),
    318: ('DEVSQ',            1, 30, 0x04,  1, 'V', 'R'),
    319: ('GEOMEAN',          1, 30, 0x04,  1, 'V', 'R'),
    320: ('HARMEAN',          1, 30, 0x04,  1, 'V', 'R'),
    321: ('SUMSQ',            0, 30, 0x04,  1, 'V', 'R'),
    322: ('KURT',             1, 30, 0x04,  1, 'V', 'R'),
    323: ('SKEW',             1, 30, 0x04,  1, 'V', 'R'),
    324: ('ZTEST',            2,  3, 0x04,  2, 'V', 'RV'),
    325: ('LARGE',            2,  2, 0x02,  2, 'V', 'RV'),
    326: ('SMALL',            2,  2, 0x02,  2, 'V', 'RV'),
    327: ('QUARTILE',         2,  2, 0x02,  2, 'V', 'RV'),
    328: ('PERCENTILE',       2,  2, 0x02,  2, 'V', 'RV'),
    329: ('PERCENTRANK',      2,  3, 0x04,  2, 'V', 'RV'),
    330: ('MODE',             1, 30, 0x04,  1, 'V', 'A'),
    331: ('TRIMMEAN',         2,  2, 0x02,  2, 'V', 'RV'),
    332: ('TINV',             2,  2, 0x02,  2, 'V', 'VV'),
    336: ('CONCATENATE',      0, 30, 0x04,  1, 'V', 'V'),
    337: ('POWER',            2,  2, 0x02,  2, 'V', 'VV'),
    342: ('RADIANS',          1,  1, 0x02,  1, 'V', 'V'),
    343: ('DEGREES',          1,  1, 0x02,  1, 'V', 'V'),
    344: ('SUBTOTAL',         2, 30, 0x04,  2, 'V', 'VR'),
    345: ('SUMIF',            2,  3, 0x04,  3, 'V', 'RVR'),
    346: ('COUNTIF',          2,  2, 0x02,  2, 'V', 'RV'),
    347: ('COUNTBLANK',       1,  1, 0x02,  1, 'V', 'R'),
    350: ('ISPMT',            4,  4, 0x02,  4, 'V', 'VVVV'),
    351: ('DATEDIF',          3,  3, 0x02,  3, 'V', 'VVV'),
    352: ('DATESTRING',       1,  1, 0x02,  1, 'V', 'V'),
    353: ('NUMBERSTRING',     2,  2, 0x02,  2, 'V', 'VV'),
    354: ('ROMAN',            1,  2, 0x04,  2, 'V', 'VV'),
    358: ('GETPIVOTDATA',     2,  2, 0x02,  2, 'V', 'RV'),
    359: ('HYPERLINK',        1,  2, 0x04,  2, 'V', 'VV'),
    360: ('PHONETIC',         1,  1, 0x02,  1, 'V', 'V'),
    361: ('AVERAGEA',         1, 30, 0x04,  1, 'V', 'R'),
    362: ('MAXA',             1, 30, 0x04,  1, 'V', 'R'),
    363: ('MINA',             1, 30, 0x04,  1, 'V', 'R'),
    364: ('STDEVPA',          1, 30, 0x04,  1, 'V', 'R'),
    365: ('VARPA',            1, 30, 0x04,  1, 'V', 'R'),
    366: ('STDEVA',           1, 30, 0x04,  1, 'V', 'R'),
    367: ('VARA',             1, 30, 0x04,  1, 'V', 'R'),
    368: ('BAHTTEXT',         1,  1, 0x02,  1, 'V', 'V'),
    369: ('THAIDAYOFWEEK',    1,  1, 0x02,  1, 'V', 'V'),
    370: ('THAIDIGIT',        1,  1, 0x02,  1, 'V', 'V'),
    371: ('THAIMONTHOFYEAR',  1,  1, 0x02,  1, 'V', 'V'),
    372: ('THAINUMSOUND',     1,  1, 0x02,  1, 'V', 'V'),
    373: ('THAINUMSTRING',    1,  1, 0x02,  1, 'V', 'V'),
    374: ('THAISTRINGLENGTH', 1,  1, 0x02,  1, 'V', 'V'),
    375: ('ISTHAIDIGIT',      1,  1, 0x02,  1, 'V', 'V'),
    376: ('ROUNDBAHTDOWN',    1,  1, 0x02,  1, 'V', 'V'),
    377: ('ROUNDBAHTUP',      1,  1, 0x02,  1, 'V', 'V'),
    378: ('THAIYEAR',         1,  1, 0x02,  1, 'V', 'V'),
    379: ('RTD',              2,  5, 0x04,  1, 'V', 'V'),
    }

tAttrNames = {
    0x00: "Skip??", # seen in SAMPLES.XLS which shipped with Excel 5.0
    0x01: "Volatile",
    0x02: "If",
    0x04: "Choose",
    0x08: "Skip",
    0x10: "Sum",
    0x20: "Assign",
    0x40: "Space",
    0x41: "SpaceVolatile",
    }

_error_opcodes = frozenset([0x07, 0x08, 0x0A, 0x0B, 0x1C, 0x1D, 0x2F])

tRangeFuncs = (min, max, min, max, min, max)
tIsectFuncs = (max, min, max, min, max, min)

def do_box_funcs(box_funcs, boxa, boxb):
    return tuple([
        func(numa, numb)
        for func, numa, numb in zip(box_funcs, boxa.coords, boxb.coords)
        ])

def adjust_cell_addr_biff8(rowval, colval, reldelta, browx=None, bcolx=None):
    row_rel = (colval >> 15) & 1
    col_rel = (colval >> 14) & 1
    rowx = rowval
    colx = colval & 0xff
    if reldelta:
        if row_rel and rowx >= 32768:
            rowx -= 65536
        if col_rel and colx >= 128:
            colx -= 256
    else:
        if row_rel:
            rowx -= browx
        if col_rel:
            colx -= bcolx
    return rowx, colx, row_rel, col_rel

def adjust_cell_addr_biff_le7(
        rowval, colval, reldelta, browx=None, bcolx=None):
    row_rel = (rowval >> 15) & 1
    col_rel = (rowval >> 14) & 1
    rowx = rowval & 0x3fff
    colx = colval
    if reldelta:
        if row_rel and rowx >= 8192:
            rowx -= 16384
        if col_rel and colx >= 128:
            colx -= 256
    else:
        if row_rel:
            rowx -= browx
        if col_rel:
            colx -= bcolx
    return rowx, colx, row_rel, col_rel

def get_cell_addr(data, pos, bv, reldelta, browx=None, bcolx=None):
    if bv >= 80:
        rowval, colval = unpack("<HH", data[pos:pos+4])
        # print "    rv=%04xh cv=%04xh" % (rowval, colval)
        return adjust_cell_addr_biff8(rowval, colval, reldelta, browx, bcolx)
    else:
        rowval, colval = unpack("<HB", data[pos:pos+3])
        # print "    rv=%04xh cv=%04xh" % (rowval, colval)
        return adjust_cell_addr_biff_le7(
                    rowval, colval, reldelta, browx, bcolx)

def get_cell_range_addr(data, pos, bv, reldelta, browx=None, bcolx=None):
    if bv >= 80:
        row1val, row2val, col1val, col2val = unpack("<HHHH", data[pos:pos+8])
        # print "    rv=%04xh cv=%04xh" % (row1val, col1val)
        # print "    rv=%04xh cv=%04xh" % (row2val, col2val)
        res1 = adjust_cell_addr_biff8(row1val, col1val, reldelta, browx, bcolx)
        res2 = adjust_cell_addr_biff8(row2val, col2val, reldelta, browx, bcolx)
        return res1, res2
    else:
        row1val, row2val, col1val, col2val = unpack("<HHBB", data[pos:pos+6])
        # print "    rv=%04xh cv=%04xh" % (row1val, col1val)
        # print "    rv=%04xh cv=%04xh" % (row2val, col2val)
        res1 = adjust_cell_addr_biff_le7(
                    row1val, col1val, reldelta, browx, bcolx)
        res2 = adjust_cell_addr_biff_le7(
                    row2val, col2val, reldelta, browx, bcolx)
        return res1, res2

def get_externsheet_local_range(bk, refx, verbose=0):
    try:
        info = bk._externsheet_info[refx]
    except IndexError:
        print("!!! get_externsheet_local_range: refx=%d, not in range(%d)" \
            % (refx, len(bk._externsheet_info)))
        return (-101, -101)
    ref_recordx, ref_first_sheetx, ref_last_sheetx = info
    if ref_recordx == bk._supbook_addins_inx:
        if verbose:
            print("/// get_externsheet_local_range(refx=%d) -> addins %r" % (refx, info))
        assert ref_first_sheetx == 0xFFFE == ref_last_sheetx
        return (-5, -5)
    if ref_recordx != bk._supbook_locals_inx:
        if verbose:
            print("/// get_externsheet_local_range(refx=%d) -> external %r" % (refx, info))
        return (-4, -4) # external reference
    if ref_first_sheetx == 0xFFFE == ref_last_sheetx:
        if verbose:
            print("/// get_externsheet_local_range(refx=%d) -> unspecified sheet %r" % (refx, info))
        return (-1, -1) # internal reference, any sheet
    if ref_first_sheetx == 0xFFFF == ref_last_sheetx:
        if verbose:
            print("/// get_externsheet_local_range(refx=%d) -> deleted sheet(s)" % (refx, ))
        return (-2, -2) # internal reference, deleted sheet(s)
    nsheets = len(bk._all_sheets_map)
    if not(0 <= ref_first_sheetx <= ref_last_sheetx < nsheets):
        if verbose:
            print("/// get_externsheet_local_range(refx=%d) -> %r" % (refx, info))
            print("--- first/last sheet not in range(%d)" % nsheets)
        return (-102, -102) # stuffed up somewhere :-(
    xlrd_sheetx1 = bk._all_sheets_map[ref_first_sheetx]
    xlrd_sheetx2 = bk._all_sheets_map[ref_last_sheetx]
    if not(0 <= xlrd_sheetx1 <= xlrd_sheetx2):
        return (-3, -3) # internal reference, but to a macro sheet
    return xlrd_sheetx1, xlrd_sheetx2

def get_externsheet_local_range_b57(
        bk, raw_extshtx, ref_first_sheetx, ref_last_sheetx, verbose=0):
    if raw_extshtx > 0:
        if verbose:
            print("/// get_externsheet_local_range_b57(raw_extshtx=%d) -> external" % raw_extshtx)
        return (-4, -4) # external reference
    if ref_first_sheetx == -1 and ref_last_sheetx == -1:
        return (-2, -2) # internal reference, deleted sheet(s)
    nsheets = len(bk._all_sheets_map)
    if not(0 <= ref_first_sheetx <= ref_last_sheetx < nsheets):
        if verbose:
            print("/// get_externsheet_local_range_b57(%d, %d, %d) -> ???" \
                % (raw_extshtx, ref_first_sheetx, ref_last_sheetx))
            print("--- first/last sheet not in range(%d)" % nsheets)
        return (-103, -103) # stuffed up somewhere :-(
    xlrd_sheetx1 = bk._all_sheets_map[ref_first_sheetx]
    xlrd_sheetx2 = bk._all_sheets_map[ref_last_sheetx]
    if not(0 <= xlrd_sheetx1 <= xlrd_sheetx2):
        return (-3, -3) # internal reference, but to a macro sheet
    return xlrd_sheetx1, xlrd_sheetx2

class FormulaError(Exception):
    pass

oBOOL = 3
oERR =  4
oMSNG = 5 # tMissArg
oNUM =  2
oREF = -1
oREL = -2
oSTRG = 1
oUNK =  0

okind_dict = {
    -2: "oREL",
    -1: "oREF",
    0 : "oUNK",
    1 : "oSTRG",
    2 : "oNUM",
    3 : "oBOOL",
    4 : "oERR",
    5 : "oMSNG",
    }

listsep = ',' #### probably should depend on locale

##
# Used in evaluating formulas.
# The following table describes the kinds and how their values
# are represented.</p>
#
# <table border="1" cellpadding="7">
# <tr>
# <th>Kind symbol</th>
# <th>Kind number</th>
# <th>Value representation</th>
# </tr>
# <tr>
# <td>oBOOL</td>
# <td align="center">3</td>
# <td>integer: 0 => False; 1 => True</td>
# </tr>
# <tr>
# <td>oERR</td>
# <td align="center">4</td>
# <td>None, or an int error code (same as XL_CELL_ERROR in the Cell class).
# </td>
# </tr>
# <tr>
# <td>oMSNG</td>
# <td align="center">5</td>
# <td>Used by Excel as a placeholder for a missing (not supplied) function
# argument. Should *not* appear as a final formula result. Value is None.</td>
# </tr>
# <tr>
# <td>oNUM</td>
# <td align="center">2</td>
# <td>A float. Note that there is no way of distinguishing dates.</td>
# </tr>
# <tr>
# <td>oREF</td>
# <td align="center">-1</td>
# <td>The value is either None or a non-empty list of
# absolute Ref3D instances.<br>
# </td>
# </tr>
# <tr>
# <td>oREL</td>
# <td align="center">-2</td>
# <td>The value is None or a non-empty list of
# fully or partially relative Ref3D instances.
# </td>
# </tr>
# <tr>
# <td>oSTRG</td>
# <td align="center">1</td>
# <td>A Unicode string.</td>
# </tr>
# <tr>
# <td>oUNK</td>
# <td align="center">0</td>
# <td>The kind is unknown or ambiguous. The value is None</td>
# </tr>
# </table>
#<p></p>

class Operand(object):

    ##
    # None means that the actual value of the operand is a variable
    # (depends on cell data), not a constant.
    value = None
    ##
    # oUNK means that the kind of operand is not known unambiguously.
    kind = oUNK
    ##
    # The reconstituted text of the original formula. Function names will be
    # in English irrespective of the original language, which doesn't seem
    # to be recorded anywhere. The separator is ",", not ";" or whatever else
    # might be more appropriate for the end-user's locale; patches welcome.
    text = '?'

    def __init__(self, akind=None, avalue=None, arank=0, atext='?'):
        if akind is not None:
            self.kind = akind
        if avalue is not None:
            self.value = avalue
        self.rank = arank
        # rank is an internal gizmo (operator precedence);
        # it's used in reconstructing formula text.
        self.text = atext

    def __repr__(self):
        kind_text = okind_dict.get(self.kind, "?Unknown kind?")
        return "Operand(kind=%s, value=%r, text=%r)" \
            % (kind_text, self.value, self.text)

#(to_py3) if CAN_SUBCLASS_BUILTIN:
# _ref3d_base = tuple

# Represents an absolute or relative 3-dimensional reference to a box
# of one or more cells.
# - New in version 0.6.0
#
# The `coords` attribute is a tuple of the form:
# (shtxlo, shtxhi, rowxlo, rowxhi, colxlo, colxhi)
# where 0 <= thingxlo <= thingx < thingxhi.
# Note that it is quite possible to have thingx > nthings; for example
# Print_Titles could have colxhi == 256 and/or rowxhi == 65536
# irrespective of how many columns/rows are actually used in the worksheet.
# The caller will need to decide how to handle this situation.
# Keyword: IndexError :-)
#
# The components of the coords attribute are also available as individual
# attributes: shtxlo, shtxhi, rowxlo, rowxhi, colxlo, and colxhi.
#
# The `relflags` attribute is a 6-tuple of flags which indicate whether
# the corresponding (sheet|row|col)(lo|hi) is relative (1) or absolute (0).
# Note that there is necessarily no information available as to what cell(s)
# the reference could possibly be relative to. The caller must decide what if
# any use to make of oREL operands. Note also that a partially relative
# reference may well be a typo.
# For example, define name A1Z10 as $a$1:$z10 (missing $ after z)
# while the cursor is on cell Sheet3!A27.<br>
# The resulting Ref3D instance will have coords = (2, 3, 0, -16, 0, 26)
# and relflags = (0, 0, 0, 1, 0, 0).<br>
# So far, only one possibility of a sheet-relative component in
# a reference has been noticed: a 2D reference located in the "current sheet".
# This will appear as coords = (0, 1, ...) and relflags = (1, 1, ...).

class Ref3D(tuple):

    def __init__(self, atuple):
        self.coords = atuple[0:6]
        self.relflags = atuple[6:12]
        if not self.relflags:
            self.relflags = (0, 0, 0, 0, 0, 0)
        (self.shtxlo, self.shtxhi,
        self.rowxlo, self.rowxhi,
        self.colxlo, self.colxhi) = self.coords

    def __repr__(self):
        if not self.relflags or self.relflags == (0, 0, 0, 0, 0, 0):
            return "Ref3D(coords=%r)" % (self.coords, )
        else:
            return "Ref3D(coords=%r, relflags=%r)" \
                % (self.coords, self.relflags)

tAdd = 0x03
tSub = 0x04
tMul = 0x05
tDiv = 0x06
tPower = 0x07
tConcat = 0x08
tLT, tLE, tEQ, tGE, tGT, tNE = list(range(0x09, 0x0F))

import operator as opr

def nop(x):
    return x

def _opr_pow(x, y): return x ** y

def _opr_lt(x, y): return x <  y
def _opr_le(x, y): return x <= y
def _opr_eq(x, y): return x == y
def _opr_ge(x, y): return x >= y
def _opr_gt(x, y): return x >  y
def _opr_ne(x, y): return x != y

def num2strg(num):
    """Attempt to emulate Excel's default conversion
       from number to string.
    """
    s = str(num)
    if s.endswith(".0"):
        s = s[:-2]
    return s

_arith_argdict = {oNUM: nop,     oSTRG: float}
_cmp_argdict =   {oNUM: nop,     oSTRG: nop}
# Seems no conversions done on relops; in Excel, "1" > 9 produces TRUE.
_strg_argdict =  {oNUM:num2strg, oSTRG:nop}
binop_rules = {
    tAdd:   (_arith_argdict, oNUM, opr.add,  30, '+'),
    tSub:   (_arith_argdict, oNUM, opr.sub,  30, '-'),
    tMul:   (_arith_argdict, oNUM, opr.mul,  40, '*'),
    tDiv:   (_arith_argdict, oNUM, opr.truediv,  40, '/'),
    tPower: (_arith_argdict, oNUM, _opr_pow, 50, '^',),
    tConcat:(_strg_argdict, oSTRG, opr.add,  20, '&'),
    tLT:    (_cmp_argdict, oBOOL, _opr_lt,   10, '<'),
    tLE:    (_cmp_argdict, oBOOL, _opr_le,   10, '<='),
    tEQ:    (_cmp_argdict, oBOOL, _opr_eq,   10, '='),
    tGE:    (_cmp_argdict, oBOOL, _opr_ge,   10, '>='),
    tGT:    (_cmp_argdict, oBOOL, _opr_gt,   10, '>'),
    tNE:    (_cmp_argdict, oBOOL, _opr_ne,   10, '<>'),
    }

unop_rules = {
    0x13: (lambda x: -x,        70, '-', ''), # unary minus
    0x12: (lambda x: x,         70, '+', ''), # unary plus
    0x14: (lambda x: x / 100.0, 60, '',  '%'),# percent
    }

LEAF_RANK = 90
FUNC_RANK = 90

STACK_ALARM_LEVEL = 5
STACK_PANIC_LEVEL = 10

def evaluate_name_formula(bk, nobj, namex, verbose=0, level=0):
    if level > STACK_ALARM_LEVEL:
        verbose = 1
    data = nobj.raw_formula
    fmlalen = nobj.basic_formula_len
    bv = bk.biff_version
    reldelta = 1 # All defined name formulas use "Method B" [OOo docs]
    if verbose:
        print("::: evaluate_name_formula %r %r %d %d %r level=%d" \
            % (namex, nobj.name, fmlalen, bv, data, level))
        hex_char_dump(data, 0, fmlalen)
    if level > STACK_PANIC_LEVEL:
        raise XLRDError("Excessive indirect references in NAME formula")
    sztab = szdict[bv]
    pos = 0
    stack = []
    any_rel = 0
    any_err = 0
    any_external = 0
    unk_opnd = Operand(oUNK, None)
    error_opnd = Operand(oERR, None)
    spush = stack.append

    def do_binop(opcd, stk):
        assert len(stk) >= 2
        bop = stk.pop()
        aop = stk.pop()
        argdict, result_kind, func, rank, sym = binop_rules[opcd]
        otext = ''.join([
            '('[:aop.rank < rank],
            aop.text,
            ')'[:aop.rank < rank],
            sym,
            '('[:bop.rank < rank],
            bop.text,
            ')'[:bop.rank < rank],
            ])
        resop = Operand(result_kind, None, rank, otext)
        try:
            bconv = argdict[bop.kind]
            aconv = argdict[aop.kind]
        except KeyError:
            stk.append(resop)
            return
        if bop.value is None or aop.value is None:
            stk.append(resop)
            return
        bval = bconv(bop.value)
        aval = aconv(aop.value)
        result = func(aval, bval)
        if result_kind == oBOOL:
            result = 1 if result else 0 # (to_py3)
        resop.value = result
        stk.append(resop)

    def do_unaryop(opcode, arglist, result_kind, stk):
        assert len(stk) >= 1
        aop = stk.pop()
        assert aop.kind in arglist
        val = aop.value
        func, rank, sym1, sym2 = unop_rules[opcode]
        otext = ''.join([
            sym1,
            '('[:aop.rank < rank],
            aop.text,
            ')'[:aop.rank < rank],
            sym2,
            ])
        if val is not None:
            val = func(val)
        stk.append(Operand(result_kind, val, rank, otext))

    def not_in_name_formula(op_arg, oname_arg):
        msg = "ERROR *** Token 0x%02x (%s) found in NAME formula" \
              % (op_arg, oname_arg)
        raise FormulaError(msg)

    if fmlalen == 0:
        stack = [unk_opnd]

    while 0 <= pos < fmlalen:
        op = data[pos]
        opcode = op & 0x1f
        optype = (op & 0x60) >> 5
        if optype:
            opx = opcode + 32
        else:
            opx = opcode
        oname = onames[opx] # + [" RVA"][optype]
        sz = sztab[opx]
        if verbose:
            print("Pos:%d Op:0x%02x Name:t%s Sz:%d opcode:%02xh optype:%02xh" \
                % (pos, op, oname, sz, opcode, optype))
            print("Stack =", stack)
        if sz == -2:
            msg = 'ERROR *** Unexpected token 0x%02x ("%s"); biff_version=%d' \
                % (op, oname, bv)
            raise FormulaError(msg)
        if not optype:
            if 0x00 <= opcode <= 0x02: # unk_opnd, tExp, tTbl
                not_in_name_formula(op, oname)
            elif 0x03 <= opcode <= 0x0E:
                # Add, Sub, Mul, Div, Power
                # tConcat
                # tLT, ..., tNE
                do_binop(opcode, stack)
            elif opcode == 0x0F: # tIsect
                if verbose: print("tIsect pre", stack, file=bk.logfile)
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                sym = ' '
                rank = 80 ########## check #######
                otext = ''.join([
                    '('[:aop.rank < rank],
                    aop.text,
                    ')'[:aop.rank < rank],
                    sym,
                    '('[:bop.rank < rank],
                    bop.text,
                    ')'[:bop.rank < rank],
                    ])
                res = Operand(oREF)
                res.text = otext
                if bop.kind == oERR or aop.kind == oERR:
                    res.kind = oERR
                elif bop.kind == oUNK or aop.kind == oUNK:
                    # This can happen with undefined
                    # (go search in the current sheet) labels.
                    # For example =Bob Sales
                    # Each label gets a NAME record with an empty formula (!)
                    # Evaluation of the tName token classifies it as oUNK
                    # res.kind = oREF
                    pass
                elif bop.kind == oREF == aop.kind:
                    if aop.value is not None and bop.value is not None:
                        assert len(aop.value) == 1
                        assert len(bop.value) == 1
                        coords = do_box_funcs(
                            tIsectFuncs, aop.value[0], bop.value[0])
                        res.value = [Ref3D(coords)]
                elif bop.kind == oREL == aop.kind:
                    res.kind = oREL
                    if aop.value is not None and bop.value is not None:
                        assert len(aop.value) == 1
                        assert len(bop.value) == 1
                        coords = do_box_funcs(
                            tIsectFuncs, aop.value[0], bop.value[0])
                        relfa = aop.value[0].relflags
                        relfb = bop.value[0].relflags
                        if relfa == relfb:
                            res.value = [Ref3D(coords + relfa)]
                else:
                    pass
                spush(res)
                if verbose: print("tIsect post", stack, file=bk.logfile)
            elif opcode == 0x10: # tList
                if verbose: print("tList pre", stack, file=bk.logfile)
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                sym = ','
                rank = 80 ########## check #######
                otext = ''.join([
                    '('[:aop.rank < rank],
                    aop.text,
                    ')'[:aop.rank < rank],
                    sym,
                    '('[:bop.rank < rank],
                    bop.text,
                    ')'[:bop.rank < rank],
                    ])
                res = Operand(oREF, None, rank, otext)
                if bop.kind == oERR or aop.kind == oERR:
                    res.kind = oERR
                elif bop.kind in (oREF, oREL) and aop.kind in (oREF, oREL):
                    res.kind = oREF
                    if aop.kind == oREL or bop.kind == oREL:
                        res.kind = oREL
                    if aop.value is not None and bop.value is not None:
                        assert len(aop.value) >= 1
                        assert len(bop.value) == 1
                        res.value = aop.value + bop.value
                else:
                    pass
                spush(res)
                if verbose: print("tList post", stack, file=bk.logfile)
            elif opcode == 0x11: # tRange
                if verbose: print("tRange pre", stack, file=bk.logfile)
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                sym = ':'
                rank = 80 ########## check #######
                otext = ''.join([
                    '('[:aop.rank < rank],
                    aop.text,
                    ')'[:aop.rank < rank],
                    sym,
                    '('[:bop.rank < rank],
                    bop.text,
                    ')'[:bop.rank < rank],
                    ])
                res = Operand(oREF, None, rank, otext)
                if bop.kind == oERR or aop.kind == oERR:
                    res = oERR
                elif bop.kind == oREF == aop.kind:
                    if aop.value is not None and bop.value is not None:
                        assert len(aop.value) == 1
                        assert len(bop.value) == 1
                        coords = do_box_funcs(
                            tRangeFuncs, aop.value[0], bop.value[0])
                        res.value = [Ref3D(coords)]
                elif bop.kind == oREL == aop.kind:
                    res.kind = oREL
                    if aop.value is not None and bop.value is not None:
                        assert len(aop.value) == 1
                        assert len(bop.value) == 1
                        coords = do_box_funcs(
                            tRangeFuncs, aop.value[0], bop.value[0])
                        relfa = aop.value[0].relflags
                        relfb = bop.value[0].relflags
                        if relfa == relfb:
                            res.value = [Ref3D(coords + relfa)]
                else:
                    pass
                spush(res)
                if verbose: print("tRange post", stack, file=bk.logfile)
            elif 0x12 <= opcode <= 0x14: # tUplus, tUminus, tPercent
                do_unaryop(opcode, (oUNK, oNUM,), oNUM, stack)
            elif opcode == 0x15: # tParen
                # source cosmetics
                pass
            elif opcode == 0x16: # tMissArg
                spush(Operand(oMSNG, None, LEAF_RANK, ''))
            elif opcode == 0x17: # tStr
                if bv <= 70:
                    strg, newpos = unpack_string_update_pos(
                                        data, pos+1, bk.encoding, lenlen=1)
                else:
                    strg, newpos = unpack_unicode_update_pos(
                                        data, pos+1, lenlen=1)
                sz = newpos - pos
                if verbose: print("   sz=%d strg=%r" % (sz, strg), file=bk.logfile)
                text = '"' + strg.replace('"', '""') + '"'
                spush(Operand(oSTRG, strg, LEAF_RANK, text))
            elif opcode == 0x18: # tExtended
                # new with BIFF 8
                assert bv >= 80
                # not in OOo docs
                raise FormulaError("tExtended token not implemented")
            elif opcode == 0x19: # tAttr
                subop, nc = unpack("<BH", data[pos+1:pos+4])
                subname = tAttrNames.get(subop, "??Unknown??")
                if subop == 0x04: # Choose
                    sz = nc * 2 + 6
                elif subop == 0x10: # Sum (single arg)
                    sz = 4
                    if verbose: print("tAttrSum", stack, file=bk.logfile)
                    assert len(stack) >= 1
                    aop = stack[-1]
                    otext = 'SUM(%s)' % aop.text
                    stack[-1] = Operand(oNUM, None, FUNC_RANK, otext)
                else:
                    sz = 4
                if verbose:
                    print("   subop=%02xh subname=t%s sz=%d nc=%02xh" \
                        % (subop, subname, sz, nc))
            elif 0x1A <= opcode <= 0x1B: # tSheet, tEndSheet
                assert bv < 50
                raise FormulaError("tSheet & tEndsheet tokens not implemented")
            elif 0x1C <= opcode <= 0x1F: # tErr, tBool, tInt, tNum
                inx = opcode - 0x1C
                nb = [1, 1, 2, 8][inx]
                kind = [oERR, oBOOL, oNUM, oNUM][inx]
                value, = unpack("<" + "BBHd"[inx], data[pos+1:pos+1+nb])
                if inx == 2: # tInt
                    value = float(value)
                    text = str(value)
                elif inx == 3: # tNum
                    text = str(value)
                elif inx == 1: # tBool
                    text = ('FALSE', 'TRUE')[value]
                else:
                    text = '"' +error_text_from_code[value] + '"'
                spush(Operand(kind, value, LEAF_RANK, text))
            else:
                raise FormulaError("Unhandled opcode: 0x%02x" % opcode)
            if sz <= 0:
                raise FormulaError("Size not set for opcode 0x%02x" % opcode)
            pos += sz
            continue
        if opcode == 0x00: # tArray
            spush(unk_opnd)
        elif opcode == 0x01: # tFunc
            nb = 1 + int(bv >= 40)
            funcx = unpack("<" + " BH"[nb], data[pos+1:pos+1+nb])[0]
            func_attrs = func_defs.get(funcx, None)
            if not func_attrs:
                print("*** formula/tFunc unknown FuncID:%d" \
                      % funcx, file=bk.logfile)
                spush(unk_opnd)
            else:
                func_name, nargs = func_attrs[:2]
                if verbose:
                    print("    FuncID=%d name=%s nargs=%d" \
                          % (funcx, func_name, nargs))
                assert len(stack) >= nargs
                argtext = listsep.join([arg.text for arg in stack[-nargs:]])
                otext = "%s(%s)" % (func_name, argtext)
                del stack[-nargs:]
                res = Operand(oUNK, None, FUNC_RANK, otext)
                spush(res)
        elif opcode == 0x02: #tFuncVar
            nb = 1 + int(bv >= 40)
            nargs, funcx = unpack("<B" + " BH"[nb], data[pos+1:pos+2+nb])
            prompt, nargs = divmod(nargs, 128)
            macro, funcx = divmod(funcx, 32768)
            if verbose:
                print("   FuncID=%d nargs=%d macro=%d prompt=%d" \
                      % (funcx, nargs, macro, prompt))
            func_attrs = func_defs.get(funcx, None)
            if not func_attrs:
                print("*** formula/tFuncVar unknown FuncID:%d" \
                      % funcx, file=bk.logfile)
                spush(unk_opnd)
            else:
                func_name, minargs, maxargs = func_attrs[:3]
                if verbose:
                    print("    name: %r, min~max args: %d~%d" \
                        % (func_name, minargs, maxargs))
                assert minargs <= nargs <= maxargs
                assert len(stack) >= nargs
                assert len(stack) >= nargs
                argtext = listsep.join([arg.text for arg in stack[-nargs:]])
                otext = "%s(%s)" % (func_name, argtext)
                res = Operand(oUNK, None, FUNC_RANK, otext)
                if funcx == 1: # IF
                    testarg = stack[-nargs]
                    if testarg.kind not in (oNUM, oBOOL):
                        if verbose and testarg.kind != oUNK:
                            print("IF testarg kind?")
                    elif testarg.value not in (0, 1):
                        if verbose and testarg.value is not None:
                            print("IF testarg value?")
                    else:
                        if nargs == 2 and not testarg.value:
                            # IF(FALSE, tv) => FALSE
                            res.kind, res.value = oBOOL, 0
                        else:
                            respos = -nargs + 2 - int(testarg.value)
                            chosen = stack[respos]
                            if chosen.kind == oMSNG:
                                res.kind, res.value = oNUM, 0
                            else:
                                res.kind, res.value = chosen.kind, chosen.value
                        if verbose:
                            print("$$$$$$ IF => constant")
                elif funcx == 100: # CHOOSE
                    testarg = stack[-nargs]
                    if testarg.kind == oNUM:
                        if 1 <= testarg.value < nargs:
                            chosen = stack[-nargs + int(testarg.value)]
                            if chosen.kind == oMSNG:
                                res.kind, res.value = oNUM, 0
                            else:
                                res.kind, res.value = chosen.kind, chosen.value
                del stack[-nargs:]
                spush(res)
        elif opcode == 0x03: #tName
            tgtnamex = unpack("<H", data[pos+1:pos+3])[0] - 1
            # Only change with BIFF version is number of trailing UNUSED bytes!
            if verbose: print("   tgtnamex=%d" % tgtnamex, file=bk.logfile)
            tgtobj = bk.name_obj_list[tgtnamex]
            if not tgtobj.evaluated:
                ### recursive ###
                evaluate_name_formula(bk, tgtobj, tgtnamex, verbose, level+1)
            if tgtobj.macro or tgtobj.binary \
            or tgtobj.any_err:
                if verbose:
                    tgtobj.dump(
                        bk.logfile,
                        header="!!! tgtobj has problems!!!",
                        footer="-----------       --------",
                        )
                res = Operand(oUNK, None)
                any_err = any_err or tgtobj.macro or tgtobj.binary or tgtobj.any_err
                any_rel = any_rel or tgtobj.any_rel
            else:
                assert len(tgtobj.stack) == 1
                res = copy.deepcopy(tgtobj.stack[0])
            res.rank = LEAF_RANK
            if tgtobj.scope == -1:
                res.text = tgtobj.name
            else:
                res.text = "%s!%s" \
                           % (bk._sheet_names[tgtobj.scope], tgtobj.name)
            if verbose:
                print("    tName: setting text to", repr(res.text), file=bk.logfile)
            spush(res)
        elif opcode == 0x04: # tRef
            # not_in_name_formula(op, oname)
            res = get_cell_addr(data, pos+1, bv, reldelta)
            if verbose: print("  ", res, file=bk.logfile)
            rowx, colx, row_rel, col_rel = res
            shx1 = shx2 = 0 ####### N.B. relative to the CURRENT SHEET
            any_rel = 1
            coords = (shx1, shx2+1, rowx, rowx+1, colx, colx+1)
            if verbose: print("   ", coords, file=bk.logfile)
            res = Operand(oUNK, None)
            if optype == 1:
                relflags = (1, 1, row_rel, row_rel, col_rel, col_rel)
                res = Operand(oREL, [Ref3D(coords + relflags)])
            spush(res)
        elif opcode == 0x05: # tArea
            # not_in_name_formula(op, oname)
            res1, res2 = get_cell_range_addr(data, pos+1, bv, reldelta)
            if verbose: print("  ", res1, res2, file=bk.logfile)
            rowx1, colx1, row_rel1, col_rel1 = res1
            rowx2, colx2, row_rel2, col_rel2 = res2
            shx1 = shx2 = 0 ####### N.B. relative to the CURRENT SHEET
            any_rel = 1
            coords = (shx1, shx2+1, rowx1, rowx2+1, colx1, colx2+1)
            if verbose: print("   ", coords, file=bk.logfile)
            res = Operand(oUNK, None)
            if optype == 1:
                relflags = (1, 1, row_rel1, row_rel2, col_rel1, col_rel2)
                res = Operand(oREL, [Ref3D(coords + relflags)])
            spush(res)
        elif opcode == 0x06: # tMemArea
            not_in_name_formula(op, oname)
        elif opcode == 0x09: # tMemFunc
            nb = unpack("<H", data[pos+1:pos+3])[0]
            if verbose: print("  %d bytes of cell ref formula" % nb, file=bk.logfile)
            # no effect on stack
        elif opcode == 0x0C: #tRefN
            not_in_name_formula(op, oname)
            # res = get_cell_addr(data, pos+1, bv, reldelta=1)
            # # note *ALL* tRefN usage has signed offset for relative addresses
            # any_rel = 1
            # if verbose: print >> bk.logfile, "   ", res
            # spush(res)
        elif opcode == 0x0D: #tAreaN
            not_in_name_formula(op, oname)
            # res = get_cell_range_addr(data, pos+1, bv, reldelta=1)
            # # note *ALL* tAreaN usage has signed offset for relative addresses
            # any_rel = 1
            # if verbose: print >> bk.logfile, "   ", res
        elif opcode == 0x1A: # tRef3d
            if bv >= 80:
                res = get_cell_addr(data, pos+3, bv, reldelta)
                refx = unpack("<H", data[pos+1:pos+3])[0]
                shx1, shx2 = get_externsheet_local_range(bk, refx, verbose)
            else:
                res = get_cell_addr(data, pos+15, bv, reldelta)
                raw_extshtx, raw_shx1, raw_shx2 = \
                             unpack("<hxxxxxxxxhh", data[pos+1:pos+15])
                if verbose:
                    print("tRef3d", raw_extshtx, raw_shx1, raw_shx2, file=bk.logfile)
                shx1, shx2 = get_externsheet_local_range_b57(
                                bk, raw_extshtx, raw_shx1, raw_shx2, verbose)
            rowx, colx, row_rel, col_rel = res
            is_rel = row_rel or col_rel
            any_rel = any_rel or is_rel
            coords = (shx1, shx2+1, rowx, rowx+1, colx, colx+1)
            any_err |= shx1 < -1
            if verbose: print("   ", coords, file=bk.logfile)
            res = Operand(oUNK, None)
            if is_rel:
                relflags = (0, 0, row_rel, row_rel, col_rel, col_rel)
                ref3d = Ref3D(coords + relflags)
                res.kind = oREL
                res.text = rangename3drel(bk, ref3d)
            else:
                ref3d = Ref3D(coords)
                res.kind = oREF
                res.text = rangename3d(bk, ref3d)
            res.rank = LEAF_RANK
            if optype == 1:
                res.value = [ref3d]
            spush(res)
        elif opcode == 0x1B: # tArea3d
            if bv >= 80:
                res1, res2 = get_cell_range_addr(data, pos+3, bv, reldelta)
                refx = unpack("<H", data[pos+1:pos+3])[0]
                shx1, shx2 = get_externsheet_local_range(bk, refx, verbose)
            else:
                res1, res2 = get_cell_range_addr(data, pos+15, bv, reldelta)
                raw_extshtx, raw_shx1, raw_shx2 = \
                             unpack("<hxxxxxxxxhh", data[pos+1:pos+15])
                if verbose:
                    print("tArea3d", raw_extshtx, raw_shx1, raw_shx2, file=bk.logfile)
                shx1, shx2 = get_externsheet_local_range_b57(
                                bk, raw_extshtx, raw_shx1, raw_shx2, verbose)
            any_err |= shx1 < -1
            rowx1, colx1, row_rel1, col_rel1 = res1
            rowx2, colx2, row_rel2, col_rel2 = res2
            is_rel = row_rel1 or col_rel1 or row_rel2 or col_rel2
            any_rel = any_rel or is_rel
            coords = (shx1, shx2+1, rowx1, rowx2+1, colx1, colx2+1)
            if verbose: print("   ", coords, file=bk.logfile)
            res = Operand(oUNK, None)
            if is_rel:
                relflags = (0, 0, row_rel1, row_rel2, col_rel1, col_rel2)
                ref3d = Ref3D(coords + relflags)
                res.kind = oREL
                res.text = rangename3drel(bk, ref3d)
            else:
                ref3d = Ref3D(coords)
                res.kind = oREF
                res.text = rangename3d(bk, ref3d)
            res.rank = LEAF_RANK
            if optype == 1:
                res.value = [ref3d]

            spush(res)
        elif opcode == 0x19: # tNameX
            dodgy = 0
            res = Operand(oUNK, None)
            if bv >= 80:
                refx, tgtnamex = unpack("<HH", data[pos+1:pos+5])
                tgtnamex -= 1
                origrefx = refx
            else:
                refx, tgtnamex = unpack("<hxxxxxxxxH", data[pos+1:pos+13])
                tgtnamex -= 1
                origrefx = refx
                if refx > 0:
                    refx -= 1
                elif refx < 0:
                    refx = -refx - 1
                else:
                    dodgy = 1
            if verbose:
                print("   origrefx=%d refx=%d tgtnamex=%d dodgy=%d" \
                    % (origrefx, refx, tgtnamex, dodgy), file=bk.logfile)
            if tgtnamex == namex:
                if verbose: print("!!!! Self-referential !!!!", file=bk.logfile)
                dodgy = any_err = 1
            if not dodgy:
                if bv >= 80:
                    shx1, shx2 = get_externsheet_local_range(bk, refx, verbose)
                elif origrefx > 0:
                    shx1, shx2 = (-4, -4) # external ref
                else:
                    exty = bk._externsheet_type_b57[refx]
                    if exty == 4: # non-specific sheet in own doc't
                        shx1, shx2 = (-1, -1) # internal, any sheet
                    else:
                        shx1, shx2 = (-666, -666)
            if dodgy or shx1 < -1:
                otext = "<<Name #%d in external(?) file #%d>>" \
                        % (tgtnamex, origrefx)
                res = Operand(oUNK, None, LEAF_RANK, otext)
            else:
                tgtobj = bk.name_obj_list[tgtnamex]
                if not tgtobj.evaluated:
                    ### recursive ###
                    evaluate_name_formula(bk, tgtobj, tgtnamex, verbose, level+1)
                if tgtobj.macro or tgtobj.binary \
                or tgtobj.any_err:
                    if verbose:
                        tgtobj.dump(
                            bk.logfile,
                            header="!!! bad tgtobj !!!",
                            footer="------------------",
                            )
                    res = Operand(oUNK, None)
                    any_err = any_err or tgtobj.macro or tgtobj.binary or tgtobj.any_err
                    any_rel = any_rel or tgtobj.any_rel
                else:
                    assert len(tgtobj.stack) == 1
                    res = copy.deepcopy(tgtobj.stack[0])
                res.rank = LEAF_RANK
                if tgtobj.scope == -1:
                    res.text = tgtobj.name
                else:
                    res.text = "%s!%s" \
                               % (bk._sheet_names[tgtobj.scope], tgtobj.name)
                if verbose:
                    print("    tNameX: setting text to", repr(res.text), file=bk.logfile)
            spush(res)
        elif opcode in _error_opcodes:
            any_err = 1
            spush(error_opnd)
        else:
            if verbose:
                print("FORMULA: /// Not handled yet: t" + oname, file=bk.logfile)
            any_err = 1
        if sz <= 0:
            raise FormulaError("Fatal: token size is not positive")
        pos += sz
    any_rel = not not any_rel
    if verbose:
        print("End of formula. level=%d any_rel=%d any_err=%d stack=%r" % \
            (level, not not any_rel, any_err, stack))
        if len(stack) >= 2:
            print("*** Stack has unprocessed args")
        print()
    nobj.stack = stack
    if len(stack) != 1:
        nobj.result = None
    else:
        nobj.result = stack[0]
    nobj.any_rel = any_rel
    nobj.any_err = any_err
    nobj.any_external = any_external
    nobj.evaluated = 1

#### under construction ####
def decompile_formula(bk, fmla, fmlalen,
    reldelta, browx=None, bcolx=None,
    # browx & bcolx are required when reldelta == 0
    verbose=0, level=0):
    if level > STACK_ALARM_LEVEL:
        verbose = 1
    data = fmla
    bv = bk.biff_version
    if verbose:
        print("::: decompile_formula len=%d reldelta=%d %r level=%d" \
            % (fmlalen, reldelta, data, level))
        hex_char_dump(data, 0, fmlalen)
    if level > STACK_PANIC_LEVEL:
        raise XLRDError("Excessive indirect references in formula")
    sztab = szdict[bv]
    pos = 0
    stack = []
    any_rel = 0
    any_err = 0
    any_external = 0
    unk_opnd = Operand(oUNK, None)
    error_opnd = Operand(oERR, None)
    spush = stack.append

    def do_binop(opcd, stk):
        assert len(stk) >= 2
        bop = stk.pop()
        aop = stk.pop()
        argdict, result_kind, func, rank, sym = binop_rules[opcd]
        otext = ''.join([
            '('[:aop.rank < rank],
            aop.text,
            ')'[:aop.rank < rank],
            sym,
            '('[:bop.rank < rank],
            bop.text,
            ')'[:bop.rank < rank],
            ])
        resop = Operand(result_kind, None, rank, otext)
        stk.append(resop)

    def do_unaryop(opcode, arglist, result_kind, stk):
        assert len(stk) >= 1
        aop = stk.pop()
        assert aop.kind in arglist
        func, rank, sym1, sym2 = unop_rules[opcode]
        otext = ''.join([
            sym1,
            '('[:aop.rank < rank],
            aop.text,
            ')'[:aop.rank < rank],
            sym2,
            ])
        stk.append(Operand(result_kind, None, rank, otext))

    def not_in_name_formula(op_arg, oname_arg):
        msg = "ERROR *** Unexpected token 0x%02x (%s) found in formula" \
              % (op_arg, oname_arg)
        # print msg
        raise FormulaError(msg)

    if fmlalen == 0:
        stack = [unk_opnd]

    while 0 <= pos < fmlalen:
        op = data[pos]
        opcode = op & 0x1f
        optype = (op & 0x60) >> 5
        if optype:
            opx = opcode + 32
        else:
            opx = opcode
        oname = onames[opx] # + [" RVA"][optype]
        sz = sztab[opx]
        if verbose:
            print("Pos:%d Op:0x%02x opname:t%s Sz:%d opcode:%02xh optype:%02xh" \
                % (pos, op, oname, sz, opcode, optype))
            print("Stack =", stack)
        if sz == -2:
            msg = 'ERROR *** Unexpected token 0x%02x ("%s"); biff_version=%d' \
                % (op, oname, bv)
            raise FormulaError(msg)
        if not optype:
            if 0x00 <= opcode <= 0x02: # unk_opnd, tExp, tTbl
                not_in_name_formula(op, oname)
            elif 0x03 <= opcode <= 0x0E:
                # Add, Sub, Mul, Div, Power
                # tConcat
                # tLT, ..., tNE
                do_binop(opcode, stack)
            elif opcode == 0x0F: # tIsect
                if verbose: print("tIsect pre", stack, file=bk.logfile)
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                sym = ' '
                rank = 80 ########## check #######
                otext = ''.join([
                    '('[:aop.rank < rank],
                    aop.text,
                    ')'[:aop.rank < rank],
                    sym,
                    '('[:bop.rank < rank],
                    bop.text,
                    ')'[:bop.rank < rank],
                    ])
                res = Operand(oREF)
                res.text = otext
                if bop.kind == oERR or aop.kind == oERR:
                    res.kind = oERR
                elif bop.kind == oUNK or aop.kind == oUNK:
                    # This can happen with undefined
                    # (go search in the current sheet) labels.
                    # For example =Bob Sales
                    # Each label gets a NAME record with an empty formula (!)
                    # Evaluation of the tName token classifies it as oUNK
                    # res.kind = oREF
                    pass
                elif bop.kind == oREF == aop.kind:
                    pass
                elif bop.kind == oREL == aop.kind:
                    res.kind = oREL
                else:
                    pass
                spush(res)
                if verbose: print("tIsect post", stack, file=bk.logfile)
            elif opcode == 0x10: # tList
                if verbose: print("tList pre", stack, file=bk.logfile)
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                sym = ','
                rank = 80 ########## check #######
                otext = ''.join([
                    '('[:aop.rank < rank],
                    aop.text,
                    ')'[:aop.rank < rank],
                    sym,
                    '('[:bop.rank < rank],
                    bop.text,
                    ')'[:bop.rank < rank],
                    ])
                res = Operand(oREF, None, rank, otext)
                if bop.kind == oERR or aop.kind == oERR:
                    res.kind = oERR
                elif bop.kind in (oREF, oREL) and aop.kind in (oREF, oREL):
                    res.kind = oREF
                    if aop.kind == oREL or bop.kind == oREL:
                        res.kind = oREL
                else:
                    pass
                spush(res)
                if verbose: print("tList post", stack, file=bk.logfile)
            elif opcode == 0x11: # tRange
                if verbose: print("tRange pre", stack, file=bk.logfile)
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                sym = ':'
                rank = 80 ########## check #######
                otext = ''.join([
                    '('[:aop.rank < rank],
                    aop.text,
                    ')'[:aop.rank < rank],
                    sym,
                    '('[:bop.rank < rank],
                    bop.text,
                    ')'[:bop.rank < rank],
                    ])
                res = Operand(oREF, None, rank, otext)
                if bop.kind == oERR or aop.kind == oERR:
                    res = oERR
                elif bop.kind == oREF == aop.kind:
                    pass
                else:
                    pass
                spush(res)
                if verbose: print("tRange post", stack, file=bk.logfile)
            elif 0x12 <= opcode <= 0x14: # tUplus, tUminus, tPercent
                do_unaryop(opcode, (oUNK, oNUM,), oNUM, stack)
            elif opcode == 0x15: # tParen
                # source cosmetics
                pass
            elif opcode == 0x16: # tMissArg
                spush(Operand(oMSNG, None, LEAF_RANK, ''))
            elif opcode == 0x17: # tStr
                if bv <= 70:
                    strg, newpos = unpack_string_update_pos(
                                        data, pos+1, bk.encoding, lenlen=1)
                else:
                    strg, newpos = unpack_unicode_update_pos(
                                        data, pos+1, lenlen=1)
                sz = newpos - pos
                if verbose: print("   sz=%d strg=%r" % (sz, strg), file=bk.logfile)
                text = '"' + strg.replace('"', '""') + '"'
                spush(Operand(oSTRG, None, LEAF_RANK, text))
            elif opcode == 0x18: # tExtended
                # new with BIFF 8
                assert bv >= 80
                # not in OOo docs
                raise FormulaError("tExtended token not implemented")
            elif opcode == 0x19: # tAttr
                subop, nc = unpack("<BH", data[pos+1:pos+4])
                subname = tAttrNames.get(subop, "??Unknown??")
                if subop == 0x04: # Choose
                    sz = nc * 2 + 6
                elif subop == 0x10: # Sum (single arg)
                    sz = 4
                    if verbose: print("tAttrSum", stack, file=bk.logfile)
                    assert len(stack) >= 1
                    aop = stack[-1]
                    otext = 'SUM(%s)' % aop.text
                    stack[-1] = Operand(oNUM, None, FUNC_RANK, otext)
                else:
                    sz = 4
                if verbose:
                    print("   subop=%02xh subname=t%s sz=%d nc=%02xh" \
                        % (subop, subname, sz, nc))
            elif 0x1A <= opcode <= 0x1B: # tSheet, tEndSheet
                assert bv < 50
                raise FormulaError("tSheet & tEndsheet tokens not implemented")
            elif 0x1C <= opcode <= 0x1F: # tErr, tBool, tInt, tNum
                inx = opcode - 0x1C
                nb = [1, 1, 2, 8][inx]
                kind = [oERR, oBOOL, oNUM, oNUM][inx]
                value, = unpack("<" + "BBHd"[inx], data[pos+1:pos+1+nb])
                if inx == 2: # tInt
                    value = float(value)
                    text = str(value)
                elif inx == 3: # tNum
                    text = str(value)
                elif inx == 1: # tBool
                    text = ('FALSE', 'TRUE')[value]
                else:
                    text = '"' +error_text_from_code[value] + '"'
                spush(Operand(kind, None, LEAF_RANK, text))
            else:
                raise FormulaError("Unhandled opcode: 0x%02x" % opcode)
            if sz <= 0:
                raise FormulaError("Size not set for opcode 0x%02x" % opcode)
            pos += sz
            continue
        if opcode == 0x00: # tArray
            spush(unk_opnd)
        elif opcode == 0x01: # tFunc
            nb = 1 + int(bv >= 40)
            funcx = unpack("<" + " BH"[nb], data[pos+1:pos+1+nb])[0]
            func_attrs = func_defs.get(funcx, None)
            if not func_attrs:
                print("*** formula/tFunc unknown FuncID:%d" % funcx, file=bk.logfile)
                spush(unk_opnd)
            else:
                func_name, nargs = func_attrs[:2]
                if verbose:
                    print("    FuncID=%d name=%s nargs=%d" \
                          % (funcx, func_name, nargs))
                assert len(stack) >= nargs
                argtext = listsep.join([arg.text for arg in stack[-nargs:]])
                otext = "%s(%s)" % (func_name, argtext)
                del stack[-nargs:]
                res = Operand(oUNK, None, FUNC_RANK, otext)
                spush(res)
        elif opcode == 0x02: #tFuncVar
            nb = 1 + int(bv >= 40)
            nargs, funcx = unpack("<B" + " BH"[nb], data[pos+1:pos+2+nb])
            prompt, nargs = divmod(nargs, 128)
            macro, funcx = divmod(funcx, 32768)
            if verbose:
                print("   FuncID=%d nargs=%d macro=%d prompt=%d" \
                      % (funcx, nargs, macro, prompt))
            #### TODO #### if funcx == 255: # call add-in function
            if funcx == 255:
                func_attrs = ("CALL_ADDIN", 1, 30)
            else:
                func_attrs = func_defs.get(funcx, None)
            if not func_attrs:
                print("*** formula/tFuncVar unknown FuncID:%d" \
                      % funcx, file=bk.logfile)
                spush(unk_opnd)
            else:
                func_name, minargs, maxargs = func_attrs[:3]
                if verbose:
                    print("    name: %r, min~max args: %d~%d" \
                        % (func_name, minargs, maxargs))
                assert minargs <= nargs <= maxargs
                assert len(stack) >= nargs
                assert len(stack) >= nargs
                argtext = listsep.join([arg.text for arg in stack[-nargs:]])
                otext = "%s(%s)" % (func_name, argtext)
                res = Operand(oUNK, None, FUNC_RANK, otext)
                del stack[-nargs:]
                spush(res)
        elif opcode == 0x03: #tName
            tgtnamex = unpack("<H", data[pos+1:pos+3])[0] - 1
            # Only change with BIFF version is number of trailing UNUSED bytes!
            if verbose: print("   tgtnamex=%d" % tgtnamex, file=bk.logfile)
            tgtobj = bk.name_obj_list[tgtnamex]
            if tgtobj.scope == -1:
                otext = tgtobj.name
            else:
                otext = "%s!%s" % (bk._sheet_names[tgtobj.scope], tgtobj.name)
            if verbose:
                print("    tName: setting text to", repr(otext), file=bk.logfile)
            res = Operand(oUNK, None, LEAF_RANK, otext)
            spush(res)
        elif opcode == 0x04: # tRef
            res = get_cell_addr(data, pos+1, bv, reldelta, browx, bcolx)
            if verbose: print("  ", res, file=bk.logfile)
            rowx, colx, row_rel, col_rel = res
            is_rel = row_rel or col_rel
            if is_rel:
                okind = oREL
            else:
                okind = oREF
            otext = cellnamerel(rowx, colx, row_rel, col_rel)
            res = Operand(okind, None, LEAF_RANK, otext)
            spush(res)
        elif opcode == 0x05: # tArea
            res1, res2 = get_cell_range_addr(
                            data, pos+1, bv, reldelta, browx, bcolx)
            if verbose: print("  ", res1, res2, file=bk.logfile)
            rowx1, colx1, row_rel1, col_rel1 = res1
            rowx2, colx2, row_rel2, col_rel2 = res2
            coords = (rowx1, rowx2+1, colx1, colx2+1)
            relflags = (row_rel1, row_rel2, col_rel1, col_rel2)
            is_rel = 1 if sum(relflags) else 0 # (to_py3)
            if is_rel:
                okind = oREL
            else:
                okind = oREF
            if verbose: print("   ", coords, relflags, file=bk.logfile)
            otext = rangename2drel(coords, relflags)
            res = Operand(okind, None, LEAF_RANK, otext)
            spush(res)
        elif opcode == 0x06: # tMemArea
            not_in_name_formula(op, oname)
        elif opcode == 0x09: # tMemFunc
            nb = unpack("<H", data[pos+1:pos+3])[0]
            if verbose: print("  %d bytes of cell ref formula" % nb, file=bk.logfile)
            # no effect on stack
        elif opcode == 0x0C: #tRefN
            not_in_name_formula(op, oname)
            # res = get_cell_addr(data, pos+1, bv, reldelta=1)
            # # note *ALL* tRefN usage has signed offset for relative addresses
            # any_rel = 1
            # if verbose: print >> bk.logfile, "   ", res
            # spush(res)
        elif opcode == 0x0D: #tAreaN
            not_in_name_formula(op, oname)
            # res = get_cell_range_addr(data, pos+1, bv, reldelta=1)
            # # note *ALL* tAreaN usage has signed offset for relative addresses
            # any_rel = 1
            # if verbose: print >> bk.logfile, "   ", res
        elif opcode == 0x1A: # tRef3d
            if bv >= 80:
                res = get_cell_addr(data, pos+3, bv, reldelta, browx, bcolx)
                refx = unpack("<H", data[pos+1:pos+3])[0]
                shx1, shx2 = get_externsheet_local_range(bk, refx, verbose)
            else:
                res = get_cell_addr(data, pos+15, bv, reldelta, browx, bcolx)
                raw_extshtx, raw_shx1, raw_shx2 = \
                             unpack("<hxxxxxxxxhh", data[pos+1:pos+15])
                if verbose:
                    print("tRef3d", raw_extshtx, raw_shx1, raw_shx2, file=bk.logfile)
                shx1, shx2 = get_externsheet_local_range_b57(
                                bk, raw_extshtx, raw_shx1, raw_shx2, verbose)
            rowx, colx, row_rel, col_rel = res
            is_rel = row_rel or col_rel
            any_rel = any_rel or is_rel
            coords = (shx1, shx2+1, rowx, rowx+1, colx, colx+1)
            any_err |= shx1 < -1
            if verbose: print("   ", coords, file=bk.logfile)
            res = Operand(oUNK, None)
            if is_rel:
                relflags = (0, 0, row_rel, row_rel, col_rel, col_rel)
                ref3d = Ref3D(coords + relflags)
                res.kind = oREL
                res.text = rangename3drel(bk, ref3d)
            else:
                ref3d = Ref3D(coords)
                res.kind = oREF
                res.text = rangename3d(bk, ref3d)
            res.rank = LEAF_RANK
            res.value = None
            spush(res)
        elif opcode == 0x1B: # tArea3d
            if bv >= 80:
                res1, res2 = get_cell_range_addr(data, pos+3, bv, reldelta)
                refx = unpack("<H", data[pos+1:pos+3])[0]
                shx1, shx2 = get_externsheet_local_range(bk, refx, verbose)
            else:
                res1, res2 = get_cell_range_addr(data, pos+15, bv, reldelta)
                raw_extshtx, raw_shx1, raw_shx2 = \
                             unpack("<hxxxxxxxxhh", data[pos+1:pos+15])
                if verbose:
                    print("tArea3d", raw_extshtx, raw_shx1, raw_shx2, file=bk.logfile)
                shx1, shx2 = get_externsheet_local_range_b57(
                                bk, raw_extshtx, raw_shx1, raw_shx2, verbose)
            any_err |= shx1 < -1
            rowx1, colx1, row_rel1, col_rel1 = res1
            rowx2, colx2, row_rel2, col_rel2 = res2
            is_rel = row_rel1 or col_rel1 or row_rel2 or col_rel2
            any_rel = any_rel or is_rel
            coords = (shx1, shx2+1, rowx1, rowx2+1, colx1, colx2+1)
            if verbose: print("   ", coords, file=bk.logfile)
            res = Operand(oUNK, None)
            if is_rel:
                relflags = (0, 0, row_rel1, row_rel2, col_rel1, col_rel2)
                ref3d = Ref3D(coords + relflags)
                res.kind = oREL
                res.text = rangename3drel(bk, ref3d)
            else:
                ref3d = Ref3D(coords)
                res.kind = oREF
                res.text = rangename3d(bk, ref3d)
            res.rank = LEAF_RANK
            spush(res)
        elif opcode == 0x19: # tNameX
            dodgy = 0
            res = Operand(oUNK, None)
            if bv >= 80:
                refx, tgtnamex = unpack("<HH", data[pos+1:pos+5])
                tgtnamex -= 1
                origrefx = refx
            else:
                refx, tgtnamex = unpack("<hxxxxxxxxH", data[pos+1:pos+13])
                tgtnamex -= 1
                origrefx = refx
                if refx > 0:
                    refx -= 1
                elif refx < 0:
                    refx = -refx - 1
                else:
                    dodgy = 1
            if verbose:
                print("   origrefx=%d refx=%d tgtnamex=%d dodgy=%d" \
                    % (origrefx, refx, tgtnamex, dodgy), file=bk.logfile)
            # if tgtnamex == namex:
            #     if verbose: print >> bk.logfile, "!!!! Self-referential !!!!"
            #     dodgy = any_err = 1
            if not dodgy:
                if bv >= 80:
                    shx1, shx2 = get_externsheet_local_range(bk, refx, verbose)
                elif origrefx > 0:
                    shx1, shx2 = (-4, -4) # external ref
                else:
                    exty = bk._externsheet_type_b57[refx]
                    if exty == 4: # non-specific sheet in own doc't
                        shx1, shx2 = (-1, -1) # internal, any sheet
                    else:
                        shx1, shx2 = (-666, -666)
            okind = oUNK
            ovalue = None
            if shx1 == -5: # addin func name
                okind = oSTRG
                ovalue = bk.addin_func_names[tgtnamex]
                otext = '"' + ovalue.replace('"', '""') + '"'
            elif dodgy or shx1 < -1:
                otext = "<<Name #%d in external(?) file #%d>>" \
                        % (tgtnamex, origrefx)
            else:
                tgtobj = bk.name_obj_list[tgtnamex]
                if tgtobj.scope == -1:
                    otext = tgtobj.name
                else:
                    otext = "%s!%s" \
                            % (bk._sheet_names[tgtobj.scope], tgtobj.name)
                if verbose:
                    print("    tNameX: setting text to", repr(res.text), file=bk.logfile)
            res = Operand(okind, ovalue, LEAF_RANK, otext)
            spush(res)
        elif opcode in _error_opcodes:
            any_err = 1
            spush(error_opnd)
        else:
            if verbose:
                print("FORMULA: /// Not handled yet: t" + oname, file=bk.logfile)
            any_err = 1
        if sz <= 0:
            raise FormulaError("Fatal: token size is not positive")
        pos += sz
    any_rel = not not any_rel
    if verbose:
        print("End of formula. level=%d any_rel=%d any_err=%d stack=%r" % \
            (level, not not any_rel, any_err, stack))
        if len(stack) >= 2:
            print("*** Stack has unprocessed args")
        print()

    if len(stack) != 1:
        result = None
    else:
        result = stack[0].text
    return result

#### under deconstruction ###
def dump_formula(bk, data, fmlalen, bv, reldelta, verbose=0, isname=0):
    if verbose:
        print("dump_formula", fmlalen, bv, len(data))
        hex_char_dump(data, 0, fmlalen)
    assert bv >= 80 #### this function needs updating ####
    sztab = szdict[bv]
    pos = 0
    stack = []
    any_rel = 0
    any_err = 0
    spush = stack.append
    while 0 <= pos < fmlalen:
        op = data[pos]
        opcode = op & 0x1f
        optype = (op & 0x60) >> 5
        if optype:
            opx = opcode + 32
        else:
            opx = opcode
        oname = onames[opx] # + [" RVA"][optype]

        sz = sztab[opx]
        if verbose:
            print("Pos:%d Op:0x%02x Name:t%s Sz:%d opcode:%02xh optype:%02xh" \
                % (pos, op, oname, sz, opcode, optype))
        if not optype:
            if 0x01 <= opcode <= 0x02: # tExp, tTbl
                # reference to a shared formula or table record
                rowx, colx = unpack("<HH", data[pos+1:pos+5])
                if verbose: print("  ", (rowx, colx), file=bk.logfile)
            elif opcode == 0x10: # tList
                if verbose: print("tList pre", stack, file=bk.logfile)
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                spush(aop + bop)
                if verbose: print("tlist post", stack, file=bk.logfile)
            elif opcode == 0x11: # tRange
                if verbose: print("tRange pre", stack, file=bk.logfile)
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                assert len(aop) == 1
                assert len(bop) == 1
                result = do_box_funcs(tRangeFuncs, aop[0], bop[0])
                spush(result)
                if verbose: print("tRange post", stack, file=bk.logfile)
            elif opcode == 0x0F: # tIsect
                if verbose: print("tIsect pre", stack, file=bk.logfile)
                assert len(stack) >= 2
                bop = stack.pop()
                aop = stack.pop()
                assert len(aop) == 1
                assert len(bop) == 1
                result = do_box_funcs(tIsectFuncs, aop[0], bop[0])
                spush(result)
                if verbose: print("tIsect post", stack, file=bk.logfile)
            elif opcode == 0x19: # tAttr
                subop, nc = unpack("<BH", data[pos+1:pos+4])
                subname = tAttrNames.get(subop, "??Unknown??")
                if subop == 0x04: # Choose
                    sz = nc * 2 + 6
                else:
                    sz = 4
                if verbose: print("   subop=%02xh subname=t%s sz=%d nc=%02xh" % (subop, subname, sz, nc), file=bk.logfile)
            elif opcode == 0x17: # tStr
                if bv <= 70:
                    nc = data[pos+1]
                    strg = data[pos+2:pos+2+nc] # left in 8-bit encoding
                    sz = nc + 2
                else:
                    strg, newpos = unpack_unicode_update_pos(data, pos+1, lenlen=1)
                    sz = newpos - pos
                if verbose: print("   sz=%d strg=%r" % (sz, strg), file=bk.logfile)
            else:
                if sz <= 0:
                    print("**** Dud size; exiting ****")
                    return
            pos += sz
            continue
        if opcode == 0x00: # tArray
            pass
        elif opcode == 0x01: # tFunc
            nb = 1 + int(bv >= 40)
            funcx = unpack("<" + " BH"[nb], data[pos+1:pos+1+nb])
            if verbose: print("   FuncID=%d" % funcx, file=bk.logfile)
        elif opcode == 0x02: #tFuncVar
            nb = 1 + int(bv >= 40)
            nargs, funcx = unpack("<B" + " BH"[nb], data[pos+1:pos+2+nb])
            prompt, nargs = divmod(nargs, 128)
            macro, funcx = divmod(funcx, 32768)
            if verbose: print("   FuncID=%d nargs=%d macro=%d prompt=%d" % (funcx, nargs, macro, prompt), file=bk.logfile)
        elif opcode == 0x03: #tName
            namex = unpack("<H", data[pos+1:pos+3])
            # Only change with BIFF version is the number of trailing UNUSED bytes!!!
            if verbose: print("   namex=%d" % namex, file=bk.logfile)
        elif opcode == 0x04: # tRef
            res = get_cell_addr(data, pos+1, bv, reldelta)
            if verbose: print("  ", res, file=bk.logfile)
        elif opcode == 0x05: # tArea
            res = get_cell_range_addr(data, pos+1, bv, reldelta)
            if verbose: print("  ", res, file=bk.logfile)
        elif opcode == 0x09: # tMemFunc
            nb = unpack("<H", data[pos+1:pos+3])[0]
            if verbose: print("  %d bytes of cell ref formula" % nb, file=bk.logfile)
        elif opcode == 0x0C: #tRefN
            res = get_cell_addr(data, pos+1, bv, reldelta=1)
            # note *ALL* tRefN usage has signed offset for relative addresses
            any_rel = 1
            if verbose: print("   ", res, file=bk.logfile)
        elif opcode == 0x0D: #tAreaN
            res = get_cell_range_addr(data, pos+1, bv, reldelta=1)
            # note *ALL* tAreaN usage has signed offset for relative addresses
            any_rel = 1
            if verbose: print("   ", res, file=bk.logfile)
        elif opcode == 0x1A: # tRef3d
            refx = unpack("<H", data[pos+1:pos+3])[0]
            res = get_cell_addr(data, pos+3, bv, reldelta)
            if verbose: print("  ", refx, res, file=bk.logfile)
            rowx, colx, row_rel, col_rel = res
            any_rel = any_rel or row_rel or col_rel
            shx1, shx2 = get_externsheet_local_range(bk, refx, verbose)
            any_err |= shx1 < -1
            coords = (shx1, shx2+1, rowx, rowx+1, colx, colx+1)
            if verbose: print("   ", coords, file=bk.logfile)
            if optype == 1: spush([coords])
        elif opcode == 0x1B: # tArea3d
            refx = unpack("<H", data[pos+1:pos+3])[0]
            res1, res2 = get_cell_range_addr(data, pos+3, bv, reldelta)
            if verbose: print("  ", refx, res1, res2, file=bk.logfile)
            rowx1, colx1, row_rel1, col_rel1 = res1
            rowx2, colx2, row_rel2, col_rel2 = res2
            any_rel = any_rel or row_rel1 or col_rel1 or row_rel2 or col_rel2
            shx1, shx2 = get_externsheet_local_range(bk, refx, verbose)
            any_err |= shx1 < -1
            coords = (shx1, shx2+1, rowx1, rowx2+1, colx1, colx2+1)
            if verbose: print("   ", coords, file=bk.logfile)
            if optype == 1: spush([coords])
        elif opcode == 0x19: # tNameX
            refx, namex = unpack("<HH", data[pos+1:pos+5])
            if verbose: print("   refx=%d namex=%d" % (refx, namex), file=bk.logfile)
        elif opcode in _error_opcodes:
            any_err = 1
        else:
            if verbose: print("FORMULA: /// Not handled yet: t" + oname, file=bk.logfile)
            any_err = 1
        if sz <= 0:
            print("**** Dud size; exiting ****")
            return
        pos += sz
    if verbose:
        print("End of formula. any_rel=%d any_err=%d stack=%r" % \
            (not not any_rel, any_err, stack), file=bk.logfile)
        if len(stack) >= 2:
            print("*** Stack has unprocessed args", file=bk.logfile)

# === Some helper functions for displaying cell references ===

# Note that a "non-standard" syntax is used in row and column
# components in relative references.
# For example, consider a relative reference: up two rows, right 3 columns.
# On screen, with cursor in cell D10, this would appear as G8.
# On screen, with cursor in cell Z100, this would appear as AC98.
# On screen, with cursor in cell A1, this would appear as D65535.
# These functions will display such a reference as [@+3,#-2].
# "@" refers to the unknown base column.
# "#" refers to the unknown base row.
#
# I'm aware of only one possibility of a sheet-relative component in
# a reference: a 2D reference located in the "current sheet".
# xlrd stores this internally with bounds of (0, 1, ...) and
# relative flags of (1, 1, ...). These functions display the
# sheet component as empty, just like Excel etc.

def rownamerel(rowx, rowxrel):
    if not rowxrel:
        return "$%d" % rowx
    if rowx > 0:
        return "#+%d" % rowx
    if rowx < 0:
        return "#-%d" % (-rowx)
    return "#"

def colnamerel(colx, colxrel):
    if not colxrel:
        return "$" + colname(colx)
    if colx > 0:
        return "@+%d" % colx
    if colx < 0:
        return "@-%d" % (-colx)
    return "@"
##
# Utility function: (5, 7) => 'H6'
def cellname(rowx, colx):
    """ (5, 7) => 'H6' """
    return "%s%d" % (colname(colx), rowx+1)

##
# Utility function: (5, 7) => '$H$6'
def cellnameabs(rowx, colx):
    """ (5, 7) => '$H$6' """
    return "$%s$%d" % (colname(colx), rowx+1)

def cellnamerel(rowx, colx, rowxrel, colxrel):
    if not rowxrel and not colxrel:
        return cellnameabs(rowx, colx)
    return "[%s,%s]" % (
        colnamerel(colx, colxrel),
        rownamerel(rowx, rowxrel))
##
# Utility function: 7 => 'H', 27 => 'AB'
def colname(colx):
    """ 7 => 'H', 27 => 'AB' """
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    if colx <= 25:
        return alphabet[colx]
    else:
        xdiv26, xmod26 = divmod(colx, 26)
        return alphabet[xdiv26 - 1] + alphabet[xmod26]

def rangename2d(rlo, rhi, clo, chi):
    """ (5, 20, 7, 10) => '$H$6:$J$20' """
    if rhi == rlo+1 and chi == clo+1:
        return cellnameabs(rlo, clo)
    return "%s:%s" % (cellnameabs(rlo, clo), cellnameabs(rhi-1, chi-1))

def rangename2drel(xxx_todo_changeme, xxx_todo_changeme1):
    (rlo, rhi, clo, chi) = xxx_todo_changeme
    (rlorel, rhirel, clorel, chirel) = xxx_todo_changeme1
    return "%s:%s" % (
        cellnamerel(rlo, clo, rlorel, clorel),
        cellnamerel(rhi-1, chi-1, rhirel, chirel)
        )
##
# Utility function:
# <br /> Ref3D((1, 4, 5, 20, 7, 10)) => 'Sheet2:Sheet3!$H$6:$J$20'
def rangename3d(book, ref3d):
    """ Ref3D(1, 4, 5, 20, 7, 10) => 'Sheet2:Sheet3!$H$6:$J$20'
        (assuming Excel's default sheetnames) """
    coords = ref3d.coords
    return "%s!%s" % (
        sheetrange(book, *coords[:2]),
        rangename2d(*coords[2:6]))

##
# Utility function:
# <br /> Ref3D(coords=(0, 1, -32, -22, -13, 13), relflags=(0, 0, 1, 1, 1, 1))
# => 'Sheet1![@-13,#-32]:[@+12,#-23]'
# where '@' refers to the current or base column and '#'
# refers to the current or base row.
def rangename3drel(book, ref3d):
    coords = ref3d.coords
    relflags = ref3d.relflags
    shdesc = sheetrangerel(book, coords[:2], relflags[:2])
    rngdesc = rangename2drel(coords[2:6], relflags[2:6])
    if not shdesc:
        return rngdesc
    return "%s!%s" % (shdesc, rngdesc)

def quotedsheetname(shnames, shx):
    if shx >= 0:
        shname = shnames[shx]
    else:
        shname = {
            -1: "?internal; any sheet?",
            -2: "internal; deleted sheet",
            -3: "internal; macro sheet",
            -4: "<<external>>",
            }.get(shx, "?error %d?" % shx)
    if "'" in shname:
        return "'" + shname.replace("'", "''") + "'"
    if " " in shname:
        return "'" + shname + "'"
    return shname

def sheetrange(book, slo, shi):
    shnames = book.sheet_names()
    shdesc = quotedsheetname(shnames, slo)
    if slo != shi-1:
        shdesc += ":" + quotedsheetname(shnames, shi-1)
    return shdesc

def sheetrangerel(book, xxx_todo_changeme2, xxx_todo_changeme3):
    (slo, shi) = xxx_todo_changeme2
    (slorel, shirel) = xxx_todo_changeme3
    if not slorel and not shirel:
        return sheetrange(book, slo, shi)
    assert (slo == 0 == shi-1) and slorel and shirel
    return ""

# ==============================================================

########NEW FILE########
__FILENAME__ = sheet
# Portions copyright  2005-2009 Stephen John Machin, Lingfo Pty Ltd
# This module is part of the xlrd3 package, which is released under a
# BSD-style licence.

# 2009-05-31 SJM Fixed problem with no CODEPAGE record on extremely minimal BIFF2.x 3rd-party file
# 2009-04-27 SJM Integrated on_demand patch by Armando Serrano Lombillo
# 2008-02-09 SJM Excel 2.0: build XFs on the fly from cell attributes
# 2007-12-04 SJM Added support for Excel 2.x (BIFF2) files.
# 2007-10-11 SJM Added missing entry for blank cell type to ctype_text
# 2007-07-11 SJM Allow for BIFF2/3-style FORMAT record in BIFF4/8 file
# 2007-04-22 SJM Remove experimental "trimming" facility.

#for debugging only
from math import isnan

import time
from struct import unpack
from array import array

from .biffh import *
from .formula import dump_formula, decompile_formula, rangename2d
from .formatting import nearest_colour_index, Format
from .xfcell import XFCell

DEBUG = 0
OBJ_MSO_DEBUG = 0

_WINDOW2_options = (
    # Attribute names and initial values to use in case
    # a WINDOW2 record is not written.
    ("show_formulas", 0),
    ("show_grid_lines", 1),
    ("show_sheet_headers", 1),
    ("panes_are_frozen", 0),
    ("show_zero_values", 1),
    ("automatic_grid_line_colour", 1),
    ("columns_from_right_to_left", 0),
    ("show_outline_symbols", 1),
    ("remove_splits_if_pane_freeze_is_removed", 0),
    ("sheet_selected", 0),
    # "sheet_visible" appears to be merely a clone of "sheet_selected".
    # The real thing is the visibility attribute from the BOUNDSHEET record.
    ("sheet_visible", 0),
    ("show_in_page_break_preview", 0),
    )

def int_floor_div(x, y):
    return divmod(x, y)[0]

class Sheet(BaseObject):
    """Contains the data for one worksheet.

    In the cell access functions, "rowx" is a row index, counting from zero,
    and "colx" is a column index, counting from zero.
    Negative values for row/column indexes and slice positions are supported in
    the expected fashion.

    For information about cell types and cell values, refer to the documentation
    of the Cell class.

    WARNING: You don't call this class yourself. You access Sheet objects via
    the Book object that was returned when you called xlrd.open_workbook("myfile.xls").
    """

    # Name of sheet.
    name = ''

    # Number of rows in sheet. A row index is in range(thesheet.nrows).
    nrows = 0

    # Number of columns in sheet. A column index is in range(thesheet.ncols).
    ncols = 0

    # The map from a column index to a Colinfo object. Often there is an entry
    # in COLINFO records for all column indexes in range(257).
    # Note that xlrd ignores the entry for the non-existent
    # 257th column. On the other hand, there may be no entry for unused columns.
    # - New in version 0.6.1
    colinfo_map = {}

    # The map from a row index to a Rowinfo object. Note that it is possible
    # to have missing entries -- at least one source of XLS files doesn't
    # bother writing ROW records.
    # - New in version 0.6.1
    rowinfo_map = {}

    # List of address ranges of cells containing column labels.
    # These are set up in Excel by Insert > Name > Labels > Columns.
    # - New in version 0.6.0
    # How to deconstruct the list::
    #
    # for crange in thesheet.col_label_ranges:
    #     rlo, rhi, clo, chi = crange
    #     for rx in xrange(rlo, rhi):
    #         for cx in xrange(clo, chi):
    #             print "Column label at (rowx=%d, colx=%d) is %r" \
    #                 (rx, cx, thesheet.cell_value(rx, cx))
    #
    col_label_ranges = []

    # List of address ranges of cells containing row labels.
    # For more details, see <i>col_label_ranges</i> above.
    # - New in version 0.6.0
    row_label_ranges = []

    # List of address ranges of cells which have been merged.
    # These are set up in Excel by Format > Cells > Alignment, then ticking
    # the "Merge cells" box.
    # - New in version 0.6.1. Extracted only if open_workbook(..., formatting_info=True)
    # How to deconstruct the list::
    #
    # for crange in thesheet.merged_cells:
    #     rlo, rhi, clo, chi = crange
    #     for rowx in xrange(rlo, rhi):
    #         for colx in xrange(clo, chi):
    #             # cell (rlo, clo) (the top left one) will carry the data
    #             # and formatting info; the remainder will be recorded as
    #             # blank cells, but a renderer will apply the formatting info
    #             # for the top left cell (e.g. border, pattern) to all cells in
    #             # the range.
    #
    merged_cells = []

    # Default column width from DEFCOLWIDTH record, else None.
    # From the OOo docs:
    # """Column width in characters, using the width of the zero character
    # from default font (first FONT record in the file). Excel adds some
    # extra space to the default width, depending on the default font and
    # default font size. The algorithm how to exactly calculate the resulting
    # column width is not known.
    # Example: The default width of 8 set in this record results in a column
    # width of 8.43 using Arial font with a size of 10 points."""
    # For the default hierarchy, refer to the Colinfo class above.
    # - New in version 0.6.1
    defcolwidth = None

    # Default column width from STANDARDWIDTH record, else None.
    # From the OOo docs:
    # """Default width of the columns in 1/256 of the width of the zero
    # character, using default font (first FONT record in the file)."""
    # For the default hierarchy, refer to the Colinfo class above.
    # - New in version 0.6.1
    standardwidth = None

    # Default value to be used for a row if there is
    # no ROW record for that row.
    # From the <i>optional</i> DEFAULTROWHEIGHT record.
    default_row_height = None

    # Default value to be used for a row if there is
    # no ROW record for that row.
    # From the optional DEFAULTROWHEIGHT record.
    default_row_height_mismatch = None

    # Default value to be used for a row if there is
    # no ROW record for that row.
    # From the optional DEFAULTROWHEIGHT record.
    default_row_hidden = None

    # Default value to be used for a row if there is
    # no ROW record for that row.
    # From the <i>optional</i> DEFAULTROWHEIGHT record.
    default_additional_space_above = None

    # Default value to be used for a row if there is
    # no ROW record for that row.
    # From the <i>optional</i> DEFAULTROWHEIGHT record.
    default_additional_space_below = None

    # Visibility of the sheet. 0 = visible, 1 = hidden (can be unhidden
    # by user -- Format/Sheet/Unhide), 2 = "very hidden" (can be unhidden
    # only by VBA macro).
    visibility = 0

    # A 256-element tuple corresponding to the contents of the GCW record for this sheet.
    # If no such record, treat as all bits zero.
    # Applies to BIFF4-7 only. See docs of Colinfo class for discussion.
    gcw = (0, ) * 256

    def __init__(self, book, position, name, number):
        self.book = book
        self.biff_version = book.biff_version
        self._position = position
        self.logfile = book.logfile
        self.pickleable = book.pickleable
        # (to_py3) self.dont_use_array = not(array_array and (CAN_PICKLE_ARRAY or not book.pickleable))
        self.name = name
        self.number = number
        self.verbosity = book.verbosity
        self.formatting_info = book.formatting_info
        self._xf_index_to_xl_type_map = book._xf_index_to_xl_type_map
        self.nrows = 0 # actual, including possibly empty cells
        self.ncols = 0
        self._maxdatarowx = -1 # highest rowx containing a non-empty cell
        self._maxdatacolx = -1 # highest colx containing a non-empty cell
        self._dimnrows = 0 # as per DIMENSIONS record
        self._dimncols = 0
        self._cell_values = []
        self._cell_types = []
        self._cell_xf_indexes = []
        self._need_fix_ragged_rows = 0
        self.defcolwidth = None
        self.standardwidth = None
        self.default_row_height = None
        self.default_row_height_mismatch = 0
        self.default_row_hidden = 0
        self.default_additional_space_above = 0
        self.default_additional_space_below = 0
        self.colinfo_map = {}
        self.rowinfo_map = {}
        self.col_label_ranges = []
        self.row_label_ranges = []
        self.merged_cells = []
        self._xf_index_stats = [0, 0, 0, 0]
        self.visibility = book._sheet_visibility[number] # from BOUNDSHEET record
        for attr, defval in _WINDOW2_options:
            setattr(self, attr, defval)
        self.first_visible_rowx = 0
        self.first_visible_colx = 0
        self.gridline_colour_index = 0x40
        self.gridline_colour_rgb = None # pre-BIFF8
        self.cached_page_break_preview_mag_factor = 0
        self.cached_normal_view_mag_factor = 0
        self._ixfe = None # BIFF2 only
        self._cell_attr_to_xfx = {} # BIFF2.0 only

        #### Don't initialise this here, use class attribute initialisation.
        #### self.gcw = (0, ) * 256 ####

        if self.biff_version >= 80:
            self.utter_max_rows = 65536
        else:
            self.utter_max_rows = 16384
        self.utter_max_cols = 256

    def cell(self, rowx, colx):
        """ Get the XFCell() object in the given row and column. """
        if self.formatting_info:
            xf_index = self.cell_xf_index(rowx, colx)
        else:
            xf_index = None
        ctype = self.cell_type(rowx, colx)
        value = self.cell_value(rowx, colx)
        return Cell(ctype, value, xf_index, self)

    def cell_value(self, rowx, colx):
        """ Value of the cell in the given row and column. """
        return self._cell_values[rowx][colx]

    def cell_type(self, rowx, colx):
        """ Type of the cell in the given row and column.
        Refer to the documentation of the Cell class.
        """
        return self._cell_types[rowx][colx]

    # New in version 0.6.1
    def cell_xf_index(self, rowx, colx):
        """ XF index of the cell in the given row and column.
        This is an index into Book.xf_list.
        """
        self.req_fmt_info()
        xfx = self._cell_xf_indexes[rowx][colx]
        if xfx > -1:
            self._xf_index_stats[0] += 1
            return xfx
        # Check for a row xf_index
        try:
            xfx = self.rowinfo_map[rowx].xf_index
            if xfx > -1:
                self._xf_index_stats[1] += 1
                return xfx
        except KeyError:
            pass
        # Check for a column xf_index
        try:
            xfx = self.colinfo_map[colx].xf_index
            assert xfx > -1
            self._xf_index_stats[2] += 1
            return xfx
        except KeyError:
            # If all else fails, 15 is used as hardwired global default xf_index.
            self._xf_index_stats[3] += 1
            return 15


    def row(self, rowx):
        """ Returns a sequence of the Cell objects in the given row. """
        return [self.cell(rowx, colx) for colx in range(self.ncols)]

    def row_types(self, rowx, start_colx=0, end_colx=None):
        """ Returns a slice of the types of the cells in the given row. """
        if end_colx is None:
            return self._cell_types[rowx][start_colx:]
        return self._cell_types[rowx][start_colx:end_colx]

    def row_values(self, rowx, start_colx=0, end_colx=None):
        """ Returns a slice of the values of the cells in the given row. """
        if end_colx is None:
            return self._cell_values[rowx][start_colx:]
        return self._cell_values[rowx][start_colx:end_colx]

    def row_slice(self, rowx, start_colx=0, end_colx=None):
        """ Returns a slice of the Cell objects in the given row. """
        nc = self.ncols
        if start_colx < 0:
            start_colx += nc
            if start_colx < 0:
                start_colx = 0
        if end_colx is None or end_colx > nc:
            end_colx = nc
        elif end_colx < 0:
            end_colx += nc
        return [self.cell(rowx, colx) for colx in range(start_colx, end_colx)]

    def col_slice(self, colx, start_rowx=0, end_rowx=None):
        """ Returns a slice of the Cell objects in the given column. """
        nr = self.nrows
        if start_rowx < 0:
            start_rowx += nr
            if start_rowx < 0:
                start_rowx = 0
        if end_rowx is None or end_rowx > nr:
            end_rowx = nr
        elif end_rowx < 0:
            end_rowx += nr
        return [self.cell(rowx, colx) for rowx in range(start_rowx, end_rowx)]

    col = col_slice
    """ Returns a sequence of the Cell objects in the given column. """

    def col_values(self, colx, start_rowx=0, end_rowx=None):
        """ Returns a slice of the values of the cells in the given column. """
        nr = self.nrows
        if start_rowx < 0:
            start_rowx += nr
            if start_rowx < 0:
                start_rowx = 0
        if end_rowx is None or end_rowx > nr:
            end_rowx = nr
        elif end_rowx < 0:
            end_rowx += nr
        return [self._cell_values[rowx][colx] for rowx in range(start_rowx, end_rowx)]

    def col_types(self, colx, start_rowx=0, end_rowx=None):
        """ Returns a slice of the types of the cells in the given column. """
        nr = self.nrows
        if start_rowx < 0:
            start_rowx += nr
            if start_rowx < 0:
                start_rowx = 0
        if end_rowx is None or end_rowx > nr:
            end_rowx = nr
        elif end_rowx < 0:
            end_rowx += nr
        return [self._cell_types[rowx][colx] for rowx in range(start_rowx, end_rowx)]

    # Following methods are used in building the worksheet.
    # They are not part of the API.

    def extend_cells(self, nr, nc):
        assert 1 <= nc <= self.utter_max_cols
        assert 1 <= nr <= self.utter_max_rows
        if nr <= self.nrows:
            # New cell is in an existing row, so extend that row (if necessary).
            # Note that nr < self.nrows means that the cell data
            # is not in ascending row order!!
            self._need_fix_ragged_rows = 1
            nrx = nr - 1
            trow = self._cell_types[nrx]
            tlen = len(trow)
            nextra = max(nc, self.ncols) - tlen
            if nextra > 0:
                xce = XL_CELL_EMPTY
                #(to_py3) if self.dont_use_array: ... removed
                trow.extend(array('B', [xce]) * nextra)
                if self.formatting_info:
                    self._cell_xf_indexes[nrx].extend(array('h', [-1]) * nextra)
                self._cell_values[nrx].extend([''] * nextra)
        if nc > self.ncols:
            self.ncols = nc
            self._need_fix_ragged_rows = 1
        if nr > self.nrows:
            scta = self._cell_types.append
            scva = self._cell_values.append
            scxa = self._cell_xf_indexes.append
            fmt_info = self.formatting_info
            xce = XL_CELL_EMPTY
            nc = self.ncols

            #(to_py3) if self.dont_use_array: ... removed
            for _unused in range(self.nrows, nr):
                scta(array('B', [xce]) * nc)
                scva([''] * nc)
                if fmt_info:
                    scxa(array('h', [-1]) * nc)
            self.nrows = nr

    def fix_ragged_rows(self):
        t0 = time.time()
        ncols = self.ncols
        xce = XL_CELL_EMPTY
        s_cell_types = self._cell_types
        s_cell_values = self._cell_values
        s_cell_xf_indexes = self._cell_xf_indexes
        s_fmt_info = self.formatting_info
        totrowlen = 0
        for rowx in range(self.nrows):
            trow = s_cell_types[rowx]
            rlen = len(trow)
            totrowlen += rlen
            nextra = ncols - rlen
            if nextra > 0:
                s_cell_values[rowx][rlen:] = [''] * nextra
                trow.extend(array('B', [xce]) * nextra)
                if s_fmt_info:
                    s_cell_xf_indexes[rowx][rlen:] = array('h', [-1]) * nextra
        self._fix_ragged_rows_time = time.time() - t0

    def tidy_dimensions(self):
        if self.verbosity >= 3:
            fprintf(self.logfile,
                "tidy_dimensions: nrows=%d ncols=%d _need_fix_ragged_rows=%d\n",
                self.nrows, self.ncols, self._need_fix_ragged_rows)
        if self.merged_cells:
            nr = nc = 0
            umaxrows = self.utter_max_rows
            umaxcols = self.utter_max_cols
            for crange in self.merged_cells:
                rlo, rhi, clo, chi = crange
                if not (0 <= rlo < rhi <= umaxrows) \
                or not (0 <= clo < chi <= umaxcols):
                    fprintf(self.logfile,
                        "*** WARNING: sheet #%d (%r), MERGEDCELLS bad range %r\n",
                        self.number, self.name, crange)
                if rhi > nr: nr = rhi
                if chi > nc: nc = chi
            self.extend_cells(nr, nc)
        if self.verbosity >= 1 and \
           (self.nrows != self._dimnrows or self.ncols != self._dimncols):
            fprintf(self.logfile,
                "NOTE *** sheet %d (%r): DIMENSIONS R,C = %d,%d should be %d,%d\n",
                self.number,
                self.name,
                self._dimnrows,
                self._dimncols,
                self.nrows,
                self.ncols,
                )
        if self._need_fix_ragged_rows:
            self.fix_ragged_rows()

    def put_cell(self, rowx, colx, ctype, value, xf_index):
        try:
            self._cell_types[rowx][colx] = ctype
            self._cell_values[rowx][colx] = value
            if self.formatting_info:
                self._cell_xf_indexes[rowx][colx] = xf_index
        except IndexError:
            self.extend_cells(rowx+1, colx+1)
            try:
                self._cell_types[rowx][colx] = ctype
                self._cell_values[rowx][colx] = value
                if self.formatting_info:
                    self._cell_xf_indexes[rowx][colx] = xf_index
            except:
                print("put_cell", rowx, colx, file=self.logfile)
                raise
        except:
            print("put_cell", rowx, colx, file=self.logfile)
            raise

    def put_blank_cell(self, rowx, colx, xf_index):
        # This is used for cells from BLANK and MULBLANK records
        ctype = XL_CELL_BLANK
        value = ''
        try:
            self._cell_types[rowx][colx] = ctype
            self._cell_values[rowx][colx] = value
            self._cell_xf_indexes[rowx][colx] = xf_index
        except IndexError:
            self.extend_cells(rowx+1, colx+1)
            try:
                self._cell_types[rowx][colx] = ctype
                self._cell_values[rowx][colx] = value
                self._cell_xf_indexes[rowx][colx] = xf_index
            except:
                print("put_cell", rowx, colx, file=self.logfile)
                raise
        except:
            print("put_cell", rowx, colx, file=self.logfile)
            raise

    def put_number_cell(self, rowx, colx, value, xf_index):
        # for debugging
        if type(value) == float and isnan(value):
            pass
        ctype = self._xf_index_to_xl_type_map[xf_index]
        try:
            self._cell_types[rowx][colx] = ctype
            self._cell_values[rowx][colx] = value
            if self.formatting_info:
                self._cell_xf_indexes[rowx][colx] = xf_index
        except IndexError:
            self.extend_cells(rowx+1, colx+1)
            try:
                self._cell_types[rowx][colx] = ctype
                self._cell_values[rowx][colx] = value
                if self.formatting_info:
                    self._cell_xf_indexes[rowx][colx] = xf_index
            except:
                print("put_number_cell", rowx, colx, file=self.logfile)
                raise
        except:
            print("put_number_cell", rowx, colx, file=self.logfile)
            raise

    # === Methods after this line neither know nor care about how cells are stored.

    def read(self, bk):
        global rc_stats
        DEBUG = 0
        verbose = DEBUG or self.verbosity >= 2
        verbose_rows = DEBUG or self.verbosity >= 4
        verbose_formulas = 1 and verbose
        oldpos = bk._position
        bk._position = self._position
        XL_SHRFMLA_ETC_ETC = (
            XL_SHRFMLA, XL_ARRAY, XL_TABLEOP, XL_TABLEOP2,
            XL_ARRAY2, XL_TABLEOP_B2,
            )
        self_put_number_cell = self.put_number_cell
        self_put_cell = self.put_cell
        self_put_blank_cell = self.put_blank_cell
        local_unpack = unpack
        bk_get_record_parts = bk.get_record_parts
        bv = self.biff_version
        fmt_info = self.formatting_info
        eof_found = 0
        while 1:
            rc, data_len, data = bk_get_record_parts()
            if rc == XL_NUMBER:
                rowx, colx, xf_index, d = local_unpack('<HHHd', data)
                self_put_number_cell(rowx, colx, d, xf_index)
            elif rc == XL_LABELSST:
                rowx, colx, xf_index, sstindex = local_unpack('<HHHi', data)
                self_put_cell(rowx, colx, XL_CELL_TEXT, bk._sharedstrings[sstindex], xf_index)
            elif rc == XL_LABEL or rc == XL_RSTRING:
                rowx, colx, xf_index = local_unpack('<HHH', data[0:6])
                if bv < BIFF_FIRST_UNICODE:
                    strg = unpack_string(data, 6, bk.encoding or bk.derive_encoding, lenlen=2)
                else:
                    strg = unpack_unicode(data, 6, lenlen=2)
                self_put_cell(rowx, colx, XL_CELL_TEXT, strg, xf_index)
            elif rc == XL_RK:
                rowx, colx, xf_index = local_unpack('<HHH', data[:6])
                d = unpack_RK(data[6:10])
                self_put_number_cell(rowx, colx, d, xf_index)
            elif rc == XL_MULRK:
                mulrk_row, mulrk_first = local_unpack('<HH', data[0:4])
                mulrk_last, = local_unpack('<H', data[-2:])
                pos = 4
                for colx in range(mulrk_first, mulrk_last+1):
                    xf_index, = local_unpack('<H', data[pos:pos+2])
                    d = unpack_RK(data[pos+2:pos+6])
                    pos += 6
                    self_put_number_cell(mulrk_row, colx, d, xf_index)
            elif rc == XL_ROW:
                # Version 0.6.0a3: ROW records are just not worth using (for memory allocation).
                # Version 0.6.1: now used for formatting info.
                if not fmt_info: continue
                rowx, bits1, bits2 = local_unpack('<H4xH4xi', data[0:16])
                if not(0 <= rowx < self.utter_max_rows):
                    print("*** NOTE: ROW record has row index %d; " \
                        "should have 0 <= rowx < %d -- record ignored!" \
                        % (rowx, self.utter_max_rows), file=self.logfile)
                    continue
                r = Rowinfo()
                # Using upkbits() is far too slow on a file
                # with 30 sheets each with 10K rows :-(
                #    upkbits(r, bits1, (
                #        ( 0, 0x7FFF, 'height'),
                #        (15, 0x8000, 'has_default_height'),
                #        ))
                #    upkbits(r, bits2, (
                #        ( 0, 0x00000007, 'outline_level'),
                #        ( 4, 0x00000010, 'outline_group_starts_ends'),
                #        ( 5, 0x00000020, 'hidden'),
                #        ( 6, 0x00000040, 'height_mismatch'),
                #        ( 7, 0x00000080, 'has_default_xf_index'),
                #        (16, 0x0FFF0000, 'xf_index'),
                #        (28, 0x10000000, 'additional_space_above'),
                #        (29, 0x20000000, 'additional_space_below'),
                #        ))
                # So:
                r.height = bits1 & 0x7fff
                r.has_default_height = (bits1 >> 15) & 1
                r.outline_level = bits2 & 7
                r.outline_group_starts_ends = (bits2 >> 4) & 1
                r.hidden = (bits2 >> 5) & 1
                r.height_mismatch = (bits2 >> 6) & 1
                r.has_default_xf_index = (bits2 >> 7) & 1
                r.xf_index = (bits2 >> 16) & 0xfff
                r.additional_space_above = (bits2 >> 28) & 1
                r.additional_space_below = (bits2 >> 29) & 1
                if not r.has_default_xf_index:
                    r.xf_index = -1
                self.rowinfo_map[rowx] = r
                if 0 and r.xf_index > -1:
                    fprintf(self.logfile,
                        "**ROW %d %d %d\n",
                        self.number, rowx, r.xf_index)
                if verbose_rows:
                    print('ROW', rowx, bits1, bits2, file=self.logfile)
                    r.dump(self.logfile,
                        header="--- sh #%d, rowx=%d ---" % (self.number, rowx))
            elif rc in XL_FORMULA_OPCODES: # 06, 0206, 0406
                if bv >= 50:
                    # IMPORTANT result_str is bytes
                    rowx, colx, xf_index, result_str, flags = local_unpack('<HHH8sH', data[0:16])
                    lenlen = 2
                    tkarr_offset = 20
                elif bv >= 30:
                    rowx, colx, xf_index, result_str, flags = local_unpack('<HHH8sH', data[0:16])
                    lenlen = 2
                    tkarr_offset = 16
                else: # BIFF2
                    rowx, colx, cell_attr,  result_str, flags = local_unpack('<HH3s8sB', data[0:16])
                    xf_index =  self.fixed_BIFF2_xfindex(cell_attr, rowx, colx)
                    lenlen = 1
                    tkarr_offset = 16
                if verbose_formulas: # testing formula dumper
                    #### XXXX FIXME
                    fprintf(self.logfile, "FORMULA: rowx=%d colx=%d\n", rowx, colx)
                    fmlalen = local_unpack("<H", data[20:22])[0]
                    decompile_formula(bk, data[22:], fmlalen,
                        reldelta=0, browx=rowx, bcolx=colx, verbose=1)
                if result_str[6:8] == b'\xFF\xFF':
                    if result_str[0]  == 0: #b'\x00':
                        # need to read next record (STRING)
                        gotstring = 0
                        # if flags & 8:
                        if 1: # "flags & 8" applies only to SHRFMLA
                            # actually there's an optional SHRFMLA or ARRAY etc record to skip over
                            rc2, data2_len, data2 = bk.get_record_parts()
                            if rc2 == XL_STRING or rc2 == XL_STRING_B2:
                                gotstring = 1
                            elif rc2 == XL_ARRAY:
                                row1x, rownx, col1x, colnx, array_flags, tokslen = \
                                    local_unpack("<HHBBBxxxxxH", data2[:14])
                                if verbose_formulas:
                                    fprintf(self.logfile, "ARRAY: %d %d %d %d %d\n",
                                        row1x, rownx, col1x, colnx, array_flags)
                                    dump_formula(bk, data2[14:], tokslen, bv, reldelta=0, verbose=1)
                            elif rc2 == XL_SHRFMLA:
                                row1x, rownx, col1x, colnx, nfmlas, tokslen = \
                                    local_unpack("<HHBBxBH", data2[:10])
                                if verbose_formulas:
                                    fprintf(self.logfile, "SHRFMLA (sub): %d %d %d %d %d\n",
                                        row1x, rownx, col1x, colnx, nfmlas)
                                    decompile_formula(bk, data2[10:], tokslen, reldelta=1, verbose=1)
                            elif rc2 not in XL_SHRFMLA_ETC_ETC:
                                raise XLRDError(
                                    "Expected SHRFMLA, ARRAY, TABLEOP* or STRING record; found 0x%04x" % rc2)
                            # if DEBUG: print "gotstring:", gotstring
                        # now for the STRING record
                        if not gotstring:
                            rc2, _unused_len, data2 = bk.get_record_parts()
                            if rc2 not in (XL_STRING, XL_STRING_B2):
                                raise XLRDError("Expected STRING record; found 0x%04x" % rc2)
                        # if DEBUG: print "STRING: data=%r BIFF=%d cp=%d" % (data2, self.biff_version, bk.encoding)
                        if self.biff_version < BIFF_FIRST_UNICODE:
                            strg = unpack_string(data2, 0, bk.encoding or bk.derive_encoding, lenlen=1 + int(bv > 20))
                        else:
                            strg = unpack_unicode(data2, 0, lenlen=2)
                        self.put_cell(rowx, colx, XL_CELL_TEXT, strg, xf_index)
                        # if DEBUG: print "FORMULA strg %r" % strg
                    elif result_str[0] == 1: #b'\x01':
                        # boolean formula result
                        value = result_str[2]
                        self.put_cell(rowx, colx, XL_CELL_BOOLEAN, value, xf_index)
                    elif result_str[0] == 2: #b'\x02':
                        # Error in cell
                        value = result_str[2]
                        self.put_cell(rowx, colx, XL_CELL_ERROR, value, xf_index)
                    elif result_str[0] == 3:#b'\x03':
                        # empty ... i.e. empty (zero-length) string, NOT an empty cell.
                        self.put_cell(rowx, colx, XL_CELL_TEXT, "", xf_index)
                    else:
                        raise XLRDError("unexpected special case (0x%02x) in FORMULA" % result_str[0])
                else:
                    # it is a number
                    d = local_unpack('<d', result_str)[0]
                    self_put_number_cell(rowx, colx, d, xf_index)
            elif rc == XL_BOOLERR:
                rowx, colx, xf_index, value, is_err = local_unpack('<HHHBB', data[:8])
                # Note OOo Calc 2.0 writes 9-byte BOOLERR records.
                # OOo docs say 8. Excel writes 8.
                cellty = (XL_CELL_BOOLEAN, XL_CELL_ERROR)[is_err]
                # if DEBUG: print "XL_BOOLERR", rowx, colx, xf_index, value, is_err
                self.put_cell(rowx, colx, cellty, value, xf_index)
            elif rc == XL_COLINFO:
                if not fmt_info: continue
                c = Colinfo()
                first_colx, last_colx, c.width, c.xf_index, flags \
                    = local_unpack("<HHHHH", data[:10])
                #### Colinfo.width is denominated in 256ths of a character,
                #### *not* in characters.
                if not(0 <= first_colx <= last_colx <= 256):
                    # Note: 256 instead of 255 is a common mistake.
                    # We silently ignore the non-existing 257th column in that case.
                    print("*** NOTE: COLINFO record has first col index %d, last %d; " \
                        "should have 0 <= first <= last <= 255 -- record ignored!" \
                        % (first_colx, last_colx), file=self.logfile)
                    del c
                    continue
                upkbits(c, flags, (
                    ( 0, 0x0001, 'hidden'),
                    ( 1, 0x0002, 'bit1_flag'),
                    # *ALL* colinfos created by Excel in "default" cases are 0x0002!!
                    # Maybe it's "locked" by analogy with XFProtection data.
                    ( 8, 0x0700, 'outline_level'),
                    (12, 0x1000, 'collapsed'),
                    ))
                for colx in range(first_colx, last_colx+1):
                    if colx > 255: break # Excel does 0 to 256 inclusive
                    self.colinfo_map[colx] = c
                    if 0:
                        fprintf(self.logfile,
                            "**COL %d %d %d\n",
                            self.number, colx, c.xf_index)
                if verbose:
                    fprintf(
                        self.logfile,
                        "COLINFO sheet #%d cols %d-%d: wid=%d xf_index=%d flags=0x%04x\n",
                        self.number, first_colx, last_colx, c.width, c.xf_index, flags,
                        )
                    c.dump(self.logfile, header='===')
            elif rc == XL_DEFCOLWIDTH:
                self.defcolwidth, = local_unpack("<H", data[:2])
                if 0: print('DEFCOLWIDTH', self.defcolwidth, file=self.logfile)
            elif rc == XL_STANDARDWIDTH:
                if data_len != 2:
                    print('*** ERROR *** STANDARDWIDTH', data_len, repr(data), file=self.logfile)
                self.standardwidth, = local_unpack("<H", data[:2])
                if 0: print('STANDARDWIDTH', self.standardwidth, file=self.logfile)
            elif rc == XL_GCW:
                if not fmt_info: continue # useless w/o COLINFO
                assert data_len == 34
                assert data[0:2] == "\x20\x00"
                iguff = unpack("<8i", data[2:34])
                gcw = []
                for bits in iguff:
                    for j in range(32):
                        gcw.append(bits & 1)
                        bits >>= 1
                self.gcw = tuple(gcw)
                if 0:
                    showgcw = "".join(["F "[x] for x in gcw]).rstrip().replace(' ', '.')
                    print("GCW:", showgcw)
            elif rc == XL_BLANK:
                if not fmt_info: continue
                rowx, colx, xf_index = local_unpack('<HHH', data[:6])
                if 0: print("BLANK", rowx, colx, xf_index, file=self.logfile)
                self_put_blank_cell(rowx, colx, xf_index)
            elif rc == XL_MULBLANK: # 00BE
                if not fmt_info: continue
                mul_row, mul_first = local_unpack('<HH', data[0:4])
                mul_last, = local_unpack('<H', data[-2:])
                if 0:
                    print("MULBLANK", mul_row, mul_first, mul_last, file=self.logfile)
                pos = 4
                for colx in range(mul_first, mul_last+1):
                    xf_index, = local_unpack('<H', data[pos:pos+2])
                    pos += 2
                    self_put_blank_cell(mul_row, colx, xf_index)
            elif rc == XL_DIMENSION or rc == XL_DIMENSION2:
                # if data_len == 10:
                # Was crashing on BIFF 4.0 file w/o the two trailing unused bytes.
                # Reported by Ralph Heimburger.
                if bv < 80:
                    dim_tuple = local_unpack('<HxxH', data[2:8])
                else:
                    dim_tuple = local_unpack('<ixxH', data[4:12])
                self.nrows, self.ncols = 0, 0
                self._dimnrows, self._dimncols = dim_tuple
                if not self.book._xf_epilogue_done:
                    # Needed for bv <= 40
                    self.book.xf_epilogue()
                if verbose:
                    fprintf(self.logfile,
                        "sheet %d(%r) DIMENSIONS: ncols=%d nrows=%d\n",
                        self.number, self.name, self._dimncols, self._dimnrows
                        )
            elif rc == XL_EOF:
                DEBUG = 0
                if DEBUG: print("SHEET.READ: EOF", file=self.logfile)
                eof_found = 1
                break
            elif rc == XL_OBJ:
                # handle SHEET-level objects; note there's a separate Book.handle_obj
                self.handle_obj(data)
            elif rc == XL_MSO_DRAWING:
                self.handle_msodrawingetc(rc, data_len, data)
            elif rc == XL_TXO:
                self.handle_txo(data)
            elif rc == XL_NOTE:
                self.handle_note(data)
            elif rc == XL_FEAT11:
                self.handle_feat11(data)
            elif rc in bofcodes: ##### EMBEDDED BOF #####
                version, boftype = local_unpack('<HH', data[0:4])
                if boftype != 0x20: # embedded chart
                    print("*** Unexpected embedded BOF (0x%04x) at offset %d: version=0x%04x type=0x%04x" \
                        % (rc, bk._position - data_len - 4, version, boftype), file=self.logfile)
                while 1:
                    code, data_len, data = bk.get_record_parts()
                    if code == XL_EOF:
                        break
                if DEBUG: print("---> found EOF", file=self.logfile)
            elif rc == XL_COUNTRY:
                bk.handle_country(data)
            elif rc == XL_LABELRANGES:
                pos = 0
                pos = unpack_cell_range_address_list_update_pos(
                        self.row_label_ranges, data, pos, bv, addr_size=8,
                        )
                pos = unpack_cell_range_address_list_update_pos(
                        self.col_label_ranges, data, pos, bv, addr_size=8,
                        )
                assert pos == data_len
            elif rc == XL_ARRAY:
                row1x, rownx, col1x, colnx, array_flags, tokslen = \
                    local_unpack("<HHBBBxxxxxH", data[:14])
                if verbose_formulas:
                    print("ARRAY:", row1x, rownx, col1x, colnx, array_flags)
                    dump_formula(bk, data[14:], tokslen, bv, reldelta=0, verbose=1)
            elif rc == XL_SHRFMLA:
                row1x, rownx, col1x, colnx, nfmlas, tokslen = \
                    local_unpack("<HHBBxBH", data[:10])
                if verbose_formulas:
                    print("SHRFMLA (main):", row1x, rownx, col1x, colnx, nfmlas)
                    decompile_formula(bk, data[10:], tokslen, reldelta=0, verbose=1)
            elif rc == XL_CONDFMT:
                if not fmt_info: continue
                assert bv >= 80
                num_CFs, needs_recalc, browx1, browx2, bcolx1, bcolx2 = \
                    unpack("<6H", data[0:12])
                if self.verbosity >= 1:
                    fprintf(self.logfile,
                        "\n*** WARNING: Ignoring CONDFMT (conditional formatting) record\n" \
                        "*** in Sheet %d (%r).\n" \
                        "*** %d CF record(s); needs_recalc_or_redraw = %d\n" \
                        "*** Bounding box is %s\n",
                        self.number, self.name, num_CFs, needs_recalc,
                        rangename2d(browx1, browx2+1, bcolx1, bcolx2+1),
                        )
                olist = [] # updated by the function
                pos = unpack_cell_range_address_list_update_pos(
                    olist, data, 12, bv, addr_size=8)
                # print >> self.logfile, repr(result), len(result)
                if self.verbosity >= 1:
                    fprintf(self.logfile,
                        "*** %d individual range(s):\n" \
                        "*** %s\n",
                        len(olist),
                        ", ".join([rangename2d(*coords) for coords in olist]),
                        )
            elif rc == XL_CF:
                if not fmt_info: continue
                cf_type, cmp_op, sz1, sz2, flags = unpack("<BBHHi", data[0:10])
                font_block = (flags >> 26) & 1
                bord_block = (flags >> 28) & 1
                patt_block = (flags >> 29) & 1
                if self.verbosity >= 1:
                    fprintf(self.logfile,
                        "\n*** WARNING: Ignoring CF (conditional formatting) sub-record.\n" \
                        "*** cf_type=%d, cmp_op=%d, sz1=%d, sz2=%d, flags=0x%08x\n" \
                        "*** optional data blocks: font=%d, border=%d, pattern=%d\n",
                        cf_type, cmp_op, sz1, sz2, flags,
                        font_block, bord_block, patt_block,
                        )
                # hex_char_dump(data, 0, data_len)
                pos = 12
                if font_block:
                    (font_height, font_options, weight, escapement, underline,
                    font_colour_index, two_bits, font_esc, font_underl) = \
                    unpack("<64x i i H H B 3x i 4x i i i 18x", data[pos:pos+118])
                    font_style = (two_bits > 1) & 1
                    posture = (font_options > 1) & 1
                    font_canc = (two_bits > 7) & 1
                    cancellation = (font_options > 7) & 1
                    if self.verbosity >= 1:
                        fprintf(self.logfile,
                            "*** Font info: height=%d, weight=%d, escapement=%d,\n" \
                            "*** underline=%d, colour_index=%d, esc=%d, underl=%d,\n" \
                            "*** style=%d, posture=%d, canc=%d, cancellation=%d\n",
                            font_height, weight, escapement, underline,
                            font_colour_index, font_esc, font_underl,
                            font_style, posture, font_canc, cancellation,
                            )
                    pos += 118
                if bord_block:
                    pos += 8
                if patt_block:
                    pos += 4
                fmla1 = data[pos:pos+sz1]
                pos += sz1
                if verbose and sz1:
                    fprintf(self.logfile,
                        "*** formula 1:\n",
                        )
                    dump_formula(bk, fmla1, sz1, bv, reldelta=0, verbose=1)
                fmla2 = data[pos:pos+sz2]
                pos += sz2
                assert pos == data_len
                if verbose and sz2:
                    fprintf(self.logfile,
                        "*** formula 2:\n",
                        )
                    dump_formula(bk, fmla2, sz2, bv, reldelta=0, verbose=1)
            elif rc == XL_DEFAULTROWHEIGHT:
                if data_len == 4:
                    bits, self.default_row_height = unpack("<HH", data[:4])
                elif data_len == 2:
                    self.default_row_height, = unpack("<H", data)
                    bits = 0
                    fprintf(self.logfile,
                        "*** WARNING: DEFAULTROWHEIGHT record len is 2, " \
                        "should be 4; assuming BIFF2 format\n")
                else:
                    bits = 0
                    fprintf(self.logfile,
                        "*** WARNING: DEFAULTROWHEIGHT record len is %d, " \
                        "should be 4; ignoring this record\n",
                        data_len)
                self.default_row_height_mismatch = bits & 1
                self.default_row_hidden = (bits >> 1) & 1
                self.default_additional_space_above = (bits >> 2) & 1
                self.default_additional_space_below = (bits >> 3) & 1
            elif rc == XL_MERGEDCELLS:
                if not fmt_info: continue
                pos = unpack_cell_range_address_list_update_pos(
                    self.merged_cells, data, 0, bv, addr_size=8)
                if verbose:
                    fprintf(self.logfile,
                        "MERGEDCELLS: %d ranges\n", int_floor_div(pos - 2, 8))
                assert pos == data_len, \
                    "MERGEDCELLS: pos=%d data_len=%d" % (pos, data_len)
            elif rc == XL_WINDOW2:
                if bv >= 80:
                    (options,
                    self.first_visible_rowx, self.first_visible_colx,
                    self.gridline_colour_index,
                    self.cached_page_break_preview_mag_factor,
                    self.cached_normal_view_mag_factor
                    ) = unpack("<HHHHxxHH", data[:14])
                else: # BIFF3-7
                    (options,
                    self.first_visible_rowx, self.first_visible_colx,
                    ) = unpack("<HHH", data[:6])
                    self.gridline_colour_rgb = unpack("<BBB", data[6:9])
                    self.gridline_colour_index = \
                        nearest_colour_index(
                            self.book.colour_map,
                            self.gridline_colour_rgb,
                            debug=0)
                    self.cached_page_break_preview_mag_factor = 0 # default (60%)
                    self.cached_normal_view_mag_factor = 0 # default (100%)
                # options -- Bit, Mask, Contents:
                # 0 0001H 0 = Show formula results 1 = Show formulas
                # 1 0002H 0 = Do not show grid lines 1 = Show grid lines
                # 2 0004H 0 = Do not show sheet headers 1 = Show sheet headers
                # 3 0008H 0 = Panes are not frozen 1 = Panes are frozen (freeze)
                # 4 0010H 0 = Show zero values as empty cells 1 = Show zero values
                # 5 0020H 0 = Manual grid line colour 1 = Automatic grid line colour
                # 6 0040H 0 = Columns from left to right 1 = Columns from right to left
                # 7 0080H 0 = Do not show outline symbols 1 = Show outline symbols
                # 8 0100H 0 = Keep splits if pane freeze is removed 1 = Remove splits if pane freeze is removed
                # 9 0200H 0 = Sheet not selected 1 = Sheet selected (BIFF5-BIFF8)
                # 10 0400H 0 = Sheet not visible 1 = Sheet visible (BIFF5-BIFF8)
                # 11 0800H 0 = Show in normal view 1 = Show in page break preview (BIFF8)
                # The freeze flag specifies, if a following PANE record (6.71) describes unfrozen or frozen panes.
                for attr, _unused_defval in _WINDOW2_options:
                    setattr(self, attr, options & 1)
                    options >>= 1
                # print "WINDOW2: visible=%d selected=%d" \
                #     % (self.sheet_visible, self.sheet_selected)
            #### all of the following are for BIFF <= 4W
            elif bv <= 45:
                if rc == XL_FORMAT or rc == XL_FORMAT2:
                    bk.handle_format(data, rc)
                elif rc == XL_FONT or rc == XL_FONT_B3B4:
                    bk.handle_font(data)
                elif rc == XL_STYLE:
                    if not self.book._xf_epilogue_done:
                        self.book.xf_epilogue()
                    bk.handle_style(data)
                elif rc == XL_PALETTE:
                    bk.handle_palette(data)
                elif rc == XL_BUILTINFMTCOUNT:
                    bk.handle_builtinfmtcount(data)
                elif rc == XL_XF4 or rc == XL_XF3 or rc == XL_XF2: #### N.B. not XL_XF
                    bk.handle_xf(data)
                elif rc == XL_DATEMODE:
                    bk.handle_datemode(data)
                elif rc == XL_CODEPAGE:
                    bk.handle_codepage(data)
                elif rc == XL_FILEPASS:
                    bk.handle_filepass(data)
                elif rc == XL_WRITEACCESS:
                    bk.handle_writeaccess(data)
                elif rc == XL_IXFE:
                    self._ixfe = local_unpack('<H', data)[0]
                elif rc == XL_NUMBER_B2:
                    rowx, colx, cell_attr, d = local_unpack('<HH3sd', data)
                    self_put_number_cell(rowx, colx, d, self.fixed_BIFF2_xfindex(cell_attr, rowx, colx))
                elif rc == XL_INTEGER:
                    rowx, colx, cell_attr, d = local_unpack('<HH3sH', data)
                    self_put_number_cell(rowx, colx, float(d), self.fixed_BIFF2_xfindex(cell_attr, rowx, colx))
                elif rc == XL_LABEL_B2:
                    rowx, colx, cell_attr = local_unpack('<HH3s', data[0:7])
                    strg = unpack_string(data, 7, bk.encoding or bk.derive_encoding(), lenlen=1)
                    self_put_cell(rowx, colx, XL_CELL_TEXT, strg, self.fixed_BIFF2_xfindex(cell_attr, rowx, colx))
                elif rc == XL_BOOLERR_B2:
                    rowx, colx, cell_attr, value, is_err = local_unpack('<HH3sBB', data)
                    cellty = (XL_CELL_BOOLEAN, XL_CELL_ERROR)[is_err]
                    # if DEBUG: print "XL_BOOLERR_B2", rowx, colx, cell_attr, value, is_err
                    self.put_cell(rowx, colx, cellty, value, self.fixed_BIFF2_xfindex(cell_attr, rowx, colx))
                elif rc == XL_BLANK_B2:
                    if not fmt_info: continue
                    rowx, colx, cell_attr = local_unpack('<HH3s', data[:7])
                    self_put_blank_cell(rowx, colx, self.fixed_BIFF2_xfindex(cell_attr, rowx, colx))
                elif rc == XL_EFONT:
                    bk.handle_efont(data)
                elif rc == XL_ROW_B2:
                    if not fmt_info: continue
                    rowx, bits1, has_defaults = local_unpack('<H4xH2xB', data[0:11])
                    if not(0 <= rowx < self.utter_max_rows):
                        print("*** NOTE: ROW_B2 record has row index %d; " \
                            "should have 0 <= rowx < %d -- record ignored!" \
                            % (rowx, self.utter_max_rows), file=self.logfile)
                        continue
                    r = Rowinfo()
                    r.height = bits1 & 0x7fff
                    r.has_default_height = (bits1 >> 15) & 1
                    r.outline_level = 0
                    r.outline_group_starts_ends = 0
                    r.hidden = 0
                    r.height_mismatch = 0
                    r.has_default_xf_index = has_defaults & 1
                    r.additional_space_above = 0
                    r.additional_space_below = 0
                    if not r.has_default_xf_index:
                        r.xf_index = -1
                    elif data_len == 18:
                        # Seems the XF index in the cell_attr is dodgy
                        xfx = local_unpack('<H', data[16:18])[0]
                        r.xf_index = self.fixed_BIFF2_xfindex(cell_attr=None, rowx=rowx, colx=-1, true_xfx=xfx)
                    else:
                        cell_attr = data[13:16]
                        r.xf_index = self.fixed_BIFF2_xfindex(cell_attr, rowx, colx=-1)
                    self.rowinfo_map[rowx] = r
                    if 0 and r.xf_index > -1:
                        fprintf(self.logfile,
                            "**ROW %d %d %d\n",
                            self.number, rowx, r.xf_index)
                    if verbose_rows:
                        print('ROW_B2', rowx, bits1, has_defaults, file=self.logfile)
                        r.dump(self.logfile,
                            header="--- sh #%d, rowx=%d ---" % (self.number, rowx))
                elif rc == XL_COLWIDTH: # BIFF2 only
                    if not fmt_info: continue
                    first_colx, last_colx, width\
                        = local_unpack("<BBH", data[:4])
                    if not(first_colx <= last_colx):
                        print("*** NOTE: COLWIDTH record has first col index %d, last %d; " \
                            "should have first <= last -- record ignored!" \
                            % (first_colx, last_colx), file=self.logfile)
                        continue
                    for colx in range(first_colx, last_colx+1):
                        if colx in self.colinfo_map:
                            c = self.colinfo_map[colx]
                        else:
                            c = Colinfo()
                            self.colinfo_map[colx] = c
                        c.width = width
                    if verbose:
                        fprintf(
                            self.logfile,
                            "COLWIDTH sheet #%d cols %d-%d: wid=%d\n",
                            self.number, first_colx, last_colx, width
                            )
                elif rc == XL_COLUMNDEFAULT: # BIFF2 only
                    if not fmt_info: continue
                    first_colx, last_colx = local_unpack("<HH", data[:4])
                    #### Warning OOo docs wrong; first_colx <= colx < last_colx
                    if verbose:
                        fprintf(
                            self.logfile,
                            "COLUMNDEFAULT sheet #%d cols in range(%d, %d)\n",
                            self.number, first_colx, last_colx
                            )
                    if not(0 <= first_colx < last_colx <= 256):
                        print("*** NOTE: COLUMNDEFAULT record has first col index %d, last %d; " \
                            "should have 0 <= first < last <= 256" \
                            % (first_colx, last_colx), file=self.logfile)
                        last_colx = min(last_colx, 256)
                    for colx in range(first_colx, last_colx):
                        offset = 4 + 3 * (colx - first_colx)
                        cell_attr = data[offset:offset+3]
                        xf_index = self.fixed_BIFF2_xfindex(cell_attr, rowx=-1, colx=colx)
                        if colx in self.colinfo_map:
                            c = self.colinfo_map[colx]
                        else:
                            c = Colinfo()
                            self.colinfo_map[colx] = c
                        c.xf_index = xf_index
        if not eof_found:
            raise XLRDError("Sheet %d (%r) missing EOF record" \
                % (self.number, self.name))
        self.tidy_dimensions()
        bk._position = oldpos
        return 1

    def fixed_BIFF2_xfindex(self, cell_attr, rowx, colx, true_xfx=None):
        DEBUG = 0
        verbose = DEBUG or self.verbosity >= 2
        if self.biff_version == 21:
            if self._xf_index_to_xl_type_map:
                if true_xfx is not None:
                    xfx = true_xfx
                else:
                    xfx = cell_attr[0] & 0x3F
                if xfx == 0x3F:
                    if self._ixfe is None:
                        raise XLRDError("BIFF2 cell record has XF index 63 but no preceding IXFE record.")
                    xfx = self._ixfe
                    # OOo docs are capable of interpretation that each
                    # cell record is preceded immediately by its own IXFE record.
                    # Empirical evidence is that (sensibly) an IXFE record applies to all
                    # following cell records until another IXFE comes along.
                return xfx
            # Have either Excel 2.0, or broken 2.1 w/o XF records -- same effect.
            self.biff_version = self.book.biff_version = 20
        #### check that XF slot in cell_attr is zero
        xfx_slot = cell_attr[0] & 0x3F
        assert xfx_slot == 0
        xfx = self._cell_attr_to_xfx.get(cell_attr)
        if xfx is not None:
            return xfx
        if verbose:
            fprintf(self.logfile, "New cell_attr %r at (%r, %r)\n", cell_attr, rowx, colx)
        book = self.book
        xf = self.fake_XF_from_BIFF20_cell_attr(cell_attr)
        xfx = len(book.xf_list)
        xf.xf_index = xfx
        book.xf_list.append(xf)
        if verbose:
            xf.dump(self.logfile, header="=== Faked XF %d ===" % xfx, footer="======")
        if xf.format_key not in book.format_map:
            msg = "ERROR *** XF[%d] unknown format key (%d, 0x%04x)\n"
            fprintf(self.logfile, msg,
                    xf.xf_index, xf.format_key, xf.format_key)
            fmt = Format(xf.format_key, FUN, "General")
            book.format_map[xf.format_key] = fmt
            while len(book.format_list) <= xf.format_key:
                book.format_list.append(fmt)
        cellty_from_fmtty = {
            FNU: XL_CELL_NUMBER,
            FUN: XL_CELL_NUMBER,
            FGE: XL_CELL_NUMBER,
            FDT: XL_CELL_DATE,
            FTX: XL_CELL_NUMBER, # Yes, a number can be formatted as text.
            }
        fmt = book.format_map[xf.format_key]
        cellty = cellty_from_fmtty[fmt.type]
        self._xf_index_to_xl_type_map[xf.xf_index] = cellty
        self._cell_attr_to_xfx[cell_attr] = xfx
        return xfx

    def fake_XF_from_BIFF20_cell_attr(self, cell_attr):
        from .formatting import XF, XFAlignment, XFBorder, XFBackground, XFProtection
        xf = XF()
        xf.alignment = XFAlignment()
        xf.alignment.indent_level = 0
        xf.alignment.shrink_to_fit = 0
        xf.alignment.text_direction = 0
        xf.border = XFBorder()
        xf.border.diag_up = 0
        xf.border.diag_down = 0
        xf.border.diag_colour_index = 0
        xf.border.diag_line_style = 0 # no line
        xf.background = XFBackground()
        xf.protection = XFProtection()
        (prot_bits, font_and_format, halign_etc) = unpack('<BBB', cell_attr)
        xf.format_key = font_and_format & 0x3F
        xf.font_index = (font_and_format & 0xC0) >> 6
        upkbits(xf.protection, prot_bits, (
            (6, 0x40, 'cell_locked'),
            (7, 0x80, 'formula_hidden'),
            ))
        xf.alignment.hor_align = halign_etc & 0x07
        for mask, side in ((0x08, 'left'), (0x10, 'right'), (0x20, 'top'), (0x40, 'bottom')):
            if halign_etc & mask:
                colour_index, line_style = 8, 1 # black, thin
            else:
                colour_index, line_style = 0, 0 # none, none
            setattr(xf.border, side + '_colour_index', colour_index)
            setattr(xf.border, side + '_line_style', line_style)
        bg = xf.background
        if halign_etc & 0x80:
            bg.fill_pattern = 17
        else:
            bg.fill_pattern = 0
        bg.background_colour_index = 9 # white
        bg.pattern_colour_index = 8 # black
        xf.parent_style_index = 0 # ???????????
        xf.alignment.vert_align = 2 # bottom
        xf.alignment.rotation = 0
        for attr_stem in ("format", "font", "alignment", "border", \
                          "background", "protection"):
            attr = "_%s_flag" % attr_stem
            setattr(xf, attr, 1)
        return xf

    def req_fmt_info(self):
        if not self.formatting_info:
            raise XLRDError("Feature requires open_workbook(..., formatting_info=True)")

    # Determine column display width.
    # - New in version 0.6.1
    #
    # @param colx Index of the queried column, range 0 to 255.
    # Note that it is possible to find out the width that will be used to display
    # columns with no cell information e.g. column IV (colx=255).
    # @return The column width that will be used for displaying
    # the given column by Excel, in units of 1/256th of the width of a
    # standard character (the digit zero in the first font).

    def computed_column_width(self, colx):
        self.req_fmt_info()
        if self.biff_version >= 80:
            colinfo = self.colinfo_map.get(colx, None)
            if colinfo is not None:
                return colinfo.width
            if self.standardwidth is not None:
                return self.standardwidth
        elif self.biff_version >= 40:
            if self.gcw[colx]:
                if self.standardwidth is not None:
                    return self.standardwidth
            else:
                colinfo = self.colinfo_map.get(colx, None)
                if colinfo is not None:
                    return colinfo.width
        elif self.biff_version == 30:
            colinfo = self.colinfo_map.get(colx, None)
            if colinfo is not None:
                return colinfo.width
        # All roads lead to Rome and the DEFCOLWIDTH ...
        if self.defcolwidth is not None:
            return self.defcolwidth * 256
        return 8 * 256 # 8 is what Excel puts in a DEFCOLWIDTH record

    def handle_msodrawingetc(self, recid, data_len, data):
        if not OBJ_MSO_DEBUG:
            return
        DEBUG = 1
        if self.biff_version < 80:
            return
        o = MSODrawing()
        pos = 0
        while pos < data_len:
            tmp, fbt, cb = unpack('<HHI', data[pos:pos+8])
            ver = tmp & 0xF
            inst = (tmp >> 4) & 0xFFF
            if ver == 0xF:
                ndb = 0 # container
            else:
                ndb = cb
            if DEBUG:
                hex_char_dump(data, pos, ndb + 8, base=0, fout=self.logfile)
                fprintf(self.logfile,
                    "fbt:0x%04X  inst:%d  ver:0x%X  cb:%d (0x%04X)\n",
                    fbt, inst, ver, cb, cb)
            if fbt == 0xF010: # Client Anchor
                assert ndb == 18
                (o.anchor_unk,
                o.anchor_colx_lo, o.anchor_rowx_lo,
                o.anchor_colx_hi, o.anchor_rowx_hi) = unpack('<Hiiii', data[pos+8:pos+8+ndb])
            elif fbt == 0xF011: # Client Data
                # must be followed by an OBJ record
                assert cb == 0
                assert pos + 8 == data_len
            else:
                pass
            pos += ndb + 8
        else:
            # didn't break out of while loop
            assert pos == data_len
        if DEBUG:
            o.dump(self.logfile, header="=== MSODrawing ===", footer= " ")


    def handle_obj(self, data):
        if not OBJ_MSO_DEBUG:
            return
        DEBUG = 1
        if self.biff_version < 80:
            return
        o = MSObj()
        data_len = len(data)
        pos = 0
        if DEBUG:
            fprintf(self.logfile, "... OBJ record ...\n")
        while pos < data_len:
            ft, cb = unpack('<HH', data[pos:pos+4])
            if DEBUG:
                hex_char_dump(data, pos, cb, base=0, fout=self.logfile)
            if ft == 0x15: # ftCmo ... s/b first
                assert pos == 0
                o.type, o.id, option_flags = unpack('<HHH', data[pos+4:pos+10])
                upkbits(o, option_flags, (
                    ( 0, 0x0001, 'locked'),
                    ( 4, 0x0010, 'printable'),
                    ( 8, 0x0100, 'autofilter'), # not documented in Excel 97 dev kit
                    ( 9, 0x0200, 'scrollbar_flag'), # not documented in Excel 97 dev kit
                    (13, 0x2000, 'autofill'),
                    (14, 0x4000, 'autoline'),
                    ))
            elif ft == 0x00:
                assert cb == 0
                assert pos + 4 == data_len
            elif ft == 0x0C: # Scrollbar
                values = unpack('<5H', data[pos+8:pos+18])
                for value, tag in zip(values, ('value', 'min', 'max', 'inc', 'page')):
                    setattr(o, 'scrollbar_' + tag, value)
            elif ft == 0x0D: # "Notes structure" [used for cell comments]
                pass ############## not documented in Excel 97 dev kit
            elif ft == 0x13: # list box data
                if o.autofilter: # non standard exit. NOT documented
                    break
            else:
                pass
            pos += cb + 4
        else:
            # didn't break out of while loop
            assert pos == data_len
        if DEBUG:
            o.dump(self.logfile, header="=== MSOBj ===", footer= " ")

    def handle_note(self, data):
        if not OBJ_MSO_DEBUG:
            return
        DEBUG = 1
        if self.biff_version < 80:
            return
        if DEBUG:
            fprintf(self.logfile, '... NOTE record ...\n')
            hex_char_dump(data, 0, len(data), base=0, fout=self.logfile)
        o = MSNote()
        data_len = len(data)
        o.rowx, o.colx, option_flags, o.object_id = unpack('<4H', data[:8])
        o.show = (option_flags >> 1) & 1
        # Docs say NULL [sic] bytes padding between string count and string data
        # to ensure that string is word-aligned. Appears to be nonsense.
        # There also seems to be a random(?) byte after the string (not counted in the
        # string length.
        o.original_author, endpos = unpack_unicode_update_pos(data, 8, lenlen=2)
        assert endpos == data_len - 1
        o.last_byte = data[-1]
        if DEBUG:
            o.dump(self.logfile, header="=== MSNote ===", footer= " ")

    def handle_txo(self, data):
        if not OBJ_MSO_DEBUG:
            return
        DEBUG = 1
        if self.biff_version < 80:
            return
        o = MSTxo()
        data_len = len(data)
        option_flags, o.rot, cchText, cbRuns = unpack('<HH6xHH4x', data)
        upkbits(o, option_flags, (
            (3, 0x000E, 'horz_align'),
            (6, 0x0070, 'vert_align'),
            (9, 0x0200, 'lock_text'),
            ))
        rc2, data2_len, data2 = self.book.get_record_parts()
        assert rc2 == XL_CONTINUE
        o.text, endpos = unpack_unicode_update_pos(data2, 0, known_len=cchText)
        assert endpos == data2_len
        rc3, data3_len, data3 = self.book.get_record_parts()
        assert rc3 == XL_CONTINUE
        # ignore the formatting runs for the moment
        if DEBUG:
            o.dump(self.logfile, header="=== MSTxo ===", footer= " ")

    def handle_feat11(self, data):
        if not OBJ_MSO_DEBUG:
            return
        # rt: Record type; this matches the BIFF rt in the first two bytes of the record; =0872h
        # grbitFrt: FRT cell reference flag (see table below for details)
        # Ref0: Range reference to a worksheet cell region if grbitFrt=1 (bitFrtRef). Otherwise blank.
        # isf: Shared feature type index =5 for Table
        # fHdr: =0 since this is for feat not feat header
        # reserved0: Reserved for future use =0 for Table
        # cref: Count of ref ranges this feature is on
        # cbFeatData: Count of byte for the current feature data.
        # reserved1: =0 currently not used
        # Ref1: Repeat of Ref0. UNDOCUMENTED
        rt, grbitFrt, Ref0, isf, fHdr, reserved0, cref, cbFeatData, reserved1, Ref1 = unpack('<HH8sHBiHiH8s', data[0:35])
        assert reserved0 == 0
        assert reserved1 == 0
        assert isf == 5
        assert rt == 0x872
        assert fHdr == 0
        assert Ref1 == Ref0
        print("FEAT11: grbitFrt=%d  Ref0=%r cref=%d cbFeatData=%d" % (grbitFrt, Ref0, cref, cbFeatData))
        # lt: Table data source type:
        #   =0 for Excel Worksheet Table =1 for read-write SharePoint linked List
        #   =2 for XML mapper Table =3 for Query Table
        # idList: The ID of the Table (unique per worksheet)
        # crwHeader: How many header/title rows the Table has at the top
        # crwTotals: How many total rows the Table has at the bottom
        # idFieldNext: Next id to try when assigning a unique id to a new field
        # cbFSData: The size of the Fixed Data portion of the Table data structure.
        # rupBuild: the rupBuild that generated the record
        # unusedShort: UNUSED short that can be used later. The value is reserved during round-tripping.
        # listFlags: Collection of bit flags: (see listFlags' bit setting table below for detail.)
        # lPosStmCache: Table data stream position of cached data
        # cbStmCache: Count of bytes of cached data
        # cchStmCache: Count of characters of uncompressed cached data in the stream
        # lem: Table edit mode (see List (Table) Editing Mode (lem) setting table below for details.)
        # rgbHashParam: Hash value for SharePoint Table
        # cchName: Count of characters in the Table name string rgbName
        (lt, idList, crwHeader, crwTotals, idFieldNext, cbFSData,
        rupBuild, unusedShort, listFlags, lPosStmCache, cbStmCache,
        cchStmCache, lem, rgbHashParam, cchName) = unpack('<iiiiiiHHiiiii16sH', data[35:35+66])
        print("lt=%d  idList=%d crwHeader=%d  crwTotals=%d  idFieldNext=%d cbFSData=%d\n"\
            "rupBuild=%d  unusedShort=%d listFlags=%04X  lPosStmCache=%d  cbStmCache=%d\n"\
            "cchStmCache=%d  lem=%d  rgbHashParam=%r  cchName=%d" % (
            lt, idList, crwHeader, crwTotals, idFieldNext, cbFSData,
            rupBuild, unusedShort,listFlags, lPosStmCache, cbStmCache,
            cchStmCache, lem, rgbHashParam, cchName))

class MSODrawing(BaseObject):
    pass

class MSObj(BaseObject):
    pass

class MSTxo(BaseObject):
    pass

class MSNote(BaseObject):
    pass

# === helpers ===

def unpack_RK(rk_str):
    #(to_py3): flags = ord(rk_str[0])
    flags = rk_str[0]
    if flags & 2:
        # There's a SIGNED 30-bit integer in there!
        i,  = unpack('<i', rk_str)
        i >>= 2 # div by 4 to drop the 2 flag bits
        if flags & 1:
            return i / 100.0
        return float(i)
    else:
        # It's the most significant 30 bits of an IEEE 754 64-bit FP number
        # (to_py3): replaced b'\0\0\0\0' + chr(flags & 252) + rk_str[1:4]
        _bytes = array('B', b'\0\0\0\0')
        _bytes.append(flags & 252)
        _bytes.extend(rk_str[1:4])
        d, = unpack('<d', _bytes)
        if flags & 1:
            d = d / 100.
        return d

##### =============== Cell ======================================== #####

cellty_from_fmtty = {
    FNU: XL_CELL_NUMBER,
    FUN: XL_CELL_NUMBER,
    FGE: XL_CELL_NUMBER,
    FDT: XL_CELL_DATE,
    FTX: XL_CELL_NUMBER, # Yes, a number can be formatted as text.
    }

ctype_text = {
    XL_CELL_EMPTY: 'empty',
    XL_CELL_TEXT: 'text',
    XL_CELL_NUMBER: 'number',
    XL_CELL_DATE: 'xldate',
    XL_CELL_BOOLEAN: 'bool',
    XL_CELL_ERROR: 'error',
    XL_CELL_BLANK: 'blank',
    }

# Contains the data for one cell -> see XFCell() class in the xfcell module.
class Cell(XFCell):
    def __repr__(self):
        if not self.has_xf:
            return "%s:%r" % (ctype_text[self.ctype], self.value)
        else:
            return "%s:%r (XF:%r)" % (ctype_text[self.ctype], self.value, self.xf_index)

# There is one and only one instance of an empty cell -- it's a singleton. This is it.
# You may use a test like "acell is empty_cell".
empty_cell = Cell(XL_CELL_EMPTY, '')

##### =============== Colinfo and Rowinfo ============================== #####


# Width and default formatting information that applies to one or
# more columns in a sheet. Derived from COLINFO records.
#
#
# Here is the default hierarchy for width, according to the OOo docs:
#
# In BIFF3, if a COLINFO record is missing for a column,
# the width specified in the record DEFCOLWIDTH is used instead.
#
# In BIFF4-BIFF7, the width set in this [COLINFO] record is only used,
# if the corresponding bit for this column is cleared in the GCW
# record, otherwise the column width set in the DEFCOLWIDTH record
# is used (the STANDARDWIDTH record is always ignored in this case [see footnote!]).
#
# In BIFF8, if a COLINFO record is missing for a column,
# the width specified in the record STANDARDWIDTH is used.
# If this [STANDARDWIDTH] record is also missing,
# the column width of the record DEFCOLWIDTH is used instead.
#
# Footnote:  The docs on the GCW record say this:
#
# If a bit is set, the corresponding column uses the width set in the STANDARDWIDTH
# record. If a bit is cleared, the corresponding column uses the width set in the
# COLINFO record for this column.
#
# If a bit is set, and the worksheet does not contain the STANDARDWIDTH record, or if
# the bit is cleared, and the worksheet does not contain the COLINFO record, the DEFCOLWIDTH
# record of the worksheet will be used instead.
#
# At the moment (2007-01-17) xlrd is going with the GCW version of the story.
# Reference to the source may be useful: see the computed_column_width(colx) method
# of the Sheet class.
# - New in version 0.6.1

class Colinfo(BaseObject):
    # Width of the column in 1/256 of the width of the zero character,
    # using default font (first FONT record in the file).
    width = 0
    # XF index to be used for formatting empty cells.
    xf_index = -1
    # 1 = column is hidden
    hidden = 0
    # Value of a 1-bit flag whose purpose is unknown
    # but is often seen set to 1
    bit1_flag = 0
    # Outline level of the column, in range(7).
    # (0 = no outline)
    outline_level = 0
    # 1 = column is collapsed
    collapsed = 0

# Height and default formatting information that applies to a row in a sheet.
# Derived from ROW records.
# - New in version 0.6.1

class Rowinfo(BaseObject):
    ##
    # Height of the row, in twips. One twip == 1/20 of a point
    height = 0
    ##
    # 0 = Row has custom height; 1 = Row has default height
    has_default_height = 0
    ##
    # Outline level of the row
    outline_level = 0
    ##
    # 1 = Outline group starts or ends here (depending on where the
    # outline buttons are located, see WSBOOL record [TODO ??]),
    # <i>and</i> is collapsed
    outline_group_starts_ends = 0
    ##
    # 1 = Row is hidden (manually, or by a filter or outline group)
    hidden = 0
    ##
    # 1 = Row height and default font height do not match
    height_mismatch = 0
    ##
    # 1 = the xf_index attribute is usable; 0 = ignore it
    has_default_xf_index = 0
    ##
    # Index to default XF record for empty cells in this row.
    # Don't use this if has_default_xf_index == 0.
    xf_index = -9999
    ##
    # This flag is set, if the upper border of at least one cell in this row
    # or if the lower border of at least one cell in the row above is
    # formatted with a thick line style. Thin and medium line styles are not
    # taken into account.
    additional_space_above = 0
    ##
    # This flag is set, if the lower border of at least one cell in this row
    # or if the upper border of at least one cell in the row below is
    # formatted with a medium or thick line style. Thin line styles are not
    # taken into account.
    additional_space_below = 0

########NEW FILE########
__FILENAME__ = xfcell
# Author:  mozman <mozman@gmx.at>
# Purpose: xfcell -- cell with convenient xf function
# Created: 04.12.2010
# Copyright (C) 2010, Manfred Moitzi
# License: BSD-style licence

"""
The XFCell() object contains the data for one cell.

WARNING: You don't call this class yourself. You access Cell objects
via methods of the Sheet object(s) that you found in the Book object that
was returned when you called xlrd.open_workbook("myfile.xls").

Cell objects have four attributes: `ctype` is an int, `value` (which depends
on `ctype`), `xf_index` and `sheet`, a reference to the containing sheet. If
**formatting_info** is not enabled when the workbook is opened, xf_index will
be **None**.

The following table describes the types of cells and how their values
are represented in Python.

=============== ===== ============ ==========================================
Type symbol     Const Python value Note
=============== ===== ============ ==========================================
XL_CELL_EMPTY   0     ""
XL_CELL_TEXT    1     str
XL_CELL_NUMBER  2     float
XL_CELL_DATE    3     float
XL_CELL_BOOLEAN 4     int          1 means TRUE, 0 means FALSE
XL_CELL_ERROR   5     int          representing internal Excel codes; for a
                                   text representation, refer to the supplied
                                   dictionary error_text_from_code
XL_CELL_BLANK   6     ""           this type will appear only when
                                   open_workbook(..., formatting_info=True)
                                   is used.
=============== ===== ============ ==========================================
"""

import datetime

from .xldate import xldate_as_tuple
from .biffh import XL_CELL_DATE, BaseObject

class XFCell(BaseObject):
    """ Extended Cell() class with convenient methods for easy access of cell
    properties.
    """
    __slots__ = ['sheet', 'ctype', 'value', 'xf']

    def __init__(self, ctype, value, xf_index=None, sheet=None):
        self.sheet = sheet
        self.ctype = ctype
        self.value = value

        if xf_index is not None:
            self.xf = self.book.xf_list[xf_index]
        else:
            self.xf = None

    @property
    def book(self):
        return self.sheet.book

    @property
    def has_xf(self):
        return (self.xf is not None)

    @property
    def xf_index(self):
        if self.has_xf:
            return self.xf.xf_index
        else:
            return None

    @property
    def parent_style(self):
        return self.book.xf_list[self.xf.parent_style_index]

    @property
    def is_datetime(self):
        return self.ctype == XL_CELL_DATE

    @property
    def has_date(self):
        if self.is_datetime:
            return self.value > 1.
        return False

    def get_color(self, index):
        return self.book.colour_map[index]

    def datetime(self):
        """ Returns a datetime.datetime object if cell type is XL_CELL_DATE
        else raises a TypeError, and raises ValueError if the the cell has
        not date value (only time value is present).
        """
        if self.is_datetime:
            if self.has_date:
                date = xldate_as_tuple(self.value, self.book.datemode)
                return datetime.datetime(*date)
            else:
                raise ValueError("Cell has no date value.")
        else:
            raise TypeError("Cell is not a XL_CELL_DATE.")

    def date(self):
        """ Returns a datetime.date object if cell type is XL_CELL_DATE
        else raises a **TypeError**. Raises **ValueError** if the cell
        doesn't have a date value (only time value is present).
        """
        dt = self.datetime()
        return dt.date()

    def time(self):
        """ Returns a datetime.time object if cell type is XL_CELL_DATE else
        raises a TypeError.
        """
        if self.is_datetime:
            date = xldate_as_tuple(self.value, self.book.datemode)
            return datetime.time(date[3], date[4], date[5])
        else:
            raise TypeError("Cell is not a XL_CELL_DATE.")

    #
    # access the XFBackground() class
    #

    @property
    def background(self):
        if self.xf.is_style and \
           self.xf._background_flag == 0:
            return self.xf.background
        elif self.xf._background_flag:
            return self.xf.background
        else:
            return self.parent_style.background

    def background_color(self):
        """ Get cell background-color as 3-tuple. """
        color_index = self.xf.background.background_colour_index
        return self.get_color(color_index)

    def fill_pattern(self):
        return self.xf.background.fill_pattern

    def pattern_color(self):
        color_index = self.xf.background.pattern_colour_index
        return self.get_color(color_index)

    #
    # access the Font() class
    #

    @property
    def font_index(self):
        if self.xf.is_style and \
           self.xf._font_flag == 0:
            return self.xf.font_index
        elif self.xf._font_flag:
            return self.xf.font_index
        else:
            return self.parent_style.font_index

    @property
    def font(self):
        """ Get the Font() class. """
        return self.book.font_list[self.xf.font_index]

    def font_color(self):
        """ Get cell foreground-color as 3-tuple. """
        return self.get_color(self.font.colour_index)

    #
    # access the Format() class
    #

    @property
    def format_key(self):
        if self.xf.is_style and \
           self.xf._format_flag == 0:
            return self.xf.format_key
        elif self.xf._format_flag:
            return self.xf.format_key
        else:
            return self.parent_style.format_key

    @property
    def format(self):
        """ Get the Format() class. """
        return self.book.format_map[self.format_key]

    def format_str(self):
        """ Get the associated 'format_str'. """
        return self.format.format_str

    #
    # access the XFAligment() class
    #

    @property
    def alignment(self):
        if self.xf.is_style and \
           self.xf._alignment_flag == 0:
            return self.xf.alignment
        elif self.xf._alignment_flag:
            return self.xf.alignment
        else:
            return self.parent_style.alignment

    #
    # access the XFBorder() class
    #

    @property
    def border(self):
        if self.xf.is_style and \
           self.xf._border_flag == 0:
            return self.xf.border
        elif self.xf._border_flag:
            return self.xf.border
        else:
            return self.parent_style.border

    def bordercolors(self):
        """ Get border color as dict of rgb-color-tuples. """
        border = self.border
        return {
            'top': self.get_color(border.top_colour_index),
            'bottom': self.get_color(border.bottom_colour_index),
            'left': self.get_color(border.left_colour_index),
            'right': self.get_color(border.right_colour_index),
            'diag': self.get_color(border.diag_colour_index),
        }

    def borderstyles(self):
        """ Get border styles as dict of ints. """
        border = self.border
        return {
            'top': border.top_line_style,
            'bottom': border.bottom_line_style,
            'left': border.left_line_style,
            'right': border.right_line_style,
            'diag': border.diag_line_style,
        }

    @property
    def has_up_diag(self):
        """ Draw a line across the cell from bottom left to top right. """
        return bool(self.border.diag_up)

    @property
    def has_down_diag(self):
        """ Draw a line across the cell from top left to bottom right. """
        return bool(self.border.diag_down)

    #
    # access the XFProtection() class
    #

    @property
    def protection(self):
        if self.xf.is_style and \
           self.xf._protection_flag == 0:
            return self.xf.protection
        elif self.xf._protection_flag:
            return self.xf.protection
        else:
            return self.parent_style.protection

    @property
    def is_cell_locked(self):
        return bool(self.protection.cell_locked)

    @property
    def is_formula_hidden(self):
        return bool(self.protection.cell_locked)

########NEW FILE########
__FILENAME__ = xfconst
# Author:  mozman <mozman@gmx.at>
# Purpose: xfconst -- xf constants
# Created: 05.12.2010
# Copyright (C) 2010, Manfred Moitzi
# License: BSD-style licence

# excelfileformat section 5.115.1 pg. 219
HOR_ALIGN_GENERAL = 0
HOR_ALIGN_LEFT = 1
HOR_ALIGN_CENTRED = 2
HOR_ALIGN_RIGHT = 3
HOR_ALIGN_FILLED = 4
HOR_ALIGN_JUSTIFIED = 5
HOR_ALIGN_CENTRED_ACROSS_SELECTION = 6
HOR_ALIGN_DISTRIBUTED = 7

# excelfileformat section 5.115.1 pg. 220
VERT_ALIGN_TOP = 0
VERT_ALIGN_CENTRED = 1
VERT_ALIGN_BOTTOM = 2
VERT_ALIGN_JUSTIFIED = 3
VERT_ALIGN_DISTRIBUTED = 4

# excelfileformat section 5.115.1 pg. 220
ORIENTATION_NONE = 0
ORIENTATION_STACKED = 1
ORIENTATION_90_COUNTERCLOCKWISE = 2
ORIENTATION_90_CLOCKWISE = 3

# excelfileformat section 5.115.1 pg. 220
ROTATION_NONE = 0
ROTATION_STACKED = 255
# other values:
# Value    Description
# =======  =================================
# 1-90     1 to 90 degrees counterclockwise
# 91-180   1 to 90 degrees clockwise

# excelfileformat section 2.5.11  Line Styles for Cell Borders pg. 24
LS_NOLINE = 0

# solid line
LS_THIN = 1

# solid line
LS_MEDIUM = 2

# - - - - - - - - -
LS_DASHED = 3

# .................
LS_DOTTED = 4

# solid line
LS_THICK = 5

# =================
LS_DOUBLE = 6

# very thin dotted
LS_HAIR = 7

# - - - - - - - - -
LS_MEDIUM_DASHED = 8

# - . - . - . - . -
LS_THIN_DASH_DOTTED = 9

# - . - . - . - . -
LS_MEDIUM_DASH_DOTTED = 10

# - .. - .. - .. - .. -
LS_THIN_DASH_DOT_DOTTED = 11

# - .. - .. - .. - .. -
LS_MEDIUM_DASH_DOT_DOTTED = 12

# \\\ . \\\ . \\\ . \\\ . \\\
LS_SLANTED_MEDIUM_DASH_DOTTED = 13






########NEW FILE########
__FILENAME__ = xldate
# No part of the content of this file was derived from the works of David Giffin.
#
# Copyright  2005-2008 Stephen John Machin, Lingfo Pty Ltd
# This module is part of the xlrd3 package, which is released under a
# BSD-style licence.
#
# Provides function(s) for dealing with Microsoft Excel  dates.
#
# 2008-10-18 SJM Fix bug in xldate_from_date_tuple (affected some years after 2099)
#
# The conversion from days to (year, month, day) starts with
# an integral "julian day number" aka JDN.
# FWIW, JDN 0 corresponds to noon on Monday November 24 in Gregorian year -4713.
# More importantly:
#    Noon on Gregorian 1900-03-01 (day 61 in the 1900-based system) is JDN 2415080.0
#    Noon on Gregorian 1904-01-02 (day  1 in the 1904-based system) is JDN 2416482.0

def ifd(x, y):
    return divmod(x, y)[0]

_JDN_delta = (2415080 - 61, 2416482 - 1)
assert _JDN_delta[1] - _JDN_delta[0] == 1462

class XLDateError(ValueError): pass

class XLDateNegative(XLDateError): pass
class XLDateAmbiguous(XLDateError): pass
class XLDateTooLarge(XLDateError): pass
class XLDateBadDatemode(XLDateError): pass
class XLDateBadTuple(XLDateError): pass

_XLDAYS_TOO_LARGE = (2958466, 2958466 - 1462) # This is equivalent to 10000-01-01

# Convert an Excel number (presumed to represent a date, a datetime or a time) into
# a tuple suitable for feeding to datetime or mx.DateTime constructors.
# @param xldate The Excel number
# @param datemode 0: 1900-based, 1: 1904-based.
# <br>WARNING: when using this function to
# interpret the contents of a workbook, you should pass in the Book.datemode
# attribute of that workbook. Whether
# the workbook has ever been anywhere near a Macintosh is irrelevant.
# @return Gregorian (year, month, day, hour, minute, nearest_second).
# <br>Special case: if 0.0 <= xldate < 1.0, it is assumed to represent a time;
# (0, 0, 0, hour, minute, second) will be returned.
# <br>Note: 1904-01-01 is not regarded as a valid date in the datemode 1 system; its "serial number"
# is zero.
# @throws XLDateNegative xldate < 0.00
# @throws XLDateAmbiguous The 1900 leap-year problem (datemode == 0 and 1.0 <= xldate < 61.0)
# @throws XLDateTooLarge Gregorian year 10000 or later
# @throws XLDateBadDatemode datemode arg is neither 0 nor 1
# @throws XLDateError Covers the 4 specific errors

def xldate_as_tuple(xldate, datemode):
    if datemode not in (0, 1):
        raise XLDateBadDatemode(datemode)
    if xldate == 0.00:
        return (0, 0, 0, 0, 0, 0)
    if xldate < 0.00:
        raise XLDateNegative(xldate)
    xldays = int(xldate)
    frac = xldate - xldays
    seconds = int(round(frac * 86400.0))
    assert 0 <= seconds <= 86400
    if seconds == 86400:
        hour = minute = second = 0
        xldays += 1
    else:
        # second = seconds % 60; minutes = seconds // 60
        minutes, second = divmod(seconds, 60)
        # minute = minutes % 60; hour    = minutes // 60
        hour, minute = divmod(minutes, 60)
    if xldays >= _XLDAYS_TOO_LARGE[datemode]:
        raise XLDateTooLarge(xldate)

    if xldays == 0:
        return (0, 0, 0, hour, minute, second)

    if xldays < 61 and datemode == 0:
        raise XLDateAmbiguous(xldate)

    jdn = xldays + _JDN_delta[datemode]
    yreg = (ifd(ifd(jdn * 4 + 274277, 146097) * 3, 4) + jdn + 1363) * 4 + 3
    mp = ifd(yreg % 1461, 4) * 535 + 333
    d = ifd(mp % 16384, 535) + 1
    # mp /= 16384
    mp >>= 14
    if mp >= 10:
        return (ifd(yreg, 1461) - 4715, mp - 9, d, hour, minute, second)
    else:
        return (ifd(yreg, 1461) - 4716, mp + 3, d, hour, minute, second)

# === conversions from date/time to xl numbers

def _leap(y):
    if y % 4: return 0
    if y % 100: return 1
    if y % 400: return 0
    return 1

_days_in_month = (None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)

# Convert a date tuple (year, month, day) to an Excel date.
# @param year Gregorian year.
# @param month 1 <= month <= 12
# @param day 1 <= day <= last day of that (year, month)
# @param datemode 0: 1900-based, 1: 1904-based.
# @throws XLDateAmbiguous The 1900 leap-year problem (datemode == 0 and 1.0 <= xldate < 61.0)
# @throws XLDateBadDatemode datemode arg is neither 0 nor 1
# @throws XLDateBadTuple (year, month, day) is too early/late or has invalid component(s)
# @throws XLDateError Covers the specific errors

def xldate_from_date_tuple(datetuple, datemode):

    (year, month, day) = datetuple
    if datemode not in (0, 1):
        raise XLDateBadDatemode(datemode)

    if year == 0 and month == 0 and day == 0:
        return 0.00

    if not (1900 <= year <= 9999):
        raise XLDateBadTuple("Invalid year: %r" % ((year, month, day),))
    if not (1 <= month <= 12):
        raise XLDateBadTuple("Invalid month: %r" % ((year, month, day),))
    if  day < 1 \
    or (day > _days_in_month[month] and not(day == 29 and month == 2 and _leap(year))):
        raise XLDateBadTuple("Invalid day: %r" % ((year, month, day),))

    Yp = year + 4716
    M = month
    if M <= 2:
        Yp = Yp - 1
        Mp = M + 9
    else:
        Mp = M - 3
    jdn = ifd(1461 * Yp, 4) + ifd(979 * Mp + 16, 32) + \
        day - 1364 - ifd(ifd(Yp + 184, 100) * 3, 4)
    xldays = jdn - _JDN_delta[datemode]
    if xldays <= 0:
        raise XLDateBadTuple("Invalid (year, month, day): %r" % ((year, month, day),))
    if xldays < 61 and datemode == 0:
        raise XLDateAmbiguous("Before 1900-03-01: %r" % ((year, month, day),))
    return float(xldays)

# Convert a time tuple (hour, minute, second) to an Excel "date" value (fraction of a day).
# @param hour 0 <= hour < 24
# @param minute 0 <= minute < 60
# @param second 0 <= second < 60
# @throws XLDateBadTuple Out-of-range hour, minute, or second

def xldate_from_time_tuple(timetuple):
    (hour, minute, second) = timetuple
    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:
        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0
    raise XLDateBadTuple("Invalid (hour, minute, second): %r" % ((hour, minute, second),))

# Convert a datetime tuple (year, month, day, hour, minute, second) to an Excel date value.
# For more details, refer to other xldate_from_*_tuple functions.
# @param datetime_tuple (year, month, day, hour, minute, second)
# @param datemode 0: 1900-based, 1: 1904-based.

def xldate_from_datetime_tuple(datetime_tuple, datemode):
    return (
        xldate_from_date_tuple(datetime_tuple[:3], datemode)
        +
        xldate_from_time_tuple(datetime_tuple[3:])
        )

########NEW FILE########
__FILENAME__ = antlr
## This file is part of PyANTLR. See LICENSE.txt for license
## details..........Copyright (C) Wolfgang Haefelinger, 2004.

## This file was copied for use with xlwt from the 2.7.7 ANTLR distribution. Yes, it
## says 2.7.5 below. The 2.7.5 distribution version didn't have a
## version in it.

## Here is the contents of the ANTLR 2.7.7 LICENSE.txt referred to above.

# SOFTWARE RIGHTS
#
# ANTLR 1989-2006 Developed by Terence Parr
# Partially supported by University of San Francisco & jGuru.com
#
# We reserve no legal rights to the ANTLR--it is fully in the
# public domain. An individual or company may do whatever
# they wish with source code distributed with ANTLR or the
# code generated by ANTLR, including the incorporation of
# ANTLR, or its output, into commerical software.
#
# We encourage users to develop software with ANTLR. However,
# we do ask that credit is given to us for developing
# ANTLR. By "credit", we mean that if you use ANTLR or
# incorporate any source code into one of your programs
# (commercial product, research project, or otherwise) that
# you acknowledge this fact somewhere in the documentation,
# research report, etc... If you like ANTLR and have
# developed a nice tool with the output, please mention that
# you developed it using ANTLR. In addition, we ask that the
# headers remain intact in our source code. As long as these
# guidelines are kept, we expect to continue enhancing this
# system and expect to make other tools available as they are
# completed.
#
# The primary ANTLR guy:
#
# Terence Parr
# parrt@cs.usfca.edu
# parrt@antlr.org

## End of contents of the ANTLR 2.7.7 LICENSE.txt ########################

## get sys module
import sys

version = sys.version.split()[0]
if version < '2.2.1':
    False = 0
if version < '2.3':
    True = not False

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                     global symbols                             ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

### ANTLR Standard Tokens
SKIP                = -1
INVALID_TYPE        = 0
EOF_TYPE            = 1
EOF                 = 1
NULL_TREE_LOOKAHEAD = 3
MIN_USER_TYPE       = 4

### ANTLR's EOF Symbol
EOF_CHAR            = ''

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                    general functions                           ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

## Version should be automatically derived from configure.in. For now,
## we need to bump it ourselfs. Don't remove the <version> tags.
## <version>
def version():
    r = {
        'major'  : '2',
        'minor'  : '7',
        'micro'  : '5',
        'patch'  : '' ,
        'version': '2.7.5'
        }
    return r
## </version>

def error(fmt,*args):
    if fmt:
        print "error: ", fmt % tuple(args)

def ifelse(cond,_then,_else):
    if cond :
        r = _then
    else:
        r = _else
    return r

def is_string_type(x):
    # return  (isinstance(x,str) or isinstance(x,unicode))
    # Simplify; xlwt doesn't support Python < 2.3
    return isinstance(basestring)

def assert_string_type(x):
    assert is_string_type(x)
    pass

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                     ANTLR Exceptions                           ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class ANTLRException(Exception):

    def __init__(self, *args):
        Exception.__init__(self, *args)


class RecognitionException(ANTLRException):

    def __init__(self, *args):
        ANTLRException.__init__(self, *args)
        self.fileName = None
        self.line = -1
        self.column = -1
        if len(args) >= 2:
            self.fileName = args[1]
        if len(args) >= 3:
            self.line = args[2]
        if len(args) >= 4:
            self.column = args[3]

    def __str__(self):
        buf = ['']
        if self.fileName:
            buf.append(self.fileName + ":")
        if self.line != -1:
            if not self.fileName:
                buf.append("line ")
            buf.append(str(self.line))
            if self.column != -1:
                buf.append(":" + str(self.column))
            buf.append(":")
        buf.append(" ")
        return str('').join(buf)

    __repr__ = __str__


class NoViableAltException(RecognitionException):

    def __init__(self, *args):
        RecognitionException.__init__(self, *args)
        self.token = None
        self.node  = None
        if isinstance(args[0],AST):
            self.node = args[0]
        elif isinstance(args[0],Token):
            self.token = args[0]
        else:
            raise TypeError("NoViableAltException requires Token or AST argument")

    def __str__(self):
        if self.token:
            line = self.token.getLine()
            col  = self.token.getColumn()
            text = self.token.getText()
            return "unexpected symbol at line %s (column %s): \"%s\"" % (line,col,text)
        if self.node == ASTNULL:
            return "unexpected end of subtree"
        assert self.node
        ### hackish, we assume that an AST contains method getText
        return "unexpected node: %s" % (self.node.getText())

    __repr__ = __str__


class NoViableAltForCharException(RecognitionException):

    def __init__(self, *args):
        self.foundChar = None
        if len(args) == 2:
            self.foundChar = args[0]
            scanner = args[1]
            RecognitionException.__init__(self, "NoViableAlt",
                                          scanner.getFilename(),
                                          scanner.getLine(),
                                          scanner.getColumn())
        elif len(args) == 4:
            self.foundChar = args[0]
            fileName = args[1]
            line = args[2]
            column = args[3]
            RecognitionException.__init__(self, "NoViableAlt",
                                          fileName, line, column)
        else:
            RecognitionException.__init__(self, "NoViableAlt",
                                          '', -1, -1)

    def __str__(self):
        mesg = "unexpected char: "
        if self.foundChar >= ' ' and self.foundChar <= '~':
            mesg += "'" + self.foundChar + "'"
        elif self.foundChar:
            mesg += "0x" + hex(ord(self.foundChar)).upper()[2:]
        else:
            mesg += "<None>"
        return mesg

    __repr__ = __str__


class SemanticException(RecognitionException):

    def __init__(self, *args):
        RecognitionException.__init__(self, *args)


class MismatchedCharException(RecognitionException):

    NONE = 0
    CHAR = 1
    NOT_CHAR = 2
    RANGE = 3
    NOT_RANGE = 4
    SET = 5
    NOT_SET = 6

    def __init__(self, *args):
        self.args = args
        if len(args) == 5:
            # Expected range / not range
            if args[3]:
                self.mismatchType = MismatchedCharException.NOT_RANGE
            else:
                self.mismatchType = MismatchedCharException.RANGE
            self.foundChar = args[0]
            self.expecting = args[1]
            self.upper = args[2]
            self.scanner = args[4]
            RecognitionException.__init__(self, "Mismatched char range",
                                          self.scanner.getFilename(),
                                          self.scanner.getLine(),
                                          self.scanner.getColumn())
        elif len(args) == 4 and is_string_type(args[1]):
            # Expected char / not char
            if args[2]:
                self.mismatchType = MismatchedCharException.NOT_CHAR
            else:
                self.mismatchType = MismatchedCharException.CHAR
            self.foundChar = args[0]
            self.expecting = args[1]
            self.scanner = args[3]
            RecognitionException.__init__(self, "Mismatched char",
                                          self.scanner.getFilename(),
                                          self.scanner.getLine(),
                                          self.scanner.getColumn())
        elif len(args) == 4 and isinstance(args[1], BitSet):
            # Expected BitSet / not BitSet
            if args[2]:
                self.mismatchType = MismatchedCharException.NOT_SET
            else:
                self.mismatchType = MismatchedCharException.SET
            self.foundChar = args[0]
            self.set = args[1]
            self.scanner = args[3]
            RecognitionException.__init__(self, "Mismatched char set",
                                          self.scanner.getFilename(),
                                          self.scanner.getLine(),
                                          self.scanner.getColumn())
        else:
            self.mismatchType = MismatchedCharException.NONE
            RecognitionException.__init__(self, "Mismatched char")

    ## Append a char to the msg buffer.  If special,
    #  then show escaped version
    #
    def appendCharName(self, sb, c):
        if not c or c == 65535:
            # 65535 = (char) -1 = EOF
            sb.append("'<EOF>'")
        elif c == '\n':
            sb.append("'\\n'")
        elif c == '\r':
            sb.append("'\\r'");
        elif c == '\t':
            sb.append("'\\t'")
        else:
            sb.append('\'' + c + '\'')

    ##
    # Returns an error message with line number/column information
    #
    def __str__(self):
        sb = ['']
        sb.append(RecognitionException.__str__(self))

        if self.mismatchType == MismatchedCharException.CHAR:
            sb.append("expecting ")
            self.appendCharName(sb, self.expecting)
            sb.append(", found ")
            self.appendCharName(sb, self.foundChar)
        elif self.mismatchType == MismatchedCharException.NOT_CHAR:
            sb.append("expecting anything but '")
            self.appendCharName(sb, self.expecting)
            sb.append("'; got it anyway")
        elif self.mismatchType in [MismatchedCharException.RANGE, MismatchedCharException.NOT_RANGE]:
            sb.append("expecting char ")
            if self.mismatchType == MismatchedCharException.NOT_RANGE:
                sb.append("NOT ")
            sb.append("in range: ")
            appendCharName(sb, self.expecting)
            sb.append("..")
            appendCharName(sb, self.upper)
            sb.append(", found ")
            appendCharName(sb, self.foundChar)
        elif self.mismatchType in [MismatchedCharException.SET, MismatchedCharException.NOT_SET]:
            sb.append("expecting ")
            if self.mismatchType == MismatchedCharException.NOT_SET:
                sb.append("NOT ")
            sb.append("one of (")
            for i in range(len(self.set)):
                self.appendCharName(sb, self.set[i])
            sb.append("), found ")
            self.appendCharName(sb, self.foundChar)

        return str().join(sb).strip()

    __repr__ = __str__


class MismatchedTokenException(RecognitionException):

    NONE = 0
    TOKEN = 1
    NOT_TOKEN = 2
    RANGE = 3
    NOT_RANGE = 4
    SET = 5
    NOT_SET = 6

    def __init__(self, *args):
        self.args =  args
        self.tokenNames = []
        self.token = None
        self.tokenText = ''
        self.node =  None
        if len(args) == 6:
            # Expected range / not range
            if args[3]:
                self.mismatchType = MismatchedTokenException.NOT_RANGE
            else:
                self.mismatchType = MismatchedTokenException.RANGE
            self.tokenNames = args[0]
            self.expecting = args[2]
            self.upper = args[3]
            self.fileName = args[5]

        elif len(args) == 4 and isinstance(args[2], int):
            # Expected token / not token
            if args[3]:
                self.mismatchType = MismatchedTokenException.NOT_TOKEN
            else:
                self.mismatchType = MismatchedTokenException.TOKEN
            self.tokenNames = args[0]
            self.expecting = args[2]

        elif len(args) == 4 and isinstance(args[2], BitSet):
            # Expected BitSet / not BitSet
            if args[3]:
                self.mismatchType = MismatchedTokenException.NOT_SET
            else:
                self.mismatchType = MismatchedTokenException.SET
            self.tokenNames = args[0]
            self.set = args[2]

        else:
            self.mismatchType = MismatchedTokenException.NONE
            RecognitionException.__init__(self, "Mismatched Token: expecting any AST node", "<AST>", -1, -1)

        if len(args) >= 2:
            if isinstance(args[1],Token):
                self.token = args[1]
                self.tokenText = self.token.getText()
                RecognitionException.__init__(self, "Mismatched Token",
                                              self.fileName,
                                              self.token.getLine(),
                                              self.token.getColumn())
            elif isinstance(args[1],AST):
                self.node = args[1]
                self.tokenText = str(self.node)
                RecognitionException.__init__(self, "Mismatched Token",
                                              "<AST>",
                                              self.node.getLine(),
                                              self.node.getColumn())
            else:
                self.tokenText = "<empty tree>"
                RecognitionException.__init__(self, "Mismatched Token",
                                              "<AST>", -1, -1)

    def appendTokenName(self, sb, tokenType):
        if tokenType == INVALID_TYPE:
            sb.append("<Set of tokens>")
        elif tokenType < 0 or tokenType >= len(self.tokenNames):
            sb.append("<" + str(tokenType) + ">")
        else:
            sb.append(self.tokenNames[tokenType])

    ##
    # Returns an error message with line number/column information
    #
    def __str__(self):
        sb = ['']
        sb.append(RecognitionException.__str__(self))

        if self.mismatchType == MismatchedTokenException.TOKEN:
            sb.append("expecting ")
            self.appendTokenName(sb, self.expecting)
            sb.append(", found " + self.tokenText)
        elif self.mismatchType == MismatchedTokenException.NOT_TOKEN:
            sb.append("expecting anything but '")
            self.appendTokenName(sb, self.expecting)
            sb.append("'; got it anyway")
        elif self.mismatchType in [MismatchedTokenException.RANGE, MismatchedTokenException.NOT_RANGE]:
            sb.append("expecting token ")
            if self.mismatchType == MismatchedTokenException.NOT_RANGE:
                sb.append("NOT ")
            sb.append("in range: ")
            appendTokenName(sb, self.expecting)
            sb.append("..")
            appendTokenName(sb, self.upper)
            sb.append(", found " + self.tokenText)
        elif self.mismatchType in [MismatchedTokenException.SET, MismatchedTokenException.NOT_SET]:
            sb.append("expecting ")
            if self.mismatchType == MismatchedTokenException.NOT_SET:
                sb.append("NOT ")
            sb.append("one of (")
            for i in range(len(self.set)):
                self.appendTokenName(sb, self.set[i])
            sb.append("), found " + self.tokenText)

        return str().join(sb).strip()

    __repr__ = __str__


class TokenStreamException(ANTLRException):

    def __init__(self, *args):
        ANTLRException.__init__(self, *args)


# Wraps an Exception in a TokenStreamException
class TokenStreamIOException(TokenStreamException):

    def __init__(self, *args):
        if args and isinstance(args[0], Exception):
            io = args[0]
            TokenStreamException.__init__(self, str(io))
            self.io = io
        else:
            TokenStreamException.__init__(self, *args)
            self.io = self


# Wraps a RecognitionException in a TokenStreamException
class TokenStreamRecognitionException(TokenStreamException):

    def __init__(self, *args):
        if args and isinstance(args[0], RecognitionException):
            recog = args[0]
            TokenStreamException.__init__(self, str(recog))
            self.recog = recog
        else:
            raise TypeError("TokenStreamRecognitionException requires RecognitionException argument")

    def __str__(self):
        return str(self.recog)

    __repr__ = __str__


class TokenStreamRetryException(TokenStreamException):

    def __init__(self, *args):
        TokenStreamException.__init__(self, *args)


class CharStreamException(ANTLRException):

    def __init__(self, *args):
        ANTLRException.__init__(self, *args)


# Wraps an Exception in a CharStreamException
class CharStreamIOException(CharStreamException):

    def __init__(self, *args):
        if args and isinstance(args[0], Exception):
            io = args[0]
            CharStreamException.__init__(self, str(io))
            self.io = io
        else:
            CharStreamException.__init__(self, *args)
            self.io = self


class TryAgain(Exception):
    pass


###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       Token                                    ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class Token(object):
    SKIP                = -1
    INVALID_TYPE        = 0
    EOF_TYPE            = 1
    EOF                 = 1
    NULL_TREE_LOOKAHEAD = 3
    MIN_USER_TYPE       = 4

    def __init__(self,**argv):
        try:
            self.type = argv['type']
        except:
            self.type = INVALID_TYPE
        try:
            self.text = argv['text']
        except:
            self.text = "<no text>"

    def isEOF(self):
        return (self.type == EOF_TYPE)

    def getColumn(self):
        return 0

    def getLine(self):
        return 0

    def getFilename(self):
        return None

    def setFilename(self,name):
        return self

    def getText(self):
        return "<no text>"

    def setText(self,text):
        if is_string_type(text):
            pass
        else:
            raise TypeError("Token.setText requires string argument")
        return self

    def setColumn(self,column):
        return self

    def setLine(self,line):
        return self

    def getType(self):
        return self.type

    def setType(self,type):
        if isinstance(type,int):
            self.type = type
        else:
            raise TypeError("Token.setType requires integer argument")
        return self

    def toString(self):
        ## not optimal
        type_ = self.type
        if type_ == 3:
            tval = 'NULL_TREE_LOOKAHEAD'
        elif type_ == 1:
            tval = 'EOF_TYPE'
        elif type_ == 0:
            tval = 'INVALID_TYPE'
        elif type_ == -1:
            tval = 'SKIP'
        else:
            tval = type_
        return '["%s",<%s>]' % (self.getText(),tval)

    __str__ = toString
    __repr__ = toString

### static attribute ..
Token.badToken = Token( type=INVALID_TYPE, text="<no text>")

if __name__ == "__main__":
    print "testing .."
    T = Token.badToken
    print T

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       CommonToken                              ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class CommonToken(Token):

    def __init__(self,**argv):
        Token.__init__(self,**argv)
        self.line = 0
        self.col  = 0
        try:
            self.line = argv['line']
        except:
            pass
        try:
            self.col = argv['col']
        except:
            pass

    def getLine(self):
        return self.line

    def getText(self):
        return self.text

    def getColumn(self):
        return self.col

    def setLine(self,line):
        self.line = line
        return self

    def setText(self,text):
        self.text = text
        return self

    def setColumn(self,col):
        self.col = col
        return self

    def toString(self):
        ## not optimal
        type_ = self.type
        if type_ == 3:
            tval = 'NULL_TREE_LOOKAHEAD'
        elif type_ == 1:
            tval = 'EOF_TYPE'
        elif type_ == 0:
            tval = 'INVALID_TYPE'
        elif type_ == -1:
            tval = 'SKIP'
        else:
            tval = type_
        d = {
           'text' : self.text,
           'type' : tval,
           'line' : self.line,
           'colm' : self.col
           }

        fmt = '["%(text)s",<%(type)s>,line=%(line)s,col=%(colm)s]'
        return fmt % d

    __str__ = toString
    __repr__ = toString


if __name__ == '__main__' :
    T = CommonToken()
    print T
    T = CommonToken(col=15,line=1,text="some text", type=5)
    print T
    T = CommonToken()
    T.setLine(1).setColumn(15).setText("some text").setType(5)
    print T
    print T.getLine()
    print T.getColumn()
    print T.getText()
    print T.getType()

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                    CommonHiddenStreamToken                     ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class CommonHiddenStreamToken(CommonToken):
    def __init__(self,*args):
        CommonToken.__init__(self,*args)
        self.hiddenBefore = None
        self.hiddenAfter  = None

    def getHiddenAfter(self):
        return self.hiddenAfter

    def getHiddenBefore(self):
        return self.hiddenBefore

    def setHiddenAfter(self,t):
        self.hiddenAfter = t

    def setHiddenBefore(self, t):
        self.hiddenBefore = t

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       Queue                                    ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

## Shall be a circular buffer on tokens ..
class Queue(object):

    def __init__(self):
        self.buffer = [] # empty list

    def append(self,item):
        self.buffer.append(item)

    def elementAt(self,index):
        return self.buffer[index]

    def reset(self):
        self.buffer = []

    def removeFirst(self):
        self.buffer.pop(0)

    def length(self):
        return len(self.buffer)

    def __str__(self):
        return str(self.buffer)

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       InputBuffer                              ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class InputBuffer(object):
    def __init__(self):
        self.nMarkers = 0
        self.markerOffset = 0
        self.numToConsume = 0
        self.queue = Queue()

    def __str__(self):
        return "(%s,%s,%s,%s)" % (
           self.nMarkers,
           self.markerOffset,
           self.numToConsume,
           self.queue)

    def __repr__(self):
        return str(self)

    def commit(self):
        self.nMarkers -= 1

    def consume(self) :
        self.numToConsume += 1

    ## probably better to return a list of items
    ## because of unicode. Or return a unicode
    ## string ..
    def getLAChars(self) :
        i = self.markerOffset
        n = self.queue.length()
        s = ''
        while i<n:
            s += self.queue.elementAt(i)
        return s

    ## probably better to return a list of items
    ## because of unicode chars
    def getMarkedChars(self) :
        s = ''
        i = 0
        n = self.markerOffset
        while i<n:
            s += self.queue.elementAt(i)
        return s

    def isMarked(self) :
        return self.nMarkers != 0

    def fill(self,k):
        ### abstract method
        raise NotImplementedError()

    def LA(self,k) :
        self.fill(k)
        return self.queue.elementAt(self.markerOffset + k - 1)

    def mark(self) :
        self.syncConsume()
        self.nMarkers += 1
        return self.markerOffset

    def rewind(self,mark) :
        self.syncConsume()
        self.markerOffset = mark
        self.nMarkers -= 1

    def reset(self) :
        self.nMarkers = 0
        self.markerOffset = 0
        self.numToConsume = 0
        self.queue.reset()

    def syncConsume(self) :
        while self.numToConsume > 0:
            if self.nMarkers > 0:
                # guess mode -- leave leading characters and bump offset.
                self.markerOffset += 1
            else:
                # normal mode -- remove first character
                self.queue.removeFirst()
            self.numToConsume -= 1

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       CharBuffer                               ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class CharBuffer(InputBuffer):
    def __init__(self,reader):
        ##assert isinstance(reader,file)
        super(CharBuffer,self).__init__()
        ## a reader is supposed to be anything that has
        ## a method 'read(int)'.
        self.input = reader

    def __str__(self):
        base = super(CharBuffer,self).__str__()
        return "CharBuffer{%s,%s" % (base,str(input))

    def fill(self,amount):
        try:
            self.syncConsume()
            while self.queue.length() < (amount + self.markerOffset) :
                ## retrieve just one char - what happend at end
                ## of input?
                c = self.input.read(1)
                ### python's behaviour is to return the empty string  on
                ### EOF, ie. no exception whatsoever is thrown. An empty
                ### python  string  has  the  nice feature that it is of
                ### type 'str' and  "not ''" would return true. Contrary,
                ### one can't  do  this: '' in 'abc'. This should return
                ### false,  but all we  get  is  then  a TypeError as an
                ### empty string is not a character.

                ### Let's assure then that we have either seen a
                ### character or an empty string (EOF).
                assert len(c) == 0 or len(c) == 1

                ### And it shall be of type string (ASCII or UNICODE).
                assert is_string_type(c)

                ### Just append EOF char to buffer. Note that buffer may
                ### contain then just more than one EOF char ..

                ### use unicode chars instead of ASCII ..
                self.queue.append(c)
        except Exception,e:
            raise CharStreamIOException(e)
        ##except: # (mk) Cannot happen ...
            ##error ("unexpected exception caught ..")
            ##assert 0

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       LexerSharedInputState                    ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class LexerSharedInputState(object):
    def __init__(self,ibuf):
        assert isinstance(ibuf,InputBuffer)
        self.input = ibuf
        self.column = 1
        self.line = 1
        self.tokenStartColumn = 1
        self.tokenStartLine = 1
        self.guessing = 0
        self.filename = None

    def reset(self):
        self.column = 1
        self.line = 1
        self.tokenStartColumn = 1
        self.tokenStartLine = 1
        self.guessing = 0
        self.filename = None
        self.input.reset()

    def LA(self,k):
        return self.input.LA(k)

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                    TokenStream                                 ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class TokenStream(object):
    def nextToken(self):
        pass

    def __iter__(self):
        return TokenStreamIterator(self)

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                    TokenStreamIterator                                 ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class TokenStreamIterator(object):
    def __init__(self,inst):
        if isinstance(inst,TokenStream):
            self.inst = inst
            return
        raise TypeError("TokenStreamIterator requires TokenStream object")

    def next(self):
        assert self.inst
        item = self.inst.nextToken()
        if not item or item.isEOF():
            raise StopIteration()
        return item

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                    TokenStreamSelector                        ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class TokenStreamSelector(TokenStream):

    def __init__(self):
        self._input = None
        self._stmap = {}
        self._stack = []

    def addInputStream(self,stream,key):
        self._stmap[key] = stream

    def getCurrentStream(self):
        return self._input

    def getStream(self,sname):
        try:
            stream = self._stmap[sname]
        except:
            raise ValueError("TokenStream " + sname + " not found");
        return stream;

    def nextToken(self):
        while 1:
            try:
                return self._input.nextToken()
            except TokenStreamRetryException,r:
                ### just retry "forever"
                pass

    def pop(self):
        stream = self._stack.pop();
        self.select(stream);
        return stream;

    def push(self,arg):
        self._stack.append(self._input);
        self.select(arg)

    def retry(self):
        raise TokenStreamRetryException()

    def select(self,arg):
        if isinstance(arg,TokenStream):
            self._input = arg
            return
        if is_string_type(arg):
            self._input = self.getStream(arg)
            return
        raise TypeError("TokenStreamSelector.select requires " +
                        "TokenStream or string argument")

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                      TokenStreamBasicFilter                    ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class TokenStreamBasicFilter(TokenStream):

    def __init__(self,input):

        self.input = input;
        self.discardMask = BitSet()

    def discard(self,arg):
        if isinstance(arg,int):
            self.discardMask.add(arg)
            return
        if isinstance(arg,BitSet):
            self.discardMark = arg
            return
        raise TypeError("TokenStreamBasicFilter.discard requires" +
                        "integer or BitSet argument")

    def nextToken(self):
        tok = self.input.nextToken()
        while tok and self.discardMask.member(tok.getType()):
            tok = self.input.nextToken()
        return tok

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                      TokenStreamHiddenTokenFilter              ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class TokenStreamHiddenTokenFilter(TokenStreamBasicFilter):

    def __init__(self,input):
        TokenStreamBasicFilter.__init__(self,input)
        self.hideMask = BitSet()
        self.nextMonitoredToken = None
        self.lastHiddenToken = None
        self.firstHidden = None

    def consume(self):
        self.nextMonitoredToken = self.input.nextToken()

    def consumeFirst(self):
        self.consume()

        p = None;
        while self.hideMask.member(self.LA(1).getType()) or \
              self.discardMask.member(self.LA(1).getType()):
            if self.hideMask.member(self.LA(1).getType()):
                if not p:
                    p = self.LA(1)
                else:
                    p.setHiddenAfter(self.LA(1))
                    self.LA(1).setHiddenBefore(p)
                    p = self.LA(1)
                self.lastHiddenToken = p
                if not self.firstHidden:
                    self.firstHidden = p
            self.consume()

    def getDiscardMask(self):
        return self.discardMask

    def getHiddenAfter(self,t):
        return t.getHiddenAfter()

    def getHiddenBefore(self,t):
        return t.getHiddenBefore()

    def getHideMask(self):
        return self.hideMask

    def getInitialHiddenToken(self):
        return self.firstHidden

    def hide(self,m):
        if isinstance(m,int):
            self.hideMask.add(m)
            return
        if isinstance(m.BitMask):
            self.hideMask = m
            return

    def LA(self,i):
        return self.nextMonitoredToken

    def nextToken(self):
        if not self.LA(1):
            self.consumeFirst()

        monitored = self.LA(1)

        monitored.setHiddenBefore(self.lastHiddenToken)
        self.lastHiddenToken = None

        self.consume()
        p = monitored

        while self.hideMask.member(self.LA(1).getType()) or \
              self.discardMask.member(self.LA(1).getType()):
            if self.hideMask.member(self.LA(1).getType()):
                p.setHiddenAfter(self.LA(1))
                if p != monitored:
                    self.LA(1).setHiddenBefore(p)
                p = self.lastHiddenToken = self.LA(1)
            self.consume()
        return monitored

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       StringBuffer                             ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class StringBuffer:
    def __init__(self,string=None):
        if string:
            self.text = list(string)
        else:
            self.text = []

    def setLength(self,sz):
        if not sz :
            self.text = []
            return
        assert sz>0
        if sz >= self.length():
            return
        ### just reset to empty buffer
        self.text = self.text[0:sz]

    def length(self):
        return len(self.text)

    def append(self,c):
        self.text.append(c)

    ### return buffer as string. Arg 'a' is  used  as index
    ## into the buffer and 2nd argument shall be the length.
    ## If 2nd args is absent, we return chars till end of
    ## buffer starting with 'a'.
    def getString(self,a=None,length=None):
        if not a :
            a = 0
        assert a>=0
        if a>= len(self.text) :
            return ""

        if not length:
            ## no second argument
            L = self.text[a:]
        else:
            assert (a+length) <= len(self.text)
            b = a + length
            L = self.text[a:b]
        s = ""
        for x in L : s += x
        return s

    toString = getString ## alias

    def __str__(self):
        return str(self.text)

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       Reader                                   ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

## When reading Japanese chars, it happens that a stream returns a
## 'char' of length 2. This looks like  a  bug  in the appropriate
## codecs - but I'm  rather  unsure about this. Anyway, if this is
## the case, I'm going to  split  this string into a list of chars
## and put them  on  hold, ie. on a  buffer. Next time when called
## we read from buffer until buffer is empty.
## wh: nov, 25th -> problem does not appear in Python 2.4.0.c1.

class Reader(object):
    def __init__(self,stream):
        self.cin = stream
        self.buf = []

    def read(self,num):
        assert num==1

        if len(self.buf):
            return self.buf.pop()

        ## Read a char - this may return a string.
        ## Is this a bug in codecs/Python?
        c = self.cin.read(1)

        if not c or len(c)==1:
            return c

        L = list(c)
        L.reverse()
        for x in L:
            self.buf.append(x)

        ## read one char ..
        return self.read(1)

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       CharScanner                              ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class CharScanner(TokenStream):
    ## class members
    NO_CHAR = 0
    EOF_CHAR = ''  ### EOF shall be the empty string.

    def __init__(self, *argv, **kwargs):
        super(CharScanner, self).__init__()
        self.saveConsumedInput = True
        self.tokenClass = None
        self.caseSensitive = True
        self.caseSensitiveLiterals = True
        self.literals = None
        self.tabsize = 8
        self._returnToken = None
        self.commitToPath = False
        self.traceDepth = 0
        self.text = StringBuffer()
        self.hashString = hash(self)
        self.setTokenObjectClass(CommonToken)
        self.setInput(*argv)

    def __iter__(self):
        return CharScannerIterator(self)

    def setInput(self,*argv):
        ## case 1:
        ## if there's no arg we default to read from
        ## standard input
        if not argv:
            import sys
            self.setInput(sys.stdin)
            return

        ## get 1st argument
        arg1 = argv[0]

        ## case 2:
        ## if arg1 is a string,  we assume it's a file name
        ## and  open  a  stream  using 2nd argument as open
        ## mode. If there's no 2nd argument we fall back to
        ## mode '+rb'.
        if is_string_type(arg1):
            f = open(arg1,"rb")
            self.setInput(f)
            self.setFilename(arg1)
            return

        ## case 3:
        ## if arg1 is a file we wrap it by a char buffer (
        ## some additional checks?? No, can't do this in
        ## general).
        if isinstance(arg1,file):
            self.setInput(CharBuffer(arg1))
            return

        ## case 4:
        ## if arg1 is of type SharedLexerInputState we use
        ## argument as is.
        if isinstance(arg1,LexerSharedInputState):
            self.inputState = arg1
            return

        ## case 5:
        ## check whether argument type is of type input
        ## buffer. If so create a SharedLexerInputState and
        ## go ahead.
        if isinstance(arg1,InputBuffer):
            self.setInput(LexerSharedInputState(arg1))
            return

        ## case 6:
        ## check whether argument type has a method read(int)
        ## If so create CharBuffer ...
        try:
            if arg1.read:
                rd = Reader(arg1)
                cb = CharBuffer(rd)
                ss = LexerSharedInputState(cb)
                self.inputState = ss
            return
        except:
            pass

        ## case 7:
        ## raise wrong argument exception
        raise TypeError(argv)

    def setTabSize(self,size) :
        self.tabsize = size

    def getTabSize(self) :
        return self.tabsize

    def setCaseSensitive(self,t) :
        self.caseSensitive = t

    def setCommitToPath(self,commit) :
        self.commitToPath = commit

    def setFilename(self,f) :
        self.inputState.filename = f

    def setLine(self,line) :
        self.inputState.line = line

    def setText(self,s) :
        self.resetText()
        self.text.append(s)

    def getCaseSensitive(self) :
        return self.caseSensitive

    def getCaseSensitiveLiterals(self) :
        return self.caseSensitiveLiterals

    def getColumn(self) :
        return self.inputState.column

    def setColumn(self,c) :
        self.inputState.column = c

    def getCommitToPath(self) :
        return self.commitToPath

    def getFilename(self) :
        return self.inputState.filename

    def getInputBuffer(self) :
        return self.inputState.input

    def getInputState(self) :
        return self.inputState

    def setInputState(self,state) :
        assert isinstance(state,LexerSharedInputState)
        self.inputState = state

    def getLine(self) :
        return self.inputState.line

    def getText(self) :
        return str(self.text)

    def getTokenObject(self) :
        return self._returnToken

    def LA(self,i) :
        c = self.inputState.input.LA(i)
        if not self.caseSensitive:
            ### E0006
            c = c.__class__.lower(c)
        return c

    def makeToken(self,type) :
        try:
            ## dynamically load a class
            assert self.tokenClass
            tok = self.tokenClass()
            tok.setType(type)
            tok.setColumn(self.inputState.tokenStartColumn)
            tok.setLine(self.inputState.tokenStartLine)
            return tok
        except:
            self.panic("unable to create new token")
        return Token.badToken

    def mark(self) :
        return self.inputState.input.mark()

    def _match_bitset(self,b) :
        if b.member(self.LA(1)):
            self.consume()
        else:
            raise MismatchedCharException(self.LA(1), b, False, self)

    def _match_string(self,s) :
        for c in s:
            if self.LA(1) == c:
                self.consume()
            else:
                raise MismatchedCharException(self.LA(1), c, False, self)

    def match(self,item):
        if is_string_type(item):
            return self._match_string(item)
        else:
            return self._match_bitset(item)

    def matchNot(self,c) :
        if self.LA(1) != c:
            self.consume()
        else:
            raise MismatchedCharException(self.LA(1), c, True, self)

    def matchRange(self,c1,c2) :
        if self.LA(1) < c1 or self.LA(1) > c2 :
            raise MismatchedCharException(self.LA(1), c1, c2, False, self)
        else:
            self.consume()

    def newline(self) :
        self.inputState.line += 1
        self.inputState.column = 1

    def tab(self) :
        c = self.getColumn()
        nc = ( ((c-1)/self.tabsize) + 1) * self.tabsize + 1
        self.setColumn(nc)

    def panic(self,s='') :
        print "CharScanner: panic: " + s
        sys.exit(1)

    def reportError(self,ex) :
        print ex

    def reportError(self,s) :
        if not self.getFilename():
            print "error: " + str(s)
        else:
            print self.getFilename() + ": error: " + str(s)

    def reportWarning(self,s) :
        if not self.getFilename():
            print "warning: " + str(s)
        else:
            print self.getFilename() + ": warning: " + str(s)

    def resetText(self) :
        self.text.setLength(0)
        self.inputState.tokenStartColumn = self.inputState.column
        self.inputState.tokenStartLine = self.inputState.line

    def rewind(self,pos) :
        self.inputState.input.rewind(pos)

    def setTokenObjectClass(self,cl):
        self.tokenClass = cl

    def testForLiteral(self,token):
        if not token:
            return
        assert isinstance(token,Token)

        _type = token.getType()

        ## special tokens can't be literals
        if _type in [SKIP,INVALID_TYPE,EOF_TYPE,NULL_TREE_LOOKAHEAD] :
            return

        _text = token.getText()
        if not _text:
            return

        assert is_string_type(_text)
        _type = self.testLiteralsTable(_text,_type)
        token.setType(_type)
        return _type

    def testLiteralsTable(self,*args):
        if is_string_type(args[0]):
            s = args[0]
            i = args[1]
        else:
            s = self.text.getString()
            i = args[0]

        ## check whether integer has been given
        if not isinstance(i,int):
            assert isinstance(i,int)

        ## check whether we have a dict
        assert isinstance(self.literals,dict)
        try:
            ## E0010
            if not self.caseSensitiveLiterals:
                s = s.__class__.lower(s)
            i = self.literals[s]
        except:
            pass
        return i

    def toLower(self,c):
        return c.__class__.lower()

    def traceIndent(self):
        print ' ' * self.traceDepth

    def traceIn(self,rname):
        self.traceDepth += 1
        self.traceIndent()
        print "> lexer %s c== %s" % (rname,self.LA(1))

    def traceOut(self,rname):
        self.traceIndent()
        print "< lexer %s c== %s" % (rname,self.LA(1))
        self.traceDepth -= 1

    def uponEOF(self):
        pass

    def append(self,c):
        if self.saveConsumedInput :
            self.text.append(c)

    def commit(self):
        self.inputState.input.commit()

    def consume(self):
        if not self.inputState.guessing:
            c = self.LA(1)
            if self.caseSensitive:
                self.append(c)
            else:
                # use input.LA(), not LA(), to get original case
                # CharScanner.LA() would toLower it.
                c =  self.inputState.input.LA(1)
                self.append(c)

            if c and c in "\t":
                self.tab()
            else:
                self.inputState.column += 1
        self.inputState.input.consume()

    ## Consume chars until one matches the given char
    def consumeUntil_char(self,c):
        while self.LA(1) != EOF_CHAR and self.LA(1) != c:
            self.consume()

    ## Consume chars until one matches the given set
    def consumeUntil_bitset(self,bitset):
        while self.LA(1) != EOF_CHAR and not self.set.member(self.LA(1)):
            self.consume()

    ### If symbol seen is EOF then generate and set token, otherwise
    ### throw exception.
    def default(self,la1):
        if not la1 :
            self.uponEOF()
            self._returnToken = self.makeToken(EOF_TYPE)
        else:
            self.raise_NoViableAlt(la1)

    def filterdefault(self,la1,*args):
        if not la1:
            self.uponEOF()
            self._returnToken = self.makeToken(EOF_TYPE)
            return

        if not args:
            self.consume()
            raise TryAgain()
        else:
            ### apply filter object
            self.commit();
            try:
                func=args[0]
                args=args[1:]
                apply(func,args)
            except RecognitionException, e:
                ## catastrophic failure
                self.reportError(e);
                self.consume();
            raise TryAgain()

    def raise_NoViableAlt(self,la1=None):
        if not la1: la1 = self.LA(1)
        fname = self.getFilename()
        line  = self.getLine()
        col   = self.getColumn()
        raise NoViableAltForCharException(la1,fname,line,col)

    def set_return_token(self,_create,_token,_ttype,_offset):
        if _create and not _token and (not _ttype == SKIP):
            string = self.text.getString(_offset)
            _token = self.makeToken(_ttype)
            _token.setText(string)
        self._returnToken = _token
        return _token

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                   CharScannerIterator                          ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class CharScannerIterator:

    def __init__(self,inst):
        if isinstance(inst,CharScanner):
            self.inst = inst
            return
        raise TypeError("CharScannerIterator requires CharScanner object")

    def next(self):
        assert self.inst
        item = self.inst.nextToken()
        if not item or item.isEOF():
            raise StopIteration()
        return item

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       BitSet                                   ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

### I'm assuming here that a long is 64bits. It appears however, that
### a long is of any size. That means we can use a single long as the
### bitset (!), ie. Python would do almost all the work (TBD).

class BitSet(object):
    BITS     = 64
    NIBBLE   = 4
    LOG_BITS = 6
    MOD_MASK = BITS -1

    def __init__(self,data=None):
        if not data:
            BitSet.__init__(self,[long(0)])
            return
        if isinstance(data,int):
            BitSet.__init__(self,[long(data)])
            return
        if isinstance(data,long):
            BitSet.__init__(self,[data])
            return
        if not isinstance(data,list):
            raise TypeError("BitSet requires integer, long, or " +
                            "list argument")
        for x in data:
            if not isinstance(x,long):
                raise TypeError(self,"List argument item is " +
                                "not a long: %s" % (x))
        self.data = data

    def __str__(self):
        bits = len(self.data) * BitSet.BITS
        s = ""
        for i in xrange(0,bits):
            if self.at(i):
                s += "1"
            else:
                s += "o"
            if not ((i+1) % 10):
                s += '|%s|' % (i+1)
        return s

    def __repr__(self):
        return str(self)

    def member(self,item):
        if not item:
            return False

        if isinstance(item,int):
            return self.at(item)

        if not is_string_type(item):
            raise TypeError(self,"char or unichar expected: %s" % (item))

        ## char is a (unicode) string with at most lenght 1, ie.
        ## a char.

        if len(item) != 1:
            raise TypeError(self,"char expected: %s" % (item))

        ### handle ASCII/UNICODE char
        num = ord(item)

        ### check whether position num is in bitset
        return self.at(num)

    def wordNumber(self,bit):
        return bit >> BitSet.LOG_BITS

    def bitMask(self,bit):
        pos = bit & BitSet.MOD_MASK  ## bit mod BITS
        return (1L << pos)

    def set(self,bit,on=True):
        # grow bitset as required (use with care!)
        i = self.wordNumber(bit)
        mask = self.bitMask(bit)
        if i>=len(self.data):
            d = i - len(self.data) + 1
            for x in xrange(0,d):
                self.data.append(0L)
            assert len(self.data) == i+1
        if on:
            self.data[i] |=  mask
        else:
            self.data[i] &= (~mask)

    ### make add an alias for set
    add = set

    def off(self,bit,off=True):
        self.set(bit,not off)

    def at(self,bit):
        i = self.wordNumber(bit)
        v = self.data[i]
        m = self.bitMask(bit)
        return v & m


###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                      some further funcs                        ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

def illegalarg_ex(func):
    raise ValueError(
       "%s is only valid if parser is built for debugging" %
       (func.func_name))

def runtime_ex(func):
    raise RuntimeException(
       "%s is only valid if parser is built for debugging" %
       (func.func_name))

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       TokenBuffer                              ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class TokenBuffer(object):
    def __init__(self,stream):
        self.input = stream
        self.nMarkers = 0
        self.markerOffset = 0
        self.numToConsume = 0
        self.queue = Queue()

    def reset(self) :
        self.nMarkers = 0
        self.markerOffset = 0
        self.numToConsume = 0
        self.queue.reset()

    def consume(self) :
        self.numToConsume += 1

    def fill(self, amount):
        self.syncConsume()
        while self.queue.length() < (amount + self.markerOffset):
            self.queue.append(self.input.nextToken())

    def getInput(self):
        return self.input

    def LA(self,k) :
        self.fill(k)
        return self.queue.elementAt(self.markerOffset + k - 1).type

    def LT(self,k) :
        self.fill(k)
        return self.queue.elementAt(self.markerOffset + k - 1)

    def mark(self) :
        self.syncConsume()
        self.nMarkers += 1
        return self.markerOffset

    def rewind(self,mark) :
        self.syncConsume()
        self.markerOffset = mark
        self.nMarkers -= 1

    def syncConsume(self) :
        while self.numToConsume > 0:
            if self.nMarkers > 0:
                # guess mode -- leave leading characters and bump offset.
                self.markerOffset += 1
            else:
                # normal mode -- remove first character
                self.queue.removeFirst()
            self.numToConsume -= 1

    def __str__(self):
        return "(%s,%s,%s,%s,%s)" % (
           self.input,
           self.nMarkers,
           self.markerOffset,
           self.numToConsume,
           self.queue)

    def __repr__(self):
        return str(self)

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       ParserSharedInputState                   ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class ParserSharedInputState(object):

    def __init__(self):
        self.input = None
        self.reset()

    def reset(self):
        self.guessing = 0
        self.filename = None
        if self.input:
            self.input.reset()

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       Parser                                   ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class Parser(object):

    def __init__(self, *args, **kwargs):
        self.tokenNames = None
        self.returnAST  = None
        self.astFactory = None
        self.tokenTypeToASTClassMap = {}
        self.ignoreInvalidDebugCalls = False
        self.traceDepth = 0
        if not args:
            self.inputState = ParserSharedInputState()
            return
        arg0 = args[0]
        assert isinstance(arg0,ParserSharedInputState)
        self.inputState = arg0
        return

    def getTokenTypeToASTClassMap(self):
        return self.tokenTypeToASTClassMap


    def addMessageListener(self, l):
        if not self.ignoreInvalidDebugCalls:
            illegalarg_ex(addMessageListener)

    def addParserListener(self,l) :
        if (not self.ignoreInvalidDebugCalls) :
            illegalarg_ex(addParserListener)

    def addParserMatchListener(self, l) :
        if (not self.ignoreInvalidDebugCalls) :
            illegalarg_ex(addParserMatchListener)

    def addParserTokenListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            illegalarg_ex(addParserTokenListener)

    def addSemanticPredicateListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            illegalarg_ex(addSemanticPredicateListener)

    def addSyntacticPredicateListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            illegalarg_ex(addSyntacticPredicateListener)

    def addTraceListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            illegalarg_ex(addTraceListener)

    def consume(self):
        raise NotImplementedError()

    def _consumeUntil_type(self,tokenType):
        while self.LA(1) != EOF_TYPE and self.LA(1) != tokenType:
            self.consume()

    def _consumeUntil_bitset(self, set):
        while self.LA(1) != EOF_TYPE and not set.member(self.LA(1)):
            self.consume()

    def consumeUntil(self,arg):
        if isinstance(arg,int):
            self._consumeUntil_type(arg)
        else:
            self._consumeUntil_bitset(arg)

    def defaultDebuggingSetup(self):
        pass

    def getAST(self) :
        return self.returnAST

    def getASTFactory(self) :
        return self.astFactory

    def getFilename(self) :
        return self.inputState.filename

    def getInputState(self) :
        return self.inputState

    def setInputState(self, state) :
        self.inputState = state

    def getTokenName(self,num) :
        return self.tokenNames[num]

    def getTokenNames(self) :
        return self.tokenNames

    def isDebugMode(self) :
        return self.false

    def LA(self, i):
        raise NotImplementedError()

    def LT(self, i):
        raise NotImplementedError()

    def mark(self):
        return self.inputState.input.mark()

    def _match_int(self,t):
        if (self.LA(1) != t):
            raise MismatchedTokenException(
               self.tokenNames, self.LT(1), t, False, self.getFilename())
        else:
            self.consume()

    def _match_set(self, b):
        if (not b.member(self.LA(1))):
            raise MismatchedTokenException(
               self.tokenNames,self.LT(1), b, False, self.getFilename())
        else:
            self.consume()

    def match(self,set) :
        if isinstance(set,int):
            self._match_int(set)
            return
        if isinstance(set,BitSet):
            self._match_set(set)
            return
        raise TypeError("Parser.match requires integer ot BitSet argument")

    def matchNot(self,t):
        if self.LA(1) == t:
            raise MismatchedTokenException(
               tokenNames, self.LT(1), t, True, self.getFilename())
        else:
            self.consume()

    def removeMessageListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            runtime_ex(removeMessageListener)

    def removeParserListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            runtime_ex(removeParserListener)

    def removeParserMatchListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            runtime_ex(removeParserMatchListener)

    def removeParserTokenListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            runtime_ex(removeParserTokenListener)

    def removeSemanticPredicateListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            runtime_ex(removeSemanticPredicateListener)

    def removeSyntacticPredicateListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            runtime_ex(removeSyntacticPredicateListener)

    def removeTraceListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            runtime_ex(removeTraceListener)

    def reportError(self,x) :
        fmt = "syntax error:"
        f = self.getFilename()
        if f:
            fmt = ("%s:" % f) + fmt
        if isinstance(x,Token):
            line = x.getColumn()
            col  = x.getLine()
            text = x.getText()
            fmt  = fmt + 'unexpected symbol at line %s (column %s) : "%s"'
            print >>sys.stderr, fmt % (line,col,text)
        else:
            print >>sys.stderr, fmt,str(x)

    def reportWarning(self,s):
        f = self.getFilename()
        if f:
            print "%s:warning: %s" % (f,str(x))
        else:
            print "warning: %s" % (str(x))

    def rewind(self, pos) :
        self.inputState.input.rewind(pos)

    def setASTFactory(self, f) :
        self.astFactory = f

    def setASTNodeClass(self, cl) :
        self.astFactory.setASTNodeType(cl)

    def setASTNodeType(self, nodeType) :
        self.setASTNodeClass(nodeType)

    def setDebugMode(self, debugMode) :
        if (not self.ignoreInvalidDebugCalls):
            runtime_ex(setDebugMode)

    def setFilename(self, f) :
        self.inputState.filename = f

    def setIgnoreInvalidDebugCalls(self, value) :
        self.ignoreInvalidDebugCalls = value

    def setTokenBuffer(self, t) :
        self.inputState.input = t

    def traceIndent(self):
        print " " * self.traceDepth

    def traceIn(self,rname):
        self.traceDepth += 1
        self.trace("> ", rname)

    def traceOut(self,rname):
        self.trace("< ", rname)
        self.traceDepth -= 1

    ### wh: moved from ASTFactory to Parser
    def addASTChild(self,currentAST, child):
        if not child:
            return
        if not currentAST.root:
            currentAST.root = child
        elif not currentAST.child:
            currentAST.root.setFirstChild(child)
        else:
            currentAST.child.setNextSibling(child)
        currentAST.child = child
        currentAST.advanceChildToEnd()

    ### wh: moved from ASTFactory to Parser
    def makeASTRoot(self,currentAST,root) :
        if root:
            ### Add the current root as a child of new root
            root.addChild(currentAST.root)
            ### The new current child is the last sibling of the old root
            currentAST.child = currentAST.root
            currentAST.advanceChildToEnd()
            ### Set the new root
            currentAST.root = root

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       LLkParser                                ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class LLkParser(Parser):

    def __init__(self, *args, **kwargs):
        try:
            arg1 = args[0]
        except:
            arg1 = 1

        if isinstance(arg1,int):
            super(LLkParser,self).__init__()
            self.k = arg1
            return

        if isinstance(arg1,ParserSharedInputState):
            super(LLkParser,self).__init__(arg1)
            self.set_k(1,*args)
            return

        if isinstance(arg1,TokenBuffer):
            super(LLkParser,self).__init__()
            self.setTokenBuffer(arg1)
            self.set_k(1,*args)
            return

        if isinstance(arg1,TokenStream):
            super(LLkParser,self).__init__()
            tokenBuf = TokenBuffer(arg1)
            self.setTokenBuffer(tokenBuf)
            self.set_k(1,*args)
            return

        ### unknown argument
        raise TypeError("LLkParser requires integer, " +
                        "ParserSharedInputStream or TokenStream argument")

    def consume(self):
        self.inputState.input.consume()

    def LA(self,i):
        return self.inputState.input.LA(i)

    def LT(self,i):
        return self.inputState.input.LT(i)

    def set_k(self,index,*args):
        try:
            self.k = args[index]
        except:
            self.k = 1

    def trace(self,ee,rname):
        print type(self)
        self.traceIndent()
        guess = ""
        if self.inputState.guessing > 0:
            guess = " [guessing]"
        print(ee + rname + guess)
        for i in xrange(1,self.k+1):
            if i != 1:
                print(", ")
            if self.LT(i) :
                v = self.LT(i).getText()
            else:
                v = "null"
            print "LA(%s) == %s" % (i,v)
        print("\n")

    def traceIn(self,rname):
        self.traceDepth += 1;
        self.trace("> ", rname);

    def traceOut(self,rname):
        self.trace("< ", rname);
        self.traceDepth -= 1;

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                    TreeParserSharedInputState                  ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class TreeParserSharedInputState(object):
    def __init__(self):
        self.guessing = 0

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       TreeParser                               ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class TreeParser(object):

    def __init__(self, *args, **kwargs):
        self.inputState = TreeParserSharedInputState()
        self._retTree   = None
        self.tokenNames = []
        self.returnAST  = None
        self.astFactory = ASTFactory()
        self.traceDepth = 0

    def getAST(self):
        return self.returnAST

    def getASTFactory(self):
        return self.astFactory

    def getTokenName(self,num) :
        return self.tokenNames[num]

    def getTokenNames(self):
        return self.tokenNames

    def match(self,t,set) :
        assert isinstance(set,int) or isinstance(set,BitSet)
        if not t or t == ASTNULL:
            raise MismatchedTokenException(self.getTokenNames(), t,set, False)

        if isinstance(set,int) and t.getType() != set:
            raise MismatchedTokenException(self.getTokenNames(), t,set, False)

        if isinstance(set,BitSet) and not set.member(t.getType):
            raise MismatchedTokenException(self.getTokenNames(), t,set, False)

    def matchNot(self,t, ttype) :
        if not t or (t == ASTNULL) or (t.getType() == ttype):
            raise MismatchedTokenException(getTokenNames(), t, ttype, True)

    def reportError(self,ex):
        print >>sys.stderr,"error:",ex

    def  reportWarning(self, s):
        print "warning:",s

    def setASTFactory(self,f):
        self.astFactory = f

    def setASTNodeType(self,nodeType):
        self.setASTNodeClass(nodeType)

    def setASTNodeClass(self,nodeType):
        self.astFactory.setASTNodeType(nodeType)

    def traceIndent(self):
        print " " * self.traceDepth

    def traceIn(self,rname,t):
        self.traceDepth += 1
        self.traceIndent()
        print("> " + rname + "(" +
              ifelse(t,str(t),"null") + ")" +
              ifelse(self.inputState.guessing>0,"[guessing]",""))

    def traceOut(self,rname,t):
        self.traceIndent()
        print("< " + rname + "(" +
              ifelse(t,str(t),"null") + ")" +
              ifelse(self.inputState.guessing>0,"[guessing]",""))
        self.traceDepth -= 1

    ### wh: moved from ASTFactory to TreeParser
    def addASTChild(self,currentAST, child):
        if not child:
            return
        if not currentAST.root:
            currentAST.root = child
        elif not currentAST.child:
            currentAST.root.setFirstChild(child)
        else:
            currentAST.child.setNextSibling(child)
        currentAST.child = child
        currentAST.advanceChildToEnd()

    ### wh: moved from ASTFactory to TreeParser
    def makeASTRoot(self,currentAST,root):
        if root:
            ### Add the current root as a child of new root
            root.addChild(currentAST.root)
            ### The new current child is the last sibling of the old root
            currentAST.child = currentAST.root
            currentAST.advanceChildToEnd()
            ### Set the new root
            currentAST.root = root

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###               funcs to work on trees                           ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

def rightmost(ast):
    if ast:
        while(ast.right):
            ast = ast.right
    return ast

def cmptree(s,t,partial):
    while(s and t):
        ### as a quick optimization, check roots first.
        if not s.equals(t):
            return False

        ### if roots match, do full list match test on children.
        if not cmptree(s.getFirstChild(),t.getFirstChild(),partial):
            return False

        s = s.getNextSibling()
        t = t.getNextSibling()

    r = ifelse(partial,not t,not s and not t)
    return r

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                          AST                                   ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class AST(object):
    def __init__(self):
        pass

    def addChild(self, c):
        pass

    def equals(self, t):
        return False

    def equalsList(self, t):
        return False

    def equalsListPartial(self, t):
        return False

    def equalsTree(self, t):
        return False

    def equalsTreePartial(self, t):
        return False

    def findAll(self, tree):
        return None

    def findAllPartial(self, subtree):
        return None

    def getFirstChild(self):
        return self

    def getNextSibling(self):
        return self

    def getText(self):
        return ""

    def getType(self):
        return INVALID_TYPE

    def getLine(self):
        return 0

    def getColumn(self):
        return 0

    def getNumberOfChildren(self):
        return 0

    def initialize(self, t, txt):
        pass

    def initialize(self, t):
        pass

    def setFirstChild(self, c):
        pass

    def setNextSibling(self, n):
        pass

    def setText(self, text):
        pass

    def setType(self, ttype):
        pass

    def toString(self):
        self.getText()

    __str__ = toString

    def toStringList(self):
        return self.getText()

    def toStringTree(self):
        return self.getText()

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       ASTNULLType                              ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

### There is only one instance of this class **/
class ASTNULLType(AST):
    def __init__(self):
        AST.__init__(self)
        pass

    def getText(self):
        return "<ASTNULL>"

    def getType(self):
        return NULL_TREE_LOOKAHEAD


###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       BaseAST                                  ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class BaseAST(AST):

    verboseStringConversion = False
    tokenNames = None

    def __init__(self):
        self.down  = None ## kid
        self.right = None ## sibling

    def addChild(self,node):
        if node:
            t = rightmost(self.down)
            if t:
                t.right = node
            else:
                assert not self.down
                self.down = node

    def getNumberOfChildren(self):
        t = self.down
        n = 0
        while t:
            n += 1
            t = t.right
        return n

    def doWorkForFindAll(self,v,target,partialMatch):
        sibling = self

        while sibling:
            c1 = partialMatch and sibling.equalsTreePartial(target)
            if c1:
                v.append(sibling)
            else:
                c2 = not partialMatch and sibling.equalsTree(target)
                if c2:
                    v.append(sibling)

            ### regardless of match or not, check any children for matches
            if sibling.getFirstChild():
                sibling.getFirstChild().doWorkForFindAll(v,target,partialMatch)

            sibling = sibling.getNextSibling()

    ### Is node t equal to 'self' in terms of token type and text?
    def equals(self,t):
        if not t:
            return False
        return self.getText() == t.getText() and self.getType() == t.getType()

    ### Is t an exact structural and equals() match of this tree.  The
    ### 'self' reference is considered the start of a sibling list.
    ###
    def equalsList(self, t):
        return cmptree(self, t, partial=False)

    ### Is 't' a subtree of this list?
    ### The siblings of the root are NOT ignored.
    ###
    def equalsListPartial(self,t):
        return cmptree(self,t,partial=True)

    ### Is tree rooted at 'self' equal to 't'?  The siblings
    ### of 'self' are ignored.
    ###
    def equalsTree(self, t):
        return self.equals(t) and \
               cmptree(self.getFirstChild(), t.getFirstChild(), partial=False)

    ### Is 't' a subtree of the tree rooted at 'self'?  The siblings
    ### of 'self' are ignored.
    ###
    def equalsTreePartial(self, t):
        if not t:
            return True
        return self.equals(t) and cmptree(
           self.getFirstChild(), t.getFirstChild(), partial=True)

    ### Walk the tree looking for all exact subtree matches.  Return
    ### an ASTEnumerator that lets the caller walk the list
    ### of subtree roots found herein.
    def findAll(self,target):
        roots = []

        ### the empty tree cannot result in an enumeration
        if not target:
            return None
        # find all matches recursively
        self.doWorkForFindAll(roots, target, False)
        return roots

    ### Walk the tree looking for all subtrees.  Return
    ###  an ASTEnumerator that lets the caller walk the list
    ###  of subtree roots found herein.
    def findAllPartial(self,sub):
        roots = []

        ### the empty tree cannot result in an enumeration
        if not sub:
            return None

        self.doWorkForFindAll(roots, sub, True)  ### find all matches recursively
        return roots

    ### Get the first child of this node None if not children
    def getFirstChild(self):
        return self.down

    ### Get the next sibling in line after this one
    def getNextSibling(self):
        return self.right

    ### Get the token text for this node
    def getText(self):
        return ""

    ### Get the token type for this node
    def getType(self):
        return 0

    def getLine(self):
        return 0

    def getColumn(self):
        return 0

    ### Remove all children */
    def removeChildren(self):
        self.down = None

    def setFirstChild(self,c):
        self.down = c

    def setNextSibling(self, n):
        self.right = n

    ### Set the token text for this node
    def setText(self, text):
        pass

    ### Set the token type for this node
    def setType(self, ttype):
        pass

    ### static
    def setVerboseStringConversion(verbose,names):
        verboseStringConversion = verbose
        tokenNames = names
    setVerboseStringConversion = staticmethod(setVerboseStringConversion)

    ### Return an array of strings that maps token ID to it's text.
    ##  @since 2.7.3
    def getTokenNames():
        return tokenNames

    def toString(self):
        return self.getText()

    ### return tree as lisp string - sibling included
    def toStringList(self):
        ts = self.toStringTree()
        sib = self.getNextSibling()
        if sib:
            ts += sib.toStringList()
        return ts

    __str__ = toStringList

    ### return tree as string - siblings ignored
    def toStringTree(self):
        ts = ""
        kid = self.getFirstChild()
        if kid:
            ts += " ("
        ts += " " + self.toString()
        if kid:
            ts += kid.toStringList()
            ts += " )"
        return ts

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       CommonAST                                ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

### Common AST node implementation
class CommonAST(BaseAST):
    def __init__(self,token=None):
        super(CommonAST,self).__init__()
        self.ttype = INVALID_TYPE
        self.text  = "<no text>"
        self.line  = 0
        self.column= 0
        self.initialize(token)
        #assert self.text

    ### Get the token text for this node
    def getText(self):
        return self.text

    ### Get the token type for this node
    def getType(self):
        return self.ttype

    ### Get the line for this node
    def getLine(self):
        return self.line

    ### Get the column for this node
    def getColumn(self):
        return self.column

    def initialize(self,*args):
        if not args:
            return

        arg0 = args[0]

        if isinstance(arg0,int):
            arg1 = args[1]
            self.setType(arg0)
            self.setText(arg1)
            return

        if isinstance(arg0,AST) or isinstance(arg0,Token):
            self.setText(arg0.getText())
            self.setType(arg0.getType())
            self.line = arg0.getLine()
            self.column = arg0.getColumn()
            return

    ### Set the token text for this node
    def setText(self,text_):
        assert is_string_type(text_)
        self.text = text_

    ### Set the token type for this node
    def setType(self,ttype_):
        assert isinstance(ttype_,int)
        self.ttype = ttype_

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                     CommonASTWithHiddenTokens                  ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class CommonASTWithHiddenTokens(CommonAST):

    def __init__(self,*args):
        CommonAST.__init__(self,*args)
        self.hiddenBefore = None
        self.hiddenAfter  = None

    def getHiddenAfter(self):
        return self.hiddenAfter

    def getHiddenBefore(self):
        return self.hiddenBefore

    def initialize(self,*args):
        CommonAST.initialize(self,*args)
        if args and isinstance(args[0],Token):
            assert isinstance(args[0],CommonHiddenStreamToken)
            self.hiddenBefore = args[0].getHiddenBefore()
            self.hiddenAfter  = args[0].getHiddenAfter()

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       ASTPair                                  ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class ASTPair(object):
    def __init__(self):
        self.root = None          ### current root of tree
        self.child = None         ### current child to which siblings are added

    ### Make sure that child is the last sibling */
    def advanceChildToEnd(self):
        if self.child:
            while self.child.getNextSibling():
                self.child = self.child.getNextSibling()

    ### Copy an ASTPair.  Don't call it clone() because we want type-safety */
    def copy(self):
        tmp = ASTPair()
        tmp.root = self.root
        tmp.child = self.child
        return tmp

    def toString(self):
        r = ifelse(not root,"null",self.root.getText())
        c = ifelse(not child,"null",self.child.getText())
        return "[%s,%s]" % (r,c)

    __str__ = toString
    __repr__ = toString


###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       ASTFactory                               ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class ASTFactory(object):
    def __init__(self,table=None):
        self._class = None
        self._classmap = ifelse(table,table,None)

    def create(self,*args):
        if not args:
            return self.create(INVALID_TYPE)

        arg0 = args[0]
        arg1 = None
        arg2 = None

        try:
            arg1 = args[1]
            arg2 = args[2]
        except:
            pass

        # ctor(int)
        if isinstance(arg0,int) and not arg2:
            ### get class for 'self' type
            c = self.getASTNodeType(arg0)
            t = self.create(c)
            if t:
                t.initialize(arg0, ifelse(arg1,arg1,""))
            return t

        # ctor(int,something)
        if isinstance(arg0,int) and arg2:
            t = self.create(arg2)
            if t:
                t.initialize(arg0,arg1)
            return t

        # ctor(AST)
        if isinstance(arg0,AST):
            t = self.create(arg0.getType())
            if t:
                t.initialize(arg0)
            return t

        # ctor(token)
        if isinstance(arg0,Token) and not arg1:
            ttype = arg0.getType()
            assert isinstance(ttype,int)
            t = self.create(ttype)
            if t:
                t.initialize(arg0)
            return t

        # ctor(token,class)
        if isinstance(arg0,Token) and arg1:
            assert isinstance(arg1,type)
            assert issubclass(arg1,AST)
            # this creates instance of 'arg1' using 'arg0' as
            # argument. Wow, that's magic!
            t = arg1(arg0)
            assert t and isinstance(t,AST)
            return t

        # ctor(class)
        if isinstance(arg0,type):
            ### next statement creates instance of type (!)
            t = arg0()
            assert isinstance(t,AST)
            return t


    def setASTNodeClass(self,className=None):
        if not className:
            return
        assert isinstance(className,type)
        assert issubclass(className,AST)
        self._class = className

    ### kind of misnomer - use setASTNodeClass instead.
    setASTNodeType = setASTNodeClass

    def getASTNodeClass(self):
        return self._class



    def getTokenTypeToASTClassMap(self):
        return self._classmap

    def setTokenTypeToASTClassMap(self,amap):
        self._classmap = amap

    def error(self, e):
        import sys
        print >> sys.stderr, e

    def setTokenTypeASTNodeType(self, tokenType, className):
        """
        Specify a mapping between a token type and a (AST) class.
        """
        if not self._classmap:
            self._classmap = {}

        if not className:
            try:
                del self._classmap[tokenType]
            except:
                pass
        else:
            ### here we should also perform actions to ensure that
            ### a. class can be loaded
            ### b. class is a subclass of AST
            ###
            assert isinstance(className,type)
            assert issubclass(className,AST)  ## a & b
            ### enter the class
            self._classmap[tokenType] = className

    def getASTNodeType(self,tokenType):
        """
        For a given token type return the AST node type. First we
        lookup a mapping table, second we try _class
        and finally we resolve to "antlr.CommonAST".
        """

        # first
        if self._classmap:
            try:
                c = self._classmap[tokenType]
                if c:
                    return c
            except:
                pass
        # second
        if self._class:
            return self._class

        # default
        return CommonAST

    ### methods that have been moved to file scope - just listed
    ### here to be somewhat consistent with original API
    def dup(self,t):
        return antlr.dup(t,self)

    def dupList(self,t):
        return antlr.dupList(t,self)

    def dupTree(self,t):
        return antlr.dupTree(t,self)

    ### methods moved to other classes
    ### 1. makeASTRoot  -> Parser
    ### 2. addASTChild  -> Parser

    ### non-standard: create alias for longish method name
    maptype = setTokenTypeASTNodeType

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       ASTVisitor                               ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class ASTVisitor(object):
    def __init__(self,*args):
        pass

    def visit(self,ast):
        pass

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###               static methods and variables                     ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

ASTNULL = ASTNULLType()

### wh: moved from ASTFactory as there's nothing ASTFactory-specific
### in this method.
def make(*nodes):
    if not nodes:
        return None

    for i in xrange(0,len(nodes)):
        node = nodes[i]
        if node:
            assert isinstance(node,AST)

    root = nodes[0]
    tail = None
    if root:
        root.setFirstChild(None)

    for i in xrange(1,len(nodes)):
        if not nodes[i]:
            continue
        if not root:
            root = tail = nodes[i]
        elif not tail:
            root.setFirstChild(nodes[i])
            tail = root.getFirstChild()
        else:
            tail.setNextSibling(nodes[i])
            tail = tail.getNextSibling()

        ### Chase tail to last sibling
        while tail.getNextSibling():
            tail = tail.getNextSibling()
    return root

def dup(t,factory):
    if not t:
        return None

    if factory:
        dup_t = factory.create(t.__class__)
    else:
        raise TypeError("dup function requires ASTFactory argument")
    dup_t.initialize(t)
    return dup_t

def dupList(t,factory):
    result = dupTree(t,factory)
    nt = result
    while t:
        ## for each sibling of the root
        t = t.getNextSibling()
        nt.setNextSibling(dupTree(t,factory))
        nt = nt.getNextSibling()
    return result

def dupTree(t,factory):
    result = dup(t,factory)
    if t:
        result.setFirstChild(dupList(t.getFirstChild(),factory))
    return result

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
### $Id: antlr.py 3750 2009-02-13 00:13:04Z sjmachin $

# Local Variables:    ***
# mode: python        ***
# py-indent-offset: 4 ***
# End:                ***

########NEW FILE########
__FILENAME__ = BIFFRecords
# -*- coding: cp1252 -*-
from struct import pack
from UnicodeUtils import upack1, upack2
import sys

class SharedStringTable(object):
    _SST_ID = 0x00FC
    _CONTINUE_ID = 0x003C

    def __init__(self, encoding):
        self.encoding = encoding
        self._str_indexes = {}
        self._tally = []
        self._add_calls = 0
        # Following 3 attrs are used for temporary storage in the
        # get_biff_record() method and methods called by it. The pseudo-
        # initialisation here is for documentation purposes only.
        self._sst_record = None
        self._continues = None
        self._current_piece = None

    def add_str(self, s):
        if self.encoding != 'ascii' and not isinstance(s, unicode):
            s = unicode(s, self.encoding)
        self._add_calls += 1
        if s not in self._str_indexes:
            idx = len(self._str_indexes)
            self._str_indexes[s] = idx
            self._tally.append(1)
        else:
            idx = self._str_indexes[s]
            self._tally[idx] += 1
        return idx

    def del_str(self, idx):
        # This is called when we are replacing the contents of a string cell.
        assert self._tally[idx] > 0
        self._tally[idx] -= 1
        self._add_calls -= 1

    def str_index(self, s):
        return self._str_indexes[s]

    def get_biff_record(self):
        self._sst_record = ''
        self._continues = [None, None]
        self._current_piece = pack('<II', 0, 0)
        data = [(idx, s) for s, idx in self._str_indexes.iteritems()]
        data.sort() # in index order
        for idx, s in data:
            if self._tally[idx] == 0:
                s = u''
            self._add_to_sst(s)
        del data
        self._new_piece()
        self._continues[0] = pack('<2HII', self._SST_ID, len(self._sst_record), self._add_calls, len(self._str_indexes))
        self._continues[1] = self._sst_record[8:]
        self._sst_record = None
        self._current_piece = None
        result = ''.join(self._continues)
        self._continues = None
        return result


    def _add_to_sst(self, s):
        u_str = upack2(s, self.encoding)

        is_unicode_str = u_str[2] == '\x01'
        if is_unicode_str:
            atom_len = 5 # 2 byte -- len,
                         # 1 byte -- options,
                         # 2 byte -- 1st sym
        else:
            atom_len = 4 # 2 byte -- len,
                         # 1 byte -- options,
                         # 1 byte -- 1st sym

        self._save_atom(u_str[0:atom_len])
        self._save_splitted(u_str[atom_len:], is_unicode_str)

    def _new_piece(self):
        if self._sst_record == '':
            self._sst_record = self._current_piece
        else:
            curr_piece_len = len(self._current_piece)
            self._continues.append(pack('<2H%ds'%curr_piece_len, self._CONTINUE_ID, curr_piece_len, self._current_piece))
        self._current_piece = ''

    def _save_atom(self, s):
        atom_len = len(s)
        free_space = 0x2020 - len(self._current_piece)
        if free_space < atom_len:
            self._new_piece()
        self._current_piece += s

    def _save_splitted(self, s, is_unicode_str):
        i = 0
        str_len = len(s)
        while i < str_len:
            piece_len = len(self._current_piece)
            free_space = 0x2020 - piece_len
            tail_len = str_len - i
            need_more_space = free_space < tail_len

            if not need_more_space:
                atom_len = tail_len
            else:
                if is_unicode_str:
                    atom_len = free_space & 0xFFFE
                else:
                    atom_len = free_space

            self._current_piece += s[i:i+atom_len]

            if need_more_space:
                self._new_piece()
                if is_unicode_str:
                    self._current_piece += '\x01'
                else:
                    self._current_piece += '\x00'

            i += atom_len


class BiffRecord(object):

    _rec_data = '' # class attribute; child classes need to set this.

    # Sheer waste.
    # def __init__(self):
    #     self._rec_data = ''

    def get_rec_id(self):
        return _REC_ID

    def get_rec_header(self):
        return pack('<2H', self._REC_ID, len(self._rec_data))

    # Not over-ridden by any child classes, never called (except by "get"; see below).
    # def get_rec_data(self):
    #     return self._rec_data

    def get(self):
        # data = self.get_rec_data()
        data = self._rec_data

        if len(data) > 0x2020: # limit for BIFF7/8
            chunks = []
            pos = 0
            while pos < len(data):
                chunk_pos = pos + 0x2020
                chunk = data[pos:chunk_pos]
                chunks.append(chunk)
                pos = chunk_pos
            continues = pack('<2H', self._REC_ID, len(chunks[0])) + chunks[0]
            for chunk in chunks[1:]:
                continues += pack('<2H%ds'%len(chunk), 0x003C, len(chunk), chunk)
                # 0x003C -- CONTINUE record id
            return continues
        else:
            return self.get_rec_header() + data


class Biff8BOFRecord(BiffRecord):
    """
    Offset Size Contents
    0      2    Version, contains 0600H for BIFF8 and BIFF8X
    2      2    Type of the following data:
                  0005H = Workbook globals
                  0006H = Visual Basic module
                  0010H = Worksheet
                  0020H = Chart
                  0040H = Macro sheet
                  0100H = Workspace file
    4      2    Build identifier
    6      2    Build year
    8      4    File history flags
    12     4    Lowest Excel version that can read all records in this file
    """
    _REC_ID      = 0x0809
    # stream types
    BOOK_GLOBAL = 0x0005
    VB_MODULE   = 0x0006
    WORKSHEET   = 0x0010
    CHART       = 0x0020
    MACROSHEET  = 0x0040
    WORKSPACE   = 0x0100

    def __init__(self, rec_type):
        version  = 0x0600
        build    = 0x0DBB
        year     = 0x07CC
        file_hist_flags = 0x00L
        ver_can_read    = 0x06L

        self._rec_data = pack('<4H2I', version, rec_type, build, year, file_hist_flags, ver_can_read)


class InteraceHdrRecord(BiffRecord):
    _REC_ID = 0x00E1

    def __init__(self):
        self._rec_data = pack('BB', 0xB0, 0x04)


class InteraceEndRecord(BiffRecord):
    _REC_ID = 0x00E2

    def __init__(self):
        self._rec_data = ''


class MMSRecord(BiffRecord):
    _REC_ID = 0x00C1

    def __init__(self):
        self._rec_data = pack('<H', 0x00)


class WriteAccessRecord(BiffRecord):
    """
    This record is part of the file protection. It contains the name of the
    user  that  has  saved  the  file. The user name is always stored as an
    equal-sized  string.  All  unused  characters after the name are filled
    with space characters. It is not required to write the mentioned string
    length. Every other length will be accepted too.
    """
    _REC_ID = 0x005C

    def __init__(self, owner):
        uowner = owner[0:0x30]
        uowner_len = len(uowner)
        self._rec_data = pack('%ds%ds' % (uowner_len, 0x70 - uowner_len), uowner, ' '*(0x70 - uowner_len))


class DSFRecord(BiffRecord):
    """
    This  record  specifies  if the file contains an additional BIFF5/BIFF7
    workbook stream.
    Record DSF, BIFF8:
    Offset Size Contents
    0        2     0 = Only the BIFF8 Workbook stream is present
                   1 = Additional BIFF5/BIFF7 Book stream is in the file
    A  double  stream file can be read by Excel 5.0 and Excel 95, and still
    contains  all  new  features  added to BIFF8 (which are left out in the
    BIFF5/BIFF7 Book stream).
    """
    _REC_ID = 0x0161

    def __init__(self):
        self._rec_data = pack('<H', 0x00)


class TabIDRecord(BiffRecord):
    _REC_ID = 0x013D

    def __init__(self, sheetcount):
        for i in range(sheetcount):
            self._rec_data += pack('<H', i+1)


class FnGroupCountRecord(BiffRecord):
    _REC_ID = 0x009C

    def __init__(self):
        self._rec_data = pack('BB', 0x0E, 0x00)


class WindowProtectRecord(BiffRecord):
    """
    This record is part of the worksheet/workbook protection. It determines
    whether  the window configuration of this document is protected. Window
    protection is not active, if this record is omitted.
    """
    _REC_ID = 0x0019

    def __init__(self, wndprotect):
        self._rec_data = pack('<H', wndprotect)


class ObjectProtectRecord(BiffRecord):
    """
    This record is part of the worksheet/workbook protection.
    It determines whether the objects of the current sheet are protected.
    Object protection is not active, if this record is omitted.
    """
    _REC_ID = 0x0063


    def __init__(self, objprotect):
        self._rec_data = pack('<H', objprotect)


class ScenProtectRecord(BiffRecord):
    """
    This record is part of the worksheet/workbook protection. It
    determines whether the scenarios of the current sheet are protected.
    Scenario protection is not active, if this record is omitted.
    """
    _REC_ID = 0x00DD


    def __init__(self, scenprotect):
        self._rec_data = pack('<H', scenprotect)


class ProtectRecord(BiffRecord):
    """
    This  record is part of the worksheet/workbook protection. It specifies
    whether  a  worksheet  or a workbook is protected against modification.
    Protection is not active, if this record is omitted.
    """

    _REC_ID = 0x0012

    def __init__(self, protect):
        self._rec_data = pack('<H', protect)


class PasswordRecord(BiffRecord):
    """
    This record is part of the worksheet/workbook protection. It
    stores a 16-bit hash value, calculated from the worksheet or workbook
    protection password.
    """
    _REC_ID = 0x0013
    def passwd_hash(self, plaintext):
        """
        Based on the algorithm provided by Daniel Rentz of OpenOffice.
        """
        if plaintext == "":
            return 0

        passwd_hash = 0x0000
        for i, char in enumerate(plaintext):
            c = ord(char) << (i + 1)
            low_15 = c & 0x7fff
            high_15 = c & 0x7fff << 15
            high_15 = high_15 >> 15
            c = low_15 | high_15
            passwd_hash ^= c
        passwd_hash ^= len(plaintext)
        passwd_hash ^= 0xCE4B
        return passwd_hash

    def __init__(self, passwd = ""):
        self._rec_data = pack('<H', self.passwd_hash(passwd))


class Prot4RevRecord(BiffRecord):
    _REC_ID = 0x01AF

    def __init__(self):
        self._rec_data = pack('<H', 0x00)


class Prot4RevPassRecord(BiffRecord):
    _REC_ID = 0x01BC

    def __init__(self):
        self._rec_data = pack('<H', 0x00)


class BackupRecord(BiffRecord):
    """
    This  record  contains  a Boolean value determining whether Excel makes
    a backup of the file while saving.
    """
    _REC_ID = 0x0040

    def __init__(self, backup):
        self._rec_data = pack('<H', backup)

class HideObjRecord(BiffRecord):
    """
    This record specifies whether and how to show objects in the workbook.

    Record HIDEOBJ, BIFF3-BIFF8:
    Offset  Size    Contents
    0       2       Viewing mode for objects:
                        0 = Show all objects
                        1 = Show placeholders
                        2 = Do not show objects
    """
    _REC_ID = 0x008D

    def __init__(self):
        self._rec_data = pack('<H', 0x00)



class RefreshAllRecord(BiffRecord):
    """
    """

    _REC_ID = 0x01B7

    def __init__(self):
        self._rec_data = pack('<H', 0x00)


class BookBoolRecord(BiffRecord):
    """
    This record contains a Boolean value determining whether to save values
    linked  from external workbooks (CRN records and XCT records). In BIFF3
    and BIFF4 this option is stored in the WSBOOL record.

    Record BOOKBOOL, BIFF5-BIFF8:

    Offset  Size    Contents
    0       2       0 = Save external linked values;
                    1 = Do not save external linked values
    """

    _REC_ID = 0x00DA

    def __init__(self):
        self._rec_data = pack('<H', 0x00)


class CountryRecord(BiffRecord):
    """
    This   record   stores  two  Windows  country  identifiers.  The  first
    represents  the  user  interface language of the Excel version that has
    saved  the file, and the second represents the system regional settings
    at the time the file was saved.

    Record COUNTRY, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       Windows country identifier of the user interface language of Excel
    2       2       Windows country identifier of the system regional settings

    The  following  table  shows most of the used country identifiers. Most
    of  these  identifiers  are  equal to the international country calling
    codes.

    1   USA
    2   Canada
    7   Russia
    """

    _REC_ID = 0x008C

    def __init__(self, ui_id, sys_settings_id):
        self._rec_data = pack('<2H', ui_id, sys_settings_id)


class UseSelfsRecord(BiffRecord):
    """
    This  record  specifies if the formulas in the workbook can use natural
    language  formulas.  This  type  of  formula can refer to cells by its
    content or the content of the column or row header cell.

    Record USESELFS, BIFF8:

    Offset  Size    Contents
    0       2       0 = Do not use natural language formulas
                    1 = Use natural language formulas

    """

    _REC_ID = 0x0160

    def __init__(self):
        self._rec_data = pack('<H', 0x01)


class EOFRecord(BiffRecord):
    _REC_ID = 0x000A

    def __init__(self):
        self._rec_data = ''


class DateModeRecord(BiffRecord):
    """
    This  record  specifies  the  base date for displaying date values. All
    dates  are  stored as count of days past this base date. In BIFF2-BIFF4
    this   record  is  part  of  the  Calculation  Settings  Block.
    In BIFF5-BIFF8 it is stored in the Workbook Globals Substream.

    Record DATEMODE, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       0 = Base is 1899-Dec-31 (the cell = 1 represents 1900-Jan-01)
                    1 = Base is 1904-Jan-01 (the cell = 1 represents 1904-Jan-02)
    """
    _REC_ID = 0x0022

    def __init__(self, from1904):
        if from1904:
            self._rec_data = pack('<H', 1)
        else:
            self._rec_data = pack('<H', 0)


class PrecisionRecord(BiffRecord):
    """
    This record stores if formulas use the real cell values for calculation
    or  the  values  displayed  on  the screen. In BIFF2- BIFF4 this record
    is  part of the Calculation Settings Block. In BIFF5-BIFF8 it is stored
    in the Workbook Globals Substream.

    Record PRECISION, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       0 = Use displayed values;
                    1 = Use real cell values
    """
    _REC_ID = 0x000E

    def __init__(self, use_real_values):
        if use_real_values:
            self._rec_data = pack('<H', 1)
        else:
            self._rec_data = pack('<H', 0)


class CodepageBiff8Record(BiffRecord):
    """
    This record stores the text encoding used to write byte strings, stored
    as MS Windows code page identifier. The CODEPAGE record in BIFF8 always
    contains  the  code  page  1200  (UTF-16).  Therefore  it is not
    possible  to  obtain the encoding used for a protection password (it is
    not UTF-16).

    Record CODEPAGE, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       Code page identifier used for byte string text encoding:
                      016FH = 367 = ASCII
                      01B5H = 437 = IBM PC CP-437 (US)
                      02D0H = 720 = IBM PC CP-720 (OEM Arabic)
                      02E1H = 737 = IBM PC CP-737 (Greek)
                      0307H = 775 = IBM PC CP-775 (Baltic)
                      0352H = 850 = IBM PC CP-850 (Latin I)
                      0354H = 852 = IBM PC CP-852 (Latin II (Central European))
                      0357H = 855 = IBM PC CP-855 (Cyrillic)
                      0359H = 857 = IBM PC CP-857 (Turkish)
                      035AH = 858 = IBM PC CP-858 (Multilingual Latin I with Euro)
                      035CH = 860 = IBM PC CP-860 (Portuguese)
                      035DH = 861 = IBM PC CP-861 (Icelandic)
                      035EH = 862 = IBM PC CP-862 (Hebrew)
                      035FH = 863 = IBM PC CP-863 (Canadian (French))
                      0360H = 864 = IBM PC CP-864 (Arabic)
                      0361H = 865 = IBM PC CP-865 (Nordic)
                      0362H = 866 = IBM PC CP-866 (Cyrillic (Russian))
                      0365H = 869 = IBM PC CP-869 (Greek (Modern))
                      036AH = 874 = Windows CP-874 (Thai)
                      03A4H = 932 = Windows CP-932 (Japanese Shift-JIS)
                      03A8H = 936 = Windows CP-936 (Chinese Simplified GBK)
                      03B5H = 949 = Windows CP-949 (Korean (Wansung))
                      03B6H = 950 = Windows CP-950 (Chinese Traditional BIG5)
                      04B0H = 1200 = UTF-16 (BIFF8)
                      04E2H = 1250 = Windows CP-1250 (Latin II) (Central European)
                      04E3H = 1251 = Windows CP-1251 (Cyrillic)
                      04E4H = 1252 = Windows CP-1252 (Latin I) (BIFF4-BIFF7)
                      04E5H = 1253 = Windows CP-1253 (Greek)
                      04E6H = 1254 = Windows CP-1254 (Turkish)
                      04E7H = 1255 = Windows CP-1255 (Hebrew)
                      04E8H = 1256 = Windows CP-1256 (Arabic)
                      04E9H = 1257 = Windows CP-1257 (Baltic)
                      04EAH = 1258 = Windows CP-1258 (Vietnamese)
                      0551H = 1361 = Windows CP-1361 (Korean (Johab))
                      2710H = 10000 = Apple Roman
                      8000H = 32768 = Apple Roman
                      8001H = 32769 = Windows CP-1252 (Latin I) (BIFF2-BIFF3)
    """
    _REC_ID = 0x0042
    UTF_16 = 0x04B0

    def __init__(self):
        self._rec_data = pack('<H', self.UTF_16)

class Window1Record(BiffRecord):
    """
    Offset Size Contents
    0      2    Horizontal position of the document window (in twips = 1/20 of a point)
    2      2    Vertical position of the document window (in twips = 1/20 of a point)
    4      2    Width of the document window (in twips = 1/20 of a point)
    6      2    Height of the document window (in twips = 1/20 of a point)
    8      2    Option flags:
                  Bits  Mask  Contents
                  0     0001H 0 = Window is visible 1 = Window is hidden
                  1     0002H 0 = Window is open 1 = Window is minimised
                  3     0008H 0 = Horizontal scroll bar hidden 1 = Horizontal scroll bar visible
                  4     0010H 0 = Vertical scroll bar hidden 1 = Vertical scroll bar visible
                  5     0020H 0 = Worksheet tab bar hidden 1 = Worksheet tab bar visible
    10     2    Index to active (displayed) worksheet
    12     2    Index of first visible tab in the worksheet tab bar
    14     2    Number of selected worksheets (highlighted in the worksheet tab bar)
    16     2    Width of worksheet tab bar (in 1/1000 of window width). The remaining space is used by the
                horizontal scrollbar.
    """
    _REC_ID = 0x003D
    # flags

    def __init__(self,
                 hpos_twips, vpos_twips,
                 width_twips, height_twips,
                 flags,
                 active_sheet,
                 first_tab_index, selected_tabs, tab_width):
        self._rec_data = pack('<9H', hpos_twips, vpos_twips,
                                      width_twips, height_twips,
                                      flags,
                                      active_sheet,
                                      first_tab_index, selected_tabs, tab_width)

class FontRecord(BiffRecord):
    """
    WARNING
        The font with index 4 is omitted in all BIFF versions.
        This means the first four fonts have zero-based indexes, and
        the fifth font and all following fonts are referenced with one-based
        indexes.

    Offset Size Contents
    0      2    Height of the font (in twips = 1/20 of a point)
    2      2    Option flags:
                  Bit Mask    Contents
                  0   0001H   1 = Characters are bold (redundant, see below)
                  1   0002H   1 = Characters are italic
                  2   0004H   1 = Characters are underlined (redundant, see below)
                  3   0008H   1 = Characters are struck out
                        0010H 1 = Outline
                        0020H  1 = Shadow
    4     2     Colour index
    6     2     Font weight (100-1000).
                Standard values are 0190H (400) for normal text and 02BCH
                (700) for bold text.
    8     2     Escapement type:
                  0000H = None
                  0001H = Superscript
                  0002H = Subscript
    10    1     Underline type:
                  00H = None
                  01H = Single
                  21H = Single accounting
                  02H = Double
                  22H = Double accounting
    11    1     Font family:
                  00H = None (unknown or don't care)
                  01H = Roman (variable width, serifed)
                  02H = Swiss (variable width, sans-serifed)
                  03H = Modern (fixed width, serifed or sans-serifed)
                  04H = Script (cursive)
                  05H = Decorative (specialised, i.e. Old English, Fraktur)
    12    1     Character set:
                  00H = 0 = ANSI Latin
                  01H = 1 = System default
                  02H = 2 = Symbol
                  4DH = 77 = Apple Roman
                  80H = 128 = ANSI Japanese Shift-JIS
                  81H = 129 = ANSI Korean (Hangul)
                  82H = 130 = ANSI Korean (Johab)
                  86H = 134 = ANSI Chinese Simplified GBK
                  88H = 136 = ANSI Chinese Traditional BIG5
                  A1H = 161 = ANSI Greek
                  A2H = 162 = ANSI Turkish
                  A3H = 163 = ANSI Vietnamese
                  B1H = 177 = ANSI Hebrew
                  B2H = 178 = ANSI Arabic
                  BAH = 186 = ANSI Baltic
                  CCH = 204 = ANSI Cyrillic
                  DEH = 222 = ANSI Thai
                  EEH = 238 = ANSI Latin II (Central European)
                  FFH = 255 = OEM Latin I
    13    1     Not used
    14    var.  Font name:
                  BIFF5/BIFF7: Byte string, 8-bit string length
                  BIFF8: Unicode string, 8-bit string length
    The boldness and underline flags are still set in the options field,
    but not used on reading the font. Font weight and underline type
    are specified in separate fields instead.
    """
    _REC_ID = 0x0031

    def __init__(self,
                    height, options, colour_index, weight, escapement,
                    underline, family, charset,
                    name):
        uname = upack1(name)
        uname_len = len(uname)

        self._rec_data = pack('<5H4B%ds' % uname_len, height, options, colour_index, weight, escapement,
                                                underline, family, charset, 0x00,
                                                uname)

class NumberFormatRecord(BiffRecord):
    """
    Record FORMAT, BIFF8:
    Offset  Size    Contents
    0       2       Format index used in other records
    2       var.    Number format string (Unicode string, 16-bit string length)

    From  BIFF5  on,  the built-in number formats will be omitted. The built-in
    formats  are  dependent  on  the current regional settings of the operating
    system.  The following table shows which number formats are used by default
    in  a  US-English  environment.  All indexes from 0 to 163 are reserved for
    built-in formats. The first user-defined format starts at 164.

    The built-in number formats, BIFF5-BIFF8

    Index   Type        Format string
    0       General     General
    1       Decimal     0
    2       Decimal     0.00
    3       Decimal     #,##0
    4       Decimal     #,##0.00
    5       Currency    "$"#,##0_);("$"#,##
    6       Currency    "$"#,##0_);[Red]("$"#,##
    7       Currency    "$"#,##0.00_);("$"#,##
    8       Currency    "$"#,##0.00_);[Red]("$"#,##
    9       Percent     0%
    10      Percent     0.00%
    11      Scientific  0.00E+00
    12      Fraction    # ?/?
    13      Fraction    # ??/??
    14      Date        M/D/YY
    15      Date        D-MMM-YY
    16      Date        D-MMM
    17      Date        MMM-YY
    18      Time        h:mm AM/PM
    19      Time        h:mm:ss AM/PM
    20      Time        h:mm
    21      Time        h:mm:ss
    22      Date/Time   M/D/YY h:mm
    37      Account     _(#,##0_);(#,##0)
    38      Account     _(#,##0_);[Red](#,##0)
    39      Account     _(#,##0.00_);(#,##0.00)
    40      Account     _(#,##0.00_);[Red](#,##0.00)
    41      Currency    _("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)
    42      Currency    _(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)
    43      Currency    _("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)
    44      Currency    _(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)
    45      Time        mm:ss
    46      Time        [h]:mm:ss
    47      Time        mm:ss.0
    48      Scientific  ##0.0E+0
    49      Text        @
    """
    _REC_ID = 0x041E

    def __init__(self, idx, fmtstr):
        ufmtstr = upack2(fmtstr)
        ufmtstr_len = len(ufmtstr)

        self._rec_data = pack('<H%ds' % ufmtstr_len, idx, ufmtstr)


class XFRecord(BiffRecord):
    """
    XF Substructures
    -------------------------------------------------------------------------
    XF_TYPE_PROT  XF Type and Cell Protection (3 Bits), BIFF3-BIFF8
    These 3 bits are part of a specific data byte.
    Bit Mask    Contents
    0   01H     1 = Cell is locked
    1   02H     1 = Formula is hidden
    2   04H     0 = Cell XF; 1 = Style XF

    XF_USED_ATTRIB   Attributes   Used  from  Parent  Style  XF  (6  Bits),
    BIFF3-BIFF8  Each  bit  describes  the  validity  of  a  specific group
    of  attributes.  In  cell XFs a cleared bit means the attributes of the
    parent  style XF are used (but only if the attributes are valid there),
    a  set  bit  means  the  attributes  of  this XF are used. In style XFs
    a cleared bit means the attribute setting is valid, a set bit means the
    attribute should be ignored.
    Bit Mask    Contents
    0   01H     Flag for number format
    1   02H     Flag for font
    2   04H     Flag for horizontal and vertical alignment, text wrap, indentation, orientation, rotation, and
                text direction
    3   08H     Flag for border lines
    4   10H     Flag for background area style
    5   20H     Flag for cell protection (cell locked and formula hidden)

    XF_HOR_ALIGN  Horizontal Alignment (3 Bits), BIFF2-BIFF8 The horizontal
    alignment consists of 3 bits and is part of a specific data byte.
    Value   Horizontal alignment
    00H     General
    01H     Left
    02H     Centred
    03H     Right
    04H     Filled
    05H     Justified (BIFF4-BIFF8X)
    06H     Centred across selection (BIFF4-BIFF8X)
    07H     Distributed (BIFF8X)

    XF_VERT_ALIGN Vertical Alignment (2 or 3 Bits), BIFF4-BIFF8
    The vertical alignment consists of 2 bits (BIFF4) or 3 bits (BIFF5-BIFF8)
    and is part of a specific data byte. Vertical alignment is not available
    in BIFF2 and BIFF3.
    Value   Vertical alignment
    00H     Top
    01H     Centred
    02H     Bottom
    03H     Justified (BIFF5-BIFF8X)
    04H     Distributed (BIFF8X)

    XF_ORIENTATION  Text  Orientation  (2  Bits),  BIFF4-BIFF7  In the BIFF
    versions  BIFF4-BIFF7,  text  can  be  rotated  in  steps of 90 degrees
    or  stacked.  The  orientation  mode  consists of 2 bits and is part of
    a specific data byte. In BIFF8 a rotation angle occurs instead of these
    flags.
    Value   Text orientation
    00H     Not rotated
    01H     Letters are stacked top-to-bottom, but not rotated
    02H     Text is rotated 90 degrees counterclockwise
    03H     Text is rotated 90 degrees clockwise

    XF_ROTATION Text Rotation Angle (1 Byte), BIFF8
    Value   Text rotation
    0       Not rotated
    1-90    1 to 90 degrees counterclockwise
    91-180  1 to 90 degrees clockwise
    255     Letters are stacked top-to-bottom, but not rotated

    XF_BORDER_34  Cell  Border  Style  (4  Bytes), BIFF3-BIFF4 Cell borders
    contain a line style and a line colour for each line of the border.
    Bit     Mask        Contents
    2-0     00000007H   Top line style
    7-3     000000F8H   Colour index for top line colour
    10-8    00000700H   Left line style
    15-11   0000F800H   Colour index for left line colour
    18-16   00070000H   Bottom line style
    23-19   00F80000H   Colour index for bottom line colour
    26-24   07000000H   Right line style
    31-27   F8000000H   Colour index for right line colour

    XF_AREA_34  Cell  Background  Area  Style (2 Bytes), BIFF3-BIFF4 A cell
    background  area  style  contains  an area pattern and a foreground and
    background colour.
    Bit     Mask    Contents
    5-0     003FH   Fill pattern
    10-6    07C0H   Colour index for pattern colour
    15-11   F800H   Colour index for pattern background
 ---------------------------------------------------------------------------------------------
    Record XF, BIFF8:
    Offset      Size    Contents
    0           2       Index to FONT record
    2           2       Index to FORMAT record
    4           2       Bit     Mask    Contents
                        2-0     0007H   XF_TYPE_PROT . XF type, cell protection (see above)
                        15-4    FFF0H   Index to parent style XF (always FFFH in style XFs)
    6           1       Bit     Mask    Contents
                        2-0     07H     XF_HOR_ALIGN . Horizontal alignment (see above)
                        3       08H     1 = Text is wrapped at right border
                        6-4     70H     XF_VERT_ALIGN . Vertical alignment (see above)
    7           1       XF_ROTATION: Text rotation angle (see above)
    8           1       Bit     Mask    Contents
                        3-0     0FH     Indent level
                        4       10H     1 = Shrink content to fit into cell
                        5               merge
                        7-6     C0H     Text direction (BIFF8X only)
                                        00b = According to context
                                        01b = Left-to-right
                                        10b = Right-to-left
    9           1       Bit     Mask    Contents
                        7-2     FCH     XF_USED_ATTRIB . Used attributes (see above)
    10          4       Cell border lines and background area:
                        Bit     Mask      Contents
                        3-0     0000000FH Left line style
                        7-4     000000F0H Right line style
                        11-8    00000F00H Top line style
                        15-12   0000F000H Bottom line style
                        22-16   007F0000H Colour index for left line colour
                        29-23   3F800000H Colour index for right line colour
                        30      40000000H 1 = Diagonal line from top left to right bottom
                        31      80000000H 1 = Diagonal line from bottom left to right top
    14          4       Bit     Mask      Contents
                        6-0     0000007FH Colour index for top line colour
                        13-7    00003F80H Colour index for bottom line colour
                        20-14   001FC000H Colour index for diagonal line colour
                        24-21   01E00000H Diagonal line style
                        31-26   FC000000H Fill pattern
    18          2       Bit     Mask    Contents
                        6-0     007FH   Colour index for pattern colour
                        13-7    3F80H   Colour index for pattern background

    """
    _REC_ID = 0x00E0

    def __init__(self, xf, xftype='cell'):
        font_xf_idx, fmt_str_xf_idx, alignment, borders, pattern, protection = xf
        fnt = pack('<H', font_xf_idx)
        fmt = pack('<H', fmt_str_xf_idx)
        if xftype == 'cell':
            prt = pack('<H',
                ((protection.cell_locked    & 0x01) << 0) |
                ((protection.formula_hidden & 0x01) << 1)
            )
        else:
            prt = pack('<H', 0xFFF5)
        aln = pack('B',
            ((alignment.horz & 0x07) << 0) |
            ((alignment.wrap & 0x01) << 3) |
            ((alignment.vert & 0x07) << 4)
        )
        rot = pack('B', alignment.rota)
        txt = pack('B',
            ((alignment.inde & 0x0F) << 0) |
            ((alignment.shri & 0x01) << 4) |
            ((alignment.merg & 0x01) << 5) |
            ((alignment.dire & 0x03) << 6)
        )
        if xftype == 'cell':
            used_attr = pack('B', 0xF8)
        else:
            used_attr = pack('B', 0xF4)

        if borders.left == borders.NO_LINE:
            borders.left_colour = 0x00
        if borders.right == borders.NO_LINE:
            borders.right_colour = 0x00
        if borders.top == borders.NO_LINE:
            borders.top_colour = 0x00
        if borders.bottom == borders.NO_LINE:
            borders.bottom_colour = 0x00
        if borders.diag == borders.NO_LINE:
            borders.diag_colour = 0x00
        brd1 = pack('<L',
            ((borders.left          & 0x0F) << 0 ) |
            ((borders.right         & 0x0F) << 4 ) |
            ((borders.top           & 0x0F) << 8 ) |
            ((borders.bottom        & 0x0F) << 12) |
            ((borders.left_colour   & 0x7F) << 16) |
            ((borders.right_colour  & 0x7F) << 23) |
            ((borders.need_diag1    & 0x01) << 30) |
            ((borders.need_diag2    & 0x01) << 31)
        )
        brd2 = pack('<L',
            ((borders.top_colour    & 0x7F) << 0 ) |
            ((borders.bottom_colour & 0x7F) << 7 ) |
            ((borders.diag_colour   & 0x7F) << 14) |
            ((borders.diag          & 0x0F) << 21) |
            ((pattern.pattern       & 0x3F) << 26)
        )
        pat = pack('<H',
            ((pattern.pattern_fore_colour & 0x7F) << 0 ) |
            ((pattern.pattern_back_colour & 0x7F) << 7 )
        )
        self._rec_data = fnt + fmt + prt + \
                        aln + rot + txt + used_attr + \
                        brd1 + brd2 + \
                        pat

class StyleRecord(BiffRecord):
    """
    STYLE record for user-defined cell styles, BIFF3-BIFF8:
    Offset  Size    Contents
    0       2       Bit     Mask    Contents
                    11-0    0FFFH   Index to style XF record
                    15      8000H   Always 0 for user-defined styles
    2       var.    BIFF2-BIFF7: Non-empty byte string, 8-bit string length
                    BIFF8: Non-empty Unicode string, 16-bit string length
    STYLE record for built-in cell styles, BIFF3-BIFF8:
    Offset  Size    Contents
    0       2       Bit     Mask    Contents
                    11-0    0FFFH   Index to style XF record
                    15      8000H   Always 1 for built-in styles
    2       1       Identifier of the built-in cell style:
                        00H = Normal
                        01H = RowLevel_lv (see next field)
                        02H = ColLevel_lv (see next field)
                        03H = Comma
                        04H = Currency
                        05H = Percent
                        06H = Comma [0] (BIFF4-BIFF8)
                        07H = Currency [0] (BIFF4-BIFF8)
                        08H = Hyperlink (BIFF8)
                        09H = Followed Hyperlink (BIFF8)
    3       1       Level for RowLevel or ColLevel style
                    (zero-based, lv), FFH otherwise
    The  RowLevel  and  ColLevel  styles specify the formatting of subtotal
    cells  in  a specific outline level. The level is specified by the last
    field  in the STYLE record. Valid values are 0-6 for the outline levels
    1-7.
    """
    _REC_ID = 0x0293

    def __init__(self):
        self._rec_data = pack('<HBB', 0x8000, 0x00, 0xFF)
        # TODO: implement user-defined styles???


class PaletteRecord(BiffRecord):
    """
    This  record  contains  the  definition  of  all  user-defined  colours
    available for cell and object formatting.

    Record PALETTE, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       Number of following colours (nm). Contains 16 in BIFF3-BIFF4 and 56 in BIFF5-BIFF8.
    2       4*nm    List of nm RGB colours

    The following table shows how colour indexes are used in other records:

    Colour index    Resulting colour or internal list index
    00H             Built-in Black (R = 00H, G = 00H, B = 00H)
    01H             Built-in White (R = FFH, G = FFH, B = FFH)
    02H             Built-in Red (R = FFH, G = 00H, B = 00H)
    03H             Built-in Green (R = 00H, G = FFH, B = 00H)
    04H             Built-in Blue (R = 00H, G = 00H, B = FFH)
    05H             Built-in Yellow (R = FFH, G = FFH, B = 00H)
    06H             Built-in Magenta (R = FFH, G = 00H, B = FFH)
    07H             Built-in Cyan (R = 00H, G = FFH, B = FFH)
    08H             First user-defined colour from the PALETTE record (entry 0 from record colour list)
    .........................

    17H (BIFF3-BIFF4) Last user-defined colour from the PALETTE record (entry 15 or 55 from record colour list)
    3FH (BIFF5-BIFF8)

    18H (BIFF3-BIFF4) System window text colour for border lines (used in records XF, CF, and
    40H (BIFF5-BIFF8) WINDOW2 (BIFF8 only))

    19H (BIFF3-BIFF4) System window background colour for pattern background (used in records XF, and CF)
    41H (BIFF5-BIFF8)

    43H             System face colour (dialogue background colour)
    4DH             System window text colour for chart border lines
    4EH             System window background colour for chart areas
    4FH             Automatic colour for chart border lines (seems to be always Black)
    50H             System ToolTip background colour (used in note objects)
    51H             System ToolTip text colour (used in note objects)
    7FFFH           System window text colour for fonts (used in records FONT, EFONT, and CF)

    """
    _REC_ID = 0x0092


class BoundSheetRecord(BiffRecord):
    """
    This  record  is  located  in  the workbook globals area and represents
    a  sheet  inside  of  the  workbook. For each sheet a BOUNDSHEET record
    is  written.  It  stores  the sheet name and a stream offset to the BOF
    record    within   the   workbook   stream.  The  record  is also known
    as BUNDLESHEET.

    Record BOUNDSHEET, BIFF5-BIFF8:
    Offset  Size    Contents
    0       4       Absolute stream position of the BOF record of the sheet represented by this record. This
                    field is never encrypted in protected files.
    4       1       Visibility:
                        00H = Visible
                        01H = Hidden
                        02H = Strong hidden
    5       1       Sheet type:
                        00H = Worksheet
                        02H = Chart
                        06H = Visual Basic module
    6       var.    Sheet name:
                        BIFF5/BIFF7: Byte string, 8-bit string length
                        BIFF8: Unicode string, 8-bit string length
    """
    _REC_ID = 0x0085

    def __init__(self, stream_pos, visibility, sheetname, encoding='ascii'):
        usheetname = upack1(sheetname, encoding)
        uusheetname_len = len(usheetname)

        self._rec_data = pack('<LBB%ds' % uusheetname_len, stream_pos, visibility, 0x00, usheetname)


class ContinueRecord(BiffRecord):
    """
    Whenever  the content of a record exceeds the given limits (see table),
    the  record  must  be  split.  Several  CONTINUE records containing the
    additional data are added after the parent record.

    BIFF version    Maximum data size of a record
    BIFF2-BIFF7     2080 bytes (2084 bytes including record header)
    BIFF8           8224 bytes (8228 bytes including record header) (0x2020)

    Record CONTINUE, BIFF2-BIFF8:
    Offset  Size    Contents
    0       var.    Data continuation of the previous record

    Unicode  strings  are  split in a special way. At the beginning of each
    CONTINUE  record  the option flags byte is repeated. Only the character
    size  flag  will  be set in this flags byte, the Rich-Text flag and the
    Far-East  flag  are set to zero. In each CONTINUE record it is possible
    that  the  character  size  changes  from  8-bit  characters  to 16-bit
    characters and vice versa.

    Never  a  Unicode  string  is  split  until  and  including  the  first
    character.  That means, all header fields (string length, option flags,
    optional Rich-Text size, and optional Far-East data size) and the first
    character  of  the string have to occur together in the leading record,
    or  have  to  be  moved completely into the CONTINUE record. Formatting
    runs cannot be split between their components (character index and FONT
    record  index).  If  a string is split between two formatting runs, the
    option flags field will not be repeated in the CONTINUE record.
    """
    _REC_ID = 0x003C


class SSTRecord(BiffRecord):
    """
    This  record  contains  a  list  of  all  strings  used anywhere in the
    workbook.  Each string occurs only once. The workbook uses indexes into
    the list to reference the strings.

    Record SST, BIFF8:
    Offset  Size    Contents
    0       4       Total number of strings in the workbook (see below)
    4       4       Number of following strings (nm)
    8       var.    List of nm Unicode strings, 16-bit string length

    The  first  field  of  the  SST  record  counts  the  total  occurrence
    of  strings  in  the  workbook.  For  instance,  the string AAA is used
    3  times  and  the string BBB is used 2 times. The first field contains
    5 and the second field contains 2, followed by the two strings.
    """
    _REC_ID = 0x00FC


class ExtSSTRecord(BiffRecord):
    """
    This  record  occurs  in  conjunction  with  the SST record. It is used
    by  Excel  to create a hash table with stream offsets to the SST record
    to optimise string search operations. Excel may not shorten this record
    if  strings  are deleted from the shared string table, so the last part
    might  contain  invalid  data. The stream indexes in this record divide
    the SST into portions containing a constant number of strings.

    Record EXTSST, BIFF8:

    Offset  Size    Contents
    0       2       Number of strings in a portion, this number is >=8
    2       var.    List of OFFSET structures for all portions. Each OFFSET contains the following data:
                        Offset Size Contents
                        0       4   Absolute stream position of first string of the portion
                        4       2   Position of first string of the portion inside of current record,
                                    including record header. This counter restarts at zero, if the SST
                                    record is continued with a CONTINUE record.
                        6       2   Not used
    """
    _REC_ID = 0x00FF

    def __init__(self, sst_stream_pos, str_placement, portions_len):
        extsst = {}
        abs_stream_pos = sst_stream_pos
        str_counter = 0
        portion_counter = 0
        while str_counter < len(str_placement):
            str_chunk_num, pos_in_chunk = str_placement[str_counter]
            if str_chunk_num <> portion_counter:
                portion_counter = str_chunk_num
                abs_stream_pos += portions_len[portion_counter-1]
                #print hex(abs_stream_pos)
            str_stream_pos = abs_stream_pos + pos_in_chunk + 4 # header
            extsst[str_counter] = (pos_in_chunk, str_stream_pos)
            str_counter += 1

        exsst_str_count_delta = max(8, len(str_placement)*8/0x2000) # maybe smth else?
        self._rec_data = pack('<H', exsst_str_count_delta)
        str_counter = 0
        while str_counter < len(str_placement):
            self._rec_data += pack('<IHH', extsst[str_counter][1], extsst[str_counter][0], 0)
            str_counter += exsst_str_count_delta

class DimensionsRecord(BiffRecord):
    """
    Record DIMENSIONS, BIFF8:

    Offset  Size    Contents
    0       4       Index to first used row
    4       4       Index to last used row, increased by 1
    8       2       Index to first used column
    10      2       Index to last used column, increased by 1
    12      2       Not used
    """
    _REC_ID = 0x0200
    def __init__(self, first_used_row, last_used_row, first_used_col, last_used_col):
        if first_used_row > last_used_row or first_used_col > last_used_col:
            # Special case: empty worksheet
            first_used_row = first_used_col = 0
            last_used_row = last_used_col = -1
        self._rec_data = pack('<2L3H',
            first_used_row, last_used_row + 1,
            first_used_col, last_used_col + 1,
            0x00)


class Window2Record(BiffRecord):
    """
    Record WINDOW2, BIFF8:

    Offset  Size Contents
    0       2 Option flags (see below)
    2       2 Index to first visible row
    4       2 Index to first visible column
    6       2 Colour index of grid line colour. Note that in BIFF2-BIFF7 an RGB colour is
                written instead.
    8       2 Not used
    10      2 Cached magnification factor in page break preview (in percent); 0 = Default (60%)
    12      2 Cached magnification factor in normal view (in percent); 0 = Default (100%)
    14      4 Not used

    In  BIFF8  this record stores used magnification factors for page break
    preview  and  normal  view.  These  values  are  used  to  restore  the
    magnification,  when the view is changed. The real magnification of the
    currently  active  view  is  stored  in the SCL record. The type of the
    active view is stored in the option flags field (see below).

     0 0001H 0 = Show formula results 1 = Show formulas
     1 0002H 0 = Do not show grid lines 1 = Show grid lines
     2 0004H 0 = Do not show sheet headers 1 = Show sheet headers
     3 0008H 0 = Panes are not frozen 1 = Panes are frozen (freeze)
     4 0010H 0 = Show zero values as empty cells 1 = Show zero values
     5 0020H 0 = Manual grid line colour 1 = Automatic grid line colour
     6 0040H 0 = Columns from left to right 1 = Columns from right to left
     7 0080H 0 = Do not show outline symbols 1 = Show outline symbols
     8 0100H 0 = Keep splits if pane freeze is removed 1 = Remove splits if pane freeze is removed
     9 0200H 0 = Sheet not selected 1 = Sheet selected (BIFF5-BIFF8)
    10 0400H 0 = Sheet not visible 1 = Sheet visible (BIFF5-BIFF8)
    11 0800H 0 = Show in normal view 1 = Show in page break preview (BIFF8)

    The freeze flag specifies, if a following PANE record describes unfrozen or frozen panes.

    *** This class appends the optional SCL record ***

    Record SCL, BIFF4-BIFF8:

    This record stores the magnification of the active view of the current worksheet.
    In BIFF8 this can be either the normal view or the page break preview.
    This is determined in the WINDOW2 record. The SCL record is part of the
    Sheet View Settings Block.

    Offset  Size    Contents
    0       2       Numerator of the view magnification fraction (num)
    2       2       Denumerator [denominator] of the view magnification fraction (den)
    The magnification is stored as reduced fraction. The magnification results from num/den.

    SJM note: Excel expresses (e.g.) 25% in reduced form i.e. 1/4. Reason unknown. This code
    writes 25/100, and Excel is happy with that.

    """
    _REC_ID = 0x023E

    def __init__(self, options, first_visible_row, first_visible_col,
        grid_colour, preview_magn, normal_magn, scl_magn):
        self._rec_data = pack('<7HL', options,
                                    first_visible_row, first_visible_col,
                                    grid_colour,
                                    0x00,
                                    preview_magn, normal_magn,
                                    0x00L)
        if scl_magn:
            self._scl_rec = pack('<4H', 0x00A0, 4, scl_magn, 100)
        else:
            self._scl_rec = ''

    def get(self):
        return self.get_rec_header() + self._rec_data + self._scl_rec


class PanesRecord(BiffRecord):
    """
    This record stores the position of window panes. It is part of the Sheet
    View Settings Block. If the sheet does not contain any splits, this
    record will not occur.
    A sheet can be split in two different ways, with unfrozen panes or with
    frozen panes. A flag in the WINDOW2 record specifies, if the panes are
    frozen, which affects the contents of this record.

    Record PANE, BIFF2-BIFF8:
    Offset      Size        Contents
    0           2           Position of the vertical split
                            (px, 0 = No vertical split):
                            Unfrozen pane: Width of the left pane(s)
                            (in twips = 1/20 of a point)
                            Frozen pane: Number of visible
                            columns in left pane(s)
    2           2           Position of the horizontal split
                            (py, 0 = No horizontal split):
                            Unfrozen pane: Height of the top pane(s)
                            (in twips = 1/20 of a point)
                            Frozen pane: Number of visible
                            rows in top pane(s)
    4           2           Index to first visible row
                            in bottom pane(s)
    6           2           Index to first visible column
                            in right pane(s)
    8           1           Identifier of pane with active
                            cell cursor
    [9]         1           Not used (BIFF5-BIFF8 only, not written
                            in BIFF2-BIFF4)

    If the panes are frozen, pane0 is always active, regardless
    of the cursor position. The correct identifiers for all possible
    combinations of visible panes are shown in the following pictures.

    px = 0, py = 0                  px = 0, py > 0
    --------------------------      ------------|-------------
    |                        |      |                        |
    |                        |      |           3            |
    |                        |      |                        |
    -           3            -      --------------------------
    |                        |      |                        |
    |                        |      |           2            |
    |                        |      |                        |
    --------------------------      ------------|-------------

    px > 0, py = 0                  px > 0, py > 0
    ------------|-------------      ------------|-------------
    |           |            |      |           |            |
    |           |            |      |     3     |      2     |
    |           |            |      |           |            |
    -     3     |      1     -      --------------------------
    |           |            |      |           |            |
    |           |            |      |     1     |      0     |
    |           |            |      |           |            |
    ------------|-------------      ------------|-------------
    """
    _REC_ID = 0x0041
    def __init__(self, px, py, first_row_bottom, first_col_right, active_pane):
        self._rec_data = pack('<5H',
                                            px, py,
                                            first_row_bottom, first_col_right,
                                            active_pane)


class RowRecord(BiffRecord):
    """
    This  record  contains  the properties of a single row in a sheet. Rows
    and cells in a sheet are divided into blocks of 32 rows.

    Record ROW, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       Index of this row
    2       2       Index to column of the first cell which is described by a cell record
    4       2       Index to column of the last cell which is described by a cell record,
                    increased by 1
    6       2       Bit     Mask    Contents
                    14-0    7FFFH   Height of the row, in twips = 1/20 of a point
                    15      8000H   0 = Row has custom height; 1 = Row has default height
    8       2       Not used
    10      2       In BIFF3-BIFF4 this field contains a relative offset
                    to calculate stream position of the first cell record
                    for this row. In BIFF5-BIFF8 this field is not used
                    anymore, but the DBCELL record instead.
    12      4       Option flags and default row formatting:
                    Bit     Mask        Contents
                    2-0     00000007H   Outline level of the row
                    4       00000010H   1 = Outline group starts or ends here (depending
                                        on where the outline buttons are located,
                                        see WSBOOL record), and is collapsed
                    5       00000020H   1 = Row is hidden (manually, or by a filter or outline group)
                    6       00000040H   1 = Row height and default font height do not match
                    7       00000080H   1 = Row has explicit default format (fl)
                    8       00000100H   Always 1
                    27-16   0FFF0000H   If fl=1: Index to default XF record
                    28      10000000H   1 = Additional space above the row. This flag is set,
                                        if the upper border of at least one cell in this row
                                        or if the lower border of at least one cell in the row
                                        above is formatted with a thick line style.
                                        Thin and medium line styles are not taken into account.
                    29      20000000H   1 = Additional space below the row. This flag is set,
                                        if the lower border of at least one cell in this row
                                        or if the upper border of at least one cell in the row
                                        below is formatted with a medium or thick line style.
                                        Thin line styles are not taken into account.
    """

    _REC_ID = 0x0208

    def __init__(self, index, first_col, last_col, height_options, options):
        self._rec_data = pack('<6HL', index, first_col, last_col + 1,
                                        height_options,
                                        0x00, 0x00,
                                        options)

class LabelSSTRecord(BiffRecord):
    """
    This record represents a cell that contains a string. It replaces the
    LABEL record and RSTRING record used in BIFF2-BIFF7.
    """
    _REC_ID = 0x00FD

    def __init__(self, row, col, xf_idx, sst_idx):
        self._rec_data = pack('<3HL', row, col, xf_idx, sst_idx)


class MergedCellsRecord(BiffRecord):
    """
    This record contains all merged cell ranges of the current sheet.

    Record MERGEDCELLS, BIFF8:

    Offset  Size    Contents
    0       var.    Cell range address list with all merged ranges

    ------------------------------------------------------------------

    A cell range address list consists of a field with the number of ranges
    and the list of the range addresses.

    Cell range address list, BIFF8:

    Offset  Size            Contents
    0       2               Number of following cell range addresses (nm)
    2       8*nm            List of nm cell range addresses

    ---------------------------------------------------------------------
    Cell range address, BIFF8:

    Offset  Size    Contents
    0       2       Index to first row
    2       2       Index to last row
    4       2       Index to first column
    6       2       Index to last column

    """
    _REC_ID = 0x00E5

    def __init__(self, merged_list):
        i = len(merged_list) - 1
        while i >= 0:
            j = 0
            merged = ''
            while (i >= 0) and (j < 0x403):
                r1, r2, c1, c2 = merged_list[i]
                merged += pack('<4H', r1, r2, c1, c2)
                i -= 1
                j += 1
            self._rec_data += pack('<3H', self._REC_ID, len(merged) + 2, j) + \
                                    merged

    # for some reason Excel doesn't use CONTINUE
    def get(self):
        return self._rec_data

class MulBlankRecord(BiffRecord):
    """
    This  record  represents  a  cell  range  of empty cells. All cells are
    located in the same row.

    Record MULBLANK, BIFF5-BIFF8:

    Offset  Size    Contents
    0       2       Index to row
    2       2       Index to first column (fc)
    4       2*nc    List of nc=lc-fc+1 16-bit indexes to XF records
    4+2*nc  2       Index to last column (lc)
    """
    _REC_ID = 0x00BE

    def __init__(self, row, first_col, last_col, xf_index):
        blanks_count = last_col-first_col+1
        self._rec_data = pack('%dH' % blanks_count, *([xf_index]*blanks_count))
        self._rec_data = pack('<2H', row, first_col) +  self._rec_data + pack('<H',  last_col)


class BlankRecord(BiffRecord):
    """
    This  record  represents  an empty cell.

    Record BLANK, BIFF5-BIFF8:

    Offset  Size    Contents
    0       2       Index to row
    2       2       Index to first column (fc)
    4       2       indexes to XF record
    """
    _REC_ID = 0x0201

    def __init__(self, row, col, xf_index):
        self._rec_data = pack('<3H', row, col, xf_index)


class RKRecord(BiffRecord):
    """
    This record represents a cell that contains an RK value (encoded integer or
    floating-point value). If a floating-point value cannot be encoded to an RK value,
    a NUMBER record will be written.
    """
    _REC_ID = 0x027E

    def __init__(self, row, col, xf_index, rk_encoded):
        self._rec_data = pack('<3Hi', row, col, xf_index, rk_encoded)


class NumberRecord(BiffRecord):
    """
    This record represents a cell that contains an IEEE-754 floating-point value.
    """
    _REC_ID = 0x0203

    def __init__(self, row, col, xf_index, number):
        self._rec_data = pack('<3Hd', row, col, xf_index, number)

class BoolErrRecord(BiffRecord):
    """
    This record represents a cell that contains a boolean or error value.
    """
    _REC_ID = 0x0205

    def __init__(self, row, col, xf_index, number, is_error):
        self._rec_data = pack('<3HBB', row, col, xf_index, number, is_error)


class FormulaRecord(BiffRecord):
    """
    Offset Size Contents
    0      2    Index to row
    2      2    Index to column
    4      2    Index to XF record
    6      8    Result of the formula
    14     2    Option flags:
                Bit Mask    Contents
                0   0001H   1 = Recalculate always
                1   0002H   1 = Calculate on open
                3   0008H   1 = Part of a shared formula
    16     4    Not used
    20     var. Formula data (RPN token array)

    """
    _REC_ID = 0x0006

    def __init__(self, row, col, xf_index, rpn, calc_flags=0):
        self._rec_data = pack('<3HQHL', row, col, xf_index, 0xFFFF000000000003, calc_flags & 3, 0) + rpn


class GutsRecord(BiffRecord):
    """
    This record contains information about the layout of outline symbols.

    Record GUTS, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       Width of the area to display row outlines (left of the sheet), in pixel
    2       2       Height of the area to display column outlines (above the sheet), in pixel
    4       2       Number of visible row outline levels (used row levels + 1; or 0, if not used)
    6       2       Number of visible column outline levels (used column levels + 1; or 0, if not used)

    """

    _REC_ID = 0x0080

    def __init__(self, row_gut_width, col_gut_height, row_visible_levels, col_visible_levels):
        self._rec_data = pack('<4H', row_gut_width, col_gut_height, row_visible_levels, col_visible_levels)

class WSBoolRecord(BiffRecord):
    """
    This  record stores a 16 bit value with Boolean options for the current
    sheet.  From BIFF5 on the "Save external linked values" option is moved
    to the record BOOKBOOL.

    Option flags of record WSBOOL, BIFF3-BIFF8:

    Bit     Mask    Contents
    0       0001H   0 = Do not show automatic page breaks
                    1 = Show automatic page breaks
    4       0010H   0 = Standard sheet
                    1 = Dialogue sheet (BIFF5-BIFF8)
    5       0020H   0 = No automatic styles in outlines
                    1 = Apply automatic styles to outlines
    6       0040H   0 = Outline buttons above outline group
                    1 = Outline buttons below outline group
    7       0080H   0 = Outline buttons left of outline group
                    1 = Outline buttons right of outline group
    8       0100H   0 = Scale printout in percent
                    1 = Fit printout to number of pages
    9       0200H   0 = Save external linked values (BIFF3?BIFF4 only)
                    1 = Do not save external linked values (BIFF3?BIFF4 only)
    10      0400H   0 = Do not show row outline symbols
                    1 = Show row outline symbols
    11      0800H   0 = Do not show column outline symbols
                    1 = Show column outline symbols
    13-12   3000H   These flags specify the arrangement of windows.
                    They are stored in BIFF4 only.
                    00 = Arrange windows tiled
                    01 = Arrange windows horizontal
                    10 = Arrange windows vertical112 = Arrange windows cascaded
    The following flags are valid for BIFF4-BIFF8 only:
    14      4000H   0 = Standard expression evaluation
                    1 = Alternative expression evaluation
    15      8000H   0 = Standard formula entries
                    1 = Alternative formula entries

    """
    _REC_ID = 0x0081

    def __init__(self, options):
        self._rec_data = pack('<H', options)

class ColInfoRecord(BiffRecord):
    """
    This record specifies the width for a given range of columns.
    If a column does not have a corresponding COLINFO record,
    the width specified in the record STANDARDWIDTH is used. If
    this record is also not present, the contents of the record
    DEFCOLWIDTH is used instead.
    This record also specifies a default XF record to use for
    cells in the columns that are not described by any cell record
    (which contain the XF index for that cell). Additionally,
    the option flags field contains hidden, outline, and collapsed
    options applied at the columns.

    Record COLINFO, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       Index to first column in the range
    2       2       Index to last column in the range
    4       2       Width of the columns in 1/256 of the width of the zero character, using default font
                    (first FONT record in the file)
    6       2       Index to XF record for default column formatting
    8       2       Option flags:
                    Bits    Mask    Contents
                    0       0001H   1 = Columns are hidden
                    10-8    0700H   Outline level of the columns (0 = no outline)
                    12      1000H   1 = Columns are collapsed
    10      2       Not used

    """
    _REC_ID = 0x007D

    def __init__(self, first_col, last_col, width, xf_index, options):
        self._rec_data = pack('<6H', first_col, last_col, width, xf_index, options, 0)

class CalcModeRecord(BiffRecord):
    """
    This record is part of the Calculation Settings Block.
    It specifies whether to calculate formulas manually,
    automatically or automatically except for multiple table operations.

    Record CALCMODE, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       FFFFH = automatic except for multiple table operations
                    0000H = manually
                    0001H = automatically (default)
    """
    _REC_ID = 0x000D

    def __init__(self, calc_mode):
        self._rec_data = pack('<h', calc_mode)


class CalcCountRecord(BiffRecord):
    """
    This record is part of the Calculation Settings Block. It specifies the maximum
    number of times the formulas should be iteratively calculated. This is a fail-safe
    against mutually recursive formulas locking up a spreadsheet application.

    Record CALCCOUNT, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       Maximum number of iterations allowed in circular references
    """

    _REC_ID = 0x000C

    def __init__(self, calc_count):
        self._rec_data = pack('<H', calc_count)

class RefModeRecord(BiffRecord):
    """
    This record is part of the Calculation Settings Block.
    It stores which method is used to show cell addresses in formulas.
    The RC mode uses numeric indexes for rows and columns,
    i.e. R(1)C(-1), or R1C1:R2C2.
    The A1 mode uses characters for columns and numbers for rows,
    i.e. B1, or $A$1:$B$2.

    Record REFMODE, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       0 = RC mode; 1 = A1 mode

    """
    _REC_ID = 0x00F

    def __init__(self, ref_mode):
        self._rec_data = pack('<H', ref_mode)

class IterationRecord(BiffRecord):
    """
    This record is part of the Calculation Settings Block.
    It stores if iterations are allowed while calculating recursive formulas.

    Record ITERATION, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       0 = Iterations off; 1 = Iterations on
    """
    _REC_ID = 0x011

    def __init__(self, iterations_on):
        self._rec_data = pack('<H', iterations_on)

class DeltaRecord(BiffRecord):
    """
    This record is part of the Calculation Settings Block.
    It stores the maximum change of the result to exit an iteration.

    Record DELTA, BIFF2-BIFF8:

    Offset  Size    Contents
    0       8       Maximum change in iteration
                    (IEEE 754 floating-point value,
                     64bit double precision)
    """
    _REC_ID = 0x010

    def __init__(self, delta):
        self._rec_data = pack('<d', delta)

class SaveRecalcRecord(BiffRecord):
    """
    This record is part of the Calculation Settings Block.
    It contains the Recalculate before save option in
    Excel's calculation settings dialogue.

    Record SAVERECALC, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       0 = Do not recalculate;
                    1 = Recalculate before saving the document

    """
    _REC_ID = 0x05F

    def __init__(self, recalc):
        self._rec_data = pack('<H', recalc)

class PrintHeadersRecord(BiffRecord):
    """
    This record stores if the row and column headers
    (the areas with row numbers and column letters) will be printed.

    Record PRINTHEADERS, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       0 = Do not print row/column headers;
                    1 = Print row/column headers
    """
    _REC_ID = 0x02A

    def __init__(self, print_headers):
        self._rec_data = pack('<H', print_headers)


class PrintGridLinesRecord(BiffRecord):
    """
    This record stores if sheet grid lines will be printed.

    Record PRINTGRIDLINES, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       0 = Do not print sheet grid lines;
                    1 = Print sheet grid lines

    """
    _REC_ID = 0x02B

    def __init__(self, print_grid):
        self._rec_data = pack('<H', print_grid)


class GridSetRecord(BiffRecord):
    """
    This record specifies if the option to print sheet grid lines
    (record PRINTGRIDLINES) has ever been changed.

    Record GRIDSET, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       0 = Print grid lines option never changed
                    1 = Print grid lines option changed
    """
    _REC_ID = 0x082

    def __init__(self, print_grid_changed):
        self._rec_data = pack('<H', print_grid_changed)


class DefaultRowHeightRecord(BiffRecord):
    """
    This record specifies the default height and default flags
    for rows that do not have a corresponding ROW record.

    Record DEFAULTROWHEIGHT, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       Option flags:
                    Bit Mask    Contents
                    0   0001H   1 = Row height and default font height do not match
                    1   0002H   1 = Row is hidden
                    2   0004H   1 = Additional space above the row
                    3   0008H   1 = Additional space below the row
    2       2       Default height for unused rows, in twips = 1/20 of a point

    """
    _REC_ID = 0x0225

    def __init__(self, options, def_height):
        self._rec_data = pack('<2H', options, def_height)


class DefColWidthRecord(BiffRecord):
    """
    This record specifies the default column width for columns that
    do not have a specific width set using the record COLINFO or COLWIDTH.
    This record has no effect, if a STANDARDWIDTH record is present in the file.

    Record DEFCOLWIDTH, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       Column width in characters, using the width of the zero
                    character from default font (first FONT record in the file)
    """
    _REC_ID = 0x0055

    def __init__(self, def_width):
        self._rec_data = pack('<H', options, def_width)

class HorizontalPageBreaksRecord(BiffRecord):
    """
    This  record  is  part  of  the  Page  Settings  Block. It contains all
    horizontal manual page breaks.

    Record HORIZONTALPAGEBREAKS, BIFF8:
    Offset  Size  Contents
    0       2     Number of following row index structures (nm)
    2       6nm   List of nm row index structures. Each row index
                  structure contains:
                    Offset  Size    Contents
                    0       2       Index to first row below the page break
                    2       2       Index to first column of this page break
                    4       2       Index to last column of this page break

    The row indexes in the lists must be ordered ascending.
    If in BIFF8 a row contains several page breaks, they must be ordered
    ascending by start column index.
    """
    _REC_ID = 0x001B

    def __init__(self, breaks_list):
        self._rec_data = pack('<H', len(breaks_list))
        for r, c1, c2 in breaks_list:
            self._rec_data += pack('<3H', r, c1, c2)

class VerticalPageBreaksRecord(BiffRecord):
    """
    This  record  is  part  of  the  Page  Settings  Block. It contains all
    vertical manual page breaks.

    Record VERTICALPAGEBREAKS, BIFF8:
    Offset  Size  Contents
    0       2     Number of following column index structures (nm)
    2       6nm   List of nm column index structures. Each column index
                  structure contains:
                    Offset  Size    Contents
                    0       2       Index to first column following the page
                                    break
                    2       2       Index to first row of this page break
                    4       2       Index to last row of this page break

    The column indexes in the lists must be ordered ascending.
    If in BIFF8 a column contains several page breaks, they must be ordered
    ascending by start row index.
    """
    _REC_ID = 0x001A

    def __init__(self, breaks_list):
        self._rec_data = pack('<H', len(breaks_list))
        for r, c1, c2 in breaks_list:
            self._rec_data += pack('<3H', r, c1, c2)

class HeaderRecord(BiffRecord):
    """
    This record is part of the Page Settings Block. It specifies the
    page  header  string  for  the current worksheet. If this record is not
    present  or  completely  empty  (record  size is 0), the sheet does not
    contain a page header.

    Record HEADER for non-empty page header, BIFF2-BIFF8:
    Offset      Size    Contents
    0           var.    Page header string
                        BIFF2-BIFF7:    Non-empty byte string, 8bit string
                        length
                        BIFF8: Non-empty Unicode string, 16bit string length
    The  header  string may contain special commands, i.e. placeholders for
    the  page  number,  current  date, or text formatting attributes. These
    fields  are  represented  by  single  letters (exception: font name and
    size,  see  below)  with  a  leading  ampersand ("&"). If the ampersand
    is  part  of the regular header text, it will be duplicated ("&&"). The
    page  header is divided into 3 sections: the left, the centred, and the
    right  section.  Each  section  is introduced by a special command. All
    text  and all commands following are part of the selected section. Each
    section  starts  with the text formatting specified in the default font
    (first  FONT  record  in  the  file). Active formatting attributes from
    a previous section do not go into the next section.

    The following table shows all available commands:

    Command         Contents
    &&              The "&" character itself
    &L              Start of the left section
    &C              Start of the centred section
    &R              Start of the right section
    &P              Current page number
    &N              Page count
    &D              Current date
    &T              Current time
    &A              Sheet name (BIFF5-BIFF8)
    &F              File name without path
    &Z              File path without file name (BIFF8X)
    &G              Picture (BIFF8X)
    &B              Bold on/off (BIFF2-BIFF4)
    &I              Italic on/off (BIFF2-BIFF4)
    &U              Underlining on/off
    &E              Double underlining on/off (BIFF5-BIFF8)
    &S              Strikeout on/off
    &X              Superscript on/off (BIFF5-BIFF8)
    &Y              Subscript on/off (BIFF5-BIFF8)
    &"<fontname>"   Set new font <fontname>
    &"<fontname>,<fontstyle>"
                    Set new font with specified style <fontstyle>.
                    The style <fontstyle> is in most cases one of
                    "Regular", "Bold", "Italic", or "Bold Italic".
                    But this setting is dependent on the used font,
                    it may differ (localised style names, or "Standard",
                    "Oblique", ...). (BIFF5-BIFF8)
    &<fontheight>   Set font height in points (<fontheight> is a decimal value).
                    If this command is followed by a plain number to be printed
                    in the header, it will be separated from the font height
                    with a space character.

    """
    _REC_ID = 0x0014

    def __init__(self, header_str):
        self._rec_data = upack2(header_str)

class FooterRecord(BiffRecord):
    """
    Semantic is equal to HEADER record
    """
    _REC_ID = 0x0015

    def __init__(self, footer_str):
        self._rec_data = upack2(footer_str)


class HCenterRecord(BiffRecord):
    """
    This  record  is  part  of the Page Settings Block. It specifies if the
    sheet is centred horizontally when printed.

    Record HCENTER, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       0 = Print sheet left aligned
                    1 = Print sheet centred horizontally

    """
    _REC_ID = 0x0083

    def __init__(self, is_horz_center):
        self._rec_data = pack('<H', is_horz_center)


class VCenterRecord(BiffRecord):
    """
    This  record  is  part  of the Page Settings Block. It specifies if the
    sheet is centred vertically when printed.

    Record VCENTER, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       0 = Print sheet aligned at top page border
                    1 = Print sheet vertically centred

    """
    _REC_ID = 0x0084

    def __init__(self, is_vert_center):
        self._rec_data = pack('<H', is_vert_center)


class LeftMarginRecord(BiffRecord):
    """
    This  record  is  part of the Page Settings Block. It contains the left
    page margin of the current worksheet.

    Record LEFTMARGIN, BIFF2-BIFF8:

    Offset  Size    Contents
    0       8       Left page margin in inches
                    (IEEE 754 floating-point value, 64bit double precision)

    """
    _REC_ID = 0x0026

    def __init__(self, margin):
        self._rec_data = pack('<d', margin)


class RightMarginRecord(BiffRecord):
    """
    This  record  is  part of the Page Settings Block. It contains the right
    page margin of the current worksheet.

    Offset  Size    Contents
    0       8       Right page margin in inches
                    (IEEE 754 floating-point value, 64?bit double precision)

    """
    _REC_ID = 0x0027

    def __init__(self, margin):
        self._rec_data = pack('<d', margin)

class TopMarginRecord(BiffRecord):
    """
    This  record  is  part of the Page Settings Block. It contains the top
    page margin of the current worksheet.

    Offset  Size    Contents
    0       8       Top page margin in inches
                    (IEEE 754 floating-point value, 64?bit double precision)

    """
    _REC_ID = 0x0028

    def __init__(self, margin):
        self._rec_data = pack('<d', margin)


class BottomMarginRecord(BiffRecord):
    """
    This  record  is  part of the Page Settings Block. It contains the bottom
    page margin of the current worksheet.

    Offset  Size    Contents
    0       8       Bottom page margin in inches
                    (IEEE 754 floating-point value, 64?bit double precision)

    """
    _REC_ID = 0x0029

    def __init__(self, margin):
        self._rec_data = pack('<d', margin)

class SetupPageRecord(BiffRecord):
    """
    This   record   is  part of the Page Settings Block. It stores the page
    format   settings   of   the  current sheet. The pages may be scaled in
    percent   or  by  using  an  absolute  number of pages. This setting is
    located   in  the  WSBOOL  record.  If  pages  are  scaled in  percent,
    the   scaling  factor  in  this  record is used, otherwise the "Fit  to
    pages"  values. One of the "Fit to pages" values may be 0. In this case
    the sheet is scaled to fit only to the other value.

    Record SETUP, BIFF5-BIFF8:

    Offset      Size    Contents
    0           2       Paper size (see below)
    2           2       Scaling factor in percent
    4           2       Start page number
    6           2       Fit worksheet width to this number of pages
                        (0 = use as many as needed)
    8           2       Fit worksheet height to this number of pages
                        (0 = use as many as needed)
    10          2       Option flags:
                        Bit     Mask        Contents
                        0       0001H       0 = Print pages in columns
                                            1 = Print pages in rows
                        1       0002H       0 = Landscape
                                            1 = Portrait
                        2       0004H       1 = Paper size, scaling factor,
                                            paper orientation (portrait/landscape),
                                            print resolution and number of copies
                                            are not initialised
                        3       0008H       0 = Print coloured
                                            1 = Print black and white
                        4       0010H       0 = Default print quality
                                            1 = Draft quality
                        5       0020H       0 = Do not print cell notes
                                            1 = Print cell notes
                        6       0040H       0 = Paper orientation setting is valid
                                            1 = Paper orientation setting not
                                            initialised
                        7       0080H       0 = Automatic page numbers
                                            1 = Use start page number
                        The following flags are valid for BIFF8 only:
                        9       0200H       0 = Print notes as displayed
                                            1 = Print notes at end of sheet
                        11-10   0C00H       00 = Print errors as displayed
                                            01 = Do not print errors
                                            10 = Print errors as "--"
                                            11 = Print errors as "#N/A!"
    12          2       Print resolution in dpi
    14          2       Vertical print resolution in dpi
    16          8       Header margin (IEEE 754 floating-point value,
                        64bit double precision)
    24          8       Footer margin (IEEE 754 floating-point value,
                        64bit double precision)
    32          2       Number of copies to print


    PAPER TYPES:

    Index   Paper type              Paper size
    0       Undefined
    1       Letter                  8 1/2" x 11"
    2       Letter small            8 1/2" x 11"
    3       Tabloid                 11" x 17"
    4       Ledger                  17" x 11"
    5       Legal                   8 1/2" x 14"
    6       Statement               5 1/2" x 8 1/2"
    7       Executive               7 1/4" x 10 1/2"
    8       A3                      297mm x 420mm
    9       A4                      210mm x 297mm
    10      A4 small                210mm x 297mm
    11      A5                      148mm x 210mm
    12      B4 (JIS)                257mm x 364mm
    13      B5 (JIS)                182mm x 257mm
    14      Folio                   8 1/2" x 13"
    15      Quarto                  215mm x 275mm
    16      10x14                   10" x 14"
    17      11x17                   11" x 17"
    18      Note                    8 1/2" x 11"
    19      Envelope #9             3 7/8" x 8 7/8"
    20      Envelope #10            4 1/8" x 9 1/2"
    21      Envelope #11            4 1/2" x 10 3/8"
    22      Envelope #12            4 3/4" x 11"
    23      Envelope #14            5" x 11 1/2"
    24      C                       17" x 22"
    25      D                       22" x 34"
    26      E                       34" x 44"
    27      Envelope DL             110mm x 220mm
    28      Envelope C5             162mm x 229mm
    29      Envelope C3             324mm x 458mm
    30      Envelope C4             229mm x 324mm
    31      Envelope C6             114mm x 162mm
    32      Envelope C6/C5          114mm x 229mm
    33      B4 (ISO)                250mm x 353mm
    34      B5 (ISO)                176mm x 250mm
    35      B6 (ISO)                125mm x 176mm
    36      Envelope Italy          110mm x 230mm
    37      Envelope Monarch        3 7/8" x 7 1/2"
    38      63/4 Envelope           3 5/8" x 6 1/2"
    39      US Standard Fanfold     14 7/8" x 11"
    40      German Std. Fanfold     8 1/2" x 12"
    41      German Legal Fanfold    8 1/2" x 13"
    42      B4 (ISO)                250mm x 353mm
    43      Japanese Postcard       100mm x 148mm
    44      9x11                    9" x 11"
    45      10x11                   10" x 11"
    46      15x11                   15" x 11"
    47      Envelope Invite         220mm x 220mm
    48      Undefined
    49      Undefined
    50      Letter Extra            9 1/2" x 12"
    51      Legal Extra             9 1/2" x 15"
    52      Tabloid Extra           11 11/16" x 18"
    53      A4 Extra                235mm x 322mm
    54      Letter Transverse       8 1/2" x 11"
    55      A4 Transverse           210mm x 297mm
    56      Letter Extra Transv.    9 1/2" x 12"
    57      Super A/A4              227mm x 356mm
    58      Super B/A3              305mm x 487mm
    59      Letter Plus             8 1/2" x 12 11/16"
    60      A4 Plus                 210mm x 330mm
    61      A5 Transverse           148mm x 210mm
    62      B5 (JIS) Transverse     182mm x 257mm
    63      A3 Extra                322mm x 445mm
    64      A5 Extra                174mm x 235mm
    65      B5 (ISO) Extra          201mm x 276mm
    66      A2                      420mm x 594mm
    67      A3 Transverse           297mm x 420mm
    68      A3 Extra Transverse     322mm x 445mm
    69      Dbl. Japanese Postcard  200mm x 148mm
    70      A6                      105mm x 148mm
    71
    72
    73
    74
    75      Letter Rotated          11" x 8 1/2"
    76      A3 Rotated              420mm x 297mm
    77      A4 Rotated              297mm x 210mm
    78      A5 Rotated              210mm x 148mm
    79      B4 (JIS) Rotated        364mm x 257mm
    80      B5 (JIS) Rotated        257mm x 182mm
    81      Japanese Postcard Rot.  148mm x 100mm
    82      Dbl. Jap. Postcard Rot. 148mm x 200mm
    83      A6 Rotated              148mm x 105mm
    84
    85
    86
    87
    88      B6 (JIS)                128mm x 182mm
    89      B6 (JIS) Rotated        182mm x 128mm
    90      12x11                   12" x 11"

    """
    _REC_ID = 0x00A1
    def __init__(self, paper, scaling, start_num, fit_width_to, fit_height_to,
                    options,
                    hres, vres,
                    header_margin, footer_margin,
                    num_copies):
        self._rec_data = pack('<8H2dH', paper, scaling, start_num,
                                        fit_width_to, fit_height_to, \
                                        options,
                                        hres, vres,
                                        header_margin, footer_margin,
                                        num_copies)

class NameRecord(BiffRecord):
    """
    This record is part of a Link Table. It contains the name and the token
    array of an internal defined name. Token arrays of defined names
    contain tokens with aberrant token classes.

    Record NAME, BIFF5/BIFF7:
    Offset      Size    Contents
       0          2     Option flags, see below
       2          1     Keyboard shortcut (only for command macro names, see below)
       3          1     Length of the name (character count, ln)
       4          2     Size of the formula data (sz)
       6          2     0 = Global name, otherwise index to EXTERNSHEET record (one-based)
       8          2     0 = Global name, otherwise index to sheet (one-based)
      10          1     Length of menu text (character count, lm)
      11          1     Length of description text (character count, ld)
      12          1     Length of help topic text (character count, lh)
      13          1     Length of status bar text (character count, ls)
      14         ln     Character array of the name
    14+ln        sz     Formula data (RPN token array without size field, 4)
  14+ln+sz       lm     Character array of menu text
     var.        ld     Character array of description text
     var.        lh     Character array of help topic text
     var.        ls     Character array of status bar text

    Record NAME, BIFF8:
    Offset      Size Contents
       0          2  Option flags, see below
       2          1  Keyboard shortcut (only for command macro names, see below)
       3          1  Length of the name (character count, ln)
       4          2  Size of the formula data (sz)
       6          2  Not used
       8          2  0 = Global name, otherwise index to sheet (one-based)
      10          1  Length of menu text (character count, lm)
      11          1  Length of description text (character count, ld)
      12          1  Length of help topic text (character count, lh)
      13          1  Length of status bar text (character count, ls)
      14        var. Name (Unicode string without length field, 3.4)
     var.        sz  Formula data (RPN token array without size field, 4)
    [var.]      var. (optional, only if lm > 0) Menu text (Unicode string without length field, 3.4)
    [var.]      var. (optional, only if ld > 0) Description text (Unicode string without length field, 3.4)
    [var.]      var. (optional, only if lh > 0) Help topic text (Unicode string without length field, 3.4)
    [var.]      var. (optional, only if ls > 0) Status bar text (Unicode string without length field, 3.4)
    """
    _REC_ID = 0x0018

    def __init__(self, options, keyboard_shortcut, name, sheet_index, rpn, menu_text='', desc_text='', help_text='', status_text=''):
        if type(name) == int:
            uname = chr(name)
        else:
            uname = upack1(name)[1:]
        uname_len = len(uname)

        #~ self._rec_data = pack('<HBBHHHBBBB%ds%ds' % (uname_len, len(rpn)), options, keyboard_shortcut, uname_len, len(rpn), 0x0000, sheet_index, len(menu_text), len(desc_text), len(help_text), len(status_text), uname, rpn) + menu_text + desc_text + help_text + status_text
        self._rec_data = pack('<HBBHHHBBBBB%ds%ds' % (uname_len, len(rpn)), options, keyboard_shortcut, uname_len, len(rpn), 0x0000, sheet_index, 0x00, len(menu_text), len(desc_text), len(help_text), len(status_text), uname, rpn) + menu_text + desc_text + help_text + status_text

# Excel (both 2003 and 2007) don't like refs
# split over a record boundary, which is what the
# standard BiffRecord.get method does.

# 8224 max data bytes in a BIFF record
# 6 bytes per ref
# 1370 = floor((8224 - 2) / 6.0) max refs in a record

_maxRefPerRecord = 1370

class ExternSheetRecord(BiffRecord):
    """
    In BIFF8 the record stores a list with indexes to SUPBOOK
    records (list of REF structures, 6.100). See 5.10.3 for
    details about external references in BIFF8.

    Record EXTERNSHEET, BIFF8:
    Offset          Size      Contents
       0             2        Number of following REF structures (nm)
       2           6nm        List of nm REF structures. Each REF contains the following data:
                              Offset     Size     Contents
                                 0         2      Index to SUPBOOK record
                                 2         2      Index to first SUPBOOK sheet
                                 4         2      Index to last SUPBOOK sheet
    """
    _REC_ID = 0x0017

    def __init__(self, refs):

        # do we always need this ref? or only if there are no refs?
        # (I believe that if there are no refs then we should not generate the link table - Ruben)
        #refs.insert(0, (0,0,0))

        self.refs = refs

    def get(self):
        res = []
        nrefs = len(self.refs)
        for idx in xrange(0, nrefs, _maxRefPerRecord):
            chunk = self.refs[idx:idx+_maxRefPerRecord]
            krefs = len(chunk)
            if idx: # CONTINUE record
                header = pack("<HH", 0x003C, 6 * krefs)
            else: # ExternSheetRecord
                header = pack("<HHH", self._REC_ID, 6 * krefs + 2, nrefs)
            res.append(header)
            res.extend([pack("<HHH", *r) for r in chunk])
        return ''.join(res)

class SupBookRecord(BiffRecord):
    """
    This record mainly stores the URL of an external document
    and a list of sheet names inside this document. Furthermore
    it is used to store DDE and OLE object links, or to indicate
    an internal 3D reference or an add-in function. See 5.10.3
    for details about external references in BIFF8.

    """
    _REC_ID = 0x01AE

class InternalReferenceSupBookRecord(SupBookRecord):
    """
    In each file occurs a SUPBOOK that is used for internal 3D
    references. It stores the number of sheets of the own document.

    Record SUPBOOK for 3D references, BIFF8:
    Offset         Size   Contents
      0             2     Number of sheets in this document
      2             2     01H 04H (relict of BIFF5/BIFF7, the byte string "<04H>", see 3.9.1)

    """

    def __init__(self, num_sheets):
        self._rec_data = pack('<HBB', num_sheets, 0x01, 0x04)

class XcallSupBookRecord(SupBookRecord):
    """
    Add-in function names are stored in EXTERNNAME records following this record.

    Offset  Size    Contents
    0       2       0001H
    2       2       01H 3AH (relict of BIFF5, the byte string ':', see EXTERNSHEET record, 5.41)

    """

    def __init__(self):
        self._rec_data = pack('<HBB', 1, 0x01, 0x3A)


class ExternnameRecord(BiffRecord):
    """
    Record EXTERNNAME for external names and Analysis add-in functions, BIFF5-BIFF8:
    Offset  Size    Contents
    0       2       Option flags (see below)
    2       2       0 for global names, or:
                    BIFF5: One-based index to EXTERNSHEET record containing the sheet name,
                    BIFF8: One-based index to sheet list in preceding EXTERNALBOOK record.
    4       2       Not used
    6       var.    BIFF5: Name (byte string, 8-bit string length, ?2.5.2).
                    BIFF8: Name (Unicode string, 8-bit string length, ?2.5.3).
                    See DEFINEDNAME record (?5.33) for a list of built-in names, if the built-in flag is set
                    in the option flags above.
    var.    var.    Formula data (RPN token array, ?3)

    Option flags for external names (BIFF5-BIFF8)
    Bit     Mask    Contents
    0       0001H   0 = Standard name; 1 = Built-in name
    1       0002H   0 = Manual link; 1 = Automatic link (DDE links and OLE links only)
    2       0004H   1 = Picture link (DDE links and OLE links only)
    3       0008H   1 = This is the StdDocumentName identifier (DDE links only)
    4       0010H   1 = OLE link
    14-5    7FE0H   Clipboard format of last successful update (DDE links and OLE links only)
    15      8000H   1 = Iconified picture link (BIFF8 OLE links only)
    """
    _REC_ID = 0x0023

    def __init__(self, options=0, index=0, name=None, fmla=None):
        self._rec_data = pack('<HHH', options, index, 0) + upack1(name) + fmla


########NEW FILE########
__FILENAME__ = Bitmap
# -*- coding: windows-1251 -*-

#  Portions are Copyright (C) 2005 Roman V. Kiseliov
#  Portions are Copyright (c) 2004 Evgeny Filatov <fufff@users.sourceforge.net>
#  Portions are Copyright (c) 2002-2004 John McNamara (Perl Spreadsheet::WriteExcel)

from BIFFRecords import BiffRecord
from struct import *


def _size_col(sheet, col):
    return sheet.col_width(col)


def _size_row(sheet, row):
    return sheet.row_height(row)


def _position_image(sheet, row_start, col_start, x1, y1, width, height):
    """Calculate the vertices that define the position of the image as required by
    the OBJ record.

             +------------+------------+
             |     A      |      B     |
       +-----+------------+------------+
       |     |(x1,y1)     |            |
       |  1  |(A1)._______|______      |
       |     |    |              |     |
       |     |    |              |     |
       +-----+----|    BITMAP    |-----+
       |     |    |              |     |
       |  2  |    |______________.     |
       |     |            |        (B2)|
       |     |            |     (x2,y2)|
       +---- +------------+------------+

    Example of a bitmap that covers some of the area from cell A1 to cell B2.

    Based on the width and height of the bitmap we need to calculate 8 vars:
        col_start, row_start, col_end, row_end, x1, y1, x2, y2.
    The width and height of the cells are also variable and have to be taken into
    account.
    The values of col_start and row_start are passed in from the calling
    function. The values of col_end and row_end are calculated by subtracting
    the width and height of the bitmap from the width and height of the
    underlying cells.
    The vertices are expressed as a percentage of the underlying cell width as
    follows (rhs values are in pixels):

           x1 = X / W *1024
           y1 = Y / H *256
           x2 = (X-1) / W *1024
           y2 = (Y-1) / H *256

           Where:  X is distance from the left side of the underlying cell
                   Y is distance from the top of the underlying cell
                   W is the width of the cell
                   H is the height of the cell

    Note: the SDK incorrectly states that the height should be expressed as a
    percentage of 1024.

    col_start  - Col containing upper left corner of object
    row_start  - Row containing top left corner of object
    x1  - Distance to left side of object
    y1  - Distance to top of object
    width  - Width of image frame
    height  - Height of image frame

    """
    # Adjust start column for offsets that are greater than the col width
    while x1 >= _size_col(sheet, col_start):
        x1 -= _size_col(sheet, col_start)
        col_start += 1
    # Adjust start row for offsets that are greater than the row height
    while y1 >= _size_row(sheet, row_start):
        y1 -= _size_row(sheet, row_start)
        row_start += 1
    # Initialise end cell to the same as the start cell
    row_end = row_start   # Row containing bottom right corner of object
    col_end = col_start   # Col containing lower right corner of object
    width = width + x1 - 1
    height = height + y1 - 1
    # Subtract the underlying cell widths to find the end cell of the image
    while (width >= _size_col(sheet, col_end)):
        width -= _size_col(sheet, col_end)
        col_end += 1
    # Subtract the underlying cell heights to find the end cell of the image
    while (height >= _size_row(sheet, row_end)):
        height -= _size_row(sheet, row_end)
        row_end += 1
    # Bitmap isn't allowed to start or finish in a hidden cell, i.e. a cell
    # with zero height or width.
    if ((_size_col(sheet, col_start) == 0) or (_size_col(sheet, col_end) == 0)
            or (_size_row(sheet, row_start) == 0) or (_size_row(sheet, row_end) == 0)):
        return
    # Convert the pixel values to the percentage value expected by Excel
    x1 = int(float(x1) / _size_col(sheet, col_start) * 1024)
    y1 = int(float(y1) / _size_row(sheet, row_start) * 256)
    # Distance to right side of object
    x2 = int(float(width) / _size_col(sheet, col_end) * 1024)
    # Distance to bottom of object
    y2 = int(float(height) / _size_row(sheet, row_end) * 256)
    return (col_start, x1, row_start, y1, col_end, x2, row_end, y2)


class ObjBmpRecord(BiffRecord):
    _REC_ID = 0x005D    # Record identifier

    def __init__(self, row, col, sheet, im_data_bmp, x, y, scale_x, scale_y):
        # Scale the frame of the image.
        width = im_data_bmp.width * scale_x
        height = im_data_bmp.height * scale_y

        # Calculate the vertices of the image and write the OBJ record
        coordinates = _position_image(sheet, row, col, x, y, width, height)
        # print coordinates
        col_start, x1, row_start, y1, col_end, x2, row_end, y2 = coordinates

        """Store the OBJ record that precedes an IMDATA record. This could be generalise
        to support other Excel objects.

        """
        cObj = 0x0001      # Count of objects in file (set to 1)
        OT = 0x0008        # Object type. 8 = Picture
        id = 0x0001        # Object ID
        grbit = 0x0614     # Option flags
        colL = col_start    # Col containing upper left corner of object
        dxL = x1            # Distance from left side of cell
        rwT = row_start     # Row containing top left corner of object
        dyT = y1            # Distance from top of cell
        colR = col_end      # Col containing lower right corner of object
        dxR = x2            # Distance from right of cell
        rwB = row_end       # Row containing bottom right corner of object
        dyB = y2            # Distance from bottom of cell
        cbMacro = 0x0000    # Length of FMLA structure
        Reserved1 = 0x0000  # Reserved
        Reserved2 = 0x0000  # Reserved
        icvBack = 0x09      # Background colour
        icvFore = 0x09      # Foreground colour
        fls = 0x00          # Fill pattern
        fAuto = 0x00        # Automatic fill
        icv = 0x08          # Line colour
        lns = 0xff          # Line style
        lnw = 0x01          # Line weight
        fAutoB = 0x00       # Automatic border
        frs = 0x0000        # Frame style
        cf = 0x0009         # Image format, 9 = bitmap
        Reserved3 = 0x0000  # Reserved
        cbPictFmla = 0x0000 # Length of FMLA structure
        Reserved4 = 0x0000  # Reserved
        grbit2 = 0x0001     # Option flags
        Reserved5 = 0x0000  # Reserved

        data = pack("<L", cObj)
        data += pack("<H", OT)
        data += pack("<H", id)
        data += pack("<H", grbit)
        data += pack("<H", colL)
        data += pack("<H", dxL)
        data += pack("<H", rwT)
        data += pack("<H", dyT)
        data += pack("<H", colR)
        data += pack("<H", dxR)
        data += pack("<H", rwB)
        data += pack("<H", dyB)
        data += pack("<H", cbMacro)
        data += pack("<L", Reserved1)
        data += pack("<H", Reserved2)
        data += pack("<B", icvBack)
        data += pack("<B", icvFore)
        data += pack("<B", fls)
        data += pack("<B", fAuto)
        data += pack("<B", icv)
        data += pack("<B", lns)
        data += pack("<B", lnw)
        data += pack("<B", fAutoB)
        data += pack("<H", frs)
        data += pack("<L", cf)
        data += pack("<H", Reserved3)
        data += pack("<H", cbPictFmla)
        data += pack("<H", Reserved4)
        data += pack("<H", grbit2)
        data += pack("<L", Reserved5)

        self._rec_data = data

def _process_bitmap(bitmap):
    """Convert a 24 bit bitmap into the modified internal format used by Windows.
    This is described in BITMAPCOREHEADER and BITMAPCOREINFO structures in the
    MSDN library.

    """
    # Open file and binmode the data in case the platform needs it.
    fh = file(bitmap, "rb")
    try:
        # Slurp the file into a string.
        data = fh.read()
    finally:
        fh.close()
    # Check that the file is big enough to be a bitmap.
    if len(data) <= 0x36:
        raise Exception("bitmap doesn't contain enough data.")
    # The first 2 bytes are used to identify the bitmap.
    if (data[:2] != "BM"):
        raise Exception("bitmap doesn't appear to to be a valid bitmap image.")
    # Remove bitmap data: ID.
    data = data[2:]
    # Read and remove the bitmap size. This is more reliable than reading
    # the data size at offset 0x22.
    #
    size = unpack("<L", data[:4])[0]
    size -=  0x36   # Subtract size of bitmap header.
    size +=  0x0C   # Add size of BIFF header.
    data = data[4:]
    # Remove bitmap data: reserved, offset, header length.
    data = data[12:]
    # Read and remove the bitmap width and height. Verify the sizes.
    width, height = unpack("<LL", data[:8])
    data = data[8:]
    if (width > 0xFFFF):
        raise Exception("bitmap: largest image width supported is 65k.")
    if (height > 0xFFFF):
        raise Exception("bitmap: largest image height supported is 65k.")
    # Read and remove the bitmap planes and bpp data. Verify them.
    planes, bitcount = unpack("<HH", data[:4])
    data = data[4:]
    if (bitcount != 24):
        raise Exception("bitmap isn't a 24bit true color bitmap.")
    if (planes != 1):
        raise Exception("bitmap: only 1 plane supported in bitmap image.")
    # Read and remove the bitmap compression. Verify compression.
    compression = unpack("<L", data[:4])[0]
    data = data[4:]
    if (compression != 0):
        raise Exception("bitmap: compression not supported in bitmap image.")
    # Remove bitmap data: data size, hres, vres, colours, imp. colours.
    data = data[20:]
    # Add the BITMAPCOREHEADER data
    header = pack("<LHHHH", 0x000c, width, height, 0x01, 0x18)
    data = header + data
    return (width, height, size, data)


class ImDataBmpRecord(BiffRecord):
    _REC_ID = 0x007F

    def __init__(self, filename):
        """Insert a 24bit bitmap image in a worksheet. The main record required is
        IMDATA but it must be proceeded by a OBJ record to define its position.

        """
        BiffRecord.__init__(self)

        self.width, self.height, self.size, data = _process_bitmap(filename)
        # Write the IMDATA record to store the bitmap data
        cf = 0x09
        env = 0x01
        lcb = self.size
        self._rec_data = pack("<HHL", cf, env, lcb) + data



########NEW FILE########
__FILENAME__ = Cell
# -*- coding: windows-1252 -*-

from struct import unpack, pack
import BIFFRecords

class StrCell(object):
    __slots__ = ["rowx", "colx", "xf_idx", "sst_idx"]

    def __init__(self, rowx, colx, xf_idx, sst_idx):
        self.rowx = rowx
        self.colx = colx
        self.xf_idx = xf_idx
        self.sst_idx = sst_idx

    def get_biff_data(self):
        # return BIFFRecords.LabelSSTRecord(self.rowx, self.colx, self.xf_idx, self.sst_idx).get()
        return pack('<5HL', 0x00FD, 10, self.rowx, self.colx, self.xf_idx, self.sst_idx)

class BlankCell(object):
    __slots__ = ["rowx", "colx", "xf_idx"]

    def __init__(self, rowx, colx, xf_idx):
        self.rowx = rowx
        self.colx = colx
        self.xf_idx = xf_idx

    def get_biff_data(self):
        # return BIFFRecords.BlankRecord(self.rowx, self.colx, self.xf_idx).get()
        return pack('<5H', 0x0201, 6, self.rowx, self.colx, self.xf_idx)

class MulBlankCell(object):
    __slots__ = ["rowx", "colx1", "colx2", "xf_idx"]

    def __init__(self, rowx, colx1, colx2, xf_idx):
        self.rowx = rowx
        self.colx1 = colx1
        self.colx2 = colx2
        self.xf_idx = xf_idx

    def get_biff_data(self):
        return BIFFRecords.MulBlankRecord(self.rowx,
            self.colx1, self.colx2, self.xf_idx).get()

class NumberCell(object):
    __slots__ = ["rowx", "colx", "xf_idx", "number"]

    def __init__(self, rowx, colx, xf_idx, number):
        self.rowx = rowx
        self.colx = colx
        self.xf_idx = xf_idx
        self.number = float(number)

    def get_encoded_data(self):
        rk_encoded = 0
        num = self.number

        # The four possible kinds of RK encoding are *not* mutually exclusive.
        # The 30-bit integer variety picks up the most.
        # In the code below, the four varieties are checked in descending order
        # of bangs per buck, or not at all.
        # SJM 2007-10-01

        if -0x20000000 <= num < 0x20000000: # fits in 30-bit *signed* int
            inum = int(num)
            if inum == num: # survives round-trip
                # print "30-bit integer RK", inum, hex(inum)
                rk_encoded = 2 | (inum << 2)
                return 1, rk_encoded

        temp = num * 100

        if -0x20000000 <= temp < 0x20000000:
            # That was step 1: the coded value will fit in
            # a 30-bit signed integer.
            itemp = int(round(temp, 0))
            # That was step 2: "itemp" is the best candidate coded value.
            # Now for step 3: simulate the decoding,
            # to check for round-trip correctness.
            if itemp / 100.0 == num:
                # print "30-bit integer RK*100", itemp, hex(itemp)
                rk_encoded = 3 | (itemp << 2)
                return 1, rk_encoded

        if 0: # Cost of extra pack+unpack not justified by tiny yield.
            packed = pack('<d', num)
            w01, w23 = unpack('<2i', packed)
            if not w01 and not(w23 & 3):
                # 34 lsb are 0
                # print "float RK", w23, hex(w23)
                return 1, w23

            packed100 = pack('<d', temp)
            w01, w23 = unpack('<2i', packed100)
            if not w01 and not(w23 & 3):
                # 34 lsb are 0
                # print "float RK*100", w23, hex(w23)
                return 1, w23 | 1

        #print "Number"
        #print
        return 0, pack('<5Hd', 0x0203, 14, self.rowx, self.colx, self.xf_idx, num)

    def get_biff_data(self):
        isRK, value = self.get_encoded_data()
        if isRK:
            return pack('<5Hi', 0x27E, 10, self.rowx, self.colx, self.xf_idx, value)
        return value # NUMBER record already packed

class BooleanCell(object):
    __slots__ = ["rowx", "colx", "xf_idx", "number"]

    def __init__(self, rowx, colx, xf_idx, number):
        self.rowx = rowx
        self.colx = colx
        self.xf_idx = xf_idx
        self.number = number

    def get_biff_data(self):
        return BIFFRecords.BoolErrRecord(self.rowx,
            self.colx, self.xf_idx, self.number, 0).get()

error_code_map = {
    0x00:  0, # Intersection of two cell ranges is empty
    0x07:  7, # Division by zero
    0x0F: 15, # Wrong type of operand
    0x17: 23, # Illegal or deleted cell reference
    0x1D: 29, # Wrong function or range name
    0x24: 36, # Value range overflow
    0x2A: 42, # Argument or function not available
    '#NULL!' :  0, # Intersection of two cell ranges is empty
    '#DIV/0!':  7, # Division by zero
    '#VALUE!': 36, # Wrong type of operand
    '#REF!'  : 23, # Illegal or deleted cell reference
    '#NAME?' : 29, # Wrong function or range name
    '#NUM!'  : 36, # Value range overflow
    '#N/A!'  : 42, # Argument or function not available
}

class ErrorCell(object):
    __slots__ = ["rowx", "colx", "xf_idx", "number"]

    def __init__(self, rowx, colx, xf_idx, error_string_or_code):
        self.rowx = rowx
        self.colx = colx
        self.xf_idx = xf_idx
        try:
            self.number = error_code_map[error_string_or_code]
        except KeyError:
            raise Exception('Illegal error value (%r)' % error_string_or_code)

    def get_biff_data(self):
        return BIFFRecords.BoolErrRecord(self.rowx,
            self.colx, self.xf_idx, self.number, 1).get()

class FormulaCell(object):
    __slots__ = ["rowx", "colx", "xf_idx", "frmla", "calc_flags"]

    def __init__(self, rowx, colx, xf_idx, frmla, calc_flags=0):
        self.rowx = rowx
        self.colx = colx
        self.xf_idx = xf_idx
        self.frmla = frmla
        self.calc_flags = calc_flags

    def get_biff_data(self):
        return BIFFRecords.FormulaRecord(self.rowx,
            self.colx, self.xf_idx, self.frmla.rpn(), self.calc_flags).get()

# module-level function for *internal* use by the Row module

def _get_cells_biff_data_mul(rowx, cell_items):
    # Return the BIFF data for all cell records in the row.
    # Adjacent BLANK|RK records are combined into MUL(BLANK|RK) records.
    pieces = []
    nitems = len(cell_items)
    i = 0
    while i < nitems:
        icolx, icell = cell_items[i]
        if isinstance(icell, NumberCell):
            isRK, value = icell.get_encoded_data()
            if not isRK:
                pieces.append(value) # pre-packed NUMBER record
                i += 1
                continue
            muldata = [(value, icell.xf_idx)]
            target = NumberCell
        elif isinstance(icell, BlankCell):
            muldata = [icell.xf_idx]
            target = BlankCell
        else:
            pieces.append(icell.get_biff_data())
            i += 1
            continue
        lastcolx = icolx
        j = i
        packed_record = ''
        for j in xrange(i+1, nitems):
            jcolx, jcell = cell_items[j]
            if jcolx != lastcolx + 1:
                nexti = j
                break
            if not isinstance(jcell, target):
                nexti = j
                break
            if target == NumberCell:
                isRK, value = jcell.get_encoded_data()
                if not isRK:
                    packed_record = value
                    nexti = j + 1
                    break
                muldata.append((value, jcell.xf_idx))
            else:
                muldata.append(jcell.xf_idx)
            lastcolx = jcolx
        else:
            nexti = j + 1
        if target == NumberCell:
            if lastcolx == icolx:
                # RK record
                value, xf_idx = muldata[0]
                pieces.append(pack('<5Hi', 0x027E, 10, rowx, icolx, xf_idx, value))
            else:
                # MULRK record
                nc = lastcolx - icolx + 1
                pieces.append(pack('<4H', 0x00BD, 6 * nc + 6, rowx, icolx))
                pieces.append(''.join([pack('<Hi', xf_idx, value) for value, xf_idx in muldata]))
                pieces.append(pack('<H', lastcolx))
        else:
            if lastcolx == icolx:
                # BLANK record
                xf_idx = muldata[0]
                pieces.append(pack('<5H', 0x0201, 6, rowx, icolx, xf_idx))
            else:
                # MULBLANK record
                nc = lastcolx - icolx + 1
                pieces.append(pack('<4H', 0x00BE, 2 * nc + 6, rowx, icolx))
                pieces.append(''.join([pack('<H', xf_idx) for xf_idx in muldata]))
                pieces.append(pack('<H', lastcolx))
        if packed_record:
            pieces.append(packed_record)
        i = nexti
    return ''.join(pieces)


########NEW FILE########
__FILENAME__ = Column
# -*- coding: windows-1252 -*-

from BIFFRecords import ColInfoRecord

class Column(object):
    def __init__(self, colx, parent_sheet):
        if not(isinstance(colx, int) and 0 <= colx <= 255):
            raise ValueError("column index (%r) not an int in range(256)" % colx)
        self._index = colx
        self._parent = parent_sheet
        self._parent_wb = parent_sheet.get_parent()
        self._xf_index = 0x0F

        self.width = 0x0B92
        self.hidden = 0
        self.level = 0
        self.collapse = 0

    def set_style(self, style):
        self._xf_index = self._parent_wb.add_style(style)

    def width_in_pixels(self):
        # *** Approximation ****
        return int(round(self.width * 0.0272 + 0.446, 0))

    def get_biff_record(self):
        options =  (self.hidden & 0x01) << 0
        options |= (self.level & 0x07) << 8
        options |= (self.collapse & 0x01) << 12

        return ColInfoRecord(self._index, self._index, self.width, self._xf_index, options).get()




########NEW FILE########
__FILENAME__ = CompoundDoc
# -*- coding: windows-1252 -*-

import sys
import struct

class Reader:
    def __init__(self, filename, dump = False):
        self.dump = dump
        self.STREAMS = {}

        doc = file(filename, 'rb').read()
        self.header, self.data = doc[0:512], doc[512:]
        del doc

        self.__build_header()
        self.__build_MSAT()
        self.__build_SAT()
        self.__build_directory()
        self.__build_short_sectors_data()
        
        if len(self.short_sectors_data) > 0:
            self.__build_SSAT()
        else:
            if self.dump and (self.total_ssat_sectors != 0 or self.ssat_start_sid != -2):
                print 'NOTE: header says that must be', self.total_ssat_sectors, 'short sectors'
                print 'NOTE: starting at', self.ssat_start_sid, 'sector'
                print 'NOTE: but file does not contains data in short sectors'
            self.ssat_start_sid = -2
            self.total_ssat_sectors = 0
            self.SSAT = [-2]

        for dentry in self.dir_entry_list[1:]:
            (did, 
             sz, name, 
             t, c, 
             did_left, did_right, did_root, 
             dentry_start_sid, 
             stream_size
            ) = dentry
            stream_data = ''
            if stream_size > 0:
                if stream_size >= self.min_stream_size:
                    args = (self.data, self.SAT, dentry_start_sid, self.sect_size)
                else:
                    args = (self.short_sectors_data, self.SSAT, dentry_start_sid, self.short_sect_size)
                stream_data = self.get_stream_data(*args)

            if name != '':
                # BAD IDEA: names may be equal. NEED use full paths...
                self.STREAMS[name] = stream_data

    
    def __build_header(self):
        self.doc_magic             = self.header[0:8]

        if self.doc_magic != '\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1':
            raise Exception, 'Not an OLE file.'

        self.file_uid              = self.header[8:24]
        self.rev_num               = self.header[24:26]
        self.ver_num               = self.header[26:28]
        self.byte_order            = self.header[28:30]
        self.log2_sect_size,       = struct.unpack('<H', self.header[30:32])
        self.log2_short_sect_size, = struct.unpack('<H', self.header[32:34])
        self.total_sat_sectors,    = struct.unpack('<L', self.header[44:48])
        self.dir_start_sid,        = struct.unpack('<l', self.header[48:52])
        self.min_stream_size,      = struct.unpack('<L', self.header[56:60])
        self.ssat_start_sid,       = struct.unpack('<l', self.header[60:64])
        self.total_ssat_sectors,   = struct.unpack('<L', self.header[64:68])
        self.msat_start_sid,       = struct.unpack('<l', self.header[68:72])
        self.total_msat_sectors,   = struct.unpack('<L', self.header[72:76])
         
        self.sect_size        = 1 << self.log2_sect_size
        self.short_sect_size  = 1 << self.log2_short_sect_size

        if self.dump:
            print 'file magic: '
            print_bin_data(self.doc_magic)

            print 'file uid: '
            print_bin_data(self.file_uid)

            print 'revision number: '
            print_bin_data(self.rev_num)
         
            print 'version number: '
            print_bin_data(self.ver_num)
            
            print 'byte order: '
            print_bin_data(self.byte_order)
            
            print 'sector size                                :', hex(self.sect_size), self.sect_size
            #print 'total sectors in file                      :', hex(self.total_sectors), self.total_sectors
            print 'short sector size                          :', hex(self.short_sect_size), self.short_sect_size
            print 'Total number of sectors used for the SAT   :', hex(self.total_sat_sectors), self.total_sat_sectors
            print 'SID of first sector of the directory stream:', hex(self.dir_start_sid), self.dir_start_sid
            print 'Minimum size of a standard stream          :', hex(self.min_stream_size), self.min_stream_size
            print 'SID of first sector of the SSAT            :', hex(self.ssat_start_sid), self.ssat_start_sid
            print 'Total number of sectors used for the SSAT  :', hex(self.total_ssat_sectors), self.total_ssat_sectors
            print 'SID of first additional sector of the MSAT :', hex(self.msat_start_sid), self.msat_start_sid
            print 'Total number of sectors used for the MSAT  :', hex(self.total_msat_sectors), self.total_msat_sectors


    def __build_MSAT(self):
        self.MSAT = list(struct.unpack('<109l', self.header[76:]))
        
        next = self.msat_start_sid
        while next > 0:
           msat_sector = struct.unpack('<128l', self.data[next*self.sect_size:(next+1)*self.sect_size])
           self.MSAT.extend(msat_sector[:127])
           next = msat_sector[-1]

        if self.dump:
            print 'MSAT (header part): \n', self.MSAT[:109]
            print 'additional MSAT sectors: \n', self.MSAT[109:]


    def __build_SAT(self):
        sat_stream = ''.join([self.data[i*self.sect_size:(i+1)*self.sect_size] for i in self.MSAT if i >= 0])

        sat_sids_count = len(sat_stream) >> 2
        self.SAT = struct.unpack('<%dl' % sat_sids_count, sat_stream) # SIDs tuple

        if self.dump:
            print 'SAT sid count:\n', sat_sids_count
            print 'SAT content:\n', self.SAT


    def __build_SSAT(self):
        ssat_stream = self.get_stream_data(self.data, self.SAT, self.ssat_start_sid, self.sect_size)

        ssids_count = len(ssat_stream) >> 2
        self.SSAT = struct.unpack('<%dl' % ssids_count, ssat_stream)

        if self.dump:
            print 'SSID count:', ssids_count
            print 'SSAT content:\n', self.SSAT


    def __build_directory(self):
        dir_stream = self.get_stream_data(self.data, self.SAT, self.dir_start_sid, self.sect_size)

        self.dir_entry_list = []

        i = 0
        while i < len(dir_stream):
            dentry = dir_stream[i:i+128] # 128 -- dir entry size
            i += 128
            
            did = len(self.dir_entry_list)
            sz, = struct.unpack('<H', dentry[64:66])
            if sz > 0 :
                name = dentry[0:sz-2].decode('utf_16_le', 'replace')
            else:
                name = u''
            t,  = struct.unpack('B', dentry[66])
            c,  = struct.unpack('B', dentry[67])
            did_left ,  = struct.unpack('<l', dentry[68:72])
            did_right ,  = struct.unpack('<l', dentry[72:76])
            did_root ,  = struct.unpack('<l', dentry[76:80])
            dentry_start_sid ,  = struct.unpack('<l', dentry[116:120])
            stream_size ,  = struct.unpack('<L', dentry[120:124])

            self.dir_entry_list.extend([(did, sz, name, t, c, 
                                            did_left, did_right, did_root, 
                                            dentry_start_sid, stream_size)]) 

        if self.dump:
            dentry_types = {
                0x00: 'Empty',
                0x01: 'User storage',
                0x02: 'User stream',
                0x03: 'LockBytes',
                0x04: 'Property',
                0x05: 'Root storage'
            }
            node_colours = {
                0x00: 'Red',
                0x01: 'Black'
            }
            print 'total directory entries:', len(self.dir_entry_list)

            for dentry in self.dir_entry_list:
                (did, sz, name, t, c, 
                 did_left, did_right, did_root, 
                 dentry_start_sid, stream_size) = dentry
                print 'DID', did
                print 'Size of the used area of the character buffer of the name:', sz
                print 'dir entry name:', repr(name)
                print 'type of entry:', t, dentry_types[t]
                print 'entry colour:', c, node_colours[c]
                print 'left child DID :', did_left
                print 'right child DID:', did_right
                print 'root DID       :', did_root
                print 'start SID       :', dentry_start_sid
                print 'stream size     :', stream_size
                if stream_size == 0:
                    print 'stream is empty'
                elif stream_size >= self.min_stream_size:
                    print 'stream stored as normal stream'
                else:
                    print 'stream stored as short-stream'

    
    def __build_short_sectors_data(self):
        (did, sz, name, t, c, 
         did_left, did_right, did_root, 
         dentry_start_sid, stream_size) = self.dir_entry_list[0]
        assert t == 0x05 # Short-Stream Container Stream (SSCS) resides in Root Storage
        if stream_size == 0:
            self.short_sectors_data = ''
        else:
            self.short_sectors_data = self.get_stream_data(self.data, self.SAT, dentry_start_sid, self.sect_size)


    def get_stream_data(self, data, SAT, start_sid, sect_size):
        sid = start_sid
        chunks = [(sid, sid)]
        stream_data = ''

        while SAT[sid] >= 0:
            next_in_chain = SAT[sid]
            last_chunk_start, last_chunk_finish = chunks[-1]
            if next_in_chain == last_chunk_finish + 1:
                chunks[-1] = last_chunk_start, next_in_chain
            else:
                chunks.extend([(next_in_chain, next_in_chain)]) 
            sid = next_in_chain
        for s, f in chunks:
            stream_data += data[s*sect_size:(f+1)*sect_size]
        #print chunks
        return stream_data

        
def print_bin_data(data):
    i = 0
    while i < len(data):
        j = 0
        while (i < len(data)) and (j < 16):
            c = '0x%02X' % ord(data[i])
            sys.stdout.write(c)
            sys.stdout.write(' ')
            i += 1
            j += 1
        print
    if i == 0:
        print '<NO DATA>'



# This implementation writes only 'Root Entry', 'Workbook' streams
# and 2 empty streams for aligning directory stream on sector boundary
# 
# LAYOUT:
# 0         header
# 76                MSAT (1st part: 109 SID)
# 512       workbook stream
# ...       additional MSAT sectors if streams' size > about 7 Mb == (109*512 * 128)
# ...       SAT
# ...       directory stream
#
# NOTE: this layout is "ad hoc". It can be more general. RTFM

class XlsDoc:
    SECTOR_SIZE = 0x0200
    MIN_LIMIT   = 0x1000

    SID_FREE_SECTOR  = -1
    SID_END_OF_CHAIN = -2
    SID_USED_BY_SAT  = -3
    SID_USED_BY_MSAT = -4

    def __init__(self):
        #self.book_stream = ''                # padded
        self.book_stream_sect = []

        self.dir_stream = ''
        self.dir_stream_sect = []

        self.packed_SAT = ''
        self.SAT_sect = []

        self.packed_MSAT_1st = ''
        self.packed_MSAT_2nd = ''
        self.MSAT_sect_2nd = []

        self.header = ''

    def __build_directory(self): # align on sector boundary
        self.dir_stream = ''

        dentry_name      = '\x00'.join('Root Entry\x00') + '\x00'
        dentry_name_sz   = len(dentry_name)
        dentry_name_pad  = '\x00'*(64 - dentry_name_sz)
        dentry_type      = 0x05 # root storage
        dentry_colour    = 0x01 # black
        dentry_did_left  = -1
        dentry_did_right = -1
        dentry_did_root  = 1
        dentry_start_sid = -2
        dentry_stream_sz = 0

        self.dir_stream += struct.pack('<64s H 2B 3l 9L l L L',
           dentry_name + dentry_name_pad,
           dentry_name_sz,
           dentry_type,
           dentry_colour,
           dentry_did_left, 
           dentry_did_right,
           dentry_did_root,
           0, 0, 0, 0, 0, 0, 0, 0, 0,
           dentry_start_sid,
           dentry_stream_sz,
           0
        )

        dentry_name      = '\x00'.join('Workbook\x00') + '\x00'
        dentry_name_sz   = len(dentry_name)
        dentry_name_pad  = '\x00'*(64 - dentry_name_sz)
        dentry_type      = 0x02 # user stream
        dentry_colour    = 0x01 # black
        dentry_did_left  = -1
        dentry_did_right = -1
        dentry_did_root  = -1
        dentry_start_sid = 0     
        dentry_stream_sz = self.book_stream_len

        self.dir_stream += struct.pack('<64s H 2B 3l 9L l L L',
           dentry_name + dentry_name_pad,
           dentry_name_sz,
           dentry_type,
           dentry_colour,
           dentry_did_left, 
           dentry_did_right,
           dentry_did_root,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 
           dentry_start_sid,
           dentry_stream_sz,
           0
        )
        
        # padding
        dentry_name      = ''
        dentry_name_sz   = len(dentry_name)
        dentry_name_pad  = '\x00'*(64 - dentry_name_sz)
        dentry_type      = 0x00 # empty
        dentry_colour    = 0x01 # black
        dentry_did_left  = -1
        dentry_did_right = -1
        dentry_did_root  = -1
        dentry_start_sid = -2
        dentry_stream_sz = 0

        self.dir_stream += struct.pack('<64s H 2B 3l 9L l L L',
           dentry_name + dentry_name_pad,
           dentry_name_sz,
           dentry_type,
           dentry_colour,
           dentry_did_left, 
           dentry_did_right,
           dentry_did_root,
           0, 0, 0, 0, 0, 0, 0, 0, 0,
           dentry_start_sid,
           dentry_stream_sz,
           0
        ) * 2
    
    def __build_sat(self):
        # Build SAT
        book_sect_count = self.book_stream_len >> 9
        dir_sect_count  = len(self.dir_stream) >> 9
        
        total_sect_count     = book_sect_count + dir_sect_count
        SAT_sect_count       = 0
        MSAT_sect_count      = 0
        SAT_sect_count_limit = 109
        while total_sect_count > 128*SAT_sect_count or SAT_sect_count > SAT_sect_count_limit:
            SAT_sect_count   += 1
            total_sect_count += 1
            if SAT_sect_count > SAT_sect_count_limit:
                MSAT_sect_count      += 1
                total_sect_count     += 1
                SAT_sect_count_limit += 127


        SAT = [self.SID_FREE_SECTOR]*128*SAT_sect_count

        sect = 0
        while sect < book_sect_count - 1:
            self.book_stream_sect.append(sect)
            SAT[sect] = sect + 1
            sect += 1
        self.book_stream_sect.append(sect)
        SAT[sect] = self.SID_END_OF_CHAIN
        sect += 1

        while sect < book_sect_count + MSAT_sect_count:
            self.MSAT_sect_2nd.append(sect)
            SAT[sect] = self.SID_USED_BY_MSAT
            sect += 1

        while sect < book_sect_count + MSAT_sect_count + SAT_sect_count:
            self.SAT_sect.append(sect)            
            SAT[sect] = self.SID_USED_BY_SAT
            sect += 1

        while sect < book_sect_count + MSAT_sect_count + SAT_sect_count + dir_sect_count - 1:
            self.dir_stream_sect.append(sect)
            SAT[sect] = sect + 1
            sect += 1
        self.dir_stream_sect.append(sect)
        SAT[sect] = self.SID_END_OF_CHAIN
        sect += 1

        self.packed_SAT = struct.pack('<%dl' % (SAT_sect_count*128), *SAT)

        MSAT_1st = [self.SID_FREE_SECTOR]*109
        for i, SAT_sect_num in zip(range(0, 109), self.SAT_sect):
            MSAT_1st[i] = SAT_sect_num
        self.packed_MSAT_1st = struct.pack('<109l', *MSAT_1st)

        MSAT_2nd = [self.SID_FREE_SECTOR]*128*MSAT_sect_count
        if MSAT_sect_count > 0:
            MSAT_2nd[- 1] = self.SID_END_OF_CHAIN

        i = 109
        msat_sect = 0
        sid_num = 0
        while i < SAT_sect_count:
            if (sid_num + 1) % 128 == 0:
                #print 'link: ',
                msat_sect += 1
                if msat_sect < len(self.MSAT_sect_2nd):
                    MSAT_2nd[sid_num] = self.MSAT_sect_2nd[msat_sect]
            else:
                #print 'sid: ',
                MSAT_2nd[sid_num] = self.SAT_sect[i]
                i += 1
            #print sid_num, MSAT_2nd[sid_num]
            sid_num += 1

        self.packed_MSAT_2nd = struct.pack('<%dl' % (MSAT_sect_count*128), *MSAT_2nd)

        #print vars()
        #print zip(range(0, sect), SAT)
        #print self.book_stream_sect
        #print self.MSAT_sect_2nd
        #print MSAT_2nd
        #print self.SAT_sect
        #print self.dir_stream_sect


    def __build_header(self):
        doc_magic             = '\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1'
        file_uid              = '\x00'*16
        rev_num               = '\x3E\x00'
        ver_num               = '\x03\x00'
        byte_order            = '\xFE\xFF'
        log_sect_size         = struct.pack('<H', 9)
        log_short_sect_size   = struct.pack('<H', 6)
        not_used0             = '\x00'*10
        total_sat_sectors     = struct.pack('<L', len(self.SAT_sect))
        dir_start_sid         = struct.pack('<l', self.dir_stream_sect[0])
        not_used1             = '\x00'*4        
        min_stream_size       = struct.pack('<L', 0x1000)
        ssat_start_sid        = struct.pack('<l', -2)
        total_ssat_sectors    = struct.pack('<L', 0)

        if len(self.MSAT_sect_2nd) == 0:
            msat_start_sid        = struct.pack('<l', -2)
        else:
            msat_start_sid        = struct.pack('<l', self.MSAT_sect_2nd[0])

        total_msat_sectors    = struct.pack('<L', len(self.MSAT_sect_2nd))

        self.header =       ''.join([  doc_magic,
                                        file_uid,
                                        rev_num,
                                        ver_num,
                                        byte_order,
                                        log_sect_size,
                                        log_short_sect_size,
                                        not_used0,
                                        total_sat_sectors,
                                        dir_start_sid,
                                        not_used1,
                                        min_stream_size,
                                        ssat_start_sid,
                                        total_ssat_sectors,
                                        msat_start_sid,
                                        total_msat_sectors
                                    ])
                                        

    def save(self, file_name_or_filelike_obj, stream):
        # 1. Align stream on 0x1000 boundary (and therefore on sector boundary)
        padding = '\x00' * (0x1000 - (len(stream) % 0x1000))
        self.book_stream_len = len(stream) + len(padding)

        self.__build_directory()
        self.__build_sat()
        self.__build_header()
        
        f = file_name_or_filelike_obj
        we_own_it = not hasattr(f, 'write')
        if we_own_it:
            f = open(file_name_or_filelike_obj, 'wb')
        f.write(self.header)
        f.write(self.packed_MSAT_1st)
        f.write(stream)
        f.write(padding)
        f.write(self.packed_MSAT_2nd)
        f.write(self.packed_SAT)
        f.write(self.dir_stream)
        if we_own_it:
            f.close()

########NEW FILE########
__FILENAME__ = big-16Mb
#!/usr/bin/env python
# tries stress SST, SAT and MSAT

from time import *
from xlwt.Workbook import *
from xlwt.Style import *

style = XFStyle()

wb = Workbook()
ws0 = wb.add_sheet('0')

colcount = 200 + 1
rowcount = 6000 + 1

t0 = time()
print "\nstart: %s" % ctime(t0)

print "Filling..."
for col in xrange(colcount):
    print "[%d]" % col, 
    for row in xrange(rowcount):
        #ws0.write(row, col, "BIG(%d, %d)" % (row, col))
        ws0.write(row, col, "BIG")

t1 = time() - t0
print "\nsince starting elapsed %.2f s" % (t1)

print "Storing..."
wb.save('big-16Mb.xls')

t2 = time() - t0
print "since starting elapsed %.2f s" % (t2)



########NEW FILE########
__FILENAME__ = big-35Mb
#!/usr/bin/env python
# tries stress SST, SAT and MSAT

from time import *
from xlwt import *

style = XFStyle()

wb = Workbook()
ws0 = wb.add_sheet('0')

colcount = 200 + 1
rowcount = 6000 + 1

t0 = time()
print "\nstart: %s" % ctime(t0)

print "Filling..."
for col in xrange(colcount):
    print "[%d]" % col, 
    for row in xrange(rowcount):
        ws0.write(row, col, "BIG(%d, %d)" % (row, col))
        #ws0.write(row, col, "BIG")

t1 = time() - t0
print "\nsince starting elapsed %.2f s" % (t1)

print "Storing..."
wb.save('big-35Mb.xls')

t2 = time() - t0
print "since starting elapsed %.2f s" % (t2)



########NEW FILE########
__FILENAME__ = blanks
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

font0 = Font()
font0.name = 'Times New Roman'
font0.struck_out = True
font0.bold = True

style0 = XFStyle()
style0.font = font0


wb = Workbook()
ws0 = wb.add_sheet('0')

ws0.write(1, 1, 'Test', style0)

for i in range(0, 0x53):
    borders = Borders()
    borders.left = i
    borders.right = i
    borders.top = i
    borders.bottom = i

    style = XFStyle()
    style.borders = borders

    ws0.write(i, 2, '', style)
    ws0.write(i, 3, hex(i), style0)

ws0.write_merge(5, 8, 6, 10, "")

wb.save('blanks.xls')

########NEW FILE########
__FILENAME__ = col_width
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman
__rev_id__ = """$Id: col_width.py 3315 2008-03-14 14:44:52Z chris $"""


from xlwt import *

w = Workbook()
ws = w.add_sheet('Hey, Dude')

for i in range(6, 80):
    fnt = Font()
    fnt.height = i*20
    style = XFStyle()
    style.font = fnt
    ws.write(1, i, 'Test')
    ws.col(i).width = 0x0d00 + i
w.save('col_width.xls')

########NEW FILE########
__FILENAME__ = country
#!/usr/bin/env python
# -*- coding: windows-1252 -*-
# Copyright (C) 2007 John Machin

from xlwt import *

w = Workbook()
w.country_code = 61
ws = w.add_sheet('AU')
w.save('country.xls')

########NEW FILE########
__FILENAME__ = dates
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *
from datetime import datetime

w = Workbook()
ws = w.add_sheet('Hey, Dude')

fmts = [
    'M/D/YY',
    'D-MMM-YY',
    'D-MMM',
    'MMM-YY',
    'h:mm AM/PM',
    'h:mm:ss AM/PM',
    'h:mm',
    'h:mm:ss',
    'M/D/YY h:mm',
    'mm:ss',
    '[h]:mm:ss',
    'mm:ss.0',
]

i = 0
for fmt in fmts:
    ws.write(i, 0, fmt)

    style = XFStyle()
    style.num_format_str = fmt

    ws.write(i, 4, datetime.now(), style)

    i += 1

w.save('dates.xls')

########NEW FILE########
__FILENAME__ = format
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

font0 = Font()
font0.name = 'Times New Roman'
font0.struck_out = True
font0.bold = True

style0 = XFStyle()
style0.font = font0


wb = Workbook()
ws0 = wb.add_sheet('0')

ws0.write(1, 1, 'Test', style0)

for i in range(0, 0x53):
    fnt = Font()
    fnt.name = 'Arial'
    fnt.colour_index = i
    fnt.outline = True

    borders = Borders()
    borders.left = i

    style = XFStyle()
    style.font = fnt
    style.borders = borders

    ws0.write(i, 2, 'colour', style)
    ws0.write(i, 3, hex(i), style0)


wb.save('format.xls')

########NEW FILE########
__FILENAME__ = formulas
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

w = Workbook()
ws = w.add_sheet('F')

ws.write(0, 0, Formula("-(1+1)"))
ws.write(1, 0, Formula("-(1+1)/(-2-2)"))
ws.write(2, 0, Formula("-(134.8780789+1)"))
ws.write(3, 0, Formula("-(134.8780789e-10+1)"))
ws.write(4, 0, Formula("-1/(1+1)+9344"))

ws.write(0, 1, Formula("-(1+1)"))
ws.write(1, 1, Formula("-(1+1)/(-2-2)"))
ws.write(2, 1, Formula("-(134.8780789+1)"))
ws.write(3, 1, Formula("-(134.8780789e-10+1)"))
ws.write(4, 1, Formula("-1/(1+1)+9344"))

ws.write(0, 2, Formula("A1*B1"))
ws.write(1, 2, Formula("A2*B2"))
ws.write(2, 2, Formula("A3*B3"))
ws.write(3, 2, Formula("A4*B4*sin(pi()/4)"))
ws.write(4, 2, Formula("A5%*B5*pi()/1000"))

##############
## NOTE: parameters are separated by semicolon!!!
##############


ws.write(5, 2, Formula("C1+C2+C3+C4+C5/(C1+C2+C3+C4/(C1+C2+C3+C4/(C1+C2+C3+C4)+C5)+C5)-20.3e-2"))
ws.write(5, 3, Formula("C1^2"))
ws.write(6, 2, Formula("SUM(C1;C2;;;;;C3;;;C4)"))
ws.write(6, 3, Formula("SUM($A$1:$C$5)"))

ws.write(7, 0, Formula('"lkjljllkllkl"'))
ws.write(7, 1, Formula('"yuyiyiyiyi"'))
ws.write(7, 2, Formula('A8 & B8 & A8'))
ws.write(8, 2, Formula('now()'))

ws.write(10, 2, Formula('TRUE'))
ws.write(11, 2, Formula('FALSE'))
ws.write(12, 3, Formula('IF(A1>A2;3;"hkjhjkhk")'))

w.save('formulas.xls')

########NEW FILE########
__FILENAME__ = formula_names
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *
from xlwt.ExcelFormulaParser import FormulaParseException

w = Workbook()
ws = w.add_sheet('F')

## This example is a little silly since the formula building is
## so simplistic that it often fails because the generated text
## has the wrong number of parameters for the function being
## tested.

i = 0
succeed_count = 0
fail_count = 0
for n in sorted(ExcelMagic.std_func_by_name):
    ws.write(i, 0, n)
    text = n + "($A$1)"
    try:
        formula = Formula(text)
    except FormulaParseException,e:
        print "Could not parse %r: %s" % (text,e.args[0])
        fail_count += 1
    else:
        ws.write(i, 3, formula)
        succeed_count += 1
    i += 1

w.save('formula_names.xls')

print "succeeded with %i functions, failed with %i" % (succeed_count,fail_count)

########NEW FILE########
__FILENAME__ = hyperlinks
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

f = Font()
f.height = 20*72
f.name = 'Verdana'
f.bold = True
f.underline = Font.UNDERLINE_DOUBLE
f.colour_index = 4

h_style = XFStyle()
h_style.font = f

w = Workbook()
ws = w.add_sheet('F')

##############
## NOTE: parameters are separated by semicolon!!!
##############

n = "HYPERLINK"
ws.write_merge(1, 1, 1, 10, Formula(n + '("http://www.irs.gov/pub/irs-pdf/f1000.pdf";"f1000.pdf")'), h_style)
ws.write_merge(2, 2, 2, 25, Formula(n + '("mailto:roman.kiseliov@gmail.com?subject=pyExcelerator-feedback&Body=Hello,%20Roman!";"pyExcelerator-feedback")'), h_style)

w.save("hyperlinks.xls")

########NEW FILE########
__FILENAME__ = image
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

w = Workbook()
ws = w.add_sheet('Image')
ws.insert_bitmap('python.bmp', 2, 2)
ws.insert_bitmap('python.bmp', 10, 2)

w.save('image.xls')

########NEW FILE########
__FILENAME__ = merged
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

fnt = Font()
fnt.name = 'Arial'
fnt.colour_index = 4
fnt.bold = True

borders = Borders()
borders.left = 6
borders.right = 6
borders.top = 6
borders.bottom = 6

al = Alignment()
al.horz = Alignment.HORZ_CENTER
al.vert = Alignment.VERT_CENTER

style = XFStyle()
style.font = fnt
style.borders = borders
style.alignment = al


wb = Workbook()
ws0 = wb.add_sheet('sheet0')
ws1 = wb.add_sheet('sheet1')
ws2 = wb.add_sheet('sheet2')

for i in range(0, 0x200, 2):
    ws0.write_merge(i, i+1, 1, 5, 'test %d' % i, style)
    ws1.write_merge(i, i, 1, 7, 'test %d' % i, style)
    ws2.write_merge(i, i+1, 1, 7 + (i%10), 'test %d' % i, style)


wb.save('merged.xls')

########NEW FILE########
__FILENAME__ = merged0
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

wb = Workbook()
ws0 = wb.add_sheet('sheet0')


fnt = Font()
fnt.name = 'Arial'
fnt.colour_index = 4
fnt.bold = True

borders = Borders()
borders.left = 6
borders.right = 6
borders.top = 6
borders.bottom = 6

style = XFStyle()
style.font = fnt
style.borders = borders

ws0.write_merge(3, 3, 1, 5, 'test1', style)
ws0.write_merge(4, 10, 1, 5, 'test2', style)
ws0.col(1).width = 0x0d00

wb.save('merged0.xls')

########NEW FILE########
__FILENAME__ = merged1
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

wb = Workbook()
ws0 = wb.add_sheet('sheet0')

fnt1 = Font()
fnt1.name = 'Verdana'
fnt1.bold = True
fnt1.height = 18*0x14

pat1 = Pattern()
pat1.pattern = Pattern.SOLID_PATTERN
pat1.pattern_fore_colour = 0x16

brd1 = Borders()
brd1.left = 0x06
brd1.right = 0x06
brd1.top = 0x06
brd1.bottom = 0x06

fnt2 = Font()
fnt2.name = 'Verdana'
fnt2.bold = True
fnt2.height = 14*0x14

brd2 = Borders()
brd2.left = 0x01
brd2.right = 0x01
brd2.top = 0x01
brd2.bottom = 0x01

pat2 = Pattern()
pat2.pattern = Pattern.SOLID_PATTERN
pat2.pattern_fore_colour = 0x01F

fnt3 = Font()
fnt3.name = 'Verdana'
fnt3.bold = True
fnt3.italic = True
fnt3.height = 12*0x14

brd3 = Borders()
brd3.left = 0x07
brd3.right = 0x07
brd3.top = 0x07
brd3.bottom = 0x07

fnt4 = Font()

al1 = Alignment()
al1.horz = Alignment.HORZ_CENTER
al1.vert = Alignment.VERT_CENTER

al2 = Alignment()
al2.horz = Alignment.HORZ_RIGHT
al2.vert = Alignment.VERT_CENTER

al3 = Alignment()
al3.horz = Alignment.HORZ_LEFT
al3.vert = Alignment.VERT_CENTER

style1 = XFStyle()
style1.font = fnt1
style1.alignment = al1
style1.pattern = pat1
style1.borders = brd1

style2 = XFStyle()
style2.font = fnt2
style2.alignment = al1
style2.pattern = pat2
style2.borders = brd2

style3 = XFStyle()
style3.font = fnt3
style3.alignment = al1
style3.pattern = pat2
style3.borders = brd3

price_style = XFStyle()
price_style.font = fnt4
price_style.alignment = al2
price_style.borders = brd3
price_style.num_format_str = '_(#,##0.00_) "money"'

ware_style = XFStyle()
ware_style.font = fnt4
ware_style.alignment = al3
ware_style.borders = brd3


ws0.merge(3, 3, 1, 5, style1)
ws0.merge(4, 10, 1, 6, style2)
ws0.merge(14, 16, 1, 7, style3)
ws0.col(1).width = 0x0d00


wb.save('merged1.xls')

########NEW FILE########
__FILENAME__ = mini
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

w = Workbook()
ws = w.add_sheet('xlwt was here')
w.save('mini.xls')

########NEW FILE########
__FILENAME__ = numbers
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

w = Workbook()
ws = w.add_sheet('Hey, Dude')

ws.write(0, 0, 1)
ws.write(1, 0, 1.23)
ws.write(2, 0, 12345678)
ws.write(3, 0, 123456.78)

ws.write(0, 1, -1)
ws.write(1, 1, -1.23)
ws.write(2, 1, -12345678)
ws.write(3, 1, -123456.78)

ws.write(0, 2, -17867868678687.0)
ws.write(1, 2, -1.23e-5)
ws.write(2, 2, -12345678.90780980)
ws.write(3, 2, -123456.78)

w.save('numbers.xls')

########NEW FILE########
__FILENAME__ = num_formats
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

w = Workbook()
ws = w.add_sheet('Hey, Dude')

fmts = [
    'general',
    '0',
    '0.00',
    '#,##0',
    '#,##0.00',
    '"$"#,##0_);("$"#,##',
    '"$"#,##0_);[Red]("$"#,##',
    '"$"#,##0.00_);("$"#,##',
    '"$"#,##0.00_);[Red]("$"#,##',
    '0%',
    '0.00%',
    '0.00E+00',
    '# ?/?',
    '# ??/??',
    'M/D/YY',
    'D-MMM-YY',
    'D-MMM',
    'MMM-YY',
    'h:mm AM/PM',
    'h:mm:ss AM/PM',
    'h:mm',
    'h:mm:ss',
    'M/D/YY h:mm',
    '_(#,##0_);(#,##0)',
    '_(#,##0_);[Red](#,##0)',
    '_(#,##0.00_);(#,##0.00)',
    '_(#,##0.00_);[Red](#,##0.00)',
    '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',
    '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
    '_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',
    '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',
    'mm:ss',
    '[h]:mm:ss',
    'mm:ss.0',
    '##0.0E+0',
    '@'   
]

i = 0
for fmt in fmts:
    ws.write(i, 0, fmt)

    style = XFStyle()
    style.num_format_str = fmt

    ws.write(i, 4, -1278.9078, style)

    i += 1

w.save('num_formats.xls')

########NEW FILE########
__FILENAME__ = outline
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

fnt = Font()
fnt.name = 'Arial'
fnt.colour_index = 4
fnt.bold = True

borders = Borders()
borders.left = 6
borders.right = 6
borders.top = 6
borders.bottom = 6

style = XFStyle()
style.font = fnt
style.borders = borders

wb = Workbook()

ws0 = wb.add_sheet('Rows Outline')

ws0.write_merge(1, 1, 1, 5, 'test 1', style)
ws0.write_merge(2, 2, 1, 4, 'test 1', style)
ws0.write_merge(3, 3, 1, 3, 'test 2', style)
ws0.write_merge(4, 4, 1, 4, 'test 1', style)
ws0.write_merge(5, 5, 1, 4, 'test 3', style)
ws0.write_merge(6, 6, 1, 5, 'test 1', style)
ws0.write_merge(7, 7, 1, 5, 'test 4', style)
ws0.write_merge(8, 8, 1, 4, 'test 1', style)
ws0.write_merge(9, 9, 1, 3, 'test 5', style)

ws0.row(1).level = 1
ws0.row(2).level = 1
ws0.row(3).level = 2
ws0.row(4).level = 2
ws0.row(5).level = 2
ws0.row(6).level = 2
ws0.row(7).level = 2
ws0.row(8).level = 1
ws0.row(9).level = 1


ws1 = wb.add_sheet('Columns Outline')

ws1.write_merge(1, 1, 1, 5, 'test 1', style)
ws1.write_merge(2, 2, 1, 4, 'test 1', style)
ws1.write_merge(3, 3, 1, 3, 'test 2', style)
ws1.write_merge(4, 4, 1, 4, 'test 1', style)
ws1.write_merge(5, 5, 1, 4, 'test 3', style)
ws1.write_merge(6, 6, 1, 5, 'test 1', style)
ws1.write_merge(7, 7, 1, 5, 'test 4', style)
ws1.write_merge(8, 8, 1, 4, 'test 1', style)
ws1.write_merge(9, 9, 1, 3, 'test 5', style)

ws1.col(1).level = 1
ws1.col(2).level = 1
ws1.col(3).level = 2
ws1.col(4).level = 2
ws1.col(5).level = 2
ws1.col(6).level = 2
ws1.col(7).level = 2
ws1.col(8).level = 1
ws1.col(9).level = 1


ws2 = wb.add_sheet('Rows and Columns Outline')

ws2.write_merge(1, 1, 1, 5, 'test 1', style)
ws2.write_merge(2, 2, 1, 4, 'test 1', style)
ws2.write_merge(3, 3, 1, 3, 'test 2', style)
ws2.write_merge(4, 4, 1, 4, 'test 1', style)
ws2.write_merge(5, 5, 1, 4, 'test 3', style)
ws2.write_merge(6, 6, 1, 5, 'test 1', style)
ws2.write_merge(7, 7, 1, 5, 'test 4', style)
ws2.write_merge(8, 8, 1, 4, 'test 1', style)
ws2.write_merge(9, 9, 1, 3, 'test 5', style)

ws2.row(1).level = 1
ws2.row(2).level = 1
ws2.row(3).level = 2
ws2.row(4).level = 2
ws2.row(5).level = 2
ws2.row(6).level = 2
ws2.row(7).level = 2
ws2.row(8).level = 1
ws2.row(9).level = 1

ws2.write_merge(1, 1, 1, 5, 'test 1', style)
ws2.write_merge(2, 2, 1, 4, 'test 1', style)
ws2.write_merge(3, 3, 1, 3, 'test 2', style)
ws2.write_merge(4, 4, 1, 4, 'test 1', style)
ws2.write_merge(5, 5, 1, 4, 'test 3', style)
ws2.write_merge(6, 6, 1, 5, 'test 1', style)
ws2.write_merge(7, 7, 1, 5, 'test 4', style)
ws2.write_merge(8, 8, 1, 4, 'test 1', style)
ws2.write_merge(9, 9, 1, 3, 'test 5', style)

ws2.col(1).level = 1
ws2.col(2).level = 1
ws2.col(3).level = 2
ws2.col(4).level = 2
ws2.col(5).level = 2
ws2.col(6).level = 2
ws2.col(7).level = 2
ws2.col(8).level = 1
ws2.col(9).level = 1


wb.save('outline.xls')

########NEW FILE########
__FILENAME__ = panes
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

w = Workbook()
ws1 = w.add_sheet('sheet 1')
ws2 = w.add_sheet('sheet 2')
ws3 = w.add_sheet('sheet 3')
ws4 = w.add_sheet('sheet 4')
ws5 = w.add_sheet('sheet 5')
ws6 = w.add_sheet('sheet 6')

for i in range(0x100):
    ws1.write(i/0x10, i%0x10, i)

for i in range(0x100):
    ws2.write(i/0x10, i%0x10, i)

for i in range(0x100):
    ws3.write(i/0x10, i%0x10, i)

for i in range(0x100):
    ws4.write(i/0x10, i%0x10, i)

for i in range(0x100):
    ws5.write(i/0x10, i%0x10, i)

for i in range(0x100):
    ws6.write(i/0x10, i%0x10, i)

ws1.panes_frozen = True
ws1.horz_split_pos = 2

ws2.panes_frozen = True
ws2.vert_split_pos = 2

ws3.panes_frozen = True
ws3.horz_split_pos = 1
ws3.vert_split_pos = 1

ws4.panes_frozen = False
ws4.horz_split_pos = 12
ws4.horz_split_first_visible = 2

ws5.panes_frozen = False
ws5.vert_split_pos = 40
ws4.vert_split_first_visible = 2

ws6.panes_frozen = False
ws6.horz_split_pos = 12
ws4.horz_split_first_visible = 2
ws6.vert_split_pos = 40
ws4.vert_split_first_visible = 2

w.save('panes.xls')


########NEW FILE########
__FILENAME__ = parse-fmla
from xlwt import ExcelFormulaParser, ExcelFormula
import sys

f = ExcelFormula.Formula(
""" -((1.80 + 2.898 * 1)/(1.80 + 2.898))*
AVERAGE((1.80 + 2.898 * 1)/(1.80 + 2.898); 
        (1.80 + 2.898 * 1)/(1.80 + 2.898); 
        (1.80 + 2.898 * 1)/(1.80 + 2.898)) + 
SIN(PI()/4)""")

#for t in f.rpn():
#    print "%15s %15s" % (ExcelFormulaParser.PtgNames[t[0]], t[1])

########NEW FILE########
__FILENAME__ = protection
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

fnt = Font()
fnt.name = 'Arial'
fnt.colour_index = 4
fnt.bold = True

borders = Borders()
borders.left = 6
borders.right = 6
borders.top = 6
borders.bottom = 6

style = XFStyle()
style.font = fnt
style.borders = borders

wb = Workbook()

ws0 = wb.add_sheet('Rows Outline')

ws0.write_merge(1, 1, 1, 5, 'test 1', style)
ws0.write_merge(2, 2, 1, 4, 'test 1', style)
ws0.write_merge(3, 3, 1, 3, 'test 2', style)
ws0.write_merge(4, 4, 1, 4, 'test 1', style)
ws0.write_merge(5, 5, 1, 4, 'test 3', style)
ws0.write_merge(6, 6, 1, 5, 'test 1', style)
ws0.write_merge(7, 7, 1, 5, 'test 4', style)
ws0.write_merge(8, 8, 1, 4, 'test 1', style)
ws0.write_merge(9, 9, 1, 3, 'test 5', style)

ws0.row(1).level = 1
ws0.row(2).level = 1
ws0.row(3).level = 2
ws0.row(4).level = 2
ws0.row(5).level = 2
ws0.row(6).level = 2
ws0.row(7).level = 2
ws0.row(8).level = 1
ws0.row(9).level = 1


ws1 = wb.add_sheet('Columns Outline')

ws1.write_merge(1, 1, 1, 5, 'test 1', style)
ws1.write_merge(2, 2, 1, 4, 'test 1', style)
ws1.write_merge(3, 3, 1, 3, 'test 2', style)
ws1.write_merge(4, 4, 1, 4, 'test 1', style)
ws1.write_merge(5, 5, 1, 4, 'test 3', style)
ws1.write_merge(6, 6, 1, 5, 'test 1', style)
ws1.write_merge(7, 7, 1, 5, 'test 4', style)
ws1.write_merge(8, 8, 1, 4, 'test 1', style)
ws1.write_merge(9, 9, 1, 3, 'test 5', style)

ws1.col(1).level = 1
ws1.col(2).level = 1
ws1.col(3).level = 2
ws1.col(4).level = 2
ws1.col(5).level = 2
ws1.col(6).level = 2
ws1.col(7).level = 2
ws1.col(8).level = 1
ws1.col(9).level = 1


ws2 = wb.add_sheet('Rows and Columns Outline')

ws2.write_merge(1, 1, 1, 5, 'test 1', style)
ws2.write_merge(2, 2, 1, 4, 'test 1', style)
ws2.write_merge(3, 3, 1, 3, 'test 2', style)
ws2.write_merge(4, 4, 1, 4, 'test 1', style)
ws2.write_merge(5, 5, 1, 4, 'test 3', style)
ws2.write_merge(6, 6, 1, 5, 'test 1', style)
ws2.write_merge(7, 7, 1, 5, 'test 4', style)
ws2.write_merge(8, 8, 1, 4, 'test 1', style)
ws2.write_merge(9, 9, 1, 3, 'test 5', style)

ws2.row(1).level = 1
ws2.row(2).level = 1
ws2.row(3).level = 2
ws2.row(4).level = 2
ws2.row(5).level = 2
ws2.row(6).level = 2
ws2.row(7).level = 2
ws2.row(8).level = 1
ws2.row(9).level = 1

ws2.col(1).level = 1
ws2.col(2).level = 1
ws2.col(3).level = 2
ws2.col(4).level = 2
ws2.col(5).level = 2
ws2.col(6).level = 2
ws2.col(7).level = 2
ws2.col(8).level = 1
ws2.col(9).level = 1


ws0.protect = True
ws0.wnd_protect = True
ws0.obj_protect = True
ws0.scen_protect = True
ws0.password = "123456"

ws1.protect = True
ws1.wnd_protect = True
ws1.obj_protect = True
ws1.scen_protect = True
ws1.password = "abcdefghij"

ws2.protect = True
ws2.wnd_protect = True
ws2.obj_protect = True
ws2.scen_protect = True
ws2.password = "ok"

wb.protect = True
wb.wnd_protect = True
wb.obj_protect = True
wb.save('protection.xls')

########NEW FILE########
__FILENAME__ = row_styles
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

w = Workbook()
ws = w.add_sheet('Hey, Dude')

for i in range(6, 80):
    fnt = Font()
    fnt.height = i*20
    style = XFStyle()
    style.font = fnt
    ws.write(i, 1, 'Test')
    ws.row(i).set_style(style)
w.save('row_styles.xls')

########NEW FILE########
__FILENAME__ = row_styles_empty
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman
__rev_id__ = """$Id: row_styles_empty.py 3309 2008-03-14 11:04:30Z chris $"""


from pyExcelerator import *

w = Workbook()
ws = w.add_sheet('Hey, Dude')

for i in range(6, 80):
    fnt = Font()
    fnt.height = i*20
    style = XFStyle()
    style.font = fnt
    ws.row(i).set_style(style)
w.save('row_styles_empty.xls')

########NEW FILE########
__FILENAME__ = simple
import xlwt
from datetime import datetime

font0 = xlwt.Font()
font0.name = 'Times New Roman'
font0.colour_index = 2
font0.bold = True

style0 = xlwt.XFStyle()
style0.font = font0

style1 = xlwt.XFStyle()
style1.num_format_str = 'D-MMM-YY'

wb = xlwt.Workbook()
ws = wb.add_sheet('A Test Sheet')

ws.write(0, 0, 'Test', style0)
ws.write(1, 0, datetime.now(), style1)
ws.write(2, 0, 1)
ws.write(2, 1, 1)
ws.write(2, 2, xlwt.Formula("A3+B3"))

wb.save('example.xls')

########NEW FILE########
__FILENAME__ = sst
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

font0 = Formatting.Font()
font0.name = 'Arial'
font1 = Formatting.Font()
font1.name = 'Arial Cyr'
font2 = Formatting.Font()
font2.name = 'Times New Roman'
font3 = Formatting.Font()
font3.name = 'Courier New Cyr'

num_format0 = '0.00000'
num_format1 = '0.000000'
num_format2 = '0.0000000'
num_format3 = '0.00000000'

st0 = XFStyle()
st1 = XFStyle()
st2 = XFStyle()
st3 = XFStyle()
st4 = XFStyle()

st0.font = font0
st0.num_format = num_format0

st1.font = font1
st1.num_format = num_format1

st2.font = font2
st2.num_format = num_format2

st3.font = font3
st3.num_format = num_format3

wb = Workbook()

wb.add_style(st0)
wb.add_style(st1)
wb.add_style(st2)
wb.add_style(st3)

ws0 = wb.add_sheet('0')
ws0.write(0, 0, 'Olya'*0x4000, st0)

#for i in range(0, 0x10):
#    ws0.write(i, 2, ('%d'%i)*0x4000, st1)
    
wb.save('sst.xls')

########NEW FILE########
__FILENAME__ = unicode0
#!/usr/bin/env python
import xlwt

# Strings passed to (for example) Worksheet.write can be unicode objects,
# or str (8-bit) objects, which are then decoded into unicode.
# The encoding to be used defaults to 'ascii'. This can be overridden
# when the Workbook instance is created:

book = xlwt.Workbook(encoding='cp1251')
sheet = book.add_sheet('cp1251-demo')
sheet.write(0, 0, '\xce\xeb\xff')
book.save('unicode0.xls')

########NEW FILE########
__FILENAME__ = unicode1
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

w = Workbook()
ws1 = w.add_sheet(u'\N{GREEK SMALL LETTER ALPHA}\N{GREEK SMALL LETTER BETA}\N{GREEK SMALL LETTER GAMMA}')

ws1.write(0, 0, u'\N{GREEK SMALL LETTER ALPHA}\N{GREEK SMALL LETTER BETA}\N{GREEK SMALL LETTER GAMMA}')
ws1.write(1, 1, u'\N{GREEK SMALL LETTER DELTA}x = 1 + \N{GREEK SMALL LETTER DELTA}')

ws1.write(2,0, u'A\u2262\u0391.')     # RFC2152 example
ws1.write(3,0, u'Hi Mom -\u263a-!')   # RFC2152 example
ws1.write(4,0, u'\u65E5\u672C\u8A9E') # RFC2152 example
ws1.write(5,0, u'Item 3 is \u00a31.') # RFC2152 example
ws1.write(8,0, u'\N{INTEGRAL}')       # RFC2152 example

w.add_sheet(u'A\u2262\u0391.')     # RFC2152 example
w.add_sheet(u'Hi Mom -\u263a-!')   # RFC2152 example
one_more_ws = w.add_sheet(u'\u65E5\u672C\u8A9E') # RFC2152 example
w.add_sheet(u'Item 3 is \u00a31.') # RFC2152 example

one_more_ws.write(0, 0, u'\u2665\u2665')

w.add_sheet(u'\N{GREEK SMALL LETTER ETA WITH TONOS}')
w.save('unicode1.xls')


########NEW FILE########
__FILENAME__ = unicode2
#!/usr/bin/env python
# -*- coding: windows-1251 -*-
# Copyright (C) 2005 Kiseliov Roman

from xlwt import *

w = Workbook()
ws1 = w.add_sheet(u'\N{GREEK SMALL LETTER ALPHA}\N{GREEK SMALL LETTER BETA}\N{GREEK SMALL LETTER GAMMA}\u2665\u041e\u041b\u042f\u2665')

fnt = Font()
fnt.height = 26*20
style = XFStyle()
style.font = fnt

for i in range(0x10000):
    ws1.write(i/0x10, i%0x10, unichr(i), style)

w.save('unicode2.xls')


########NEW FILE########
__FILENAME__ = wsprops
props = \
[
        'name',
        'parent',
        'rows',
        'cols',
        'merged_ranges',
        'bmp_rec',
        'show_formulas',
        'show_grid',
        'show_headers',
        'panes_frozen',
        'show_empty_as_zero',
        'auto_colour_grid',
        'cols_right_to_left',
        'show_outline',
        'remove_splits',
        'selected',
        'hidden',
        'page_preview',
        'first_visible_row',
        'first_visible_col',
        'grid_colour',
        'preview_magn',
        'normal_magn',
        'row_gut_width',
        'col_gut_height',
        'show_auto_page_breaks',
        'dialogue_sheet',
        'auto_style_outline',
        'outline_below',
        'outline_right',
        'fit_num_pages',
        'show_row_outline',
        'show_col_outline',
        'alt_expr_eval',
        'alt_formula_entries',
        'row_default_height',
        'col_default_width',
        'calc_mode',
        'calc_count',
        'RC_ref_mode',
        'iterations_on',
        'delta',
        'save_recalc',
        'print_headers',
        'print_grid',
        'grid_set',
        'vert_page_breaks',
        'horz_page_breaks',
        'header_str',
        'footer_str',
        'print_centered_vert',
        'print_centered_horz',
        'left_margin',
        'right_margin',
        'top_margin',
        'bottom_margin',
        'paper_size_code',
        'print_scaling',
        'start_page_number',
        'fit_width_to_pages',
        'fit_height_to_pages',
        'print_in_rows',
        'portrait',
        'print_not_colour',
        'print_draft',
        'print_notes',
        'print_notes_at_end',
        'print_omit_errors',
        'print_hres',
        'print_vres',
        'header_margin',
        'footer_margin',
        'copies_num',
]

from xlwt import *

wb = Workbook()
ws = wb.add_sheet('sheet')

print ws.name
print ws.parent
print ws.rows
print ws.cols
print ws.merged_ranges
print ws.bmp_rec
print ws.show_formulas
print ws.show_grid
print ws.show_headers
print ws.panes_frozen
print ws.show_empty_as_zero
print ws.auto_colour_grid
print ws.cols_right_to_left
print ws.show_outline
print ws.remove_splits
print ws.selected
# print ws.hidden
print ws.page_preview
print ws.first_visible_row
print ws.first_visible_col
print ws.grid_colour
print ws.preview_magn
print ws.normal_magn
#print ws.row_gut_width
#print ws.col_gut_height
print ws.show_auto_page_breaks
print ws.dialogue_sheet
print ws.auto_style_outline
print ws.outline_below
print ws.outline_right
print ws.fit_num_pages
print ws.show_row_outline
print ws.show_col_outline
print ws.alt_expr_eval
print ws.alt_formula_entries
print ws.row_default_height
print ws.col_default_width
print ws.calc_mode
print ws.calc_count
print ws.RC_ref_mode
print ws.iterations_on
print ws.delta
print ws.save_recalc
print ws.print_headers
print ws.print_grid
#print ws.grid_set
print ws.vert_page_breaks
print ws.horz_page_breaks
print ws.header_str
print ws.footer_str
print ws.print_centered_vert
print ws.print_centered_horz
print ws.left_margin
print ws.right_margin
print ws.top_margin
print ws.bottom_margin
print ws.paper_size_code
print ws.print_scaling
print ws.start_page_number
print ws.fit_width_to_pages
print ws.fit_height_to_pages
print ws.print_in_rows
print ws.portrait
print ws.print_colour
print ws.print_draft
print ws.print_notes
print ws.print_notes_at_end
print ws.print_omit_errors
print ws.print_hres
print ws.print_vres
print ws.header_margin
print ws.footer_margin
print ws.copies_num

########NEW FILE########
__FILENAME__ = xlwt_easyxf_simple_demo

# Write an XLS file with a single worksheet, containing
# a heading row and some rows of data.

import xlwt
import datetime
ezxf = xlwt.easyxf

def write_xls(file_name, sheet_name, headings, data, heading_xf, data_xfs):
    book = xlwt.Workbook()
    sheet = book.add_sheet(sheet_name)
    rowx = 0
    for colx, value in enumerate(headings):
        sheet.write(rowx, colx, value, heading_xf)
    sheet.set_panes_frozen(True) # frozen headings instead of split panes
    sheet.set_horz_split_pos(rowx+1) # in general, freeze after last heading row
    sheet.set_remove_splits(True) # if user does unfreeze, don't leave a split there
    for row in data:
        rowx += 1
        for colx, value in enumerate(row):
            sheet.write(rowx, colx, value, data_xfs[colx])
    book.save(file_name)

if __name__ == '__main__':
    import sys
    mkd = datetime.date
    hdngs = ['Date', 'Stock Code', 'Quantity', 'Unit Price', 'Value', 'Message']
    kinds =  'date    text          int         price         money    text'.split()
    data = [
        [mkd(2007, 7, 1), 'ABC', 1000, 1.234567, 1234.57, ''],
        [mkd(2007, 12, 31), 'XYZ', -100, 4.654321, -465.43, 'Goods returned'],
        ] + [
            [mkd(2008, 6, 30), 'PQRCD', 100, 2.345678, 234.57, ''],
        ] * 100

    heading_xf = ezxf('font: bold on; align: wrap on, vert centre, horiz center')
    kind_to_xf_map = {
        'date': ezxf(num_format_str='yyyy-mm-dd'),
        'int': ezxf(num_format_str='#,##0'),
        'money': ezxf('font: italic on; pattern: pattern solid, fore-colour grey25',
            num_format_str='$#,##0.00'),
        'price': ezxf(num_format_str='#0.000000'),
        'text': ezxf(),
        }
    data_xfs = [kind_to_xf_map[k] for k in kinds]
    write_xls('xlwt_easyxf_simple_demo.xls', 'Demo', hdngs, data, heading_xf, data_xfs)

########NEW FILE########
__FILENAME__ = ExcelFormula
# -*- coding: windows-1252 -*-

import ExcelFormulaParser, ExcelFormulaLexer
import struct
from antlr import ANTLRException


class Formula(object):
    __slots__ = ["__init__",  "__s", "__parser", "__sheet_refs", "__xcall_refs"]


    def __init__(self, s):
        try:
            self.__s = s
            lexer = ExcelFormulaLexer.Lexer(s)
            self.__parser = ExcelFormulaParser.Parser(lexer)
            self.__parser.formula()
            self.__sheet_refs = self.__parser.sheet_references
            self.__xcall_refs = self.__parser.xcall_references
        except ANTLRException, e:
            # print e
            raise ExcelFormulaParser.FormulaParseException, "can't parse formula " + s

    def get_references(self):
        return self.__sheet_refs, self.__xcall_refs

    def patch_references(self, patches):
        for offset, idx in patches:
            self.__parser.rpn = self.__parser.rpn[:offset] + struct.pack('<H', idx) + self.__parser.rpn[offset+2:]

    def text(self):
        return self.__s

    def rpn(self):
        '''
        Offset    Size    Contents
        0         2       Size of the following formula data (sz)
        2         sz      Formula data (RPN token array)
        [2+sz]    var.    (optional) Additional data for specific tokens

        '''
        return struct.pack("<H", len(self.__parser.rpn)) + self.__parser.rpn


########NEW FILE########
__FILENAME__ = ExcelFormulaLexer
# -*- coding: windows-1252 -*-

import sys
from antlr import EOF, CommonToken as Tok, TokenStream, TokenStreamException
import struct
import ExcelFormulaParser
from re import compile as recompile, match, LOCALE, UNICODE, IGNORECASE, VERBOSE


int_const_pattern = r"\d+\b"
flt_const_pattern = r"""
    (?:
        (?: \d* \. \d+ ) # .1 .12 .123 etc 9.1 etc 98.1 etc
        |
        (?: \d+ \. ) # 1. 12. 123. etc
    )
    # followed by optional exponent part
    (?: [Ee] [+-]? \d+ ) ?
    """
str_const_pattern = r'"(?:[^"]|"")*"'
#range2d_pattern   = recompile(r"\$?[A-I]?[A-Z]\$?\d+:\$?[A-I]?[A-Z]\$?\d+"
ref2d_r1c1_pattern = r"[Rr]0*[1-9][0-9]*[Cc]0*[1-9][0-9]*"
ref2d_pattern     = r"\$?[A-I]?[A-Z]\$?0*[1-9][0-9]*"
true_pattern      = r"TRUE\b"
false_pattern     = r"FALSE\b"
if_pattern        = r"IF\b"
choose_pattern    = r"CHOOSE\b"
name_pattern      = r"\w[\.\w]*"
quotename_pattern = r"'(?:[^']|'')*'" #### It's essential that this bracket be non-grouping.
ne_pattern        = r"<>"
ge_pattern        = r">="
le_pattern        = r"<="

pattern_type_tuples = (
    (flt_const_pattern, ExcelFormulaParser.NUM_CONST),
    (int_const_pattern, ExcelFormulaParser.INT_CONST),
    (str_const_pattern, ExcelFormulaParser.STR_CONST),
#    (range2d_pattern  , ExcelFormulaParser.RANGE2D),
    (ref2d_r1c1_pattern, ExcelFormulaParser.REF2D_R1C1),
    (ref2d_pattern    , ExcelFormulaParser.REF2D),
    (true_pattern     , ExcelFormulaParser.TRUE_CONST),
    (false_pattern    , ExcelFormulaParser.FALSE_CONST),
    (if_pattern       , ExcelFormulaParser.FUNC_IF),
    (choose_pattern   , ExcelFormulaParser.FUNC_CHOOSE),
    (name_pattern     , ExcelFormulaParser.NAME),
    (quotename_pattern, ExcelFormulaParser.QUOTENAME),
    (ne_pattern,        ExcelFormulaParser.NE),
    (ge_pattern,        ExcelFormulaParser.GE),
    (le_pattern,        ExcelFormulaParser.LE),
)

_re = recompile(
    '(' + ')|('.join([i[0] for i in pattern_type_tuples]) + ')',
    VERBOSE+LOCALE+IGNORECASE)

_toktype = [None] + [i[1] for i in pattern_type_tuples]
# need dummy at start because re.MatchObject.lastindex counts from 1

single_char_lookup = {
    '=': ExcelFormulaParser.EQ,
    '<': ExcelFormulaParser.LT,
    '>': ExcelFormulaParser.GT,
    '+': ExcelFormulaParser.ADD,
    '-': ExcelFormulaParser.SUB,
    '*': ExcelFormulaParser.MUL,
    '/': ExcelFormulaParser.DIV,
    ':': ExcelFormulaParser.COLON,
    ';': ExcelFormulaParser.SEMICOLON,
    ',': ExcelFormulaParser.COMMA,
    '(': ExcelFormulaParser.LP,
    ')': ExcelFormulaParser.RP,
    '&': ExcelFormulaParser.CONCAT,
    '%': ExcelFormulaParser.PERCENT,
    '^': ExcelFormulaParser.POWER,
    '!': ExcelFormulaParser.BANG,
    }

class Lexer(TokenStream):
    def __init__(self, text):
        self._text = text[:]
        self._pos = 0
        self._line = 0

    def isEOF(self):
        return len(self._text) <= self._pos

    def curr_ch(self):
        return self._text[self._pos]

    def next_ch(self, n = 1):
        self._pos += n

    def is_whitespace(self):
        return self.curr_ch() in " \t\n\r\f\v"

    def match_pattern(self):
        m = _re.match(self._text, self._pos)
        if not m:
            return None
        self._pos = m.end(0)
        return Tok(type = _toktype[m.lastindex], text = m.group(0), col = m.start(0) + 1)

    def nextToken(self):
        # skip whitespace
        while not self.isEOF() and self.is_whitespace():
            self.next_ch()
        if self.isEOF():
            return Tok(type = EOF)
        # first, try to match token with 2 or more chars
        t = self.match_pattern()
        if t:
            return t
        # second, we want 1-char tokens
        te = self.curr_ch()
        try:
            ty = single_char_lookup[te]
        except KeyError:
            raise TokenStreamException(
                "Unexpected char %r in column %u." % (self.curr_ch(), self._pos))
        self.next_ch()
        return Tok(type=ty, text=te, col=self._pos)

if __name__ == '__main__':
    try:
        for t in Lexer(""" 1.23 456 "abcd" R2C2 a1 iv65536 true false if choose a_name 'qname' <> >= <= """):
            print t
    except TokenStreamException, e:
        print "error:", e

########NEW FILE########
__FILENAME__ = ExcelFormulaParser
### $ANTLR 2.7.7 (20060930): "xlwt/excel-formula.g" -> "ExcelFormulaParser.py"$
### import antlr and other modules ..
import sys
import antlr

version = sys.version.split()[0]
if version < '2.2.1':
    False = 0
if version < '2.3':
    True = not False
### header action >>>
import struct
import Utils
from UnicodeUtils import upack1
from ExcelMagic import *

_RVAdelta =     {"R": 0, "V": 0x20, "A": 0x40}
_RVAdeltaRef =  {"R": 0, "V": 0x20, "A": 0x40, "D": 0x20}
_RVAdeltaArea = {"R": 0, "V": 0x20, "A": 0x40, "D": 0}


class FormulaParseException(Exception):
   """
   An exception indicating that a Formula could not be successfully parsed.
   """
### header action <<<
### preamble action>>>

### preamble action <<<

### import antlr.Token
from antlr import Token
### >>>The Known Token Types <<<
SKIP                = antlr.SKIP
INVALID_TYPE        = antlr.INVALID_TYPE
EOF_TYPE            = antlr.EOF_TYPE
EOF                 = antlr.EOF
NULL_TREE_LOOKAHEAD = antlr.NULL_TREE_LOOKAHEAD
MIN_USER_TYPE       = antlr.MIN_USER_TYPE
TRUE_CONST = 4
FALSE_CONST = 5
STR_CONST = 6
NUM_CONST = 7
INT_CONST = 8
FUNC_IF = 9
FUNC_CHOOSE = 10
NAME = 11
QUOTENAME = 12
EQ = 13
NE = 14
GT = 15
LT = 16
GE = 17
LE = 18
ADD = 19
SUB = 20
MUL = 21
DIV = 22
POWER = 23
PERCENT = 24
LP = 25
RP = 26
LB = 27
RB = 28
COLON = 29
COMMA = 30
SEMICOLON = 31
REF2D = 32
REF2D_R1C1 = 33
BANG = 34
CONCAT = 35

class Parser(antlr.LLkParser):
    ### user action >>>
    ### user action <<<

    def __init__(self, *args, **kwargs):
        antlr.LLkParser.__init__(self, *args, **kwargs)
        self.tokenNames = _tokenNames
        ### __init__ header action >>>
        self.rpn = ""
        self.sheet_references = []
        self.xcall_references = []
        ### __init__ header action <<<

    def formula(self):

        pass
        self.expr("V")

    def expr(self,
        arg_type
    ):

        pass
        self.prec0_expr(arg_type)
        while True:
            if ((self.LA(1) >= EQ and self.LA(1) <= LE)):
                pass
                la1 = self.LA(1)
                if False:
                    pass
                elif la1 and la1 in [EQ]:
                    pass
                    self.match(EQ)
                    op = struct.pack('B', ptgEQ)
                elif la1 and la1 in [NE]:
                    pass
                    self.match(NE)
                    op = struct.pack('B', ptgNE)
                elif la1 and la1 in [GT]:
                    pass
                    self.match(GT)
                    op = struct.pack('B', ptgGT)
                elif la1 and la1 in [LT]:
                    pass
                    self.match(LT)
                    op = struct.pack('B', ptgLT)
                elif la1 and la1 in [GE]:
                    pass
                    self.match(GE)
                    op = struct.pack('B', ptgGE)
                elif la1 and la1 in [LE]:
                    pass
                    self.match(LE)
                    op = struct.pack('B', ptgLE)
                else:
                        raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                self.prec0_expr(arg_type)
                self.rpn += op
            else:
                break


    def prec0_expr(self,
        arg_type
    ):

        pass
        self.prec1_expr(arg_type)
        while True:
            if (self.LA(1)==CONCAT):
                pass
                pass
                self.match(CONCAT)
                op = struct.pack('B', ptgConcat)
                self.prec1_expr(arg_type)
                self.rpn += op
            else:
                break


    def prec1_expr(self,
        arg_type
    ):

        pass
        self.prec2_expr(arg_type)
        while True:
            if (self.LA(1)==ADD or self.LA(1)==SUB):
                pass
                la1 = self.LA(1)
                if False:
                    pass
                elif la1 and la1 in [ADD]:
                    pass
                    self.match(ADD)
                    op = struct.pack('B', ptgAdd)
                elif la1 and la1 in [SUB]:
                    pass
                    self.match(SUB)
                    op = struct.pack('B', ptgSub)
                else:
                        raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                self.prec2_expr(arg_type)
                self.rpn += op;
                          # print "**prec1_expr4 %s" % arg_type
            else:
                break


    def prec2_expr(self,
        arg_type
    ):

        pass
        self.prec3_expr(arg_type)
        while True:
            if (self.LA(1)==MUL or self.LA(1)==DIV):
                pass
                la1 = self.LA(1)
                if False:
                    pass
                elif la1 and la1 in [MUL]:
                    pass
                    self.match(MUL)
                    op = struct.pack('B', ptgMul)
                elif la1 and la1 in [DIV]:
                    pass
                    self.match(DIV)
                    op = struct.pack('B', ptgDiv)
                else:
                        raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                self.prec3_expr(arg_type)
                self.rpn += op
            else:
                break


    def prec3_expr(self,
        arg_type
    ):

        pass
        self.prec4_expr(arg_type)
        while True:
            if (self.LA(1)==POWER):
                pass
                pass
                self.match(POWER)
                op = struct.pack('B', ptgPower)
                self.prec4_expr(arg_type)
                self.rpn += op
            else:
                break


    def prec4_expr(self,
        arg_type
    ):

        pass
        self.prec5_expr(arg_type)
        la1 = self.LA(1)
        if False:
            pass
        elif la1 and la1 in [PERCENT]:
            pass
            self.match(PERCENT)
            self.rpn += struct.pack('B', ptgPercent)
        elif la1 and la1 in [EOF,EQ,NE,GT,LT,GE,LE,ADD,SUB,MUL,DIV,POWER,RP,COMMA,SEMICOLON,CONCAT]:
            pass
        else:
                raise antlr.NoViableAltException(self.LT(1), self.getFilename())


    def prec5_expr(self,
        arg_type
    ):

        la1 = self.LA(1)
        if False:
            pass
        elif la1 and la1 in [TRUE_CONST,FALSE_CONST,STR_CONST,NUM_CONST,INT_CONST,FUNC_IF,FUNC_CHOOSE,NAME,QUOTENAME,LP,REF2D]:
            pass
            self.primary(arg_type)
        elif la1 and la1 in [SUB]:
            pass
            self.match(SUB)
            self.primary(arg_type)
            self.rpn += struct.pack('B', ptgUminus)
        else:
                raise antlr.NoViableAltException(self.LT(1), self.getFilename())


    def primary(self,
        arg_type
    ):

        str_tok = None
        int_tok = None
        num_tok = None
        ref2d_tok = None
        ref2d1_tok = None
        ref2d2_tok = None
        ref3d_ref2d = None
        ref3d_ref2d2 = None
        name_tok = None
        func_tok = None
        la1 = self.LA(1)
        if False:
            pass
        elif la1 and la1 in [TRUE_CONST]:
            pass
            self.match(TRUE_CONST)
            self.rpn += struct.pack("2B", ptgBool, 1)
        elif la1 and la1 in [FALSE_CONST]:
            pass
            self.match(FALSE_CONST)
            self.rpn += struct.pack("2B", ptgBool, 0)
        elif la1 and la1 in [STR_CONST]:
            pass
            str_tok = self.LT(1)
            self.match(STR_CONST)
            self.rpn += struct.pack("B", ptgStr) + upack1(str_tok.text[1:-1].replace("\"\"", "\""))
        elif la1 and la1 in [NUM_CONST]:
            pass
            num_tok = self.LT(1)
            self.match(NUM_CONST)
            self.rpn += struct.pack("<Bd", ptgNum, float(num_tok.text))
        elif la1 and la1 in [FUNC_IF]:
            pass
            self.match(FUNC_IF)
            self.match(LP)
            self.expr("V")
            la1 = self.LA(1)
            if False:
                pass
            elif la1 and la1 in [SEMICOLON]:
                pass
                self.match(SEMICOLON)
            elif la1 and la1 in [COMMA]:
                pass
                self.match(COMMA)
            else:
                    raise antlr.NoViableAltException(self.LT(1), self.getFilename())

            self.rpn += struct.pack("<BBH", ptgAttr, 0x02, 0) # tAttrIf
            pos0 = len(self.rpn) - 2
            self.expr(arg_type)
            la1 = self.LA(1)
            if False:
                pass
            elif la1 and la1 in [SEMICOLON]:
                pass
                self.match(SEMICOLON)
            elif la1 and la1 in [COMMA]:
                pass
                self.match(COMMA)
            else:
                    raise antlr.NoViableAltException(self.LT(1), self.getFilename())

            self.rpn += struct.pack("<BBH", ptgAttr, 0x08, 0) # tAttrSkip
            pos1 = len(self.rpn) - 2
            self.rpn = self.rpn[:pos0] + struct.pack("<H", pos1-pos0) + self.rpn[pos0+2:]
            self.expr(arg_type)
            self.match(RP)
            self.rpn += struct.pack("<BBH", ptgAttr, 0x08, 3) # tAttrSkip
            self.rpn += struct.pack("<BBH", ptgFuncVarR, 3, 1) # 3 = nargs, 1 = IF func
            pos2 = len(self.rpn)
            self.rpn = self.rpn[:pos1] + struct.pack("<H", pos2-(pos1+2)-1) + self.rpn[pos1+2:]
        elif la1 and la1 in [FUNC_CHOOSE]:
            pass
            self.match(FUNC_CHOOSE)
            arg_type = "R"
            rpn_chunks = []
            self.match(LP)
            self.expr("V")
            rpn_start = len(self.rpn)
            ref_markers = [len(self.sheet_references)]
            while True:
                if (self.LA(1)==COMMA or self.LA(1)==SEMICOLON):
                    pass
                    la1 = self.LA(1)
                    if False:
                        pass
                    elif la1 and la1 in [SEMICOLON]:
                        pass
                        self.match(SEMICOLON)
                    elif la1 and la1 in [COMMA]:
                        pass
                        self.match(COMMA)
                    else:
                            raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                    mark = len(self.rpn)
                    la1 = self.LA(1)
                    if False:
                        pass
                    elif la1 and la1 in [TRUE_CONST,FALSE_CONST,STR_CONST,NUM_CONST,INT_CONST,FUNC_IF,FUNC_CHOOSE,NAME,QUOTENAME,SUB,LP,REF2D]:
                        pass
                        self.expr(arg_type)
                    elif la1 and la1 in [RP,COMMA,SEMICOLON]:
                        pass
                        self.rpn += struct.pack("B", ptgMissArg)
                    else:
                            raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                    rpn_chunks.append(self.rpn[mark:])
                    ref_markers.append(len(self.sheet_references))
                else:
                    break

            self.match(RP)
            self.rpn = self.rpn[:rpn_start]
            nc = len(rpn_chunks)
            chunklens = [len(chunk) for chunk in rpn_chunks]
            skiplens = [0] * nc
            skiplens[-1] = 3
            for ic in xrange(nc-1, 0, -1):
               skiplens[ic-1] = skiplens[ic] + chunklens[ic] + 4
            jump_pos = [2 * nc + 2]
            for ic in xrange(nc):
               jump_pos.append(jump_pos[-1] + chunklens[ic] + 4)
            chunk_shift = 2 * nc + 6 # size of tAttrChoose
            for ic in xrange(nc):
               for refx in xrange(ref_markers[ic], ref_markers[ic+1]):
                   ref = self.sheet_references[refx]
                   self.sheet_references[refx] = (ref[0], ref[1], ref[2] + chunk_shift)
               chunk_shift += 4 # size of tAttrSkip
            choose_rpn = []
            choose_rpn.append(struct.pack("<BBH", ptgAttr, 0x04, nc)) # 0x04 is tAttrChoose
            choose_rpn.append(struct.pack("<%dH" % (nc+1), *jump_pos))
            for ic in xrange(nc):
               choose_rpn.append(rpn_chunks[ic])
               choose_rpn.append(struct.pack("<BBH", ptgAttr, 0x08, skiplens[ic])) # 0x08 is tAttrSkip
            choose_rpn.append(struct.pack("<BBH", ptgFuncVarV, nc+1, 100)) # 100 is CHOOSE fn
            self.rpn += "".join(choose_rpn)
        elif la1 and la1 in [LP]:
            pass
            self.match(LP)
            self.expr(arg_type)
            self.match(RP)
            self.rpn += struct.pack("B", ptgParen)
        else:
            if (self.LA(1)==INT_CONST) and (_tokenSet_0.member(self.LA(2))):
                pass
                int_tok = self.LT(1)
                self.match(INT_CONST)
                # print "**int_const", int_tok.text
                int_value = int(int_tok.text)
                if int_value <= 65535:
                   self.rpn += struct.pack("<BH", ptgInt, int_value)
                else:
                   self.rpn += struct.pack("<Bd", ptgNum, float(int_value))
            elif (self.LA(1)==REF2D) and (_tokenSet_0.member(self.LA(2))):
                pass
                ref2d_tok = self.LT(1)
                self.match(REF2D)
                # print "**ref2d %s %s" % (ref2d_tok.text, arg_type)
                r, c = Utils.cell_to_packed_rowcol(ref2d_tok.text)
                ptg = ptgRefR + _RVAdeltaRef[arg_type]
                self.rpn += struct.pack("<B2H", ptg, r, c)
            elif (self.LA(1)==REF2D) and (self.LA(2)==COLON):
                pass
                ref2d1_tok = self.LT(1)
                self.match(REF2D)
                self.match(COLON)
                ref2d2_tok = self.LT(1)
                self.match(REF2D)
                r1, c1 = Utils.cell_to_packed_rowcol(ref2d1_tok.text)
                r2, c2 = Utils.cell_to_packed_rowcol(ref2d2_tok.text)
                ptg = ptgAreaR + _RVAdeltaArea[arg_type]
                self.rpn += struct.pack("<B4H", ptg, r1, r2, c1, c2)
            elif (self.LA(1)==INT_CONST or self.LA(1)==NAME or self.LA(1)==QUOTENAME) and (self.LA(2)==COLON or self.LA(2)==BANG):
                pass
                sheet1=self.sheet()
                sheet2 = sheet1
                la1 = self.LA(1)
                if False:
                    pass
                elif la1 and la1 in [COLON]:
                    pass
                    self.match(COLON)
                    sheet2=self.sheet()
                elif la1 and la1 in [BANG]:
                    pass
                else:
                        raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                self.match(BANG)
                ref3d_ref2d = self.LT(1)
                self.match(REF2D)
                ptg = ptgRef3dR + _RVAdeltaRef[arg_type]
                rpn_ref2d = ""
                r1, c1 = Utils.cell_to_packed_rowcol(ref3d_ref2d.text)
                rpn_ref2d = struct.pack("<3H", 0x0000, r1, c1)
                la1 = self.LA(1)
                if False:
                    pass
                elif la1 and la1 in [COLON]:
                    pass
                    self.match(COLON)
                    ref3d_ref2d2 = self.LT(1)
                    self.match(REF2D)
                    ptg = ptgArea3dR + _RVAdeltaArea[arg_type]
                    r2, c2 = Utils.cell_to_packed_rowcol(ref3d_ref2d2.text)
                    rpn_ref2d = struct.pack("<5H", 0x0000, r1, r2, c1, c2)
                elif la1 and la1 in [EOF,EQ,NE,GT,LT,GE,LE,ADD,SUB,MUL,DIV,POWER,PERCENT,RP,COMMA,SEMICOLON,CONCAT]:
                    pass
                else:
                        raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                self.rpn += struct.pack("<B", ptg)
                self.sheet_references.append((sheet1, sheet2, len(self.rpn)))
                self.rpn += rpn_ref2d
            elif (self.LA(1)==NAME) and (_tokenSet_0.member(self.LA(2))):
                pass
                name_tok = self.LT(1)
                self.match(NAME)
                raise Exception("[formula] found unexpected NAME token (%r)" % name_tok.txt)
                # #### TODO: handle references to defined names here
            elif (self.LA(1)==NAME) and (self.LA(2)==LP):
                pass
                func_tok = self.LT(1)
                self.match(NAME)
                func_toku = func_tok.text.upper()
                if func_toku in all_funcs_by_name:
                   (opcode,
                   min_argc,
                   max_argc,
                   func_type,
                   arg_type_str) = all_funcs_by_name[func_toku]
                   arg_type_list = list(arg_type_str)
                else:
                   raise Exception("[formula] unknown function (%s)" % func_tok.text)
                # print "**func_tok1 %s %s" % (func_toku, func_type)
                xcall = opcode < 0
                if xcall:
                   # The name of the add-in function is passed as the 1st arg
                   # of the hidden XCALL function
                   self.xcall_references.append((func_toku, len(self.rpn) + 1))
                   self.rpn += struct.pack("<BHHH",
                       ptgNameXR,
                       0xadde, # ##PATCHME## index to REF entry in EXTERNSHEET record
                       0xefbe, # ##PATCHME## one-based index to EXTERNNAME record
                       0x0000) # unused
                self.match(LP)
                arg_count=self.expr_list(arg_type_list, min_argc, max_argc)
                self.match(RP)
                if arg_count > max_argc or arg_count < min_argc:
                   raise Exception, "%d parameters for function: %s" % (arg_count, func_tok.text)
                if xcall:
                   func_ptg = ptgFuncVarR + _RVAdelta[func_type]
                   self.rpn += struct.pack("<2BH", func_ptg, arg_count + 1, 255) # 255 is magic XCALL function
                elif min_argc == max_argc:
                   func_ptg = ptgFuncR + _RVAdelta[func_type]
                   self.rpn += struct.pack("<BH", func_ptg, opcode)
                elif arg_count == 1 and func_tok.text.upper() == "SUM":
                   self.rpn += struct.pack("<BBH", ptgAttr, 0x10, 0) # tAttrSum
                else:
                   func_ptg = ptgFuncVarR + _RVAdelta[func_type]
                   self.rpn += struct.pack("<2BH", func_ptg, arg_count, opcode)
            else:
                raise antlr.NoViableAltException(self.LT(1), self.getFilename())


    def sheet(self):
        ref = None

        sheet_ref_name = None
        sheet_ref_int = None
        sheet_ref_quote = None
        la1 = self.LA(1)
        if False:
            pass
        elif la1 and la1 in [NAME]:
            pass
            sheet_ref_name = self.LT(1)
            self.match(NAME)
            ref = sheet_ref_name.text
        elif la1 and la1 in [INT_CONST]:
            pass
            sheet_ref_int = self.LT(1)
            self.match(INT_CONST)
            ref = sheet_ref_int.text
        elif la1 and la1 in [QUOTENAME]:
            pass
            sheet_ref_quote = self.LT(1)
            self.match(QUOTENAME)
            ref = sheet_ref_quote.text[1:-1].replace("''", "'")
        else:
                raise antlr.NoViableAltException(self.LT(1), self.getFilename())

        return ref

    def expr_list(self,
        arg_type_list, min_argc, max_argc
    ):
        arg_cnt = None

        arg_cnt = 0
        arg_type = arg_type_list[arg_cnt]
        # print "**expr_list1[%d] req=%s" % (arg_cnt, arg_type)
        la1 = self.LA(1)
        if False:
            pass
        elif la1 and la1 in [TRUE_CONST,FALSE_CONST,STR_CONST,NUM_CONST,INT_CONST,FUNC_IF,FUNC_CHOOSE,NAME,QUOTENAME,SUB,LP,REF2D]:
            pass
            self.expr(arg_type)
            arg_cnt += 1
            while True:
                if (self.LA(1)==COMMA or self.LA(1)==SEMICOLON):
                    pass
                    if arg_cnt < len(arg_type_list):
                       arg_type = arg_type_list[arg_cnt]
                    else:
                       arg_type = arg_type_list[-1]
                    if arg_type == "+":
                       arg_type = arg_type_list[-2]
                    # print "**expr_list2[%d] req=%s" % (arg_cnt, arg_type)
                    la1 = self.LA(1)
                    if False:
                        pass
                    elif la1 and la1 in [SEMICOLON]:
                        pass
                        self.match(SEMICOLON)
                    elif la1 and la1 in [COMMA]:
                        pass
                        self.match(COMMA)
                    else:
                            raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                    la1 = self.LA(1)
                    if False:
                        pass
                    elif la1 and la1 in [TRUE_CONST,FALSE_CONST,STR_CONST,NUM_CONST,INT_CONST,FUNC_IF,FUNC_CHOOSE,NAME,QUOTENAME,SUB,LP,REF2D]:
                        pass
                        self.expr(arg_type)
                    elif la1 and la1 in [RP,COMMA,SEMICOLON]:
                        pass
                        self.rpn += struct.pack("B", ptgMissArg)
                    else:
                            raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                    arg_cnt += 1
                else:
                    break

        elif la1 and la1 in [RP]:
            pass
        else:
                raise antlr.NoViableAltException(self.LT(1), self.getFilename())

        return arg_cnt


_tokenNames = [
    "<0>",
    "EOF",
    "<2>",
    "NULL_TREE_LOOKAHEAD",
    "TRUE_CONST",
    "FALSE_CONST",
    "STR_CONST",
    "NUM_CONST",
    "INT_CONST",
    "FUNC_IF",
    "FUNC_CHOOSE",
    "NAME",
    "QUOTENAME",
    "EQ",
    "NE",
    "GT",
    "LT",
    "GE",
    "LE",
    "ADD",
    "SUB",
    "MUL",
    "DIV",
    "POWER",
    "PERCENT",
    "LP",
    "RP",
    "LB",
    "RB",
    "COLON",
    "COMMA",
    "SEMICOLON",
    "REF2D",
    "REF2D_R1C1",
    "BANG",
    "CONCAT"
]


### generate bit set
def mk_tokenSet_0():
    ### var1
    data = [ 37681618946L, 0L]
    return data
_tokenSet_0 = antlr.BitSet(mk_tokenSet_0())


########NEW FILE########
__FILENAME__ = ExcelMagic
# -*- coding: ascii -*-
"""
lots of Excel Magic Numbers
"""

# Boundaries BIFF8+

MAX_ROW = 65536
MAX_COL = 256


biff_records = {
    0x0000: "DIMENSIONS",
    0x0001: "BLANK",
    0x0002: "INTEGER",
    0x0003: "NUMBER",
    0x0004: "LABEL",
    0x0005: "BOOLERR",
    0x0006: "FORMULA",
    0x0007: "STRING",
    0x0008: "ROW",
    0x0009: "BOF",
    0x000A: "EOF",
    0x000B: "INDEX",
    0x000C: "CALCCOUNT",
    0x000D: "CALCMODE",
    0x000E: "PRECISION",
    0x000F: "REFMODE",
    0x0010: "DELTA",
    0x0011: "ITERATION",
    0x0012: "PROTECT",
    0x0013: "PASSWORD",
    0x0014: "HEADER",
    0x0015: "FOOTER",
    0x0016: "EXTERNCOUNT",
    0x0017: "EXTERNSHEET",
    0x0018: "NAME",
    0x0019: "WINDOWPROTECT",
    0x001A: "VERTICALPAGEBREAKS",
    0x001B: "HORIZONTALPAGEBREAKS",
    0x001C: "NOTE",
    0x001D: "SELECTION",
    0x001E: "FORMAT",
    0x001F: "FORMATCOUNT",
    0x0020: "COLUMNDEFAULT",
    0x0021: "ARRAY",
    0x0022: "1904",
    0x0023: "EXTERNNAME",
    0x0024: "COLWIDTH",
    0x0025: "DEFAULTROWHEIGHT",
    0x0026: "LEFTMARGIN",
    0x0027: "RIGHTMARGIN",
    0x0028: "TOPMARGIN",
    0x0029: "BOTTOMMARGIN",
    0x002A: "PRINTHEADERS",
    0x002B: "PRINTGRIDLINES",
    0x002F: "FILEPASS",
    0x0031: "FONT",
    0x0036: "TABLE",
    0x003C: "CONTINUE",
    0x003D: "WINDOW1",
    0x003E: "WINDOW2",
    0x0040: "BACKUP",
    0x0041: "PANE",
    0x0042: "CODEPAGE",
    0x0043: "XF",
    0x0044: "IXFE",
    0x0045: "EFONT",
    0x004D: "PLS",
    0x0050: "DCON",
    0x0051: "DCONREF",
    0x0053: "DCONNAME",
    0x0055: "DEFCOLWIDTH",
    0x0056: "BUILTINFMTCNT",
    0x0059: "XCT",
    0x005A: "CRN",
    0x005B: "FILESHARING",
    0x005C: "WRITEACCESS",
    0x005D: "OBJ",
    0x005E: "UNCALCED",
    0x005F: "SAFERECALC",
    0x0060: "TEMPLATE",
    0x0063: "OBJPROTECT",
    0x007D: "COLINFO",
    0x007E: "RK",
    0x007F: "IMDATA",
    0x0080: "GUTS",
    0x0081: "WSBOOL",
    0x0082: "GRIDSET",
    0x0083: "HCENTER",
    0x0084: "VCENTER",
    0x0085: "BOUNDSHEET",
    0x0086: "WRITEPROT",
    0x0087: "ADDIN",
    0x0088: "EDG",
    0x0089: "PUB",
    0x008C: "COUNTRY",
    0x008D: "HIDEOBJ",
    0x008E: "BUNDLESOFFSET",
    0x008F: "BUNDLEHEADER",
    0x0090: "SORT",
    0x0091: "SUB",
    0x0092: "PALETTE",
    0x0093: "STYLE",
    0x0094: "LHRECORD",
    0x0095: "LHNGRAPH",
    0x0096: "SOUND",
    0x0098: "LPR",
    0x0099: "STANDARDWIDTH",
    0x009A: "FNGROUPNAME",
    0x009B: "FILTERMODE",
    0x009C: "FNGROUPCOUNT",
    0x009D: "AUTOFILTERINFO",
    0x009E: "AUTOFILTER",
    0x00A0: "SCL",
    0x00A1: "SETUP",
    0x00A9: "COORDLIST",
    0x00AB: "GCW",
    0x00AE: "SCENMAN",
    0x00AF: "SCENARIO",
    0x00B0: "SXVIEW",
    0x00B1: "SXVD",
    0x00B2: "SXVI",
    0x00B4: "SXIVD",
    0x00B5: "SXLI",
    0x00B6: "SXPI",
    0x00B8: "DOCROUTE",
    0x00B9: "RECIPNAME",
    0x00BC: "SHRFMLA",
    0x00BD: "MULRK",
    0x00BE: "MULBLANK",
    0x00C1: "MMS",
    0x00C2: "ADDMENU",
    0x00C3: "DELMENU",
    0x00C5: "SXDI",
    0x00C6: "SXDB",
    0x00C7: "SXFIELD",
    0x00C8: "SXINDEXLIST",
    0x00C9: "SXDOUBLE",
    0x00CD: "SXSTRING",
    0x00CE: "SXDATETIME",
    0x00D0: "SXTBL",
    0x00D1: "SXTBRGITEM",
    0x00D2: "SXTBPG",
    0x00D3: "OBPROJ",
    0x00D5: "SXIDSTM",
    0x00D6: "RSTRING",
    0x00D7: "DBCELL",
    0x00DA: "BOOKBOOL",
    0x00DC: "SXEXT|PARAMQRY",
    0x00DD: "SCENPROTECT",
    0x00DE: "OLESIZE",
    0x00DF: "UDDESC",
    0x00E0: "XF",
    0x00E1: "INTERFACEHDR",
    0x00E2: "INTERFACEEND",
    0x00E3: "SXVS",
    0x00E5: "MERGEDCELLS",
    0x00E9: "BITMAP",
    0x00EB: "MSODRAWINGGROUP",
    0x00EC: "MSODRAWING",
    0x00ED: "MSODRAWINGSELECTION",
    0x00F0: "SXRULE",
    0x00F1: "SXEX",
    0x00F2: "SXFILT",
    0x00F6: "SXNAME",
    0x00F7: "SXSELECT",
    0x00F8: "SXPAIR",
    0x00F9: "SXFMLA",
    0x00FB: "SXFORMAT",
    0x00FC: "SST",
    0x00FD: "LABELSST",
    0x00FF: "EXTSST",
    0x0100: "SXVDEX",
    0x0103: "SXFORMULA",
    0x0122: "SXDBEX",
    0x0137: "CHTRINSERT",
    0x0138: "CHTRINFO",
    0x013B: "CHTRCELLCONTENT",
    0x013D: "TABID",
    0x0140: "CHTRMOVERANGE",
    0x014D: "CHTRINSERTTAB",
    0x015F: "LABELRANGES",
    0x0160: "USESELFS",
    0x0161: "DSF",
    0x0162: "XL5MODIFY",
    0x0196: "CHTRHEADER",
    0x01A9: "USERBVIEW",
    0x01AA: "USERSVIEWBEGIN",
    0x01AB: "USERSVIEWEND",
    0x01AD: "QSI",
    0x01AE: "SUPBOOK",
    0x01AF: "PROT4REV",
    0x01B0: "CONDFMT",
    0x01B1: "CF",
    0x01B2: "DVAL",
    0x01B5: "DCONBIN",
    0x01B6: "TXO",
    0x01B7: "REFRESHALL",
    0x01B8: "HLINK",
    0x01BA: "CODENAME",
    0x01BB: "SXFDBTYPE",
    0x01BC: "PROT4REVPASS",
    0x01BE: "DV",
    0x01C0: "XL9FILE",
    0x01C1: "RECALCID",
    0x0200: "DIMENSIONS",
    0x0201: "BLANK",
    0x0203: "NUMBER",
    0x0204: "LABEL",
    0x0205: "BOOLERR",
    0x0206: "FORMULA",
    0x0207: "STRING",
    0x0208: "ROW",
    0x0209: "BOF",
    0x020B: "INDEX",
    0x0218: "NAME",
    0x0221: "ARRAY",
    0x0223: "EXTERNNAME",
    0x0225: "DEFAULTROWHEIGHT",
    0x0231: "FONT",
    0x0236: "TABLE",
    0x023E: "WINDOW2",
    0x0243: "XF",
    0x027E: "RK",
    0x0293: "STYLE",
    0x0406: "FORMULA",
    0x0409: "BOF",
    0x041E: "FORMAT",
    0x0443: "XF",
    0x04BC: "SHRFMLA",
    0x0800: "SCREENTIP",
    0x0803: "WEBQRYSETTINGS",
    0x0804: "WEBQRYTABLES",
    0x0809: "BOF",
    0x0862: "SHEETLAYOUT",
    0x0867: "SHEETPROTECTION",
    0x1001: "UNITS",
    0x1002: "ChartChart",
    0x1003: "ChartSeries",
    0x1006: "ChartDataformat",
    0x1007: "ChartLineformat",
    0x1009: "ChartMarkerformat",
    0x100A: "ChartAreaformat",
    0x100B: "ChartPieformat",
    0x100C: "ChartAttachedlabel",
    0x100D: "ChartSeriestext",
    0x1014: "ChartChartformat",
    0x1015: "ChartLegend",
    0x1016: "ChartSerieslist",
    0x1017: "ChartBar",
    0x1018: "ChartLine",
    0x1019: "ChartPie",
    0x101A: "ChartArea",
    0x101B: "ChartScatter",
    0x101C: "ChartChartline",
    0x101D: "ChartAxis",
    0x101E: "ChartTick",
    0x101F: "ChartValuerange",
    0x1020: "ChartCatserrange",
    0x1021: "ChartAxislineformat",
    0x1022: "ChartFormatlink",
    0x1024: "ChartDefaulttext",
    0x1025: "ChartText",
    0x1026: "ChartFontx",
    0x1027: "ChartObjectLink",
    0x1032: "ChartFrame",
    0x1033: "BEGIN",
    0x1034: "END",
    0x1035: "ChartPlotarea",
    0x103A: "Chart3D",
    0x103C: "ChartPicf",
    0x103D: "ChartDropbar",
    0x103E: "ChartRadar",
    0x103F: "ChartSurface",
    0x1040: "ChartRadararea",
    0x1041: "ChartAxisparent",
    0x1043: "ChartLegendxn",
    0x1044: "ChartShtprops",
    0x1045: "ChartSertocrt",
    0x1046: "ChartAxesused",
    0x1048: "ChartSbaseref",
    0x104A: "ChartSerparent",
    0x104B: "ChartSerauxtrend",
    0x104E: "ChartIfmt",
    0x104F: "ChartPos",
    0x1050: "ChartAlruns",
    0x1051: "ChartAI",
    0x105B: "ChartSerauxerrbar",
    0x105D: "ChartSerfmt",
    0x105F: "Chart3DDataFormat",
    0x1060: "ChartFbi",
    0x1061: "ChartBoppop",
    0x1062: "ChartAxcext",
    0x1063: "ChartDat",
    0x1064: "ChartPlotgrowth",
    0x1065: "ChartSiindex",
    0x1066: "ChartGelframe",
    0x1067: "ChartBoppcustom",
    0xFFFF: ""
}


all_funcs_by_name = {
    # Includes Analysis ToolPak aka ATP aka add-in aka xcall functions,
    # distinguished by -ve opcode.
    # name: (opcode, min # args, max # args, func return type, func arg types)
    # + in func arg types means more of the same.
    'ABS'         : ( 24, 1,  1, 'V', 'V'),
    'ACCRINT'     : ( -1, 6,  7, 'V', 'VVVVVVV'),
    'ACCRINTM'    : ( -1, 3,  5, 'V', 'VVVVV'),
    'ACOS'        : ( 99, 1,  1, 'V', 'V'),
    'ACOSH'       : (233, 1,  1, 'V', 'V'),
    'ADDRESS'     : (219, 2,  5, 'V', 'VVVVV'),
    'AMORDEGRC'   : ( -1, 7,  7, 'V', 'VVVVVVV'),
    'AMORLINC'    : ( -1, 7,  7, 'V', 'VVVVVVV'),
    'AND'         : ( 36, 1, 30, 'V', 'D+'),
    'AREAS'       : ( 75, 1,  1, 'V', 'R'),
    'ASC'         : (214, 1,  1, 'V', 'V'),
    'ASIN'        : ( 98, 1,  1, 'V', 'V'),
    'ASINH'       : (232, 1,  1, 'V', 'V'),
    'ATAN'        : ( 18, 1,  1, 'V', 'V'),
    'ATAN2'       : ( 97, 2,  2, 'V', 'VV'),
    'ATANH'       : (234, 1,  1, 'V', 'V'),
    'AVEDEV'      : (269, 1, 30, 'V', 'D+'),
    'AVERAGE'     : (  5, 1, 30, 'V', 'D+'),
    'AVERAGEA'    : (361, 1, 30, 'V', 'D+'),
    'BAHTTEXT'    : (368, 1,  1, 'V', 'V'),
    'BESSELI'     : ( -1, 2,  2, 'V', 'VV'),
    'BESSELJ'     : ( -1, 2,  2, 'V', 'VV'),
    'BESSELK'     : ( -1, 2,  2, 'V', 'VV'),
    'BESSELY'     : ( -1, 2,  2, 'V', 'VV'),
    'BETADIST'    : (270, 3,  5, 'V', 'VVVVV'),
    'BETAINV'     : (272, 3,  5, 'V', 'VVVVV'),
    'BIN2DEC'     : ( -1, 1,  1, 'V', 'V'),
    'BIN2HEX'     : ( -1, 1,  2, 'V', 'VV'),
    'BIN2OCT'     : ( -1, 1,  2, 'V', 'VV'),
    'BINOMDIST'   : (273, 4,  4, 'V', 'VVVV'),
    'CEILING'     : (288, 2,  2, 'V', 'VV'),
    'CELL'        : (125, 1,  2, 'V', 'VR'),
    'CHAR'        : (111, 1,  1, 'V', 'V'),
    'CHIDIST'     : (274, 2,  2, 'V', 'VV'),
    'CHIINV'      : (275, 2,  2, 'V', 'VV'),
    'CHITEST'     : (306, 2,  2, 'V', 'AA'),
    'CHOOSE'      : (100, 2, 30, 'R', 'VR+'),
    'CLEAN'       : (162, 1,  1, 'V', 'V'),
    'CODE'        : (121, 1,  1, 'V', 'V'),
    'COLUMN'      : (  9, 0,  1, 'V', 'R'),
    'COLUMNS'     : ( 77, 1,  1, 'V', 'R'),
    'COMBIN'      : (276, 2,  2, 'V', 'VV'),
    'COMPLEX'     : ( -1, 2,  3, 'V', 'VVV'),
    'CONCATENATE' : (336, 1, 30, 'V', 'V+'),
    'CONFIDENCE'  : (277, 3,  3, 'V', 'VVV'),
    'CONVERT'     : ( -1, 3,  3, 'V', 'VVV'),
    'CORREL'      : (307, 2,  2, 'V', 'AA'),
    'COS'         : ( 16, 1,  1, 'V', 'V'),
    'COSH'        : (230, 1,  1, 'V', 'V'),
    'COUNT'       : (  0, 1, 30, 'V', 'D+'),
    'COUNTA'      : (169, 1, 30, 'V', 'D+'),
    'COUNTBLANK'  : (347, 1,  1, 'V', 'R'),
    'COUNTIF'     : (346, 2,  2, 'V', 'RV'),
    'COUPDAYBS'   : ( -1, 3,  5, 'V', 'VVVVV'),
    'COUPDAYS'    : ( -1, 3,  5, 'V', 'VVVVV'),
    'COUPDAYSNC'  : ( -1, 3,  5, 'V', 'VVVVV'),
    'COUPNCD'     : ( -1, 3,  5, 'V', 'VVVVV'),
    'COUPNUM'     : ( -1, 3,  5, 'V', 'VVVVV'),
    'COUPPCD'     : ( -1, 3,  5, 'V', 'VVVVV'),
    'COVAR'       : (308, 2,  2, 'V', 'AA'),
    'CRITBINOM'   : (278, 3,  3, 'V', 'VVV'),
    'CUMIPMT'     : ( -1, 6,  6, 'V', 'VVVVVV'),
    'CUMPRINC'    : ( -1, 6,  6, 'V', 'VVVVVV'),
    'DATE'        : ( 65, 3,  3, 'V', 'VVV'),
    'DATEDIF'     : (351, 3,  3, 'V', 'VVV'),
    'DATEVALUE'   : (140, 1,  1, 'V', 'V'),
    'DAVERAGE'    : ( 42, 3,  3, 'V', 'RRR'),
    'DAY'         : ( 67, 1,  1, 'V', 'V'),
    'DAYS360'     : (220, 2,  3, 'V', 'VVV'),
    'DB'          : (247, 4,  5, 'V', 'VVVVV'),
    'DBCS'        : (215, 1,  1, 'V', 'V'),
    'DCOUNT'      : ( 40, 3,  3, 'V', 'RRR'),
    'DCOUNTA'     : (199, 3,  3, 'V', 'RRR'),
    'DDB'         : (144, 4,  5, 'V', 'VVVVV'),
    'DEC2BIN'     : ( -1, 1,  2, 'V', 'VV'),
    'DEC2HEX'     : ( -1, 1,  2, 'V', 'VV'),
    'DEC2OCT'     : ( -1, 1,  2, 'V', 'VV'),
    'DEGREES'     : (343, 1,  1, 'V', 'V'),
    'DELTA'       : ( -1, 1,  2, 'V', 'VV'),
    'DEVSQ'       : (318, 1, 30, 'V', 'D+'),
    'DGET'        : (235, 3,  3, 'V', 'RRR'),
    'DISC'        : ( -1, 4,  5, 'V', 'VVVVV'),
    'DMAX'        : ( 44, 3,  3, 'V', 'RRR'),
    'DMIN'        : ( 43, 3,  3, 'V', 'RRR'),
    'DOLLAR'      : ( 13, 1,  2, 'V', 'VV'),
    'DOLLARDE'    : ( -1, 2,  2, 'V', 'VV'),
    'DOLLARFR'    : ( -1, 2,  2, 'V', 'VV'),
    'DPRODUCT'    : (189, 3,  3, 'V', 'RRR'),
    'DSTDEV'      : ( 45, 3,  3, 'V', 'RRR'),
    'DSTDEVP'     : (195, 3,  3, 'V', 'RRR'),
    'DSUM'        : ( 41, 3,  3, 'V', 'RRR'),
    'DURATION'    : ( -1, 5,  6, 'V', 'VVVVVV'),
    'DVAR'        : ( 47, 3,  3, 'V', 'RRR'),
    'DVARP'       : (196, 3,  3, 'V', 'RRR'),
    'EDATE'       : ( -1, 2,  2, 'V', 'VV'),
    'EFFECT'      : ( -1, 2,  2, 'V', 'VV'),
    'EOMONTH'     : ( -1, 1,  2, 'V', 'VV'),
    'ERF'         : ( -1, 1,  2, 'V', 'VV'),
    'ERFC'        : ( -1, 1,  1, 'V', 'V'),
    'ERROR.TYPE'  : (261, 1,  1, 'V', 'V'),
    'EVEN'        : (279, 1,  1, 'V', 'V'),
    'EXACT'       : (117, 2,  2, 'V', 'VV'),
    'EXP'         : ( 21, 1,  1, 'V', 'V'),
    'EXPONDIST'   : (280, 3,  3, 'V', 'VVV'),
    'FACT'        : (184, 1,  1, 'V', 'V'),
    'FACTDOUBLE'  : ( -1, 1,  1, 'V', 'V'),
    'FALSE'       : ( 35, 0,  0, 'V', '-'),
    'FDIST'       : (281, 3,  3, 'V', 'VVV'),
    'FIND'        : (124, 2,  3, 'V', 'VVV'),
    'FINDB'       : (205, 2,  3, 'V', 'VVV'),
    'FINV'        : (282, 3,  3, 'V', 'VVV'),
    'FISHER'      : (283, 1,  1, 'V', 'V'),
    'FISHERINV'   : (284, 1,  1, 'V', 'V'),
    'FIXED'       : ( 14, 2,  3, 'V', 'VVV'),
    'FLOOR'       : (285, 2,  2, 'V', 'VV'),
    'FORECAST'    : (309, 3,  3, 'V', 'VAA'),
    'FREQUENCY'   : (252, 2,  2, 'A', 'RR'),
    'FTEST'       : (310, 2,  2, 'V', 'AA'),
    'FV'          : ( 57, 3,  5, 'V', 'VVVVV'),
    'FVSCHEDULE'  : ( -1, 2,  2, 'V', 'VA'),
    'GAMMADIST'   : (286, 4,  4, 'V', 'VVVV'),
    'GAMMAINV'    : (287, 3,  3, 'V', 'VVV'),
    'GAMMALN'     : (271, 1,  1, 'V', 'V'),
    'GCD'         : ( -1, 1, 29, 'V', 'V+'),
    'GEOMEAN'     : (319, 1, 30, 'V', 'D+'),
    'GESTEP'      : ( -1, 1,  2, 'V', 'VV'),
    'GETPIVOTDATA': (358, 2, 30, 'A', 'VAV+'),
    'GROWTH'      : ( 52, 1,  4, 'A', 'RRRV'),
    'HARMEAN'     : (320, 1, 30, 'V', 'D+'),
    'HEX2BIN'     : ( -1, 1,  2, 'V', 'VV'),
    'HEX2DEC'     : ( -1, 1,  1, 'V', 'V'),
    'HEX2OCT'     : ( -1, 1,  2, 'V', 'VV'),
    'HLOOKUP'     : (101, 3,  4, 'V', 'VRRV'),
    'HOUR'        : ( 71, 1,  1, 'V', 'V'),
    'HYPERLINK'   : (359, 1,  2, 'V', 'VV'),
    'HYPGEOMDIST' : (289, 4,  4, 'V', 'VVVV'),
    'IF'          : (  1, 2,  3, 'R', 'VRR'),
    'IMABS'       : ( -1, 1,  1, 'V', 'V'),
    'IMAGINARY'   : ( -1, 1,  1, 'V', 'V'),
    'IMARGUMENT'  : ( -1, 1,  1, 'V', 'V'),
    'IMCONJUGATE' : ( -1, 1,  1, 'V', 'V'),
    'IMCOS'       : ( -1, 1,  1, 'V', 'V'),
    'IMDIV'       : ( -1, 2,  2, 'V', 'VV'),
    'IMEXP'       : ( -1, 1,  1, 'V', 'V'),
    'IMLN'        : ( -1, 1,  1, 'V', 'V'),
    'IMLOG10'     : ( -1, 1,  1, 'V', 'V'),
    'IMLOG2'      : ( -1, 1,  1, 'V', 'V'),
    'IMPOWER'     : ( -1, 2,  2, 'V', 'VV'),
    'IMPRODUCT'   : ( -1, 2,  2, 'V', 'VV'),
    'IMREAL'      : ( -1, 1,  1, 'V', 'V'),
    'IMSIN'       : ( -1, 1,  1, 'V', 'V'),
    'IMSQRT'      : ( -1, 1,  1, 'V', 'V'),
    'IMSUB'       : ( -1, 2,  2, 'V', 'VV'),
    'IMSUM'       : ( -1, 1, 29, 'V', 'V+'),
    'INDEX'       : ( 29, 2,  4, 'R', 'RVVV'),
    'INDIRECT'    : (148, 1,  2, 'R', 'VV'),
    'INFO'        : (244, 1,  1, 'V', 'V'),
    'INT'         : ( 25, 1,  1, 'V', 'V'),
    'INTERCEPT'   : (311, 2,  2, 'V', 'AA'),
    'INTRATE'     : ( -1, 4,  5, 'V', 'VVVVV'),
    'IPMT'        : (167, 4,  6, 'V', 'VVVVVV'),
    'IRR'         : ( 62, 1,  2, 'V', 'RV'),
    'ISBLANK'     : (129, 1,  1, 'V', 'V'),
    'ISERR'       : (126, 1,  1, 'V', 'V'),
    'ISERROR'     : (  3, 1,  1, 'V', 'V'),
    'ISEVEN'      : ( -1, 1,  1, 'V', 'V'),
    'ISLOGICAL'   : (198, 1,  1, 'V', 'V'),
    'ISNA'        : (  2, 1,  1, 'V', 'V'),
    'ISNONTEXT'   : (190, 1,  1, 'V', 'V'),
    'ISNUMBER'    : (128, 1,  1, 'V', 'V'),
    'ISODD'       : ( -1, 1,  1, 'V', 'V'),
    'ISPMT'       : (350, 4,  4, 'V', 'VVVV'),
    'ISREF'       : (105, 1,  1, 'V', 'R'),
    'ISTEXT'      : (127, 1,  1, 'V', 'V'),
    'KURT'        : (322, 1, 30, 'V', 'D+'),
    'LARGE'       : (325, 2,  2, 'V', 'RV'),
    'LCM'         : ( -1, 1, 29, 'V', 'V+'),
    'LEFT'        : (115, 1,  2, 'V', 'VV'),
    'LEFTB'       : (208, 1,  2, 'V', 'VV'),
    'LEN'         : ( 32, 1,  1, 'V', 'V'),
    'LENB'        : (211, 1,  1, 'V', 'V'),
    'LINEST'      : ( 49, 1,  4, 'A', 'RRVV'),
    'LN'          : ( 22, 1,  1, 'V', 'V'),
    'LOG'         : (109, 1,  2, 'V', 'VV'),
    'LOG10'       : ( 23, 1,  1, 'V', 'V'),
    'LOGEST'      : ( 51, 1,  4, 'A', 'RRVV'),
    'LOGINV'      : (291, 3,  3, 'V', 'VVV'),
    'LOGNORMDIST' : (290, 3,  3, 'V', 'VVV'),
    'LOOKUP'      : ( 28, 2,  3, 'V', 'VRR'),
    'LOWER'       : (112, 1,  1, 'V', 'V'),
    'MATCH'       : ( 64, 2,  3, 'V', 'VRR'),
    'MAX'         : (  7, 1, 30, 'V', 'D+'),
    'MAXA'        : (362, 1, 30, 'V', 'D+'),
    'MDETERM'     : (163, 1,  1, 'V', 'A'),
    'MDURATION'   : ( -1, 5,  6, 'V', 'VVVVVV'),
    'MEDIAN'      : (227, 1, 30, 'V', 'D+'),
    'MID'         : ( 31, 3,  3, 'V', 'VVV'),
    'MIDB'        : (210, 3,  3, 'V', 'VVV'),
    'MIN'         : (  6, 1, 30, 'V', 'D+'),
    'MINA'        : (363, 1, 30, 'V', 'D+'),
    'MINUTE'      : ( 72, 1,  1, 'V', 'V'),
    'MINVERSE'    : (164, 1,  1, 'A', 'A'),
    'MIRR'        : ( 61, 3,  3, 'V', 'RVV'),
    'MMULT'       : (165, 2,  2, 'A', 'AA'),
    'MOD'         : ( 39, 2,  2, 'V', 'VV'),
    'MODE'        : (330, 1, 30, 'V', 'A+'), ################ weird #################
    'MONTH'       : ( 68, 1,  1, 'V', 'V'),
    'MROUND'      : ( -1, 2,  2, 'V', 'VV'),
    'MULTINOMIAL' : ( -1, 1, 29, 'V', 'V+'),
    'N'           : (131, 1,  1, 'V', 'R'),
    'NA'          : ( 10, 0,  0, 'V', '-'),
    'NEGBINOMDIST': (292, 3,  3, 'V', 'VVV'),
    'NETWORKDAYS' : ( -1, 2,  3, 'V', 'VVR'),
    'NOMINAL'     : ( -1, 2,  2, 'V', 'VV'),
    'NORMDIST'    : (293, 4,  4, 'V', 'VVVV'),
    'NORMINV'     : (295, 3,  3, 'V', 'VVV'),
    'NORMSDIST'   : (294, 1,  1, 'V', 'V'),
    'NORMSINV'    : (296, 1,  1, 'V', 'V'),
    'NOT'         : ( 38, 1,  1, 'V', 'V'),
    'NOW'         : ( 74, 0,  0, 'V', '-'),
    'NPER'        : ( 58, 3,  5, 'V', 'VVVVV'),
    'NPV'         : ( 11, 2, 30, 'V', 'VD+'),
    'OCT2BIN'     : ( -1, 1,  2, 'V', 'VV'),
    'OCT2DEC'     : ( -1, 1,  1, 'V', 'V'),
    'OCT2HEX'     : ( -1, 1,  2, 'V', 'VV'),
    'ODD'         : (298, 1,  1, 'V', 'V'),
    'ODDFPRICE'   : ( -1, 9,  9, 'V', 'VVVVVVVVV'),
    'ODDFYIELD'   : ( -1, 9,  9, 'V', 'VVVVVVVVV'),
    'ODDLPRICE'   : ( -1, 8,  8, 'V', 'VVVVVVVV'),
    'ODDLYIELD'   : ( -1, 8,  8, 'V', 'VVVVVVVV'),
    'OFFSET'      : ( 78, 3,  5, 'R', 'RVVVV'),
    'OR'          : ( 37, 1, 30, 'V', 'D+'),
    'PEARSON'     : (312, 2,  2, 'V', 'AA'),
    'PERCENTILE'  : (328, 2,  2, 'V', 'RV'),
    'PERCENTRANK' : (329, 2,  3, 'V', 'RVV'),
    'PERMUT'      : (299, 2,  2, 'V', 'VV'),
    'PHONETIC'    : (360, 1,  1, 'V', 'R'),
    'PI'          : ( 19, 0,  0, 'V', '-'),
    'PMT'         : ( 59, 3,  5, 'V', 'VVVVV'),
    'POISSON'     : (300, 3,  3, 'V', 'VVV'),
    'POWER'       : (337, 2,  2, 'V', 'VV'),
    'PPMT'        : (168, 4,  6, 'V', 'VVVVVV'),
    'PRICE'       : ( -1, 6,  7, 'V', 'VVVVVVV'),
    'PRICEDISC'   : ( -1, 4,  5, 'V', 'VVVVV'),
    'PRICEMAT'    : ( -1, 5,  6, 'V', 'VVVVVV'),
    'PROB'        : (317, 3,  4, 'V', 'AAVV'),
    'PRODUCT'     : (183, 1, 30, 'V', 'D+'),
    'PROPER'      : (114, 1,  1, 'V', 'V'),
    'PV'          : ( 56, 3,  5, 'V', 'VVVVV'),
    'QUARTILE'    : (327, 2,  2, 'V', 'RV'),
    'QUOTIENT'    : ( -1, 2,  2, 'V', 'VV'),
    'RADIANS'     : (342, 1,  1, 'V', 'V'),
    'RAND'        : ( 63, 0,  0, 'V', '-'),
    'RANDBETWEEN' : ( -1, 2,  2, 'V', 'VV'),
    'RANK'        : (216, 2,  3, 'V', 'VRV'),
    'RATE'        : ( 60, 3,  6, 'V', 'VVVVVV'),
    'RECEIVED'    : ( -1, 4,  5, 'V', 'VVVVV'),
    'REPLACE'     : (119, 4,  4, 'V', 'VVVV'),
    'REPLACEB'    : (207, 4,  4, 'V', 'VVVV'),
    'REPT'        : ( 30, 2,  2, 'V', 'VV'),
    'RIGHT'       : (116, 1,  2, 'V', 'VV'),
    'RIGHTB'      : (209, 1,  2, 'V', 'VV'),
    'ROMAN'       : (354, 1,  2, 'V', 'VV'),
    'ROUND'       : ( 27, 2,  2, 'V', 'VV'),
    'ROUNDDOWN'   : (213, 2,  2, 'V', 'VV'),
    'ROUNDUP'     : (212, 2,  2, 'V', 'VV'),
    'ROW'         : (  8, 0,  1, 'V', 'R'),
    'ROWS'        : ( 76, 1,  1, 'V', 'R'),
    'RSQ'         : (313, 2,  2, 'V', 'AA'),
    'RTD'         : (379, 3, 30, 'A', 'VVV+'),
    'SEARCH'      : ( 82, 2,  3, 'V', 'VVV'),
    'SEARCHB'     : (206, 2,  3, 'V', 'VVV'),
    'SECOND'      : ( 73, 1,  1, 'V', 'V'),
    'SERIESSUM'   : ( -1, 4,  4, 'V', 'VVVA'),
    'SIGN'        : ( 26, 1,  1, 'V', 'V'),
    'SIN'         : ( 15, 1,  1, 'V', 'V'),
    'SINH'        : (229, 1,  1, 'V', 'V'),
    'SKEW'        : (323, 1, 30, 'V', 'D+'),
    'SLN'         : (142, 3,  3, 'V', 'VVV'),
    'SLOPE'       : (315, 2,  2, 'V', 'AA'),
    'SMALL'       : (326, 2,  2, 'V', 'RV'),
    'SQRT'        : ( 20, 1,  1, 'V', 'V'),
    'SQRTPI'      : ( -1, 1,  1, 'V', 'V'),
    'STANDARDIZE' : (297, 3,  3, 'V', 'VVV'),
    'STDEV'       : ( 12, 1, 30, 'V', 'D+'),
    'STDEVA'      : (366, 1, 30, 'V', 'D+'),
    'STDEVP'      : (193, 1, 30, 'V', 'D+'),
    'STDEVPA'     : (364, 1, 30, 'V', 'D+'),
    'STEYX'       : (314, 2,  2, 'V', 'AA'),
    'SUBSTITUTE'  : (120, 3,  4, 'V', 'VVVV'),
    'SUBTOTAL'    : (344, 2, 30, 'V', 'VR+'),
    'SUM'         : (  4, 1, 30, 'V', 'D+'),
    'SUMIF'       : (345, 2,  3, 'V', 'RVR'),
    'SUMPRODUCT'  : (228, 1, 30, 'V', 'A+'),
    'SUMSQ'       : (321, 1, 30, 'V', 'D+'),
    'SUMX2MY2'    : (304, 2,  2, 'V', 'AA'),
    'SUMX2PY2'    : (305, 2,  2, 'V', 'AA'),
    'SUMXMY2'     : (303, 2,  2, 'V', 'AA'),
    'SYD'         : (143, 4,  4, 'V', 'VVVV'),
    'T'           : (130, 1,  1, 'V', 'R'),
    'TAN'         : ( 17, 1,  1, 'V', 'V'),
    'TANH'        : (231, 1,  1, 'V', 'V'),
    'TBILLEQ'     : ( -1, 3,  3, 'V', 'VVV'),
    'TBILLPRICE'  : ( -1, 3,  3, 'V', 'VVV'),
    'TBILLYIELD'  : ( -1, 3,  3, 'V', 'VVV'),
    'TDIST'       : (301, 3,  3, 'V', 'VVV'),
    'TEXT'        : ( 48, 2,  2, 'V', 'VV'),
    'TIME'        : ( 66, 3,  3, 'V', 'VVV'),
    'TIMEVALUE'   : (141, 1,  1, 'V', 'V'),
    'TINV'        : (332, 2,  2, 'V', 'VV'),
    'TODAY'       : (221, 0,  0, 'V', '-'),
    'TRANSPOSE'   : ( 83, 1,  1, 'A', 'A'),
    'TREND'       : ( 50, 1,  4, 'A', 'RRRV'),
    'TRIM'        : (118, 1,  1, 'V', 'V'),
    'TRIMMEAN'    : (331, 2,  2, 'V', 'RV'),
    'TRUE'        : ( 34, 0,  0, 'V', '-'),
    'TRUNC'       : (197, 1,  2, 'V', 'VV'),
    'TTEST'       : (316, 4,  4, 'V', 'AAVV'),
    'TYPE'        : ( 86, 1,  1, 'V', 'V'),
    'UPPER'       : (113, 1,  1, 'V', 'V'),
    'USDOLLAR'    : (204, 1,  2, 'V', 'VV'),
    'VALUE'       : ( 33, 1,  1, 'V', 'V'),
    'VAR'         : ( 46, 1, 30, 'V', 'D+'),
    'VARA'        : (367, 1, 30, 'V', 'D+'),
    'VARP'        : (194, 1, 30, 'V', 'D+'),
    'VARPA'       : (365, 1, 30, 'V', 'D+'),
    'VDB'         : (222, 5,  7, 'V', 'VVVVVVV'),
    'VLOOKUP'     : (102, 3,  4, 'V', 'VRRV'),
    'WEEKDAY'     : ( 70, 1,  2, 'V', 'VV'),
    'WEEKNUM'     : ( -1, 1,  2, 'V', 'VV'),
    'WEIBULL'     : (302, 4,  4, 'V', 'VVVV'),
    'WORKDAY'     : ( -1, 2,  3, 'V', 'VVR'),
    'XIRR'        : ( -1, 2,  3, 'V', 'AAV'),
    'XNPV'        : ( -1, 3,  3, 'V', 'VAA'),
    'YEAR'        : ( 69, 1,  1, 'V', 'V'),
    'YEARFRAC'    : ( -1, 2,  3, 'V', 'VVV'),
    'YIELD'       : ( -1, 6,  7, 'V', 'VVVVVVV'),
    'YIELDDISC'   : ( -1, 4,  5, 'V', 'VVVVV'),
    'YIELDMAT'    : ( -1, 5,  6, 'V', 'VVVVVV'),
    'ZTEST'       : (324, 2,  3, 'V', 'RVV'),
    }

# Formulas Parse things

ptgExp          = 0x01
ptgTbl          = 0x02
ptgAdd          = 0x03
ptgSub          = 0x04
ptgMul          = 0x05
ptgDiv          = 0x06
ptgPower        = 0x07
ptgConcat       = 0x08
ptgLT           = 0x09
ptgLE           = 0x0a
ptgEQ           = 0x0b
ptgGE           = 0x0c
ptgGT           = 0x0d
ptgNE           = 0x0e
ptgIsect        = 0x0f
ptgUnion        = 0x10
ptgRange        = 0x11
ptgUplus        = 0x12
ptgUminus       = 0x13
ptgPercent      = 0x14
ptgParen        = 0x15
ptgMissArg      = 0x16
ptgStr          = 0x17
ptgExtend       = 0x18
ptgAttr         = 0x19
ptgSheet        = 0x1a
ptgEndSheet     = 0x1b
ptgErr          = 0x1c
ptgBool         = 0x1d
ptgInt          = 0x1e
ptgNum          = 0x1f

ptgArrayR       = 0x20
ptgFuncR        = 0x21
ptgFuncVarR     = 0x22
ptgNameR        = 0x23
ptgRefR         = 0x24
ptgAreaR        = 0x25
ptgMemAreaR     = 0x26
ptgMemErrR      = 0x27
ptgMemNoMemR    = 0x28
ptgMemFuncR     = 0x29
ptgRefErrR      = 0x2a
ptgAreaErrR     = 0x2b
ptgRefNR        = 0x2c
ptgAreaNR       = 0x2d
ptgMemAreaNR    = 0x2e
ptgMemNoMemNR   = 0x2f
ptgNameXR       = 0x39
ptgRef3dR       = 0x3a
ptgArea3dR      = 0x3b
ptgRefErr3dR    = 0x3c
ptgAreaErr3dR   = 0x3d

ptgArrayV       = 0x40
ptgFuncV        = 0x41
ptgFuncVarV     = 0x42
ptgNameV        = 0x43
ptgRefV         = 0x44
ptgAreaV        = 0x45
ptgMemAreaV     = 0x46
ptgMemErrV      = 0x47
ptgMemNoMemV    = 0x48
ptgMemFuncV     = 0x49
ptgRefErrV      = 0x4a
ptgAreaErrV     = 0x4b
ptgRefNV        = 0x4c
ptgAreaNV       = 0x4d
ptgMemAreaNV    = 0x4e
ptgMemNoMemNV   = 0x4f
ptgFuncCEV      = 0x58
ptgNameXV       = 0x59
ptgRef3dV       = 0x5a
ptgArea3dV      = 0x5b
ptgRefErr3dV    = 0x5c
ptgAreaErr3dV   = 0x5d

ptgArrayA       = 0x60
ptgFuncA        = 0x61
ptgFuncVarA     = 0x62
ptgNameA        = 0x63
ptgRefA         = 0x64
ptgAreaA        = 0x65
ptgMemAreaA     = 0x66
ptgMemErrA      = 0x67
ptgMemNoMemA    = 0x68
ptgMemFuncA     = 0x69
ptgRefErrA      = 0x6a
ptgAreaErrA     = 0x6b
ptgRefNA        = 0x6c
ptgAreaNA       = 0x6d
ptgMemAreaNA    = 0x6e
ptgMemNoMemNA   = 0x6f
ptgFuncCEA      = 0x78
ptgNameXA       = 0x79
ptgRef3dA       = 0x7a
ptgArea3dA      = 0x7b
ptgRefErr3dA    = 0x7c
ptgAreaErr3dA   = 0x7d


PtgNames = {
    ptgExp         : "ptgExp",
    ptgTbl         : "ptgTbl",
    ptgAdd         : "ptgAdd",
    ptgSub         : "ptgSub",
    ptgMul         : "ptgMul",
    ptgDiv         : "ptgDiv",
    ptgPower       : "ptgPower",
    ptgConcat      : "ptgConcat",
    ptgLT          : "ptgLT",
    ptgLE          : "ptgLE",
    ptgEQ          : "ptgEQ",
    ptgGE          : "ptgGE",
    ptgGT          : "ptgGT",
    ptgNE          : "ptgNE",
    ptgIsect       : "ptgIsect",
    ptgUnion       : "ptgUnion",
    ptgRange       : "ptgRange",
    ptgUplus       : "ptgUplus",
    ptgUminus      : "ptgUminus",
    ptgPercent     : "ptgPercent",
    ptgParen       : "ptgParen",
    ptgMissArg     : "ptgMissArg",
    ptgStr         : "ptgStr",
    ptgExtend      : "ptgExtend",
    ptgAttr        : "ptgAttr",
    ptgSheet       : "ptgSheet",
    ptgEndSheet    : "ptgEndSheet",
    ptgErr         : "ptgErr",
    ptgBool        : "ptgBool",
    ptgInt         : "ptgInt",
    ptgNum         : "ptgNum",
    ptgArrayR      : "ptgArrayR",
    ptgFuncR       : "ptgFuncR",
    ptgFuncVarR    : "ptgFuncVarR",
    ptgNameR       : "ptgNameR",
    ptgRefR        : "ptgRefR",
    ptgAreaR       : "ptgAreaR",
    ptgMemAreaR    : "ptgMemAreaR",
    ptgMemErrR     : "ptgMemErrR",
    ptgMemNoMemR   : "ptgMemNoMemR",
    ptgMemFuncR    : "ptgMemFuncR",
    ptgRefErrR     : "ptgRefErrR",
    ptgAreaErrR    : "ptgAreaErrR",
    ptgRefNR       : "ptgRefNR",
    ptgAreaNR      : "ptgAreaNR",
    ptgMemAreaNR   : "ptgMemAreaNR",
    ptgMemNoMemNR  : "ptgMemNoMemNR",
    ptgNameXR      : "ptgNameXR",
    ptgRef3dR      : "ptgRef3dR",
    ptgArea3dR     : "ptgArea3dR",
    ptgRefErr3dR   : "ptgRefErr3dR",
    ptgAreaErr3dR  : "ptgAreaErr3dR",
    ptgArrayV      : "ptgArrayV",
    ptgFuncV       : "ptgFuncV",
    ptgFuncVarV    : "ptgFuncVarV",
    ptgNameV       : "ptgNameV",
    ptgRefV        : "ptgRefV",
    ptgAreaV       : "ptgAreaV",
    ptgMemAreaV    : "ptgMemAreaV",
    ptgMemErrV     : "ptgMemErrV",
    ptgMemNoMemV   : "ptgMemNoMemV",
    ptgMemFuncV    : "ptgMemFuncV",
    ptgRefErrV     : "ptgRefErrV",
    ptgAreaErrV    : "ptgAreaErrV",
    ptgRefNV       : "ptgRefNV",
    ptgAreaNV      : "ptgAreaNV",
    ptgMemAreaNV   : "ptgMemAreaNV",
    ptgMemNoMemNV  : "ptgMemNoMemNV",
    ptgFuncCEV     : "ptgFuncCEV",
    ptgNameXV      : "ptgNameXV",
    ptgRef3dV      : "ptgRef3dV",
    ptgArea3dV     : "ptgArea3dV",
    ptgRefErr3dV   : "ptgRefErr3dV",
    ptgAreaErr3dV  : "ptgAreaErr3dV",
    ptgArrayA      : "ptgArrayA",
    ptgFuncA       : "ptgFuncA",
    ptgFuncVarA    : "ptgFuncVarA",
    ptgNameA       : "ptgNameA",
    ptgRefA        : "ptgRefA",
    ptgAreaA       : "ptgAreaA",
    ptgMemAreaA    : "ptgMemAreaA",
    ptgMemErrA     : "ptgMemErrA",
    ptgMemNoMemA   : "ptgMemNoMemA",
    ptgMemFuncA    : "ptgMemFuncA",
    ptgRefErrA     : "ptgRefErrA",
    ptgAreaErrA    : "ptgAreaErrA",
    ptgRefNA       : "ptgRefNA",
    ptgAreaNA      : "ptgAreaNA",
    ptgMemAreaNA   : "ptgMemAreaNA",
    ptgMemNoMemNA  : "ptgMemNoMemNA",
    ptgFuncCEA     : "ptgFuncCEA",
    ptgNameXA      : "ptgNameXA",
    ptgRef3dA      : "ptgRef3dA",
    ptgArea3dA     : "ptgArea3dA",
    ptgRefErr3dA   : "ptgRefErr3dA",
    ptgAreaErr3dA  : "ptgAreaErr3dA"
}


error_msg_by_code = {
    0x00: u"#NULL!",  # intersection of two cell ranges is empty
    0x07: u"#DIV/0!", # division by zero
    0x0F: u"#VALUE!", # wrong type of operand
    0x17: u"#REF!",   # illegal or deleted cell reference
    0x1D: u"#NAME?",  # wrong function or range name
    0x24: u"#NUM!",   # value range overflow
    0x2A: u"#N/A!"    # argument or function not available
}

########NEW FILE########
__FILENAME__ = Formatting
#!/usr/bin/env python
'''
The  XF  record is able to store explicit cell formatting attributes or the
attributes  of  a cell style. Explicit formatting includes the reference to
a  cell  style  XF  record. This allows to extend a defined cell style with
some  explicit  attributes.  The  formatting  attributes  are  divided into
6 groups:

Group           Attributes
-------------------------------------
Number format   Number format index (index to FORMAT record)
Font            Font index (index to FONT record)
Alignment       Horizontal and vertical alignment, text wrap, indentation,
                orientation/rotation, text direction
Border          Border line styles and colours
Background      Background area style and colours
Protection      Cell locked, formula hidden

For  each  group  a flag in the cell XF record specifies whether to use the
attributes  contained  in  that  XF  record  or  in  the  referenced  style
XF  record. In style XF records, these flags specify whether the attributes
will  overwrite  explicit  cell  formatting  when  the  style is applied to
a  cell. Changing a cell style (without applying this style to a cell) will
change  all  cells which already use that style and do not contain explicit
cell  attributes for the changed style attributes. If a cell XF record does
not  contain  explicit  attributes  in a group (if the attribute group flag
is not set), it repeats the attributes of its style XF record.

'''

import BIFFRecords

class Font(object):

    ESCAPEMENT_NONE         = 0x00
    ESCAPEMENT_SUPERSCRIPT  = 0x01
    ESCAPEMENT_SUBSCRIPT    = 0x02

    UNDERLINE_NONE          = 0x00
    UNDERLINE_SINGLE        = 0x01
    UNDERLINE_SINGLE_ACC    = 0x21
    UNDERLINE_DOUBLE        = 0x02
    UNDERLINE_DOUBLE_ACC    = 0x22

    FAMILY_NONE         = 0x00
    FAMILY_ROMAN        = 0x01
    FAMILY_SWISS        = 0x02
    FAMILY_MODERN       = 0x03
    FAMILY_SCRIPT       = 0x04
    FAMILY_DECORATIVE   = 0x05

    CHARSET_ANSI_LATIN          = 0x00
    CHARSET_SYS_DEFAULT         = 0x01
    CHARSET_SYMBOL              = 0x02
    CHARSET_APPLE_ROMAN         = 0x4D
    CHARSET_ANSI_JAP_SHIFT_JIS  = 0x80
    CHARSET_ANSI_KOR_HANGUL     = 0x81
    CHARSET_ANSI_KOR_JOHAB      = 0x82
    CHARSET_ANSI_CHINESE_GBK    = 0x86
    CHARSET_ANSI_CHINESE_BIG5   = 0x88
    CHARSET_ANSI_GREEK          = 0xA1
    CHARSET_ANSI_TURKISH        = 0xA2
    CHARSET_ANSI_VIETNAMESE     = 0xA3
    CHARSET_ANSI_HEBREW         = 0xB1
    CHARSET_ANSI_ARABIC         = 0xB2
    CHARSET_ANSI_BALTIC         = 0xBA
    CHARSET_ANSI_CYRILLIC       = 0xCC
    CHARSET_ANSI_THAI           = 0xDE
    CHARSET_ANSI_LATIN_II       = 0xEE
    CHARSET_OEM_LATIN_I         = 0xFF

    def __init__(self):
        # twip = 1/20 of a point = 1/1440 of a inch
        # usually resolution == 96 pixels per 1 inch
        # (rarely 120 pixels per 1 inch or another one)

        self.height = 0x00C8 # 200: this is font with height 10 points
        self.italic = False
        self.struck_out = False
        self.outline = False
        self.shadow = False
        self.colour_index = 0x7FFF
        self.bold = False
        self._weight = 0x0190 # 0x02BC gives bold font
        self.escapement = self.ESCAPEMENT_NONE
        self.underline = self.UNDERLINE_NONE
        self.family = self.FAMILY_NONE
        self.charset = self.CHARSET_SYS_DEFAULT
        self.name = 'Arial'

    def get_biff_record(self):
        height = self.height

        options = 0x00
        if self.bold:
            options |= 0x01
            self._weight = 0x02BC
        if self.italic:
            options |= 0x02
        if self.underline != self.UNDERLINE_NONE:
            options |= 0x04
        if self.struck_out:
            options |= 0x08
        if self.outline:
            options |= 0x010
        if self.shadow:
            options |= 0x020

        colour_index = self.colour_index
        weight = self._weight
        escapement = self.escapement
        underline = self.underline
        family = self.family
        charset = self.charset
        name = self.name

        return BIFFRecords.FontRecord(height, options, colour_index, weight, escapement,
                    underline, family, charset,
                    name)

    def _search_key(self):
        return (
            self.height,
            self.italic,
            self.struck_out,
            self.outline,
            self.shadow,
            self.colour_index,
            self.bold,
            self._weight,
            self.escapement,
            self.underline,
            self.family,
            self.charset,
            self.name,
            )

class Alignment(object):
    HORZ_GENERAL                = 0x00
    HORZ_LEFT                   = 0x01
    HORZ_CENTER                 = 0x02
    HORZ_RIGHT                  = 0x03
    HORZ_FILLED                 = 0x04
    HORZ_JUSTIFIED              = 0x05 # BIFF4-BIFF8X
    HORZ_CENTER_ACROSS_SEL      = 0x06 # Centred across selection (BIFF4-BIFF8X)
    HORZ_DISTRIBUTED            = 0x07 # Distributed (BIFF8X)

    VERT_TOP                    = 0x00
    VERT_CENTER                 = 0x01
    VERT_BOTTOM                 = 0x02
    VERT_JUSTIFIED              = 0x03 # Justified (BIFF5-BIFF8X)
    VERT_DISTRIBUTED            = 0x04 # Distributed (BIFF8X)

    DIRECTION_GENERAL           = 0x00 # BIFF8X
    DIRECTION_LR                = 0x01
    DIRECTION_RL                = 0x02

    ORIENTATION_NOT_ROTATED     = 0x00
    ORIENTATION_STACKED         = 0x01
    ORIENTATION_90_CC           = 0x02
    ORIENTATION_90_CW           = 0x03

    ROTATION_0_ANGLE            = 0x00
    ROTATION_STACKED            = 0xFF

    WRAP_AT_RIGHT               = 0x01
    NOT_WRAP_AT_RIGHT           = 0x00

    SHRINK_TO_FIT               = 0x01
    NOT_SHRINK_TO_FIT           = 0x00

    def __init__(self):
        self.horz = self.HORZ_GENERAL
        self.vert = self.VERT_BOTTOM
        self.dire = self.DIRECTION_GENERAL
        self.orie = self.ORIENTATION_NOT_ROTATED
        self.rota = self.ROTATION_0_ANGLE
        self.wrap = self.NOT_WRAP_AT_RIGHT
        self.shri = self.NOT_SHRINK_TO_FIT
        self.inde = 0
        self.merg = 0

    def _search_key(self):
        return (
            self.horz, self.vert, self.dire, self.orie, self.rota,
            self.wrap, self.shri, self.inde, self.merg,
            )

class Borders(object):
    NO_LINE = 0x00
    THIN    = 0x01
    MEDIUM  = 0x02
    DASHED  = 0x03
    DOTTED  = 0x04
    THICK   = 0x05
    DOUBLE  = 0x06
    HAIR    = 0x07
    #The following for BIFF8
    MEDIUM_DASHED               = 0x08
    THIN_DASH_DOTTED            = 0x09
    MEDIUM_DASH_DOTTED          = 0x0A
    THIN_DASH_DOT_DOTTED        = 0x0B
    MEDIUM_DASH_DOT_DOTTED      = 0x0C
    SLANTED_MEDIUM_DASH_DOTTED  = 0x0D

    NEED_DIAG1      = 0x01
    NEED_DIAG2      = 0x01
    NO_NEED_DIAG1   = 0x00
    NO_NEED_DIAG2   = 0x00

    def __init__(self):
        self.left   = self.NO_LINE
        self.right  = self.NO_LINE
        self.top    = self.NO_LINE
        self.bottom = self.NO_LINE
        self.diag   = self.NO_LINE

        self.left_colour   = 0x40
        self.right_colour  = 0x40
        self.top_colour    = 0x40
        self.bottom_colour = 0x40
        self.diag_colour   = 0x40

        self.need_diag1 = self.NO_NEED_DIAG1
        self.need_diag2 = self.NO_NEED_DIAG2

    def _search_key(self):
        return (
             self.left, self.right, self.top, self.bottom, self.diag,
             self.left_colour, self.right_colour, self.top_colour,
             self.bottom_colour, self.diag_colour,
             self.need_diag1, self.need_diag2,
            )

class Pattern(object):
    # patterns 0x00 - 0x12
    NO_PATTERN      = 0x00
    SOLID_PATTERN   = 0x01

    def __init__(self):
        self.pattern = self.NO_PATTERN
        self.pattern_fore_colour = 0x40
        self.pattern_back_colour = 0x41

    def _search_key(self):
        return (
            self.pattern,
            self.pattern_fore_colour,
            self.pattern_back_colour,
            )

class Protection(object):
    def __init__(self):
        self.cell_locked = 1
        self.formula_hidden = 0

    def _search_key(self):
        return (
            self.cell_locked,
            self.formula_hidden,
            )

########NEW FILE########
__FILENAME__ = Row
# -*- coding: windows-1252 -*-

import BIFFRecords
import Style
from Cell import StrCell, BlankCell, NumberCell, FormulaCell, MulBlankCell, BooleanCell, ErrorCell, \
    _get_cells_biff_data_mul
import ExcelFormula
import datetime as dt
try:
    from decimal import Decimal
except ImportError:
    # Python 2.3: decimal not supported; create dummy Decimal class
    class Decimal(object):
        pass


class Row(object):
    __slots__ = [# private variables
                 "__idx",
                 "__parent",
                 "__parent_wb",
                 "__cells",
                 "__min_col_idx",
                 "__max_col_idx",
                 "__xf_index",
                 "__has_default_xf_index",
                 "__height_in_pixels",
                 # public variables
                 "height",
                 "has_default_height",
                 "height_mismatch",
                 "level",
                 "collapse",
                 "hidden",
                 "space_above",
                 "space_below"]

    def __init__(self, rowx, parent_sheet):
        if not (isinstance(rowx, int) and 0 <= rowx <= 65535):
            raise ValueError("row index (%r) not an int in range(65536)" % rowx)
        self.__idx = rowx
        self.__parent = parent_sheet
        self.__parent_wb = parent_sheet.get_parent()
        self.__cells = {}
        self.__min_col_idx = 0
        self.__max_col_idx = 0
        self.__xf_index = 0x0F
        self.__has_default_xf_index = 0
        self.__height_in_pixels = 0x11

        self.height = 0x00FF
        self.has_default_height = 0x00
        self.height_mismatch = 0
        self.level = 0
        self.collapse = 0
        self.hidden = 0
        self.space_above = 0
        self.space_below = 0


    def __adjust_height(self, style):
        twips = style.font.height
        points = float(twips)/20.0
        # Cell height in pixels can be calcuted by following approx. formula:
        # cell height in pixels = font height in points * 83/50 + 2/5
        # It works when screen resolution is 96 dpi
        pix = int(round(points*83.0/50.0 + 2.0/5.0))
        if pix > self.__height_in_pixels:
            self.__height_in_pixels = pix


    def __adjust_bound_col_idx(self, *args):
        for arg in args:
            iarg = int(arg)
            if not ((0 <= iarg <= 255) and arg == iarg):
                raise ValueError("column index (%r) not an int in range(256)" % arg)
            sheet = self.__parent
            if iarg < self.__min_col_idx:
                self.__min_col_idx = iarg
            if iarg > self.__max_col_idx:
                self.__max_col_idx = iarg
            if iarg < sheet.first_used_col:
                sheet.first_used_col = iarg
            if iarg > sheet.last_used_col:
                sheet.last_used_col = iarg

    def __excel_date_dt(self, date):
        if isinstance(date, dt.date) and (not isinstance(date, dt.datetime)):
            epoch = dt.date(1899, 12, 31)
        elif isinstance(date, dt.time):
            date = dt.datetime.combine(dt.datetime(1900, 1, 1), date)
            epoch = dt.datetime(1900, 1, 1, 0, 0, 0)
        else:
            epoch = dt.datetime(1899, 12, 31, 0, 0, 0)
        delta = date - epoch
        xldate = delta.days + float(delta.seconds) / (24*60*60)
        # Add a day for Excel's missing leap day in 1900
        if xldate > 59:
            xldate += 1
        return xldate

    def get_height_in_pixels(self):
        return self.__height_in_pixels


    def set_style(self, style):
        self.__adjust_height(style)
        self.__xf_index = self.__parent_wb.add_style(style)
        self.__has_default_xf_index = 1


    def get_xf_index(self):
        return self.__xf_index


    def get_cells_count(self):
        return len(self.__cells)


    def get_min_col(self):
        return self.__min_col_idx


    def get_max_col(self):
        return self.__max_col_idx


    def get_row_biff_data(self):
        height_options = (self.height & 0x07FFF)
        height_options |= (self.has_default_height & 0x01) << 15

        options =  (self.level & 0x07) << 0
        options |= (self.collapse & 0x01) << 4
        options |= (self.hidden & 0x01) << 5
        options |= (self.height_mismatch & 0x01) << 6
        options |= (self.__has_default_xf_index & 0x01) << 7
        options |= (0x01 & 0x01) << 8
        options |= (self.__xf_index & 0x0FFF) << 16
        options |= (self.space_above & 1) << 28
        options |= (self.space_below & 1) << 29

        return BIFFRecords.RowRecord(self.__idx, self.__min_col_idx,
            self.__max_col_idx, height_options, options).get()

    def insert_cell(self, col_index, cell_obj):
        if col_index in self.__cells:
            if not self.__parent._cell_overwrite_ok:
                msg = "Attempt to overwrite cell: sheetname=%r rowx=%d colx=%d" \
                    % (self.__parent.name, self.__idx, col_index)
                raise Exception(msg)
            prev_cell_obj = self.__cells[col_index]
            sst_idx = getattr(prev_cell_obj, 'sst_idx', None)
            if sst_idx is not None:
                self.__parent_wb.del_str(sst_idx)
        self.__cells[col_index] = cell_obj

    def insert_mulcells(self, colx1, colx2, cell_obj):
        self.insert_cell(colx1, cell_obj)
        for col_index in xrange(colx1+1, colx2+1):
            self.insert_cell(col_index, None)

    def get_cells_biff_data(self):
        cell_items = [item for item in self.__cells.iteritems() if item[1] is not None]
        cell_items.sort() # in column order
        return _get_cells_biff_data_mul(self.__idx, cell_items)
        # previously:
        # return ''.join([cell.get_biff_data() for colx, cell in cell_items])

    def get_index(self):
        return self.__idx

    def set_cell_text(self, colx, value, style=Style.default_style):
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(colx)
        xf_index = self.__parent_wb.add_style(style)
        self.insert_cell(colx, StrCell(self.__idx, colx, xf_index, self.__parent_wb.add_str(value)))

    def set_cell_blank(self, colx, style=Style.default_style):
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(colx)
        xf_index = self.__parent_wb.add_style(style)
        self.insert_cell(colx, BlankCell(self.__idx, colx, xf_index))

    def set_cell_mulblanks(self, first_colx, last_colx, style=Style.default_style):
        assert 0 <= first_colx <= last_colx <= 255
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(first_colx, last_colx)
        xf_index = self.__parent_wb.add_style(style)
        # ncols = last_colx - first_colx + 1
        self.insert_mulcells(first_colx, last_colx, MulBlankCell(self.__idx, first_colx, last_colx, xf_index))

    def set_cell_number(self, colx, number, style=Style.default_style):
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(colx)
        xf_index = self.__parent_wb.add_style(style)
        self.insert_cell(colx, NumberCell(self.__idx, colx, xf_index, number))

    def set_cell_date(self, colx, datetime_obj, style=Style.default_style):
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(colx)
        xf_index = self.__parent_wb.add_style(style)
        self.insert_cell(colx,
            NumberCell(self.__idx, colx, xf_index, self.__excel_date_dt(datetime_obj)))

    def set_cell_formula(self, colx, formula, style=Style.default_style, calc_flags=0):
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(colx)
        xf_index = self.__parent_wb.add_style(style)
        self.__parent_wb.add_sheet_reference(formula)
        self.insert_cell(colx, FormulaCell(self.__idx, colx, xf_index, formula, calc_flags=0))

    def set_cell_boolean(self, colx, value, style=Style.default_style):
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(colx)
        xf_index = self.__parent_wb.add_style(style)
        self.insert_cell(colx, BooleanCell(self.__idx, colx, xf_index, bool(value)))

    def set_cell_error(self, colx, error_string_or_code, style=Style.default_style):
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(colx)
        xf_index = self.__parent_wb.add_style(style)
        self.insert_cell(colx, ErrorCell(self.__idx, colx, xf_index, error_string_or_code))

    def write(self, col, label, style=Style.default_style):
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(col)
        style_index = self.__parent_wb.add_style(style)
        if isinstance(label, basestring):
            if len(label) > 0:
                self.insert_cell(col,
                    StrCell(self.__idx, col, style_index, self.__parent_wb.add_str(label))
                    )
            else:
                self.insert_cell(col, BlankCell(self.__idx, col, style_index))
        elif isinstance(label, bool): # bool is subclass of int; test bool first
            self.insert_cell(col, BooleanCell(self.__idx, col, style_index, label))
        elif isinstance(label, (float, int, long, Decimal)):
            self.insert_cell(col, NumberCell(self.__idx, col, style_index, label))
        elif isinstance(label, (dt.datetime, dt.date, dt.time)):
            date_number = self.__excel_date_dt(label)
            self.insert_cell(col, NumberCell(self.__idx, col, style_index, date_number))
        elif label is None:
            self.insert_cell(col, BlankCell(self.__idx, col, style_index))
        elif isinstance(label, ExcelFormula.Formula):
            self.__parent_wb.add_sheet_reference(label)
            self.insert_cell(col, FormulaCell(self.__idx, col, style_index, label))
        else:
            raise Exception("Unexpected data type %r" % type(label))

    write_blanks = set_cell_mulblanks




########NEW FILE########
__FILENAME__ = Style
# -*- coding: windows-1252 -*-

import Formatting
from BIFFRecords import *

FIRST_USER_DEFINED_NUM_FORMAT_IDX = 164

class XFStyle(object):

    def __init__(self):
        self.num_format_str  = 'General'
        self.font            = Formatting.Font()
        self.alignment       = Formatting.Alignment()
        self.borders         = Formatting.Borders()
        self.pattern         = Formatting.Pattern()
        self.protection      = Formatting.Protection()

default_style = XFStyle()

class StyleCollection(object):
    _std_num_fmt_list = [
            'general',
            '0',
            '0.00',
            '#,##0',
            '#,##0.00',
            '"$"#,##0_);("$"#,##',
            '"$"#,##0_);[Red]("$"#,##',
            '"$"#,##0.00_);("$"#,##',
            '"$"#,##0.00_);[Red]("$"#,##',
            '0%',
            '0.00%',
            '0.00E+00',
            '# ?/?',
            '# ??/??',
            'M/D/YY',
            'D-MMM-YY',
            'D-MMM',
            'MMM-YY',
            'h:mm AM/PM',
            'h:mm:ss AM/PM',
            'h:mm',
            'h:mm:ss',
            'M/D/YY h:mm',
            '_(#,##0_);(#,##0)',
            '_(#,##0_);[Red](#,##0)',
            '_(#,##0.00_);(#,##0.00)',
            '_(#,##0.00_);[Red](#,##0.00)',
            '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',
            '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
            '_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',
            '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',
            'mm:ss',
            '[h]:mm:ss',
            'mm:ss.0',
            '##0.0E+0',
            '@'
    ]

    def __init__(self, style_compression=0):
        self.style_compression = style_compression
        self.stats = [0, 0, 0, 0, 0, 0]
        self._font_id2x = {}
        self._font_x2id = {}
        self._font_val2x = {}

        for x in (0, 1, 2, 3, 5): # The font with index 4 is omitted in all BIFF versions
            font = Formatting.Font()
            search_key = font._search_key()
            self._font_id2x[font] = x
            self._font_x2id[x] = font
            self._font_val2x[search_key] = x

        self._xf_id2x = {}
        self._xf_x2id = {}
        self._xf_val2x = {}

        self._num_formats = {}
        for fmtidx, fmtstr in zip(range(0, 23), StyleCollection._std_num_fmt_list[0:23]):
            self._num_formats[fmtstr] = fmtidx
        for fmtidx, fmtstr in zip(range(37, 50), StyleCollection._std_num_fmt_list[23:]):
            self._num_formats[fmtstr] = fmtidx

        self.default_style = XFStyle()
        self._default_xf = self._add_style(self.default_style)[0]

    def add(self, style):
        if style == None:
            return 0x10
        return self._add_style(style)[1]

    def _add_style(self, style):
        num_format_str = style.num_format_str
        if num_format_str in self._num_formats:
            num_format_idx = self._num_formats[num_format_str]
        else:
            num_format_idx = (
                FIRST_USER_DEFINED_NUM_FORMAT_IDX
                + len(self._num_formats)
                - len(StyleCollection._std_num_fmt_list)
                )
            self._num_formats[num_format_str] = num_format_idx

        font = style.font
        if font in self._font_id2x:
            font_idx = self._font_id2x[font]
            self.stats[0] += 1
        elif self.style_compression:
            search_key = font._search_key()
            font_idx = self._font_val2x.get(search_key)
            if font_idx is not None:
                self._font_id2x[font] = font_idx
                self.stats[1] += 1
            else:
                font_idx = len(self._font_x2id) + 1 # Why plus 1? Font 4 is missing
                self._font_id2x[font] = font_idx
                self._font_val2x[search_key] = font_idx
                self._font_x2id[font_idx] = font
                self.stats[2] += 1
        else:
            font_idx = len(self._font_id2x) + 1
            self._font_id2x[font] = font_idx
            self.stats[2] += 1

        gof = (style.alignment, style.borders, style.pattern, style.protection)
        xf = (font_idx, num_format_idx) + gof
        if xf in self._xf_id2x:
            xf_index = self._xf_id2x[xf]
            self.stats[3] += 1
        elif self.style_compression == 2:
            xf_key = (font_idx, num_format_idx) + tuple([obj._search_key() for obj in gof])
            xf_index = self._xf_val2x.get(xf_key)
            if xf_index is not None:
                self._xf_id2x[xf] = xf_index
                self.stats[4] += 1
            else:
                xf_index = 0x10 + len(self._xf_x2id)
                self._xf_id2x[xf] = xf_index
                self._xf_val2x[xf_key] = xf_index
                self._xf_x2id[xf_index] = xf
                self.stats[5] += 1
        else:
            xf_index = 0x10 + len(self._xf_id2x)
            self._xf_id2x[xf] = xf_index
            self.stats[5] += 1

        if xf_index >= 0xFFF:
            # 12 bits allowed, 0xFFF is a sentinel value
            raise ValueError("More than 4094 XFs (styles)")

        return xf, xf_index

    def get_biff_data(self):
        result = ''
        result += self._all_fonts()
        result += self._all_num_formats()
        result += self._all_cell_styles()
        result += self._all_styles()
        return result

    def _all_fonts(self):
        result = ''
        if self.style_compression:
            alist = self._font_x2id.items()
        else:
            alist = [(x, o) for o, x in self._font_id2x.items()]
        alist.sort()
        for font_idx, font in alist:
            result += font.get_biff_record().get()
        return result

    def _all_num_formats(self):
        result = ''
        alist = [
            (v, k)
            for k, v in self._num_formats.items()
            if v >= FIRST_USER_DEFINED_NUM_FORMAT_IDX
            ]
        alist.sort()
        for fmtidx, fmtstr in alist:
            result += NumberFormatRecord(fmtidx, fmtstr).get()
        return result

    def _all_cell_styles(self):
        result = ''
        for i in range(0, 16):
            result += XFRecord(self._default_xf, 'style').get()
        if self.style_compression == 2:
            alist = self._xf_x2id.items()
        else:
            alist = [(x, o) for o, x in self._xf_id2x.items()]
        alist.sort()
        for xf_idx, xf in alist:
            result += XFRecord(xf).get()
        return result

    def _all_styles(self):
        return StyleRecord().get()

# easyxf and its supporting objects ###################################

class EasyXFException(Exception):
    pass

class EasyXFCallerError(EasyXFException):
    pass

class EasyXFAuthorError(EasyXFException):
    pass

class IntULim(object):
    # If astring represents a valid unsigned integer ('123', '0xabcd', etc)
    # and it is <= limit, return the int value; otherwise return None.

    def __init__(self, limit):
        self.limit = limit

    def __call__(self, astring):
        try:
            value = int(astring, 0)
        except ValueError:
            return None
        if not 0 <= value <= self.limit:
            return None
        return value

bool_map = {
    # Text values for all Boolean attributes
    '1': 1, 'yes': 1, 'true':  1, 'on':  1,
    '0': 0, 'no':  0, 'false': 0, 'off': 0,
    }

border_line_map = {
    # Text values for these borders attributes:
    # left, right, top, bottom and diag
    'no_line':  0x00,
    'thin':     0x01,
    'medium':   0x02,
    'dashed':   0x03,
    'dotted':   0x04,
    'thick':    0x05,
    'double':   0x06,
    'hair':     0x07,
    'medium_dashed':                0x08,
    'thin_dash_dotted':             0x09,
    'medium_dash_dotted':           0x0a,
    'thin_dash_dot_dotted':         0x0b,
    'medium_dash_dot_dotted':       0x0c,
    'slanted_medium_dash_dotted':   0x0d,
    }

charset_map = {
    # Text values for font.charset
    'ansi_latin':           0x00,
    'sys_default':          0x01,
    'symbol':               0x02,
    'apple_roman':          0x4d,
    'ansi_jap_shift_jis':   0x80,
    'ansi_kor_hangul':      0x81,
    'ansi_kor_johab':       0x82,
    'ansi_chinese_gbk':     0x86,
    'ansi_chinese_big5':    0x88,
    'ansi_greek':           0xa1,
    'ansi_turkish':         0xa2,
    'ansi_vietnamese':      0xa3,
    'ansi_hebrew':          0xb1,
    'ansi_arabic':          0xb2,
    'ansi_baltic':          0xba,
    'ansi_cyrillic':        0xcc,
    'ansi_thai':            0xde,
    'ansi_latin_ii':        0xee,
    'oem_latin_i':          0xff,
    }


# Text values for colour indices. "grey" is a synonym of "gray".
# The names are those given by Microsoft Excel 2003 to the colours
# in the default palette. There is no great correspondence with
# any W3C name-to-RGB mapping.
_colour_map_text = """\
aqua 0x31
black 0x08
blue 0x0C
blue_gray 0x36
bright_green 0x0B
brown 0x3C
coral 0x1D
cyan_ega 0x0F
dark_blue 0x12
dark_blue_ega 0x12
dark_green 0x3A
dark_green_ega 0x11
dark_purple 0x1C
dark_red 0x10
dark_red_ega 0x10
dark_teal 0x38
dark_yellow 0x13
gold 0x33
gray_ega 0x17
gray25 0x16
gray40 0x37
gray50 0x17
gray80 0x3F
green 0x11
ice_blue 0x1F
indigo 0x3E
ivory 0x1A
lavender 0x2E
light_blue 0x30
light_green 0x2A
light_orange 0x34
light_turquoise 0x29
light_yellow 0x2B
lime 0x32
magenta_ega 0x0E
ocean_blue 0x1E
olive_ega 0x13
olive_green 0x3B
orange 0x35
pale_blue 0x2C
periwinkle 0x18
pink 0x0E
plum 0x3D
purple_ega 0x14
red 0x0A
rose 0x2D
sea_green 0x39
silver_ega 0x16
sky_blue 0x28
tan 0x2F
teal 0x15
teal_ega 0x15
turquoise 0x0F
violet 0x14
white 0x09
yellow 0x0D"""

colour_map = {}
for _line in _colour_map_text.splitlines():
    _name, _num = _line.split()
    _num = int(_num, 0)
    colour_map[_name] = _num
    if 'gray' in _name:
        colour_map[_name.replace('gray', 'grey')] = _num
del _colour_map_text, _line, _name, _num


pattern_map = {
    # Text values for pattern.pattern
    # xlwt/doc/pattern_examples.xls showcases all of these patterns.
    'no_fill':              0,
    'none':                 0,
    'solid':                1,
    'solid_fill':           1,
    'solid_pattern':        1,
    'fine_dots':            2,
    'alt_bars':             3,
    'sparse_dots':          4,
    'thick_horz_bands':     5,
    'thick_vert_bands':     6,
    'thick_backward_diag':  7,
    'thick_forward_diag':   8,
    'big_spots':            9,
    'bricks':               10,
    'thin_horz_bands':      11,
    'thin_vert_bands':      12,
    'thin_backward_diag':   13,
    'thin_forward_diag':    14,
    'squares':              15,
    'diamonds':             16,
    }

def any_str_func(s):
    return s.strip()

def colour_index_func(s, maxval=0x7F):
    try:
        value = int(s, 0)
    except ValueError:
        return None
    if not (0 <= value <= maxval):
        return None
    return value

colour_index_func_7 = colour_index_func

def colour_index_func_15(s):
    return colour_index_func(s, maxval=0x7FFF)

def rotation_func(s):
    try:
        value = int(s, 0)
    except ValueError:
        return None
    if not (-90 <= value <= 90):
        raise EasyXFCallerError("rotation %d: should be -90 to +90 degrees" % value)
    if value < 0:
        value = 90 - value # encode as 91 to 180 (clockwise)
    return value

xf_dict = {
    'align': 'alignment', # synonym
    'alignment': {
        'dire': {
            'general': 0,
            'lr': 1,
            'rl': 2,
            },
        'direction': 'dire',
        'horiz': 'horz',
        'horizontal': 'horz',
        'horz': {
            'general': 0,
            'left': 1,
            'center': 2,
            'centre': 2, # "align: horiz centre" means xf.alignment.horz is set to 2
            'right': 3,
            'filled': 4,
            'justified': 5,
            'center_across_selection': 6,
            'centre_across_selection': 6,
            'distributed': 7,
            },
        'inde': IntULim(15), # restriction: 0 <= value <= 15
        'indent': 'inde',
        'rota': [{'stacked': 255, 'none': 0, }, rotation_func],
        'rotation': 'rota',
        'shri': bool_map,
        'shrink': 'shri',
        'shrink_to_fit': 'shri',
        'vert': {
            'top': 0,
            'center': 1,
            'centre': 1,
            'bottom': 2,
            'justified': 3,
            'distributed': 4,
            },
         'vertical': 'vert',
         'wrap': bool_map,
         },
    'border': 'borders',
    'borders': {
        'left':     [border_line_map, IntULim(0x0d)],
        'right':    [border_line_map, IntULim(0x0d)],
        'top':      [border_line_map, IntULim(0x0d)],
        'bottom':   [border_line_map, IntULim(0x0d)],
        'diag':     [border_line_map, IntULim(0x0d)],
        'top_colour':       [colour_map, colour_index_func_7],
        'bottom_colour':    [colour_map, colour_index_func_7],
        'left_colour':      [colour_map, colour_index_func_7],
        'right_colour':     [colour_map, colour_index_func_7],
        'diag_colour':      [colour_map, colour_index_func_7],
        'top_color':        'top_colour',
        'bottom_color':     'bottom_colour',
        'left_color':       'left_colour',
        'right_color':      'right_colour',
        'diag_color':       'diag-colour',
        'need_diag_1':  bool_map,
        'need_diag_2':  bool_map,
        },
    'font': {
        'bold': bool_map,
        'charset': charset_map,
        'color':  'colour_index',
        'color_index':  'colour_index',
        'colour':  'colour_index',
        'colour_index': [colour_map, colour_index_func_15],
        'escapement': {'none': 0, 'superscript': 1, 'subscript': 2},
        'family': {'none': 0, 'roman': 1, 'swiss': 2, 'modern': 3, 'script': 4, 'decorative': 5, },
        'height': IntULim(0xFFFF), # practical limits are much narrower e.g. 160 to 1440 (8pt to 72pt)
        'italic': bool_map,
        'name': any_str_func,
        'outline': bool_map,
        'shadow': bool_map,
        'struck_out': bool_map,
        'underline': [bool_map, {'none': 0, 'single': 1, 'single_acc': 0x21, 'double': 2, 'double_acc': 0x22, }],
        },
    'pattern': {
        'back_color':   'pattern_back_colour',
        'back_colour':  'pattern_back_colour',
        'fore_color':   'pattern_fore_colour',
        'fore_colour':  'pattern_fore_colour',
        'pattern': [pattern_map, IntULim(16)],
        'pattern_back_color':   'pattern_back_colour',
        'pattern_back_colour':  [colour_map, colour_index_func_7],
        'pattern_fore_color':   'pattern_fore_colour',
        'pattern_fore_colour':  [colour_map, colour_index_func_7],
        },
    'protection': {
        'cell_locked' :   bool_map,
        'formula_hidden': bool_map,
        },
    }

def _esplit(s, split_char, esc_char="\\"):
    escaped = False
    olist = ['']
    for c in s:
        if escaped:
            olist[-1] += c
            escaped = False
        elif c == esc_char:
            escaped = True
        elif c == split_char:
            olist.append('')
        else:
            olist[-1] += c
    return olist

def _parse_strg_to_obj(strg, obj, parse_dict,
    field_sep=",", line_sep=";", intro_sep=":", esc_char="\\", debug=False):
    for line in _esplit(strg, line_sep, esc_char):
        line = line.strip()
        if not line:
            break
        split_line = _esplit(line, intro_sep, esc_char)
        if len(split_line) != 2:
            raise EasyXFCallerError('line %r should have exactly 1 "%c"' % (line, intro_sep))
        section, item_str = split_line
        section = section.strip().lower()
        for counter in range(2):
            result = parse_dict.get(section)
            if result is None:
                raise EasyXFCallerError('section %r is unknown' % section)
            if isinstance(result, dict):
                break
            if not isinstance(result, str):
                raise EasyXFAuthorError(
                    'section %r should map to dict or str object; found %r' % (section, type(result)))
            # synonym
            old_section = section
            section = result
        else:
            raise EasyXFAuthorError('Attempt to define synonym of synonym (%r: %r)' % (old_section, result))
        section_dict = result
        section_obj = getattr(obj, section, None)
        if section_obj is None:
            raise EasyXFAuthorError('instance of %s class has no attribute named %s' % (obj.__class__.__name__, section))
        for kv_str in _esplit(item_str, field_sep, esc_char):
            guff = kv_str.split()
            if not guff:
                continue
            k = guff[0].lower().replace('-', '_')
            v = ' '.join(guff[1:])
            if not v:
                raise EasyXFCallerError("no value supplied for %s.%s" % (section, k))
            for counter in xrange(2):
                result = section_dict.get(k)
                if result is None:
                    raise EasyXFCallerError('%s.%s is not a known attribute' % (section, k))
                if not isinstance(result, basestring):
                    break
                # synonym
                old_k = k
                k = result
            else:
                raise EasyXFAuthorError('Attempt to define synonym of synonym (%r: %r)' % (old_k, result))
            value_info = result
            if not isinstance(value_info, list):
                value_info = [value_info]
            for value_rule in value_info:
                if isinstance(value_rule, dict):
                    # dict maps strings to integer field values
                    vl = v.lower().replace('-', '_')
                    if vl in value_rule:
                        value = value_rule[vl]
                        break
                elif callable(value_rule):
                    value = value_rule(v)
                    if value is not None:
                        break
                else:
                    raise EasyXFAuthorError("unknown value rule for attribute %r: %r" % (k, value_rule))
            else:
                raise EasyXFCallerError("unexpected value %r for %s.%s" % (v, section, k))
            try:
                orig = getattr(section_obj, k)
            except AttributeError:
                raise EasyXFAuthorError('%s.%s in dictionary but not in supplied object' % (section, k))
            if debug: print "+++ %s.%s = %r # %s; was %r" % (section, k, value, v, orig)
            setattr(section_obj, k, value)

def easyxf(strg_to_parse="", num_format_str=None,
    field_sep=",", line_sep=";", intro_sep=":", esc_char="\\", debug=False):
    xfobj = XFStyle()
    if num_format_str is not None:
        xfobj.num_format_str = num_format_str
    if strg_to_parse:
        _parse_strg_to_obj(strg_to_parse, xfobj, xf_dict,
            field_sep=field_sep, line_sep=line_sep, intro_sep=intro_sep, esc_char=esc_char, debug=debug)
    return xfobj

########NEW FILE########
__FILENAME__ = UnicodeUtils
# -*- coding: windows-1252 -*-

'''
From BIFF8 on, strings are always stored using UTF-16LE  text encoding. The
character  array  is  a  sequence  of  16-bit  values4.  Additionally it is
possible  to  use  a  compressed  format, which omits the high bytes of all
characters, if they are all zero.

The following tables describe the standard format of the entire string, but
in many records the strings differ from this format. This will be mentioned
separately. It is possible (but not required) to store Rich-Text formatting
information  and  Asian  phonetic information inside a Unicode string. This
results  in  four  different  ways  to  store a string. The character array
is not zero-terminated.

The  string  consists  of  the  character count (as usual an 8-bit value or
a  16-bit value), option flags, the character array and optional formatting
information.  If the string is empty, sometimes the option flags field will
not occur. This is mentioned at the respective place.

Offset  Size    Contents
0       1 or 2  Length of the string (character count, ln)
1 or 2  1       Option flags:
                  Bit   Mask Contents
                  0     01H  Character compression (ccompr):
                               0 = Compressed (8-bit characters)
                               1 = Uncompressed (16-bit characters)
                  2     04H  Asian phonetic settings (phonetic):
                               0 = Does not contain Asian phonetic settings
                               1 = Contains Asian phonetic settings
                  3     08H  Rich-Text settings (richtext):
                               0 = Does not contain Rich-Text settings
                               1 = Contains Rich-Text settings
[2 or 3] 2      (optional, only if richtext=1) Number of Rich-Text formatting runs (rt)
[var.]   4      (optional, only if phonetic=1) Size of Asian phonetic settings block (in bytes, sz)
var.     ln or 
         2ln   Character array (8-bit characters or 16-bit characters, dependent on ccompr)
[var.]   4rt   (optional, only if richtext=1) List of rt formatting runs 
[var.]   sz     (optional, only if phonetic=1) Asian Phonetic Settings Block 
'''


from struct import pack

def upack2(s, encoding='ascii'):
    # If not unicode, make it so.
    if isinstance(s, unicode):
        us = s
    else:
        us = unicode(s, encoding)
    # Limit is based on number of content characters
    # (not on number of bytes in packed result)
    len_us = len(us)
    if len_us > 65535:
        raise Exception('String longer than 65535 characters')
    try:
        encs = us.encode('latin1')
        # Success here means all chars are in U+0000 to U+00FF
        # inclusive, meaning that we can use "compressed format".
        flag = 0
    except UnicodeEncodeError:
        encs = us.encode('utf_16_le')
        flag = 1
    return pack('<HB', len_us, flag) + encs

def upack1(s, encoding='ascii'):
    # Same as upack2(), but with a one-byte length field.
    if isinstance(s, unicode):
        us = s
    else:
        us = unicode(s, encoding)
    len_us = len(us)
    if len_us > 255:
        raise Exception('String longer than 255 characters')
    try:
        encs = us.encode('latin1')
        flag = 0
    except UnicodeEncodeError:
        encs = us.encode('utf_16_le')
        flag = 1
    return pack('<BB', len_us, flag) + encs

########NEW FILE########
__FILENAME__ = Utils
# pyXLWriter: A library for generating Excel Spreadsheets
# Copyright (c) 2004 Evgeny Filatov <fufff@users.sourceforge.net>
# Copyright (c) 2002-2004 John McNamara (Perl Spreadsheet::WriteExcel)
#
# This library is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# This library is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser
# General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this library; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#----------------------------------------------------------------------------
# This module was written/ported from PERL Spreadsheet::WriteExcel module
# The author of the PERL Spreadsheet::WriteExcel module is John McNamara
# <jmcnamara@cpan.org>
#----------------------------------------------------------------------------
# See the README.txt distributed with pyXLWriter for more details.

# Portions are (C) Roman V. Kiseliov, 2005


# Utilities for work with reference to cells and with sheetnames


__rev_id__ = """$Id: Utils.py 3844 2009-05-20 01:02:54Z sjmachin $"""

import re
from struct import pack
from ExcelMagic import MAX_ROW, MAX_COL


_re_cell_ex = re.compile(r"(\$?)([A-I]?[A-Z])(\$?)(\d+)", re.IGNORECASE)
_re_row_range = re.compile(r"\$?(\d+):\$?(\d+)")
_re_col_range = re.compile(r"\$?([A-I]?[A-Z]):\$?([A-I]?[A-Z])", re.IGNORECASE)
_re_cell_range = re.compile(r"\$?([A-I]?[A-Z]\$?\d+):\$?([A-I]?[A-Z]\$?\d+)", re.IGNORECASE)
_re_cell_ref = re.compile(r"\$?([A-I]?[A-Z]\$?\d+)", re.IGNORECASE)


def col_by_name(colname):
    """
    """
    col = 0
    pow = 1
    for i in xrange(len(colname)-1, -1, -1):
        ch = colname[i]
        col += (ord(ch) - ord('A') + 1) * pow
        pow *= 26
    return col - 1


def cell_to_rowcol(cell):
    """Convert an Excel cell reference string in A1 notation
    to numeric row/col notation.

    Returns: row, col, row_abs, col_abs

    """
    m = _re_cell_ex.match(cell)
    if not m:
        raise Exception("Ill-formed single_cell reference: %s" % cell)
    col_abs, col, row_abs, row = m.groups()
    row_abs = bool(row_abs)
    col_abs = bool(col_abs)
    row = int(row) - 1
    col = col_by_name(col.upper())
    return row, col, row_abs, col_abs


def cell_to_rowcol2(cell):
    """Convert an Excel cell reference string in A1 notation
    to numeric row/col notation.

    Returns: row, col

    """
    m = _re_cell_ex.match(cell)
    if not m:
        raise Exception("Error in cell format")
    col_abs, col, row_abs, row = m.groups()
    # Convert base26 column string to number
    # All your Base are belong to us.
    row = int(row) - 1
    col = col_by_name(col.upper())
    return row, col


def rowcol_to_cell(row, col, row_abs=False, col_abs=False):
    """Convert numeric row/col notation to an Excel cell reference string in
    A1 notation.

    """
    assert 0 <= row < MAX_ROW # MAX_ROW counts from 1
    assert 0 <= col < MAX_COL # MAX_COL counts from 1
    d = col // 26
    m = col % 26
    chr1 = ""    # Most significant character in AA1
    if row_abs:
        row_abs = '$'
    else:
        row_abs = ''
    if col_abs:
        col_abs = '$'
    else:
        col_abs = ''
    if d > 0:
        chr1 = chr(ord('A') + d  - 1)
    chr2 = chr(ord('A') + m)
    # Zero index to 1-index
    return col_abs + chr1 + chr2 + row_abs + str(row + 1)

def rowcol_pair_to_cellrange(row1, col1, row2, col2,
    row1_abs=False, col1_abs=False, row2_abs=False, col2_abs=False):
    """Convert two (row,column) pairs
    into a cell range string in A1:B2 notation.

    Returns: cell range string
    """
    assert row1 <= row2
    assert col1 <= col2
    return (
        rowcol_to_cell(row1, col1, row1_abs, col1_abs)
        + ":"
        + rowcol_to_cell(row2, col2, row2_abs, col2_abs)
        )

def cellrange_to_rowcol_pair(cellrange):
    """Convert cell range string in A1 notation to numeric row/col
    pair.

    Returns: row1, col1, row2, col2

    """
    cellrange = cellrange.upper()
    # Convert a row range: '1:3'
    res = _re_row_range.match(cellrange)
    if res:
        row1 = int(res.group(1)) - 1
        col1 = 0
        row2 = int(res.group(2)) - 1
        col2 = -1
        return row1, col1, row2, col2
    # Convert a column range: 'A:A' or 'B:G'.
    # A range such as A:A is equivalent to A1:A16384, so add rows as required
    res = _re_col_range.match(cellrange)
    if res:
        col1 = col_by_name(res.group(1).upper())
        row1 = 0
        col2 = col_by_name(res.group(2).upper())
        row2 = -1
        return row1, col1, row2, col2
    # Convert a cell range: 'A1:B7'
    res = _re_cell_range.match(cellrange)
    if res:
        row1, col1 = cell_to_rowcol2(res.group(1))
        row2, col2 = cell_to_rowcol2(res.group(2))
        return row1, col1, row2, col2
    # Convert a cell reference: 'A1' or 'AD2000'
    res = _re_cell_ref.match(cellrange)
    if res:
        row1, col1 = cell_to_rowcol2(res.group(1))
        return row1, col1, row1, col1
    raise Exception("Unknown cell reference %s" % (cell))


def cell_to_packed_rowcol(cell):
    """ pack row and column into the required 4 byte format """
    row, col, row_abs, col_abs = cell_to_rowcol(cell)
    if col >= MAX_COL:
        raise Exception("Column %s greater than IV in formula" % cell)
    if row >= MAX_ROW: # this for BIFF8. for BIFF7 available 2^14
        raise Exception("Row %s greater than %d in formula" % (cell, MAX_ROW))
    col |= int(not row_abs) << 15
    col |= int(not col_abs) << 14
    return row, col

# === sheetname functions ===

def valid_sheet_name(sheet_name):
    if sheet_name == u"" or sheet_name[0] == u"'" or len(sheet_name) > 31:
        return False
    for c in sheet_name:
        if c in u"[]:\\?/*\x00":
            return False
    return True

def quote_sheet_name(unquoted_sheet_name):
    if not valid_sheet_name(unquoted_sheet_name):
        raise Exception(
            'attempt to quote an invalid worksheet name %r' % unquoted_sheet_name)
    return u"'" + unquoted_sheet_name.replace(u"'", u"''") + u"'"

########NEW FILE########
__FILENAME__ = Workbook
# -*- coding: windows-1252 -*-
'''
Record Order in BIFF8
  Workbook Globals Substream
      BOF Type = workbook globals
      Interface Header
      MMS
      Interface End
      WRITEACCESS
      CODEPAGE
      DSF
      TABID
      FNGROUPCOUNT
      Workbook Protection Block
            WINDOWPROTECT
            PROTECT
            PASSWORD
            PROT4REV
            PROT4REVPASS
      BACKUP
      HIDEOBJ
      WINDOW1
      DATEMODE
      PRECISION
      REFRESHALL
      BOOKBOOL
      FONT +
      FORMAT *
      XF +
      STYLE +
    ? PALETTE
      USESELFS

      BOUNDSHEET +

      COUNTRY
    ? Link Table
      SST
      ExtSST
      EOF
'''

import BIFFRecords
import Style

class Workbook(object):

    #################################################################
    ## Constructor
    #################################################################
    def __init__(self, encoding='ascii', style_compression=0):
        self.encoding = encoding
        self.__owner = 'None'
        self.__country_code = None # 0x07 is Russia :-)
        self.__wnd_protect = 0
        self.__obj_protect = 0
        self.__protect = 0
        self.__backup_on_save = 0
        # for WINDOW1 record
        self.__hpos_twips = 0x01E0
        self.__vpos_twips = 0x005A
        self.__width_twips = 0x3FCF
        self.__height_twips = 0x2A4E

        self.__active_sheet = 0
        self.__first_tab_index = 0
        self.__selected_tabs = 0x01
        self.__tab_width_twips = 0x0258

        self.__wnd_hidden = 0
        self.__wnd_mini = 0
        self.__hscroll_visible = 1
        self.__vscroll_visible = 1
        self.__tabs_visible = 1

        self.__styles = Style.StyleCollection(style_compression)

        self.__dates_1904 = 0
        self.__use_cell_values = 1

        self.__sst = BIFFRecords.SharedStringTable(self.encoding)

        self.__worksheets = []
        self.__worksheet_idx_from_name = {}
        self.__sheet_refs = {}
        self._supbook_xref = {}
        self._xcall_xref = {}
        self._ownbook_supbookx = None
        self._ownbook_supbook_ref = None
        self._xcall_supbookx = None
        self._xcall_supbook_ref = None



    #################################################################
    ## Properties, "getters", "setters"
    #################################################################

    def get_style_stats(self):
        return self.__styles.stats[:]

    def set_owner(self, value):
        self.__owner = value

    def get_owner(self):
        return self.__owner

    owner = property(get_owner, set_owner)

    #################################################################

    def set_country_code(self, value):
        self.__country_code = value

    def get_country_code(self):
        return self.__country_code

    country_code = property(get_country_code, set_country_code)

    #################################################################

    def set_wnd_protect(self, value):
        self.__wnd_protect = int(value)

    def get_wnd_protect(self):
        return bool(self.__wnd_protect)

    wnd_protect = property(get_wnd_protect, set_wnd_protect)

    #################################################################

    def set_obj_protect(self, value):
        self.__obj_protect = int(value)

    def get_obj_protect(self):
        return bool(self.__obj_protect)

    obj_protect = property(get_obj_protect, set_obj_protect)

    #################################################################

    def set_protect(self, value):
        self.__protect = int(value)

    def get_protect(self):
        return bool(self.__protect)

    protect = property(get_protect, set_protect)

    #################################################################

    def set_backup_on_save(self, value):
        self.__backup_on_save = int(value)

    def get_backup_on_save(self):
        return bool(self.__backup_on_save)

    backup_on_save = property(get_backup_on_save, set_backup_on_save)

    #################################################################

    def set_hpos(self, value):
        self.__hpos_twips = value & 0xFFFF

    def get_hpos(self):
        return self.__hpos_twips

    hpos = property(get_hpos, set_hpos)

    #################################################################

    def set_vpos(self, value):
        self.__vpos_twips = value & 0xFFFF

    def get_vpos(self):
        return self.__vpos_twips

    vpos = property(get_vpos, set_vpos)

    #################################################################

    def set_width(self, value):
        self.__width_twips = value & 0xFFFF

    def get_width(self):
        return self.__width_twips

    width = property(get_width, set_width)

    #################################################################

    def set_height(self, value):
        self.__height_twips = value & 0xFFFF

    def get_height(self):
        return self.__height_twips

    height = property(get_height, set_height)

    #################################################################

    def set_active_sheet(self, value):
        self.__active_sheet = value & 0xFFFF
        self.__first_tab_index = self.__active_sheet

    def get_active_sheet(self):
        return self.__active_sheet

    active_sheet = property(get_active_sheet, set_active_sheet)

    #################################################################

    def set_tab_width(self, value):
        self.__tab_width_twips = value & 0xFFFF

    def get_tab_width(self):
        return self.__tab_width_twips

    tab_width = property(get_tab_width, set_tab_width)

    #################################################################

    def set_wnd_visible(self, value):
        self.__wnd_hidden = int(not value)

    def get_wnd_visible(self):
        return not bool(self.__wnd_hidden)

    wnd_visible = property(get_wnd_visible, set_wnd_visible)

    #################################################################

    def set_wnd_mini(self, value):
        self.__wnd_mini = int(value)

    def get_wnd_mini(self):
        return bool(self.__wnd_mini)

    wnd_mini = property(get_wnd_mini, set_wnd_mini)

    #################################################################

    def set_hscroll_visible(self, value):
        self.__hscroll_visible = int(value)

    def get_hscroll_visible(self):
        return bool(self.__hscroll_visible)

    hscroll_visible = property(get_hscroll_visible, set_hscroll_visible)

    #################################################################

    def set_vscroll_visible(self, value):
        self.__vscroll_visible = int(value)

    def get_vscroll_visible(self):
        return bool(self.__vscroll_visible)

    vscroll_visible = property(get_vscroll_visible, set_vscroll_visible)

    #################################################################

    def set_tabs_visible(self, value):
        self.__tabs_visible = int(value)

    def get_tabs_visible(self):
        return bool(self.__tabs_visible)

    tabs_visible = property(get_tabs_visible, set_tabs_visible)

    #################################################################

    def set_dates_1904(self, value):
        self.__dates_1904 = int(value)

    def get_dates_1904(self):
        return bool(self.__dates_1904)

    dates_1904 = property(get_dates_1904, set_dates_1904)

    #################################################################

    def set_use_cell_values(self, value):
        self.__use_cell_values = int(value)

    def get_use_cell_values(self):
        return bool(self.__use_cell_values)

    use_cell_values = property(get_use_cell_values, set_use_cell_values)

    #################################################################

    def get_default_style(self):
        return self.__styles.default_style

    default_style = property(get_default_style)

    ##################################################################
    ## Methods
    ##################################################################

    def add_style(self, style):
        return self.__styles.add(style)

    def add_str(self, s):
        return self.__sst.add_str(s)

    def del_str(self, sst_idx):
        self.__sst.del_str(sst_idx)

    def str_index(self, s):
        return self.__sst.str_index(s)

    def add_sheet(self, sheetname, cell_overwrite_ok=False):
        import Worksheet, Utils
        if not isinstance(sheetname, unicode):
            sheetname = sheetname.decode(self.encoding)
        if not Utils.valid_sheet_name(sheetname):
            raise Exception("invalid worksheet name %r" % sheetname)
        lower_name = sheetname.lower()
        if lower_name in self.__worksheet_idx_from_name:
            raise Exception("duplicate worksheet name %r" % sheetname)
        self.__worksheet_idx_from_name[lower_name] = len(self.__worksheets)
        self.__worksheets.append(Worksheet.Worksheet(sheetname, self, cell_overwrite_ok))
        return self.__worksheets[-1]

    def get_sheet(self, sheetnum):
        return self.__worksheets[sheetnum]

    def raise_bad_sheetname(self, sheetname):
        raise Exception("Formula: unknown sheet name %s" % sheetname)

    def convert_sheetindex(self, strg_ref, n_sheets):
        idx = int(strg_ref)
        if 0 <= idx < n_sheets:
            return idx
        msg = "Formula: sheet index (%s) >= number of sheets (%d)" % (strg_ref, n_sheets)
        raise Exception(msg)

    def _get_supbook_index(self, tag):
        if tag in self._supbook_xref:
            return self._supbook_xref[tag]
        self._supbook_xref[tag] = idx = len(self._supbook_xref)
        return idx

    def setup_ownbook(self):
        self._ownbook_supbookx = self._get_supbook_index(('ownbook', 0))
        self._ownbook_supbook_ref = None
        reference = (self._ownbook_supbookx, 0xFFFE, 0xFFFE)
        if reference in self.__sheet_refs:
            raise Exception("can't happen")
        self.__sheet_refs[reference] = self._ownbook_supbook_ref = len(self.__sheet_refs)

    def setup_xcall(self):
        self._xcall_supbookx = self._get_supbook_index(('xcall', 0))
        self._xcall_supbook_ref = None
        reference = (self._xcall_supbookx, 0xFFFE, 0xFFFE)
        if reference in self.__sheet_refs:
            raise Exception("can't happen")
        self.__sheet_refs[reference] = self._xcall_supbook_ref = len(self.__sheet_refs)

    def add_sheet_reference(self, formula):
        patches = []
        n_sheets = len(self.__worksheets)
        sheet_refs, xcall_refs = formula.get_references()

        for ref0, ref1, offset in sheet_refs:
            if not ref0.isdigit():
                try:
                    ref0n = self.__worksheet_idx_from_name[ref0.lower()]
                except KeyError:
                    self.raise_bad_sheetname(ref0)
            else:
                ref0n = self.convert_sheetindex(ref0, n_sheets)
            if ref1 == ref0:
                ref1n = ref0n
            elif not ref1.isdigit():
                try:
                    ref1n = self.__worksheet_idx_from_name[ref1.lower()]
                except KeyError:
                    self.raise_bad_sheetname(ref1)
            else:
                ref1n = self.convert_sheetindex(ref1, n_sheets)
            if ref1n < ref0n:
                msg = "Formula: sheets out of order; %r:%r -> (%d, %d)" \
                    % (ref0, ref1, ref0n, ref1n)
                raise Exception(msg)
            if self._ownbook_supbookx is None:
                self.setup_ownbook()
            reference = (self._ownbook_supbookx, ref0n, ref1n)
            if reference in self.__sheet_refs:
                patches.append((offset, self.__sheet_refs[reference]))
            else:
                nrefs = len(self.__sheet_refs)
                if nrefs > 65535:
                    raise Exception('More than 65536 inter-sheet references')
                self.__sheet_refs[reference] = nrefs
                patches.append((offset, nrefs))

        for funcname, offset in xcall_refs:
            if self._ownbook_supbookx is None:
                self.setup_ownbook()
            if self._xcall_supbookx is None:
                self.setup_xcall()
            # print funcname, self._supbook_xref
            patches.append((offset, self._xcall_supbook_ref))
            if not isinstance(funcname, unicode):
                funcname = funcname.decode(self.encoding)
            if funcname in self._xcall_xref:
                idx = self._xcall_xref[funcname]
            else:
                self._xcall_xref[funcname] = idx = len(self._xcall_xref)
            patches.append((offset + 2, idx + 1))

        formula.patch_references(patches)

    ##################################################################
    ## BIFF records generation
    ##################################################################

    def __bof_rec(self):
        return BIFFRecords.Biff8BOFRecord(BIFFRecords.Biff8BOFRecord.BOOK_GLOBAL).get()

    def __eof_rec(self):
        return BIFFRecords.EOFRecord().get()

    def __intf_hdr_rec(self):
        return BIFFRecords.InteraceHdrRecord().get()

    def __intf_end_rec(self):
        return BIFFRecords.InteraceEndRecord().get()

    def __intf_mms_rec(self):
        return BIFFRecords.MMSRecord().get()

    def __write_access_rec(self):
        return BIFFRecords.WriteAccessRecord(self.__owner).get()

    def __wnd_protect_rec(self):
        return BIFFRecords.WindowProtectRecord(self.__wnd_protect).get()

    def __obj_protect_rec(self):
        return BIFFRecords.ObjectProtectRecord(self.__obj_protect).get()

    def __protect_rec(self):
        return BIFFRecords.ProtectRecord(self.__protect).get()

    def __password_rec(self):
        return BIFFRecords.PasswordRecord().get()

    def __prot4rev_rec(self):
        return BIFFRecords.Prot4RevRecord().get()

    def __prot4rev_pass_rec(self):
        return BIFFRecords.Prot4RevPassRecord().get()

    def __backup_rec(self):
        return BIFFRecords.BackupRecord(self.__backup_on_save).get()

    def __hide_obj_rec(self):
        return BIFFRecords.HideObjRecord().get()

    def __window1_rec(self):
        flags = 0
        flags |= (self.__wnd_hidden) << 0
        flags |= (self.__wnd_mini) << 1
        flags |= (self.__hscroll_visible) << 3
        flags |= (self.__vscroll_visible) << 4
        flags |= (self.__tabs_visible) << 5

        return BIFFRecords.Window1Record(self.__hpos_twips, self.__vpos_twips,
                                self.__width_twips, self.__height_twips,
                                flags,
                                self.__active_sheet, self.__first_tab_index,
                                self.__selected_tabs, self.__tab_width_twips).get()

    def __codepage_rec(self):
        return BIFFRecords.CodepageBiff8Record().get()

    def __country_rec(self):
        if not self.__country_code:
            return ''
        return BIFFRecords.CountryRecord(self.__country_code, self.__country_code).get()

    def __dsf_rec(self):
        return BIFFRecords.DSFRecord().get()

    def __tabid_rec(self):
        return BIFFRecords.TabIDRecord(len(self.__worksheets)).get()

    def __fngroupcount_rec(self):
        return BIFFRecords.FnGroupCountRecord().get()

    def __datemode_rec(self):
        return BIFFRecords.DateModeRecord(self.__dates_1904).get()

    def __precision_rec(self):
        return BIFFRecords.PrecisionRecord(self.__use_cell_values).get()

    def __refresh_all_rec(self):
        return BIFFRecords.RefreshAllRecord().get()

    def __bookbool_rec(self):
        return BIFFRecords.BookBoolRecord().get()

    def __all_fonts_num_formats_xf_styles_rec(self):
        return self.__styles.get_biff_data()

    def __palette_rec(self):
        result = ''
        return result

    def __useselfs_rec(self):
        return BIFFRecords.UseSelfsRecord().get()

    def __boundsheets_rec(self, data_len_before, data_len_after, sheet_biff_lens):
        #  .................................
        # BOUNDSEHEET0
        # BOUNDSEHEET1
        # BOUNDSEHEET2
        # ..................................
        # WORKSHEET0
        # WORKSHEET1
        # WORKSHEET2
        boundsheets_len = 0
        for sheet in self.__worksheets:
            boundsheets_len += len(BIFFRecords.BoundSheetRecord(
                0x00L, sheet.visibility, sheet.name, self.encoding
                ).get())

        start = data_len_before + boundsheets_len + data_len_after

        result = ''
        for sheet_biff_len,  sheet in zip(sheet_biff_lens, self.__worksheets):
            result += BIFFRecords.BoundSheetRecord(
                start, sheet.visibility, sheet.name, self.encoding
                ).get()
            start += sheet_biff_len
        return result

    def __all_links_rec(self):
        pieces = []
        temp = [(idx, tag) for tag, idx in self._supbook_xref.items()]
        temp.sort()
        for idx, tag in temp:
            stype, snum = tag
            if stype == 'ownbook':
                rec = BIFFRecords.InternalReferenceSupBookRecord(len(self.__worksheets)).get()
                pieces.append(rec)
            elif stype == 'xcall':
                rec = BIFFRecords.XcallSupBookRecord().get()
                pieces.append(rec)
                temp = [(idx, name) for name, idx in self._xcall_xref.items()]
                temp.sort()
                for idx, name in temp:
                    rec = BIFFRecords.ExternnameRecord(
                        options=0, index=0, name=name, fmla='\x02\x00\x1c\x17').get()
                    pieces.append(rec)
            else:
                raise Exception('unknown supbook stype %r' % stype)
        if len(self.__sheet_refs) > 0:
            # get references in index order
            temp = [(idx, ref) for ref, idx in self.__sheet_refs.items()]
            temp.sort()
            temp = [ref for idx, ref in temp]
            externsheet_record = BIFFRecords.ExternSheetRecord(temp).get()
            pieces.append(externsheet_record)
        return ''.join(pieces)

    def __sst_rec(self):
        return self.__sst.get_biff_record()

    def __ext_sst_rec(self, abs_stream_pos):
        return ''
        #return BIFFRecords.ExtSSTRecord(abs_stream_pos, self.sst_record.str_placement,
        #self.sst_record.portions_len).get()

    def get_biff_data(self):
        before = ''
        before += self.__bof_rec()
        before += self.__intf_hdr_rec()
        before += self.__intf_mms_rec()
        before += self.__intf_end_rec()
        before += self.__write_access_rec()
        before += self.__codepage_rec()
        before += self.__dsf_rec()
        before += self.__tabid_rec()
        before += self.__fngroupcount_rec()
        before += self.__wnd_protect_rec()
        before += self.__protect_rec()
        before += self.__obj_protect_rec()
        before += self.__password_rec()
        before += self.__prot4rev_rec()
        before += self.__prot4rev_pass_rec()
        before += self.__backup_rec()
        before += self.__hide_obj_rec()
        before += self.__window1_rec()
        before += self.__datemode_rec()
        before += self.__precision_rec()
        before += self.__refresh_all_rec()
        before += self.__bookbool_rec()
        before += self.__all_fonts_num_formats_xf_styles_rec()
        before += self.__palette_rec()
        before += self.__useselfs_rec()

        country            = self.__country_rec()
        all_links          = self.__all_links_rec()

        shared_str_table   = self.__sst_rec()
        after = country + all_links + shared_str_table

        ext_sst = self.__ext_sst_rec(0) # need fake cause we need calc stream pos
        eof = self.__eof_rec()

        self.__worksheets[self.__active_sheet].selected = True
        sheets = ''
        sheet_biff_lens = []
        for sheet in self.__worksheets:
            data = sheet.get_biff_data()
            sheets += data
            sheet_biff_lens.append(len(data))

        bundlesheets = self.__boundsheets_rec(len(before), len(after)+len(ext_sst)+len(eof), sheet_biff_lens)

        sst_stream_pos = len(before) + len(bundlesheets) + len(country)  + len(all_links)
        ext_sst = self.__ext_sst_rec(sst_stream_pos)

        return before + bundlesheets + after + ext_sst + eof + sheets

    def save(self, filename):
        import CompoundDoc

        doc = CompoundDoc.XlsDoc()
        doc.save(filename, self.get_biff_data())



########NEW FILE########
__FILENAME__ = Worksheet
# -*- coding: windows-1252 -*-
'''
            BOF
            UNCALCED
            INDEX
            Calculation Settings Block
            PRINTHEADERS
            PRINTGRIDLINES
            GRIDSET
            GUTS
            DEFAULTROWHEIGHT
            WSBOOL
            Page Settings Block
            Worksheet Protection Block
            DEFCOLWIDTH
            COLINFO
            SORT
            DIMENSIONS
            Row Blocks
            WINDOW2
            SCL
            PANE
            SELECTION
            STANDARDWIDTH
            MERGEDCELLS
            LABELRANGES
            PHONETIC
            Conditional Formatting Table
            Hyperlink Table
            Data Validity Table
            SHEETLAYOUT (BIFF8X only)
            SHEETPROTECTION (BIFF8X only)
            RANGEPROTECTION (BIFF8X only)
            EOF
'''

import BIFFRecords
import Bitmap
import Formatting
import Style
import tempfile


class Worksheet(object):
    from Workbook import Workbook

    #################################################################
    ## Constructor
    #################################################################
    def __init__(self, sheetname, parent_book, cell_overwrite_ok=False):
        import Row
        self.Row = Row.Row

        import Column
        self.Column = Column.Column

        self.__name = sheetname
        self.__parent = parent_book
        self._cell_overwrite_ok = cell_overwrite_ok

        self.__rows = {}
        self.__cols = {}
        self.__merged_ranges = []
        self.__bmp_rec = ''

        self.__show_formulas = 0
        self.__show_grid = 1
        self.__show_headers = 1
        self.__panes_frozen = 0
        ### self.__show_empty_as_zero = 1 ### deprecated with extreme prejudice 2009-05-19
        self.show_zero_values = 1
        self.__auto_colour_grid = 1
        self.__cols_right_to_left = 0
        self.__show_outline = 1
        self.__remove_splits = 0
        self.__selected = 0
        # RED HERRING ALERT: "sheet_visible" is a clone of the "selected" attribute.
        # Typically a workbook created by the Excel UI will have one sheet
        # (the sheet that was selected when the user saved it)
        # with both bits set to 1, and all other sheets will have both
        # bits set to 0. The true visibility of the sheet is found in the "visibility"
        # attribute obtained from the BOUNDSHEET record.
        self.__sheet_visible = 0
        self.__page_preview = 0

        self.__first_visible_row = 0
        self.__first_visible_col = 0
        self.__grid_colour = 0x40
        self.__preview_magn = 60 # percent
        self.__normal_magn = 100 # percent

        self.visibility = 0 # from/to BOUNDSHEET record.

        self.__vert_split_pos = None
        self.__horz_split_pos = None
        self.__vert_split_first_visible = None
        self.__horz_split_first_visible = None
        self.__split_active_pane = None

        self.__row_gut_width = 0
        self.__col_gut_height = 0

        self.__show_auto_page_breaks = 1
        self.__dialogue_sheet = 0
        self.__auto_style_outline = 0
        self.__outline_below = 0
        self.__outline_right = 0
        self.__fit_num_pages = 0
        self.__show_row_outline = 1
        self.__show_col_outline = 1
        self.__alt_expr_eval = 0
        self.__alt_formula_entries = 0

        self.__row_default_height = 0x00FF
        self.row_default_height_mismatch = 0
        self.row_default_hidden = 0
        self.row_default_space_above = 0
        self.row_default_space_below = 0

        self.__col_default_width = 0x0008

        self.__calc_mode = 1
        self.__calc_count = 0x0064
        self.__RC_ref_mode = 1
        self.__iterations_on = 0
        self.__delta = 0.001
        self.__save_recalc = 0

        self.__print_headers = 0
        self.__print_grid = 0
        self.__grid_set = 1
        self.__vert_page_breaks = []
        self.__horz_page_breaks = []
        self.__header_str = '&P'
        self.__footer_str = '&F'
        self.__print_centered_vert = 0
        self.__print_centered_horz = 1
        self.__left_margin = 0.3 #0.5
        self.__right_margin = 0.3 #0.5
        self.__top_margin = 0.61 #1.0
        self.__bottom_margin = 0.37 #1.0
        self.__paper_size_code = 9 # A4
        self.__print_scaling = 100
        self.__start_page_number = 1
        self.__fit_width_to_pages = 1
        self.__fit_height_to_pages = 1
        self.__print_in_rows = 1
        self.__portrait = 1
        self.__print_not_colour = 0
        self.__print_draft = 0
        self.__print_notes = 0
        self.__print_notes_at_end = 0
        self.__print_omit_errors = 0
        self.__print_hres = 0x012C # 300 dpi
        self.__print_vres = 0x012C # 300 dpi
        self.__header_margin = 0.1
        self.__footer_margin = 0.1
        self.__copies_num = 1

        self.__wnd_protect = 0
        self.__obj_protect = 0
        self.__protect = 0
        self.__scen_protect = 0
        self.__password = ''

        self.last_used_row = 0
        self.first_used_row = 65535
        self.last_used_col = 0
        self.first_used_col = 255
        self.row_tempfile = None
        self.__flushed_rows = {}
        self.__row_visible_levels = 0

    #################################################################
    ## Properties, "getters", "setters"
    #################################################################

    def set_name(self, value):
        self.__name = value

    def get_name(self):
        return self.__name

    name = property(get_name, set_name)

    #################################################################

    def get_parent(self):
        return self.__parent

    parent = property(get_parent)

    #################################################################

    def get_rows(self):
        return self.__rows

    rows = property(get_rows)

    #################################################################

    def get_cols(self):
        return self.__cols

    cols = property(get_cols)

    #################################################################

    def get_merged_ranges(self):
        return self.__merged_ranges

    merged_ranges = property(get_merged_ranges)

    #################################################################

    def get_bmp_rec(self):
        return self.__bmp_rec

    bmp_rec = property(get_bmp_rec)

    #################################################################

    def set_show_formulas(self, value):
        self.__show_formulas = int(value)

    def get_show_formulas(self):
        return bool(self.__show_formulas)

    show_formulas = property(get_show_formulas, set_show_formulas)

    #################################################################

    def set_show_grid(self, value):
        self.__show_grid = int(value)

    def get_show_grid(self):
        return bool(self.__show_grid)

    show_grid = property(get_show_grid, set_show_grid)

    #################################################################

    def set_show_headers(self, value):
        self.__show_headers = int(value)

    def get_show_headers(self):
        return bool(self.__show_headers)

    show_headers = property(get_show_headers, set_show_headers)

    #################################################################

    def set_panes_frozen(self, value):
        self.__panes_frozen = int(value)

    def get_panes_frozen(self):
        return bool(self.__panes_frozen)

    panes_frozen = property(get_panes_frozen, set_panes_frozen)

    #################################################################

    ### def set_show_empty_as_zero(self, value):
    ###     self.__show_empty_as_zero = int(value)

    ### def get_show_empty_as_zero(self):
    ###     return bool(self.__show_empty_as_zero)

    ### show_empty_as_zero = property(get_show_empty_as_zero, set_show_empty_as_zero)

    #################################################################

    def set_auto_colour_grid(self, value):
        self.__auto_colour_grid = int(value)

    def get_auto_colour_grid(self):
        return bool(self.__auto_colour_grid)

    auto_colour_grid = property(get_auto_colour_grid, set_auto_colour_grid)

    #################################################################

    def set_cols_right_to_left(self, value):
        self.__cols_right_to_left = int(value)

    def get_cols_right_to_left(self):
        return bool(self.__cols_right_to_left)

    cols_right_to_left = property(get_cols_right_to_left, set_cols_right_to_left)

    #################################################################

    def set_show_outline(self, value):
        self.__show_outline = int(value)

    def get_show_outline(self):
        return bool(self.__show_outline)

    show_outline = property(get_show_outline, set_show_outline)

    #################################################################

    def set_remove_splits(self, value):
        self.__remove_splits = int(value)

    def get_remove_splits(self):
        return bool(self.__remove_splits)

    remove_splits = property(get_remove_splits, set_remove_splits)

    #################################################################

    def set_selected(self, value):
        self.__selected = int(value)

    def get_selected(self):
        return bool(self.__selected)

    selected = property(get_selected, set_selected)

    #################################################################

    def set_sheet_visible(self, value):
        self.__sheet_visible = int(value)

    def get_sheet_visible(self):
        return bool(self.__sheet_visible)

    sheet_visible = property(get_sheet_visible, set_sheet_visible)

    #################################################################

    def set_page_preview(self, value):
        self.__page_preview = int(value)

    def get_page_preview(self):
        return bool(self.__page_preview)

    page_preview = property(get_page_preview, set_page_preview)

    #################################################################

    def set_first_visible_row(self, value):
        self.__first_visible_row = value

    def get_first_visible_row(self):
        return self.__first_visible_row

    first_visible_row = property(get_first_visible_row, set_first_visible_row)

    #################################################################

    def set_first_visible_col(self, value):
        self.__first_visible_col = value

    def get_first_visible_col(self):
        return self.__first_visible_col

    first_visible_col = property(get_first_visible_col, set_first_visible_col)

    #################################################################

    def set_grid_colour(self, value):
        self.__grid_colour = value

    def get_grid_colour(self):
        return self.__grid_colour

    grid_colour = property(get_grid_colour, set_grid_colour)

    #################################################################

    def set_preview_magn(self, value):
        self.__preview_magn = value

    def get_preview_magn(self):
        return self.__preview_magn

    preview_magn = property(get_preview_magn, set_preview_magn)

    #################################################################

    def set_normal_magn(self, value):
        self.__normal_magn = value

    def get_normal_magn(self):
        return self.__normal_magn

    normal_magn = property(get_normal_magn, set_normal_magn)

    #################################################################

    def set_vert_split_pos(self, value):
        self.__vert_split_pos = abs(value)

    def get_vert_split_pos(self):
        return self.__vert_split_pos

    vert_split_pos = property(get_vert_split_pos, set_vert_split_pos)

    #################################################################

    def set_horz_split_pos(self, value):
        self.__horz_split_pos = abs(value)

    def get_horz_split_pos(self):
        return self.__horz_split_pos

    horz_split_pos = property(get_horz_split_pos, set_horz_split_pos)

    #################################################################

    def set_vert_split_first_visible(self, value):
        self.__vert_split_first_visible = abs(value)

    def get_vert_split_first_visible(self):
        return self.__vert_split_first_visible

    vert_split_first_visible = property(get_vert_split_first_visible, set_vert_split_first_visible)

    #################################################################

    def set_horz_split_first_visible(self, value):
        self.__horz_split_first_visible = abs(value)

    def get_horz_split_first_visible(self):
        return self.__horz_split_first_visible

    horz_split_first_visible = property(get_horz_split_first_visible, set_horz_split_first_visible)

    #################################################################

    #def set_split_active_pane(self, value):
    #    self.__split_active_pane = abs(value) & 0x03
    #
    #def get_split_active_pane(self):
    #    return self.__split_active_pane
    #
    #split_active_pane = property(get_split_active_pane, set_split_active_pane)

    #################################################################

    #def set_row_gut_width(self, value):
    #    self.__row_gut_width = value
    #
    #def get_row_gut_width(self):
    #    return self.__row_gut_width
    #
    #row_gut_width = property(get_row_gut_width, set_row_gut_width)
    #
    #################################################################
    #
    #def set_col_gut_height(self, value):
    #    self.__col_gut_height = value
    #
    #def get_col_gut_height(self):
    #    return self.__col_gut_height
    #
    #col_gut_height = property(get_col_gut_height, set_col_gut_height)
    #
    #################################################################

    def set_show_auto_page_breaks(self, value):
        self.__show_auto_page_breaks = int(value)

    def get_show_auto_page_breaks(self):
        return bool(self.__show_auto_page_breaks)

    show_auto_page_breaks = property(get_show_auto_page_breaks, set_show_auto_page_breaks)

    #################################################################

    def set_dialogue_sheet(self, value):
        self.__dialogue_sheet = int(value)

    def get_dialogue_sheet(self):
        return bool(self.__dialogue_sheet)

    dialogue_sheet = property(get_dialogue_sheet, set_dialogue_sheet)

    #################################################################

    def set_auto_style_outline(self, value):
        self.__auto_style_outline = int(value)

    def get_auto_style_outline(self):
        return bool(self.__auto_style_outline)

    auto_style_outline = property(get_auto_style_outline, set_auto_style_outline)

    #################################################################

    def set_outline_below(self, value):
        self.__outline_below = int(value)

    def get_outline_below(self):
        return bool(self.__outline_below)

    outline_below = property(get_outline_below, set_outline_below)

    #################################################################

    def set_outline_right(self, value):
        self.__outline_right = int(value)

    def get_outline_right(self):
        return bool(self.__outline_right)

    outline_right = property(get_outline_right, set_outline_right)

    #################################################################

    def set_fit_num_pages(self, value):
        self.__fit_num_pages = value

    def get_fit_num_pages(self):
        return self.__fit_num_pages

    fit_num_pages = property(get_fit_num_pages, set_fit_num_pages)

    #################################################################

    def set_show_row_outline(self, value):
        self.__show_row_outline = int(value)

    def get_show_row_outline(self):
        return bool(self.__show_row_outline)

    show_row_outline = property(get_show_row_outline, set_show_row_outline)

    #################################################################

    def set_show_col_outline(self, value):
        self.__show_col_outline = int(value)

    def get_show_col_outline(self):
        return bool(self.__show_col_outline)

    show_col_outline = property(get_show_col_outline, set_show_col_outline)

    #################################################################

    def set_alt_expr_eval(self, value):
        self.__alt_expr_eval = int(value)

    def get_alt_expr_eval(self):
        return bool(self.__alt_expr_eval)

    alt_expr_eval = property(get_alt_expr_eval, set_alt_expr_eval)

    #################################################################

    def set_alt_formula_entries(self, value):
        self.__alt_formula_entries = int(value)

    def get_alt_formula_entries(self):
        return bool(self.__alt_formula_entries)

    alt_formula_entries = property(get_alt_formula_entries, set_alt_formula_entries)

    #################################################################

    def set_row_default_height(self, value):
        self.__row_default_height = value

    def get_row_default_height(self):
        return self.__row_default_height

    row_default_height = property(get_row_default_height, set_row_default_height)

    #################################################################

    def set_col_default_width(self, value):
        self.__col_default_width = value

    def get_col_default_width(self):
        return self.__col_default_width

    col_default_width = property(get_col_default_width, set_col_default_width)

    #################################################################

    def set_calc_mode(self, value):
        self.__calc_mode = value & 0x03

    def get_calc_mode(self):
        return self.__calc_mode

    calc_mode = property(get_calc_mode, set_calc_mode)

    #################################################################

    def set_calc_count(self, value):
        self.__calc_count = value

    def get_calc_count(self):
        return self.__calc_count

    calc_count = property(get_calc_count, set_calc_count)

    #################################################################

    def set_RC_ref_mode(self, value):
        self.__RC_ref_mode = int(value)

    def get_RC_ref_mode(self):
        return bool(self.__RC_ref_mode)

    RC_ref_mode = property(get_RC_ref_mode, set_RC_ref_mode)

    #################################################################

    def set_iterations_on(self, value):
        self.__iterations_on = int(value)

    def get_iterations_on(self):
        return bool(self.__iterations_on)

    iterations_on = property(get_iterations_on, set_iterations_on)

    #################################################################

    def set_delta(self, value):
        self.__delta = value

    def get_delta(self):
        return self.__delta

    delta = property(get_delta, set_delta)

    #################################################################

    def set_save_recalc(self, value):
        self.__save_recalc = int(value)

    def get_save_recalc(self):
        return bool(self.__save_recalc)

    save_recalc = property(get_save_recalc, set_save_recalc)

    #################################################################

    def set_print_headers(self, value):
        self.__print_headers = int(value)

    def get_print_headers(self):
        return bool(self.__print_headers)

    print_headers = property(get_print_headers, set_print_headers)

    #################################################################

    def set_print_grid(self, value):
        self.__print_grid = int(value)

    def get_print_grid(self):
        return bool(self.__print_grid)

    print_grid = property(get_print_grid, set_print_grid)

    #################################################################
    #
    #def set_grid_set(self, value):
    #    self.__grid_set = int(value)
    #
    #def get_grid_set(self):
    #    return bool(self.__grid_set)
    #
    #grid_set = property(get_grid_set, set_grid_set)
    #
    #################################################################

    def set_vert_page_breaks(self, value):
        self.__vert_page_breaks = value

    def get_vert_page_breaks(self):
        return self.__vert_page_breaks

    vert_page_breaks = property(get_vert_page_breaks, set_vert_page_breaks)

    #################################################################

    def set_horz_page_breaks(self, value):
        self.__horz_page_breaks = value

    def get_horz_page_breaks(self):
        return self.__horz_page_breaks

    horz_page_breaks = property(get_horz_page_breaks, set_horz_page_breaks)

    #################################################################

    def set_header_str(self, value):
        if isinstance(value, str):
            value = unicode(value, self.__parent.encoding)
        self.__header_str = value

    def get_header_str(self):
        return self.__header_str

    header_str = property(get_header_str, set_header_str)

    #################################################################

    def set_footer_str(self, value):
        if isinstance(value, str):
            value = unicode(value, self.__parent.encoding)
        self.__footer_str = value

    def get_footer_str(self):
        return self.__footer_str

    footer_str = property(get_footer_str, set_footer_str)

    #################################################################

    def set_print_centered_vert(self, value):
        self.__print_centered_vert = int(value)

    def get_print_centered_vert(self):
        return bool(self.__print_centered_vert)

    print_centered_vert = property(get_print_centered_vert, set_print_centered_vert)

    #################################################################

    def set_print_centered_horz(self, value):
        self.__print_centered_horz = int(value)

    def get_print_centered_horz(self):
        return bool(self.__print_centered_horz)

    print_centered_horz = property(get_print_centered_horz, set_print_centered_horz)

    #################################################################

    def set_left_margin(self, value):
        self.__left_margin = value

    def get_left_margin(self):
        return self.__left_margin

    left_margin = property(get_left_margin, set_left_margin)

    #################################################################

    def set_right_margin(self, value):
        self.__right_margin = value

    def get_right_margin(self):
        return self.__right_margin

    right_margin = property(get_right_margin, set_right_margin)

    #################################################################

    def set_top_margin(self, value):
        self.__top_margin = value

    def get_top_margin(self):
        return self.__top_margin

    top_margin = property(get_top_margin, set_top_margin)

    #################################################################

    def set_bottom_margin(self, value):
        self.__bottom_margin = value

    def get_bottom_margin(self):
        return self.__bottom_margin

    bottom_margin = property(get_bottom_margin, set_bottom_margin)

    #################################################################

    def set_paper_size_code(self, value):
        self.__paper_size_code = value

    def get_paper_size_code(self):
        return self.__paper_size_code

    paper_size_code = property(get_paper_size_code, set_paper_size_code)

    #################################################################

    def set_print_scaling(self, value):
        self.__print_scaling = value

    def get_print_scaling(self):
        return self.__print_scaling

    print_scaling = property(get_print_scaling, set_print_scaling)

    #################################################################

    def set_start_page_number(self, value):
        self.__start_page_number = value

    def get_start_page_number(self):
        return self.__start_page_number

    start_page_number = property(get_start_page_number, set_start_page_number)

    #################################################################

    def set_fit_width_to_pages(self, value):
        self.__fit_width_to_pages = value

    def get_fit_width_to_pages(self):
        return self.__fit_width_to_pages

    fit_width_to_pages = property(get_fit_width_to_pages, set_fit_width_to_pages)

    #################################################################

    def set_fit_height_to_pages(self, value):
        self.__fit_height_to_pages = value

    def get_fit_height_to_pages(self):
        return self.__fit_height_to_pages

    fit_height_to_pages = property(get_fit_height_to_pages, set_fit_height_to_pages)

    #################################################################

    def set_print_in_rows(self, value):
        self.__print_in_rows = int(value)

    def get_print_in_rows(self):
        return bool(self.__print_in_rows)

    print_in_rows = property(get_print_in_rows, set_print_in_rows)

    #################################################################

    def set_portrait(self, value):
        self.__portrait = int(value)

    def get_portrait(self):
        return bool(self.__portrait)

    portrait = property(get_portrait, set_portrait)

    #################################################################

    def set_print_colour(self, value):
        self.__print_not_colour = int(not value)

    def get_print_colour(self):
        return not bool(self.__print_not_colour)

    print_colour = property(get_print_colour, set_print_colour)

    #################################################################

    def set_print_draft(self, value):
        self.__print_draft = int(value)

    def get_print_draft(self):
        return bool(self.__print_draft)

    print_draft = property(get_print_draft, set_print_draft)

    #################################################################

    def set_print_notes(self, value):
        self.__print_notes = int(value)

    def get_print_notes(self):
        return bool(self.__print_notes)

    print_notes = property(get_print_notes, set_print_notes)

    #################################################################

    def set_print_notes_at_end(self, value):
        self.__print_notes_at_end = int(value)

    def get_print_notes_at_end(self):
        return bool(self.__print_notes_at_end)

    print_notes_at_end = property(get_print_notes_at_end, set_print_notes_at_end)

    #################################################################

    def set_print_omit_errors(self, value):
        self.__print_omit_errors = int(value)

    def get_print_omit_errors(self):
        return bool(self.__print_omit_errors)

    print_omit_errors = property(get_print_omit_errors, set_print_omit_errors)

    #################################################################

    def set_print_hres(self, value):
        self.__print_hres = value

    def get_print_hres(self):
        return self.__print_hres

    print_hres = property(get_print_hres, set_print_hres)

    #################################################################

    def set_print_vres(self, value):
        self.__print_vres = value

    def get_print_vres(self):
        return self.__print_vres

    print_vres = property(get_print_vres, set_print_vres)

    #################################################################

    def set_header_margin(self, value):
        self.__header_margin = value

    def get_header_margin(self):
        return self.__header_margin

    header_margin = property(get_header_margin, set_header_margin)

    #################################################################

    def set_footer_margin(self, value):
        self.__footer_margin = value

    def get_footer_margin(self):
        return self.__footer_margin

    footer_margin = property(get_footer_margin, set_footer_margin)

    #################################################################

    def set_copies_num(self, value):
        self.__copies_num = value

    def get_copies_num(self):
        return self.__copies_num

    copies_num = property(get_copies_num, set_copies_num)

    ##################################################################

    def set_wnd_protect(self, value):
        self.__wnd_protect = int(value)

    def get_wnd_protect(self):
        return bool(self.__wnd_protect)

    wnd_protect = property(get_wnd_protect, set_wnd_protect)

    #################################################################

    def set_obj_protect(self, value):
        self.__obj_protect = int(value)

    def get_obj_protect(self):
        return bool(self.__obj_protect)

    obj_protect = property(get_obj_protect, set_obj_protect)

    #################################################################

    def set_protect(self, value):
        self.__protect = int(value)

    def get_protect(self):
        return bool(self.__protect)

    protect = property(get_protect, set_protect)

    #################################################################

    def set_scen_protect(self, value):
        self.__scen_protect = int(value)

    def get_scen_protect(self):
        return bool(self.__scen_protect)

    scen_protect = property(get_scen_protect, set_scen_protect)

    #################################################################

    def set_password(self, value):
        self.__password = value

    def get_password(self):
        return self.__password

    password = property(get_password, set_password)

    ##################################################################
    ## Methods
    ##################################################################

    def get_parent(self):
        return self.__parent

    def write(self, r, c, label="", style=Style.default_style):
        self.row(r).write(c, label, style)

    def merge(self, r1, r2, c1, c2, style=Style.default_style):
        # Stand-alone merge of previously written cells.
        # Problems: (1) style to be used should be existing style of
        # the top-left cell, not an arg.
        # (2) should ensure that any previous data value in
        # non-top-left cells is nobbled.
        # Note: if a cell is set by a data record then later
        # is referenced by a [MUL]BLANK record, Excel will blank
        # out the cell on the screen, but OOo & Gnu will not
        # blank it out. Need to do something better than writing
        # multiple records. In the meantime, avoid this method and use
        # write_merge() instead.
        if c2 > c1:
            self.row(r1).write_blanks(c1 + 1, c2,  style)
        for r in range(r1+1, r2+1):
            self.row(r).write_blanks(c1, c2,  style)
        self.__merged_ranges.append((r1, r2, c1, c2))

    def write_merge(self, r1, r2, c1, c2, label="", style=Style.default_style):
        assert 0 <= c1 <= c2 <= 255
        assert 0 <= r1 <= r2 <= 65535
        self.write(r1, c1, label, style)
        if c2 > c1:
            self.row(r1).write_blanks(c1 + 1, c2,  style) # skip (r1, c1)
        for r in range(r1+1, r2+1):
            self.row(r).write_blanks(c1, c2,  style)
        self.__merged_ranges.append((r1, r2, c1, c2))

    def insert_bitmap(self, filename, row, col, x = 0, y = 0, scale_x = 1, scale_y = 1):
        bmp = Bitmap.ImDataBmpRecord(filename)
        obj = Bitmap.ObjBmpRecord(row, col, self, bmp, x, y, scale_x, scale_y)

        self.__bmp_rec += obj.get() + bmp.get()

    def col(self, indx):
        if indx not in self.__cols:
            self.__cols[indx] = self.Column(indx, self)
        return self.__cols[indx]

    def row(self, indx):
        if indx not in self.__rows:
            if indx in self.__flushed_rows:
                raise Exception("Attempt to reuse row index %d of sheet %r after flushing" % (indx, self.__name))
            self.__rows[indx] = self.Row(indx, self)
            if indx > self.last_used_row:
                self.last_used_row = indx
            if indx < self.first_used_row:
                self.first_used_row = indx
        return self.__rows[indx]

    def row_height(self, row): # in pixels
        if row in self.__rows:
            return self.__rows[row].get_height_in_pixels()
        else:
            return 17

    def col_width(self, col): # in pixels
        if col in self.__cols:
            return self.__cols[col].width_in_pixels()
        else:
            return 64


    ##################################################################
    ## BIFF records generation
    ##################################################################

    def __bof_rec(self):
        return BIFFRecords.Biff8BOFRecord(BIFFRecords.Biff8BOFRecord.WORKSHEET).get()

    def __update_row_visible_levels(self):
        if self.__rows:
            temp = max([self.__rows[r].level for r in self.__rows]) + 1
            self.__row_visible_levels = max(temp, self.__row_visible_levels)

    def __guts_rec(self):
        self.__update_row_visible_levels()
        col_visible_levels = 0
        if len(self.__cols) != 0:
            col_visible_levels = max([self.__cols[c].level for c in self.__cols]) + 1
        return BIFFRecords.GutsRecord(
            self.__row_gut_width, self.__col_gut_height, self.__row_visible_levels, col_visible_levels).get()

    def __defaultrowheight_rec(self):
        options = 0x0000
        options |= (self.row_default_height_mismatch & 1) << 0
        options |= (self.row_default_hidden & 1) << 1
        options |= (self.row_default_space_above & 1) << 2
        options |= (self.row_default_space_below & 1) << 3
        defht = self.__row_default_height
        return BIFFRecords.DefaultRowHeightRecord(options, defht).get()

    def __wsbool_rec(self):
        options = 0x00
        options |= (self.__show_auto_page_breaks & 0x01) << 0
        options |= (self.__dialogue_sheet & 0x01) << 4
        options |= (self.__auto_style_outline & 0x01) << 5
        options |= (self.__outline_below & 0x01) << 6
        options |= (self.__outline_right & 0x01) << 7
        options |= (self.__fit_num_pages & 0x01) << 8
        options |= (self.__show_row_outline & 0x01) << 10
        options |= (self.__show_col_outline & 0x01) << 11
        options |= (self.__alt_expr_eval & 0x01) << 14
        options |= (self.__alt_formula_entries & 0x01) << 15

        return BIFFRecords.WSBoolRecord(options).get()

    def __eof_rec(self):
        return BIFFRecords.EOFRecord().get()

    def __colinfo_rec(self):
        result = ''
        for col in self.__cols:
            result += self.__cols[col].get_biff_record()
        return result

    def __dimensions_rec(self):
        return BIFFRecords.DimensionsRecord(
            self.first_used_row, self.last_used_row,
            self.first_used_col, self.last_used_col
            ).get()

    def __window2_rec(self):
        # Appends SCL record.
        options = 0
        options |= (self.__show_formulas        & 0x01) << 0
        options |= (self.__show_grid            & 0x01) << 1
        options |= (self.__show_headers         & 0x01) << 2
        options |= (self.__panes_frozen         & 0x01) << 3
        options |= (self.show_zero_values       & 0x01) << 4
        options |= (self.__auto_colour_grid     & 0x01) << 5
        options |= (self.__cols_right_to_left   & 0x01) << 6
        options |= (self.__show_outline         & 0x01) << 7
        options |= (self.__remove_splits        & 0x01) << 8
        options |= (self.__selected             & 0x01) << 9
        options |= (self.__sheet_visible        & 0x01) << 10
        options |= (self.__page_preview         & 0x01) << 11
        if self.__page_preview:
            scl_magn = self.__preview_magn
        else:
            scl_magn = self.__normal_magn
        return BIFFRecords.Window2Record(
            options, self.__first_visible_row, self.__first_visible_col,
            self.__grid_colour,
            self.__preview_magn, self.__normal_magn, scl_magn).get()

    def __panes_rec(self):
        if self.__vert_split_pos is None and self.__horz_split_pos is None:
            return ""

        if self.__vert_split_pos is None:
            self.__vert_split_pos = 0
        if self.__horz_split_pos is None:
            self.__horz_split_pos = 0

        if self.__panes_frozen:
            if self.__vert_split_first_visible is None:
                self.__vert_split_first_visible = self.__vert_split_pos
            if self.__horz_split_first_visible is None:
                self.__horz_split_first_visible = self.__horz_split_pos
        else:
            if self.__vert_split_first_visible is None:
                self.__vert_split_first_visible = 0
            if self.__horz_split_first_visible is None:
                self.__horz_split_first_visible = 0
            # inspired by pyXLWriter
            self.__horz_split_pos = 20*self.__horz_split_pos + 255
            self.__vert_split_pos = 113.879*self.__vert_split_pos + 390

        if self.__vert_split_pos > 0 and self.__horz_split_pos > 0:
            self.__split_active_pane = 0
        elif self.__vert_split_pos > 0 and self.__horz_split_pos == 0:
            self.__split_active_pane = 1
        elif self.__vert_split_pos == 0 and self.__horz_split_pos > 0:
            self.__split_active_pane = 2
        else:
            self.__split_active_pane = 3

        result = BIFFRecords.PanesRecord(self.__vert_split_pos,
                                         self.__horz_split_pos,
                                         self.__horz_split_first_visible,
                                         self.__vert_split_first_visible,
                                         self.__split_active_pane).get()
        return result

    def __row_blocks_rec(self):
        result = []
        for row in self.__rows.itervalues():
            result.append(row.get_row_biff_data())
            result.append(row.get_cells_biff_data())
        return ''.join(result)

    def __merged_rec(self):
        return BIFFRecords.MergedCellsRecord(self.__merged_ranges).get()

    def __bitmaps_rec(self):
        return self.__bmp_rec

    def __calc_settings_rec(self):
        result = ''
        result += BIFFRecords.CalcModeRecord(self.__calc_mode & 0x01).get()
        result += BIFFRecords.CalcCountRecord(self.__calc_count & 0xFFFF).get()
        result += BIFFRecords.RefModeRecord(self.__RC_ref_mode & 0x01).get()
        result += BIFFRecords.IterationRecord(self.__iterations_on & 0x01).get()
        result += BIFFRecords.DeltaRecord(self.__delta).get()
        result += BIFFRecords.SaveRecalcRecord(self.__save_recalc & 0x01).get()
        return result

    def __print_settings_rec(self):
        result = ''
        result += BIFFRecords.PrintHeadersRecord(self.__print_headers).get()
        result += BIFFRecords.PrintGridLinesRecord(self.__print_grid).get()
        result += BIFFRecords.GridSetRecord(self.__grid_set).get()
        result += BIFFRecords.HorizontalPageBreaksRecord(self.__horz_page_breaks).get()
        result += BIFFRecords.VerticalPageBreaksRecord(self.__vert_page_breaks).get()
        result += BIFFRecords.HeaderRecord(self.__header_str).get()
        result += BIFFRecords.FooterRecord(self.__footer_str).get()
        result += BIFFRecords.HCenterRecord(self.__print_centered_horz).get()
        result += BIFFRecords.VCenterRecord(self.__print_centered_vert).get()
        result += BIFFRecords.LeftMarginRecord(self.__left_margin).get()
        result += BIFFRecords.RightMarginRecord(self.__right_margin).get()
        result += BIFFRecords.TopMarginRecord(self.__top_margin).get()
        result += BIFFRecords.BottomMarginRecord(self.__bottom_margin).get()

        setup_page_options =  (self.__print_in_rows & 0x01) << 0
        setup_page_options |=  (self.__portrait & 0x01) << 1
        setup_page_options |=  (0x00 & 0x01) << 2
        setup_page_options |=  (self.__print_not_colour & 0x01) << 3
        setup_page_options |=  (self.__print_draft & 0x01) << 4
        setup_page_options |=  (self.__print_notes & 0x01) << 5
        setup_page_options |=  (0x00 & 0x01) << 6
        setup_page_options |=  (0x01 & 0x01) << 7
        setup_page_options |=  (self.__print_notes_at_end & 0x01) << 9
        setup_page_options |=  (self.__print_omit_errors & 0x03) << 10

        result += BIFFRecords.SetupPageRecord(self.__paper_size_code,
                                self.__print_scaling,
                                self.__start_page_number,
                                self.__fit_width_to_pages,
                                self.__fit_height_to_pages,
                                setup_page_options,
                                self.__print_hres,
                                self.__print_vres,
                                self.__header_margin,
                                self.__footer_margin,
                                self.__copies_num).get()
        return result

    def __protection_rec(self):
        result = ''
        result += BIFFRecords.ProtectRecord(self.__protect).get()
        result += BIFFRecords.ScenProtectRecord(self.__scen_protect).get()
        result += BIFFRecords.WindowProtectRecord(self.__wnd_protect).get()
        result += BIFFRecords.ObjectProtectRecord(self.__obj_protect).get()
        result += BIFFRecords.PasswordRecord(self.__password).get()
        return result

    def get_biff_data(self):
        result = [
            self.__bof_rec(),
            self.__calc_settings_rec(),
            self.__guts_rec(),
            self.__defaultrowheight_rec(),
            self.__wsbool_rec(),
            self.__colinfo_rec(),
            self.__dimensions_rec(),
            self.__print_settings_rec(),
            self.__protection_rec(),
            ]
        if self.row_tempfile:
            self.row_tempfile.flush()
            self.row_tempfile.seek(0)
            result.append(self.row_tempfile.read())
        result.extend([
            self.__row_blocks_rec(),
            self.__merged_rec(),
            self.__bitmaps_rec(),
            self.__window2_rec(),
            self.__panes_rec(),
            self.__eof_rec(),
            ])
        return ''.join(result)

    def flush_row_data(self):
        if self.row_tempfile is None:
            self.row_tempfile = tempfile.TemporaryFile()
        self.row_tempfile.write(self.__row_blocks_rec())
        for rowx in self.__rows:
            self.__flushed_rows[rowx] = 1
        self.__update_row_visible_levels()
        self.__rows = {}



########NEW FILE########
__FILENAME__ = antlr
## This file is part of PyANTLR. See LICENSE.txt for license
## details..........Copyright (C) Wolfgang Haefelinger, 2004.

## This file was copied for use with xlwt from the 2.7.7 ANTLR distribution. Yes, it
## says 2.7.5 below. The 2.7.5 distribution version didn't have a
## version in it.

## Here is the contents of the ANTLR 2.7.7 LICENSE.txt referred to above.

# SOFTWARE RIGHTS
#
# ANTLR 1989-2006 Developed by Terence Parr
# Partially supported by University of San Francisco & jGuru.com
#
# We reserve no legal rights to the ANTLR--it is fully in the
# public domain. An individual or company may do whatever
# they wish with source code distributed with ANTLR or the
# code generated by ANTLR, including the incorporation of
# ANTLR, or its output, into commerical software.
#
# We encourage users to develop software with ANTLR. However,
# we do ask that credit is given to us for developing
# ANTLR. By "credit", we mean that if you use ANTLR or
# incorporate any source code into one of your programs
# (commercial product, research project, or otherwise) that
# you acknowledge this fact somewhere in the documentation,
# research report, etc... If you like ANTLR and have
# developed a nice tool with the output, please mention that
# you developed it using ANTLR. In addition, we ask that the
# headers remain intact in our source code. As long as these
# guidelines are kept, we expect to continue enhancing this
# system and expect to make other tools available as they are
# completed.
#
# The primary ANTLR guy:
#
# Terence Parr
# parrt@cs.usfca.edu
# parrt@antlr.org

## End of contents of the ANTLR 2.7.7 LICENSE.txt ########################

## get sys module
import sys

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                     global symbols                             ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

### ANTLR Standard Tokens
SKIP                = -1
INVALID_TYPE        = 0
EOF_TYPE            = 1
EOF                 = 1
NULL_TREE_LOOKAHEAD = 3
MIN_USER_TYPE       = 4

### ANTLR's EOF Symbol
EOF_CHAR            = ''

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                    general functions                           ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

## Version should be automatically derived from configure.in. For now,
## we need to bump it ourselfs. Don't remove the <version> tags.
## <version>
def version():
    r = {
        'major'  : '2',
        'minor'  : '7',
        'micro'  : '5',
        'patch'  : '' ,
        'version': '2.7.5'
        }
    return r
## </version>

def error(fmt,*args):
    if fmt:
        print("error: ", fmt % tuple(args))

def ifelse(cond,_then,_else):
    if cond :
        r = _then
    else:
        r = _else
    return r

def is_string_type(x):
    # return  (isinstance(x,str) or isinstance(x,unicode))
    # Simplify; xlwt doesn't support Python < 2.3
    return isinstance(str)

def assert_string_type(x):
    assert is_string_type(x)
    pass

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                     ANTLR Exceptions                           ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class ANTLRException(Exception):

    def __init__(self, *args):
        Exception.__init__(self, *args)


class RecognitionException(ANTLRException):

    def __init__(self, *args):
        ANTLRException.__init__(self, *args)
        self.fileName = None
        self.line = -1
        self.column = -1
        if len(args) >= 2:
            self.fileName = args[1]
        if len(args) >= 3:
            self.line = args[2]
        if len(args) >= 4:
            self.column = args[3]

    def __str__(self):
        buf = ['']
        if self.fileName:
            buf.append(self.fileName + ":")
        if self.line != -1:
            if not self.fileName:
                buf.append("line ")
            buf.append(str(self.line))
            if self.column != -1:
                buf.append(":" + str(self.column))
            buf.append(":")
        buf.append(" ")
        return str('').join(buf)

    __repr__ = __str__


class NoViableAltException(RecognitionException):

    def __init__(self, *args):
        RecognitionException.__init__(self, *args)
        self.token = None
        self.node  = None
        if isinstance(args[0],AST):
            self.node = args[0]
        elif isinstance(args[0],Token):
            self.token = args[0]
        else:
            raise TypeError("NoViableAltException requires Token or AST argument")

    def __str__(self):
        if self.token:
            line = self.token.getLine()
            col  = self.token.getColumn()
            text = self.token.getText()
            return "unexpected symbol at line %s (column %s): \"%s\"" % (line,col,text)
        if self.node == ASTNULL:
            return "unexpected end of subtree"
        assert self.node
        ### hackish, we assume that an AST contains method getText
        return "unexpected node: %s" % (self.node.getText())

    __repr__ = __str__


class NoViableAltForCharException(RecognitionException):

    def __init__(self, *args):
        self.foundChar = None
        if len(args) == 2:
            self.foundChar = args[0]
            scanner = args[1]
            RecognitionException.__init__(self, "NoViableAlt",
                                          scanner.getFilename(),
                                          scanner.getLine(),
                                          scanner.getColumn())
        elif len(args) == 4:
            self.foundChar = args[0]
            fileName = args[1]
            line = args[2]
            column = args[3]
            RecognitionException.__init__(self, "NoViableAlt",
                                          fileName, line, column)
        else:
            RecognitionException.__init__(self, "NoViableAlt",
                                          '', -1, -1)

    def __str__(self):
        mesg = "unexpected char: "
        if self.foundChar >= ' ' and self.foundChar <= '~':
            mesg += "'" + self.foundChar + "'"
        elif self.foundChar:
            mesg += "0x" + hex(ord(self.foundChar)).upper()[2:]
        else:
            mesg += "<None>"
        return mesg

    __repr__ = __str__


class SemanticException(RecognitionException):

    def __init__(self, *args):
        RecognitionException.__init__(self, *args)


class MismatchedCharException(RecognitionException):

    NONE = 0
    CHAR = 1
    NOT_CHAR = 2
    RANGE = 3
    NOT_RANGE = 4
    SET = 5
    NOT_SET = 6

    def __init__(self, *args):
        self.args = args
        if len(args) == 5:
            # Expected range / not range
            if args[3]:
                self.mismatchType = MismatchedCharException.NOT_RANGE
            else:
                self.mismatchType = MismatchedCharException.RANGE
            self.foundChar = args[0]
            self.expecting = args[1]
            self.upper = args[2]
            self.scanner = args[4]
            RecognitionException.__init__(self, "Mismatched char range",
                                          self.scanner.getFilename(),
                                          self.scanner.getLine(),
                                          self.scanner.getColumn())
        elif len(args) == 4 and is_string_type(args[1]):
            # Expected char / not char
            if args[2]:
                self.mismatchType = MismatchedCharException.NOT_CHAR
            else:
                self.mismatchType = MismatchedCharException.CHAR
            self.foundChar = args[0]
            self.expecting = args[1]
            self.scanner = args[3]
            RecognitionException.__init__(self, "Mismatched char",
                                          self.scanner.getFilename(),
                                          self.scanner.getLine(),
                                          self.scanner.getColumn())
        elif len(args) == 4 and isinstance(args[1], BitSet):
            # Expected BitSet / not BitSet
            if args[2]:
                self.mismatchType = MismatchedCharException.NOT_SET
            else:
                self.mismatchType = MismatchedCharException.SET
            self.foundChar = args[0]
            self.set = args[1]
            self.scanner = args[3]
            RecognitionException.__init__(self, "Mismatched char set",
                                          self.scanner.getFilename(),
                                          self.scanner.getLine(),
                                          self.scanner.getColumn())
        else:
            self.mismatchType = MismatchedCharException.NONE
            RecognitionException.__init__(self, "Mismatched char")

    ## Append a char to the msg buffer.  If special,
    #  then show escaped version
    #
    def appendCharName(self, sb, c):
        if not c or c == 65535:
            # 65535 = (char) -1 = EOF
            sb.append("'<EOF>'")
        elif c == '\n':
            sb.append("'\\n'")
        elif c == '\r':
            sb.append("'\\r'");
        elif c == '\t':
            sb.append("'\\t'")
        else:
            sb.append('\'' + c + '\'')

    ##
    # Returns an error message with line number/column information
    #
    def __str__(self):
        sb = ['']
        sb.append(RecognitionException.__str__(self))

        if self.mismatchType == MismatchedCharException.CHAR:
            sb.append("expecting ")
            self.appendCharName(sb, self.expecting)
            sb.append(", found ")
            self.appendCharName(sb, self.foundChar)
        elif self.mismatchType == MismatchedCharException.NOT_CHAR:
            sb.append("expecting anything but '")
            self.appendCharName(sb, self.expecting)
            sb.append("'; got it anyway")
        elif self.mismatchType in [MismatchedCharException.RANGE, MismatchedCharException.NOT_RANGE]:
            sb.append("expecting char ")
            if self.mismatchType == MismatchedCharException.NOT_RANGE:
                sb.append("NOT ")
            sb.append("in range: ")
            appendCharName(sb, self.expecting)
            sb.append("..")
            appendCharName(sb, self.upper)
            sb.append(", found ")
            appendCharName(sb, self.foundChar)
        elif self.mismatchType in [MismatchedCharException.SET, MismatchedCharException.NOT_SET]:
            sb.append("expecting ")
            if self.mismatchType == MismatchedCharException.NOT_SET:
                sb.append("NOT ")
            sb.append("one of (")
            for i in range(len(self.set)):
                self.appendCharName(sb, self.set[i])
            sb.append("), found ")
            self.appendCharName(sb, self.foundChar)

        return str().join(sb).strip()

    __repr__ = __str__


class MismatchedTokenException(RecognitionException):

    NONE = 0
    TOKEN = 1
    NOT_TOKEN = 2
    RANGE = 3
    NOT_RANGE = 4
    SET = 5
    NOT_SET = 6

    def __init__(self, *args):
        self.args =  args
        self.tokenNames = []
        self.token = None
        self.tokenText = ''
        self.node =  None
        if len(args) == 6:
            # Expected range / not range
            if args[3]:
                self.mismatchType = MismatchedTokenException.NOT_RANGE
            else:
                self.mismatchType = MismatchedTokenException.RANGE
            self.tokenNames = args[0]
            self.expecting = args[2]
            self.upper = args[3]
            self.fileName = args[5]

        elif len(args) == 4 and isinstance(args[2], int):
            # Expected token / not token
            if args[3]:
                self.mismatchType = MismatchedTokenException.NOT_TOKEN
            else:
                self.mismatchType = MismatchedTokenException.TOKEN
            self.tokenNames = args[0]
            self.expecting = args[2]

        elif len(args) == 4 and isinstance(args[2], BitSet):
            # Expected BitSet / not BitSet
            if args[3]:
                self.mismatchType = MismatchedTokenException.NOT_SET
            else:
                self.mismatchType = MismatchedTokenException.SET
            self.tokenNames = args[0]
            self.set = args[2]

        else:
            self.mismatchType = MismatchedTokenException.NONE
            RecognitionException.__init__(self, "Mismatched Token: expecting any AST node", "<AST>", -1, -1)

        if len(args) >= 2:
            if isinstance(args[1],Token):
                self.token = args[1]
                self.tokenText = self.token.getText()
                RecognitionException.__init__(self, "Mismatched Token",
                                              self.fileName,
                                              self.token.getLine(),
                                              self.token.getColumn())
            elif isinstance(args[1],AST):
                self.node = args[1]
                self.tokenText = str(self.node)
                RecognitionException.__init__(self, "Mismatched Token",
                                              "<AST>",
                                              self.node.getLine(),
                                              self.node.getColumn())
            else:
                self.tokenText = "<empty tree>"
                RecognitionException.__init__(self, "Mismatched Token",
                                              "<AST>", -1, -1)

    def appendTokenName(self, sb, tokenType):
        if tokenType == INVALID_TYPE:
            sb.append("<Set of tokens>")
        elif tokenType < 0 or tokenType >= len(self.tokenNames):
            sb.append("<" + str(tokenType) + ">")
        else:
            sb.append(self.tokenNames[tokenType])

    ##
    # Returns an error message with line number/column information
    #
    def __str__(self):
        sb = ['']
        sb.append(RecognitionException.__str__(self))

        if self.mismatchType == MismatchedTokenException.TOKEN:
            sb.append("expecting ")
            self.appendTokenName(sb, self.expecting)
            sb.append(", found " + self.tokenText)
        elif self.mismatchType == MismatchedTokenException.NOT_TOKEN:
            sb.append("expecting anything but '")
            self.appendTokenName(sb, self.expecting)
            sb.append("'; got it anyway")
        elif self.mismatchType in [MismatchedTokenException.RANGE, MismatchedTokenException.NOT_RANGE]:
            sb.append("expecting token ")
            if self.mismatchType == MismatchedTokenException.NOT_RANGE:
                sb.append("NOT ")
            sb.append("in range: ")
            appendTokenName(sb, self.expecting)
            sb.append("..")
            appendTokenName(sb, self.upper)
            sb.append(", found " + self.tokenText)
        elif self.mismatchType in [MismatchedTokenException.SET, MismatchedTokenException.NOT_SET]:
            sb.append("expecting ")
            if self.mismatchType == MismatchedTokenException.NOT_SET:
                sb.append("NOT ")
            sb.append("one of (")
            for i in range(len(self.set)):
                self.appendTokenName(sb, self.set[i])
            sb.append("), found " + self.tokenText)

        return str().join(sb).strip()

    __repr__ = __str__


class TokenStreamException(ANTLRException):

    def __init__(self, *args):
        ANTLRException.__init__(self, *args)


# Wraps an Exception in a TokenStreamException
class TokenStreamIOException(TokenStreamException):

    def __init__(self, *args):
        if args and isinstance(args[0], Exception):
            io = args[0]
            TokenStreamException.__init__(self, str(io))
            self.io = io
        else:
            TokenStreamException.__init__(self, *args)
            self.io = self


# Wraps a RecognitionException in a TokenStreamException
class TokenStreamRecognitionException(TokenStreamException):

    def __init__(self, *args):
        if args and isinstance(args[0], RecognitionException):
            recog = args[0]
            TokenStreamException.__init__(self, str(recog))
            self.recog = recog
        else:
            raise TypeError("TokenStreamRecognitionException requires RecognitionException argument")

    def __str__(self):
        return str(self.recog)

    __repr__ = __str__


class TokenStreamRetryException(TokenStreamException):

    def __init__(self, *args):
        TokenStreamException.__init__(self, *args)


class CharStreamException(ANTLRException):

    def __init__(self, *args):
        ANTLRException.__init__(self, *args)


# Wraps an Exception in a CharStreamException
class CharStreamIOException(CharStreamException):

    def __init__(self, *args):
        if args and isinstance(args[0], Exception):
            io = args[0]
            CharStreamException.__init__(self, str(io))
            self.io = io
        else:
            CharStreamException.__init__(self, *args)
            self.io = self


class TryAgain(Exception):
    pass


###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       Token                                    ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class Token(object):
    SKIP                = -1
    INVALID_TYPE        = 0
    EOF_TYPE            = 1
    EOF                 = 1
    NULL_TREE_LOOKAHEAD = 3
    MIN_USER_TYPE       = 4

    def __init__(self,**argv):
        try:
            self.type = argv['type']
        except:
            self.type = INVALID_TYPE
        try:
            self.text = argv['text']
        except:
            self.text = "<no text>"

    def isEOF(self):
        return (self.type == EOF_TYPE)

    def getColumn(self):
        return 0

    def getLine(self):
        return 0

    def getFilename(self):
        return None

    def setFilename(self,name):
        return self

    def getText(self):
        return "<no text>"

    def setText(self,text):
        if is_string_type(text):
            pass
        else:
            raise TypeError("Token.setText requires string argument")
        return self

    def setColumn(self,column):
        return self

    def setLine(self,line):
        return self

    def getType(self):
        return self.type

    def setType(self,type):
        if isinstance(type,int):
            self.type = type
        else:
            raise TypeError("Token.setType requires integer argument")
        return self

    def toString(self):
        ## not optimal
        type_ = self.type
        if type_ == 3:
            tval = 'NULL_TREE_LOOKAHEAD'
        elif type_ == 1:
            tval = 'EOF_TYPE'
        elif type_ == 0:
            tval = 'INVALID_TYPE'
        elif type_ == -1:
            tval = 'SKIP'
        else:
            tval = type_
        return '["%s",<%s>]' % (self.getText(),tval)

    __str__ = toString
    __repr__ = toString

### static attribute ..
Token.badToken = Token( type=INVALID_TYPE, text="<no text>")

if __name__ == "__main__":
    print("testing ..")
    T = Token.badToken
    print(T)

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       CommonToken                              ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class CommonToken(Token):

    def __init__(self,**argv):
        Token.__init__(self,**argv)
        self.line = 0
        self.col  = 0
        try:
            self.line = argv['line']
        except:
            pass
        try:
            self.col = argv['col']
        except:
            pass

    def getLine(self):
        return self.line

    def getText(self):
        return self.text

    def getColumn(self):
        return self.col

    def setLine(self,line):
        self.line = line
        return self

    def setText(self,text):
        self.text = text
        return self

    def setColumn(self,col):
        self.col = col
        return self

    def toString(self):
        ## not optimal
        type_ = self.type
        if type_ == 3:
            tval = 'NULL_TREE_LOOKAHEAD'
        elif type_ == 1:
            tval = 'EOF_TYPE'
        elif type_ == 0:
            tval = 'INVALID_TYPE'
        elif type_ == -1:
            tval = 'SKIP'
        else:
            tval = type_
        d = {
           'text' : self.text,
           'type' : tval,
           'line' : self.line,
           'colm' : self.col
           }

        fmt = '["%(text)s",<%(type)s>,line=%(line)s,col=%(colm)s]'
        return fmt % d

    __str__ = toString
    __repr__ = toString


if __name__ == '__main__' :
    T = CommonToken()
    print(T)
    T = CommonToken(col=15,line=1,text="some text", type=5)
    print(T)
    T = CommonToken()
    T.setLine(1).setColumn(15).setText("some text").setType(5)
    print(T)
    print(T.getLine())
    print(T.getColumn())
    print(T.getText())
    print(T.getType())

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                    CommonHiddenStreamToken                     ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class CommonHiddenStreamToken(CommonToken):
    def __init__(self,*args):
        CommonToken.__init__(self,*args)
        self.hiddenBefore = None
        self.hiddenAfter  = None

    def getHiddenAfter(self):
        return self.hiddenAfter

    def getHiddenBefore(self):
        return self.hiddenBefore

    def setHiddenAfter(self,t):
        self.hiddenAfter = t

    def setHiddenBefore(self, t):
        self.hiddenBefore = t

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       Queue                                    ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

## Shall be a circular buffer on tokens ..
class Queue(object):

    def __init__(self):
        self.buffer = [] # empty list

    def append(self,item):
        self.buffer.append(item)

    def elementAt(self,index):
        return self.buffer[index]

    def reset(self):
        self.buffer = []

    def removeFirst(self):
        self.buffer.pop(0)

    def length(self):
        return len(self.buffer)

    def __str__(self):
        return str(self.buffer)

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       InputBuffer                              ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class InputBuffer(object):
    def __init__(self):
        self.nMarkers = 0
        self.markerOffset = 0
        self.numToConsume = 0
        self.queue = Queue()

    def __str__(self):
        return "(%s,%s,%s,%s)" % (
           self.nMarkers,
           self.markerOffset,
           self.numToConsume,
           self.queue)

    def __repr__(self):
        return str(self)

    def commit(self):
        self.nMarkers -= 1

    def consume(self) :
        self.numToConsume += 1

    ## probably better to return a list of items
    ## because of unicode. Or return a unicode
    ## string ..
    def getLAChars(self) :
        i = self.markerOffset
        n = self.queue.length()
        s = ''
        while i<n:
            s += self.queue.elementAt(i)
        return s

    ## probably better to return a list of items
    ## because of unicode chars
    def getMarkedChars(self) :
        s = ''
        i = 0
        n = self.markerOffset
        while i<n:
            s += self.queue.elementAt(i)
        return s

    def isMarked(self) :
        return self.nMarkers != 0

    def fill(self,k):
        ### abstract method
        raise NotImplementedError()

    def LA(self,k) :
        self.fill(k)
        return self.queue.elementAt(self.markerOffset + k - 1)

    def mark(self) :
        self.syncConsume()
        self.nMarkers += 1
        return self.markerOffset

    def rewind(self,mark) :
        self.syncConsume()
        self.markerOffset = mark
        self.nMarkers -= 1

    def reset(self) :
        self.nMarkers = 0
        self.markerOffset = 0
        self.numToConsume = 0
        self.queue.reset()

    def syncConsume(self) :
        while self.numToConsume > 0:
            if self.nMarkers > 0:
                # guess mode -- leave leading characters and bump offset.
                self.markerOffset += 1
            else:
                # normal mode -- remove first character
                self.queue.removeFirst()
            self.numToConsume -= 1

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       CharBuffer                               ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class CharBuffer(InputBuffer):
    def __init__(self,reader):
        ##assert isinstance(reader,file)
        super(CharBuffer,self).__init__()
        ## a reader is supposed to be anything that has
        ## a method 'read(int)'.
        self.input = reader

    def __str__(self):
        base = super(CharBuffer,self).__str__()
        return "CharBuffer{%s,%s" % (base,str(input))

    def fill(self,amount):
        try:
            self.syncConsume()
            while self.queue.length() < (amount + self.markerOffset) :
                ## retrieve just one char - what happend at end
                ## of input?
                c = self.input.read(1)
                ### python's behaviour is to return the empty string  on
                ### EOF, ie. no exception whatsoever is thrown. An empty
                ### python  string  has  the  nice feature that it is of
                ### type 'str' and  "not ''" would return true. Contrary,
                ### one can't  do  this: '' in 'abc'. This should return
                ### false,  but all we  get  is  then  a TypeError as an
                ### empty string is not a character.

                ### Let's assure then that we have either seen a
                ### character or an empty string (EOF).
                assert len(c) == 0 or len(c) == 1

                ### And it shall be of type string (ASCII or UNICODE).
                assert is_string_type(c)

                ### Just append EOF char to buffer. Note that buffer may
                ### contain then just more than one EOF char ..

                ### use unicode chars instead of ASCII ..
                self.queue.append(c)
        except Exception as e:
            raise CharStreamIOException(e)
        ##except: # (mk) Cannot happen ...
            ##error ("unexpected exception caught ..")
            ##assert 0

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       LexerSharedInputState                    ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class LexerSharedInputState(object):
    def __init__(self,ibuf):
        assert isinstance(ibuf,InputBuffer)
        self.input = ibuf
        self.column = 1
        self.line = 1
        self.tokenStartColumn = 1
        self.tokenStartLine = 1
        self.guessing = 0
        self.filename = None

    def reset(self):
        self.column = 1
        self.line = 1
        self.tokenStartColumn = 1
        self.tokenStartLine = 1
        self.guessing = 0
        self.filename = None
        self.input.reset()

    def LA(self,k):
        return self.input.LA(k)

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                    TokenStream                                 ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class TokenStream(object):
    def nextToken(self):
        pass

    def __iter__(self):
        return TokenStreamIterator(self)

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                    TokenStreamIterator                                 ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class TokenStreamIterator(object):
    def __init__(self,inst):
        if isinstance(inst,TokenStream):
            self.inst = inst
            return
        raise TypeError("TokenStreamIterator requires TokenStream object")

    def __next__(self):
        assert self.inst
        item = self.inst.nextToken()
        if not item or item.isEOF():
            raise StopIteration()
        return item

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                    TokenStreamSelector                        ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class TokenStreamSelector(TokenStream):

    def __init__(self):
        self._input = None
        self._stmap = {}
        self._stack = []

    def addInputStream(self,stream,key):
        self._stmap[key] = stream

    def getCurrentStream(self):
        return self._input

    def getStream(self,sname):
        try:
            stream = self._stmap[sname]
        except:
            raise ValueError("TokenStream " + sname + " not found");
        return stream;

    def nextToken(self):
        while 1:
            try:
                return self._input.nextToken()
            except TokenStreamRetryException as r:
                ### just retry "forever"
                pass

    def pop(self):
        stream = self._stack.pop();
        self.select(stream);
        return stream;

    def push(self,arg):
        self._stack.append(self._input);
        self.select(arg)

    def retry(self):
        raise TokenStreamRetryException()

    def select(self,arg):
        if isinstance(arg,TokenStream):
            self._input = arg
            return
        if is_string_type(arg):
            self._input = self.getStream(arg)
            return
        raise TypeError("TokenStreamSelector.select requires " +
                        "TokenStream or string argument")

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                      TokenStreamBasicFilter                    ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class TokenStreamBasicFilter(TokenStream):

    def __init__(self,input):

        self.input = input;
        self.discardMask = BitSet()

    def discard(self,arg):
        if isinstance(arg,int):
            self.discardMask.add(arg)
            return
        if isinstance(arg,BitSet):
            self.discardMark = arg
            return
        raise TypeError("TokenStreamBasicFilter.discard requires" +
                        "integer or BitSet argument")

    def nextToken(self):
        tok = self.input.nextToken()
        while tok and self.discardMask.member(tok.getType()):
            tok = self.input.nextToken()
        return tok

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                      TokenStreamHiddenTokenFilter              ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class TokenStreamHiddenTokenFilter(TokenStreamBasicFilter):

    def __init__(self,input):
        TokenStreamBasicFilter.__init__(self,input)
        self.hideMask = BitSet()
        self.nextMonitoredToken = None
        self.lastHiddenToken = None
        self.firstHidden = None

    def consume(self):
        self.nextMonitoredToken = self.input.nextToken()

    def consumeFirst(self):
        self.consume()

        p = None;
        while self.hideMask.member(self.LA(1).getType()) or \
              self.discardMask.member(self.LA(1).getType()):
            if self.hideMask.member(self.LA(1).getType()):
                if not p:
                    p = self.LA(1)
                else:
                    p.setHiddenAfter(self.LA(1))
                    self.LA(1).setHiddenBefore(p)
                    p = self.LA(1)
                self.lastHiddenToken = p
                if not self.firstHidden:
                    self.firstHidden = p
            self.consume()

    def getDiscardMask(self):
        return self.discardMask

    def getHiddenAfter(self,t):
        return t.getHiddenAfter()

    def getHiddenBefore(self,t):
        return t.getHiddenBefore()

    def getHideMask(self):
        return self.hideMask

    def getInitialHiddenToken(self):
        return self.firstHidden

    def hide(self,m):
        if isinstance(m,int):
            self.hideMask.add(m)
            return
        if isinstance(m.BitMask):
            self.hideMask = m
            return

    def LA(self,i):
        return self.nextMonitoredToken

    def nextToken(self):
        if not self.LA(1):
            self.consumeFirst()

        monitored = self.LA(1)

        monitored.setHiddenBefore(self.lastHiddenToken)
        self.lastHiddenToken = None

        self.consume()
        p = monitored

        while self.hideMask.member(self.LA(1).getType()) or \
              self.discardMask.member(self.LA(1).getType()):
            if self.hideMask.member(self.LA(1).getType()):
                p.setHiddenAfter(self.LA(1))
                if p != monitored:
                    self.LA(1).setHiddenBefore(p)
                p = self.lastHiddenToken = self.LA(1)
            self.consume()
        return monitored

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       StringBuffer                             ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class StringBuffer:
    def __init__(self,string=None):
        if string:
            self.text = list(string)
        else:
            self.text = []

    def setLength(self,sz):
        if not sz :
            self.text = []
            return
        assert sz>0
        if sz >= self.length():
            return
        ### just reset to empty buffer
        self.text = self.text[0:sz]

    def length(self):
        return len(self.text)

    def append(self,c):
        self.text.append(c)

    ### return buffer as string. Arg 'a' is  used  as index
    ## into the buffer and 2nd argument shall be the length.
    ## If 2nd args is absent, we return chars till end of
    ## buffer starting with 'a'.
    def getString(self,a=None,length=None):
        if not a :
            a = 0
        assert a>=0
        if a>= len(self.text) :
            return ""

        if not length:
            ## no second argument
            L = self.text[a:]
        else:
            assert (a+length) <= len(self.text)
            b = a + length
            L = self.text[a:b]
        s = ""
        for x in L : s += x
        return s

    toString = getString ## alias

    def __str__(self):
        return str(self.text)

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       Reader                                   ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

## When reading Japanese chars, it happens that a stream returns a
## 'char' of length 2. This looks like  a  bug  in the appropriate
## codecs - but I'm  rather  unsure about this. Anyway, if this is
## the case, I'm going to  split  this string into a list of chars
## and put them  on  hold, ie. on a  buffer. Next time when called
## we read from buffer until buffer is empty.
## wh: nov, 25th -> problem does not appear in Python 2.4.0.c1.

class Reader(object):
    def __init__(self,stream):
        self.cin = stream
        self.buf = []

    def read(self,num):
        assert num==1

        if len(self.buf):
            return self.buf.pop()

        ## Read a char - this may return a string.
        ## Is this a bug in codecs/Python?
        c = self.cin.read(1)

        if not c or len(c)==1:
            return c

        L = list(c)
        L.reverse()
        for x in L:
            self.buf.append(x)

        ## read one char ..
        return self.read(1)

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       CharScanner                              ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class CharScanner(TokenStream):
    ## class members
    NO_CHAR = 0
    EOF_CHAR = ''  ### EOF shall be the empty string.

    def __init__(self, *argv, **kwargs):
        super(CharScanner, self).__init__()
        self.saveConsumedInput = True
        self.tokenClass = None
        self.caseSensitive = True
        self.caseSensitiveLiterals = True
        self.literals = None
        self.tabsize = 8
        self._returnToken = None
        self.commitToPath = False
        self.traceDepth = 0
        self.text = StringBuffer()
        self.hashString = hash(self)
        self.setTokenObjectClass(CommonToken)
        self.setInput(*argv)

    def __iter__(self):
        return CharScannerIterator(self)

    def setInput(self,*argv):
        ## case 1:
        ## if there's no arg we default to read from
        ## standard input
        if not argv:
            import sys
            self.setInput(sys.stdin)
            return

        ## get 1st argument
        arg1 = argv[0]

        ## case 2:
        ## if arg1 is a string,  we assume it's a file name
        ## and  open  a  stream  using 2nd argument as open
        ## mode. If there's no 2nd argument we fall back to
        ## mode '+rb'.
        if is_string_type(arg1):
            f = open(arg1,"rb")
            self.setInput(f)
            self.setFilename(arg1)
            return

        ## case 3:
        ## if arg1 is a file we wrap it by a char buffer (
        ## some additional checks?? No, can't do this in
        ## general).
        if isinstance(arg1,file):
            self.setInput(CharBuffer(arg1))
            return

        ## case 4:
        ## if arg1 is of type SharedLexerInputState we use
        ## argument as is.
        if isinstance(arg1,LexerSharedInputState):
            self.inputState = arg1
            return

        ## case 5:
        ## check whether argument type is of type input
        ## buffer. If so create a SharedLexerInputState and
        ## go ahead.
        if isinstance(arg1,InputBuffer):
            self.setInput(LexerSharedInputState(arg1))
            return

        ## case 6:
        ## check whether argument type has a method read(int)
        ## If so create CharBuffer ...
        try:
            if arg1.read:
                rd = Reader(arg1)
                cb = CharBuffer(rd)
                ss = LexerSharedInputState(cb)
                self.inputState = ss
            return
        except:
            pass

        ## case 7:
        ## raise wrong argument exception
        raise TypeError(argv)

    def setTabSize(self,size) :
        self.tabsize = size

    def getTabSize(self) :
        return self.tabsize

    def setCaseSensitive(self,t) :
        self.caseSensitive = t

    def setCommitToPath(self,commit) :
        self.commitToPath = commit

    def setFilename(self,f) :
        self.inputState.filename = f

    def setLine(self,line) :
        self.inputState.line = line

    def setText(self,s) :
        self.resetText()
        self.text.append(s)

    def getCaseSensitive(self) :
        return self.caseSensitive

    def getCaseSensitiveLiterals(self) :
        return self.caseSensitiveLiterals

    def getColumn(self) :
        return self.inputState.column

    def setColumn(self,c) :
        self.inputState.column = c

    def getCommitToPath(self) :
        return self.commitToPath

    def getFilename(self) :
        return self.inputState.filename

    def getInputBuffer(self) :
        return self.inputState.input

    def getInputState(self) :
        return self.inputState

    def setInputState(self,state) :
        assert isinstance(state,LexerSharedInputState)
        self.inputState = state

    def getLine(self) :
        return self.inputState.line

    def getText(self) :
        return str(self.text)

    def getTokenObject(self) :
        return self._returnToken

    def LA(self,i) :
        c = self.inputState.input.LA(i)
        if not self.caseSensitive:
            ### E0006
            c = c.__class__.lower(c)
        return c

    def makeToken(self,type) :
        try:
            ## dynamically load a class
            assert self.tokenClass
            tok = self.tokenClass()
            tok.setType(type)
            tok.setColumn(self.inputState.tokenStartColumn)
            tok.setLine(self.inputState.tokenStartLine)
            return tok
        except:
            self.panic("unable to create new token")
        return Token.badToken

    def mark(self) :
        return self.inputState.input.mark()

    def _match_bitset(self,b) :
        if b.member(self.LA(1)):
            self.consume()
        else:
            raise MismatchedCharException(self.LA(1), b, False, self)

    def _match_string(self,s) :
        for c in s:
            if self.LA(1) == c:
                self.consume()
            else:
                raise MismatchedCharException(self.LA(1), c, False, self)

    def match(self,item):
        if is_string_type(item):
            return self._match_string(item)
        else:
            return self._match_bitset(item)

    def matchNot(self,c) :
        if self.LA(1) != c:
            self.consume()
        else:
            raise MismatchedCharException(self.LA(1), c, True, self)

    def matchRange(self,c1,c2) :
        if self.LA(1) < c1 or self.LA(1) > c2 :
            raise MismatchedCharException(self.LA(1), c1, c2, False, self)
        else:
            self.consume()

    def newline(self) :
        self.inputState.line += 1
        self.inputState.column = 1

    def tab(self) :
        c = self.getColumn()
        nc = ( ((c-1)/self.tabsize) + 1) * self.tabsize + 1
        self.setColumn(nc)

    def panic(self,s='') :
        print("CharScanner: panic: " + s)
        sys.exit(1)

    def reportError(self,ex) :
        print(ex)

    def reportError(self,s) :
        if not self.getFilename():
            print("error: " + str(s))
        else:
            print(self.getFilename() + ": error: " + str(s))

    def reportWarning(self,s) :
        if not self.getFilename():
            print("warning: " + str(s))
        else:
            print(self.getFilename() + ": warning: " + str(s))

    def resetText(self) :
        self.text.setLength(0)
        self.inputState.tokenStartColumn = self.inputState.column
        self.inputState.tokenStartLine = self.inputState.line

    def rewind(self,pos) :
        self.inputState.input.rewind(pos)

    def setTokenObjectClass(self,cl):
        self.tokenClass = cl

    def testForLiteral(self,token):
        if not token:
            return
        assert isinstance(token,Token)

        _type = token.getType()

        ## special tokens can't be literals
        if _type in [SKIP,INVALID_TYPE,EOF_TYPE,NULL_TREE_LOOKAHEAD] :
            return

        _text = token.getText()
        if not _text:
            return

        assert is_string_type(_text)
        _type = self.testLiteralsTable(_text,_type)
        token.setType(_type)
        return _type

    def testLiteralsTable(self,*args):
        if is_string_type(args[0]):
            s = args[0]
            i = args[1]
        else:
            s = self.text.getString()
            i = args[0]

        ## check whether integer has been given
        if not isinstance(i,int):
            assert isinstance(i,int)

        ## check whether we have a dict
        assert isinstance(self.literals,dict)
        try:
            ## E0010
            if not self.caseSensitiveLiterals:
                s = s.__class__.lower(s)
            i = self.literals[s]
        except:
            pass
        return i

    def toLower(self,c):
        return c.__class__.lower()

    def traceIndent(self):
        print(' ' * self.traceDepth)

    def traceIn(self,rname):
        self.traceDepth += 1
        self.traceIndent()
        print("> lexer %s c== %s" % (rname,self.LA(1)))

    def traceOut(self,rname):
        self.traceIndent()
        print("< lexer %s c== %s" % (rname,self.LA(1)))
        self.traceDepth -= 1

    def uponEOF(self):
        pass

    def append(self,c):
        if self.saveConsumedInput :
            self.text.append(c)

    def commit(self):
        self.inputState.input.commit()

    def consume(self):
        if not self.inputState.guessing:
            c = self.LA(1)
            if self.caseSensitive:
                self.append(c)
            else:
                # use input.LA(), not LA(), to get original case
                # CharScanner.LA() would toLower it.
                c =  self.inputState.input.LA(1)
                self.append(c)

            if c and c in "\t":
                self.tab()
            else:
                self.inputState.column += 1
        self.inputState.input.consume()

    ## Consume chars until one matches the given char
    def consumeUntil_char(self,c):
        while self.LA(1) != EOF_CHAR and self.LA(1) != c:
            self.consume()

    ## Consume chars until one matches the given set
    def consumeUntil_bitset(self,bitset):
        while self.LA(1) != EOF_CHAR and not self.set.member(self.LA(1)):
            self.consume()

    ### If symbol seen is EOF then generate and set token, otherwise
    ### throw exception.
    def default(self,la1):
        if not la1 :
            self.uponEOF()
            self._returnToken = self.makeToken(EOF_TYPE)
        else:
            self.raise_NoViableAlt(la1)

    def filterdefault(self,la1,*args):
        if not la1:
            self.uponEOF()
            self._returnToken = self.makeToken(EOF_TYPE)
            return

        if not args:
            self.consume()
            raise TryAgain()
        else:
            ### apply filter object
            self.commit();
            try:
                func=args[0]
                args=args[1:]
                func(*args)
            except RecognitionException as e:
                ## catastrophic failure
                self.reportError(e);
                self.consume();
            raise TryAgain()

    def raise_NoViableAlt(self,la1=None):
        if not la1: la1 = self.LA(1)
        fname = self.getFilename()
        line  = self.getLine()
        col   = self.getColumn()
        raise NoViableAltForCharException(la1,fname,line,col)

    def set_return_token(self,_create,_token,_ttype,_offset):
        if _create and not _token and (not _ttype == SKIP):
            string = self.text.getString(_offset)
            _token = self.makeToken(_ttype)
            _token.setText(string)
        self._returnToken = _token
        return _token

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                   CharScannerIterator                          ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class CharScannerIterator:

    def __init__(self,inst):
        if isinstance(inst,CharScanner):
            self.inst = inst
            return
        raise TypeError("CharScannerIterator requires CharScanner object")

    def __next__(self):
        assert self.inst
        item = self.inst.nextToken()
        if not item or item.isEOF():
            raise StopIteration()
        return item

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       BitSet                                   ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

### I'm assuming here that a long is 64bits. It appears however, that
### a long is of any size. That means we can use a single long as the
### bitset (!), ie. Python would do almost all the work (TBD).

class BitSet(object):
    BITS     = 64
    NIBBLE   = 4
    LOG_BITS = 6
    MOD_MASK = BITS -1

    def __init__(self,data=None):
        if not data:
            BitSet.__init__(self,[int(0)])
            return
        if isinstance(data,int):
            BitSet.__init__(self,[int(data)])
            return
        if isinstance(data,int):
            BitSet.__init__(self,[data])
            return
        if not isinstance(data,list):
            raise TypeError("BitSet requires integer, long, or " +
                            "list argument")
        for x in data:
            if not isinstance(x,int):
                raise TypeError(self,"List argument item is " +
                                "not a long: %s" % (x))
        self.data = data

    def __str__(self):
        bits = len(self.data) * BitSet.BITS
        s = ""
        for i in range(0,bits):
            if self.at(i):
                s += "1"
            else:
                s += "o"
            if not ((i+1) % 10):
                s += '|%s|' % (i+1)
        return s

    def __repr__(self):
        return str(self)

    def member(self,item):
        if not item:
            return False

        if isinstance(item,int):
            return self.at(item)

        if not is_string_type(item):
            raise TypeError(self,"char or unichar expected: %s" % (item))

        ## char is a (unicode) string with at most lenght 1, ie.
        ## a char.

        if len(item) != 1:
            raise TypeError(self,"char expected: %s" % (item))

        ### handle ASCII/UNICODE char
        num = ord(item)

        ### check whether position num is in bitset
        return self.at(num)

    def wordNumber(self,bit):
        return bit >> BitSet.LOG_BITS

    def bitMask(self,bit):
        pos = bit & BitSet.MOD_MASK  ## bit mod BITS
        return (1 << pos)

    def set(self,bit,on=True):
        # grow bitset as required (use with care!)
        i = self.wordNumber(bit)
        mask = self.bitMask(bit)
        if i>=len(self.data):
            d = i - len(self.data) + 1
            for x in range(0,d):
                self.data.append(0)
            assert len(self.data) == i+1
        if on:
            self.data[i] |=  mask
        else:
            self.data[i] &= (~mask)

    ### make add an alias for set
    add = set

    def off(self,bit,off=True):
        self.set(bit,not off)

    def at(self,bit):
        i = self.wordNumber(bit)
        v = self.data[i]
        m = self.bitMask(bit)
        return v & m


###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                      some further funcs                        ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

def illegalarg_ex(func):
    raise ValueError(
       "%s is only valid if parser is built for debugging" %
       (func.__name__))

def runtime_ex(func):
    raise RuntimeException(
       "%s is only valid if parser is built for debugging" %
       (func.__name__))

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       TokenBuffer                              ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class TokenBuffer(object):
    def __init__(self,stream):
        self.input = stream
        self.nMarkers = 0
        self.markerOffset = 0
        self.numToConsume = 0
        self.queue = Queue()

    def reset(self) :
        self.nMarkers = 0
        self.markerOffset = 0
        self.numToConsume = 0
        self.queue.reset()

    def consume(self) :
        self.numToConsume += 1

    def fill(self, amount):
        self.syncConsume()
        while self.queue.length() < (amount + self.markerOffset):
            self.queue.append(self.input.nextToken())

    def getInput(self):
        return self.input

    def LA(self,k) :
        self.fill(k)
        return self.queue.elementAt(self.markerOffset + k - 1).type

    def LT(self,k) :
        self.fill(k)
        return self.queue.elementAt(self.markerOffset + k - 1)

    def mark(self) :
        self.syncConsume()
        self.nMarkers += 1
        return self.markerOffset

    def rewind(self,mark) :
        self.syncConsume()
        self.markerOffset = mark
        self.nMarkers -= 1

    def syncConsume(self) :
        while self.numToConsume > 0:
            if self.nMarkers > 0:
                # guess mode -- leave leading characters and bump offset.
                self.markerOffset += 1
            else:
                # normal mode -- remove first character
                self.queue.removeFirst()
            self.numToConsume -= 1

    def __str__(self):
        return "(%s,%s,%s,%s,%s)" % (
           self.input,
           self.nMarkers,
           self.markerOffset,
           self.numToConsume,
           self.queue)

    def __repr__(self):
        return str(self)

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       ParserSharedInputState                   ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class ParserSharedInputState(object):

    def __init__(self):
        self.input = None
        self.reset()

    def reset(self):
        self.guessing = 0
        self.filename = None
        if self.input:
            self.input.reset()

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       Parser                                   ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class Parser(object):

    def __init__(self, *args, **kwargs):
        self.tokenNames = None
        self.returnAST  = None
        self.astFactory = None
        self.tokenTypeToASTClassMap = {}
        self.ignoreInvalidDebugCalls = False
        self.traceDepth = 0
        if not args:
            self.inputState = ParserSharedInputState()
            return
        arg0 = args[0]
        assert isinstance(arg0,ParserSharedInputState)
        self.inputState = arg0
        return

    def getTokenTypeToASTClassMap(self):
        return self.tokenTypeToASTClassMap


    def addMessageListener(self, l):
        if not self.ignoreInvalidDebugCalls:
            illegalarg_ex(addMessageListener)

    def addParserListener(self,l) :
        if (not self.ignoreInvalidDebugCalls) :
            illegalarg_ex(addParserListener)

    def addParserMatchListener(self, l) :
        if (not self.ignoreInvalidDebugCalls) :
            illegalarg_ex(addParserMatchListener)

    def addParserTokenListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            illegalarg_ex(addParserTokenListener)

    def addSemanticPredicateListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            illegalarg_ex(addSemanticPredicateListener)

    def addSyntacticPredicateListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            illegalarg_ex(addSyntacticPredicateListener)

    def addTraceListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            illegalarg_ex(addTraceListener)

    def consume(self):
        raise NotImplementedError()

    def _consumeUntil_type(self,tokenType):
        while self.LA(1) != EOF_TYPE and self.LA(1) != tokenType:
            self.consume()

    def _consumeUntil_bitset(self, set):
        while self.LA(1) != EOF_TYPE and not set.member(self.LA(1)):
            self.consume()

    def consumeUntil(self,arg):
        if isinstance(arg,int):
            self._consumeUntil_type(arg)
        else:
            self._consumeUntil_bitset(arg)

    def defaultDebuggingSetup(self):
        pass

    def getAST(self) :
        return self.returnAST

    def getASTFactory(self) :
        return self.astFactory

    def getFilename(self) :
        return self.inputState.filename

    def getInputState(self) :
        return self.inputState

    def setInputState(self, state) :
        self.inputState = state

    def getTokenName(self,num) :
        return self.tokenNames[num]

    def getTokenNames(self) :
        return self.tokenNames

    def isDebugMode(self) :
        return self.false

    def LA(self, i):
        raise NotImplementedError()

    def LT(self, i):
        raise NotImplementedError()

    def mark(self):
        return self.inputState.input.mark()

    def _match_int(self,t):
        if (self.LA(1) != t):
            raise MismatchedTokenException(
               self.tokenNames, self.LT(1), t, False, self.getFilename())
        else:
            self.consume()

    def _match_set(self, b):
        if (not b.member(self.LA(1))):
            raise MismatchedTokenException(
               self.tokenNames,self.LT(1), b, False, self.getFilename())
        else:
            self.consume()

    def match(self,set) :
        if isinstance(set,int):
            self._match_int(set)
            return
        if isinstance(set,BitSet):
            self._match_set(set)
            return
        raise TypeError("Parser.match requires integer ot BitSet argument")

    def matchNot(self,t):
        if self.LA(1) == t:
            raise MismatchedTokenException(
               tokenNames, self.LT(1), t, True, self.getFilename())
        else:
            self.consume()

    def removeMessageListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            runtime_ex(removeMessageListener)

    def removeParserListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            runtime_ex(removeParserListener)

    def removeParserMatchListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            runtime_ex(removeParserMatchListener)

    def removeParserTokenListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            runtime_ex(removeParserTokenListener)

    def removeSemanticPredicateListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            runtime_ex(removeSemanticPredicateListener)

    def removeSyntacticPredicateListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            runtime_ex(removeSyntacticPredicateListener)

    def removeTraceListener(self, l) :
        if (not self.ignoreInvalidDebugCalls):
            runtime_ex(removeTraceListener)

    def reportError(self,x) :
        fmt = "syntax error:"
        f = self.getFilename()
        if f:
            fmt = ("%s:" % f) + fmt
        if isinstance(x,Token):
            line = x.getColumn()
            col  = x.getLine()
            text = x.getText()
            fmt  = fmt + 'unexpected symbol at line %s (column %s) : "%s"'
            print(fmt % (line,col,text), file=sys.stderr)
        else:
            print(fmt,str(x), file=sys.stderr)

    def reportWarning(self,s):
        f = self.getFilename()
        if f:
            print("%s:warning: %s" % (f,str(x)))
        else:
            print("warning: %s" % (str(x)))

    def rewind(self, pos) :
        self.inputState.input.rewind(pos)

    def setASTFactory(self, f) :
        self.astFactory = f

    def setASTNodeClass(self, cl) :
        self.astFactory.setASTNodeType(cl)

    def setASTNodeType(self, nodeType) :
        self.setASTNodeClass(nodeType)

    def setDebugMode(self, debugMode) :
        if (not self.ignoreInvalidDebugCalls):
            runtime_ex(setDebugMode)

    def setFilename(self, f) :
        self.inputState.filename = f

    def setIgnoreInvalidDebugCalls(self, value) :
        self.ignoreInvalidDebugCalls = value

    def setTokenBuffer(self, t) :
        self.inputState.input = t

    def traceIndent(self):
        print(" " * self.traceDepth)

    def traceIn(self,rname):
        self.traceDepth += 1
        self.trace("> ", rname)

    def traceOut(self,rname):
        self.trace("< ", rname)
        self.traceDepth -= 1

    ### wh: moved from ASTFactory to Parser
    def addASTChild(self,currentAST, child):
        if not child:
            return
        if not currentAST.root:
            currentAST.root = child
        elif not currentAST.child:
            currentAST.root.setFirstChild(child)
        else:
            currentAST.child.setNextSibling(child)
        currentAST.child = child
        currentAST.advanceChildToEnd()

    ### wh: moved from ASTFactory to Parser
    def makeASTRoot(self,currentAST,root) :
        if root:
            ### Add the current root as a child of new root
            root.addChild(currentAST.root)
            ### The new current child is the last sibling of the old root
            currentAST.child = currentAST.root
            currentAST.advanceChildToEnd()
            ### Set the new root
            currentAST.root = root

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       LLkParser                                ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class LLkParser(Parser):

    def __init__(self, *args, **kwargs):
        try:
            arg1 = args[0]
        except:
            arg1 = 1

        if isinstance(arg1,int):
            super(LLkParser,self).__init__()
            self.k = arg1
            return

        if isinstance(arg1,ParserSharedInputState):
            super(LLkParser,self).__init__(arg1)
            self.set_k(1,*args)
            return

        if isinstance(arg1,TokenBuffer):
            super(LLkParser,self).__init__()
            self.setTokenBuffer(arg1)
            self.set_k(1,*args)
            return

        if isinstance(arg1,TokenStream):
            super(LLkParser,self).__init__()
            tokenBuf = TokenBuffer(arg1)
            self.setTokenBuffer(tokenBuf)
            self.set_k(1,*args)
            return

        ### unknown argument
        raise TypeError("LLkParser requires integer, " +
                        "ParserSharedInputStream or TokenStream argument")

    def consume(self):
        self.inputState.input.consume()

    def LA(self,i):
        return self.inputState.input.LA(i)

    def LT(self,i):
        return self.inputState.input.LT(i)

    def set_k(self,index,*args):
        try:
            self.k = args[index]
        except:
            self.k = 1

    def trace(self,ee,rname):
        print(type(self))
        self.traceIndent()
        guess = ""
        if self.inputState.guessing > 0:
            guess = " [guessing]"
        print((ee + rname + guess))
        for i in range(1,self.k+1):
            if i != 1:
                print(", ")
            if self.LT(i) :
                v = self.LT(i).getText()
            else:
                v = "null"
            print("LA(%s) == %s" % (i,v))
        print("\n")

    def traceIn(self,rname):
        self.traceDepth += 1;
        self.trace("> ", rname);

    def traceOut(self,rname):
        self.trace("< ", rname);
        self.traceDepth -= 1;

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                    TreeParserSharedInputState                  ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class TreeParserSharedInputState(object):
    def __init__(self):
        self.guessing = 0

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       TreeParser                               ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class TreeParser(object):

    def __init__(self, *args, **kwargs):
        self.inputState = TreeParserSharedInputState()
        self._retTree   = None
        self.tokenNames = []
        self.returnAST  = None
        self.astFactory = ASTFactory()
        self.traceDepth = 0

    def getAST(self):
        return self.returnAST

    def getASTFactory(self):
        return self.astFactory

    def getTokenName(self,num) :
        return self.tokenNames[num]

    def getTokenNames(self):
        return self.tokenNames

    def match(self,t,set) :
        assert isinstance(set,int) or isinstance(set,BitSet)
        if not t or t == ASTNULL:
            raise MismatchedTokenException(self.getTokenNames(), t,set, False)

        if isinstance(set,int) and t.getType() != set:
            raise MismatchedTokenException(self.getTokenNames(), t,set, False)

        if isinstance(set,BitSet) and not set.member(t.getType):
            raise MismatchedTokenException(self.getTokenNames(), t,set, False)

    def matchNot(self,t, ttype) :
        if not t or (t == ASTNULL) or (t.getType() == ttype):
            raise MismatchedTokenException(getTokenNames(), t, ttype, True)

    def reportError(self,ex):
        print("error:",ex, file=sys.stderr)

    def  reportWarning(self, s):
        print("warning:",s)

    def setASTFactory(self,f):
        self.astFactory = f

    def setASTNodeType(self,nodeType):
        self.setASTNodeClass(nodeType)

    def setASTNodeClass(self,nodeType):
        self.astFactory.setASTNodeType(nodeType)

    def traceIndent(self):
        print(" " * self.traceDepth)

    def traceIn(self,rname,t):
        self.traceDepth += 1
        self.traceIndent()
        print(("> " + rname + "(" +
              ifelse(t,str(t),"null") + ")" +
              ifelse(self.inputState.guessing>0,"[guessing]","")))

    def traceOut(self,rname,t):
        self.traceIndent()
        print(("< " + rname + "(" +
              ifelse(t,str(t),"null") + ")" +
              ifelse(self.inputState.guessing>0,"[guessing]","")))
        self.traceDepth -= 1

    ### wh: moved from ASTFactory to TreeParser
    def addASTChild(self,currentAST, child):
        if not child:
            return
        if not currentAST.root:
            currentAST.root = child
        elif not currentAST.child:
            currentAST.root.setFirstChild(child)
        else:
            currentAST.child.setNextSibling(child)
        currentAST.child = child
        currentAST.advanceChildToEnd()

    ### wh: moved from ASTFactory to TreeParser
    def makeASTRoot(self,currentAST,root):
        if root:
            ### Add the current root as a child of new root
            root.addChild(currentAST.root)
            ### The new current child is the last sibling of the old root
            currentAST.child = currentAST.root
            currentAST.advanceChildToEnd()
            ### Set the new root
            currentAST.root = root

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###               funcs to work on trees                           ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

def rightmost(ast):
    if ast:
        while(ast.right):
            ast = ast.right
    return ast

def cmptree(s,t,partial):
    while(s and t):
        ### as a quick optimization, check roots first.
        if not s.equals(t):
            return False

        ### if roots match, do full list match test on children.
        if not cmptree(s.getFirstChild(),t.getFirstChild(),partial):
            return False

        s = s.getNextSibling()
        t = t.getNextSibling()

    r = ifelse(partial,not t,not s and not t)
    return r

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                          AST                                   ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class AST(object):
    def __init__(self):
        pass

    def addChild(self, c):
        pass

    def equals(self, t):
        return False

    def equalsList(self, t):
        return False

    def equalsListPartial(self, t):
        return False

    def equalsTree(self, t):
        return False

    def equalsTreePartial(self, t):
        return False

    def findAll(self, tree):
        return None

    def findAllPartial(self, subtree):
        return None

    def getFirstChild(self):
        return self

    def getNextSibling(self):
        return self

    def getText(self):
        return ""

    def getType(self):
        return INVALID_TYPE

    def getLine(self):
        return 0

    def getColumn(self):
        return 0

    def getNumberOfChildren(self):
        return 0

    def initialize(self, t, txt):
        pass

    def initialize(self, t):
        pass

    def setFirstChild(self, c):
        pass

    def setNextSibling(self, n):
        pass

    def setText(self, text):
        pass

    def setType(self, ttype):
        pass

    def toString(self):
        self.getText()

    __str__ = toString

    def toStringList(self):
        return self.getText()

    def toStringTree(self):
        return self.getText()

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       ASTNULLType                              ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

### There is only one instance of this class **/
class ASTNULLType(AST):
    def __init__(self):
        AST.__init__(self)
        pass

    def getText(self):
        return "<ASTNULL>"

    def getType(self):
        return NULL_TREE_LOOKAHEAD


###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       BaseAST                                  ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class BaseAST(AST):

    verboseStringConversion = False
    tokenNames = None

    def __init__(self):
        self.down  = None ## kid
        self.right = None ## sibling

    def addChild(self,node):
        if node:
            t = rightmost(self.down)
            if t:
                t.right = node
            else:
                assert not self.down
                self.down = node

    def getNumberOfChildren(self):
        t = self.down
        n = 0
        while t:
            n += 1
            t = t.right
        return n

    def doWorkForFindAll(self,v,target,partialMatch):
        sibling = self

        while sibling:
            c1 = partialMatch and sibling.equalsTreePartial(target)
            if c1:
                v.append(sibling)
            else:
                c2 = not partialMatch and sibling.equalsTree(target)
                if c2:
                    v.append(sibling)

            ### regardless of match or not, check any children for matches
            if sibling.getFirstChild():
                sibling.getFirstChild().doWorkForFindAll(v,target,partialMatch)

            sibling = sibling.getNextSibling()

    ### Is node t equal to 'self' in terms of token type and text?
    def equals(self,t):
        if not t:
            return False
        return self.getText() == t.getText() and self.getType() == t.getType()

    ### Is t an exact structural and equals() match of this tree.  The
    ### 'self' reference is considered the start of a sibling list.
    ###
    def equalsList(self, t):
        return cmptree(self, t, partial=False)

    ### Is 't' a subtree of this list?
    ### The siblings of the root are NOT ignored.
    ###
    def equalsListPartial(self,t):
        return cmptree(self,t,partial=True)

    ### Is tree rooted at 'self' equal to 't'?  The siblings
    ### of 'self' are ignored.
    ###
    def equalsTree(self, t):
        return self.equals(t) and \
               cmptree(self.getFirstChild(), t.getFirstChild(), partial=False)

    ### Is 't' a subtree of the tree rooted at 'self'?  The siblings
    ### of 'self' are ignored.
    ###
    def equalsTreePartial(self, t):
        if not t:
            return True
        return self.equals(t) and cmptree(
           self.getFirstChild(), t.getFirstChild(), partial=True)

    ### Walk the tree looking for all exact subtree matches.  Return
    ### an ASTEnumerator that lets the caller walk the list
    ### of subtree roots found herein.
    def findAll(self,target):
        roots = []

        ### the empty tree cannot result in an enumeration
        if not target:
            return None
        # find all matches recursively
        self.doWorkForFindAll(roots, target, False)
        return roots

    ### Walk the tree looking for all subtrees.  Return
    ###  an ASTEnumerator that lets the caller walk the list
    ###  of subtree roots found herein.
    def findAllPartial(self,sub):
        roots = []

        ### the empty tree cannot result in an enumeration
        if not sub:
            return None

        self.doWorkForFindAll(roots, sub, True)  ### find all matches recursively
        return roots

    ### Get the first child of this node None if not children
    def getFirstChild(self):
        return self.down

    ### Get the next sibling in line after this one
    def getNextSibling(self):
        return self.right

    ### Get the token text for this node
    def getText(self):
        return ""

    ### Get the token type for this node
    def getType(self):
        return 0

    def getLine(self):
        return 0

    def getColumn(self):
        return 0

    ### Remove all children */
    def removeChildren(self):
        self.down = None

    def setFirstChild(self,c):
        self.down = c

    def setNextSibling(self, n):
        self.right = n

    ### Set the token text for this node
    def setText(self, text):
        pass

    ### Set the token type for this node
    def setType(self, ttype):
        pass

    ### static
    def setVerboseStringConversion(verbose,names):
        verboseStringConversion = verbose
        tokenNames = names
    setVerboseStringConversion = staticmethod(setVerboseStringConversion)

    ### Return an array of strings that maps token ID to it's text.
    ##  @since 2.7.3
    def getTokenNames():
        return tokenNames

    def toString(self):
        return self.getText()

    ### return tree as lisp string - sibling included
    def toStringList(self):
        ts = self.toStringTree()
        sib = self.getNextSibling()
        if sib:
            ts += sib.toStringList()
        return ts

    __str__ = toStringList

    ### return tree as string - siblings ignored
    def toStringTree(self):
        ts = ""
        kid = self.getFirstChild()
        if kid:
            ts += " ("
        ts += " " + self.toString()
        if kid:
            ts += kid.toStringList()
            ts += " )"
        return ts

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       CommonAST                                ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

### Common AST node implementation
class CommonAST(BaseAST):
    def __init__(self,token=None):
        super(CommonAST,self).__init__()
        self.ttype = INVALID_TYPE
        self.text  = "<no text>"
        self.line  = 0
        self.column= 0
        self.initialize(token)
        #assert self.text

    ### Get the token text for this node
    def getText(self):
        return self.text

    ### Get the token type for this node
    def getType(self):
        return self.ttype

    ### Get the line for this node
    def getLine(self):
        return self.line

    ### Get the column for this node
    def getColumn(self):
        return self.column

    def initialize(self,*args):
        if not args:
            return

        arg0 = args[0]

        if isinstance(arg0,int):
            arg1 = args[1]
            self.setType(arg0)
            self.setText(arg1)
            return

        if isinstance(arg0,AST) or isinstance(arg0,Token):
            self.setText(arg0.getText())
            self.setType(arg0.getType())
            self.line = arg0.getLine()
            self.column = arg0.getColumn()
            return

    ### Set the token text for this node
    def setText(self,text_):
        assert is_string_type(text_)
        self.text = text_

    ### Set the token type for this node
    def setType(self,ttype_):
        assert isinstance(ttype_,int)
        self.ttype = ttype_

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                     CommonASTWithHiddenTokens                  ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class CommonASTWithHiddenTokens(CommonAST):

    def __init__(self,*args):
        CommonAST.__init__(self,*args)
        self.hiddenBefore = None
        self.hiddenAfter  = None

    def getHiddenAfter(self):
        return self.hiddenAfter

    def getHiddenBefore(self):
        return self.hiddenBefore

    def initialize(self,*args):
        CommonAST.initialize(self,*args)
        if args and isinstance(args[0],Token):
            assert isinstance(args[0],CommonHiddenStreamToken)
            self.hiddenBefore = args[0].getHiddenBefore()
            self.hiddenAfter  = args[0].getHiddenAfter()

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       ASTPair                                  ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class ASTPair(object):
    def __init__(self):
        self.root = None          ### current root of tree
        self.child = None         ### current child to which siblings are added

    ### Make sure that child is the last sibling */
    def advanceChildToEnd(self):
        if self.child:
            while self.child.getNextSibling():
                self.child = self.child.getNextSibling()

    ### Copy an ASTPair.  Don't call it clone() because we want type-safety */
    def copy(self):
        tmp = ASTPair()
        tmp.root = self.root
        tmp.child = self.child
        return tmp

    def toString(self):
        r = ifelse(not root,"null",self.root.getText())
        c = ifelse(not child,"null",self.child.getText())
        return "[%s,%s]" % (r,c)

    __str__ = toString
    __repr__ = toString


###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       ASTFactory                               ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class ASTFactory(object):
    def __init__(self,table=None):
        self._class = None
        self._classmap = ifelse(table,table,None)

    def create(self,*args):
        if not args:
            return self.create(INVALID_TYPE)

        arg0 = args[0]
        arg1 = None
        arg2 = None

        try:
            arg1 = args[1]
            arg2 = args[2]
        except:
            pass

        # ctor(int)
        if isinstance(arg0,int) and not arg2:
            ### get class for 'self' type
            c = self.getASTNodeType(arg0)
            t = self.create(c)
            if t:
                t.initialize(arg0, ifelse(arg1,arg1,""))
            return t

        # ctor(int,something)
        if isinstance(arg0,int) and arg2:
            t = self.create(arg2)
            if t:
                t.initialize(arg0,arg1)
            return t

        # ctor(AST)
        if isinstance(arg0,AST):
            t = self.create(arg0.getType())
            if t:
                t.initialize(arg0)
            return t

        # ctor(token)
        if isinstance(arg0,Token) and not arg1:
            ttype = arg0.getType()
            assert isinstance(ttype,int)
            t = self.create(ttype)
            if t:
                t.initialize(arg0)
            return t

        # ctor(token,class)
        if isinstance(arg0,Token) and arg1:
            assert isinstance(arg1,type)
            assert issubclass(arg1,AST)
            # this creates instance of 'arg1' using 'arg0' as
            # argument. Wow, that's magic!
            t = arg1(arg0)
            assert t and isinstance(t,AST)
            return t

        # ctor(class)
        if isinstance(arg0,type):
            ### next statement creates instance of type (!)
            t = arg0()
            assert isinstance(t,AST)
            return t


    def setASTNodeClass(self,className=None):
        if not className:
            return
        assert isinstance(className,type)
        assert issubclass(className,AST)
        self._class = className

    ### kind of misnomer - use setASTNodeClass instead.
    setASTNodeType = setASTNodeClass

    def getASTNodeClass(self):
        return self._class



    def getTokenTypeToASTClassMap(self):
        return self._classmap

    def setTokenTypeToASTClassMap(self,amap):
        self._classmap = amap

    def error(self, e):
        import sys
        print(e, file=sys.stderr)

    def setTokenTypeASTNodeType(self, tokenType, className):
        """
        Specify a mapping between a token type and a (AST) class.
        """
        if not self._classmap:
            self._classmap = {}

        if not className:
            try:
                del self._classmap[tokenType]
            except:
                pass
        else:
            ### here we should also perform actions to ensure that
            ### a. class can be loaded
            ### b. class is a subclass of AST
            ###
            assert isinstance(className,type)
            assert issubclass(className,AST)  ## a & b
            ### enter the class
            self._classmap[tokenType] = className

    def getASTNodeType(self,tokenType):
        """
        For a given token type return the AST node type. First we
        lookup a mapping table, second we try _class
        and finally we resolve to "antlr.CommonAST".
        """

        # first
        if self._classmap:
            try:
                c = self._classmap[tokenType]
                if c:
                    return c
            except:
                pass
        # second
        if self._class:
            return self._class

        # default
        return CommonAST

    ### methods that have been moved to file scope - just listed
    ### here to be somewhat consistent with original API
    def dup(self,t):
        return antlr.dup(t,self)

    def dupList(self,t):
        return antlr.dupList(t,self)

    def dupTree(self,t):
        return antlr.dupTree(t,self)

    ### methods moved to other classes
    ### 1. makeASTRoot  -> Parser
    ### 2. addASTChild  -> Parser

    ### non-standard: create alias for longish method name
    maptype = setTokenTypeASTNodeType

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###                       ASTVisitor                               ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

class ASTVisitor(object):
    def __init__(self,*args):
        pass

    def visit(self,ast):
        pass

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###
###               static methods and variables                     ###
###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx###

ASTNULL = ASTNULLType()

### wh: moved from ASTFactory as there's nothing ASTFactory-specific
### in this method.
def make(*nodes):
    if not nodes:
        return None

    for i in range(0,len(nodes)):
        node = nodes[i]
        if node:
            assert isinstance(node,AST)

    root = nodes[0]
    tail = None
    if root:
        root.setFirstChild(None)

    for i in range(1,len(nodes)):
        if not nodes[i]:
            continue
        if not root:
            root = tail = nodes[i]
        elif not tail:
            root.setFirstChild(nodes[i])
            tail = root.getFirstChild()
        else:
            tail.setNextSibling(nodes[i])
            tail = tail.getNextSibling()

        ### Chase tail to last sibling
        while tail.getNextSibling():
            tail = tail.getNextSibling()
    return root

def dup(t,factory):
    if not t:
        return None

    if factory:
        dup_t = factory.create(t.__class__)
    else:
        raise TypeError("dup function requires ASTFactory argument")
    dup_t.initialize(t)
    return dup_t

def dupList(t,factory):
    result = dupTree(t,factory)
    nt = result
    while t:
        ## for each sibling of the root
        t = t.getNextSibling()
        nt.setNextSibling(dupTree(t,factory))
        nt = nt.getNextSibling()
    return result

def dupTree(t,factory):
    result = dup(t,factory)
    if t:
        result.setFirstChild(dupList(t.getFirstChild(),factory))
    return result

###xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
### $Id: antlr.py 3750 2009-02-13 00:13:04Z sjmachin $

# Local Variables:    ***
# mode: python        ***
# py-indent-offset: 4 ***
# End:                ***

########NEW FILE########
__FILENAME__ = BIFFRecords
from struct import pack
from .UnicodeUtils import upack1, upack2
import sys

class SharedStringTable(object):
    _SST_ID = 0x00FC
    _CONTINUE_ID = 0x003C

    def __init__(self, encoding):
        self.encoding = encoding
        self._str_indexes = {}
        self._tally = []
        self._add_calls = 0
        # Following 3 attrs are used for temporary storage in the
        # get_biff_record() method and methods called by it. The pseudo-
        # initialisation here is for documentation purposes only.
        self._sst_record = None
        self._continues = None
        self._current_piece = None

    def add_str(self, s):
        if self.encoding != 'ascii' and not isinstance(s, str):
            s = str(s, self.encoding)
        self._add_calls += 1
        if s not in self._str_indexes:
            idx = len(self._str_indexes)
            self._str_indexes[s] = idx
            self._tally.append(1)
        else:
            idx = self._str_indexes[s]
            self._tally[idx] += 1
        return idx

    def del_str(self, idx):
        # This is called when we are replacing the contents of a string cell.
        assert self._tally[idx] > 0
        self._tally[idx] -= 1
        self._add_calls -= 1

    def str_index(self, s):
        return self._str_indexes[s]

    def get_biff_record(self):
        self._sst_record = b''
        self._continues = [None, None]
        self._current_piece = pack('<II', 0, 0)
        data = [(idx, s) for s, idx in list(self._str_indexes.items())]
        data.sort() # in index order
        for idx, s in data:
            if self._tally[idx] == 0:
                s = b''
            self._add_to_sst(s)
        del data
        self._new_piece()
        self._continues[0] = pack('<2HII', self._SST_ID, len(self._sst_record), self._add_calls, len(self._str_indexes))
        self._continues[1] = self._sst_record[8:]
        self._sst_record = None
        self._current_piece = None
        result = b''.join(self._continues)
        self._continues = None
        return result


    def _add_to_sst(self, s):
        u_str = upack2(s, self.encoding)
        # (to_py3): added b'...'
        is_unicode_str = u_str[2] == b'\x01'
        if is_unicode_str:
            atom_len = 5 # 2 byte -- len,
                         # 1 byte -- options,
                         # 2 byte -- 1st sym
        else:
            atom_len = 4 # 2 byte -- len,
                         # 1 byte -- options,
                         # 1 byte -- 1st sym

        self._save_atom(u_str[0:atom_len])
        self._save_splitted(u_str[atom_len:], is_unicode_str)

    def _new_piece(self):
        if self._sst_record == b'':
            self._sst_record = self._current_piece
        else:
            curr_piece_len = len(self._current_piece)
            self._continues.append(pack('<2H%ds'%curr_piece_len, self._CONTINUE_ID, curr_piece_len, self._current_piece))
        self._current_piece = b''

    def _save_atom(self, s):
        atom_len = len(s)
        free_space = 0x2020 - len(self._current_piece)
        if free_space < atom_len:
            self._new_piece()
        self._current_piece += s

    def _save_splitted(self, s, is_unicode_str):
        i = 0
        str_len = len(s)
        while i < str_len:
            piece_len = len(self._current_piece)
            free_space = 0x2020 - piece_len
            tail_len = str_len - i
            need_more_space = free_space < tail_len

            if not need_more_space:
                atom_len = tail_len
            else:
                if is_unicode_str:
                    atom_len = free_space & 0xFFFE
                else:
                    atom_len = free_space

            self._current_piece += s[i:i+atom_len]

            if need_more_space:
                self._new_piece()
                if is_unicode_str:
                    self._current_piece += b'\x01' # (to_py3): added b'...'
                else:
                    self._current_piece += b'\x00' # (to_py3): added b'...'

            i += atom_len


class BiffRecord(object):

    _rec_data = b'' # class attribute; child classes need to set this.

    # Sheer waste.
    # def __init__(self):
    #     self._rec_data = ''

    def get_rec_id(self):
        return _REC_ID

    def get_rec_header(self):
        return pack('<2H', self._REC_ID, len(self._rec_data))

    # Not over-ridden by any child classes, never called (except by "get"; see below).
    # def get_rec_data(self):
    #     return self._rec_data

    def get(self):
        # data = self.get_rec_data()
        data = self._rec_data

        if len(data) > 0x2020: # limit for BIFF7/8
            chunks = []
            pos = 0
            while pos < len(data):
                chunk_pos = pos + 0x2020
                chunk = data[pos:chunk_pos]
                chunks.append(chunk)
                pos = chunk_pos
            continues = pack('<2H', self._REC_ID, len(chunks[0])) + chunks[0]
            for chunk in chunks[1:]:
                continues += pack('<2H%ds'%len(chunk), 0x003C, len(chunk), chunk)
                # 0x003C -- CONTINUE record id
            return continues
        else:
            return self.get_rec_header() + data


class Biff8BOFRecord(BiffRecord):
    """
    Offset Size Contents
    0      2    Version, contains 0600H for BIFF8 and BIFF8X
    2      2    Type of the following data:
                  0005H = Workbook globals
                  0006H = Visual Basic module
                  0010H = Worksheet
                  0020H = Chart
                  0040H = Macro sheet
                  0100H = Workspace file
    4      2    Build identifier
    6      2    Build year
    8      4    File history flags
    12     4    Lowest Excel version that can read all records in this file
    """
    _REC_ID      = 0x0809
    # stream types
    BOOK_GLOBAL = 0x0005
    VB_MODULE   = 0x0006
    WORKSHEET   = 0x0010
    CHART       = 0x0020
    MACROSHEET  = 0x0040
    WORKSPACE   = 0x0100

    def __init__(self, rec_type):
        version  = 0x0600
        build    = 0x0DBB
        year     = 0x07CC
        file_hist_flags = 0x00
        ver_can_read    = 0x06

        self._rec_data = pack('<4H2I', version, rec_type, build, year, file_hist_flags, ver_can_read)


class InteraceHdrRecord(BiffRecord):
    _REC_ID = 0x00E1

    def __init__(self):
        self._rec_data = pack('BB', 0xB0, 0x04)


class InteraceEndRecord(BiffRecord):
    _REC_ID = 0x00E2

    def __init__(self):
        self._rec_data = b''


class MMSRecord(BiffRecord):
    _REC_ID = 0x00C1

    def __init__(self):
        self._rec_data = pack('<H', 0x00)


class WriteAccessRecord(BiffRecord):
    """
    This record is part of the file protection. It contains the name of the
    user  that  has  saved  the  file. The user name is always stored as an
    equal-sized  string.  All  unused  characters after the name are filled
    with space characters. It is not required to write the mentioned string
    length. Every other length will be accepted too.
    """
    _REC_ID = 0x005C

    def __init__(self, owner):
        uowner = owner[0:0x30]
        uowner_len = len(uowner)
        self._rec_data = pack(bytes('%ds%ds' % (uowner_len, 0x70 - uowner_len), encoding='utf8'), bytes(uowner, encoding='utf8'), b' '*(0x70 - uowner_len)) # (to_py3): added b'...'
        # self._rec_data = (b'%ds%ds' % (uowner_len, 0x70 - uowner_len), uowner, b' '*(0x70 - uowner_len)) # (to_py3): added b'...'


class DSFRecord(BiffRecord):
    """
    This  record  specifies  if the file contains an additional BIFF5/BIFF7
    workbook stream.
    Record DSF, BIFF8:
    Offset Size Contents
    0        2     0 = Only the BIFF8 Workbook stream is present
                   1 = Additional BIFF5/BIFF7 Book stream is in the file
    A  double  stream file can be read by Excel 5.0 and Excel 95, and still
    contains  all  new  features  added to BIFF8 (which are left out in the
    BIFF5/BIFF7 Book stream).
    """
    _REC_ID = 0x0161

    def __init__(self):
        self._rec_data = pack('<H', 0x00)


class TabIDRecord(BiffRecord):
    _REC_ID = 0x013D

    def __init__(self, sheetcount):
        for i in range(sheetcount):
            self._rec_data += pack('<H', i+1)


class FnGroupCountRecord(BiffRecord):
    _REC_ID = 0x009C

    def __init__(self):
        self._rec_data = pack('BB', 0x0E, 0x00)


class WindowProtectRecord(BiffRecord):
    """
    This record is part of the worksheet/workbook protection. It determines
    whether  the window configuration of this document is protected. Window
    protection is not active, if this record is omitted.
    """
    _REC_ID = 0x0019

    def __init__(self, wndprotect):
        self._rec_data = pack('<H', wndprotect)


class ObjectProtectRecord(BiffRecord):
    """
    This record is part of the worksheet/workbook protection.
    It determines whether the objects of the current sheet are protected.
    Object protection is not active, if this record is omitted.
    """
    _REC_ID = 0x0063


    def __init__(self, objprotect):
        self._rec_data = pack('<H', objprotect)


class ScenProtectRecord(BiffRecord):
    """
    This record is part of the worksheet/workbook protection. It
    determines whether the scenarios of the current sheet are protected.
    Scenario protection is not active, if this record is omitted.
    """
    _REC_ID = 0x00DD


    def __init__(self, scenprotect):
        self._rec_data = pack('<H', scenprotect)


class ProtectRecord(BiffRecord):
    """
    This  record is part of the worksheet/workbook protection. It specifies
    whether  a  worksheet  or a workbook is protected against modification.
    Protection is not active, if this record is omitted.
    """

    _REC_ID = 0x0012

    def __init__(self, protect):
        self._rec_data = pack('<H', protect)


class PasswordRecord(BiffRecord):
    """
    This record is part of the worksheet/workbook protection. It
    stores a 16-bit hash value, calculated from the worksheet or workbook
    protection password.
    """
    _REC_ID = 0x0013
    def passwd_hash(self, plaintext):
        """
        Based on the algorithm provided by Daniel Rentz of OpenOffice.
        """
        if plaintext == b"":
            return 0

        passwd_hash = 0x0000
        for i, char in enumerate(plaintext):
            c = ord(char) << (i + 1)
            low_15 = c & 0x7fff
            high_15 = c & 0x7fff << 15
            high_15 = high_15 >> 15
            c = low_15 | high_15
            passwd_hash ^= c
        passwd_hash ^= len(plaintext)
        passwd_hash ^= 0xCE4B
        return passwd_hash

    def __init__(self, passwd = b""):
        self._rec_data = pack('<H', self.passwd_hash(passwd))


class Prot4RevRecord(BiffRecord):
    _REC_ID = 0x01AF

    def __init__(self):
        self._rec_data = pack('<H', 0x00)


class Prot4RevPassRecord(BiffRecord):
    _REC_ID = 0x01BC

    def __init__(self):
        self._rec_data = pack('<H', 0x00)


class BackupRecord(BiffRecord):
    """
    This  record  contains  a Boolean value determining whether Excel makes
    a backup of the file while saving.
    """
    _REC_ID = 0x0040

    def __init__(self, backup):
        self._rec_data = pack('<H', backup)

class HideObjRecord(BiffRecord):
    """
    This record specifies whether and how to show objects in the workbook.

    Record HIDEOBJ, BIFF3-BIFF8:
    Offset  Size    Contents
    0       2       Viewing mode for objects:
                        0 = Show all objects
                        1 = Show placeholders
                        2 = Do not show objects
    """
    _REC_ID = 0x008D

    def __init__(self):
        self._rec_data = pack('<H', 0x00)



class RefreshAllRecord(BiffRecord):
    """
    """

    _REC_ID = 0x01B7

    def __init__(self):
        self._rec_data = pack('<H', 0x00)


class BookBoolRecord(BiffRecord):
    """
    This record contains a Boolean value determining whether to save values
    linked  from external workbooks (CRN records and XCT records). In BIFF3
    and BIFF4 this option is stored in the WSBOOL record.

    Record BOOKBOOL, BIFF5-BIFF8:

    Offset  Size    Contents
    0       2       0 = Save external linked values;
                    1 = Do not save external linked values
    """

    _REC_ID = 0x00DA

    def __init__(self):
        self._rec_data = pack('<H', 0x00)


class CountryRecord(BiffRecord):
    """
    This   record   stores  two  Windows  country  identifiers.  The  first
    represents  the  user  interface language of the Excel version that has
    saved  the file, and the second represents the system regional settings
    at the time the file was saved.

    Record COUNTRY, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       Windows country identifier of the user interface language of Excel
    2       2       Windows country identifier of the system regional settings

    The  following  table  shows most of the used country identifiers. Most
    of  these  identifiers  are  equal to the international country calling
    codes.

    1   USA
    2   Canada
    7   Russia
    """

    _REC_ID = 0x008C

    def __init__(self, ui_id, sys_settings_id):
        self._rec_data = pack('<2H', ui_id, sys_settings_id)


class UseSelfsRecord(BiffRecord):
    """
    This  record  specifies if the formulas in the workbook can use natural
    language  formulas.  This  type  of  formula can refer to cells by its
    content or the content of the column or row header cell.

    Record USESELFS, BIFF8:

    Offset  Size    Contents
    0       2       0 = Do not use natural language formulas
                    1 = Use natural language formulas

    """

    _REC_ID = 0x0160

    def __init__(self):
        self._rec_data = pack('<H', 0x01)


class EOFRecord(BiffRecord):
    _REC_ID = 0x000A

    def __init__(self):
        self._rec_data = b''


class DateModeRecord(BiffRecord):
    """
    This  record  specifies  the  base date for displaying date values. All
    dates  are  stored as count of days past this base date. In BIFF2-BIFF4
    this   record  is  part  of  the  Calculation  Settings  Block.
    In BIFF5-BIFF8 it is stored in the Workbook Globals Substream.

    Record DATEMODE, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       0 = Base is 1899-Dec-31 (the cell = 1 represents 1900-Jan-01)
                    1 = Base is 1904-Jan-01 (the cell = 1 represents 1904-Jan-02)
    """
    _REC_ID = 0x0022

    def __init__(self, from1904):
        if from1904:
            self._rec_data = pack('<H', 1)
        else:
            self._rec_data = pack('<H', 0)


class PrecisionRecord(BiffRecord):
    """
    This record stores if formulas use the real cell values for calculation
    or  the  values  displayed  on  the screen. In BIFF2- BIFF4 this record
    is  part of the Calculation Settings Block. In BIFF5-BIFF8 it is stored
    in the Workbook Globals Substream.

    Record PRECISION, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       0 = Use displayed values;
                    1 = Use real cell values
    """
    _REC_ID = 0x000E

    def __init__(self, use_real_values):
        if use_real_values:
            self._rec_data = pack('<H', 1)
        else:
            self._rec_data = pack('<H', 0)


class CodepageBiff8Record(BiffRecord):
    """
    This record stores the text encoding used to write byte strings, stored
    as MS Windows code page identifier. The CODEPAGE record in BIFF8 always
    contains  the  code  page  1200  (UTF-16).  Therefore  it is not
    possible  to  obtain the encoding used for a protection password (it is
    not UTF-16).

    Record CODEPAGE, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       Code page identifier used for byte string text encoding:
                      016FH = 367 = ASCII
                      01B5H = 437 = IBM PC CP-437 (US)
                      02D0H = 720 = IBM PC CP-720 (OEM Arabic)
                      02E1H = 737 = IBM PC CP-737 (Greek)
                      0307H = 775 = IBM PC CP-775 (Baltic)
                      0352H = 850 = IBM PC CP-850 (Latin I)
                      0354H = 852 = IBM PC CP-852 (Latin II (Central European))
                      0357H = 855 = IBM PC CP-855 (Cyrillic)
                      0359H = 857 = IBM PC CP-857 (Turkish)
                      035AH = 858 = IBM PC CP-858 (Multilingual Latin I with Euro)
                      035CH = 860 = IBM PC CP-860 (Portuguese)
                      035DH = 861 = IBM PC CP-861 (Icelandic)
                      035EH = 862 = IBM PC CP-862 (Hebrew)
                      035FH = 863 = IBM PC CP-863 (Canadian (French))
                      0360H = 864 = IBM PC CP-864 (Arabic)
                      0361H = 865 = IBM PC CP-865 (Nordic)
                      0362H = 866 = IBM PC CP-866 (Cyrillic (Russian))
                      0365H = 869 = IBM PC CP-869 (Greek (Modern))
                      036AH = 874 = Windows CP-874 (Thai)
                      03A4H = 932 = Windows CP-932 (Japanese Shift-JIS)
                      03A8H = 936 = Windows CP-936 (Chinese Simplified GBK)
                      03B5H = 949 = Windows CP-949 (Korean (Wansung))
                      03B6H = 950 = Windows CP-950 (Chinese Traditional BIG5)
                      04B0H = 1200 = UTF-16 (BIFF8)
                      04E2H = 1250 = Windows CP-1250 (Latin II) (Central European)
                      04E3H = 1251 = Windows CP-1251 (Cyrillic)
                      04E4H = 1252 = Windows CP-1252 (Latin I) (BIFF4-BIFF7)
                      04E5H = 1253 = Windows CP-1253 (Greek)
                      04E6H = 1254 = Windows CP-1254 (Turkish)
                      04E7H = 1255 = Windows CP-1255 (Hebrew)
                      04E8H = 1256 = Windows CP-1256 (Arabic)
                      04E9H = 1257 = Windows CP-1257 (Baltic)
                      04EAH = 1258 = Windows CP-1258 (Vietnamese)
                      0551H = 1361 = Windows CP-1361 (Korean (Johab))
                      2710H = 10000 = Apple Roman
                      8000H = 32768 = Apple Roman
                      8001H = 32769 = Windows CP-1252 (Latin I) (BIFF2-BIFF3)
    """
    _REC_ID = 0x0042
    UTF_16 = 0x04B0

    def __init__(self):
        self._rec_data = pack('<H', self.UTF_16)

class Window1Record(BiffRecord):
    """
    Offset Size Contents
    0      2    Horizontal position of the document window (in twips = 1/20 of a point)
    2      2    Vertical position of the document window (in twips = 1/20 of a point)
    4      2    Width of the document window (in twips = 1/20 of a point)
    6      2    Height of the document window (in twips = 1/20 of a point)
    8      2    Option flags:
                  Bits  Mask  Contents
                  0     0001H 0 = Window is visible 1 = Window is hidden
                  1     0002H 0 = Window is open 1 = Window is minimised
                  3     0008H 0 = Horizontal scroll bar hidden 1 = Horizontal scroll bar visible
                  4     0010H 0 = Vertical scroll bar hidden 1 = Vertical scroll bar visible
                  5     0020H 0 = Worksheet tab bar hidden 1 = Worksheet tab bar visible
    10     2    Index to active (displayed) worksheet
    12     2    Index of first visible tab in the worksheet tab bar
    14     2    Number of selected worksheets (highlighted in the worksheet tab bar)
    16     2    Width of worksheet tab bar (in 1/1000 of window width). The remaining space is used by the
                horizontal scrollbar.
    """
    _REC_ID = 0x003D
    # flags

    def __init__(self,
                 hpos_twips, vpos_twips,
                 width_twips, height_twips,
                 flags,
                 active_sheet,
                 first_tab_index, selected_tabs, tab_width):
        self._rec_data = pack('<9H', hpos_twips, vpos_twips,
                                      width_twips, height_twips,
                                      flags,
                                      active_sheet,
                                      first_tab_index, selected_tabs, tab_width)

class FontRecord(BiffRecord):
    """
    WARNING
        The font with index 4 is omitted in all BIFF versions.
        This means the first four fonts have zero-based indexes, and
        the fifth font and all following fonts are referenced with one-based
        indexes.

    Offset Size Contents
    0      2    Height of the font (in twips = 1/20 of a point)
    2      2    Option flags:
                  Bit Mask    Contents
                  0   0001H   1 = Characters are bold (redundant, see below)
                  1   0002H   1 = Characters are italic
                  2   0004H   1 = Characters are underlined (redundant, see below)
                  3   0008H   1 = Characters are struck out
                        0010H 1 = Outline
                        0020H  1 = Shadow
    4     2     Colour index
    6     2     Font weight (100-1000).
                Standard values are 0190H (400) for normal text and 02BCH
                (700) for bold text.
    8     2     Escapement type:
                  0000H = None
                  0001H = Superscript
                  0002H = Subscript
    10    1     Underline type:
                  00H = None
                  01H = Single
                  21H = Single accounting
                  02H = Double
                  22H = Double accounting
    11    1     Font family:
                  00H = None (unknown or don't care)
                  01H = Roman (variable width, serifed)
                  02H = Swiss (variable width, sans-serifed)
                  03H = Modern (fixed width, serifed or sans-serifed)
                  04H = Script (cursive)
                  05H = Decorative (specialised, i.e. Old English, Fraktur)
    12    1     Character set:
                  00H = 0 = ANSI Latin
                  01H = 1 = System default
                  02H = 2 = Symbol
                  4DH = 77 = Apple Roman
                  80H = 128 = ANSI Japanese Shift-JIS
                  81H = 129 = ANSI Korean (Hangul)
                  82H = 130 = ANSI Korean (Johab)
                  86H = 134 = ANSI Chinese Simplified GBK
                  88H = 136 = ANSI Chinese Traditional BIG5
                  A1H = 161 = ANSI Greek
                  A2H = 162 = ANSI Turkish
                  A3H = 163 = ANSI Vietnamese
                  B1H = 177 = ANSI Hebrew
                  B2H = 178 = ANSI Arabic
                  BAH = 186 = ANSI Baltic
                  CCH = 204 = ANSI Cyrillic
                  DEH = 222 = ANSI Thai
                  EEH = 238 = ANSI Latin II (Central European)
                  FFH = 255 = OEM Latin I
    13    1     Not used
    14    var.  Font name:
                  BIFF5/BIFF7: Byte string, 8-bit string length
                  BIFF8: Unicode string, 8-bit string length
    The boldness and underline flags are still set in the options field,
    but not used on reading the font. Font weight and underline type
    are specified in separate fields instead.
    """
    _REC_ID = 0x0031

    def __init__(self,
                    height, options, colour_index, weight, escapement,
                    underline, family, charset,
                    name):
        uname = upack1(name)
        uname_len = len(uname)

        self._rec_data = pack('<5H4B%ds' % uname_len, height, options, colour_index, weight, escapement,
                                                underline, family, charset, 0x00,
                                                uname)

class NumberFormatRecord(BiffRecord):
    """
    Record FORMAT, BIFF8:
    Offset  Size    Contents
    0       2       Format index used in other records
    2       var.    Number format string (Unicode string, 16-bit string length)

    From  BIFF5  on,  the built-in number formats will be omitted. The built-in
    formats  are  dependent  on  the current regional settings of the operating
    system.  The following table shows which number formats are used by default
    in  a  US-English  environment.  All indexes from 0 to 163 are reserved for
    built-in formats. The first user-defined format starts at 164.

    The built-in number formats, BIFF5-BIFF8

    Index   Type        Format string
    0       General     General
    1       Decimal     0
    2       Decimal     0.00
    3       Decimal     #,##0
    4       Decimal     #,##0.00
    5       Currency    "$"#,##0_);("$"#,##
    6       Currency    "$"#,##0_);[Red]("$"#,##
    7       Currency    "$"#,##0.00_);("$"#,##
    8       Currency    "$"#,##0.00_);[Red]("$"#,##
    9       Percent     0%
    10      Percent     0.00%
    11      Scientific  0.00E+00
    12      Fraction    # ?/?
    13      Fraction    # ??/??
    14      Date        M/D/YY
    15      Date        D-MMM-YY
    16      Date        D-MMM
    17      Date        MMM-YY
    18      Time        h:mm AM/PM
    19      Time        h:mm:ss AM/PM
    20      Time        h:mm
    21      Time        h:mm:ss
    22      Date/Time   M/D/YY h:mm
    37      Account     _(#,##0_);(#,##0)
    38      Account     _(#,##0_);[Red](#,##0)
    39      Account     _(#,##0.00_);(#,##0.00)
    40      Account     _(#,##0.00_);[Red](#,##0.00)
    41      Currency    _("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)
    42      Currency    _(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)
    43      Currency    _("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)
    44      Currency    _(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)
    45      Time        mm:ss
    46      Time        [h]:mm:ss
    47      Time        mm:ss.0
    48      Scientific  ##0.0E+0
    49      Text        @
    """
    _REC_ID = 0x041E

    def __init__(self, idx, fmtstr):
        ufmtstr = upack2(fmtstr)
        ufmtstr_len = len(ufmtstr)

        self._rec_data = pack('<H%ds' % ufmtstr_len, idx, ufmtstr)


class XFRecord(BiffRecord):
    """
    XF Substructures
    -------------------------------------------------------------------------
    XF_TYPE_PROT  XF Type and Cell Protection (3 Bits), BIFF3-BIFF8
    These 3 bits are part of a specific data byte.
    Bit Mask    Contents
    0   01H     1 = Cell is locked
    1   02H     1 = Formula is hidden
    2   04H     0 = Cell XF; 1 = Style XF

    XF_USED_ATTRIB   Attributes   Used  from  Parent  Style  XF  (6  Bits),
    BIFF3-BIFF8  Each  bit  describes  the  validity  of  a  specific group
    of  attributes.  In  cell XFs a cleared bit means the attributes of the
    parent  style XF are used (but only if the attributes are valid there),
    a  set  bit  means  the  attributes  of  this XF are used. In style XFs
    a cleared bit means the attribute setting is valid, a set bit means the
    attribute should be ignored.
    Bit Mask    Contents
    0   01H     Flag for number format
    1   02H     Flag for font
    2   04H     Flag for horizontal and vertical alignment, text wrap, indentation, orientation, rotation, and
                text direction
    3   08H     Flag for border lines
    4   10H     Flag for background area style
    5   20H     Flag for cell protection (cell locked and formula hidden)

    XF_HOR_ALIGN  Horizontal Alignment (3 Bits), BIFF2-BIFF8 The horizontal
    alignment consists of 3 bits and is part of a specific data byte.
    Value   Horizontal alignment
    00H     General
    01H     Left
    02H     Centred
    03H     Right
    04H     Filled
    05H     Justified (BIFF4-BIFF8X)
    06H     Centred across selection (BIFF4-BIFF8X)
    07H     Distributed (BIFF8X)

    XF_VERT_ALIGN Vertical Alignment (2 or 3 Bits), BIFF4-BIFF8
    The vertical alignment consists of 2 bits (BIFF4) or 3 bits (BIFF5-BIFF8)
    and is part of a specific data byte. Vertical alignment is not available
    in BIFF2 and BIFF3.
    Value   Vertical alignment
    00H     Top
    01H     Centred
    02H     Bottom
    03H     Justified (BIFF5-BIFF8X)
    04H     Distributed (BIFF8X)

    XF_ORIENTATION  Text  Orientation  (2  Bits),  BIFF4-BIFF7  In the BIFF
    versions  BIFF4-BIFF7,  text  can  be  rotated  in  steps of 90 degrees
    or  stacked.  The  orientation  mode  consists of 2 bits and is part of
    a specific data byte. In BIFF8 a rotation angle occurs instead of these
    flags.
    Value   Text orientation
    00H     Not rotated
    01H     Letters are stacked top-to-bottom, but not rotated
    02H     Text is rotated 90 degrees counterclockwise
    03H     Text is rotated 90 degrees clockwise

    XF_ROTATION Text Rotation Angle (1 Byte), BIFF8
    Value   Text rotation
    0       Not rotated
    1-90    1 to 90 degrees counterclockwise
    91-180  1 to 90 degrees clockwise
    255     Letters are stacked top-to-bottom, but not rotated

    XF_BORDER_34  Cell  Border  Style  (4  Bytes), BIFF3-BIFF4 Cell borders
    contain a line style and a line colour for each line of the border.
    Bit     Mask        Contents
    2-0     00000007H   Top line style
    7-3     000000F8H   Colour index for top line colour
    10-8    00000700H   Left line style
    15-11   0000F800H   Colour index for left line colour
    18-16   00070000H   Bottom line style
    23-19   00F80000H   Colour index for bottom line colour
    26-24   07000000H   Right line style
    31-27   F8000000H   Colour index for right line colour

    XF_AREA_34  Cell  Background  Area  Style (2 Bytes), BIFF3-BIFF4 A cell
    background  area  style  contains  an area pattern and a foreground and
    background colour.
    Bit     Mask    Contents
    5-0     003FH   Fill pattern
    10-6    07C0H   Colour index for pattern colour
    15-11   F800H   Colour index for pattern background
 ---------------------------------------------------------------------------------------------
    Record XF, BIFF8:
    Offset      Size    Contents
    0           2       Index to FONT record
    2           2       Index to FORMAT record
    4           2       Bit     Mask    Contents
                        2-0     0007H   XF_TYPE_PROT . XF type, cell protection (see above)
                        15-4    FFF0H   Index to parent style XF (always FFFH in style XFs)
    6           1       Bit     Mask    Contents
                        2-0     07H     XF_HOR_ALIGN . Horizontal alignment (see above)
                        3       08H     1 = Text is wrapped at right border
                        6-4     70H     XF_VERT_ALIGN . Vertical alignment (see above)
    7           1       XF_ROTATION: Text rotation angle (see above)
    8           1       Bit     Mask    Contents
                        3-0     0FH     Indent level
                        4       10H     1 = Shrink content to fit into cell
                        5               merge
                        7-6     C0H     Text direction (BIFF8X only)
                                        00b = According to context
                                        01b = Left-to-right
                                        10b = Right-to-left
    9           1       Bit     Mask    Contents
                        7-2     FCH     XF_USED_ATTRIB . Used attributes (see above)
    10          4       Cell border lines and background area:
                        Bit     Mask      Contents
                        3-0     0000000FH Left line style
                        7-4     000000F0H Right line style
                        11-8    00000F00H Top line style
                        15-12   0000F000H Bottom line style
                        22-16   007F0000H Colour index for left line colour
                        29-23   3F800000H Colour index for right line colour
                        30      40000000H 1 = Diagonal line from top left to right bottom
                        31      80000000H 1 = Diagonal line from bottom left to right top
    14          4       Bit     Mask      Contents
                        6-0     0000007FH Colour index for top line colour
                        13-7    00003F80H Colour index for bottom line colour
                        20-14   001FC000H Colour index for diagonal line colour
                        24-21   01E00000H Diagonal line style
                        31-26   FC000000H Fill pattern
    18          2       Bit     Mask    Contents
                        6-0     007FH   Colour index for pattern colour
                        13-7    3F80H   Colour index for pattern background

    """
    _REC_ID = 0x00E0

    def __init__(self, xf, xftype='cell'):
        font_xf_idx, fmt_str_xf_idx, alignment, borders, pattern, protection = xf
        fnt = pack('<H', font_xf_idx)
        fmt = pack('<H', fmt_str_xf_idx)
        if xftype == 'cell':
            prt = pack('<H',
                ((protection.cell_locked    & 0x01) << 0) |
                ((protection.formula_hidden & 0x01) << 1)
            )
        else:
            prt = pack('<H', 0xFFF5)
        aln = pack('B',
            ((alignment.horz & 0x07) << 0) |
            ((alignment.wrap & 0x01) << 3) |
            ((alignment.vert & 0x07) << 4)
        )
        rot = pack('B', alignment.rota)
        txt = pack('B',
            ((alignment.inde & 0x0F) << 0) |
            ((alignment.shri & 0x01) << 4) |
            ((alignment.merg & 0x01) << 5) |
            ((alignment.dire & 0x03) << 6)
        )
        if xftype == 'cell':
            used_attr = pack('B', 0xF8)
        else:
            used_attr = pack('B', 0xF4)

        if borders.left == borders.NO_LINE:
            borders.left_colour = 0x00
        if borders.right == borders.NO_LINE:
            borders.right_colour = 0x00
        if borders.top == borders.NO_LINE:
            borders.top_colour = 0x00
        if borders.bottom == borders.NO_LINE:
            borders.bottom_colour = 0x00
        if borders.diag == borders.NO_LINE:
            borders.diag_colour = 0x00
        brd1 = pack('<L',
            ((borders.left          & 0x0F) << 0 ) |
            ((borders.right         & 0x0F) << 4 ) |
            ((borders.top           & 0x0F) << 8 ) |
            ((borders.bottom        & 0x0F) << 12) |
            ((borders.left_colour   & 0x7F) << 16) |
            ((borders.right_colour  & 0x7F) << 23) |
            ((borders.need_diag1    & 0x01) << 30) |
            ((borders.need_diag2    & 0x01) << 31)
        )
        brd2 = pack('<L',
            ((borders.top_colour    & 0x7F) << 0 ) |
            ((borders.bottom_colour & 0x7F) << 7 ) |
            ((borders.diag_colour   & 0x7F) << 14) |
            ((borders.diag          & 0x0F) << 21) |
            ((pattern.pattern       & 0x3F) << 26)
        )
        pat = pack('<H',
            ((pattern.pattern_fore_colour & 0x7F) << 0 ) |
            ((pattern.pattern_back_colour & 0x7F) << 7 )
        )
        self._rec_data = fnt + fmt + prt + \
                        aln + rot + txt + used_attr + \
                        brd1 + brd2 + \
                        pat

class StyleRecord(BiffRecord):
    """
    STYLE record for user-defined cell styles, BIFF3-BIFF8:
    Offset  Size    Contents
    0       2       Bit     Mask    Contents
                    11-0    0FFFH   Index to style XF record
                    15      8000H   Always 0 for user-defined styles
    2       var.    BIFF2-BIFF7: Non-empty byte string, 8-bit string length
                    BIFF8: Non-empty Unicode string, 16-bit string length
    STYLE record for built-in cell styles, BIFF3-BIFF8:
    Offset  Size    Contents
    0       2       Bit     Mask    Contents
                    11-0    0FFFH   Index to style XF record
                    15      8000H   Always 1 for built-in styles
    2       1       Identifier of the built-in cell style:
                        00H = Normal
                        01H = RowLevel_lv (see next field)
                        02H = ColLevel_lv (see next field)
                        03H = Comma
                        04H = Currency
                        05H = Percent
                        06H = Comma [0] (BIFF4-BIFF8)
                        07H = Currency [0] (BIFF4-BIFF8)
                        08H = Hyperlink (BIFF8)
                        09H = Followed Hyperlink (BIFF8)
    3       1       Level for RowLevel or ColLevel style
                    (zero-based, lv), FFH otherwise
    The  RowLevel  and  ColLevel  styles specify the formatting of subtotal
    cells  in  a specific outline level. The level is specified by the last
    field  in the STYLE record. Valid values are 0-6 for the outline levels
    1-7.
    """
    _REC_ID = 0x0293

    def __init__(self):
        self._rec_data = pack('<HBB', 0x8000, 0x00, 0xFF)
        # TODO: implement user-defined styles???


class PaletteRecord(BiffRecord):
    """
    This  record  contains  the  definition  of  all  user-defined  colours
    available for cell and object formatting.

    Record PALETTE, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       Number of following colours (nm). Contains 16 in BIFF3-BIFF4 and 56 in BIFF5-BIFF8.
    2       4*nm    List of nm RGB colours

    The following table shows how colour indexes are used in other records:

    Colour index    Resulting colour or internal list index
    00H             Built-in Black (R = 00H, G = 00H, B = 00H)
    01H             Built-in White (R = FFH, G = FFH, B = FFH)
    02H             Built-in Red (R = FFH, G = 00H, B = 00H)
    03H             Built-in Green (R = 00H, G = FFH, B = 00H)
    04H             Built-in Blue (R = 00H, G = 00H, B = FFH)
    05H             Built-in Yellow (R = FFH, G = FFH, B = 00H)
    06H             Built-in Magenta (R = FFH, G = 00H, B = FFH)
    07H             Built-in Cyan (R = 00H, G = FFH, B = FFH)
    08H             First user-defined colour from the PALETTE record (entry 0 from record colour list)
    .........................

    17H (BIFF3-BIFF4) Last user-defined colour from the PALETTE record (entry 15 or 55 from record colour list)
    3FH (BIFF5-BIFF8)

    18H (BIFF3-BIFF4) System window text colour for border lines (used in records XF, CF, and
    40H (BIFF5-BIFF8) WINDOW2 (BIFF8 only))

    19H (BIFF3-BIFF4) System window background colour for pattern background (used in records XF, and CF)
    41H (BIFF5-BIFF8)

    43H             System face colour (dialogue background colour)
    4DH             System window text colour for chart border lines
    4EH             System window background colour for chart areas
    4FH             Automatic colour for chart border lines (seems to be always Black)
    50H             System ToolTip background colour (used in note objects)
    51H             System ToolTip text colour (used in note objects)
    7FFFH           System window text colour for fonts (used in records FONT, EFONT, and CF)

    """
    _REC_ID = 0x0092


class BoundSheetRecord(BiffRecord):
    """
    This  record  is  located  in  the workbook globals area and represents
    a  sheet  inside  of  the  workbook. For each sheet a BOUNDSHEET record
    is  written.  It  stores  the sheet name and a stream offset to the BOF
    record    within   the   workbook   stream.  The  record  is also known
    as BUNDLESHEET.

    Record BOUNDSHEET, BIFF5-BIFF8:
    Offset  Size    Contents
    0       4       Absolute stream position of the BOF record of the sheet represented by this record. This
                    field is never encrypted in protected files.
    4       1       Visibility:
                        00H = Visible
                        01H = Hidden
                        02H = Strong hidden
    5       1       Sheet type:
                        00H = Worksheet
                        02H = Chart
                        06H = Visual Basic module
    6       var.    Sheet name:
                        BIFF5/BIFF7: Byte string, 8-bit string length
                        BIFF8: Unicode string, 8-bit string length
    """
    _REC_ID = 0x0085

    def __init__(self, stream_pos, visibility, sheetname, encoding='ascii'):
        usheetname = upack1(sheetname, encoding)
        uusheetname_len = len(usheetname)

        self._rec_data = pack('<LBB%ds' % uusheetname_len, stream_pos, visibility, 0x00, usheetname)


class ContinueRecord(BiffRecord):
    """
    Whenever  the content of a record exceeds the given limits (see table),
    the  record  must  be  split.  Several  CONTINUE records containing the
    additional data are added after the parent record.

    BIFF version    Maximum data size of a record
    BIFF2-BIFF7     2080 bytes (2084 bytes including record header)
    BIFF8           8224 bytes (8228 bytes including record header) (0x2020)

    Record CONTINUE, BIFF2-BIFF8:
    Offset  Size    Contents
    0       var.    Data continuation of the previous record

    Unicode  strings  are  split in a special way. At the beginning of each
    CONTINUE  record  the option flags byte is repeated. Only the character
    size  flag  will  be set in this flags byte, the Rich-Text flag and the
    Far-East  flag  are set to zero. In each CONTINUE record it is possible
    that  the  character  size  changes  from  8-bit  characters  to 16-bit
    characters and vice versa.

    Never  a  Unicode  string  is  split  until  and  including  the  first
    character.  That means, all header fields (string length, option flags,
    optional Rich-Text size, and optional Far-East data size) and the first
    character  of  the string have to occur together in the leading record,
    or  have  to  be  moved completely into the CONTINUE record. Formatting
    runs cannot be split between their components (character index and FONT
    record  index).  If  a string is split between two formatting runs, the
    option flags field will not be repeated in the CONTINUE record.
    """
    _REC_ID = 0x003C


class SSTRecord(BiffRecord):
    """
    This  record  contains  a  list  of  all  strings  used anywhere in the
    workbook.  Each string occurs only once. The workbook uses indexes into
    the list to reference the strings.

    Record SST, BIFF8:
    Offset  Size    Contents
    0       4       Total number of strings in the workbook (see below)
    4       4       Number of following strings (nm)
    8       var.    List of nm Unicode strings, 16-bit string length

    The  first  field  of  the  SST  record  counts  the  total  occurrence
    of  strings  in  the  workbook.  For  instance,  the string AAA is used
    3  times  and  the string BBB is used 2 times. The first field contains
    5 and the second field contains 2, followed by the two strings.
    """
    _REC_ID = 0x00FC


class ExtSSTRecord(BiffRecord):
    """
    This  record  occurs  in  conjunction  with  the SST record. It is used
    by  Excel  to create a hash table with stream offsets to the SST record
    to optimise string search operations. Excel may not shorten this record
    if  strings  are deleted from the shared string table, so the last part
    might  contain  invalid  data. The stream indexes in this record divide
    the SST into portions containing a constant number of strings.

    Record EXTSST, BIFF8:

    Offset  Size    Contents
    0       2       Number of strings in a portion, this number is >=8
    2       var.    List of OFFSET structures for all portions. Each OFFSET contains the following data:
                        Offset Size Contents
                        0       4   Absolute stream position of first string of the portion
                        4       2   Position of first string of the portion inside of current record,
                                    including record header. This counter restarts at zero, if the SST
                                    record is continued with a CONTINUE record.
                        6       2   Not used
    """
    _REC_ID = 0x00FF

    def __init__(self, sst_stream_pos, str_placement, portions_len):
        extsst = {}
        abs_stream_pos = sst_stream_pos
        str_counter = 0
        portion_counter = 0
        while str_counter < len(str_placement):
            str_chunk_num, pos_in_chunk = str_placement[str_counter]
            if str_chunk_num != portion_counter:
                portion_counter = str_chunk_num
                abs_stream_pos += portions_len[portion_counter-1]
                #print hex(abs_stream_pos)
            str_stream_pos = abs_stream_pos + pos_in_chunk + 4 # header
            extsst[str_counter] = (pos_in_chunk, str_stream_pos)
            str_counter += 1

        exsst_str_count_delta = max(8, len(str_placement)*8/0x2000) # maybe smth else?
        self._rec_data = pack('<H', exsst_str_count_delta)
        str_counter = 0
        while str_counter < len(str_placement):
            self._rec_data += pack('<IHH', extsst[str_counter][1], extsst[str_counter][0], 0)
            str_counter += exsst_str_count_delta

class DimensionsRecord(BiffRecord):
    """
    Record DIMENSIONS, BIFF8:

    Offset  Size    Contents
    0       4       Index to first used row
    4       4       Index to last used row, increased by 1
    8       2       Index to first used column
    10      2       Index to last used column, increased by 1
    12      2       Not used
    """
    _REC_ID = 0x0200
    def __init__(self, first_used_row, last_used_row, first_used_col, last_used_col):
        if first_used_row > last_used_row or first_used_col > last_used_col:
            # Special case: empty worksheet
            first_used_row = first_used_col = 0
            last_used_row = last_used_col = -1
        self._rec_data = pack('<2L3H',
            first_used_row, last_used_row + 1,
            first_used_col, last_used_col + 1,
            0x00)


class Window2Record(BiffRecord):
    """
    Record WINDOW2, BIFF8:

    Offset  Size Contents
    0       2 Option flags (see below)
    2       2 Index to first visible row
    4       2 Index to first visible column
    6       2 Colour index of grid line colour. Note that in BIFF2-BIFF7 an RGB colour is
                written instead.
    8       2 Not used
    10      2 Cached magnification factor in page break preview (in percent); 0 = Default (60%)
    12      2 Cached magnification factor in normal view (in percent); 0 = Default (100%)
    14      4 Not used

    In  BIFF8  this record stores used magnification factors for page break
    preview  and  normal  view.  These  values  are  used  to  restore  the
    magnification,  when the view is changed. The real magnification of the
    currently  active  view  is  stored  in the SCL record. The type of the
    active view is stored in the option flags field (see below).

     0 0001H 0 = Show formula results 1 = Show formulas
     1 0002H 0 = Do not show grid lines 1 = Show grid lines
     2 0004H 0 = Do not show sheet headers 1 = Show sheet headers
     3 0008H 0 = Panes are not frozen 1 = Panes are frozen (freeze)
     4 0010H 0 = Show zero values as empty cells 1 = Show zero values
     5 0020H 0 = Manual grid line colour 1 = Automatic grid line colour
     6 0040H 0 = Columns from left to right 1 = Columns from right to left
     7 0080H 0 = Do not show outline symbols 1 = Show outline symbols
     8 0100H 0 = Keep splits if pane freeze is removed 1 = Remove splits if pane freeze is removed
     9 0200H 0 = Sheet not selected 1 = Sheet selected (BIFF5-BIFF8)
    10 0400H 0 = Sheet not visible 1 = Sheet visible (BIFF5-BIFF8)
    11 0800H 0 = Show in normal view 1 = Show in page break preview (BIFF8)

    The freeze flag specifies, if a following PANE record describes unfrozen or frozen panes.

    *** This class appends the optional SCL record ***

    Record SCL, BIFF4-BIFF8:

    This record stores the magnification of the active view of the current worksheet.
    In BIFF8 this can be either the normal view or the page break preview.
    This is determined in the WINDOW2 record. The SCL record is part of the
    Sheet View Settings Block.

    Offset  Size    Contents
    0       2       Numerator of the view magnification fraction (num)
    2       2       Denumerator [denominator] of the view magnification fraction (den)
    The magnification is stored as reduced fraction. The magnification results from num/den.

    SJM note: Excel expresses (e.g.) 25% in reduced form i.e. 1/4. Reason unknown. This code
    writes 25/100, and Excel is happy with that.

    """
    _REC_ID = 0x023E

    def __init__(self, options, first_visible_row, first_visible_col,
        grid_colour, preview_magn, normal_magn, scl_magn):
        self._rec_data = pack('<7HL', options,
                                    first_visible_row, first_visible_col,
                                    grid_colour,
                                    0x00,
                                    preview_magn, normal_magn,
                                    0x00)
        if scl_magn:
            self._scl_rec = pack('<4H', 0x00A0, 4, scl_magn, 100)
        else:
            self._scl_rec = b''

    def get(self):
        return self.get_rec_header() + self._rec_data + self._scl_rec


class PanesRecord(BiffRecord):
    """
    This record stores the position of window panes. It is part of the Sheet
    View Settings Block. If the sheet does not contain any splits, this
    record will not occur.
    A sheet can be split in two different ways, with unfrozen panes or with
    frozen panes. A flag in the WINDOW2 record specifies, if the panes are
    frozen, which affects the contents of this record.

    Record PANE, BIFF2-BIFF8:
    Offset      Size        Contents
    0           2           Position of the vertical split
                            (px, 0 = No vertical split):
                            Unfrozen pane: Width of the left pane(s)
                            (in twips = 1/20 of a point)
                            Frozen pane: Number of visible
                            columns in left pane(s)
    2           2           Position of the horizontal split
                            (py, 0 = No horizontal split):
                            Unfrozen pane: Height of the top pane(s)
                            (in twips = 1/20 of a point)
                            Frozen pane: Number of visible
                            rows in top pane(s)
    4           2           Index to first visible row
                            in bottom pane(s)
    6           2           Index to first visible column
                            in right pane(s)
    8           1           Identifier of pane with active
                            cell cursor
    [9]         1           Not used (BIFF5-BIFF8 only, not written
                            in BIFF2-BIFF4)

    If the panes are frozen, pane0 is always active, regardless
    of the cursor position. The correct identifiers for all possible
    combinations of visible panes are shown in the following pictures.

    px = 0, py = 0                  px = 0, py > 0
    --------------------------      ------------|-------------
    |                        |      |                        |
    |                        |      |           3            |
    |                        |      |                        |
    -           3            -      --------------------------
    |                        |      |                        |
    |                        |      |           2            |
    |                        |      |                        |
    --------------------------      ------------|-------------

    px > 0, py = 0                  px > 0, py > 0
    ------------|-------------      ------------|-------------
    |           |            |      |           |            |
    |           |            |      |     3     |      2     |
    |           |            |      |           |            |
    -     3     |      1     -      --------------------------
    |           |            |      |           |            |
    |           |            |      |     1     |      0     |
    |           |            |      |           |            |
    ------------|-------------      ------------|-------------
    """
    _REC_ID = 0x0041
    def __init__(self, px, py, first_row_bottom, first_col_right, active_pane):
        self._rec_data = pack('<5H', int(px), int(py), int(first_row_bottom),
                              int(first_col_right), int(active_pane))


class RowRecord(BiffRecord):
    """
    This  record  contains  the properties of a single row in a sheet. Rows
    and cells in a sheet are divided into blocks of 32 rows.

    Record ROW, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       Index of this row
    2       2       Index to column of the first cell which is described by a cell record
    4       2       Index to column of the last cell which is described by a cell record,
                    increased by 1
    6       2       Bit     Mask    Contents
                    14-0    7FFFH   Height of the row, in twips = 1/20 of a point
                    15      8000H   0 = Row has custom height; 1 = Row has default height
    8       2       Not used
    10      2       In BIFF3-BIFF4 this field contains a relative offset
                    to calculate stream position of the first cell record
                    for this row. In BIFF5-BIFF8 this field is not used
                    anymore, but the DBCELL record instead.
    12      4       Option flags and default row formatting:
                    Bit     Mask        Contents
                    2-0     00000007H   Outline level of the row
                    4       00000010H   1 = Outline group starts or ends here (depending
                                        on where the outline buttons are located,
                                        see WSBOOL record), and is collapsed
                    5       00000020H   1 = Row is hidden (manually, or by a filter or outline group)
                    6       00000040H   1 = Row height and default font height do not match
                    7       00000080H   1 = Row has explicit default format (fl)
                    8       00000100H   Always 1
                    27-16   0FFF0000H   If fl=1: Index to default XF record
                    28      10000000H   1 = Additional space above the row. This flag is set,
                                        if the upper border of at least one cell in this row
                                        or if the lower border of at least one cell in the row
                                        above is formatted with a thick line style.
                                        Thin and medium line styles are not taken into account.
                    29      20000000H   1 = Additional space below the row. This flag is set,
                                        if the lower border of at least one cell in this row
                                        or if the upper border of at least one cell in the row
                                        below is formatted with a medium or thick line style.
                                        Thin line styles are not taken into account.
    """

    _REC_ID = 0x0208

    def __init__(self, index, first_col, last_col, height_options, options):
        self._rec_data = pack('<6HL', index, first_col, last_col + 1,
                                        height_options,
                                        0x00, 0x00,
                                        options)

class LabelSSTRecord(BiffRecord):
    """
    This record represents a cell that contains a string. It replaces the
    LABEL record and RSTRING record used in BIFF2-BIFF7.
    """
    _REC_ID = 0x00FD

    def __init__(self, row, col, xf_idx, sst_idx):
        self._rec_data = pack('<3HL', row, col, xf_idx, sst_idx)


class MergedCellsRecord(BiffRecord):
    """
    This record contains all merged cell ranges of the current sheet.

    Record MERGEDCELLS, BIFF8:

    Offset  Size    Contents
    0       var.    Cell range address list with all merged ranges

    ------------------------------------------------------------------

    A cell range address list consists of a field with the number of ranges
    and the list of the range addresses.

    Cell range address list, BIFF8:

    Offset  Size            Contents
    0       2               Number of following cell range addresses (nm)
    2       8*nm            List of nm cell range addresses

    ---------------------------------------------------------------------
    Cell range address, BIFF8:

    Offset  Size    Contents
    0       2       Index to first row
    2       2       Index to last row
    4       2       Index to first column
    6       2       Index to last column

    """
    _REC_ID = 0x00E5

    def __init__(self, merged_list):
        i = len(merged_list) - 1
        while i >= 0:
            j = 0
            merged = b''
            while (i >= 0) and (j < 0x403):
                r1, r2, c1, c2 = merged_list[i]
                merged += pack('<4H', r1, r2, c1, c2)
                i -= 1
                j += 1
            self._rec_data += pack('<3H', self._REC_ID, len(merged) + 2, j) + \
                                    merged

    # for some reason Excel doesn't use CONTINUE
    def get(self):
        return self._rec_data

class MulBlankRecord(BiffRecord):
    """
    This  record  represents  a  cell  range  of empty cells. All cells are
    located in the same row.

    Record MULBLANK, BIFF5-BIFF8:

    Offset  Size    Contents
    0       2       Index to row
    2       2       Index to first column (fc)
    4       2*nc    List of nc=lc-fc+1 16-bit indexes to XF records
    4+2*nc  2       Index to last column (lc)
    """
    _REC_ID = 0x00BE

    def __init__(self, row, first_col, last_col, xf_index):
        blanks_count = last_col-first_col+1
        self._rec_data = pack('%dH' % blanks_count, *([xf_index]*blanks_count))
        self._rec_data = pack('<2H', row, first_col) +  self._rec_data + pack('<H',  last_col)


class BlankRecord(BiffRecord):
    """
    This  record  represents  an empty cell.

    Record BLANK, BIFF5-BIFF8:

    Offset  Size    Contents
    0       2       Index to row
    2       2       Index to first column (fc)
    4       2       indexes to XF record
    """
    _REC_ID = 0x0201

    def __init__(self, row, col, xf_index):
        self._rec_data = pack('<3H', row, col, xf_index)


class RKRecord(BiffRecord):
    """
    This record represents a cell that contains an RK value (encoded integer or
    floating-point value). If a floating-point value cannot be encoded to an RK value,
    a NUMBER record will be written.
    """
    _REC_ID = 0x027E

    def __init__(self, row, col, xf_index, rk_encoded):
        self._rec_data = pack('<3Hi', row, col, xf_index, rk_encoded)


class NumberRecord(BiffRecord):
    """
    This record represents a cell that contains an IEEE-754 floating-point value.
    """
    _REC_ID = 0x0203

    def __init__(self, row, col, xf_index, number):
        self._rec_data = pack('<3Hd', row, col, xf_index, number)

class BoolErrRecord(BiffRecord):
    """
    This record represents a cell that contains a boolean or error value.
    """
    _REC_ID = 0x0205

    def __init__(self, row, col, xf_index, number, is_error):
        self._rec_data = pack('<3HBB', row, col, xf_index, number, is_error)


class FormulaRecord(BiffRecord):
    """
    Offset Size Contents
    0      2    Index to row
    2      2    Index to column
    4      2    Index to XF record
    6      8    Result of the formula
    14     2    Option flags:
                Bit Mask    Contents
                0   0001H   1 = Recalculate always
                1   0002H   1 = Calculate on open
                3   0008H   1 = Part of a shared formula
    16     4    Not used
    20     var. Formula data (RPN token array)

    """
    _REC_ID = 0x0006

    def __init__(self, row, col, xf_index, rpn, calc_flags=0):
        self._rec_data = pack('<3HQHL', row, col, xf_index, 0xFFFF000000000003, calc_flags & 3, 0) + rpn


class GutsRecord(BiffRecord):
    """
    This record contains information about the layout of outline symbols.

    Record GUTS, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       Width of the area to display row outlines (left of the sheet), in pixel
    2       2       Height of the area to display column outlines (above the sheet), in pixel
    4       2       Number of visible row outline levels (used row levels + 1; or 0, if not used)
    6       2       Number of visible column outline levels (used column levels + 1; or 0, if not used)

    """

    _REC_ID = 0x0080

    def __init__(self, row_gut_width, col_gut_height, row_visible_levels, col_visible_levels):
        self._rec_data = pack('<4H', row_gut_width, col_gut_height, row_visible_levels, col_visible_levels)

class WSBoolRecord(BiffRecord):
    """
    This  record stores a 16 bit value with Boolean options for the current
    sheet.  From BIFF5 on the "Save external linked values" option is moved
    to the record BOOKBOOL.

    Option flags of record WSBOOL, BIFF3-BIFF8:

    Bit     Mask    Contents
    0       0001H   0 = Do not show automatic page breaks
                    1 = Show automatic page breaks
    4       0010H   0 = Standard sheet
                    1 = Dialogue sheet (BIFF5-BIFF8)
    5       0020H   0 = No automatic styles in outlines
                    1 = Apply automatic styles to outlines
    6       0040H   0 = Outline buttons above outline group
                    1 = Outline buttons below outline group
    7       0080H   0 = Outline buttons left of outline group
                    1 = Outline buttons right of outline group
    8       0100H   0 = Scale printout in percent
                    1 = Fit printout to number of pages
    9       0200H   0 = Save external linked values (BIFF3?BIFF4 only)
                    1 = Do not save external linked values (BIFF3?BIFF4 only)
    10      0400H   0 = Do not show row outline symbols
                    1 = Show row outline symbols
    11      0800H   0 = Do not show column outline symbols
                    1 = Show column outline symbols
    13-12   3000H   These flags specify the arrangement of windows.
                    They are stored in BIFF4 only.
                    00 = Arrange windows tiled
                    01 = Arrange windows horizontal
                    10 = Arrange windows vertical112 = Arrange windows cascaded
    The following flags are valid for BIFF4-BIFF8 only:
    14      4000H   0 = Standard expression evaluation
                    1 = Alternative expression evaluation
    15      8000H   0 = Standard formula entries
                    1 = Alternative formula entries

    """
    _REC_ID = 0x0081

    def __init__(self, options):
        self._rec_data = pack('<H', options)

class ColInfoRecord(BiffRecord):
    """
    This record specifies the width for a given range of columns.
    If a column does not have a corresponding COLINFO record,
    the width specified in the record STANDARDWIDTH is used. If
    this record is also not present, the contents of the record
    DEFCOLWIDTH is used instead.
    This record also specifies a default XF record to use for
    cells in the columns that are not described by any cell record
    (which contain the XF index for that cell). Additionally,
    the option flags field contains hidden, outline, and collapsed
    options applied at the columns.

    Record COLINFO, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       Index to first column in the range
    2       2       Index to last column in the range
    4       2       Width of the columns in 1/256 of the width of the zero character, using default font
                    (first FONT record in the file)
    6       2       Index to XF record for default column formatting
    8       2       Option flags:
                    Bits    Mask    Contents
                    0       0001H   1 = Columns are hidden
                    10-8    0700H   Outline level of the columns (0 = no outline)
                    12      1000H   1 = Columns are collapsed
    10      2       Not used

    """
    _REC_ID = 0x007D

    def __init__(self, first_col, last_col, width, xf_index, options):
        self._rec_data = pack('<6H', first_col, last_col, width, xf_index, options, 0)

class CalcModeRecord(BiffRecord):
    """
    This record is part of the Calculation Settings Block.
    It specifies whether to calculate formulas manually,
    automatically or automatically except for multiple table operations.

    Record CALCMODE, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       FFFFH = automatic except for multiple table operations
                    0000H = manually
                    0001H = automatically (default)
    """
    _REC_ID = 0x000D

    def __init__(self, calc_mode):
        self._rec_data = pack('<h', calc_mode)


class CalcCountRecord(BiffRecord):
    """
    This record is part of the Calculation Settings Block. It specifies the maximum
    number of times the formulas should be iteratively calculated. This is a fail-safe
    against mutually recursive formulas locking up a spreadsheet application.

    Record CALCCOUNT, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       Maximum number of iterations allowed in circular references
    """

    _REC_ID = 0x000C

    def __init__(self, calc_count):
        self._rec_data = pack('<H', calc_count)

class RefModeRecord(BiffRecord):
    """
    This record is part of the Calculation Settings Block.
    It stores which method is used to show cell addresses in formulas.
    The RC mode uses numeric indexes for rows and columns,
    i.e. R(1)C(-1), or R1C1:R2C2.
    The A1 mode uses characters for columns and numbers for rows,
    i.e. B1, or $A$1:$B$2.

    Record REFMODE, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       0 = RC mode; 1 = A1 mode

    """
    _REC_ID = 0x00F

    def __init__(self, ref_mode):
        self._rec_data = pack('<H', ref_mode)

class IterationRecord(BiffRecord):
    """
    This record is part of the Calculation Settings Block.
    It stores if iterations are allowed while calculating recursive formulas.

    Record ITERATION, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       0 = Iterations off; 1 = Iterations on
    """
    _REC_ID = 0x011

    def __init__(self, iterations_on):
        self._rec_data = pack('<H', iterations_on)

class DeltaRecord(BiffRecord):
    """
    This record is part of the Calculation Settings Block.
    It stores the maximum change of the result to exit an iteration.

    Record DELTA, BIFF2-BIFF8:

    Offset  Size    Contents
    0       8       Maximum change in iteration
                    (IEEE 754 floating-point value,
                     64bit double precision)
    """
    _REC_ID = 0x010

    def __init__(self, delta):
        self._rec_data = pack('<d', delta)

class SaveRecalcRecord(BiffRecord):
    """
    This record is part of the Calculation Settings Block.
    It contains the Recalculate before save option in
    Excel's calculation settings dialogue.

    Record SAVERECALC, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       0 = Do not recalculate;
                    1 = Recalculate before saving the document

    """
    _REC_ID = 0x05F

    def __init__(self, recalc):
        self._rec_data = pack('<H', recalc)

class PrintHeadersRecord(BiffRecord):
    """
    This record stores if the row and column headers
    (the areas with row numbers and column letters) will be printed.

    Record PRINTHEADERS, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       0 = Do not print row/column headers;
                    1 = Print row/column headers
    """
    _REC_ID = 0x02A

    def __init__(self, print_headers):
        self._rec_data = pack('<H', print_headers)


class PrintGridLinesRecord(BiffRecord):
    """
    This record stores if sheet grid lines will be printed.

    Record PRINTGRIDLINES, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       0 = Do not print sheet grid lines;
                    1 = Print sheet grid lines

    """
    _REC_ID = 0x02B

    def __init__(self, print_grid):
        self._rec_data = pack('<H', print_grid)


class GridSetRecord(BiffRecord):
    """
    This record specifies if the option to print sheet grid lines
    (record PRINTGRIDLINES) has ever been changed.

    Record GRIDSET, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       0 = Print grid lines option never changed
                    1 = Print grid lines option changed
    """
    _REC_ID = 0x082

    def __init__(self, print_grid_changed):
        self._rec_data = pack('<H', print_grid_changed)


class DefaultRowHeightRecord(BiffRecord):
    """
    This record specifies the default height and default flags
    for rows that do not have a corresponding ROW record.

    Record DEFAULTROWHEIGHT, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       Option flags:
                    Bit Mask    Contents
                    0   0001H   1 = Row height and default font height do not match
                    1   0002H   1 = Row is hidden
                    2   0004H   1 = Additional space above the row
                    3   0008H   1 = Additional space below the row
    2       2       Default height for unused rows, in twips = 1/20 of a point

    """
    _REC_ID = 0x0225

    def __init__(self, options, def_height):
        self._rec_data = pack('<2H', options, def_height)


class DefColWidthRecord(BiffRecord):
    """
    This record specifies the default column width for columns that
    do not have a specific width set using the record COLINFO or COLWIDTH.
    This record has no effect, if a STANDARDWIDTH record is present in the file.

    Record DEFCOLWIDTH, BIFF2-BIFF8:

    Offset  Size    Contents
    0       2       Column width in characters, using the width of the zero
                    character from default font (first FONT record in the file)
    """
    _REC_ID = 0x0055

    def __init__(self, def_width):
        self._rec_data = pack('<H', options, def_width)

class HorizontalPageBreaksRecord(BiffRecord):
    """
    This  record  is  part  of  the  Page  Settings  Block. It contains all
    horizontal manual page breaks.

    Record HORIZONTALPAGEBREAKS, BIFF8:
    Offset  Size  Contents
    0       2     Number of following row index structures (nm)
    2       6nm   List of nm row index structures. Each row index
                  structure contains:
                    Offset  Size    Contents
                    0       2       Index to first row below the page break
                    2       2       Index to first column of this page break
                    4       2       Index to last column of this page break

    The row indexes in the lists must be ordered ascending.
    If in BIFF8 a row contains several page breaks, they must be ordered
    ascending by start column index.
    """
    _REC_ID = 0x001B

    def __init__(self, breaks_list):
        self._rec_data = pack('<H', len(breaks_list))
        for r, c1, c2 in breaks_list:
            self._rec_data += pack('<3H', r, c1, c2)

class VerticalPageBreaksRecord(BiffRecord):
    """
    This  record  is  part  of  the  Page  Settings  Block. It contains all
    vertical manual page breaks.

    Record VERTICALPAGEBREAKS, BIFF8:
    Offset  Size  Contents
    0       2     Number of following column index structures (nm)
    2       6nm   List of nm column index structures. Each column index
                  structure contains:
                    Offset  Size    Contents
                    0       2       Index to first column following the page
                                    break
                    2       2       Index to first row of this page break
                    4       2       Index to last row of this page break

    The column indexes in the lists must be ordered ascending.
    If in BIFF8 a column contains several page breaks, they must be ordered
    ascending by start row index.
    """
    _REC_ID = 0x001A

    def __init__(self, breaks_list):
        self._rec_data = pack('<H', len(breaks_list))
        for r, c1, c2 in breaks_list:
            self._rec_data += pack('<3H', r, c1, c2)

class HeaderRecord(BiffRecord):
    """
    This record is part of the Page Settings Block. It specifies the
    page  header  string  for  the current worksheet. If this record is not
    present  or  completely  empty  (record  size is 0), the sheet does not
    contain a page header.

    Record HEADER for non-empty page header, BIFF2-BIFF8:
    Offset      Size    Contents
    0           var.    Page header string
                        BIFF2-BIFF7:    Non-empty byte string, 8bit string
                        length
                        BIFF8: Non-empty Unicode string, 16bit string length
    The  header  string may contain special commands, i.e. placeholders for
    the  page  number,  current  date, or text formatting attributes. These
    fields  are  represented  by  single  letters (exception: font name and
    size,  see  below)  with  a  leading  ampersand ("&"). If the ampersand
    is  part  of the regular header text, it will be duplicated ("&&"). The
    page  header is divided into 3 sections: the left, the centred, and the
    right  section.  Each  section  is introduced by a special command. All
    text  and all commands following are part of the selected section. Each
    section  starts  with the text formatting specified in the default font
    (first  FONT  record  in  the  file). Active formatting attributes from
    a previous section do not go into the next section.

    The following table shows all available commands:

    Command         Contents
    &&              The "&" character itself
    &L              Start of the left section
    &C              Start of the centred section
    &R              Start of the right section
    &P              Current page number
    &N              Page count
    &D              Current date
    &T              Current time
    &A              Sheet name (BIFF5-BIFF8)
    &F              File name without path
    &Z              File path without file name (BIFF8X)
    &G              Picture (BIFF8X)
    &B              Bold on/off (BIFF2-BIFF4)
    &I              Italic on/off (BIFF2-BIFF4)
    &U              Underlining on/off
    &E              Double underlining on/off (BIFF5-BIFF8)
    &S              Strikeout on/off
    &X              Superscript on/off (BIFF5-BIFF8)
    &Y              Subscript on/off (BIFF5-BIFF8)
    &"<fontname>"   Set new font <fontname>
    &"<fontname>,<fontstyle>"
                    Set new font with specified style <fontstyle>.
                    The style <fontstyle> is in most cases one of
                    "Regular", "Bold", "Italic", or "Bold Italic".
                    But this setting is dependent on the used font,
                    it may differ (localised style names, or "Standard",
                    "Oblique", ...). (BIFF5-BIFF8)
    &<fontheight>   Set font height in points (<fontheight> is a decimal value).
                    If this command is followed by a plain number to be printed
                    in the header, it will be separated from the font height
                    with a space character.

    """
    _REC_ID = 0x0014

    def __init__(self, header_str):
        self._rec_data = upack2(header_str)

class FooterRecord(BiffRecord):
    """
    Semantic is equal to HEADER record
    """
    _REC_ID = 0x0015

    def __init__(self, footer_str):
        self._rec_data = upack2(footer_str)


class HCenterRecord(BiffRecord):
    """
    This  record  is  part  of the Page Settings Block. It specifies if the
    sheet is centred horizontally when printed.

    Record HCENTER, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       0 = Print sheet left aligned
                    1 = Print sheet centred horizontally

    """
    _REC_ID = 0x0083

    def __init__(self, is_horz_center):
        self._rec_data = pack('<H', is_horz_center)


class VCenterRecord(BiffRecord):
    """
    This  record  is  part  of the Page Settings Block. It specifies if the
    sheet is centred vertically when printed.

    Record VCENTER, BIFF3-BIFF8:

    Offset  Size    Contents
    0       2       0 = Print sheet aligned at top page border
                    1 = Print sheet vertically centred

    """
    _REC_ID = 0x0084

    def __init__(self, is_vert_center):
        self._rec_data = pack('<H', is_vert_center)


class LeftMarginRecord(BiffRecord):
    """
    This  record  is  part of the Page Settings Block. It contains the left
    page margin of the current worksheet.

    Record LEFTMARGIN, BIFF2-BIFF8:

    Offset  Size    Contents
    0       8       Left page margin in inches
                    (IEEE 754 floating-point value, 64bit double precision)

    """
    _REC_ID = 0x0026

    def __init__(self, margin):
        self._rec_data = pack('<d', margin)


class RightMarginRecord(BiffRecord):
    """
    This  record  is  part of the Page Settings Block. It contains the right
    page margin of the current worksheet.

    Offset  Size    Contents
    0       8       Right page margin in inches
                    (IEEE 754 floating-point value, 64?bit double precision)

    """
    _REC_ID = 0x0027

    def __init__(self, margin):
        self._rec_data = pack('<d', margin)

class TopMarginRecord(BiffRecord):
    """
    This  record  is  part of the Page Settings Block. It contains the top
    page margin of the current worksheet.

    Offset  Size    Contents
    0       8       Top page margin in inches
                    (IEEE 754 floating-point value, 64?bit double precision)

    """
    _REC_ID = 0x0028

    def __init__(self, margin):
        self._rec_data = pack('<d', margin)


class BottomMarginRecord(BiffRecord):
    """
    This  record  is  part of the Page Settings Block. It contains the bottom
    page margin of the current worksheet.

    Offset  Size    Contents
    0       8       Bottom page margin in inches
                    (IEEE 754 floating-point value, 64?bit double precision)

    """
    _REC_ID = 0x0029

    def __init__(self, margin):
        self._rec_data = pack('<d', margin)

class SetupPageRecord(BiffRecord):
    """
    This   record   is  part of the Page Settings Block. It stores the page
    format   settings   of   the  current sheet. The pages may be scaled in
    percent   or  by  using  an  absolute  number of pages. This setting is
    located   in  the  WSBOOL  record.  If  pages  are  scaled in  percent,
    the   scaling  factor  in  this  record is used, otherwise the "Fit  to
    pages"  values. One of the "Fit to pages" values may be 0. In this case
    the sheet is scaled to fit only to the other value.

    Record SETUP, BIFF5-BIFF8:

    Offset      Size    Contents
    0           2       Paper size (see below)
    2           2       Scaling factor in percent
    4           2       Start page number
    6           2       Fit worksheet width to this number of pages
                        (0 = use as many as needed)
    8           2       Fit worksheet height to this number of pages
                        (0 = use as many as needed)
    10          2       Option flags:
                        Bit     Mask        Contents
                        0       0001H       0 = Print pages in columns
                                            1 = Print pages in rows
                        1       0002H       0 = Landscape
                                            1 = Portrait
                        2       0004H       1 = Paper size, scaling factor,
                                            paper orientation (portrait/landscape),
                                            print resolution and number of copies
                                            are not initialised
                        3       0008H       0 = Print coloured
                                            1 = Print black and white
                        4       0010H       0 = Default print quality
                                            1 = Draft quality
                        5       0020H       0 = Do not print cell notes
                                            1 = Print cell notes
                        6       0040H       0 = Paper orientation setting is valid
                                            1 = Paper orientation setting not
                                            initialised
                        7       0080H       0 = Automatic page numbers
                                            1 = Use start page number
                        The following flags are valid for BIFF8 only:
                        9       0200H       0 = Print notes as displayed
                                            1 = Print notes at end of sheet
                        11-10   0C00H       00 = Print errors as displayed
                                            01 = Do not print errors
                                            10 = Print errors as "--"
                                            11 = Print errors as "#N/A!"
    12          2       Print resolution in dpi
    14          2       Vertical print resolution in dpi
    16          8       Header margin (IEEE 754 floating-point value,
                        64bit double precision)
    24          8       Footer margin (IEEE 754 floating-point value,
                        64bit double precision)
    32          2       Number of copies to print


    PAPER TYPES:

    Index   Paper type              Paper size
    0       Undefined
    1       Letter                  8 1/2" x 11"
    2       Letter small            8 1/2" x 11"
    3       Tabloid                 11" x 17"
    4       Ledger                  17" x 11"
    5       Legal                   8 1/2" x 14"
    6       Statement               5 1/2" x 8 1/2"
    7       Executive               7 1/4" x 10 1/2"
    8       A3                      297mm x 420mm
    9       A4                      210mm x 297mm
    10      A4 small                210mm x 297mm
    11      A5                      148mm x 210mm
    12      B4 (JIS)                257mm x 364mm
    13      B5 (JIS)                182mm x 257mm
    14      Folio                   8 1/2" x 13"
    15      Quarto                  215mm x 275mm
    16      10x14                   10" x 14"
    17      11x17                   11" x 17"
    18      Note                    8 1/2" x 11"
    19      Envelope #9             3 7/8" x 8 7/8"
    20      Envelope #10            4 1/8" x 9 1/2"
    21      Envelope #11            4 1/2" x 10 3/8"
    22      Envelope #12            4 3/4" x 11"
    23      Envelope #14            5" x 11 1/2"
    24      C                       17" x 22"
    25      D                       22" x 34"
    26      E                       34" x 44"
    27      Envelope DL             110mm x 220mm
    28      Envelope C5             162mm x 229mm
    29      Envelope C3             324mm x 458mm
    30      Envelope C4             229mm x 324mm
    31      Envelope C6             114mm x 162mm
    32      Envelope C6/C5          114mm x 229mm
    33      B4 (ISO)                250mm x 353mm
    34      B5 (ISO)                176mm x 250mm
    35      B6 (ISO)                125mm x 176mm
    36      Envelope Italy          110mm x 230mm
    37      Envelope Monarch        3 7/8" x 7 1/2"
    38      63/4 Envelope           3 5/8" x 6 1/2"
    39      US Standard Fanfold     14 7/8" x 11"
    40      German Std. Fanfold     8 1/2" x 12"
    41      German Legal Fanfold    8 1/2" x 13"
    42      B4 (ISO)                250mm x 353mm
    43      Japanese Postcard       100mm x 148mm
    44      9x11                    9" x 11"
    45      10x11                   10" x 11"
    46      15x11                   15" x 11"
    47      Envelope Invite         220mm x 220mm
    48      Undefined
    49      Undefined
    50      Letter Extra            9 1/2" x 12"
    51      Legal Extra             9 1/2" x 15"
    52      Tabloid Extra           11 11/16" x 18"
    53      A4 Extra                235mm x 322mm
    54      Letter Transverse       8 1/2" x 11"
    55      A4 Transverse           210mm x 297mm
    56      Letter Extra Transv.    9 1/2" x 12"
    57      Super A/A4              227mm x 356mm
    58      Super B/A3              305mm x 487mm
    59      Letter Plus             8 1/2" x 12 11/16"
    60      A4 Plus                 210mm x 330mm
    61      A5 Transverse           148mm x 210mm
    62      B5 (JIS) Transverse     182mm x 257mm
    63      A3 Extra                322mm x 445mm
    64      A5 Extra                174mm x 235mm
    65      B5 (ISO) Extra          201mm x 276mm
    66      A2                      420mm x 594mm
    67      A3 Transverse           297mm x 420mm
    68      A3 Extra Transverse     322mm x 445mm
    69      Dbl. Japanese Postcard  200mm x 148mm
    70      A6                      105mm x 148mm
    71
    72
    73
    74
    75      Letter Rotated          11" x 8 1/2"
    76      A3 Rotated              420mm x 297mm
    77      A4 Rotated              297mm x 210mm
    78      A5 Rotated              210mm x 148mm
    79      B4 (JIS) Rotated        364mm x 257mm
    80      B5 (JIS) Rotated        257mm x 182mm
    81      Japanese Postcard Rot.  148mm x 100mm
    82      Dbl. Jap. Postcard Rot. 148mm x 200mm
    83      A6 Rotated              148mm x 105mm
    84
    85
    86
    87
    88      B6 (JIS)                128mm x 182mm
    89      B6 (JIS) Rotated        182mm x 128mm
    90      12x11                   12" x 11"

    """
    _REC_ID = 0x00A1
    def __init__(self, paper, scaling, start_num, fit_width_to, fit_height_to,
                    options,
                    hres, vres,
                    header_margin, footer_margin,
                    num_copies):
        self._rec_data = pack('<8H2dH', paper, scaling, start_num,
                                        fit_width_to, fit_height_to, \
                                        options,
                                        hres, vres,
                                        header_margin, footer_margin,
                                        num_copies)

class NameRecord(BiffRecord):
    """
    This record is part of a Link Table. It contains the name and the token
    array of an internal defined name. Token arrays of defined names
    contain tokens with aberrant token classes.

    Record NAME, BIFF5/BIFF7:
    Offset      Size    Contents
       0          2     Option flags, see below
       2          1     Keyboard shortcut (only for command macro names, see below)
       3          1     Length of the name (character count, ln)
       4          2     Size of the formula data (sz)
       6          2     0 = Global name, otherwise index to EXTERNSHEET record (one-based)
       8          2     0 = Global name, otherwise index to sheet (one-based)
      10          1     Length of menu text (character count, lm)
      11          1     Length of description text (character count, ld)
      12          1     Length of help topic text (character count, lh)
      13          1     Length of status bar text (character count, ls)
      14         ln     Character array of the name
    14+ln        sz     Formula data (RPN token array without size field, 4)
  14+ln+sz       lm     Character array of menu text
     var.        ld     Character array of description text
     var.        lh     Character array of help topic text
     var.        ls     Character array of status bar text

    Record NAME, BIFF8:
    Offset      Size Contents
       0          2  Option flags, see below
       2          1  Keyboard shortcut (only for command macro names, see below)
       3          1  Length of the name (character count, ln)
       4          2  Size of the formula data (sz)
       6          2  Not used
       8          2  0 = Global name, otherwise index to sheet (one-based)
      10          1  Length of menu text (character count, lm)
      11          1  Length of description text (character count, ld)
      12          1  Length of help topic text (character count, lh)
      13          1  Length of status bar text (character count, ls)
      14        var. Name (Unicode string without length field, 3.4)
     var.        sz  Formula data (RPN token array without size field, 4)
    [var.]      var. (optional, only if lm > 0) Menu text (Unicode string without length field, 3.4)
    [var.]      var. (optional, only if ld > 0) Description text (Unicode string without length field, 3.4)
    [var.]      var. (optional, only if lh > 0) Help topic text (Unicode string without length field, 3.4)
    [var.]      var. (optional, only if ls > 0) Status bar text (Unicode string without length field, 3.4)
    """
    _REC_ID = 0x0018

    def __init__(self, options, keyboard_shortcut, name, sheet_index, rpn,
                 menu_text=b'', desc_text=b'', help_text=b'', status_text=b''):
        if type(name) == int:
            uname = chr(name)
        else:
            uname = upack1(name)[1:]
        uname_len = len(uname)

        #~ self._rec_data = pack('<HBBHHHBBBB%ds%ds' % (uname_len, len(rpn)), options, keyboard_shortcut, uname_len, len(rpn), 0x0000, sheet_index, len(menu_text), len(desc_text), len(help_text), len(status_text), uname, rpn) + menu_text + desc_text + help_text + status_text
        self._rec_data = pack('<HBBHHHBBBBB%ds%ds' % (uname_len, len(rpn)), options, keyboard_shortcut, uname_len, len(rpn), 0x0000, sheet_index, 0x00, len(menu_text), len(desc_text), len(help_text), len(status_text), uname, rpn) + menu_text + desc_text + help_text + status_text

# Excel (both 2003 and 2007) don't like refs
# split over a record boundary, which is what the
# standard BiffRecord.get method does.

# 8224 max data bytes in a BIFF record
# 6 bytes per ref
# 1370 = floor((8224 - 2) / 6.0) max refs in a record

_maxRefPerRecord = 1370

class ExternSheetRecord(BiffRecord):
    """
    In BIFF8 the record stores a list with indexes to SUPBOOK
    records (list of REF structures, 6.100). See 5.10.3 for
    details about external references in BIFF8.

    Record EXTERNSHEET, BIFF8:
    Offset          Size      Contents
       0             2        Number of following REF structures (nm)
       2           6nm        List of nm REF structures. Each REF contains the following data:
                              Offset     Size     Contents
                                 0         2      Index to SUPBOOK record
                                 2         2      Index to first SUPBOOK sheet
                                 4         2      Index to last SUPBOOK sheet
    """
    _REC_ID = 0x0017

    def __init__(self, refs):

        # do we always need this ref? or only if there are no refs?
        # (I believe that if there are no refs then we should not generate the link table - Ruben)
        #refs.insert(0, (0,0,0))

        self.refs = refs

    def get(self):
        res = []
        nrefs = len(self.refs)
        for idx in range(0, nrefs, _maxRefPerRecord):
            chunk = self.refs[idx:idx+_maxRefPerRecord]
            krefs = len(chunk)
            if idx: # CONTINUE record
                header = pack("<HH", 0x003C, 6 * krefs)
            else: # ExternSheetRecord
                header = pack("<HHH", self._REC_ID, 6 * krefs + 2, nrefs)
            res.append(header)
            res.extend([pack("<HHH", *r) for r in chunk])
        return b''.join(res)

class SupBookRecord(BiffRecord):
    """
    This record mainly stores the URL of an external document
    and a list of sheet names inside this document. Furthermore
    it is used to store DDE and OLE object links, or to indicate
    an internal 3D reference or an add-in function. See 5.10.3
    for details about external references in BIFF8.

    """
    _REC_ID = 0x01AE

class InternalReferenceSupBookRecord(SupBookRecord):
    """
    In each file occurs a SUPBOOK that is used for internal 3D
    references. It stores the number of sheets of the own document.

    Record SUPBOOK for 3D references, BIFF8:
    Offset         Size   Contents
      0             2     Number of sheets in this document
      2             2     01H 04H (relict of BIFF5/BIFF7, the byte string "<04H>", see 3.9.1)

    """

    def __init__(self, num_sheets):
        self._rec_data = pack('<HBB', num_sheets, 0x01, 0x04)

class XcallSupBookRecord(SupBookRecord):
    """
    Add-in function names are stored in EXTERNNAME records following this record.

    Offset  Size    Contents
    0       2       0001H
    2       2       01H 3AH (relict of BIFF5, the byte string ':', see EXTERNSHEET record, 5.41)

    """

    def __init__(self):
        self._rec_data = pack('<HBB', 1, 0x01, 0x3A)


class ExternnameRecord(BiffRecord):
    """
    Record EXTERNNAME for external names and Analysis add-in functions, BIFF5-BIFF8:
    Offset  Size    Contents
    0       2       Option flags (see below)
    2       2       0 for global names, or:
                    BIFF5: One-based index to EXTERNSHEET record containing the sheet name,
                    BIFF8: One-based index to sheet list in preceding EXTERNALBOOK record.
    4       2       Not used
    6       var.    BIFF5: Name (byte string, 8-bit string length, ?2.5.2).
                    BIFF8: Name (Unicode string, 8-bit string length, ?2.5.3).
                    See DEFINEDNAME record (?5.33) for a list of built-in names, if the built-in flag is set
                    in the option flags above.
    var.    var.    Formula data (RPN token array, ?3)

    Option flags for external names (BIFF5-BIFF8)
    Bit     Mask    Contents
    0       0001H   0 = Standard name; 1 = Built-in name
    1       0002H   0 = Manual link; 1 = Automatic link (DDE links and OLE links only)
    2       0004H   1 = Picture link (DDE links and OLE links only)
    3       0008H   1 = This is the StdDocumentName identifier (DDE links only)
    4       0010H   1 = OLE link
    14-5    7FE0H   Clipboard format of last successful update (DDE links and OLE links only)
    15      8000H   1 = Iconified picture link (BIFF8 OLE links only)
    """
    _REC_ID = 0x0023

    def __init__(self, options=0, index=0, name=None, fmla=None):
        self._rec_data = pack('<HHH', options, index, 0) + upack1(name) + fmla.encode()


########NEW FILE########
__FILENAME__ = Bitmap
#  Portions are Copyright (C) 2005 Roman V. Kiseliov
#  Portions are Copyright (c) 2004 Evgeny Filatov <fufff@users.sourceforge.net>
#  Portions are Copyright (c) 2002-2004 John McNamara (Perl Spreadsheet::WriteExcel)

from .BIFFRecords import BiffRecord
from struct import *


def _size_col(sheet, col):
    return sheet.col_width(col)


def _size_row(sheet, row):
    return sheet.row_height(row)


def _position_image(sheet, row_start, col_start, x1, y1, width, height):
    """Calculate the vertices that define the position of the image as required by
    the OBJ record.

             +------------+------------+
             |     A      |      B     |
       +-----+------------+------------+
       |     |(x1,y1)     |            |
       |  1  |(A1)._______|______      |
       |     |    |              |     |
       |     |    |              |     |
       +-----+----|    BITMAP    |-----+
       |     |    |              |     |
       |  2  |    |______________.     |
       |     |            |        (B2)|
       |     |            |     (x2,y2)|
       +---- +------------+------------+

    Example of a bitmap that covers some of the area from cell A1 to cell B2.

    Based on the width and height of the bitmap we need to calculate 8 vars:
        col_start, row_start, col_end, row_end, x1, y1, x2, y2.
    The width and height of the cells are also variable and have to be taken into
    account.
    The values of col_start and row_start are passed in from the calling
    function. The values of col_end and row_end are calculated by subtracting
    the width and height of the bitmap from the width and height of the
    underlying cells.
    The vertices are expressed as a percentage of the underlying cell width as
    follows (rhs values are in pixels):

           x1 = X / W *1024
           y1 = Y / H *256
           x2 = (X-1) / W *1024
           y2 = (Y-1) / H *256

           Where:  X is distance from the left side of the underlying cell
                   Y is distance from the top of the underlying cell
                   W is the width of the cell
                   H is the height of the cell

    Note: the SDK incorrectly states that the height should be expressed as a
    percentage of 1024.

    col_start  - Col containing upper left corner of object
    row_start  - Row containing top left corner of object
    x1  - Distance to left side of object
    y1  - Distance to top of object
    width  - Width of image frame
    height  - Height of image frame

    """
    # Adjust start column for offsets that are greater than the col width
    while x1 >= _size_col(sheet, col_start):
        x1 -= _size_col(sheet, col_start)
        col_start += 1
    # Adjust start row for offsets that are greater than the row height
    while y1 >= _size_row(sheet, row_start):
        y1 -= _size_row(sheet, row_start)
        row_start += 1
    # Initialise end cell to the same as the start cell
    row_end = row_start   # Row containing bottom right corner of object
    col_end = col_start   # Col containing lower right corner of object
    width = width + x1 - 1
    height = height + y1 - 1
    # Subtract the underlying cell widths to find the end cell of the image
    while (width >= _size_col(sheet, col_end)):
        width -= _size_col(sheet, col_end)
        col_end += 1
    # Subtract the underlying cell heights to find the end cell of the image
    while (height >= _size_row(sheet, row_end)):
        height -= _size_row(sheet, row_end)
        row_end += 1
    # Bitmap isn't allowed to start or finish in a hidden cell, i.e. a cell
    # with zero height or width.
    if ((_size_col(sheet, col_start) == 0) or (_size_col(sheet, col_end) == 0)
            or (_size_row(sheet, row_start) == 0) or (_size_row(sheet, row_end) == 0)):
        return
    # Convert the pixel values to the percentage value expected by Excel
    x1 = int(float(x1) / _size_col(sheet, col_start) * 1024)
    y1 = int(float(y1) / _size_row(sheet, row_start) * 256)
    # Distance to right side of object
    x2 = int(float(width) / _size_col(sheet, col_end) * 1024)
    # Distance to bottom of object
    y2 = int(float(height) / _size_row(sheet, row_end) * 256)
    return (col_start, x1, row_start, y1, col_end, x2, row_end, y2)


class ObjBmpRecord(BiffRecord):
    _REC_ID = 0x005D    # Record identifier

    def __init__(self, row, col, sheet, im_data_bmp, x, y, scale_x, scale_y):
        # Scale the frame of the image.
        width = im_data_bmp.width * scale_x
        height = im_data_bmp.height * scale_y

        # Calculate the vertices of the image and write the OBJ record
        coordinates = _position_image(sheet, row, col, x, y, width, height)
        # print coordinates
        col_start, x1, row_start, y1, col_end, x2, row_end, y2 = coordinates

        """Store the OBJ record that precedes an IMDATA record. This could be generalise
        to support other Excel objects.

        """
        cObj = 0x0001      # Count of objects in file (set to 1)
        OT = 0x0008        # Object type. 8 = Picture
        id = 0x0001        # Object ID
        grbit = 0x0614     # Option flags
        colL = col_start    # Col containing upper left corner of object
        dxL = x1            # Distance from left side of cell
        rwT = row_start     # Row containing top left corner of object
        dyT = y1            # Distance from top of cell
        colR = col_end      # Col containing lower right corner of object
        dxR = x2            # Distance from right of cell
        rwB = row_end       # Row containing bottom right corner of object
        dyB = y2            # Distance from bottom of cell
        cbMacro = 0x0000    # Length of FMLA structure
        Reserved1 = 0x0000  # Reserved
        Reserved2 = 0x0000  # Reserved
        icvBack = 0x09      # Background colour
        icvFore = 0x09      # Foreground colour
        fls = 0x00          # Fill pattern
        fAuto = 0x00        # Automatic fill
        icv = 0x08          # Line colour
        lns = 0xff          # Line style
        lnw = 0x01          # Line weight
        fAutoB = 0x00       # Automatic border
        frs = 0x0000        # Frame style
        cf = 0x0009         # Image format, 9 = bitmap
        Reserved3 = 0x0000  # Reserved
        cbPictFmla = 0x0000 # Length of FMLA structure
        Reserved4 = 0x0000  # Reserved
        grbit2 = 0x0001     # Option flags
        Reserved5 = 0x0000  # Reserved

        data = pack("<L", cObj)
        data += pack("<H", OT)
        data += pack("<H", id)
        data += pack("<H", grbit)
        data += pack("<H", colL)
        data += pack("<H", dxL)
        data += pack("<H", rwT)
        data += pack("<H", dyT)
        data += pack("<H", colR)
        data += pack("<H", dxR)
        data += pack("<H", rwB)
        data += pack("<H", dyB)
        data += pack("<H", cbMacro)
        data += pack("<L", Reserved1)
        data += pack("<H", Reserved2)
        data += pack("<B", icvBack)
        data += pack("<B", icvFore)
        data += pack("<B", fls)
        data += pack("<B", fAuto)
        data += pack("<B", icv)
        data += pack("<B", lns)
        data += pack("<B", lnw)
        data += pack("<B", fAutoB)
        data += pack("<H", frs)
        data += pack("<L", cf)
        data += pack("<H", Reserved3)
        data += pack("<H", cbPictFmla)
        data += pack("<H", Reserved4)
        data += pack("<H", grbit2)
        data += pack("<L", Reserved5)

        self._rec_data = data

def _process_bitmap(bitmap):
    """Convert a 24 bit bitmap into the modified internal format used by Windows.
    This is described in BITMAPCOREHEADER and BITMAPCOREINFO structures in the
    MSDN library.

    """
    # Open file and binmode the data in case the platform needs it.
    fh = open(bitmap, 'rb')
    try:
        # Slurp the file into a string.
        data = fh.read()
    finally:
        fh.close()
    # Check that the file is big enough to be a bitmap.
    if len(data) <= 0x36:
        raise Exception("bitmap doesn't contain enough data.")
    # The first 2 bytes are used to identify the bitmap.
    if (data[:2] != b"BM"):
        raise Exception("bitmap doesn't appear to to be a valid bitmap image.")
    # Remove bitmap data: ID.
    data = data[2:]
    # Read and remove the bitmap size. This is more reliable than reading
    # the data size at offset 0x22.
    #
    size = unpack("<L", data[:4])[0]
    size -=  0x36   # Subtract size of bitmap header.
    size +=  0x0C   # Add size of BIFF header.
    data = data[4:]
    # Remove bitmap data: reserved, offset, header length.
    data = data[12:]
    # Read and remove the bitmap width and height. Verify the sizes.
    width, height = unpack("<LL", data[:8])
    data = data[8:]
    if (width > 0xFFFF):
        raise Exception("bitmap: largest image width supported is 65k.")
    if (height > 0xFFFF):
        raise Exception("bitmap: largest image height supported is 65k.")
    # Read and remove the bitmap planes and bpp data. Verify them.
    planes, bitcount = unpack("<HH", data[:4])
    data = data[4:]
    if (bitcount != 24):
        raise Exception("bitmap isn't a 24bit true color bitmap.")
    if (planes != 1):
        raise Exception("bitmap: only 1 plane supported in bitmap image.")
    # Read and remove the bitmap compression. Verify compression.
    compression = unpack("<L", data[:4])[0]
    data = data[4:]
    if (compression != 0):
        raise Exception("bitmap: compression not supported in bitmap image.")
    # Remove bitmap data: data size, hres, vres, colours, imp. colours.
    data = data[20:]
    # Add the BITMAPCOREHEADER data
    header = pack("<LHHHH", 0x000c, width, height, 0x01, 0x18)
    data = header + data
    return (width, height, size, data)


class ImDataBmpRecord(BiffRecord):
    _REC_ID = 0x007F

    def __init__(self, filename):
        """Insert a 24bit bitmap image in a worksheet. The main record required is
        IMDATA but it must be proceeded by a OBJ record to define its position.

        """
        BiffRecord.__init__(self)

        self.width, self.height, self.size, data = _process_bitmap(filename)
        # Write the IMDATA record to store the bitmap data
        cf = 0x09
        env = 0x01
        lcb = self.size
        self._rec_data = pack("<HHL", cf, env, lcb) + data

########NEW FILE########
__FILENAME__ = Cell
from struct import unpack, pack
from . import BIFFRecords

class StrCell(object):
    __slots__ = ["rowx", "colx", "xf_idx", "sst_idx"]

    def __init__(self, rowx, colx, xf_idx, sst_idx):
        self.rowx = rowx
        self.colx = colx
        self.xf_idx = xf_idx
        self.sst_idx = sst_idx

    def get_biff_data(self):
        return pack('<5HL', 0x00FD, 10, self.rowx, self.colx, self.xf_idx, self.sst_idx)

class BlankCell(object):
    __slots__ = ["rowx", "colx", "xf_idx"]

    def __init__(self, rowx, colx, xf_idx):
        self.rowx = rowx
        self.colx = colx
        self.xf_idx = xf_idx

    def get_biff_data(self):
        return pack('<5H', 0x0201, 6, self.rowx, self.colx, self.xf_idx)

class MulBlankCell(object):
    __slots__ = ["rowx", "colx1", "colx2", "xf_idx"]

    def __init__(self, rowx, colx1, colx2, xf_idx):
        self.rowx = rowx
        self.colx1 = colx1
        self.colx2 = colx2
        self.xf_idx = xf_idx

    def get_biff_data(self):
        return BIFFRecords.MulBlankRecord(self.rowx,
            self.colx1, self.colx2, self.xf_idx).get()

class NumberCell(object):
    __slots__ = ["rowx", "colx", "xf_idx", "number"]

    def __init__(self, rowx, colx, xf_idx, number):
        self.rowx = rowx
        self.colx = colx
        self.xf_idx = xf_idx
        self.number = float(number)

    def get_encoded_data(self):
        rk_encoded = 0
        num = self.number

        # The four possible kinds of RK encoding are *not* mutually exclusive.
        # The 30-bit integer variety picks up the most.
        # In the code below, the four varieties are checked in descending order
        # of bangs per buck, or not at all.
        # SJM 2007-10-01

        if -0x20000000 <= num < 0x20000000: # fits in 30-bit *signed* int
            inum = int(num)
            if inum == num: # survives round-trip
                rk_encoded = 2 | (inum << 2)
                return 1, rk_encoded

        temp = num * 100

        if -0x20000000 <= temp < 0x20000000:
            # That was step 1: the coded value will fit in
            # a 30-bit signed integer.
            itemp = int(round(temp, 0))
            # That was step 2: "itemp" is the best candidate coded value.
            # Now for step 3: simulate the decoding,
            # to check for round-trip correctness.
            if itemp / 100.0 == num:
                rk_encoded = 3 | (itemp << 2)
                return 1, rk_encoded

        if 0: # Cost of extra pack+unpack not justified by tiny yield.
            packed = pack('<d', num)
            w01, w23 = unpack('<2i', packed)
            if not w01 and not(w23 & 3):
                return 1, w23

            packed100 = pack('<d', temp)
            w01, w23 = unpack('<2i', packed100)
            if not w01 and not(w23 & 3):
                return 1, w23 | 1

        return 0, pack('<5Hd', 0x0203, 14, self.rowx, self.colx, self.xf_idx, num)

    def get_biff_data(self):
        isRK, value = self.get_encoded_data()
        if isRK:
            return pack('<5Hi', 0x27E, 10, self.rowx, self.colx, self.xf_idx, value)
        return value # NUMBER record already packed

class BooleanCell(object):
    __slots__ = ["rowx", "colx", "xf_idx", "number"]

    def __init__(self, rowx, colx, xf_idx, number):
        self.rowx = rowx
        self.colx = colx
        self.xf_idx = xf_idx
        self.number = number

    def get_biff_data(self):
        return BIFFRecords.BoolErrRecord(self.rowx,
            self.colx, self.xf_idx, self.number, 0).get()

error_code_map = {
    0x00:  0, # Intersection of two cell ranges is empty
    0x07:  7, # Division by zero
    0x0F: 15, # Wrong type of operand
    0x17: 23, # Illegal or deleted cell reference
    0x1D: 29, # Wrong function or range name
    0x24: 36, # Value range overflow
    0x2A: 42, # Argument or function not available
    '#NULL!' :  0, # Intersection of two cell ranges is empty
    '#DIV/0!':  7, # Division by zero
    '#VALUE!': 36, # Wrong type of operand
    '#REF!'  : 23, # Illegal or deleted cell reference
    '#NAME?' : 29, # Wrong function or range name
    '#NUM!'  : 36, # Value range overflow
    '#N/A!'  : 42, # Argument or function not available
}

class ErrorCell(object):
    __slots__ = ["rowx", "colx", "xf_idx", "number"]

    def __init__(self, rowx, colx, xf_idx, error_string_or_code):
        self.rowx = rowx
        self.colx = colx
        self.xf_idx = xf_idx
        try:
            self.number = error_code_map[error_string_or_code]
        except KeyError:
            raise Exception('Illegal error value (%r)' % error_string_or_code)

    def get_biff_data(self):
        return BIFFRecords.BoolErrRecord(self.rowx,
            self.colx, self.xf_idx, self.number, 1).get()

class FormulaCell(object):
    __slots__ = ["rowx", "colx", "xf_idx", "frmla", "calc_flags"]

    def __init__(self, rowx, colx, xf_idx, frmla, calc_flags=0):
        self.rowx = rowx
        self.colx = colx
        self.xf_idx = xf_idx
        self.frmla = frmla
        self.calc_flags = calc_flags

    def get_biff_data(self):
        return BIFFRecords.FormulaRecord(self.rowx,
            self.colx, self.xf_idx, self.frmla.rpn(), self.calc_flags).get()

# module-level function for *internal* use by the Row module

def _get_cells_biff_data_mul(rowx, cell_items):
    # Return the BIFF data for all cell records in the row.
    # Adjacent BLANK|RK records are combined into MUL(BLANK|RK) records.
    pieces = []
    nitems = len(cell_items)
    i = 0
    while i < nitems:
        icolx, icell = cell_items[i]
        if isinstance(icell, NumberCell):
            isRK, value = icell.get_encoded_data()
            if not isRK:
                pieces.append(value) # pre-packed NUMBER record
                i += 1
                continue
            muldata = [(value, icell.xf_idx)]
            target = NumberCell
        elif isinstance(icell, BlankCell):
            muldata = [icell.xf_idx]
            target = BlankCell
        else:
            pieces.append(icell.get_biff_data())
            i += 1
            continue
        lastcolx = icolx
        j = i

        packed_record = b'' # (to_py3): 'b' binary data
        for j in range(i+1, nitems):
            jcolx, jcell = cell_items[j]
            if jcolx != lastcolx + 1:
                nexti = j
                break
            if not isinstance(jcell, target):
                nexti = j
                break
            if target == NumberCell:
                isRK, value = jcell.get_encoded_data()
                if not isRK:
                    packed_record = value
                    nexti = j + 1
                    break
                muldata.append((value, jcell.xf_idx))
            else:
                muldata.append(jcell.xf_idx)
            lastcolx = jcolx
        else:
            nexti = j + 1
        if target == NumberCell:
            if lastcolx == icolx:
                # RK record
                value, xf_idx = muldata[0]
                pieces.append(pack('<5Hi', 0x027E, 10, rowx, icolx, xf_idx, value))
            else:
                # MULRK record
                nc = lastcolx - icolx + 1
                pieces.append(pack('<4H', 0x00BD, 6 * nc + 6, rowx, icolx))
                # (to_py3): 'b' binary data
                pieces.append(b''.join([pack('<Hi', xf_idx, value) for value, xf_idx in muldata]))
                pieces.append(pack('<H', lastcolx))
        else:
            if lastcolx == icolx:
                # BLANK record
                xf_idx = muldata[0]
                pieces.append(pack('<5H', 0x0201, 6, rowx, icolx, xf_idx))
            else:
                # MULBLANK record
                nc = lastcolx - icolx + 1
                pieces.append(pack('<4H', 0x00BE, 2 * nc + 6, rowx, icolx))
                # (to_py3): 'b' binary data
                pieces.append(b''.join([pack('<H', xf_idx) for xf_idx in muldata]))
                pieces.append(pack('<H', lastcolx))
        if packed_record:
            pieces.append(packed_record)
        i = nexti
    return b''.join(pieces) # (to_py3): 'b' binary data

########NEW FILE########
__FILENAME__ = Column
# -*- coding: windows-1252 -*-

from .BIFFRecords import ColInfoRecord

class Column(object):
    def __init__(self, colx, parent_sheet):
        if not(isinstance(colx, int) and 0 <= colx <= 255):
            raise ValueError("column index (%r) not an int in range(256)" % colx)
        self._index = colx
        self._parent = parent_sheet
        self._parent_wb = parent_sheet.get_parent()
        self._xf_index = 0x0F

        self.width = 0x0B92
        self.hidden = 0
        self.level = 0
        self.collapse = 0

    def set_style(self, style):
        self._xf_index = self._parent_wb.add_style(style)

    def width_in_pixels(self):
        # *** Approximation ****
        return int(round(self.width * 0.0272 + 0.446, 0))

    def get_biff_record(self):
        options =  (self.hidden & 0x01) << 0
        options |= (self.level & 0x07) << 8
        options |= (self.collapse & 0x01) << 12

        return ColInfoRecord(self._index, self._index, self.width, self._xf_index, options).get()




########NEW FILE########
__FILENAME__ = CompoundDoc
import sys
import struct

ENCODING = 'utf-16-le'

class Reader:
    def __init__(self, filename, dump = False):
        self.dump = dump
        self.STREAMS = {}

        doc = file(filename, 'rb').read()
        self.header, self.data = doc[0:512], doc[512:]
        del doc

        self.__build_header()
        self.__build_MSAT()
        self.__build_SAT()
        self.__build_directory()
        self.__build_short_sectors_data()

        if len(self.short_sectors_data) > 0:
            self.__build_SSAT()
        else:
            if self.dump and (self.total_ssat_sectors != 0 or self.ssat_start_sid != -2):
                print('NOTE: header says that must be', self.total_ssat_sectors, 'short sectors')
                print('NOTE: starting at', self.ssat_start_sid, 'sector')
                print('NOTE: but file does not contains data in short sectors')
            self.ssat_start_sid = -2
            self.total_ssat_sectors = 0
            self.SSAT = [-2]

        for dentry in self.dir_entry_list[1:]:
            (did,
             sz, name,
             t, c,
             did_left, did_right, did_root,
             dentry_start_sid,
             stream_size
            ) = dentry
            stream_data = b''
            if stream_size > 0:
                if stream_size >= self.min_stream_size:
                    args = (self.data, self.SAT, dentry_start_sid, self.sect_size)
                else:
                    args = (self.short_sectors_data, self.SSAT, dentry_start_sid, self.short_sect_size)
                stream_data = self.get_stream_data(*args)

            if name != b'':
                # BAD IDEA: names may be equal. NEED use full paths...
                self.STREAMS[name] = stream_data


    def __build_header(self):
        self.doc_magic             = self.header[0:8]

        if self.doc_magic != b'\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1':
            raise Exception('Not an OLE file.')

        self.file_uid              = self.header[8:24]
        self.rev_num               = self.header[24:26]
        self.ver_num               = self.header[26:28]
        self.byte_order            = self.header[28:30]
        self.log2_sect_size,       = struct.unpack('<H', self.header[30:32])
        self.log2_short_sect_size, = struct.unpack('<H', self.header[32:34])
        self.total_sat_sectors,    = struct.unpack('<L', self.header[44:48])
        self.dir_start_sid,        = struct.unpack('<l', self.header[48:52])
        self.min_stream_size,      = struct.unpack('<L', self.header[56:60])
        self.ssat_start_sid,       = struct.unpack('<l', self.header[60:64])
        self.total_ssat_sectors,   = struct.unpack('<L', self.header[64:68])
        self.msat_start_sid,       = struct.unpack('<l', self.header[68:72])
        self.total_msat_sectors,   = struct.unpack('<L', self.header[72:76])

        self.sect_size        = 1 << self.log2_sect_size
        self.short_sect_size  = 1 << self.log2_short_sect_size

        if self.dump:
            print('file magic: ')
            print_bin_data(self.doc_magic)

            print('file uid: ')
            print_bin_data(self.file_uid)

            print('revision number: ')
            print_bin_data(self.rev_num)

            print('version number: ')
            print_bin_data(self.ver_num)

            print('byte order: ')
            print_bin_data(self.byte_order)

            print('sector size                                :', hex(self.sect_size), self.sect_size)
            #print 'total sectors in file                      :', hex(self.total_sectors), self.total_sectors
            print('short sector size                          :', hex(self.short_sect_size), self.short_sect_size)
            print('Total number of sectors used for the SAT   :', hex(self.total_sat_sectors), self.total_sat_sectors)
            print('SID of first sector of the directory stream:', hex(self.dir_start_sid), self.dir_start_sid)
            print('Minimum size of a standard stream          :', hex(self.min_stream_size), self.min_stream_size)
            print('SID of first sector of the SSAT            :', hex(self.ssat_start_sid), self.ssat_start_sid)
            print('Total number of sectors used for the SSAT  :', hex(self.total_ssat_sectors), self.total_ssat_sectors)
            print('SID of first additional sector of the MSAT :', hex(self.msat_start_sid), self.msat_start_sid)
            print('Total number of sectors used for the MSAT  :', hex(self.total_msat_sectors), self.total_msat_sectors)


    def __build_MSAT(self):
        self.MSAT = list(struct.unpack('<109l', self.header[76:]))

        next = self.msat_start_sid
        while next > 0:
            msat_sector = struct.unpack('<128l', self.data[next*self.sect_size:(next+1)*self.sect_size])
            self.MSAT.extend(msat_sector[:127])
            next = msat_sector[-1]

        if self.dump:
            print('MSAT (header part): \n', self.MSAT[:109])
            print('additional MSAT sectors: \n', self.MSAT[109:])


    def __build_SAT(self):
        sat_stream = b''.join([self.data[i*self.sect_size:(i+1)*self.sect_size] for i in self.MSAT if i >= 0])

        sat_sids_count = len(sat_stream) >> 2
        self.SAT = struct.unpack('<%dl' % sat_sids_count, sat_stream) # SIDs tuple

        if self.dump:
            print('SAT sid count:\n', sat_sids_count)
            print('SAT content:\n', self.SAT)


    def __build_SSAT(self):
        ssat_stream = self.get_stream_data(self.data, self.SAT, self.ssat_start_sid, self.sect_size)

        ssids_count = len(ssat_stream) >> 2
        self.SSAT = struct.unpack('<%dl' % ssids_count, ssat_stream)

        if self.dump:
            print('SSID count:', ssids_count)
            print('SSAT content:\n', self.SSAT)


    def __build_directory(self):
        dir_stream = self.get_stream_data(self.data, self.SAT, self.dir_start_sid, self.sect_size)

        self.dir_entry_list = []

        i = 0
        while i < len(dir_stream):
            dentry = dir_stream[i:i+128] # 128 -- dir entry size
            i += 128

            did = len(self.dir_entry_list)
            sz, = struct.unpack('<H', dentry[64:66])
            if sz > 0 :
                name = dentry[0:sz-2].decode('utf_16_le', 'replace')
            else:
                name = b''
            t,  = struct.unpack('B', dentry[66])
            c,  = struct.unpack('B', dentry[67])
            did_left ,  = struct.unpack('<l', dentry[68:72])
            did_right ,  = struct.unpack('<l', dentry[72:76])
            did_root ,  = struct.unpack('<l', dentry[76:80])
            dentry_start_sid ,  = struct.unpack('<l', dentry[116:120])
            stream_size ,  = struct.unpack('<L', dentry[120:124])

            self.dir_entry_list.extend([(did, sz, name, t, c,
                                            did_left, did_right, did_root,
                                            dentry_start_sid, stream_size)])

        if self.dump:
            dentry_types = {
                0x00: 'Empty',
                0x01: 'User storage',
                0x02: 'User stream',
                0x03: 'LockBytes',
                0x04: 'Property',
                0x05: 'Root storage'
            }
            node_colours = {
                0x00: 'Red',
                0x01: 'Black'
            }
            print('total directory entries:', len(self.dir_entry_list))

            for dentry in self.dir_entry_list:
                (did, sz, name, t, c,
                 did_left, did_right, did_root,
                 dentry_start_sid, stream_size) = dentry
                print('DID', did)
                print('Size of the used area of the character buffer of the name:', sz)
                print('dir entry name:', repr(name))
                print('type of entry:', t, dentry_types[t])
                print('entry colour:', c, node_colours[c])
                print('left child DID :', did_left)
                print('right child DID:', did_right)
                print('root DID       :', did_root)
                print('start SID       :', dentry_start_sid)
                print('stream size     :', stream_size)
                if stream_size == 0:
                    print('stream is empty')
                elif stream_size >= self.min_stream_size:
                    print('stream stored as normal stream')
                else:
                    print('stream stored as short-stream')


    def __build_short_sectors_data(self):
        (did, sz, name, t, c,
         did_left, did_right, did_root,
         dentry_start_sid, stream_size) = self.dir_entry_list[0]
        assert t == 0x05 # Short-Stream Container Stream (SSCS) resides in Root Storage
        if stream_size == 0:
            self.short_sectors_data = b''
        else:
            self.short_sectors_data = self.get_stream_data(self.data, self.SAT, dentry_start_sid, self.sect_size)


    def get_stream_data(self, data, SAT, start_sid, sect_size):
        sid = start_sid
        chunks = [(sid, sid)]
        stream_data = b''

        while SAT[sid] >= 0:
            next_in_chain = SAT[sid]
            last_chunk_start, last_chunk_finish = chunks[-1]
            if next_in_chain == last_chunk_finish + 1:
                chunks[-1] = last_chunk_start, next_in_chain
            else:
                chunks.extend([(next_in_chain, next_in_chain)])
            sid = next_in_chain
        for s, f in chunks:
            stream_data += data[s*sect_size:(f+1)*sect_size]
        #print chunks
        return stream_data


def print_bin_data(data):
    i = 0
    while i < len(data):
        j = 0
        while (i < len(data)) and (j < 16):
            c = b'0x%02X' % ord(data[i])
            sys.stdout.write(c)
            sys.stdout.write(' ')
            i += 1
            j += 1
        print()
    if i == 0:
        print('<NO DATA>')



# This implementation writes only 'Root Entry', 'Workbook' streams
# and 2 empty streams for aligning directory stream on sector boundary
#
# LAYOUT:
# 0         header
# 76                MSAT (1st part: 109 SID)
# 512       workbook stream
# ...       additional MSAT sectors if streams' size > about 7 Mb == (109*512 * 128)
# ...       SAT
# ...       directory stream
#
# NOTE: this layout is "ad hoc". It can be more general. RTFM

class XlsDoc:
    SECTOR_SIZE = 0x0200
    MIN_LIMIT   = 0x1000

    SID_FREE_SECTOR  = -1
    SID_END_OF_CHAIN = -2
    SID_USED_BY_SAT  = -3
    SID_USED_BY_MSAT = -4

    def __init__(self):
        self.book_stream_sect = []

        self.dir_stream = b''
        self.dir_stream_sect = []

        self.packed_SAT = b''
        self.SAT_sect = []

        self.packed_MSAT_1st = b''
        self.packed_MSAT_2nd = b''
        self.MSAT_sect_2nd = []

        self.header = b''

    def __build_directory(self): # align on sector boundary
        self.dir_stream = b''

        #(to_py3): replaced = b'\x00'.join(b'Root Entry\x00') + b'\x00'
        dentry_name      = 'Root Entry\x00'.encode(ENCODING)
        dentry_name_sz   = len(dentry_name)
        dentry_name_pad  = b'\x00'*(64 - dentry_name_sz)
        dentry_type      = 0x05 # root storage
        dentry_colour    = 0x01 # black
        dentry_did_left  = -1
        dentry_did_right = -1
        dentry_did_root  = 1
        dentry_start_sid = -2
        dentry_stream_sz = 0

        self.dir_stream += struct.pack('<64s H 2B 3l 9L l L L',
           dentry_name + dentry_name_pad,
           dentry_name_sz,
           dentry_type,
           dentry_colour,
           dentry_did_left,
           dentry_did_right,
           dentry_did_root,
           0, 0, 0, 0, 0, 0, 0, 0, 0,
           dentry_start_sid,
           dentry_stream_sz,
           0
        )
        # (to_py3): replaced = b'\x00'.join(b'Workbook\x00') + b'\x00'
        dentry_name      = 'Workbook\x00'.encode(ENCODING)
        dentry_name_sz   = len(dentry_name)
        dentry_name_pad  = b'\x00'*(64 - dentry_name_sz)
        dentry_type      = 0x02 # user stream
        dentry_colour    = 0x01 # black
        dentry_did_left  = -1
        dentry_did_right = -1
        dentry_did_root  = -1
        dentry_start_sid = 0
        dentry_stream_sz = self.book_stream_len

        self.dir_stream += struct.pack('<64s H 2B 3l 9L l L L',
           dentry_name + dentry_name_pad,
           dentry_name_sz,
           dentry_type,
           dentry_colour,
           dentry_did_left,
           dentry_did_right,
           dentry_did_root,
           0, 0, 0, 0, 0, 0, 0, 0, 0,
           dentry_start_sid,
           dentry_stream_sz,
           0
        )

        # padding
        dentry_name      = b''
        dentry_name_sz   = len(dentry_name)
        dentry_name_pad  = b'\x00'*(64 - dentry_name_sz)
        dentry_type      = 0x00 # empty
        dentry_colour    = 0x01 # black
        dentry_did_left  = -1
        dentry_did_right = -1
        dentry_did_root  = -1
        dentry_start_sid = -2
        dentry_stream_sz = 0

        self.dir_stream += struct.pack('<64s H 2B 3l 9L l L L',
           dentry_name + dentry_name_pad,
           dentry_name_sz,
           dentry_type,
           dentry_colour,
           dentry_did_left,
           dentry_did_right,
           dentry_did_root,
           0, 0, 0, 0, 0, 0, 0, 0, 0,
           dentry_start_sid,
           dentry_stream_sz,
           0
        ) * 2

    def __build_sat(self):
        # Build SAT
        book_sect_count = self.book_stream_len >> 9
        dir_sect_count  = len(self.dir_stream) >> 9

        total_sect_count     = book_sect_count + dir_sect_count
        SAT_sect_count       = 0
        MSAT_sect_count      = 0
        SAT_sect_count_limit = 109
        while total_sect_count > 128*SAT_sect_count or SAT_sect_count > SAT_sect_count_limit:
            SAT_sect_count   += 1
            total_sect_count += 1
            if SAT_sect_count > SAT_sect_count_limit:
                MSAT_sect_count      += 1
                total_sect_count     += 1
                SAT_sect_count_limit += 127


        SAT = [self.SID_FREE_SECTOR]*128*SAT_sect_count

        sect = 0
        while sect < book_sect_count - 1:
            self.book_stream_sect.append(sect)
            SAT[sect] = sect + 1
            sect += 1
        self.book_stream_sect.append(sect)
        SAT[sect] = self.SID_END_OF_CHAIN
        sect += 1

        while sect < book_sect_count + MSAT_sect_count:
            self.MSAT_sect_2nd.append(sect)
            SAT[sect] = self.SID_USED_BY_MSAT
            sect += 1

        while sect < book_sect_count + MSAT_sect_count + SAT_sect_count:
            self.SAT_sect.append(sect)
            SAT[sect] = self.SID_USED_BY_SAT
            sect += 1

        while sect < book_sect_count + MSAT_sect_count + SAT_sect_count + dir_sect_count - 1:
            self.dir_stream_sect.append(sect)
            SAT[sect] = sect + 1
            sect += 1
        self.dir_stream_sect.append(sect)
        SAT[sect] = self.SID_END_OF_CHAIN
        sect += 1

        self.packed_SAT = struct.pack('<%dl' % (SAT_sect_count*128), *SAT)

        MSAT_1st = [self.SID_FREE_SECTOR]*109
        for i, SAT_sect_num in zip(list(range(0, 109)), self.SAT_sect):
            MSAT_1st[i] = SAT_sect_num
        self.packed_MSAT_1st = struct.pack('<109l', *MSAT_1st)

        MSAT_2nd = [self.SID_FREE_SECTOR]*128*MSAT_sect_count
        if MSAT_sect_count > 0:
            MSAT_2nd[- 1] = self.SID_END_OF_CHAIN

        i = 109
        msat_sect = 0
        sid_num = 0
        while i < SAT_sect_count:
            if (sid_num + 1) % 128 == 0:
                #print 'link: ',
                msat_sect += 1
                if msat_sect < len(self.MSAT_sect_2nd):
                    MSAT_2nd[sid_num] = self.MSAT_sect_2nd[msat_sect]
            else:
                #print 'sid: ',
                MSAT_2nd[sid_num] = self.SAT_sect[i]
                i += 1
            #print sid_num, MSAT_2nd[sid_num]
            sid_num += 1

        self.packed_MSAT_2nd = struct.pack('<%dl' % (MSAT_sect_count*128), *MSAT_2nd)

        #print vars()
        #print zip(range(0, sect), SAT)
        #print self.book_stream_sect
        #print self.MSAT_sect_2nd
        #print MSAT_2nd
        #print self.SAT_sect
        #print self.dir_stream_sect


    def __build_header(self):
        doc_magic             = b'\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1'
        file_uid              = b'\x00'*16
        rev_num               = b'\x3E\x00'
        ver_num               = b'\x03\x00'
        byte_order            = b'\xFE\xFF'
        log_sect_size         = struct.pack('<H', 9)
        log_short_sect_size   = struct.pack('<H', 6)
        not_used0             = b'\x00'*10
        total_sat_sectors     = struct.pack('<L', len(self.SAT_sect))
        dir_start_sid         = struct.pack('<l', self.dir_stream_sect[0])
        not_used1             = b'\x00'*4
        min_stream_size       = struct.pack('<L', 0x1000)
        ssat_start_sid        = struct.pack('<l', -2)
        total_ssat_sectors    = struct.pack('<L', 0)

        if len(self.MSAT_sect_2nd) == 0:
            msat_start_sid        = struct.pack('<l', -2)
        else:
            msat_start_sid        = struct.pack('<l', self.MSAT_sect_2nd[0])

        total_msat_sectors    = struct.pack('<L', len(self.MSAT_sect_2nd))

        self.header =       b''.join([  doc_magic,
                                        file_uid,
                                        rev_num,
                                        ver_num,
                                        byte_order,
                                        log_sect_size,
                                        log_short_sect_size,
                                        not_used0,
                                        total_sat_sectors,
                                        dir_start_sid,
                                        not_used1,
                                        min_stream_size,
                                        ssat_start_sid,
                                        total_ssat_sectors,
                                        msat_start_sid,
                                        total_msat_sectors
                                    ])


    def save(self, file_name_or_filelike_obj, stream):
        # 1. Align stream on 0x1000 boundary (and therefore on sector boundary)
        padding = b'\x00' * (0x1000 - (len(stream) % 0x1000))
        self.book_stream_len = len(stream) + len(padding)

        self.__build_directory()
        self.__build_sat()
        self.__build_header()

        f = file_name_or_filelike_obj
        we_own_it = not hasattr(f, 'write')
        if we_own_it:
            f = open(file_name_or_filelike_obj, 'wb')
        f.write(self.header)
        f.write(self.packed_MSAT_1st)
        f.write(stream)
        f.write(padding)
        f.write(self.packed_MSAT_2nd)
        f.write(self.packed_SAT)
        f.write(self.dir_stream)
        if we_own_it:
            f.close()

########NEW FILE########
__FILENAME__ = ExcelFormula
from . import ExcelFormulaParser, ExcelFormulaLexer
import struct
from .antlr import ANTLRException


class Formula(object):
    __slots__ = ["__s", "__parser", "__sheet_refs", "__xcall_refs"]


    def __init__(self, s):
        try:
            self.__s = s
            lexer = ExcelFormulaLexer.Lexer(s)
            self.__parser = ExcelFormulaParser.Parser(lexer)
            self.__parser.formula()
            self.__sheet_refs = self.__parser.sheet_references
            self.__xcall_refs = self.__parser.xcall_references
        except ANTLRException as e:
            # print e
            raise ExcelFormulaParser.FormulaParseException("can't parse formula " + s)

    def get_references(self):
        return self.__sheet_refs, self.__xcall_refs

    def patch_references(self, patches):
        for offset, idx in patches:
            self.__parser.rpn = self.__parser.rpn[:offset] + struct.pack('<H', idx) + self.__parser.rpn[offset+2:]

    def text(self):
        return self.__s

    def rpn(self):
        '''
        Offset    Size    Contents
        0         2       Size of the following formula data (sz)
        2         sz      Formula data (RPN token array)
        [2+sz]    var.    (optional) Additional data for specific tokens

        '''
        return struct.pack("<H", len(self.__parser.rpn)) + self.__parser.rpn


########NEW FILE########
__FILENAME__ = ExcelFormulaLexer
import sys
from .antlr import EOF, CommonToken as Tok, TokenStream, TokenStreamException
import struct
from . import ExcelFormulaParser
from re import compile as recompile, match, LOCALE, UNICODE, IGNORECASE, VERBOSE


int_const_pattern = r"\d+\b"
flt_const_pattern = r"""
    (?:
        (?: \d* \. \d+ ) # .1 .12 .123 etc 9.1 etc 98.1 etc
        |
        (?: \d+ \. ) # 1. 12. 123. etc
    )
    # followed by optional exponent part
    (?: [Ee] [+-]? \d+ ) ?
    """
str_const_pattern = r'"(?:[^"]|"")*"'
#range2d_pattern   = recompile(r"\$?[A-I]?[A-Z]\$?\d+:\$?[A-I]?[A-Z]\$?\d+"
ref2d_r1c1_pattern = r"[Rr]0*[1-9][0-9]*[Cc]0*[1-9][0-9]*"
ref2d_pattern     = r"\$?[A-I]?[A-Z]\$?0*[1-9][0-9]*"
true_pattern      = r"TRUE\b"
false_pattern     = r"FALSE\b"
if_pattern        = r"IF\b"
choose_pattern    = r"CHOOSE\b"
name_pattern      = r"\w[\.\w]*"
quotename_pattern = r"'(?:[^']|'')*'" #### It's essential that this bracket be non-grouping.
ne_pattern        = r"<>"
ge_pattern        = r">="
le_pattern        = r"<="

pattern_type_tuples = (
    (flt_const_pattern, ExcelFormulaParser.NUM_CONST),
    (int_const_pattern, ExcelFormulaParser.INT_CONST),
    (str_const_pattern, ExcelFormulaParser.STR_CONST),
#    (range2d_pattern  , ExcelFormulaParser.RANGE2D),
    (ref2d_r1c1_pattern, ExcelFormulaParser.REF2D_R1C1),
    (ref2d_pattern    , ExcelFormulaParser.REF2D),
    (true_pattern     , ExcelFormulaParser.TRUE_CONST),
    (false_pattern    , ExcelFormulaParser.FALSE_CONST),
    (if_pattern       , ExcelFormulaParser.FUNC_IF),
    (choose_pattern   , ExcelFormulaParser.FUNC_CHOOSE),
    (name_pattern     , ExcelFormulaParser.NAME),
    (quotename_pattern, ExcelFormulaParser.QUOTENAME),
    (ne_pattern,        ExcelFormulaParser.NE),
    (ge_pattern,        ExcelFormulaParser.GE),
    (le_pattern,        ExcelFormulaParser.LE),
)

_re = recompile(
    '(' + ')|('.join([i[0] for i in pattern_type_tuples]) + ')',
    VERBOSE+LOCALE+IGNORECASE)

_toktype = [None] + [i[1] for i in pattern_type_tuples]
# need dummy at start because re.MatchObject.lastindex counts from 1

single_char_lookup = {
    '=': ExcelFormulaParser.EQ,
    '<': ExcelFormulaParser.LT,
    '>': ExcelFormulaParser.GT,
    '+': ExcelFormulaParser.ADD,
    '-': ExcelFormulaParser.SUB,
    '*': ExcelFormulaParser.MUL,
    '/': ExcelFormulaParser.DIV,
    ':': ExcelFormulaParser.COLON,
    ';': ExcelFormulaParser.SEMICOLON,
    ',': ExcelFormulaParser.COMMA,
    '(': ExcelFormulaParser.LP,
    ')': ExcelFormulaParser.RP,
    '&': ExcelFormulaParser.CONCAT,
    '%': ExcelFormulaParser.PERCENT,
    '^': ExcelFormulaParser.POWER,
    '!': ExcelFormulaParser.BANG,
    }

class Lexer(TokenStream):
    def __init__(self, text):
        self._text = text[:]
        self._pos = 0
        self._line = 0

    def isEOF(self):
        return len(self._text) <= self._pos

    def curr_ch(self):
        return self._text[self._pos]

    def next_ch(self, n = 1):
        self._pos += n

    def is_whitespace(self):
        return self.curr_ch() in " \t\n\r\f\v"

    def match_pattern(self):
        m = _re.match(self._text, self._pos)
        if not m:
            return None
        self._pos = m.end(0)
        return Tok(type = _toktype[m.lastindex], text = m.group(0), col = m.start(0) + 1)

    def nextToken(self):
        # skip whitespace
        while not self.isEOF() and self.is_whitespace():
            self.next_ch()
        if self.isEOF():
            return Tok(type = EOF)
        # first, try to match token with 2 or more chars
        t = self.match_pattern()
        if t:
            return t
        # second, we want 1-char tokens
        te = self.curr_ch()
        try:
            ty = single_char_lookup[te]
        except KeyError:
            raise TokenStreamException(
                "Unexpected char %r in column %u." % (self.curr_ch(), self._pos))
        self.next_ch()
        return Tok(type=ty, text=te, col=self._pos)

if __name__ == '__main__':
    try:
        for t in Lexer(""" 1.23 456 "abcd" R2C2 a1 iv65536 true false if choose a_name 'qname' <> >= <= """):
            print(t)
    except TokenStreamException as e:
        print("error:", e)

########NEW FILE########
__FILENAME__ = ExcelFormulaParser
### $ANTLR 2.7.7 (20060930): "xlwt/excel-formula.g" -> "ExcelFormulaParser.py"$
### import antlr and other modules ..
import sys
from . import antlr

### header action >>>
import struct
from . import Utils
from .UnicodeUtils import upack1
from .ExcelMagic import *

_RVAdelta =     {"R": 0, "V": 0x20, "A": 0x40}
_RVAdeltaRef =  {"R": 0, "V": 0x20, "A": 0x40, "D": 0x20}
_RVAdeltaArea = {"R": 0, "V": 0x20, "A": 0x40, "D": 0}


class FormulaParseException(Exception):
    """
    An exception indicating that a Formula could not be successfully parsed.
    """
### header action <<<
### preamble action>>>

### preamble action <<<

### import antlr.Token
from .antlr import Token
### >>>The Known Token Types <<<
SKIP                = antlr.SKIP
INVALID_TYPE        = antlr.INVALID_TYPE
EOF_TYPE            = antlr.EOF_TYPE
EOF                 = antlr.EOF
NULL_TREE_LOOKAHEAD = antlr.NULL_TREE_LOOKAHEAD
MIN_USER_TYPE       = antlr.MIN_USER_TYPE
TRUE_CONST = 4
FALSE_CONST = 5
STR_CONST = 6
NUM_CONST = 7
INT_CONST = 8
FUNC_IF = 9
FUNC_CHOOSE = 10
NAME = 11
QUOTENAME = 12
EQ = 13
NE = 14
GT = 15
LT = 16
GE = 17
LE = 18
ADD = 19
SUB = 20
MUL = 21
DIV = 22
POWER = 23
PERCENT = 24
LP = 25
RP = 26
LB = 27
RB = 28
COLON = 29
COMMA = 30
SEMICOLON = 31
REF2D = 32
REF2D_R1C1 = 33
BANG = 34
CONCAT = 35

class Parser(antlr.LLkParser):
    ### user action >>>
    ### user action <<<

    def __init__(self, *args, **kwargs):
        antlr.LLkParser.__init__(self, *args, **kwargs)
        self.tokenNames = _tokenNames
        ### __init__ header action >>>
        self.rpn = b""
        self.sheet_references = []
        self.xcall_references = []
        ### __init__ header action <<<

    def formula(self):
        self.expr("V")

    def expr(self, arg_type):
        self.prec0_expr(arg_type)
        while True:
            if ((self.LA(1) >= EQ and self.LA(1) <= LE)):
                pass
                la1 = self.LA(1)
                if False:
                    pass
                elif la1 and la1 in [EQ]:
                    pass
                    self.match(EQ)
                    op = struct.pack('B', ptgEQ)
                elif la1 and la1 in [NE]:
                    pass
                    self.match(NE)
                    op = struct.pack('B', ptgNE)
                elif la1 and la1 in [GT]:
                    pass
                    self.match(GT)
                    op = struct.pack('B', ptgGT)
                elif la1 and la1 in [LT]:
                    pass
                    self.match(LT)
                    op = struct.pack('B', ptgLT)
                elif la1 and la1 in [GE]:
                    pass
                    self.match(GE)
                    op = struct.pack('B', ptgGE)
                elif la1 and la1 in [LE]:
                    pass
                    self.match(LE)
                    op = struct.pack('B', ptgLE)
                else:
                        raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                self.prec0_expr(arg_type)
                self.rpn += op
            else:
                break


    def prec0_expr(self,
        arg_type
    ):

        pass
        self.prec1_expr(arg_type)
        while True:
            if (self.LA(1)==CONCAT):
                pass
                pass
                self.match(CONCAT)
                op = struct.pack('B', ptgConcat)
                self.prec1_expr(arg_type)
                self.rpn += op
            else:
                break


    def prec1_expr(self,
        arg_type
    ):

        pass
        self.prec2_expr(arg_type)
        while True:
            if (self.LA(1)==ADD or self.LA(1)==SUB):
                pass
                la1 = self.LA(1)
                if False:
                    pass
                elif la1 and la1 in [ADD]:
                    pass
                    self.match(ADD)
                    op = struct.pack('B', ptgAdd)
                elif la1 and la1 in [SUB]:
                    pass
                    self.match(SUB)
                    op = struct.pack('B', ptgSub)
                else:
                        raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                self.prec2_expr(arg_type)
                self.rpn += op;
                          # print "**prec1_expr4 %s" % arg_type
            else:
                break


    def prec2_expr(self,
        arg_type
    ):

        pass
        self.prec3_expr(arg_type)
        while True:
            if (self.LA(1)==MUL or self.LA(1)==DIV):
                pass
                la1 = self.LA(1)
                if False:
                    pass
                elif la1 and la1 in [MUL]:
                    pass
                    self.match(MUL)
                    op = struct.pack('B', ptgMul)
                elif la1 and la1 in [DIV]:
                    pass
                    self.match(DIV)
                    op = struct.pack('B', ptgDiv)
                else:
                        raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                self.prec3_expr(arg_type)
                self.rpn += op
            else:
                break


    def prec3_expr(self,
        arg_type
    ):

        pass
        self.prec4_expr(arg_type)
        while True:
            if (self.LA(1)==POWER):
                pass
                pass
                self.match(POWER)
                op = struct.pack('B', ptgPower)
                self.prec4_expr(arg_type)
                self.rpn += op
            else:
                break


    def prec4_expr(self,
        arg_type
    ):

        pass
        self.prec5_expr(arg_type)
        la1 = self.LA(1)
        if False:
            pass
        elif la1 and la1 in [PERCENT]:
            pass
            self.match(PERCENT)
            self.rpn += struct.pack('B', ptgPercent)
        elif la1 and la1 in [EOF,EQ,NE,GT,LT,GE,LE,ADD,SUB,MUL,DIV,POWER,RP,COMMA,SEMICOLON,CONCAT]:
            pass
        else:
                raise antlr.NoViableAltException(self.LT(1), self.getFilename())


    def prec5_expr(self,
        arg_type
    ):

        la1 = self.LA(1)
        if False:
            pass
        elif la1 and la1 in [TRUE_CONST,FALSE_CONST,STR_CONST,NUM_CONST,INT_CONST,FUNC_IF,FUNC_CHOOSE,NAME,QUOTENAME,LP,REF2D]:
            pass
            self.primary(arg_type)
        elif la1 and la1 in [SUB]:
            pass
            self.match(SUB)
            self.primary(arg_type)
            self.rpn += struct.pack('B', ptgUminus)
        else:
                raise antlr.NoViableAltException(self.LT(1), self.getFilename())


    def primary(self,
        arg_type
    ):

        str_tok = None
        int_tok = None
        num_tok = None
        ref2d_tok = None
        ref2d1_tok = None
        ref2d2_tok = None
        ref3d_ref2d = None
        ref3d_ref2d2 = None
        name_tok = None
        func_tok = None
        la1 = self.LA(1)
        if False:
            pass
        elif la1 and la1 in [TRUE_CONST]:
            pass
            self.match(TRUE_CONST)
            self.rpn += struct.pack("2B", ptgBool, 1)
        elif la1 and la1 in [FALSE_CONST]:
            pass
            self.match(FALSE_CONST)
            self.rpn += struct.pack("2B", ptgBool, 0)
        elif la1 and la1 in [STR_CONST]:
            pass
            str_tok = self.LT(1)
            self.match(STR_CONST)
            self.rpn += struct.pack("B", ptgStr) + upack1(str_tok.text[1:-1].replace("\"\"", "\""))
        elif la1 and la1 in [NUM_CONST]:
            pass
            num_tok = self.LT(1)
            self.match(NUM_CONST)
            self.rpn += struct.pack("<Bd", ptgNum, float(num_tok.text))
        elif la1 and la1 in [FUNC_IF]:
            pass
            self.match(FUNC_IF)
            self.match(LP)
            self.expr("V")
            la1 = self.LA(1)
            if False:
                pass
            elif la1 and la1 in [SEMICOLON]:
                pass
                self.match(SEMICOLON)
            elif la1 and la1 in [COMMA]:
                pass
                self.match(COMMA)
            else:
                    raise antlr.NoViableAltException(self.LT(1), self.getFilename())

            self.rpn += struct.pack("<BBH", ptgAttr, 0x02, 0) # tAttrIf
            pos0 = len(self.rpn) - 2
            self.expr(arg_type)
            la1 = self.LA(1)
            if False:
                pass
            elif la1 and la1 in [SEMICOLON]:
                pass
                self.match(SEMICOLON)
            elif la1 and la1 in [COMMA]:
                pass
                self.match(COMMA)
            else:
                    raise antlr.NoViableAltException(self.LT(1), self.getFilename())

            self.rpn += struct.pack("<BBH", ptgAttr, 0x08, 0) # tAttrSkip
            pos1 = len(self.rpn) - 2
            self.rpn = self.rpn[:pos0] + struct.pack("<H", pos1-pos0) + self.rpn[pos0+2:]
            self.expr(arg_type)
            self.match(RP)
            self.rpn += struct.pack("<BBH", ptgAttr, 0x08, 3) # tAttrSkip
            self.rpn += struct.pack("<BBH", ptgFuncVarR, 3, 1) # 3 = nargs, 1 = IF func
            pos2 = len(self.rpn)
            self.rpn = self.rpn[:pos1] + struct.pack("<H", pos2-(pos1+2)-1) + self.rpn[pos1+2:]
        elif la1 and la1 in [FUNC_CHOOSE]:
            pass
            self.match(FUNC_CHOOSE)
            arg_type = b"R"
            rpn_chunks = []
            self.match(LP)
            self.expr("V")
            rpn_start = len(self.rpn)
            ref_markers = [len(self.sheet_references)]
            while True:
                if (self.LA(1)==COMMA or self.LA(1)==SEMICOLON):
                    pass
                    la1 = self.LA(1)
                    if False:
                        pass
                    elif la1 and la1 in [SEMICOLON]:
                        pass
                        self.match(SEMICOLON)
                    elif la1 and la1 in [COMMA]:
                        pass
                        self.match(COMMA)
                    else:
                            raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                    mark = len(self.rpn)
                    la1 = self.LA(1)
                    if False:
                        pass
                    elif la1 and la1 in [TRUE_CONST,FALSE_CONST,STR_CONST,NUM_CONST,INT_CONST,FUNC_IF,FUNC_CHOOSE,NAME,QUOTENAME,SUB,LP,REF2D]:
                        pass
                        self.expr(arg_type)
                    elif la1 and la1 in [RP,COMMA,SEMICOLON]:
                        pass
                        self.rpn += struct.pack("B", ptgMissArg)
                    else:
                            raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                    rpn_chunks.append(self.rpn[mark:])
                    ref_markers.append(len(self.sheet_references))
                else:
                    break

            self.match(RP)
            self.rpn = self.rpn[:rpn_start]
            nc = len(rpn_chunks)
            chunklens = [len(chunk) for chunk in rpn_chunks]
            skiplens = [0] * nc
            skiplens[-1] = 3
            for ic in range(nc-1, 0, -1):
                skiplens[ic-1] = skiplens[ic] + chunklens[ic] + 4
            jump_pos = [2 * nc + 2]
            for ic in range(nc):
                jump_pos.append(jump_pos[-1] + chunklens[ic] + 4)
            chunk_shift = 2 * nc + 6 # size of tAttrChoose
            for ic in range(nc):
                for refx in range(ref_markers[ic], ref_markers[ic+1]):
                    ref = self.sheet_references[refx]
                    self.sheet_references[refx] = (ref[0], ref[1], ref[2] + chunk_shift)
                chunk_shift += 4 # size of tAttrSkip
            choose_rpn = []
            choose_rpn.append(struct.pack("<BBH", ptgAttr, 0x04, nc)) # 0x04 is tAttrChoose
            choose_rpn.append(struct.pack("<%dH" % (nc+1), *jump_pos))
            for ic in range(nc):
                choose_rpn.append(rpn_chunks[ic])
                choose_rpn.append(struct.pack("<BBH", ptgAttr, 0x08, skiplens[ic])) # 0x08 is tAttrSkip
            choose_rpn.append(struct.pack("<BBH", ptgFuncVarV, nc+1, 100)) # 100 is CHOOSE fn
            self.rpn += b"".join(choose_rpn)
        elif la1 and la1 in [LP]:
            pass
            self.match(LP)
            self.expr(arg_type)
            self.match(RP)
            self.rpn += struct.pack("B", ptgParen)
        else:
            if (self.LA(1)==INT_CONST) and (_tokenSet_0.member(self.LA(2))):
                pass
                int_tok = self.LT(1)
                self.match(INT_CONST)
                # print "**int_const", int_tok.text
                int_value = int(int_tok.text)
                if int_value <= 65535:
                    self.rpn += struct.pack("<BH", ptgInt, int_value)
                else:
                    self.rpn += struct.pack("<Bd", ptgNum, float(int_value))
            elif (self.LA(1)==REF2D) and (_tokenSet_0.member(self.LA(2))):
                pass
                ref2d_tok = self.LT(1)
                self.match(REF2D)
                # print "**ref2d %s %s" % (ref2d_tok.text, arg_type)
                r, c = Utils.cell_to_packed_rowcol(ref2d_tok.text)
                ptg = ptgRefR + _RVAdeltaRef[arg_type]
                self.rpn += struct.pack("<B2H", ptg, r, c)
            elif (self.LA(1)==REF2D) and (self.LA(2)==COLON):
                pass
                ref2d1_tok = self.LT(1)
                self.match(REF2D)
                self.match(COLON)
                ref2d2_tok = self.LT(1)
                self.match(REF2D)
                r1, c1 = Utils.cell_to_packed_rowcol(ref2d1_tok.text)
                r2, c2 = Utils.cell_to_packed_rowcol(ref2d2_tok.text)
                ptg = ptgAreaR + _RVAdeltaArea[arg_type]
                self.rpn += struct.pack("<B4H", ptg, r1, r2, c1, c2)
            elif (self.LA(1)==INT_CONST or self.LA(1)==NAME or self.LA(1)==QUOTENAME) and (self.LA(2)==COLON or self.LA(2)==BANG):
                pass
                sheet1=self.sheet()
                sheet2 = sheet1
                la1 = self.LA(1)
                if False:
                    pass
                elif la1 and la1 in [COLON]:
                    pass
                    self.match(COLON)
                    sheet2=self.sheet()
                elif la1 and la1 in [BANG]:
                    pass
                else:
                        raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                self.match(BANG)
                ref3d_ref2d = self.LT(1)
                self.match(REF2D)
                ptg = ptgRef3dR + _RVAdeltaRef[arg_type]
                rpn_ref2d = b""
                r1, c1 = Utils.cell_to_packed_rowcol(ref3d_ref2d.text)
                rpn_ref2d = struct.pack("<3H", 0x0000, r1, c1)
                la1 = self.LA(1)
                if False:
                    pass
                elif la1 and la1 in [COLON]:
                    pass
                    self.match(COLON)
                    ref3d_ref2d2 = self.LT(1)
                    self.match(REF2D)
                    ptg = ptgArea3dR + _RVAdeltaArea[arg_type]
                    r2, c2 = Utils.cell_to_packed_rowcol(ref3d_ref2d2.text)
                    rpn_ref2d = struct.pack("<5H", 0x0000, r1, r2, c1, c2)
                elif la1 and la1 in [EOF,EQ,NE,GT,LT,GE,LE,ADD,SUB,MUL,DIV,POWER,PERCENT,RP,COMMA,SEMICOLON,CONCAT]:
                    pass
                else:
                    raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                self.rpn += struct.pack("<B", ptg)
                self.sheet_references.append((sheet1, sheet2, len(self.rpn)))
                self.rpn += rpn_ref2d
            elif (self.LA(1)==NAME) and (_tokenSet_0.member(self.LA(2))):
                name_tok = self.LT(1)
                self.match(NAME)
                raise Exception("[formula] found unexpected NAME token (%r)" % name_tok.txt)
                # #### TODO: handle references to defined names here
            elif (self.LA(1)==NAME) and (self.LA(2)==LP):
                func_tok = self.LT(1)
                self.match(NAME)
                func_toku = func_tok.text.upper()
                if func_toku in all_funcs_by_name:
                    (opcode,
                    min_argc,
                    max_argc,
                    func_type,
                    arg_type_str) = all_funcs_by_name[func_toku]
                    arg_type_list = list(arg_type_str)
                else:
                    raise Exception("[formula] unknown function (%s)" % func_tok.text)
                # print "**func_tok1 %s %s" % (func_toku, func_type)
                xcall = opcode < 0
                if xcall:
                    # The name of the add-in function is passed as the 1st arg
                    # of the hidden XCALL function
                    self.xcall_references.append((func_toku, len(self.rpn) + 1))
                    self.rpn += struct.pack("<BHHH",
                        ptgNameXR,
                        0xadde, # ##PATCHME## index to REF entry in EXTERNSHEET record
                        0xefbe, # ##PATCHME## one-based index to EXTERNNAME record
                        0x0000) # unused
                self.match(LP)
                arg_count=self.expr_list(arg_type_list, min_argc, max_argc)
                self.match(RP)
                if arg_count > max_argc or arg_count < min_argc:
                    raise Exception("%d parameters for function: %s" % (arg_count, func_tok.text))
                if xcall:
                    func_ptg = ptgFuncVarR + _RVAdelta[func_type]
                    self.rpn += struct.pack("<2BH", func_ptg, arg_count + 1, 255) # 255 is magic XCALL function
                elif min_argc == max_argc:
                    func_ptg = ptgFuncR + _RVAdelta[func_type]
                    self.rpn += struct.pack("<BH", func_ptg, opcode)
                elif arg_count == 1 and func_tok.text.upper() == "SUM":
                    self.rpn += struct.pack("<BBH", ptgAttr, 0x10, 0) # tAttrSum
                else:
                    func_ptg = ptgFuncVarR + _RVAdelta[func_type]
                    self.rpn += struct.pack("<2BH", func_ptg, arg_count, opcode)
            else:
                raise antlr.NoViableAltException(self.LT(1), self.getFilename())

    def sheet(self):
        ref = None
        sheet_ref_name = None
        sheet_ref_int = None
        sheet_ref_quote = None
        la1 = self.LA(1)
        if False:
            pass
        elif la1 and la1 in [NAME]:
            sheet_ref_name = self.LT(1)
            self.match(NAME)
            ref = sheet_ref_name.text
        elif la1 and la1 in [INT_CONST]:
            sheet_ref_int = self.LT(1)
            self.match(INT_CONST)
            ref = sheet_ref_int.text
        elif la1 and la1 in [QUOTENAME]:
            sheet_ref_quote = self.LT(1)
            self.match(QUOTENAME)
            ref = sheet_ref_quote.text[1:-1].replace("''", "'")
        else:
                raise antlr.NoViableAltException(self.LT(1), self.getFilename())

        return ref

    def expr_list(self,
        arg_type_list, min_argc, max_argc
    ):
        arg_cnt = None

        arg_cnt = 0
        arg_type = arg_type_list[arg_cnt]
        # print "**expr_list1[%d] req=%s" % (arg_cnt, arg_type)
        la1 = self.LA(1)
        if False:
            pass
        elif la1 and la1 in [TRUE_CONST,FALSE_CONST,STR_CONST,NUM_CONST,INT_CONST,FUNC_IF,FUNC_CHOOSE,NAME,QUOTENAME,SUB,LP,REF2D]:
            pass
            self.expr(arg_type)
            arg_cnt += 1
            while True:
                if (self.LA(1)==COMMA or self.LA(1)==SEMICOLON):
                    pass
                    if arg_cnt < len(arg_type_list):
                        arg_type = arg_type_list[arg_cnt]
                    else:
                        arg_type = arg_type_list[-1]
                    if arg_type == "+":
                        arg_type = arg_type_list[-2]
                    # print "**expr_list2[%d] req=%s" % (arg_cnt, arg_type)
                    la1 = self.LA(1)
                    if False:
                        pass
                    elif la1 and la1 in [SEMICOLON]:
                        pass
                        self.match(SEMICOLON)
                    elif la1 and la1 in [COMMA]:
                        pass
                        self.match(COMMA)
                    else:
                        raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                    la1 = self.LA(1)
                    if False:
                        pass
                    elif la1 and la1 in [TRUE_CONST,FALSE_CONST,STR_CONST,NUM_CONST,INT_CONST,FUNC_IF,FUNC_CHOOSE,NAME,QUOTENAME,SUB,LP,REF2D]:
                        pass
                        self.expr(arg_type)
                    elif la1 and la1 in [RP,COMMA,SEMICOLON]:
                        pass
                        self.rpn += struct.pack("B", ptgMissArg)
                    else:
                        raise antlr.NoViableAltException(self.LT(1), self.getFilename())

                    arg_cnt += 1
                else:
                    break

        elif la1 and la1 in [RP]:
            pass
        else:
            raise antlr.NoViableAltException(self.LT(1), self.getFilename())

        return arg_cnt


_tokenNames = [
    "<0>",
    "EOF",
    "<2>",
    "NULL_TREE_LOOKAHEAD",
    "TRUE_CONST",
    "FALSE_CONST",
    "STR_CONST",
    "NUM_CONST",
    "INT_CONST",
    "FUNC_IF",
    "FUNC_CHOOSE",
    "NAME",
    "QUOTENAME",
    "EQ",
    "NE",
    "GT",
    "LT",
    "GE",
    "LE",
    "ADD",
    "SUB",
    "MUL",
    "DIV",
    "POWER",
    "PERCENT",
    "LP",
    "RP",
    "LB",
    "RB",
    "COLON",
    "COMMA",
    "SEMICOLON",
    "REF2D",
    "REF2D_R1C1",
    "BANG",
    "CONCAT"
]


### generate bit set
def mk_tokenSet_0():
    ### var1
    data = [ 37681618946, 0]
    return data
_tokenSet_0 = antlr.BitSet(mk_tokenSet_0())


########NEW FILE########
__FILENAME__ = ExcelMagic
""" lots of Excel Magic Numbers """

# Boundaries BIFF8+

MAX_ROW = 65536
MAX_COL = 256


biff_records = {
    0x0000: "DIMENSIONS",
    0x0001: "BLANK",
    0x0002: "INTEGER",
    0x0003: "NUMBER",
    0x0004: "LABEL",
    0x0005: "BOOLERR",
    0x0006: "FORMULA",
    0x0007: "STRING",
    0x0008: "ROW",
    0x0009: "BOF",
    0x000A: "EOF",
    0x000B: "INDEX",
    0x000C: "CALCCOUNT",
    0x000D: "CALCMODE",
    0x000E: "PRECISION",
    0x000F: "REFMODE",
    0x0010: "DELTA",
    0x0011: "ITERATION",
    0x0012: "PROTECT",
    0x0013: "PASSWORD",
    0x0014: "HEADER",
    0x0015: "FOOTER",
    0x0016: "EXTERNCOUNT",
    0x0017: "EXTERNSHEET",
    0x0018: "NAME",
    0x0019: "WINDOWPROTECT",
    0x001A: "VERTICALPAGEBREAKS",
    0x001B: "HORIZONTALPAGEBREAKS",
    0x001C: "NOTE",
    0x001D: "SELECTION",
    0x001E: "FORMAT",
    0x001F: "FORMATCOUNT",
    0x0020: "COLUMNDEFAULT",
    0x0021: "ARRAY",
    0x0022: "1904",
    0x0023: "EXTERNNAME",
    0x0024: "COLWIDTH",
    0x0025: "DEFAULTROWHEIGHT",
    0x0026: "LEFTMARGIN",
    0x0027: "RIGHTMARGIN",
    0x0028: "TOPMARGIN",
    0x0029: "BOTTOMMARGIN",
    0x002A: "PRINTHEADERS",
    0x002B: "PRINTGRIDLINES",
    0x002F: "FILEPASS",
    0x0031: "FONT",
    0x0036: "TABLE",
    0x003C: "CONTINUE",
    0x003D: "WINDOW1",
    0x003E: "WINDOW2",
    0x0040: "BACKUP",
    0x0041: "PANE",
    0x0042: "CODEPAGE",
    0x0043: "XF",
    0x0044: "IXFE",
    0x0045: "EFONT",
    0x004D: "PLS",
    0x0050: "DCON",
    0x0051: "DCONREF",
    0x0053: "DCONNAME",
    0x0055: "DEFCOLWIDTH",
    0x0056: "BUILTINFMTCNT",
    0x0059: "XCT",
    0x005A: "CRN",
    0x005B: "FILESHARING",
    0x005C: "WRITEACCESS",
    0x005D: "OBJ",
    0x005E: "UNCALCED",
    0x005F: "SAFERECALC",
    0x0060: "TEMPLATE",
    0x0063: "OBJPROTECT",
    0x007D: "COLINFO",
    0x007E: "RK",
    0x007F: "IMDATA",
    0x0080: "GUTS",
    0x0081: "WSBOOL",
    0x0082: "GRIDSET",
    0x0083: "HCENTER",
    0x0084: "VCENTER",
    0x0085: "BOUNDSHEET",
    0x0086: "WRITEPROT",
    0x0087: "ADDIN",
    0x0088: "EDG",
    0x0089: "PUB",
    0x008C: "COUNTRY",
    0x008D: "HIDEOBJ",
    0x008E: "BUNDLESOFFSET",
    0x008F: "BUNDLEHEADER",
    0x0090: "SORT",
    0x0091: "SUB",
    0x0092: "PALETTE",
    0x0093: "STYLE",
    0x0094: "LHRECORD",
    0x0095: "LHNGRAPH",
    0x0096: "SOUND",
    0x0098: "LPR",
    0x0099: "STANDARDWIDTH",
    0x009A: "FNGROUPNAME",
    0x009B: "FILTERMODE",
    0x009C: "FNGROUPCOUNT",
    0x009D: "AUTOFILTERINFO",
    0x009E: "AUTOFILTER",
    0x00A0: "SCL",
    0x00A1: "SETUP",
    0x00A9: "COORDLIST",
    0x00AB: "GCW",
    0x00AE: "SCENMAN",
    0x00AF: "SCENARIO",
    0x00B0: "SXVIEW",
    0x00B1: "SXVD",
    0x00B2: "SXVI",
    0x00B4: "SXIVD",
    0x00B5: "SXLI",
    0x00B6: "SXPI",
    0x00B8: "DOCROUTE",
    0x00B9: "RECIPNAME",
    0x00BC: "SHRFMLA",
    0x00BD: "MULRK",
    0x00BE: "MULBLANK",
    0x00C1: "MMS",
    0x00C2: "ADDMENU",
    0x00C3: "DELMENU",
    0x00C5: "SXDI",
    0x00C6: "SXDB",
    0x00C7: "SXFIELD",
    0x00C8: "SXINDEXLIST",
    0x00C9: "SXDOUBLE",
    0x00CD: "SXSTRING",
    0x00CE: "SXDATETIME",
    0x00D0: "SXTBL",
    0x00D1: "SXTBRGITEM",
    0x00D2: "SXTBPG",
    0x00D3: "OBPROJ",
    0x00D5: "SXIDSTM",
    0x00D6: "RSTRING",
    0x00D7: "DBCELL",
    0x00DA: "BOOKBOOL",
    0x00DC: "SXEXT|PARAMQRY",
    0x00DD: "SCENPROTECT",
    0x00DE: "OLESIZE",
    0x00DF: "UDDESC",
    0x00E0: "XF",
    0x00E1: "INTERFACEHDR",
    0x00E2: "INTERFACEEND",
    0x00E3: "SXVS",
    0x00E5: "MERGEDCELLS",
    0x00E9: "BITMAP",
    0x00EB: "MSODRAWINGGROUP",
    0x00EC: "MSODRAWING",
    0x00ED: "MSODRAWINGSELECTION",
    0x00F0: "SXRULE",
    0x00F1: "SXEX",
    0x00F2: "SXFILT",
    0x00F6: "SXNAME",
    0x00F7: "SXSELECT",
    0x00F8: "SXPAIR",
    0x00F9: "SXFMLA",
    0x00FB: "SXFORMAT",
    0x00FC: "SST",
    0x00FD: "LABELSST",
    0x00FF: "EXTSST",
    0x0100: "SXVDEX",
    0x0103: "SXFORMULA",
    0x0122: "SXDBEX",
    0x0137: "CHTRINSERT",
    0x0138: "CHTRINFO",
    0x013B: "CHTRCELLCONTENT",
    0x013D: "TABID",
    0x0140: "CHTRMOVERANGE",
    0x014D: "CHTRINSERTTAB",
    0x015F: "LABELRANGES",
    0x0160: "USESELFS",
    0x0161: "DSF",
    0x0162: "XL5MODIFY",
    0x0196: "CHTRHEADER",
    0x01A9: "USERBVIEW",
    0x01AA: "USERSVIEWBEGIN",
    0x01AB: "USERSVIEWEND",
    0x01AD: "QSI",
    0x01AE: "SUPBOOK",
    0x01AF: "PROT4REV",
    0x01B0: "CONDFMT",
    0x01B1: "CF",
    0x01B2: "DVAL",
    0x01B5: "DCONBIN",
    0x01B6: "TXO",
    0x01B7: "REFRESHALL",
    0x01B8: "HLINK",
    0x01BA: "CODENAME",
    0x01BB: "SXFDBTYPE",
    0x01BC: "PROT4REVPASS",
    0x01BE: "DV",
    0x01C0: "XL9FILE",
    0x01C1: "RECALCID",
    0x0200: "DIMENSIONS",
    0x0201: "BLANK",
    0x0203: "NUMBER",
    0x0204: "LABEL",
    0x0205: "BOOLERR",
    0x0206: "FORMULA",
    0x0207: "STRING",
    0x0208: "ROW",
    0x0209: "BOF",
    0x020B: "INDEX",
    0x0218: "NAME",
    0x0221: "ARRAY",
    0x0223: "EXTERNNAME",
    0x0225: "DEFAULTROWHEIGHT",
    0x0231: "FONT",
    0x0236: "TABLE",
    0x023E: "WINDOW2",
    0x0243: "XF",
    0x027E: "RK",
    0x0293: "STYLE",
    0x0406: "FORMULA",
    0x0409: "BOF",
    0x041E: "FORMAT",
    0x0443: "XF",
    0x04BC: "SHRFMLA",
    0x0800: "SCREENTIP",
    0x0803: "WEBQRYSETTINGS",
    0x0804: "WEBQRYTABLES",
    0x0809: "BOF",
    0x0862: "SHEETLAYOUT",
    0x0867: "SHEETPROTECTION",
    0x1001: "UNITS",
    0x1002: "ChartChart",
    0x1003: "ChartSeries",
    0x1006: "ChartDataformat",
    0x1007: "ChartLineformat",
    0x1009: "ChartMarkerformat",
    0x100A: "ChartAreaformat",
    0x100B: "ChartPieformat",
    0x100C: "ChartAttachedlabel",
    0x100D: "ChartSeriestext",
    0x1014: "ChartChartformat",
    0x1015: "ChartLegend",
    0x1016: "ChartSerieslist",
    0x1017: "ChartBar",
    0x1018: "ChartLine",
    0x1019: "ChartPie",
    0x101A: "ChartArea",
    0x101B: "ChartScatter",
    0x101C: "ChartChartline",
    0x101D: "ChartAxis",
    0x101E: "ChartTick",
    0x101F: "ChartValuerange",
    0x1020: "ChartCatserrange",
    0x1021: "ChartAxislineformat",
    0x1022: "ChartFormatlink",
    0x1024: "ChartDefaulttext",
    0x1025: "ChartText",
    0x1026: "ChartFontx",
    0x1027: "ChartObjectLink",
    0x1032: "ChartFrame",
    0x1033: "BEGIN",
    0x1034: "END",
    0x1035: "ChartPlotarea",
    0x103A: "Chart3D",
    0x103C: "ChartPicf",
    0x103D: "ChartDropbar",
    0x103E: "ChartRadar",
    0x103F: "ChartSurface",
    0x1040: "ChartRadararea",
    0x1041: "ChartAxisparent",
    0x1043: "ChartLegendxn",
    0x1044: "ChartShtprops",
    0x1045: "ChartSertocrt",
    0x1046: "ChartAxesused",
    0x1048: "ChartSbaseref",
    0x104A: "ChartSerparent",
    0x104B: "ChartSerauxtrend",
    0x104E: "ChartIfmt",
    0x104F: "ChartPos",
    0x1050: "ChartAlruns",
    0x1051: "ChartAI",
    0x105B: "ChartSerauxerrbar",
    0x105D: "ChartSerfmt",
    0x105F: "Chart3DDataFormat",
    0x1060: "ChartFbi",
    0x1061: "ChartBoppop",
    0x1062: "ChartAxcext",
    0x1063: "ChartDat",
    0x1064: "ChartPlotgrowth",
    0x1065: "ChartSiindex",
    0x1066: "ChartGelframe",
    0x1067: "ChartBoppcustom",
    0xFFFF: ""
}


all_funcs_by_name = {
    # Includes Analysis ToolPak aka ATP aka add-in aka xcall functions,
    # distinguished by -ve opcode.
    # name: (opcode, min # args, max # args, func return type, func arg types)
    # + in func arg types means more of the same.
    'ABS'         : ( 24, 1,  1, 'V', 'V'),
    'ACCRINT'     : ( -1, 6,  7, 'V', 'VVVVVVV'),
    'ACCRINTM'    : ( -1, 3,  5, 'V', 'VVVVV'),
    'ACOS'        : ( 99, 1,  1, 'V', 'V'),
    'ACOSH'       : (233, 1,  1, 'V', 'V'),
    'ADDRESS'     : (219, 2,  5, 'V', 'VVVVV'),
    'AMORDEGRC'   : ( -1, 7,  7, 'V', 'VVVVVVV'),
    'AMORLINC'    : ( -1, 7,  7, 'V', 'VVVVVVV'),
    'AND'         : ( 36, 1, 30, 'V', 'D+'),
    'AREAS'       : ( 75, 1,  1, 'V', 'R'),
    'ASC'         : (214, 1,  1, 'V', 'V'),
    'ASIN'        : ( 98, 1,  1, 'V', 'V'),
    'ASINH'       : (232, 1,  1, 'V', 'V'),
    'ATAN'        : ( 18, 1,  1, 'V', 'V'),
    'ATAN2'       : ( 97, 2,  2, 'V', 'VV'),
    'ATANH'       : (234, 1,  1, 'V', 'V'),
    'AVEDEV'      : (269, 1, 30, 'V', 'D+'),
    'AVERAGE'     : (  5, 1, 30, 'V', 'D+'),
    'AVERAGEA'    : (361, 1, 30, 'V', 'D+'),
    'BAHTTEXT'    : (368, 1,  1, 'V', 'V'),
    'BESSELI'     : ( -1, 2,  2, 'V', 'VV'),
    'BESSELJ'     : ( -1, 2,  2, 'V', 'VV'),
    'BESSELK'     : ( -1, 2,  2, 'V', 'VV'),
    'BESSELY'     : ( -1, 2,  2, 'V', 'VV'),
    'BETADIST'    : (270, 3,  5, 'V', 'VVVVV'),
    'BETAINV'     : (272, 3,  5, 'V', 'VVVVV'),
    'BIN2DEC'     : ( -1, 1,  1, 'V', 'V'),
    'BIN2HEX'     : ( -1, 1,  2, 'V', 'VV'),
    'BIN2OCT'     : ( -1, 1,  2, 'V', 'VV'),
    'BINOMDIST'   : (273, 4,  4, 'V', 'VVVV'),
    'CEILING'     : (288, 2,  2, 'V', 'VV'),
    'CELL'        : (125, 1,  2, 'V', 'VR'),
    'CHAR'        : (111, 1,  1, 'V', 'V'),
    'CHIDIST'     : (274, 2,  2, 'V', 'VV'),
    'CHIINV'      : (275, 2,  2, 'V', 'VV'),
    'CHITEST'     : (306, 2,  2, 'V', 'AA'),
    'CHOOSE'      : (100, 2, 30, 'R', 'VR+'),
    'CLEAN'       : (162, 1,  1, 'V', 'V'),
    'CODE'        : (121, 1,  1, 'V', 'V'),
    'COLUMN'      : (  9, 0,  1, 'V', 'R'),
    'COLUMNS'     : ( 77, 1,  1, 'V', 'R'),
    'COMBIN'      : (276, 2,  2, 'V', 'VV'),
    'COMPLEX'     : ( -1, 2,  3, 'V', 'VVV'),
    'CONCATENATE' : (336, 1, 30, 'V', 'V+'),
    'CONFIDENCE'  : (277, 3,  3, 'V', 'VVV'),
    'CONVERT'     : ( -1, 3,  3, 'V', 'VVV'),
    'CORREL'      : (307, 2,  2, 'V', 'AA'),
    'COS'         : ( 16, 1,  1, 'V', 'V'),
    'COSH'        : (230, 1,  1, 'V', 'V'),
    'COUNT'       : (  0, 1, 30, 'V', 'D+'),
    'COUNTA'      : (169, 1, 30, 'V', 'D+'),
    'COUNTBLANK'  : (347, 1,  1, 'V', 'R'),
    'COUNTIF'     : (346, 2,  2, 'V', 'RV'),
    'COUPDAYBS'   : ( -1, 3,  5, 'V', 'VVVVV'),
    'COUPDAYS'    : ( -1, 3,  5, 'V', 'VVVVV'),
    'COUPDAYSNC'  : ( -1, 3,  5, 'V', 'VVVVV'),
    'COUPNCD'     : ( -1, 3,  5, 'V', 'VVVVV'),
    'COUPNUM'     : ( -1, 3,  5, 'V', 'VVVVV'),
    'COUPPCD'     : ( -1, 3,  5, 'V', 'VVVVV'),
    'COVAR'       : (308, 2,  2, 'V', 'AA'),
    'CRITBINOM'   : (278, 3,  3, 'V', 'VVV'),
    'CUMIPMT'     : ( -1, 6,  6, 'V', 'VVVVVV'),
    'CUMPRINC'    : ( -1, 6,  6, 'V', 'VVVVVV'),
    'DATE'        : ( 65, 3,  3, 'V', 'VVV'),
    'DATEDIF'     : (351, 3,  3, 'V', 'VVV'),
    'DATEVALUE'   : (140, 1,  1, 'V', 'V'),
    'DAVERAGE'    : ( 42, 3,  3, 'V', 'RRR'),
    'DAY'         : ( 67, 1,  1, 'V', 'V'),
    'DAYS360'     : (220, 2,  3, 'V', 'VVV'),
    'DB'          : (247, 4,  5, 'V', 'VVVVV'),
    'DBCS'        : (215, 1,  1, 'V', 'V'),
    'DCOUNT'      : ( 40, 3,  3, 'V', 'RRR'),
    'DCOUNTA'     : (199, 3,  3, 'V', 'RRR'),
    'DDB'         : (144, 4,  5, 'V', 'VVVVV'),
    'DEC2BIN'     : ( -1, 1,  2, 'V', 'VV'),
    'DEC2HEX'     : ( -1, 1,  2, 'V', 'VV'),
    'DEC2OCT'     : ( -1, 1,  2, 'V', 'VV'),
    'DEGREES'     : (343, 1,  1, 'V', 'V'),
    'DELTA'       : ( -1, 1,  2, 'V', 'VV'),
    'DEVSQ'       : (318, 1, 30, 'V', 'D+'),
    'DGET'        : (235, 3,  3, 'V', 'RRR'),
    'DISC'        : ( -1, 4,  5, 'V', 'VVVVV'),
    'DMAX'        : ( 44, 3,  3, 'V', 'RRR'),
    'DMIN'        : ( 43, 3,  3, 'V', 'RRR'),
    'DOLLAR'      : ( 13, 1,  2, 'V', 'VV'),
    'DOLLARDE'    : ( -1, 2,  2, 'V', 'VV'),
    'DOLLARFR'    : ( -1, 2,  2, 'V', 'VV'),
    'DPRODUCT'    : (189, 3,  3, 'V', 'RRR'),
    'DSTDEV'      : ( 45, 3,  3, 'V', 'RRR'),
    'DSTDEVP'     : (195, 3,  3, 'V', 'RRR'),
    'DSUM'        : ( 41, 3,  3, 'V', 'RRR'),
    'DURATION'    : ( -1, 5,  6, 'V', 'VVVVVV'),
    'DVAR'        : ( 47, 3,  3, 'V', 'RRR'),
    'DVARP'       : (196, 3,  3, 'V', 'RRR'),
    'EDATE'       : ( -1, 2,  2, 'V', 'VV'),
    'EFFECT'      : ( -1, 2,  2, 'V', 'VV'),
    'EOMONTH'     : ( -1, 1,  2, 'V', 'VV'),
    'ERF'         : ( -1, 1,  2, 'V', 'VV'),
    'ERFC'        : ( -1, 1,  1, 'V', 'V'),
    'ERROR.TYPE'  : (261, 1,  1, 'V', 'V'),
    'EVEN'        : (279, 1,  1, 'V', 'V'),
    'EXACT'       : (117, 2,  2, 'V', 'VV'),
    'EXP'         : ( 21, 1,  1, 'V', 'V'),
    'EXPONDIST'   : (280, 3,  3, 'V', 'VVV'),
    'FACT'        : (184, 1,  1, 'V', 'V'),
    'FACTDOUBLE'  : ( -1, 1,  1, 'V', 'V'),
    'FALSE'       : ( 35, 0,  0, 'V', '-'),
    'FDIST'       : (281, 3,  3, 'V', 'VVV'),
    'FIND'        : (124, 2,  3, 'V', 'VVV'),
    'FINDB'       : (205, 2,  3, 'V', 'VVV'),
    'FINV'        : (282, 3,  3, 'V', 'VVV'),
    'FISHER'      : (283, 1,  1, 'V', 'V'),
    'FISHERINV'   : (284, 1,  1, 'V', 'V'),
    'FIXED'       : ( 14, 2,  3, 'V', 'VVV'),
    'FLOOR'       : (285, 2,  2, 'V', 'VV'),
    'FORECAST'    : (309, 3,  3, 'V', 'VAA'),
    'FREQUENCY'   : (252, 2,  2, 'A', 'RR'),
    'FTEST'       : (310, 2,  2, 'V', 'AA'),
    'FV'          : ( 57, 3,  5, 'V', 'VVVVV'),
    'FVSCHEDULE'  : ( -1, 2,  2, 'V', 'VA'),
    'GAMMADIST'   : (286, 4,  4, 'V', 'VVVV'),
    'GAMMAINV'    : (287, 3,  3, 'V', 'VVV'),
    'GAMMALN'     : (271, 1,  1, 'V', 'V'),
    'GCD'         : ( -1, 1, 29, 'V', 'V+'),
    'GEOMEAN'     : (319, 1, 30, 'V', 'D+'),
    'GESTEP'      : ( -1, 1,  2, 'V', 'VV'),
    'GETPIVOTDATA': (358, 2, 30, 'A', 'VAV+'),
    'GROWTH'      : ( 52, 1,  4, 'A', 'RRRV'),
    'HARMEAN'     : (320, 1, 30, 'V', 'D+'),
    'HEX2BIN'     : ( -1, 1,  2, 'V', 'VV'),
    'HEX2DEC'     : ( -1, 1,  1, 'V', 'V'),
    'HEX2OCT'     : ( -1, 1,  2, 'V', 'VV'),
    'HLOOKUP'     : (101, 3,  4, 'V', 'VRRV'),
    'HOUR'        : ( 71, 1,  1, 'V', 'V'),
    'HYPERLINK'   : (359, 1,  2, 'V', 'VV'),
    'HYPGEOMDIST' : (289, 4,  4, 'V', 'VVVV'),
    'IF'          : (  1, 2,  3, 'R', 'VRR'),
    'IMABS'       : ( -1, 1,  1, 'V', 'V'),
    'IMAGINARY'   : ( -1, 1,  1, 'V', 'V'),
    'IMARGUMENT'  : ( -1, 1,  1, 'V', 'V'),
    'IMCONJUGATE' : ( -1, 1,  1, 'V', 'V'),
    'IMCOS'       : ( -1, 1,  1, 'V', 'V'),
    'IMDIV'       : ( -1, 2,  2, 'V', 'VV'),
    'IMEXP'       : ( -1, 1,  1, 'V', 'V'),
    'IMLN'        : ( -1, 1,  1, 'V', 'V'),
    'IMLOG10'     : ( -1, 1,  1, 'V', 'V'),
    'IMLOG2'      : ( -1, 1,  1, 'V', 'V'),
    'IMPOWER'     : ( -1, 2,  2, 'V', 'VV'),
    'IMPRODUCT'   : ( -1, 2,  2, 'V', 'VV'),
    'IMREAL'      : ( -1, 1,  1, 'V', 'V'),
    'IMSIN'       : ( -1, 1,  1, 'V', 'V'),
    'IMSQRT'      : ( -1, 1,  1, 'V', 'V'),
    'IMSUB'       : ( -1, 2,  2, 'V', 'VV'),
    'IMSUM'       : ( -1, 1, 29, 'V', 'V+'),
    'INDEX'       : ( 29, 2,  4, 'R', 'RVVV'),
    'INDIRECT'    : (148, 1,  2, 'R', 'VV'),
    'INFO'        : (244, 1,  1, 'V', 'V'),
    'INT'         : ( 25, 1,  1, 'V', 'V'),
    'INTERCEPT'   : (311, 2,  2, 'V', 'AA'),
    'INTRATE'     : ( -1, 4,  5, 'V', 'VVVVV'),
    'IPMT'        : (167, 4,  6, 'V', 'VVVVVV'),
    'IRR'         : ( 62, 1,  2, 'V', 'RV'),
    'ISBLANK'     : (129, 1,  1, 'V', 'V'),
    'ISERR'       : (126, 1,  1, 'V', 'V'),
    'ISERROR'     : (  3, 1,  1, 'V', 'V'),
    'ISEVEN'      : ( -1, 1,  1, 'V', 'V'),
    'ISLOGICAL'   : (198, 1,  1, 'V', 'V'),
    'ISNA'        : (  2, 1,  1, 'V', 'V'),
    'ISNONTEXT'   : (190, 1,  1, 'V', 'V'),
    'ISNUMBER'    : (128, 1,  1, 'V', 'V'),
    'ISODD'       : ( -1, 1,  1, 'V', 'V'),
    'ISPMT'       : (350, 4,  4, 'V', 'VVVV'),
    'ISREF'       : (105, 1,  1, 'V', 'R'),
    'ISTEXT'      : (127, 1,  1, 'V', 'V'),
    'KURT'        : (322, 1, 30, 'V', 'D+'),
    'LARGE'       : (325, 2,  2, 'V', 'RV'),
    'LCM'         : ( -1, 1, 29, 'V', 'V+'),
    'LEFT'        : (115, 1,  2, 'V', 'VV'),
    'LEFTB'       : (208, 1,  2, 'V', 'VV'),
    'LEN'         : ( 32, 1,  1, 'V', 'V'),
    'LENB'        : (211, 1,  1, 'V', 'V'),
    'LINEST'      : ( 49, 1,  4, 'A', 'RRVV'),
    'LN'          : ( 22, 1,  1, 'V', 'V'),
    'LOG'         : (109, 1,  2, 'V', 'VV'),
    'LOG10'       : ( 23, 1,  1, 'V', 'V'),
    'LOGEST'      : ( 51, 1,  4, 'A', 'RRVV'),
    'LOGINV'      : (291, 3,  3, 'V', 'VVV'),
    'LOGNORMDIST' : (290, 3,  3, 'V', 'VVV'),
    'LOOKUP'      : ( 28, 2,  3, 'V', 'VRR'),
    'LOWER'       : (112, 1,  1, 'V', 'V'),
    'MATCH'       : ( 64, 2,  3, 'V', 'VRR'),
    'MAX'         : (  7, 1, 30, 'V', 'D+'),
    'MAXA'        : (362, 1, 30, 'V', 'D+'),
    'MDETERM'     : (163, 1,  1, 'V', 'A'),
    'MDURATION'   : ( -1, 5,  6, 'V', 'VVVVVV'),
    'MEDIAN'      : (227, 1, 30, 'V', 'D+'),
    'MID'         : ( 31, 3,  3, 'V', 'VVV'),
    'MIDB'        : (210, 3,  3, 'V', 'VVV'),
    'MIN'         : (  6, 1, 30, 'V', 'D+'),
    'MINA'        : (363, 1, 30, 'V', 'D+'),
    'MINUTE'      : ( 72, 1,  1, 'V', 'V'),
    'MINVERSE'    : (164, 1,  1, 'A', 'A'),
    'MIRR'        : ( 61, 3,  3, 'V', 'RVV'),
    'MMULT'       : (165, 2,  2, 'A', 'AA'),
    'MOD'         : ( 39, 2,  2, 'V', 'VV'),
    'MODE'        : (330, 1, 30, 'V', 'A+'), ################ weird #################
    'MONTH'       : ( 68, 1,  1, 'V', 'V'),
    'MROUND'      : ( -1, 2,  2, 'V', 'VV'),
    'MULTINOMIAL' : ( -1, 1, 29, 'V', 'V+'),
    'N'           : (131, 1,  1, 'V', 'R'),
    'NA'          : ( 10, 0,  0, 'V', '-'),
    'NEGBINOMDIST': (292, 3,  3, 'V', 'VVV'),
    'NETWORKDAYS' : ( -1, 2,  3, 'V', 'VVR'),
    'NOMINAL'     : ( -1, 2,  2, 'V', 'VV'),
    'NORMDIST'    : (293, 4,  4, 'V', 'VVVV'),
    'NORMINV'     : (295, 3,  3, 'V', 'VVV'),
    'NORMSDIST'   : (294, 1,  1, 'V', 'V'),
    'NORMSINV'    : (296, 1,  1, 'V', 'V'),
    'NOT'         : ( 38, 1,  1, 'V', 'V'),
    'NOW'         : ( 74, 0,  0, 'V', '-'),
    'NPER'        : ( 58, 3,  5, 'V', 'VVVVV'),
    'NPV'         : ( 11, 2, 30, 'V', 'VD+'),
    'OCT2BIN'     : ( -1, 1,  2, 'V', 'VV'),
    'OCT2DEC'     : ( -1, 1,  1, 'V', 'V'),
    'OCT2HEX'     : ( -1, 1,  2, 'V', 'VV'),
    'ODD'         : (298, 1,  1, 'V', 'V'),
    'ODDFPRICE'   : ( -1, 9,  9, 'V', 'VVVVVVVVV'),
    'ODDFYIELD'   : ( -1, 9,  9, 'V', 'VVVVVVVVV'),
    'ODDLPRICE'   : ( -1, 8,  8, 'V', 'VVVVVVVV'),
    'ODDLYIELD'   : ( -1, 8,  8, 'V', 'VVVVVVVV'),
    'OFFSET'      : ( 78, 3,  5, 'R', 'RVVVV'),
    'OR'          : ( 37, 1, 30, 'V', 'D+'),
    'PEARSON'     : (312, 2,  2, 'V', 'AA'),
    'PERCENTILE'  : (328, 2,  2, 'V', 'RV'),
    'PERCENTRANK' : (329, 2,  3, 'V', 'RVV'),
    'PERMUT'      : (299, 2,  2, 'V', 'VV'),
    'PHONETIC'    : (360, 1,  1, 'V', 'R'),
    'PI'          : ( 19, 0,  0, 'V', '-'),
    'PMT'         : ( 59, 3,  5, 'V', 'VVVVV'),
    'POISSON'     : (300, 3,  3, 'V', 'VVV'),
    'POWER'       : (337, 2,  2, 'V', 'VV'),
    'PPMT'        : (168, 4,  6, 'V', 'VVVVVV'),
    'PRICE'       : ( -1, 6,  7, 'V', 'VVVVVVV'),
    'PRICEDISC'   : ( -1, 4,  5, 'V', 'VVVVV'),
    'PRICEMAT'    : ( -1, 5,  6, 'V', 'VVVVVV'),
    'PROB'        : (317, 3,  4, 'V', 'AAVV'),
    'PRODUCT'     : (183, 1, 30, 'V', 'D+'),
    'PROPER'      : (114, 1,  1, 'V', 'V'),
    'PV'          : ( 56, 3,  5, 'V', 'VVVVV'),
    'QUARTILE'    : (327, 2,  2, 'V', 'RV'),
    'QUOTIENT'    : ( -1, 2,  2, 'V', 'VV'),
    'RADIANS'     : (342, 1,  1, 'V', 'V'),
    'RAND'        : ( 63, 0,  0, 'V', '-'),
    'RANDBETWEEN' : ( -1, 2,  2, 'V', 'VV'),
    'RANK'        : (216, 2,  3, 'V', 'VRV'),
    'RATE'        : ( 60, 3,  6, 'V', 'VVVVVV'),
    'RECEIVED'    : ( -1, 4,  5, 'V', 'VVVVV'),
    'REPLACE'     : (119, 4,  4, 'V', 'VVVV'),
    'REPLACEB'    : (207, 4,  4, 'V', 'VVVV'),
    'REPT'        : ( 30, 2,  2, 'V', 'VV'),
    'RIGHT'       : (116, 1,  2, 'V', 'VV'),
    'RIGHTB'      : (209, 1,  2, 'V', 'VV'),
    'ROMAN'       : (354, 1,  2, 'V', 'VV'),
    'ROUND'       : ( 27, 2,  2, 'V', 'VV'),
    'ROUNDDOWN'   : (213, 2,  2, 'V', 'VV'),
    'ROUNDUP'     : (212, 2,  2, 'V', 'VV'),
    'ROW'         : (  8, 0,  1, 'V', 'R'),
    'ROWS'        : ( 76, 1,  1, 'V', 'R'),
    'RSQ'         : (313, 2,  2, 'V', 'AA'),
    'RTD'         : (379, 3, 30, 'A', 'VVV+'),
    'SEARCH'      : ( 82, 2,  3, 'V', 'VVV'),
    'SEARCHB'     : (206, 2,  3, 'V', 'VVV'),
    'SECOND'      : ( 73, 1,  1, 'V', 'V'),
    'SERIESSUM'   : ( -1, 4,  4, 'V', 'VVVA'),
    'SIGN'        : ( 26, 1,  1, 'V', 'V'),
    'SIN'         : ( 15, 1,  1, 'V', 'V'),
    'SINH'        : (229, 1,  1, 'V', 'V'),
    'SKEW'        : (323, 1, 30, 'V', 'D+'),
    'SLN'         : (142, 3,  3, 'V', 'VVV'),
    'SLOPE'       : (315, 2,  2, 'V', 'AA'),
    'SMALL'       : (326, 2,  2, 'V', 'RV'),
    'SQRT'        : ( 20, 1,  1, 'V', 'V'),
    'SQRTPI'      : ( -1, 1,  1, 'V', 'V'),
    'STANDARDIZE' : (297, 3,  3, 'V', 'VVV'),
    'STDEV'       : ( 12, 1, 30, 'V', 'D+'),
    'STDEVA'      : (366, 1, 30, 'V', 'D+'),
    'STDEVP'      : (193, 1, 30, 'V', 'D+'),
    'STDEVPA'     : (364, 1, 30, 'V', 'D+'),
    'STEYX'       : (314, 2,  2, 'V', 'AA'),
    'SUBSTITUTE'  : (120, 3,  4, 'V', 'VVVV'),
    'SUBTOTAL'    : (344, 2, 30, 'V', 'VR+'),
    'SUM'         : (  4, 1, 30, 'V', 'D+'),
    'SUMIF'       : (345, 2,  3, 'V', 'RVR'),
    'SUMPRODUCT'  : (228, 1, 30, 'V', 'A+'),
    'SUMSQ'       : (321, 1, 30, 'V', 'D+'),
    'SUMX2MY2'    : (304, 2,  2, 'V', 'AA'),
    'SUMX2PY2'    : (305, 2,  2, 'V', 'AA'),
    'SUMXMY2'     : (303, 2,  2, 'V', 'AA'),
    'SYD'         : (143, 4,  4, 'V', 'VVVV'),
    'T'           : (130, 1,  1, 'V', 'R'),
    'TAN'         : ( 17, 1,  1, 'V', 'V'),
    'TANH'        : (231, 1,  1, 'V', 'V'),
    'TBILLEQ'     : ( -1, 3,  3, 'V', 'VVV'),
    'TBILLPRICE'  : ( -1, 3,  3, 'V', 'VVV'),
    'TBILLYIELD'  : ( -1, 3,  3, 'V', 'VVV'),
    'TDIST'       : (301, 3,  3, 'V', 'VVV'),
    'TEXT'        : ( 48, 2,  2, 'V', 'VV'),
    'TIME'        : ( 66, 3,  3, 'V', 'VVV'),
    'TIMEVALUE'   : (141, 1,  1, 'V', 'V'),
    'TINV'        : (332, 2,  2, 'V', 'VV'),
    'TODAY'       : (221, 0,  0, 'V', '-'),
    'TRANSPOSE'   : ( 83, 1,  1, 'A', 'A'),
    'TREND'       : ( 50, 1,  4, 'A', 'RRRV'),
    'TRIM'        : (118, 1,  1, 'V', 'V'),
    'TRIMMEAN'    : (331, 2,  2, 'V', 'RV'),
    'TRUE'        : ( 34, 0,  0, 'V', '-'),
    'TRUNC'       : (197, 1,  2, 'V', 'VV'),
    'TTEST'       : (316, 4,  4, 'V', 'AAVV'),
    'TYPE'        : ( 86, 1,  1, 'V', 'V'),
    'UPPER'       : (113, 1,  1, 'V', 'V'),
    'USDOLLAR'    : (204, 1,  2, 'V', 'VV'),
    'VALUE'       : ( 33, 1,  1, 'V', 'V'),
    'VAR'         : ( 46, 1, 30, 'V', 'D+'),
    'VARA'        : (367, 1, 30, 'V', 'D+'),
    'VARP'        : (194, 1, 30, 'V', 'D+'),
    'VARPA'       : (365, 1, 30, 'V', 'D+'),
    'VDB'         : (222, 5,  7, 'V', 'VVVVVVV'),
    'VLOOKUP'     : (102, 3,  4, 'V', 'VRRV'),
    'WEEKDAY'     : ( 70, 1,  2, 'V', 'VV'),
    'WEEKNUM'     : ( -1, 1,  2, 'V', 'VV'),
    'WEIBULL'     : (302, 4,  4, 'V', 'VVVV'),
    'WORKDAY'     : ( -1, 2,  3, 'V', 'VVR'),
    'XIRR'        : ( -1, 2,  3, 'V', 'AAV'),
    'XNPV'        : ( -1, 3,  3, 'V', 'VAA'),
    'YEAR'        : ( 69, 1,  1, 'V', 'V'),
    'YEARFRAC'    : ( -1, 2,  3, 'V', 'VVV'),
    'YIELD'       : ( -1, 6,  7, 'V', 'VVVVVVV'),
    'YIELDDISC'   : ( -1, 4,  5, 'V', 'VVVVV'),
    'YIELDMAT'    : ( -1, 5,  6, 'V', 'VVVVVV'),
    'ZTEST'       : (324, 2,  3, 'V', 'RVV'),
    }

# Formulas Parse things

ptgExp          = 0x01
ptgTbl          = 0x02
ptgAdd          = 0x03
ptgSub          = 0x04
ptgMul          = 0x05
ptgDiv          = 0x06
ptgPower        = 0x07
ptgConcat       = 0x08
ptgLT           = 0x09
ptgLE           = 0x0a
ptgEQ           = 0x0b
ptgGE           = 0x0c
ptgGT           = 0x0d
ptgNE           = 0x0e
ptgIsect        = 0x0f
ptgUnion        = 0x10
ptgRange        = 0x11
ptgUplus        = 0x12
ptgUminus       = 0x13
ptgPercent      = 0x14
ptgParen        = 0x15
ptgMissArg      = 0x16
ptgStr          = 0x17
ptgExtend       = 0x18
ptgAttr         = 0x19
ptgSheet        = 0x1a
ptgEndSheet     = 0x1b
ptgErr          = 0x1c
ptgBool         = 0x1d
ptgInt          = 0x1e
ptgNum          = 0x1f

ptgArrayR       = 0x20
ptgFuncR        = 0x21
ptgFuncVarR     = 0x22
ptgNameR        = 0x23
ptgRefR         = 0x24
ptgAreaR        = 0x25
ptgMemAreaR     = 0x26
ptgMemErrR      = 0x27
ptgMemNoMemR    = 0x28
ptgMemFuncR     = 0x29
ptgRefErrR      = 0x2a
ptgAreaErrR     = 0x2b
ptgRefNR        = 0x2c
ptgAreaNR       = 0x2d
ptgMemAreaNR    = 0x2e
ptgMemNoMemNR   = 0x2f
ptgNameXR       = 0x39
ptgRef3dR       = 0x3a
ptgArea3dR      = 0x3b
ptgRefErr3dR    = 0x3c
ptgAreaErr3dR   = 0x3d

ptgArrayV       = 0x40
ptgFuncV        = 0x41
ptgFuncVarV     = 0x42
ptgNameV        = 0x43
ptgRefV         = 0x44
ptgAreaV        = 0x45
ptgMemAreaV     = 0x46
ptgMemErrV      = 0x47
ptgMemNoMemV    = 0x48
ptgMemFuncV     = 0x49
ptgRefErrV      = 0x4a
ptgAreaErrV     = 0x4b
ptgRefNV        = 0x4c
ptgAreaNV       = 0x4d
ptgMemAreaNV    = 0x4e
ptgMemNoMemNV   = 0x4f
ptgFuncCEV      = 0x58
ptgNameXV       = 0x59
ptgRef3dV       = 0x5a
ptgArea3dV      = 0x5b
ptgRefErr3dV    = 0x5c
ptgAreaErr3dV   = 0x5d

ptgArrayA       = 0x60
ptgFuncA        = 0x61
ptgFuncVarA     = 0x62
ptgNameA        = 0x63
ptgRefA         = 0x64
ptgAreaA        = 0x65
ptgMemAreaA     = 0x66
ptgMemErrA      = 0x67
ptgMemNoMemA    = 0x68
ptgMemFuncA     = 0x69
ptgRefErrA      = 0x6a
ptgAreaErrA     = 0x6b
ptgRefNA        = 0x6c
ptgAreaNA       = 0x6d
ptgMemAreaNA    = 0x6e
ptgMemNoMemNA   = 0x6f
ptgFuncCEA      = 0x78
ptgNameXA       = 0x79
ptgRef3dA       = 0x7a
ptgArea3dA      = 0x7b
ptgRefErr3dA    = 0x7c
ptgAreaErr3dA   = 0x7d


PtgNames = {
    ptgExp         : "ptgExp",
    ptgTbl         : "ptgTbl",
    ptgAdd         : "ptgAdd",
    ptgSub         : "ptgSub",
    ptgMul         : "ptgMul",
    ptgDiv         : "ptgDiv",
    ptgPower       : "ptgPower",
    ptgConcat      : "ptgConcat",
    ptgLT          : "ptgLT",
    ptgLE          : "ptgLE",
    ptgEQ          : "ptgEQ",
    ptgGE          : "ptgGE",
    ptgGT          : "ptgGT",
    ptgNE          : "ptgNE",
    ptgIsect       : "ptgIsect",
    ptgUnion       : "ptgUnion",
    ptgRange       : "ptgRange",
    ptgUplus       : "ptgUplus",
    ptgUminus      : "ptgUminus",
    ptgPercent     : "ptgPercent",
    ptgParen       : "ptgParen",
    ptgMissArg     : "ptgMissArg",
    ptgStr         : "ptgStr",
    ptgExtend      : "ptgExtend",
    ptgAttr        : "ptgAttr",
    ptgSheet       : "ptgSheet",
    ptgEndSheet    : "ptgEndSheet",
    ptgErr         : "ptgErr",
    ptgBool        : "ptgBool",
    ptgInt         : "ptgInt",
    ptgNum         : "ptgNum",
    ptgArrayR      : "ptgArrayR",
    ptgFuncR       : "ptgFuncR",
    ptgFuncVarR    : "ptgFuncVarR",
    ptgNameR       : "ptgNameR",
    ptgRefR        : "ptgRefR",
    ptgAreaR       : "ptgAreaR",
    ptgMemAreaR    : "ptgMemAreaR",
    ptgMemErrR     : "ptgMemErrR",
    ptgMemNoMemR   : "ptgMemNoMemR",
    ptgMemFuncR    : "ptgMemFuncR",
    ptgRefErrR     : "ptgRefErrR",
    ptgAreaErrR    : "ptgAreaErrR",
    ptgRefNR       : "ptgRefNR",
    ptgAreaNR      : "ptgAreaNR",
    ptgMemAreaNR   : "ptgMemAreaNR",
    ptgMemNoMemNR  : "ptgMemNoMemNR",
    ptgNameXR      : "ptgNameXR",
    ptgRef3dR      : "ptgRef3dR",
    ptgArea3dR     : "ptgArea3dR",
    ptgRefErr3dR   : "ptgRefErr3dR",
    ptgAreaErr3dR  : "ptgAreaErr3dR",
    ptgArrayV      : "ptgArrayV",
    ptgFuncV       : "ptgFuncV",
    ptgFuncVarV    : "ptgFuncVarV",
    ptgNameV       : "ptgNameV",
    ptgRefV        : "ptgRefV",
    ptgAreaV       : "ptgAreaV",
    ptgMemAreaV    : "ptgMemAreaV",
    ptgMemErrV     : "ptgMemErrV",
    ptgMemNoMemV   : "ptgMemNoMemV",
    ptgMemFuncV    : "ptgMemFuncV",
    ptgRefErrV     : "ptgRefErrV",
    ptgAreaErrV    : "ptgAreaErrV",
    ptgRefNV       : "ptgRefNV",
    ptgAreaNV      : "ptgAreaNV",
    ptgMemAreaNV   : "ptgMemAreaNV",
    ptgMemNoMemNV  : "ptgMemNoMemNV",
    ptgFuncCEV     : "ptgFuncCEV",
    ptgNameXV      : "ptgNameXV",
    ptgRef3dV      : "ptgRef3dV",
    ptgArea3dV     : "ptgArea3dV",
    ptgRefErr3dV   : "ptgRefErr3dV",
    ptgAreaErr3dV  : "ptgAreaErr3dV",
    ptgArrayA      : "ptgArrayA",
    ptgFuncA       : "ptgFuncA",
    ptgFuncVarA    : "ptgFuncVarA",
    ptgNameA       : "ptgNameA",
    ptgRefA        : "ptgRefA",
    ptgAreaA       : "ptgAreaA",
    ptgMemAreaA    : "ptgMemAreaA",
    ptgMemErrA     : "ptgMemErrA",
    ptgMemNoMemA   : "ptgMemNoMemA",
    ptgMemFuncA    : "ptgMemFuncA",
    ptgRefErrA     : "ptgRefErrA",
    ptgAreaErrA    : "ptgAreaErrA",
    ptgRefNA       : "ptgRefNA",
    ptgAreaNA      : "ptgAreaNA",
    ptgMemAreaNA   : "ptgMemAreaNA",
    ptgMemNoMemNA  : "ptgMemNoMemNA",
    ptgFuncCEA     : "ptgFuncCEA",
    ptgNameXA      : "ptgNameXA",
    ptgRef3dA      : "ptgRef3dA",
    ptgArea3dA     : "ptgArea3dA",
    ptgRefErr3dA   : "ptgRefErr3dA",
    ptgAreaErr3dA  : "ptgAreaErr3dA"
}


error_msg_by_code = {
    0x00: "#NULL!",  # intersection of two cell ranges is empty
    0x07: "#DIV/0!", # division by zero
    0x0F: "#VALUE!", # wrong type of operand
    0x17: "#REF!",   # illegal or deleted cell reference
    0x1D: "#NAME?",  # wrong function or range name
    0x24: "#NUM!",   # value range overflow
    0x2A: "#N/A!"    # argument or function not available
}

########NEW FILE########
__FILENAME__ = Formatting
#!/usr/bin/env python
'''
The  XF  record is able to store explicit cell formatting attributes or the
attributes  of  a cell style. Explicit formatting includes the reference to
a  cell  style  XF  record. This allows to extend a defined cell style with
some  explicit  attributes.  The  formatting  attributes  are  divided into
6 groups:

Group           Attributes
-------------------------------------
Number format   Number format index (index to FORMAT record)
Font            Font index (index to FONT record)
Alignment       Horizontal and vertical alignment, text wrap, indentation,
                orientation/rotation, text direction
Border          Border line styles and colours
Background      Background area style and colours
Protection      Cell locked, formula hidden

For  each  group  a flag in the cell XF record specifies whether to use the
attributes  contained  in  that  XF  record  or  in  the  referenced  style
XF  record. In style XF records, these flags specify whether the attributes
will  overwrite  explicit  cell  formatting  when  the  style is applied to
a  cell. Changing a cell style (without applying this style to a cell) will
change  all  cells which already use that style and do not contain explicit
cell  attributes for the changed style attributes. If a cell XF record does
not  contain  explicit  attributes  in a group (if the attribute group flag
is not set), it repeats the attributes of its style XF record.

'''

from . import BIFFRecords

class Font(object):

    ESCAPEMENT_NONE         = 0x00
    ESCAPEMENT_SUPERSCRIPT  = 0x01
    ESCAPEMENT_SUBSCRIPT    = 0x02

    UNDERLINE_NONE          = 0x00
    UNDERLINE_SINGLE        = 0x01
    UNDERLINE_SINGLE_ACC    = 0x21
    UNDERLINE_DOUBLE        = 0x02
    UNDERLINE_DOUBLE_ACC    = 0x22

    FAMILY_NONE         = 0x00
    FAMILY_ROMAN        = 0x01
    FAMILY_SWISS        = 0x02
    FAMILY_MODERN       = 0x03
    FAMILY_SCRIPT       = 0x04
    FAMILY_DECORATIVE   = 0x05

    CHARSET_ANSI_LATIN          = 0x00
    CHARSET_SYS_DEFAULT         = 0x01
    CHARSET_SYMBOL              = 0x02
    CHARSET_APPLE_ROMAN         = 0x4D
    CHARSET_ANSI_JAP_SHIFT_JIS  = 0x80
    CHARSET_ANSI_KOR_HANGUL     = 0x81
    CHARSET_ANSI_KOR_JOHAB      = 0x82
    CHARSET_ANSI_CHINESE_GBK    = 0x86
    CHARSET_ANSI_CHINESE_BIG5   = 0x88
    CHARSET_ANSI_GREEK          = 0xA1
    CHARSET_ANSI_TURKISH        = 0xA2
    CHARSET_ANSI_VIETNAMESE     = 0xA3
    CHARSET_ANSI_HEBREW         = 0xB1
    CHARSET_ANSI_ARABIC         = 0xB2
    CHARSET_ANSI_BALTIC         = 0xBA
    CHARSET_ANSI_CYRILLIC       = 0xCC
    CHARSET_ANSI_THAI           = 0xDE
    CHARSET_ANSI_LATIN_II       = 0xEE
    CHARSET_OEM_LATIN_I         = 0xFF

    def __init__(self):
        # twip = 1/20 of a point = 1/1440 of a inch
        # usually resolution == 96 pixels per 1 inch
        # (rarely 120 pixels per 1 inch or another one)

        self.height = 0x00C8 # 200: this is font with height 10 points
        self.italic = False
        self.struck_out = False
        self.outline = False
        self.shadow = False
        self.colour_index = 0x7FFF
        self.bold = False
        self._weight = 0x0190 # 0x02BC gives bold font
        self.escapement = self.ESCAPEMENT_NONE
        self.underline = self.UNDERLINE_NONE
        self.family = self.FAMILY_NONE
        self.charset = self.CHARSET_SYS_DEFAULT
        self.name = b'Arial'

    def get_biff_record(self):
        height = self.height

        options = 0x00
        if self.bold:
            options |= 0x01
            self._weight = 0x02BC
        if self.italic:
            options |= 0x02
        if self.underline != self.UNDERLINE_NONE:
            options |= 0x04
        if self.struck_out:
            options |= 0x08
        if self.outline:
            options |= 0x010
        if self.shadow:
            options |= 0x020

        colour_index = self.colour_index
        weight = self._weight
        escapement = self.escapement
        underline = self.underline
        family = self.family
        charset = self.charset
        name = self.name

        return BIFFRecords.FontRecord(height, options, colour_index, weight, escapement,
                    underline, family, charset,
                    name)

    def _search_key(self):
        return (
            self.height,
            self.italic,
            self.struck_out,
            self.outline,
            self.shadow,
            self.colour_index,
            self.bold,
            self._weight,
            self.escapement,
            self.underline,
            self.family,
            self.charset,
            self.name,
            )

class Alignment(object):
    HORZ_GENERAL                = 0x00
    HORZ_LEFT                   = 0x01
    HORZ_CENTER                 = 0x02
    HORZ_RIGHT                  = 0x03
    HORZ_FILLED                 = 0x04
    HORZ_JUSTIFIED              = 0x05 # BIFF4-BIFF8X
    HORZ_CENTER_ACROSS_SEL      = 0x06 # Centred across selection (BIFF4-BIFF8X)
    HORZ_DISTRIBUTED            = 0x07 # Distributed (BIFF8X)

    VERT_TOP                    = 0x00
    VERT_CENTER                 = 0x01
    VERT_BOTTOM                 = 0x02
    VERT_JUSTIFIED              = 0x03 # Justified (BIFF5-BIFF8X)
    VERT_DISTRIBUTED            = 0x04 # Distributed (BIFF8X)

    DIRECTION_GENERAL           = 0x00 # BIFF8X
    DIRECTION_LR                = 0x01
    DIRECTION_RL                = 0x02

    ORIENTATION_NOT_ROTATED     = 0x00
    ORIENTATION_STACKED         = 0x01
    ORIENTATION_90_CC           = 0x02
    ORIENTATION_90_CW           = 0x03

    ROTATION_0_ANGLE            = 0x00
    ROTATION_STACKED            = 0xFF

    WRAP_AT_RIGHT               = 0x01
    NOT_WRAP_AT_RIGHT           = 0x00

    SHRINK_TO_FIT               = 0x01
    NOT_SHRINK_TO_FIT           = 0x00

    def __init__(self):
        self.horz = self.HORZ_GENERAL
        self.vert = self.VERT_BOTTOM
        self.dire = self.DIRECTION_GENERAL
        self.orie = self.ORIENTATION_NOT_ROTATED
        self.rota = self.ROTATION_0_ANGLE
        self.wrap = self.NOT_WRAP_AT_RIGHT
        self.shri = self.NOT_SHRINK_TO_FIT
        self.inde = 0
        self.merg = 0

    def _search_key(self):
        return (
            self.horz, self.vert, self.dire, self.orie, self.rota,
            self.wrap, self.shri, self.inde, self.merg,
            )

class Borders(object):
    NO_LINE = 0x00
    THIN    = 0x01
    MEDIUM  = 0x02
    DASHED  = 0x03
    DOTTED  = 0x04
    THICK   = 0x05
    DOUBLE  = 0x06
    HAIR    = 0x07
    #The following for BIFF8
    MEDIUM_DASHED               = 0x08
    THIN_DASH_DOTTED            = 0x09
    MEDIUM_DASH_DOTTED          = 0x0A
    THIN_DASH_DOT_DOTTED        = 0x0B
    MEDIUM_DASH_DOT_DOTTED      = 0x0C
    SLANTED_MEDIUM_DASH_DOTTED  = 0x0D

    NEED_DIAG1      = 0x01
    NEED_DIAG2      = 0x01
    NO_NEED_DIAG1   = 0x00
    NO_NEED_DIAG2   = 0x00

    def __init__(self):
        self.left   = self.NO_LINE
        self.right  = self.NO_LINE
        self.top    = self.NO_LINE
        self.bottom = self.NO_LINE
        self.diag   = self.NO_LINE

        self.left_colour   = 0x40
        self.right_colour  = 0x40
        self.top_colour    = 0x40
        self.bottom_colour = 0x40
        self.diag_colour   = 0x40

        self.need_diag1 = self.NO_NEED_DIAG1
        self.need_diag2 = self.NO_NEED_DIAG2

    def _search_key(self):
        return (
             self.left, self.right, self.top, self.bottom, self.diag,
             self.left_colour, self.right_colour, self.top_colour,
             self.bottom_colour, self.diag_colour,
             self.need_diag1, self.need_diag2,
            )

class Pattern(object):
    # patterns 0x00 - 0x12
    NO_PATTERN      = 0x00
    SOLID_PATTERN   = 0x01

    def __init__(self):
        self.pattern = self.NO_PATTERN
        self.pattern_fore_colour = 0x40
        self.pattern_back_colour = 0x41

    def _search_key(self):
        return (
            self.pattern,
            self.pattern_fore_colour,
            self.pattern_back_colour,
            )

class Protection(object):
    def __init__(self):
        self.cell_locked = 1
        self.formula_hidden = 0

    def _search_key(self):
        return (
            self.cell_locked,
            self.formula_hidden,
            )

########NEW FILE########
__FILENAME__ = Row
# -*- coding: windows-1252 -*-

from . import BIFFRecords
from . import Style
from .Cell import StrCell, BlankCell, NumberCell, FormulaCell, MulBlankCell, BooleanCell, ErrorCell, \
    _get_cells_biff_data_mul
from . import ExcelFormula
import datetime as dt
try:
    from decimal import Decimal
except ImportError:
    # Python 2.3: decimal not supported; create dummy Decimal class
    class Decimal(object):
        pass


class Row(object):
    __slots__ = [# private variables
                 "__idx",
                 "__parent",
                 "__parent_wb",
                 "__cells",
                 "__min_col_idx",
                 "__max_col_idx",
                 "__xf_index",
                 "__has_default_xf_index",
                 "__height_in_pixels",
                 # public variables
                 "height",
                 "has_default_height",
                 "height_mismatch",
                 "level",
                 "collapse",
                 "hidden",
                 "space_above",
                 "space_below"]

    def __init__(self, rowx, parent_sheet):
        if not (isinstance(rowx, int) and 0 <= rowx <= 65535):
            raise ValueError("row index (%r) not an int in range(65536)" % rowx)
        self.__idx = rowx
        self.__parent = parent_sheet
        self.__parent_wb = parent_sheet.get_parent()
        self.__cells = {}
        self.__min_col_idx = 0
        self.__max_col_idx = 0
        self.__xf_index = 0x0F
        self.__has_default_xf_index = 0
        self.__height_in_pixels = 0x11

        self.height = 0x00FF
        self.has_default_height = 0x00
        self.height_mismatch = 0
        self.level = 0
        self.collapse = 0
        self.hidden = 0
        self.space_above = 0
        self.space_below = 0


    def __adjust_height(self, style):
        twips = style.font.height
        points = float(twips)/20.0
        # Cell height in pixels can be calcuted by following approx. formula:
        # cell height in pixels = font height in points * 83/50 + 2/5
        # It works when screen resolution is 96 dpi
        pix = int(round(points*83.0/50.0 + 2.0/5.0))
        if pix > self.__height_in_pixels:
            self.__height_in_pixels = pix


    def __adjust_bound_col_idx(self, *args):
        for arg in args:
            iarg = int(arg)
            if not ((0 <= iarg <= 255) and arg == iarg):
                raise ValueError("column index (%r) not an int in range(256)" % arg)
            sheet = self.__parent
            if iarg < self.__min_col_idx:
                self.__min_col_idx = iarg
            if iarg > self.__max_col_idx:
                self.__max_col_idx = iarg
            if iarg < sheet.first_used_col:
                sheet.first_used_col = iarg
            if iarg > sheet.last_used_col:
                sheet.last_used_col = iarg

    def __excel_date_dt(self, date):
        if isinstance(date, dt.date) and (not isinstance(date, dt.datetime)):
            epoch = dt.date(1899, 12, 31)
        elif isinstance(date, dt.time):
            date = dt.datetime.combine(dt.datetime(1900, 1, 1), date)
            epoch = dt.datetime(1900, 1, 1, 0, 0, 0)
        else:
            epoch = dt.datetime(1899, 12, 31, 0, 0, 0)
        delta = date - epoch
        xldate = delta.days + float(delta.seconds) / (24*60*60)
        # Add a day for Excel's missing leap day in 1900
        if xldate > 59:
            xldate += 1
        return xldate

    def get_height_in_pixels(self):
        return self.__height_in_pixels


    def set_style(self, style):
        self.__adjust_height(style)
        self.__xf_index = self.__parent_wb.add_style(style)
        self.__has_default_xf_index = 1


    def get_xf_index(self):
        return self.__xf_index


    def get_cells_count(self):
        return len(self.__cells)


    def get_min_col(self):
        return self.__min_col_idx


    def get_max_col(self):
        return self.__max_col_idx


    def get_row_biff_data(self):
        height_options = (self.height & 0x07FFF)
        height_options |= (self.has_default_height & 0x01) << 15

        options =  (self.level & 0x07) << 0
        options |= (self.collapse & 0x01) << 4
        options |= (self.hidden & 0x01) << 5
        options |= (self.height_mismatch & 0x01) << 6
        options |= (self.__has_default_xf_index & 0x01) << 7
        options |= (0x01 & 0x01) << 8
        options |= (self.__xf_index & 0x0FFF) << 16
        options |= (self.space_above & 1) << 28
        options |= (self.space_below & 1) << 29

        return BIFFRecords.RowRecord(self.__idx, self.__min_col_idx,
            self.__max_col_idx, height_options, options).get()

    def insert_cell(self, col_index, cell_obj):
        if col_index in self.__cells:
            if not self.__parent._cell_overwrite_ok:
                msg = "Attempt to overwrite cell: sheetname=%r rowx=%d colx=%d" \
                    % (self.__parent.name, self.__idx, col_index)
                raise Exception(msg)
            prev_cell_obj = self.__cells[col_index]
            sst_idx = getattr(prev_cell_obj, 'sst_idx', None)
            if sst_idx is not None:
                self.__parent_wb.del_str(sst_idx)
        self.__cells[col_index] = cell_obj

    def insert_mulcells(self, colx1, colx2, cell_obj):
        self.insert_cell(colx1, cell_obj)
        for col_index in range(colx1+1, colx2+1):
            self.insert_cell(col_index, None)

    def get_cells_biff_data(self):
        cell_items = [item for item in self.__cells.items() if item[1] is not None]
        cell_items.sort() # in column order
        return _get_cells_biff_data_mul(self.__idx, cell_items)
        # previously:
        # return ''.join([cell.get_biff_data() for colx, cell in cell_items])

    def get_index(self):
        return self.__idx

    def set_cell_text(self, colx, value, style=Style.default_style):
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(colx)
        xf_index = self.__parent_wb.add_style(style)
        self.insert_cell(colx, StrCell(self.__idx, colx, xf_index, self.__parent_wb.add_str(value)))

    def set_cell_blank(self, colx, style=Style.default_style):
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(colx)
        xf_index = self.__parent_wb.add_style(style)
        self.insert_cell(colx, BlankCell(self.__idx, colx, xf_index))

    def set_cell_mulblanks(self, first_colx, last_colx, style=Style.default_style):
        assert 0 <= first_colx <= last_colx <= 255
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(first_colx, last_colx)
        xf_index = self.__parent_wb.add_style(style)
        # ncols = last_colx - first_colx + 1
        self.insert_mulcells(first_colx, last_colx, MulBlankCell(self.__idx, first_colx, last_colx, xf_index))

    def set_cell_number(self, colx, number, style=Style.default_style):
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(colx)
        xf_index = self.__parent_wb.add_style(style)
        self.insert_cell(colx, NumberCell(self.__idx, colx, xf_index, number))

    def set_cell_date(self, colx, datetime_obj, style=Style.default_style):
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(colx)
        xf_index = self.__parent_wb.add_style(style)
        self.insert_cell(colx,
            NumberCell(self.__idx, colx, xf_index, self.__excel_date_dt(datetime_obj)))

    def set_cell_formula(self, colx, formula, style=Style.default_style, calc_flags=0):
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(colx)
        xf_index = self.__parent_wb.add_style(style)
        self.__parent_wb.add_sheet_reference(formula)
        self.insert_cell(colx, FormulaCell(self.__idx, colx, xf_index, formula, calc_flags=0))

    def set_cell_boolean(self, colx, value, style=Style.default_style):
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(colx)
        xf_index = self.__parent_wb.add_style(style)
        self.insert_cell(colx, BooleanCell(self.__idx, colx, xf_index, bool(value)))

    def set_cell_error(self, colx, error_string_or_code, style=Style.default_style):
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(colx)
        xf_index = self.__parent_wb.add_style(style)
        self.insert_cell(colx, ErrorCell(self.__idx, colx, xf_index, error_string_or_code))

    def write(self, col, label, style=Style.default_style):
        self.__adjust_height(style)
        self.__adjust_bound_col_idx(col)
        style_index = self.__parent_wb.add_style(style)
        if isinstance(label, str):
            if len(label) > 0:
                self.insert_cell(col,
                    StrCell(self.__idx, col, style_index, self.__parent_wb.add_str(label))
                    )
            else:
                self.insert_cell(col, BlankCell(self.__idx, col, style_index))
        elif isinstance(label, bool): # bool is subclass of int; test bool first
            self.insert_cell(col, BooleanCell(self.__idx, col, style_index, label))
        elif isinstance(label, (float, int, Decimal)):
            self.insert_cell(col, NumberCell(self.__idx, col, style_index, label))
        elif isinstance(label, (dt.datetime, dt.date, dt.time)):
            date_number = self.__excel_date_dt(label)
            self.insert_cell(col, NumberCell(self.__idx, col, style_index, date_number))
        elif label is None:
            self.insert_cell(col, BlankCell(self.__idx, col, style_index))
        elif isinstance(label, ExcelFormula.Formula):
            self.__parent_wb.add_sheet_reference(label)
            self.insert_cell(col, FormulaCell(self.__idx, col, style_index, label))
        else:
            raise Exception("Unexpected data type %r" % type(label))

    write_blanks = set_cell_mulblanks




########NEW FILE########
__FILENAME__ = Style
# -*- coding: windows-1252 -*-

from . import Formatting
from .BIFFRecords import *
import collections

FIRST_USER_DEFINED_NUM_FORMAT_IDX = 164

class XFStyle(object):

    def __init__(self):
        self.num_format_str  = 'General'
        self.font            = Formatting.Font()
        self.alignment       = Formatting.Alignment()
        self.borders         = Formatting.Borders()
        self.pattern         = Formatting.Pattern()
        self.protection      = Formatting.Protection()

default_style = XFStyle()

class StyleCollection(object):
    _std_num_fmt_list = [
            'general',
            '0',
            '0.00',
            '#,##0',
            '#,##0.00',
            '"$"#,##0_);("$"#,##',
            '"$"#,##0_);[Red]("$"#,##',
            '"$"#,##0.00_);("$"#,##',
            '"$"#,##0.00_);[Red]("$"#,##',
            '0%',
            '0.00%',
            '0.00E+00',
            '# ?/?',
            '# ??/??',
            'M/D/YY',
            'D-MMM-YY',
            'D-MMM',
            'MMM-YY',
            'h:mm AM/PM',
            'h:mm:ss AM/PM',
            'h:mm',
            'h:mm:ss',
            'M/D/YY h:mm',
            '_(#,##0_);(#,##0)',
            '_(#,##0_);[Red](#,##0)',
            '_(#,##0.00_);(#,##0.00)',
            '_(#,##0.00_);[Red](#,##0.00)',
            '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',
            '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
            '_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',
            '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',
            'mm:ss',
            '[h]:mm:ss',
            'mm:ss.0',
            '##0.0E+0',
            '@'
    ]

    def __init__(self, style_compression=0):
        self.style_compression = style_compression
        self.stats = [0, 0, 0, 0, 0, 0]
        self._font_id2x = {}
        self._font_x2id = {}
        self._font_val2x = {}

        for x in (0, 1, 2, 3, 5): # The font with index 4 is omitted in all BIFF versions
            font = Formatting.Font()
            search_key = font._search_key()
            self._font_id2x[font] = x
            self._font_x2id[x] = font
            self._font_val2x[search_key] = x

        self._xf_id2x = {}
        self._xf_x2id = {}
        self._xf_val2x = {}

        self._num_formats = {}
        for fmtidx, fmtstr in zip(list(range(0, 23)), StyleCollection._std_num_fmt_list[0:23]):
            self._num_formats[fmtstr] = fmtidx
        for fmtidx, fmtstr in zip(list(range(37, 50)), StyleCollection._std_num_fmt_list[23:]):
            self._num_formats[fmtstr] = fmtidx

        self.default_style = XFStyle()
        self._default_xf = self._add_style(self.default_style)[0]

    def add(self, style):
        if style == None:
            return 0x10
        return self._add_style(style)[1]

    def _add_style(self, style):
        num_format_str = style.num_format_str
        if num_format_str in self._num_formats:
            num_format_idx = self._num_formats[num_format_str]
        else:
            num_format_idx = (
                FIRST_USER_DEFINED_NUM_FORMAT_IDX
                + len(self._num_formats)
                - len(StyleCollection._std_num_fmt_list)
                )
            self._num_formats[num_format_str] = num_format_idx

        font = style.font
        if font in self._font_id2x:
            font_idx = self._font_id2x[font]
            self.stats[0] += 1
        elif self.style_compression:
            search_key = font._search_key()
            font_idx = self._font_val2x.get(search_key)
            if font_idx is not None:
                self._font_id2x[font] = font_idx
                self.stats[1] += 1
            else:
                font_idx = len(self._font_x2id) + 1 # Why plus 1? Font 4 is missing
                self._font_id2x[font] = font_idx
                self._font_val2x[search_key] = font_idx
                self._font_x2id[font_idx] = font
                self.stats[2] += 1
        else:
            font_idx = len(self._font_id2x) + 1
            self._font_id2x[font] = font_idx
            self.stats[2] += 1

        gof = (style.alignment, style.borders, style.pattern, style.protection)
        xf = (font_idx, num_format_idx) + gof
        if xf in self._xf_id2x:
            xf_index = self._xf_id2x[xf]
            self.stats[3] += 1
        elif self.style_compression == 2:
            xf_key = (font_idx, num_format_idx) + tuple([obj._search_key() for obj in gof])
            xf_index = self._xf_val2x.get(xf_key)
            if xf_index is not None:
                self._xf_id2x[xf] = xf_index
                self.stats[4] += 1
            else:
                xf_index = 0x10 + len(self._xf_x2id)
                self._xf_id2x[xf] = xf_index
                self._xf_val2x[xf_key] = xf_index
                self._xf_x2id[xf_index] = xf
                self.stats[5] += 1
        else:
            xf_index = 0x10 + len(self._xf_id2x)
            self._xf_id2x[xf] = xf_index
            self.stats[5] += 1

        if xf_index >= 0xFFF:
            # 12 bits allowed, 0xFFF is a sentinel value
            raise ValueError("More than 4094 XFs (styles)")

        return xf, xf_index

    def get_biff_data(self):
        result = b''
        result += self._all_fonts()
        result += self._all_num_formats()
        result += self._all_cell_styles()
        result += self._all_styles()
        return result

    def _all_fonts(self):
        result = b''
        if self.style_compression:
            alist = list(self._font_x2id.items())
        else:
            alist = [(x, o) for o, x in list(self._font_id2x.items())]
        alist.sort()
        for font_idx, font in alist:
            result += font.get_biff_record().get()
        return result

    def _all_num_formats(self):
        result = b''
        alist = [
            (v, k)
            for k, v in list(self._num_formats.items())
            if v >= FIRST_USER_DEFINED_NUM_FORMAT_IDX
            ]
        alist.sort()
        for fmtidx, fmtstr in alist:
            result += NumberFormatRecord(fmtidx, fmtstr).get()
        return result

    def _all_cell_styles(self):
        result = b''
        for i in range(0, 16):
            result += XFRecord(self._default_xf, 'style').get()
        if self.style_compression == 2:
            alist = list(self._xf_x2id.items())
        else:
            alist = [(x, o) for o, x in list(self._xf_id2x.items())]
        alist.sort()
        for xf_idx, xf in alist:
            result += XFRecord(xf).get()
        return result

    def _all_styles(self):
        return StyleRecord().get()

# easyxf and its supporting objects ###################################

class EasyXFException(Exception):
    pass

class EasyXFCallerError(EasyXFException):
    pass

class EasyXFAuthorError(EasyXFException):
    pass

class IntULim(object):
    # If astring represents a valid unsigned integer ('123', '0xabcd', etc)
    # and it is <= limit, return the int value; otherwise return None.

    def __init__(self, limit):
        self.limit = limit

    def __call__(self, astring):
        try:
            value = int(astring, 0)
        except ValueError:
            return None
        if not 0 <= value <= self.limit:
            return None
        return value

bool_map = {
    # Text values for all Boolean attributes
    '1': 1, 'yes': 1, 'true':  1, 'on':  1,
    '0': 0, 'no':  0, 'false': 0, 'off': 0,
    }

border_line_map = {
    # Text values for these borders attributes:
    # left, right, top, bottom and diag
    'no_line':  0x00,
    'thin':     0x01,
    'medium':   0x02,
    'dashed':   0x03,
    'dotted':   0x04,
    'thick':    0x05,
    'double':   0x06,
    'hair':     0x07,
    'medium_dashed':                0x08,
    'thin_dash_dotted':             0x09,
    'medium_dash_dotted':           0x0a,
    'thin_dash_dot_dotted':         0x0b,
    'medium_dash_dot_dotted':       0x0c,
    'slanted_medium_dash_dotted':   0x0d,
    }

charset_map = {
    # Text values for font.charset
    'ansi_latin':           0x00,
    'sys_default':          0x01,
    'symbol':               0x02,
    'apple_roman':          0x4d,
    'ansi_jap_shift_jis':   0x80,
    'ansi_kor_hangul':      0x81,
    'ansi_kor_johab':       0x82,
    'ansi_chinese_gbk':     0x86,
    'ansi_chinese_big5':    0x88,
    'ansi_greek':           0xa1,
    'ansi_turkish':         0xa2,
    'ansi_vietnamese':      0xa3,
    'ansi_hebrew':          0xb1,
    'ansi_arabic':          0xb2,
    'ansi_baltic':          0xba,
    'ansi_cyrillic':        0xcc,
    'ansi_thai':            0xde,
    'ansi_latin_ii':        0xee,
    'oem_latin_i':          0xff,
    }


# Text values for colour indices. "grey" is a synonym of "gray".
# The names are those given by Microsoft Excel 2003 to the colours
# in the default palette. There is no great correspondence with
# any W3C name-to-RGB mapping.
_colour_map_text = """\
aqua 0x31
black 0x08
blue 0x0C
blue_gray 0x36
bright_green 0x0B
brown 0x3C
coral 0x1D
cyan_ega 0x0F
dark_blue 0x12
dark_blue_ega 0x12
dark_green 0x3A
dark_green_ega 0x11
dark_purple 0x1C
dark_red 0x10
dark_red_ega 0x10
dark_teal 0x38
dark_yellow 0x13
gold 0x33
gray_ega 0x17
gray25 0x16
gray40 0x37
gray50 0x17
gray80 0x3F
green 0x11
ice_blue 0x1F
indigo 0x3E
ivory 0x1A
lavender 0x2E
light_blue 0x30
light_green 0x2A
light_orange 0x34
light_turquoise 0x29
light_yellow 0x2B
lime 0x32
magenta_ega 0x0E
ocean_blue 0x1E
olive_ega 0x13
olive_green 0x3B
orange 0x35
pale_blue 0x2C
periwinkle 0x18
pink 0x0E
plum 0x3D
purple_ega 0x14
red 0x0A
rose 0x2D
sea_green 0x39
silver_ega 0x16
sky_blue 0x28
tan 0x2F
teal 0x15
teal_ega 0x15
turquoise 0x0F
violet 0x14
white 0x09
yellow 0x0D"""

colour_map = {}
for _line in _colour_map_text.splitlines():
    _name, _num = _line.split()
    _num = int(_num, 0)
    colour_map[_name] = _num
    if 'gray' in _name:
        colour_map[_name.replace('gray', 'grey')] = _num
del _colour_map_text, _line, _name, _num


pattern_map = {
    # Text values for pattern.pattern
    # xlwt/doc/pattern_examples.xls showcases all of these patterns.
    'no_fill':              0,
    'none':                 0,
    'solid':                1,
    'solid_fill':           1,
    'solid_pattern':        1,
    'fine_dots':            2,
    'alt_bars':             3,
    'sparse_dots':          4,
    'thick_horz_bands':     5,
    'thick_vert_bands':     6,
    'thick_backward_diag':  7,
    'thick_forward_diag':   8,
    'big_spots':            9,
    'bricks':               10,
    'thin_horz_bands':      11,
    'thin_vert_bands':      12,
    'thin_backward_diag':   13,
    'thin_forward_diag':    14,
    'squares':              15,
    'diamonds':             16,
    }

def any_str_func(s):
    return s.strip()

def colour_index_func(s, maxval=0x7F):
    try:
        value = int(s, 0)
    except ValueError:
        return None
    if not (0 <= value <= maxval):
        return None
    return value

colour_index_func_7 = colour_index_func

def colour_index_func_15(s):
    return colour_index_func(s, maxval=0x7FFF)

def rotation_func(s):
    try:
        value = int(s, 0)
    except ValueError:
        return None
    if not (-90 <= value <= 90):
        raise EasyXFCallerError("rotation %d: should be -90 to +90 degrees" % value)
    if value < 0:
        value = 90 - value # encode as 91 to 180 (clockwise)
    return value

xf_dict = {
    'align': 'alignment', # synonym
    'alignment': {
        'dire': {
            'general': 0,
            'lr': 1,
            'rl': 2,
            },
        'direction': 'dire',
        'horiz': 'horz',
        'horizontal': 'horz',
        'horz': {
            'general': 0,
            'left': 1,
            'center': 2,
            'centre': 2, # "align: horiz centre" means xf.alignment.horz is set to 2
            'right': 3,
            'filled': 4,
            'justified': 5,
            'center_across_selection': 6,
            'centre_across_selection': 6,
            'distributed': 7,
            },
        'inde': IntULim(15), # restriction: 0 <= value <= 15
        'indent': 'inde',
        'rota': [{'stacked': 255, 'none': 0, }, rotation_func],
        'rotation': 'rota',
        'shri': bool_map,
        'shrink': 'shri',
        'shrink_to_fit': 'shri',
        'vert': {
            'top': 0,
            'center': 1,
            'centre': 1,
            'bottom': 2,
            'justified': 3,
            'distributed': 4,
            },
         'vertical': 'vert',
         'wrap': bool_map,
         },
    'border': 'borders',
    'borders': {
        'left':     [border_line_map, IntULim(0x0d)],
        'right':    [border_line_map, IntULim(0x0d)],
        'top':      [border_line_map, IntULim(0x0d)],
        'bottom':   [border_line_map, IntULim(0x0d)],
        'diag':     [border_line_map, IntULim(0x0d)],
        'top_colour':       [colour_map, colour_index_func_7],
        'bottom_colour':    [colour_map, colour_index_func_7],
        'left_colour':      [colour_map, colour_index_func_7],
        'right_colour':     [colour_map, colour_index_func_7],
        'diag_colour':      [colour_map, colour_index_func_7],
        'top_color':        'top_colour',
        'bottom_color':     'bottom_colour',
        'left_color':       'left_colour',
        'right_color':      'right_colour',
        'diag_color':       'diag-colour',
        'need_diag_1':  bool_map,
        'need_diag_2':  bool_map,
        },
    'font': {
        'bold': bool_map,
        'charset': charset_map,
        'color':  'colour_index',
        'color_index':  'colour_index',
        'colour':  'colour_index',
        'colour_index': [colour_map, colour_index_func_15],
        'escapement': {'none': 0, 'superscript': 1, 'subscript': 2},
        'family': {'none': 0, 'roman': 1, 'swiss': 2, 'modern': 3, 'script': 4, 'decorative': 5, },
        'height': IntULim(0xFFFF), # practical limits are much narrower e.g. 160 to 1440 (8pt to 72pt)
        'italic': bool_map,
        'name': any_str_func,
        'outline': bool_map,
        'shadow': bool_map,
        'struck_out': bool_map,
        'underline': [bool_map, {'none': 0, 'single': 1, 'single_acc': 0x21, 'double': 2, 'double_acc': 0x22, }],
        },
    'pattern': {
        'back_color':   'pattern_back_colour',
        'back_colour':  'pattern_back_colour',
        'fore_color':   'pattern_fore_colour',
        'fore_colour':  'pattern_fore_colour',
        'pattern': [pattern_map, IntULim(16)],
        'pattern_back_color':   'pattern_back_colour',
        'pattern_back_colour':  [colour_map, colour_index_func_7],
        'pattern_fore_color':   'pattern_fore_colour',
        'pattern_fore_colour':  [colour_map, colour_index_func_7],
        },
    'protection': {
        'cell_locked' :   bool_map,
        'formula_hidden': bool_map,
        },
    }

def _esplit(s, split_char, esc_char="\\"):
    escaped = False
    olist = ['']
    for c in s:
        if escaped:
            olist[-1] += c
            escaped = False
        elif c == esc_char:
            escaped = True
        elif c == split_char:
            olist.append('')
        else:
            olist[-1] += c
    return olist

def _parse_strg_to_obj(strg, obj, parse_dict,
    field_sep=",", line_sep=";", intro_sep=":", esc_char="\\", debug=False):
    for line in _esplit(strg, line_sep, esc_char):
        line = line.strip()
        if not line:
            break
        split_line = _esplit(line, intro_sep, esc_char)
        if len(split_line) != 2:
            raise EasyXFCallerError('line %r should have exactly 1 "%c"' % (line, intro_sep))
        section, item_str = split_line
        section = section.strip().lower()
        for counter in range(2):
            result = parse_dict.get(section)
            if result is None:
                raise EasyXFCallerError('section %r is unknown' % section)
            if isinstance(result, dict):
                break
            if not isinstance(result, str):
                raise EasyXFAuthorError(
                    'section %r should map to dict or str object; found %r' % (section, type(result)))
            # synonym
            old_section = section
            section = result
        else:
            raise EasyXFAuthorError('Attempt to define synonym of synonym (%r: %r)' % (old_section, result))
        section_dict = result
        section_obj = getattr(obj, section, None)
        if section_obj is None:
            raise EasyXFAuthorError('instance of %s class has no attribute named %s' % (obj.__class__.__name__, section))
        for kv_str in _esplit(item_str, field_sep, esc_char):
            guff = kv_str.split()
            if not guff:
                continue
            k = guff[0].lower().replace('-', '_')
            v = ' '.join(guff[1:])
            if not v:
                raise EasyXFCallerError("no value supplied for %s.%s" % (section, k))
            for counter in range(2):
                result = section_dict.get(k)
                if result is None:
                    raise EasyXFCallerError('%s.%s is not a known attribute' % (section, k))
                if not isinstance(result, str):
                    break
                # synonym
                old_k = k
                k = result
            else:
                raise EasyXFAuthorError('Attempt to define synonym of synonym (%r: %r)' % (old_k, result))
            value_info = result
            if not isinstance(value_info, list):
                value_info = [value_info]
            for value_rule in value_info:
                if isinstance(value_rule, dict):
                    # dict maps strings to integer field values
                    vl = v.lower().replace('-', '_')
                    if vl in value_rule:
                        value = value_rule[vl]
                        break
                elif isinstance(value_rule, collections.Callable):
                    value = value_rule(v)
                    if value is not None:
                        break
                else:
                    raise EasyXFAuthorError("unknown value rule for attribute %r: %r" % (k, value_rule))
            else:
                raise EasyXFCallerError("unexpected value %r for %s.%s" % (v, section, k))
            try:
                orig = getattr(section_obj, k)
            except AttributeError:
                raise EasyXFAuthorError('%s.%s in dictionary but not in supplied object' % (section, k))
            if debug: print("+++ %s.%s = %r # %s; was %r" % (section, k, value, v, orig))
            setattr(section_obj, k, value)

def easyxf(strg_to_parse="", num_format_str=None,
    field_sep=",", line_sep=";", intro_sep=":", esc_char="\\", debug=False):
    xfobj = XFStyle()
    if num_format_str is not None:
        xfobj.num_format_str = num_format_str
    if strg_to_parse:
        _parse_strg_to_obj(strg_to_parse, xfobj, xf_dict,
            field_sep=field_sep, line_sep=line_sep, intro_sep=intro_sep, esc_char=esc_char, debug=debug)
    return xfobj

########NEW FILE########
__FILENAME__ = UnicodeUtils
'''
From BIFF8 on, strings are always stored using UTF-16LE  text encoding. The
character  array  is  a  sequence  of  16-bit  values4.  Additionally it is
possible  to  use  a  compressed  format, which omits the high bytes of all
characters, if they are all zero.

The following tables describe the standard format of the entire string, but
in many records the strings differ from this format. This will be mentioned
separately. It is possible (but not required) to store Rich-Text formatting
information  and  Asian  phonetic information inside a Unicode string. This
results  in  four  different  ways  to  store a string. The character array
is not zero-terminated.

The  string  consists  of  the  character count (as usual an 8-bit value or
a  16-bit value), option flags, the character array and optional formatting
information.  If the string is empty, sometimes the option flags field will
not occur. This is mentioned at the respective place.

Offset  Size    Contents
0       1 or 2  Length of the string (character count, ln)
1 or 2  1       Option flags:
                  Bit   Mask Contents
                  0     01H  Character compression (ccompr):
                               0 = Compressed (8-bit characters)
                               1 = Uncompressed (16-bit characters)
                  2     04H  Asian phonetic settings (phonetic):
                               0 = Does not contain Asian phonetic settings
                               1 = Contains Asian phonetic settings
                  3     08H  Rich-Text settings (richtext):
                               0 = Does not contain Rich-Text settings
                               1 = Contains Rich-Text settings
[2 or 3] 2      (optional, only if richtext=1) Number of Rich-Text formatting runs (rt)
[var.]   4      (optional, only if phonetic=1) Size of Asian phonetic settings block (in bytes, sz)
var.     ln or
         2ln   Character array (8-bit characters or 16-bit characters, dependent on ccompr)
[var.]   4rt   (optional, only if richtext=1) List of rt formatting runs
[var.]   sz     (optional, only if phonetic=1) Asian Phonetic Settings Block
'''


from struct import pack

def upack2(s, encoding='ascii'):
    # If not unicode, make it so.
    if isinstance(s, str):
        us = s
    else:
        us = str(s, encoding)
    # Limit is based on number of content characters
    # (not on number of bytes in packed result)
    len_us = len(us)
    if len_us > 65535:
        raise Exception('String longer than 65535 characters')
    try:
        encs = us.encode('latin1')
        # Success here means all chars are in U+0000 to U+00FF
        # inclusive, meaning that we can use "compressed format".
        flag = 0
    except UnicodeEncodeError:
        encs = us.encode('utf_16_le')
        flag = 1
    return pack('<HB', len_us, flag) + encs

def upack1(s, encoding='ascii'):
    # Same as upack2(), but with a one-byte length field.
    if isinstance(s, str):
        us = s
    else:
        us = str(s, encoding)
    len_us = len(us)
    if len_us > 255:
        raise Exception('String longer than 255 characters')
    try:
        encs = us.encode('latin1')
        flag = 0
    except UnicodeEncodeError:
        encs = us.encode('utf_16_le')
        flag = 1
    return pack('<BB', len_us, flag) + encs

########NEW FILE########
__FILENAME__ = Utils
# pyXLWriter: A library for generating Excel Spreadsheets
# Copyright (c) 2004 Evgeny Filatov <fufff@users.sourceforge.net>
# Copyright (c) 2002-2004 John McNamara (Perl Spreadsheet::WriteExcel)
#
# This library is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# This library is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser
# General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this library; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#----------------------------------------------------------------------------
# This module was written/ported from PERL Spreadsheet::WriteExcel module
# The author of the PERL Spreadsheet::WriteExcel module is John McNamara
# <jmcnamara@cpan.org>
#----------------------------------------------------------------------------
# See the README.txt distributed with pyXLWriter for more details.

# Portions are (C) Roman V. Kiseliov, 2005


# Utilities for work with reference to cells and with sheetnames


__rev_id__ = """$Id: Utils.py 3844 2009-05-20 01:02:54Z sjmachin $"""

import re
from struct import pack
from .ExcelMagic import MAX_ROW, MAX_COL


_re_cell_ex = re.compile(r"(\$?)([A-I]?[A-Z])(\$?)(\d+)", re.IGNORECASE)
_re_row_range = re.compile(r"\$?(\d+):\$?(\d+)")
_re_col_range = re.compile(r"\$?([A-I]?[A-Z]):\$?([A-I]?[A-Z])", re.IGNORECASE)
_re_cell_range = re.compile(r"\$?([A-I]?[A-Z]\$?\d+):\$?([A-I]?[A-Z]\$?\d+)", re.IGNORECASE)
_re_cell_ref = re.compile(r"\$?([A-I]?[A-Z]\$?\d+)", re.IGNORECASE)


def col_by_name(colname):
    """
    """
    col = 0
    pow = 1
    for i in range(len(colname)-1, -1, -1):
        ch = colname[i]
        col += (ord(ch) - ord('A') + 1) * pow
        pow *= 26
    return col - 1


def cell_to_rowcol(cell):
    """Convert an Excel cell reference string in A1 notation
    to numeric row/col notation.

    Returns: row, col, row_abs, col_abs

    """
    m = _re_cell_ex.match(cell)
    if not m:
        raise Exception("Ill-formed single_cell reference: %s" % cell)
    col_abs, col, row_abs, row = m.groups()
    row_abs = bool(row_abs)
    col_abs = bool(col_abs)
    row = int(row) - 1
    col = col_by_name(col.upper())
    return row, col, row_abs, col_abs


def cell_to_rowcol2(cell):
    """Convert an Excel cell reference string in A1 notation
    to numeric row/col notation.

    Returns: row, col

    """
    m = _re_cell_ex.match(cell)
    if not m:
        raise Exception("Error in cell format")
    col_abs, col, row_abs, row = m.groups()
    # Convert base26 column string to number
    # All your Base are belong to us.
    row = int(row) - 1
    col = col_by_name(col.upper())
    return row, col


def rowcol_to_cell(row, col, row_abs=False, col_abs=False):
    """Convert numeric row/col notation to an Excel cell reference string in
    A1 notation.

    """
    assert 0 <= row < MAX_ROW # MAX_ROW counts from 1
    assert 0 <= col < MAX_COL # MAX_COL counts from 1
    d = col // 26
    m = col % 26
    chr1 = ""    # Most significant character in AA1
    if row_abs:
        row_abs = '$'
    else:
        row_abs = ''
    if col_abs:
        col_abs = '$'
    else:
        col_abs = ''
    if d > 0:
        chr1 = chr(ord('A') + d  - 1)
    chr2 = chr(ord('A') + m)
    # Zero index to 1-index
    return col_abs + chr1 + chr2 + row_abs + str(row + 1)

def rowcol_pair_to_cellrange(row1, col1, row2, col2,
    row1_abs=False, col1_abs=False, row2_abs=False, col2_abs=False):
    """Convert two (row,column) pairs
    into a cell range string in A1:B2 notation.

    Returns: cell range string
    """
    assert row1 <= row2
    assert col1 <= col2
    return (
        rowcol_to_cell(row1, col1, row1_abs, col1_abs)
        + ":"
        + rowcol_to_cell(row2, col2, row2_abs, col2_abs)
        )

def cellrange_to_rowcol_pair(cellrange):
    """Convert cell range string in A1 notation to numeric row/col
    pair.

    Returns: row1, col1, row2, col2

    """
    cellrange = cellrange.upper()
    # Convert a row range: '1:3'
    res = _re_row_range.match(cellrange)
    if res:
        row1 = int(res.group(1)) - 1
        col1 = 0
        row2 = int(res.group(2)) - 1
        col2 = -1
        return row1, col1, row2, col2
    # Convert a column range: 'A:A' or 'B:G'.
    # A range such as A:A is equivalent to A1:A16384, so add rows as required
    res = _re_col_range.match(cellrange)
    if res:
        col1 = col_by_name(res.group(1).upper())
        row1 = 0
        col2 = col_by_name(res.group(2).upper())
        row2 = -1
        return row1, col1, row2, col2
    # Convert a cell range: 'A1:B7'
    res = _re_cell_range.match(cellrange)
    if res:
        row1, col1 = cell_to_rowcol2(res.group(1))
        row2, col2 = cell_to_rowcol2(res.group(2))
        return row1, col1, row2, col2
    # Convert a cell reference: 'A1' or 'AD2000'
    res = _re_cell_ref.match(cellrange)
    if res:
        row1, col1 = cell_to_rowcol2(res.group(1))
        return row1, col1, row1, col1
    raise Exception("Unknown cell reference %s" % (cell))


def cell_to_packed_rowcol(cell):
    """ pack row and column into the required 4 byte format """
    row, col, row_abs, col_abs = cell_to_rowcol(cell)
    if col >= MAX_COL:
        raise Exception("Column %s greater than IV in formula" % cell)
    if row >= MAX_ROW: # this for BIFF8. for BIFF7 available 2^14
        raise Exception("Row %s greater than %d in formula" % (cell, MAX_ROW))
    col |= int(not row_abs) << 15
    col |= int(not col_abs) << 14
    return row, col

# === sheetname functions ===

def valid_sheet_name(sheet_name):
    if sheet_name == "" or sheet_name[0] == "'" or len(sheet_name) > 31:
        return False
    for c in sheet_name:
        if c in "[]:\\?/*\x00":
            return False
    return True

def quote_sheet_name(unquoted_sheet_name):
    if not valid_sheet_name(unquoted_sheet_name):
        raise Exception(
            'attempt to quote an invalid worksheet name %r' % unquoted_sheet_name)
    return "'" + unquoted_sheet_name.replace("'", "''") + "'"

########NEW FILE########
__FILENAME__ = Workbook
'''
Record Order in BIFF8
  Workbook Globals Substream
      BOF Type = workbook globals
      Interface Header
      MMS
      Interface End
      WRITEACCESS
      CODEPAGE
      DSF
      TABID
      FNGROUPCOUNT
      Workbook Protection Block
            WINDOWPROTECT
            PROTECT
            PASSWORD
            PROT4REV
            PROT4REVPASS
      BACKUP
      HIDEOBJ
      WINDOW1
      DATEMODE
      PRECISION
      REFRESHALL
      BOOKBOOL
      FONT +
      FORMAT *
      XF +
      STYLE +
    ? PALETTE
      USESELFS

      BOUNDSHEET +

      COUNTRY
    ? Link Table
      SST
      ExtSST
      EOF
'''

from . import BIFFRecords
from . import Style

class Workbook(object):

    #################################################################
    ## Constructor
    #################################################################
    def __init__(self, encoding='ascii', style_compression=0):
        self.encoding = encoding
        self.__owner = 'None'
        self.__country_code = None # 0x07 is Russia :-)
        self.__wnd_protect = 0
        self.__obj_protect = 0
        self.__protect = 0
        self.__backup_on_save = 0
        # for WINDOW1 record
        self.__hpos_twips = 0x01E0
        self.__vpos_twips = 0x005A
        self.__width_twips = 0x3FCF
        self.__height_twips = 0x2A4E

        self.__active_sheet = 0
        self.__first_tab_index = 0
        self.__selected_tabs = 0x01
        self.__tab_width_twips = 0x0258

        self.__wnd_hidden = 0
        self.__wnd_mini = 0
        self.__hscroll_visible = 1
        self.__vscroll_visible = 1
        self.__tabs_visible = 1

        self.__styles = Style.StyleCollection(style_compression)

        self.__dates_1904 = 0
        self.__use_cell_values = 1

        self.__sst = BIFFRecords.SharedStringTable(self.encoding)

        self.__worksheets = []
        self.__worksheet_idx_from_name = {}
        self.__sheet_refs = {}
        self._supbook_xref = {}
        self._xcall_xref = {}
        self._ownbook_supbookx = None
        self._ownbook_supbook_ref = None
        self._xcall_supbookx = None
        self._xcall_supbook_ref = None



    #################################################################
    ## Properties, "getters", "setters"
    #################################################################

    def get_style_stats(self):
        return self.__styles.stats[:]

    def set_owner(self, value):
        self.__owner = value

    def get_owner(self):
        return self.__owner

    owner = property(get_owner, set_owner)

    #################################################################

    def set_country_code(self, value):
        self.__country_code = value

    def get_country_code(self):
        return self.__country_code

    country_code = property(get_country_code, set_country_code)

    #################################################################

    def set_wnd_protect(self, value):
        self.__wnd_protect = int(value)

    def get_wnd_protect(self):
        return bool(self.__wnd_protect)

    wnd_protect = property(get_wnd_protect, set_wnd_protect)

    #################################################################

    def set_obj_protect(self, value):
        self.__obj_protect = int(value)

    def get_obj_protect(self):
        return bool(self.__obj_protect)

    obj_protect = property(get_obj_protect, set_obj_protect)

    #################################################################

    def set_protect(self, value):
        self.__protect = int(value)

    def get_protect(self):
        return bool(self.__protect)

    protect = property(get_protect, set_protect)

    #################################################################

    def set_backup_on_save(self, value):
        self.__backup_on_save = int(value)

    def get_backup_on_save(self):
        return bool(self.__backup_on_save)

    backup_on_save = property(get_backup_on_save, set_backup_on_save)

    #################################################################

    def set_hpos(self, value):
        self.__hpos_twips = value & 0xFFFF

    def get_hpos(self):
        return self.__hpos_twips

    hpos = property(get_hpos, set_hpos)

    #################################################################

    def set_vpos(self, value):
        self.__vpos_twips = value & 0xFFFF

    def get_vpos(self):
        return self.__vpos_twips

    vpos = property(get_vpos, set_vpos)

    #################################################################

    def set_width(self, value):
        self.__width_twips = value & 0xFFFF

    def get_width(self):
        return self.__width_twips

    width = property(get_width, set_width)

    #################################################################

    def set_height(self, value):
        self.__height_twips = value & 0xFFFF

    def get_height(self):
        return self.__height_twips

    height = property(get_height, set_height)

    #################################################################

    def set_active_sheet(self, value):
        self.__active_sheet = value & 0xFFFF
        self.__first_tab_index = self.__active_sheet

    def get_active_sheet(self):
        return self.__active_sheet

    active_sheet = property(get_active_sheet, set_active_sheet)

    #################################################################

    def set_tab_width(self, value):
        self.__tab_width_twips = value & 0xFFFF

    def get_tab_width(self):
        return self.__tab_width_twips

    tab_width = property(get_tab_width, set_tab_width)

    #################################################################

    def set_wnd_visible(self, value):
        self.__wnd_hidden = int(not value)

    def get_wnd_visible(self):
        return not bool(self.__wnd_hidden)

    wnd_visible = property(get_wnd_visible, set_wnd_visible)

    #################################################################

    def set_wnd_mini(self, value):
        self.__wnd_mini = int(value)

    def get_wnd_mini(self):
        return bool(self.__wnd_mini)

    wnd_mini = property(get_wnd_mini, set_wnd_mini)

    #################################################################

    def set_hscroll_visible(self, value):
        self.__hscroll_visible = int(value)

    def get_hscroll_visible(self):
        return bool(self.__hscroll_visible)

    hscroll_visible = property(get_hscroll_visible, set_hscroll_visible)

    #################################################################

    def set_vscroll_visible(self, value):
        self.__vscroll_visible = int(value)

    def get_vscroll_visible(self):
        return bool(self.__vscroll_visible)

    vscroll_visible = property(get_vscroll_visible, set_vscroll_visible)

    #################################################################

    def set_tabs_visible(self, value):
        self.__tabs_visible = int(value)

    def get_tabs_visible(self):
        return bool(self.__tabs_visible)

    tabs_visible = property(get_tabs_visible, set_tabs_visible)

    #################################################################

    def set_dates_1904(self, value):
        self.__dates_1904 = int(value)

    def get_dates_1904(self):
        return bool(self.__dates_1904)

    dates_1904 = property(get_dates_1904, set_dates_1904)

    #################################################################

    def set_use_cell_values(self, value):
        self.__use_cell_values = int(value)

    def get_use_cell_values(self):
        return bool(self.__use_cell_values)

    use_cell_values = property(get_use_cell_values, set_use_cell_values)

    #################################################################

    def get_default_style(self):
        return self.__styles.default_style

    default_style = property(get_default_style)

    ##################################################################
    ## Methods
    ##################################################################

    def add_style(self, style):
        return self.__styles.add(style)

    def add_str(self, s):
        return self.__sst.add_str(s)

    def del_str(self, sst_idx):
        self.__sst.del_str(sst_idx)

    def str_index(self, s):
        return self.__sst.str_index(s)

    def add_sheet(self, sheetname, cell_overwrite_ok=False):
        from . import Worksheet, Utils
        if not isinstance(sheetname, str):
            sheetname = sheetname.decode(self.encoding)
        if not Utils.valid_sheet_name(sheetname):
            raise Exception("invalid worksheet name %r" % sheetname)
        lower_name = sheetname.lower()
        if lower_name in self.__worksheet_idx_from_name:
            raise Exception("duplicate worksheet name %r" % sheetname)
        self.__worksheet_idx_from_name[lower_name] = len(self.__worksheets)
        self.__worksheets.append(Worksheet(sheetname, self, cell_overwrite_ok))
        return self.__worksheets[-1]

    def get_sheet(self, sheetnum):
        return self.__worksheets[sheetnum]

    def raise_bad_sheetname(self, sheetname):
        raise Exception("Formula: unknown sheet name %s" % sheetname)

    def convert_sheetindex(self, strg_ref, n_sheets):
        idx = int(strg_ref)
        if 0 <= idx < n_sheets:
            return idx
        msg = "Formula: sheet index (%s) >= number of sheets (%d)" % (strg_ref, n_sheets)
        raise Exception(msg)

    def _get_supbook_index(self, tag):
        if tag in self._supbook_xref:
            return self._supbook_xref[tag]
        self._supbook_xref[tag] = idx = len(self._supbook_xref)
        return idx

    def setup_ownbook(self):
        self._ownbook_supbookx = self._get_supbook_index(('ownbook', 0))
        self._ownbook_supbook_ref = None
        reference = (self._ownbook_supbookx, 0xFFFE, 0xFFFE)
        if reference in self.__sheet_refs:
            raise Exception("can't happen")
        self.__sheet_refs[reference] = self._ownbook_supbook_ref = len(self.__sheet_refs)

    def setup_xcall(self):
        self._xcall_supbookx = self._get_supbook_index(('xcall', 0))
        self._xcall_supbook_ref = None
        reference = (self._xcall_supbookx, 0xFFFE, 0xFFFE)
        if reference in self.__sheet_refs:
            raise Exception("can't happen")
        self.__sheet_refs[reference] = self._xcall_supbook_ref = len(self.__sheet_refs)

    def add_sheet_reference(self, formula):
        patches = []
        n_sheets = len(self.__worksheets)
        sheet_refs, xcall_refs = formula.get_references()

        for ref0, ref1, offset in sheet_refs:
            if not ref0.isdigit():
                try:
                    ref0n = self.__worksheet_idx_from_name[ref0.lower()]
                except KeyError:
                    self.raise_bad_sheetname(ref0)
            else:
                ref0n = self.convert_sheetindex(ref0, n_sheets)
            if ref1 == ref0:
                ref1n = ref0n
            elif not ref1.isdigit():
                try:
                    ref1n = self.__worksheet_idx_from_name[ref1.lower()]
                except KeyError:
                    self.raise_bad_sheetname(ref1)
            else:
                ref1n = self.convert_sheetindex(ref1, n_sheets)
            if ref1n < ref0n:
                msg = "Formula: sheets out of order; %r:%r -> (%d, %d)" \
                    % (ref0, ref1, ref0n, ref1n)
                raise Exception(msg)
            if self._ownbook_supbookx is None:
                self.setup_ownbook()
            reference = (self._ownbook_supbookx, ref0n, ref1n)
            if reference in self.__sheet_refs:
                patches.append((offset, self.__sheet_refs[reference]))
            else:
                nrefs = len(self.__sheet_refs)
                if nrefs > 65535:
                    raise Exception('More than 65536 inter-sheet references')
                self.__sheet_refs[reference] = nrefs
                patches.append((offset, nrefs))

        for funcname, offset in xcall_refs:
            if self._ownbook_supbookx is None:
                self.setup_ownbook()
            if self._xcall_supbookx is None:
                self.setup_xcall()
            # print funcname, self._supbook_xref
            patches.append((offset, self._xcall_supbook_ref))
            if not isinstance(funcname, str):
                funcname = funcname.decode(self.encoding)
            if funcname in self._xcall_xref:
                idx = self._xcall_xref[funcname]
            else:
                self._xcall_xref[funcname] = idx = len(self._xcall_xref)
            patches.append((offset + 2, idx + 1))

        formula.patch_references(patches)

    ##################################################################
    ## BIFF records generation
    ##################################################################

    def __bof_rec(self):
        return BIFFRecords.Biff8BOFRecord(BIFFRecords.Biff8BOFRecord.BOOK_GLOBAL).get()

    def __eof_rec(self):
        return BIFFRecords.EOFRecord().get()

    def __intf_hdr_rec(self):
        return BIFFRecords.InteraceHdrRecord().get()

    def __intf_end_rec(self):
        return BIFFRecords.InteraceEndRecord().get()

    def __intf_mms_rec(self):
        return BIFFRecords.MMSRecord().get()

    def __write_access_rec(self):
        return BIFFRecords.WriteAccessRecord(self.__owner).get()

    def __wnd_protect_rec(self):
        return BIFFRecords.WindowProtectRecord(self.__wnd_protect).get()

    def __obj_protect_rec(self):
        return BIFFRecords.ObjectProtectRecord(self.__obj_protect).get()

    def __protect_rec(self):
        return BIFFRecords.ProtectRecord(self.__protect).get()

    def __password_rec(self):
        return BIFFRecords.PasswordRecord().get()

    def __prot4rev_rec(self):
        return BIFFRecords.Prot4RevRecord().get()

    def __prot4rev_pass_rec(self):
        return BIFFRecords.Prot4RevPassRecord().get()

    def __backup_rec(self):
        return BIFFRecords.BackupRecord(self.__backup_on_save).get()

    def __hide_obj_rec(self):
        return BIFFRecords.HideObjRecord().get()

    def __window1_rec(self):
        flags = 0
        flags |= (self.__wnd_hidden) << 0
        flags |= (self.__wnd_mini) << 1
        flags |= (self.__hscroll_visible) << 3
        flags |= (self.__vscroll_visible) << 4
        flags |= (self.__tabs_visible) << 5

        return BIFFRecords.Window1Record(self.__hpos_twips, self.__vpos_twips,
                                self.__width_twips, self.__height_twips,
                                flags,
                                self.__active_sheet, self.__first_tab_index,
                                self.__selected_tabs, self.__tab_width_twips).get()

    def __codepage_rec(self):
        return BIFFRecords.CodepageBiff8Record().get()

    def __country_rec(self):
        if not self.__country_code:
            return b''
        return BIFFRecords.CountryRecord(self.__country_code, self.__country_code).get()

    def __dsf_rec(self):
        return BIFFRecords.DSFRecord().get()

    def __tabid_rec(self):
        return BIFFRecords.TabIDRecord(len(self.__worksheets)).get()

    def __fngroupcount_rec(self):
        return BIFFRecords.FnGroupCountRecord().get()

    def __datemode_rec(self):
        return BIFFRecords.DateModeRecord(self.__dates_1904).get()

    def __precision_rec(self):
        return BIFFRecords.PrecisionRecord(self.__use_cell_values).get()

    def __refresh_all_rec(self):
        return BIFFRecords.RefreshAllRecord().get()

    def __bookbool_rec(self):
        return BIFFRecords.BookBoolRecord().get()

    def __all_fonts_num_formats_xf_styles_rec(self):
        return self.__styles.get_biff_data()

    def __palette_rec(self):
        result = b''
        return result

    def __useselfs_rec(self):
        return BIFFRecords.UseSelfsRecord().get()

    def __boundsheets_rec(self, data_len_before, data_len_after, sheet_biff_lens):
        #  .................................
        # BOUNDSEHEET0
        # BOUNDSEHEET1
        # BOUNDSEHEET2
        # ..................................
        # WORKSHEET0
        # WORKSHEET1
        # WORKSHEET2
        boundsheets_len = 0
        for sheet in self.__worksheets:
            boundsheets_len += len(BIFFRecords.BoundSheetRecord(
                0x00, sheet.visibility, sheet.name, self.encoding
                ).get())

        start = data_len_before + boundsheets_len + data_len_after

        result = b''
        for sheet_biff_len,  sheet in zip(sheet_biff_lens, self.__worksheets):
            result += BIFFRecords.BoundSheetRecord(
                start, sheet.visibility, sheet.name, self.encoding
                ).get()
            start += sheet_biff_len
        return result

    def __all_links_rec(self):
        pieces = []
        temp = [(idx, tag) for tag, idx in list(self._supbook_xref.items())]
        temp.sort()
        for idx, tag in temp:
            stype, snum = tag
            if stype == 'ownbook':
                rec = BIFFRecords.InternalReferenceSupBookRecord(len(self.__worksheets)).get()
                pieces.append(rec)
            elif stype == 'xcall':
                rec = BIFFRecords.XcallSupBookRecord().get()
                pieces.append(rec)
                temp = [(idx, name) for name, idx in list(self._xcall_xref.items())]
                temp.sort()
                for idx, name in temp:
                    rec = BIFFRecords.ExternnameRecord(
                        options=0, index=0, name=name, fmla='\x02\x00\x1c\x17').get()
                    pieces.append(rec)
            else:
                raise Exception('unknown supbook stype %r' % stype)
        if len(self.__sheet_refs) > 0:
            # get references in index order
            temp = [(idx, ref) for ref, idx in list(self.__sheet_refs.items())]
            temp.sort()
            temp = [ref for idx, ref in temp]
            externsheet_record = BIFFRecords.ExternSheetRecord(temp).get()
            pieces.append(externsheet_record)
        return b''.join(pieces)

    def __sst_rec(self):
        return self.__sst.get_biff_record()

    def __ext_sst_rec(self, abs_stream_pos):
        return b''
        #return BIFFRecords.ExtSSTRecord(abs_stream_pos, self.sst_record.str_placement,
        #self.sst_record.portions_len).get()

    def get_biff_data(self):
        before = b''
        before += self.__bof_rec()
        before += self.__intf_hdr_rec()
        before += self.__intf_mms_rec()
        before += self.__intf_end_rec()
        before += self.__write_access_rec()
        before += self.__codepage_rec()
        before += self.__dsf_rec()
        before += self.__tabid_rec()
        before += self.__fngroupcount_rec()
        before += self.__wnd_protect_rec()
        before += self.__protect_rec()
        before += self.__obj_protect_rec()
        before += self.__password_rec()
        before += self.__prot4rev_rec()
        before += self.__prot4rev_pass_rec()
        before += self.__backup_rec()
        before += self.__hide_obj_rec()
        before += self.__window1_rec()
        before += self.__datemode_rec()
        before += self.__precision_rec()
        before += self.__refresh_all_rec()
        before += self.__bookbool_rec()
        before += self.__all_fonts_num_formats_xf_styles_rec()
        before += self.__palette_rec()
        before += self.__useselfs_rec()

        country = self.__country_rec()
        all_links = self.__all_links_rec()

        shared_str_table   = self.__sst_rec()
        after = country + all_links + shared_str_table

        ext_sst = self.__ext_sst_rec(0) # need fake cause we need calc stream pos
        eof = self.__eof_rec()

        self.__worksheets[self.__active_sheet].selected = True
        sheets = b''
        sheet_biff_lens = []
        for sheet in self.__worksheets:
            data = sheet.get_biff_data()
            sheets += data
            sheet_biff_lens.append(len(data))

        bundlesheets = self.__boundsheets_rec(len(before), len(after)+len(ext_sst)+len(eof), sheet_biff_lens)

        sst_stream_pos = len(before) + len(bundlesheets) + len(country)  + len(all_links)
        ext_sst = self.__ext_sst_rec(sst_stream_pos)

        return before + bundlesheets + after + ext_sst + eof + sheets

    def save(self, filename):
        from . import CompoundDoc

        doc = CompoundDoc.XlsDoc()
        doc.save(filename, self.get_biff_data())



########NEW FILE########
__FILENAME__ = Worksheet
'''
            BOF
            UNCALCED
            INDEX
            Calculation Settings Block
            PRINTHEADERS
            PRINTGRIDLINES
            GRIDSET
            GUTS
            DEFAULTROWHEIGHT
            WSBOOL
            Page Settings Block
            Worksheet Protection Block
            DEFCOLWIDTH
            COLINFO
            SORT
            DIMENSIONS
            Row Blocks
            WINDOW2
            SCL
            PANE
            SELECTION
            STANDARDWIDTH
            MERGEDCELLS
            LABELRANGES
            PHONETIC
            Conditional Formatting Table
            Hyperlink Table
            Data Validity Table
            SHEETLAYOUT (BIFF8X only)
            SHEETPROTECTION (BIFF8X only)
            RANGEPROTECTION (BIFF8X only)
            EOF
'''

from . import BIFFRecords
from . import Bitmap
from . import Formatting
from . import Style
import tempfile


class Worksheet(object):
    from .Workbook import Workbook

    #################################################################
    ## Constructor
    #################################################################
    def __init__(self, sheetname, parent_book, cell_overwrite_ok=False):
        from . import Row
        self.Row = Row #(to_py3): Row.Row -> Row

        from . import Column
        self.Column = Column #(to_py3): Column.Column -> Column

        self.__name = sheetname
        self.__parent = parent_book
        self._cell_overwrite_ok = cell_overwrite_ok

        self.__rows = {}
        self.__cols = {}
        self.__merged_ranges = []
        self.__bmp_rec = b''

        self.__show_formulas = 0
        self.__show_grid = 1
        self.__show_headers = 1
        self.__panes_frozen = 0
        ### self.__show_empty_as_zero = 1 ### deprecated with extreme prejudice 2009-05-19
        self.show_zero_values = 1
        self.__auto_colour_grid = 1
        self.__cols_right_to_left = 0
        self.__show_outline = 1
        self.__remove_splits = 0
        self.__selected = 0
        # RED HERRING ALERT: "sheet_visible" is a clone of the "selected" attribute.
        # Typically a workbook created by the Excel UI will have one sheet
        # (the sheet that was selected when the user saved it)
        # with both bits set to 1, and all other sheets will have both
        # bits set to 0. The true visibility of the sheet is found in the "visibility"
        # attribute obtained from the BOUNDSHEET record.
        self.__sheet_visible = 0
        self.__page_preview = 0

        self.__first_visible_row = 0
        self.__first_visible_col = 0
        self.__grid_colour = 0x40
        self.__preview_magn = 60 # percent
        self.__normal_magn = 100 # percent

        self.visibility = 0 # from/to BOUNDSHEET record.

        self.__vert_split_pos = None
        self.__horz_split_pos = None
        self.__vert_split_first_visible = None
        self.__horz_split_first_visible = None
        self.__split_active_pane = None

        self.__row_gut_width = 0
        self.__col_gut_height = 0

        self.__show_auto_page_breaks = 1
        self.__dialogue_sheet = 0
        self.__auto_style_outline = 0
        self.__outline_below = 0
        self.__outline_right = 0
        self.__fit_num_pages = 0
        self.__show_row_outline = 1
        self.__show_col_outline = 1
        self.__alt_expr_eval = 0
        self.__alt_formula_entries = 0

        self.__row_default_height = 0x00FF
        self.row_default_height_mismatch = 0
        self.row_default_hidden = 0
        self.row_default_space_above = 0
        self.row_default_space_below = 0

        self.__col_default_width = 0x0008

        self.__calc_mode = 1
        self.__calc_count = 0x0064
        self.__RC_ref_mode = 1
        self.__iterations_on = 0
        self.__delta = 0.001
        self.__save_recalc = 0

        self.__print_headers = 0
        self.__print_grid = 0
        self.__grid_set = 1
        self.__vert_page_breaks = []
        self.__horz_page_breaks = []
        self.__header_str = '&P'
        self.__footer_str = '&F'
        self.__print_centered_vert = 0
        self.__print_centered_horz = 1
        self.__left_margin = 0.3 #0.5
        self.__right_margin = 0.3 #0.5
        self.__top_margin = 0.61 #1.0
        self.__bottom_margin = 0.37 #1.0
        self.__paper_size_code = 9 # A4
        self.__print_scaling = 100
        self.__start_page_number = 1
        self.__fit_width_to_pages = 1
        self.__fit_height_to_pages = 1
        self.__print_in_rows = 1
        self.__portrait = 1
        self.__print_not_colour = 0
        self.__print_draft = 0
        self.__print_notes = 0
        self.__print_notes_at_end = 0
        self.__print_omit_errors = 0
        self.__print_hres = 0x012C # 300 dpi
        self.__print_vres = 0x012C # 300 dpi
        self.__header_margin = 0.1
        self.__footer_margin = 0.1
        self.__copies_num = 1

        self.__wnd_protect = 0
        self.__obj_protect = 0
        self.__protect = 0
        self.__scen_protect = 0
        self.__password = b''

        self.last_used_row = 0
        self.first_used_row = 65535
        self.last_used_col = 0
        self.first_used_col = 255
        self.row_tempfile = None
        self.__flushed_rows = {}
        self.__row_visible_levels = 0

    #################################################################
    ## Properties, "getters", "setters"
    #################################################################

    def set_name(self, value):
        self.__name = value

    def get_name(self):
        return self.__name

    name = property(get_name, set_name)

    #################################################################

    def get_parent(self):
        return self.__parent

    parent = property(get_parent)

    #################################################################

    def get_rows(self):
        return self.__rows

    rows = property(get_rows)

    #################################################################

    def get_cols(self):
        return self.__cols

    cols = property(get_cols)

    #################################################################

    def get_merged_ranges(self):
        return self.__merged_ranges

    merged_ranges = property(get_merged_ranges)

    #################################################################

    def get_bmp_rec(self):
        return self.__bmp_rec

    bmp_rec = property(get_bmp_rec)

    #################################################################

    def set_show_formulas(self, value):
        self.__show_formulas = int(value)

    def get_show_formulas(self):
        return bool(self.__show_formulas)

    show_formulas = property(get_show_formulas, set_show_formulas)

    #################################################################

    def set_show_grid(self, value):
        self.__show_grid = int(value)

    def get_show_grid(self):
        return bool(self.__show_grid)

    show_grid = property(get_show_grid, set_show_grid)

    #################################################################

    def set_show_headers(self, value):
        self.__show_headers = int(value)

    def get_show_headers(self):
        return bool(self.__show_headers)

    show_headers = property(get_show_headers, set_show_headers)

    #################################################################

    def set_panes_frozen(self, value):
        self.__panes_frozen = int(value)

    def get_panes_frozen(self):
        return bool(self.__panes_frozen)

    panes_frozen = property(get_panes_frozen, set_panes_frozen)

    #################################################################

    ### def set_show_empty_as_zero(self, value):
    ###     self.__show_empty_as_zero = int(value)

    ### def get_show_empty_as_zero(self):
    ###     return bool(self.__show_empty_as_zero)

    ### show_empty_as_zero = property(get_show_empty_as_zero, set_show_empty_as_zero)

    #################################################################

    def set_auto_colour_grid(self, value):
        self.__auto_colour_grid = int(value)

    def get_auto_colour_grid(self):
        return bool(self.__auto_colour_grid)

    auto_colour_grid = property(get_auto_colour_grid, set_auto_colour_grid)

    #################################################################

    def set_cols_right_to_left(self, value):
        self.__cols_right_to_left = int(value)

    def get_cols_right_to_left(self):
        return bool(self.__cols_right_to_left)

    cols_right_to_left = property(get_cols_right_to_left, set_cols_right_to_left)

    #################################################################

    def set_show_outline(self, value):
        self.__show_outline = int(value)

    def get_show_outline(self):
        return bool(self.__show_outline)

    show_outline = property(get_show_outline, set_show_outline)

    #################################################################

    def set_remove_splits(self, value):
        self.__remove_splits = int(value)

    def get_remove_splits(self):
        return bool(self.__remove_splits)

    remove_splits = property(get_remove_splits, set_remove_splits)

    #################################################################

    def set_selected(self, value):
        self.__selected = int(value)

    def get_selected(self):
        return bool(self.__selected)

    selected = property(get_selected, set_selected)

    #################################################################

    def set_sheet_visible(self, value):
        self.__sheet_visible = int(value)

    def get_sheet_visible(self):
        return bool(self.__sheet_visible)

    sheet_visible = property(get_sheet_visible, set_sheet_visible)

    #################################################################

    def set_page_preview(self, value):
        self.__page_preview = int(value)

    def get_page_preview(self):
        return bool(self.__page_preview)

    page_preview = property(get_page_preview, set_page_preview)

    #################################################################

    def set_first_visible_row(self, value):
        self.__first_visible_row = value

    def get_first_visible_row(self):
        return self.__first_visible_row

    first_visible_row = property(get_first_visible_row, set_first_visible_row)

    #################################################################

    def set_first_visible_col(self, value):
        self.__first_visible_col = value

    def get_first_visible_col(self):
        return self.__first_visible_col

    first_visible_col = property(get_first_visible_col, set_first_visible_col)

    #################################################################

    def set_grid_colour(self, value):
        self.__grid_colour = value

    def get_grid_colour(self):
        return self.__grid_colour

    grid_colour = property(get_grid_colour, set_grid_colour)

    #################################################################

    def set_preview_magn(self, value):
        self.__preview_magn = value

    def get_preview_magn(self):
        return self.__preview_magn

    preview_magn = property(get_preview_magn, set_preview_magn)

    #################################################################

    def set_normal_magn(self, value):
        self.__normal_magn = value

    def get_normal_magn(self):
        return self.__normal_magn

    normal_magn = property(get_normal_magn, set_normal_magn)

    #################################################################

    def set_vert_split_pos(self, value):
        self.__vert_split_pos = abs(value)

    def get_vert_split_pos(self):
        return self.__vert_split_pos

    vert_split_pos = property(get_vert_split_pos, set_vert_split_pos)

    #################################################################

    def set_horz_split_pos(self, value):
        self.__horz_split_pos = abs(value)

    def get_horz_split_pos(self):
        return self.__horz_split_pos

    horz_split_pos = property(get_horz_split_pos, set_horz_split_pos)

    #################################################################

    def set_vert_split_first_visible(self, value):
        self.__vert_split_first_visible = abs(value)

    def get_vert_split_first_visible(self):
        return self.__vert_split_first_visible

    vert_split_first_visible = property(get_vert_split_first_visible, set_vert_split_first_visible)

    #################################################################

    def set_horz_split_first_visible(self, value):
        self.__horz_split_first_visible = abs(value)

    def get_horz_split_first_visible(self):
        return self.__horz_split_first_visible

    horz_split_first_visible = property(get_horz_split_first_visible, set_horz_split_first_visible)

    #################################################################

    #def set_split_active_pane(self, value):
    #    self.__split_active_pane = abs(value) & 0x03
    #
    #def get_split_active_pane(self):
    #    return self.__split_active_pane
    #
    #split_active_pane = property(get_split_active_pane, set_split_active_pane)

    #################################################################

    #def set_row_gut_width(self, value):
    #    self.__row_gut_width = value
    #
    #def get_row_gut_width(self):
    #    return self.__row_gut_width
    #
    #row_gut_width = property(get_row_gut_width, set_row_gut_width)
    #
    #################################################################
    #
    #def set_col_gut_height(self, value):
    #    self.__col_gut_height = value
    #
    #def get_col_gut_height(self):
    #    return self.__col_gut_height
    #
    #col_gut_height = property(get_col_gut_height, set_col_gut_height)
    #
    #################################################################

    def set_show_auto_page_breaks(self, value):
        self.__show_auto_page_breaks = int(value)

    def get_show_auto_page_breaks(self):
        return bool(self.__show_auto_page_breaks)

    show_auto_page_breaks = property(get_show_auto_page_breaks, set_show_auto_page_breaks)

    #################################################################

    def set_dialogue_sheet(self, value):
        self.__dialogue_sheet = int(value)

    def get_dialogue_sheet(self):
        return bool(self.__dialogue_sheet)

    dialogue_sheet = property(get_dialogue_sheet, set_dialogue_sheet)

    #################################################################

    def set_auto_style_outline(self, value):
        self.__auto_style_outline = int(value)

    def get_auto_style_outline(self):
        return bool(self.__auto_style_outline)

    auto_style_outline = property(get_auto_style_outline, set_auto_style_outline)

    #################################################################

    def set_outline_below(self, value):
        self.__outline_below = int(value)

    def get_outline_below(self):
        return bool(self.__outline_below)

    outline_below = property(get_outline_below, set_outline_below)

    #################################################################

    def set_outline_right(self, value):
        self.__outline_right = int(value)

    def get_outline_right(self):
        return bool(self.__outline_right)

    outline_right = property(get_outline_right, set_outline_right)

    #################################################################

    def set_fit_num_pages(self, value):
        self.__fit_num_pages = value

    def get_fit_num_pages(self):
        return self.__fit_num_pages

    fit_num_pages = property(get_fit_num_pages, set_fit_num_pages)

    #################################################################

    def set_show_row_outline(self, value):
        self.__show_row_outline = int(value)

    def get_show_row_outline(self):
        return bool(self.__show_row_outline)

    show_row_outline = property(get_show_row_outline, set_show_row_outline)

    #################################################################

    def set_show_col_outline(self, value):
        self.__show_col_outline = int(value)

    def get_show_col_outline(self):
        return bool(self.__show_col_outline)

    show_col_outline = property(get_show_col_outline, set_show_col_outline)

    #################################################################

    def set_alt_expr_eval(self, value):
        self.__alt_expr_eval = int(value)

    def get_alt_expr_eval(self):
        return bool(self.__alt_expr_eval)

    alt_expr_eval = property(get_alt_expr_eval, set_alt_expr_eval)

    #################################################################

    def set_alt_formula_entries(self, value):
        self.__alt_formula_entries = int(value)

    def get_alt_formula_entries(self):
        return bool(self.__alt_formula_entries)

    alt_formula_entries = property(get_alt_formula_entries, set_alt_formula_entries)

    #################################################################

    def set_row_default_height(self, value):
        self.__row_default_height = value

    def get_row_default_height(self):
        return self.__row_default_height

    row_default_height = property(get_row_default_height, set_row_default_height)

    #################################################################

    def set_col_default_width(self, value):
        self.__col_default_width = value

    def get_col_default_width(self):
        return self.__col_default_width

    col_default_width = property(get_col_default_width, set_col_default_width)

    #################################################################

    def set_calc_mode(self, value):
        self.__calc_mode = value & 0x03

    def get_calc_mode(self):
        return self.__calc_mode

    calc_mode = property(get_calc_mode, set_calc_mode)

    #################################################################

    def set_calc_count(self, value):
        self.__calc_count = value

    def get_calc_count(self):
        return self.__calc_count

    calc_count = property(get_calc_count, set_calc_count)

    #################################################################

    def set_RC_ref_mode(self, value):
        self.__RC_ref_mode = int(value)

    def get_RC_ref_mode(self):
        return bool(self.__RC_ref_mode)

    RC_ref_mode = property(get_RC_ref_mode, set_RC_ref_mode)

    #################################################################

    def set_iterations_on(self, value):
        self.__iterations_on = int(value)

    def get_iterations_on(self):
        return bool(self.__iterations_on)

    iterations_on = property(get_iterations_on, set_iterations_on)

    #################################################################

    def set_delta(self, value):
        self.__delta = value

    def get_delta(self):
        return self.__delta

    delta = property(get_delta, set_delta)

    #################################################################

    def set_save_recalc(self, value):
        self.__save_recalc = int(value)

    def get_save_recalc(self):
        return bool(self.__save_recalc)

    save_recalc = property(get_save_recalc, set_save_recalc)

    #################################################################

    def set_print_headers(self, value):
        self.__print_headers = int(value)

    def get_print_headers(self):
        return bool(self.__print_headers)

    print_headers = property(get_print_headers, set_print_headers)

    #################################################################

    def set_print_grid(self, value):
        self.__print_grid = int(value)

    def get_print_grid(self):
        return bool(self.__print_grid)

    print_grid = property(get_print_grid, set_print_grid)

    #################################################################
    #
    #def set_grid_set(self, value):
    #    self.__grid_set = int(value)
    #
    #def get_grid_set(self):
    #    return bool(self.__grid_set)
    #
    #grid_set = property(get_grid_set, set_grid_set)
    #
    #################################################################

    def set_vert_page_breaks(self, value):
        self.__vert_page_breaks = value

    def get_vert_page_breaks(self):
        return self.__vert_page_breaks

    vert_page_breaks = property(get_vert_page_breaks, set_vert_page_breaks)

    #################################################################

    def set_horz_page_breaks(self, value):
        self.__horz_page_breaks = value

    def get_horz_page_breaks(self):
        return self.__horz_page_breaks

    horz_page_breaks = property(get_horz_page_breaks, set_horz_page_breaks)

    #################################################################

    def set_header_str(self, value):
        if isinstance(value, str):
            value = str(value, self.__parent.encoding)
        self.__header_str = value

    def get_header_str(self):
        return self.__header_str

    header_str = property(get_header_str, set_header_str)

    #################################################################

    def set_footer_str(self, value):
        if isinstance(value, str):
            value = str(value, self.__parent.encoding)
        self.__footer_str = value

    def get_footer_str(self):
        return self.__footer_str

    footer_str = property(get_footer_str, set_footer_str)

    #################################################################

    def set_print_centered_vert(self, value):
        self.__print_centered_vert = int(value)

    def get_print_centered_vert(self):
        return bool(self.__print_centered_vert)

    print_centered_vert = property(get_print_centered_vert, set_print_centered_vert)

    #################################################################

    def set_print_centered_horz(self, value):
        self.__print_centered_horz = int(value)

    def get_print_centered_horz(self):
        return bool(self.__print_centered_horz)

    print_centered_horz = property(get_print_centered_horz, set_print_centered_horz)

    #################################################################

    def set_left_margin(self, value):
        self.__left_margin = value

    def get_left_margin(self):
        return self.__left_margin

    left_margin = property(get_left_margin, set_left_margin)

    #################################################################

    def set_right_margin(self, value):
        self.__right_margin = value

    def get_right_margin(self):
        return self.__right_margin

    right_margin = property(get_right_margin, set_right_margin)

    #################################################################

    def set_top_margin(self, value):
        self.__top_margin = value

    def get_top_margin(self):
        return self.__top_margin

    top_margin = property(get_top_margin, set_top_margin)

    #################################################################

    def set_bottom_margin(self, value):
        self.__bottom_margin = value

    def get_bottom_margin(self):
        return self.__bottom_margin

    bottom_margin = property(get_bottom_margin, set_bottom_margin)

    #################################################################

    def set_paper_size_code(self, value):
        self.__paper_size_code = value

    def get_paper_size_code(self):
        return self.__paper_size_code

    paper_size_code = property(get_paper_size_code, set_paper_size_code)

    #################################################################

    def set_print_scaling(self, value):
        self.__print_scaling = value

    def get_print_scaling(self):
        return self.__print_scaling

    print_scaling = property(get_print_scaling, set_print_scaling)

    #################################################################

    def set_start_page_number(self, value):
        self.__start_page_number = value

    def get_start_page_number(self):
        return self.__start_page_number

    start_page_number = property(get_start_page_number, set_start_page_number)

    #################################################################

    def set_fit_width_to_pages(self, value):
        self.__fit_width_to_pages = value

    def get_fit_width_to_pages(self):
        return self.__fit_width_to_pages

    fit_width_to_pages = property(get_fit_width_to_pages, set_fit_width_to_pages)

    #################################################################

    def set_fit_height_to_pages(self, value):
        self.__fit_height_to_pages = value

    def get_fit_height_to_pages(self):
        return self.__fit_height_to_pages

    fit_height_to_pages = property(get_fit_height_to_pages, set_fit_height_to_pages)

    #################################################################

    def set_print_in_rows(self, value):
        self.__print_in_rows = int(value)

    def get_print_in_rows(self):
        return bool(self.__print_in_rows)

    print_in_rows = property(get_print_in_rows, set_print_in_rows)

    #################################################################

    def set_portrait(self, value):
        self.__portrait = int(value)

    def get_portrait(self):
        return bool(self.__portrait)

    portrait = property(get_portrait, set_portrait)

    #################################################################

    def set_print_colour(self, value):
        self.__print_not_colour = int(not value)

    def get_print_colour(self):
        return not bool(self.__print_not_colour)

    print_colour = property(get_print_colour, set_print_colour)

    #################################################################

    def set_print_draft(self, value):
        self.__print_draft = int(value)

    def get_print_draft(self):
        return bool(self.__print_draft)

    print_draft = property(get_print_draft, set_print_draft)

    #################################################################

    def set_print_notes(self, value):
        self.__print_notes = int(value)

    def get_print_notes(self):
        return bool(self.__print_notes)

    print_notes = property(get_print_notes, set_print_notes)

    #################################################################

    def set_print_notes_at_end(self, value):
        self.__print_notes_at_end = int(value)

    def get_print_notes_at_end(self):
        return bool(self.__print_notes_at_end)

    print_notes_at_end = property(get_print_notes_at_end, set_print_notes_at_end)

    #################################################################

    def set_print_omit_errors(self, value):
        self.__print_omit_errors = int(value)

    def get_print_omit_errors(self):
        return bool(self.__print_omit_errors)

    print_omit_errors = property(get_print_omit_errors, set_print_omit_errors)

    #################################################################

    def set_print_hres(self, value):
        self.__print_hres = value

    def get_print_hres(self):
        return self.__print_hres

    print_hres = property(get_print_hres, set_print_hres)

    #################################################################

    def set_print_vres(self, value):
        self.__print_vres = value

    def get_print_vres(self):
        return self.__print_vres

    print_vres = property(get_print_vres, set_print_vres)

    #################################################################

    def set_header_margin(self, value):
        self.__header_margin = value

    def get_header_margin(self):
        return self.__header_margin

    header_margin = property(get_header_margin, set_header_margin)

    #################################################################

    def set_footer_margin(self, value):
        self.__footer_margin = value

    def get_footer_margin(self):
        return self.__footer_margin

    footer_margin = property(get_footer_margin, set_footer_margin)

    #################################################################

    def set_copies_num(self, value):
        self.__copies_num = value

    def get_copies_num(self):
        return self.__copies_num

    copies_num = property(get_copies_num, set_copies_num)

    ##################################################################

    def set_wnd_protect(self, value):
        self.__wnd_protect = int(value)

    def get_wnd_protect(self):
        return bool(self.__wnd_protect)

    wnd_protect = property(get_wnd_protect, set_wnd_protect)

    #################################################################

    def set_obj_protect(self, value):
        self.__obj_protect = int(value)

    def get_obj_protect(self):
        return bool(self.__obj_protect)

    obj_protect = property(get_obj_protect, set_obj_protect)

    #################################################################

    def set_protect(self, value):
        self.__protect = int(value)

    def get_protect(self):
        return bool(self.__protect)

    protect = property(get_protect, set_protect)

    #################################################################

    def set_scen_protect(self, value):
        self.__scen_protect = int(value)

    def get_scen_protect(self):
        return bool(self.__scen_protect)

    scen_protect = property(get_scen_protect, set_scen_protect)

    #################################################################

    def set_password(self, value):
        self.__password = value

    def get_password(self):
        return self.__password

    password = property(get_password, set_password)

    ##################################################################
    ## Methods
    ##################################################################

    def get_parent(self):
        return self.__parent

    def write(self, r, c, label=b"", style=Style.default_style):
        self.row(r).write(c, label, style)

    def merge(self, r1, r2, c1, c2, style=Style.default_style):
        # Stand-alone merge of previously written cells.
        # Problems: (1) style to be used should be existing style of
        # the top-left cell, not an arg.
        # (2) should ensure that any previous data value in
        # non-top-left cells is nobbled.
        # Note: if a cell is set by a data record then later
        # is referenced by a [MUL]BLANK record, Excel will blank
        # out the cell on the screen, but OOo & Gnu will not
        # blank it out. Need to do something better than writing
        # multiple records. In the meantime, avoid this method and use
        # write_merge() instead.
        if c2 > c1:
            self.row(r1).write_blanks(c1 + 1, c2,  style)
        for r in range(r1+1, r2+1):
            self.row(r).write_blanks(c1, c2,  style)
        self.__merged_ranges.append((r1, r2, c1, c2))

    def write_merge(self, r1, r2, c1, c2, label=b"", style=Style.default_style):
        assert 0 <= c1 <= c2 <= 255
        assert 0 <= r1 <= r2 <= 65535
        self.write(r1, c1, label, style)
        if c2 > c1:
            self.row(r1).write_blanks(c1 + 1, c2,  style) # skip (r1, c1)
        for r in range(r1+1, r2+1):
            self.row(r).write_blanks(c1, c2,  style)
        self.__merged_ranges.append((r1, r2, c1, c2))

    def insert_bitmap(self, filename, row, col, x = 0, y = 0, scale_x = 1, scale_y = 1):
        bmp = Bitmap.ImDataBmpRecord(filename)
        obj = Bitmap.ObjBmpRecord(row, col, self, bmp, x, y, scale_x, scale_y)

        self.__bmp_rec += obj.get() + bmp.get()

    def col(self, indx):
        if indx not in self.__cols:
            self.__cols[indx] = self.Column(indx, self)
        return self.__cols[indx]

    def row(self, indx):
        if indx not in self.__rows:
            if indx in self.__flushed_rows:
                raise Exception("Attempt to reuse row index %d of sheet %r after flushing" % (indx, self.__name))
            self.__rows[indx] = self.Row(indx, self)
            if indx > self.last_used_row:
                self.last_used_row = indx
            if indx < self.first_used_row:
                self.first_used_row = indx
        return self.__rows[indx]

    def row_height(self, row): # in pixels
        if row in self.__rows:
            return self.__rows[row].get_height_in_pixels()
        else:
            return 17

    def col_width(self, col): # in pixels
        if col in self.__cols:
            return self.__cols[col].width_in_pixels()
        else:
            return 64


    ##################################################################
    ## BIFF records generation
    ##################################################################

    def __bof_rec(self):
        return BIFFRecords.Biff8BOFRecord(BIFFRecords.Biff8BOFRecord.WORKSHEET).get()

    def __update_row_visible_levels(self):
        if self.__rows:
            temp = max([self.__rows[r].level for r in self.__rows]) + 1
            self.__row_visible_levels = max(temp, self.__row_visible_levels)

    def __guts_rec(self):
        self.__update_row_visible_levels()
        col_visible_levels = 0
        if len(self.__cols) != 0:
            col_visible_levels = max([self.__cols[c].level for c in self.__cols]) + 1
        return BIFFRecords.GutsRecord(
            self.__row_gut_width, self.__col_gut_height, self.__row_visible_levels, col_visible_levels).get()

    def __defaultrowheight_rec(self):
        options = 0x0000
        options |= (self.row_default_height_mismatch & 1) << 0
        options |= (self.row_default_hidden & 1) << 1
        options |= (self.row_default_space_above & 1) << 2
        options |= (self.row_default_space_below & 1) << 3
        defht = self.__row_default_height
        return BIFFRecords.DefaultRowHeightRecord(options, defht).get()

    def __wsbool_rec(self):
        options = 0x00
        options |= (self.__show_auto_page_breaks & 0x01) << 0
        options |= (self.__dialogue_sheet & 0x01) << 4
        options |= (self.__auto_style_outline & 0x01) << 5
        options |= (self.__outline_below & 0x01) << 6
        options |= (self.__outline_right & 0x01) << 7
        options |= (self.__fit_num_pages & 0x01) << 8
        options |= (self.__show_row_outline & 0x01) << 10
        options |= (self.__show_col_outline & 0x01) << 11
        options |= (self.__alt_expr_eval & 0x01) << 14
        options |= (self.__alt_formula_entries & 0x01) << 15

        return BIFFRecords.WSBoolRecord(options).get()

    def __eof_rec(self):
        return BIFFRecords.EOFRecord().get()

    def __colinfo_rec(self):
        result = b''
        for col in self.__cols:
            result += self.__cols[col].get_biff_record()
        return result

    def __dimensions_rec(self):
        return BIFFRecords.DimensionsRecord(
            self.first_used_row, self.last_used_row,
            self.first_used_col, self.last_used_col
            ).get()

    def __window2_rec(self):
        # Appends SCL record.
        options = 0
        options |= (self.__show_formulas        & 0x01) << 0
        options |= (self.__show_grid            & 0x01) << 1
        options |= (self.__show_headers         & 0x01) << 2
        options |= (self.__panes_frozen         & 0x01) << 3
        options |= (self.show_zero_values       & 0x01) << 4
        options |= (self.__auto_colour_grid     & 0x01) << 5
        options |= (self.__cols_right_to_left   & 0x01) << 6
        options |= (self.__show_outline         & 0x01) << 7
        options |= (self.__remove_splits        & 0x01) << 8
        options |= (self.__selected             & 0x01) << 9
        options |= (self.__sheet_visible        & 0x01) << 10
        options |= (self.__page_preview         & 0x01) << 11
        if self.__page_preview:
            scl_magn = self.__preview_magn
        else:
            scl_magn = self.__normal_magn
        return BIFFRecords.Window2Record(
            options, self.__first_visible_row, self.__first_visible_col,
            self.__grid_colour,
            self.__preview_magn, self.__normal_magn, scl_magn).get()

    def __panes_rec(self):
        if self.__vert_split_pos is None and self.__horz_split_pos is None:
            return b""

        if self.__vert_split_pos is None:
            self.__vert_split_pos = 0
        if self.__horz_split_pos is None:
            self.__horz_split_pos = 0

        if self.__panes_frozen:
            if self.__vert_split_first_visible is None:
                self.__vert_split_first_visible = self.__vert_split_pos
            if self.__horz_split_first_visible is None:
                self.__horz_split_first_visible = self.__horz_split_pos
        else:
            if self.__vert_split_first_visible is None:
                self.__vert_split_first_visible = 0
            if self.__horz_split_first_visible is None:
                self.__horz_split_first_visible = 0
            # inspired by pyXLWriter
            self.__horz_split_pos = 20*self.__horz_split_pos + 255
            self.__vert_split_pos = int(113.879*self.__vert_split_pos + 390)

        if self.__vert_split_pos > 0 and self.__horz_split_pos > 0:
            self.__split_active_pane = 0
        elif self.__vert_split_pos > 0 and self.__horz_split_pos == 0:
            self.__split_active_pane = 1
        elif self.__vert_split_pos == 0 and self.__horz_split_pos > 0:
            self.__split_active_pane = 2
        else:
            self.__split_active_pane = 3

        result = BIFFRecords.PanesRecord(self.__vert_split_pos,
                                         self.__horz_split_pos,
                                         self.__horz_split_first_visible,
                                         self.__vert_split_first_visible,
                                         self.__split_active_pane).get()
        return result

    def __row_blocks_rec(self):
        result = []
        for row in self.__rows.values():
            result.append(row.get_row_biff_data())
            result.append(row.get_cells_biff_data())
        return b''.join(result)

    def __merged_rec(self):
        return BIFFRecords.MergedCellsRecord(self.__merged_ranges).get()

    def __bitmaps_rec(self):
        return self.__bmp_rec

    def __calc_settings_rec(self):
        result = b''
        result += BIFFRecords.CalcModeRecord(self.__calc_mode & 0x01).get()
        result += BIFFRecords.CalcCountRecord(self.__calc_count & 0xFFFF).get()
        result += BIFFRecords.RefModeRecord(self.__RC_ref_mode & 0x01).get()
        result += BIFFRecords.IterationRecord(self.__iterations_on & 0x01).get()
        result += BIFFRecords.DeltaRecord(self.__delta).get()
        result += BIFFRecords.SaveRecalcRecord(self.__save_recalc & 0x01).get()
        return result

    def __print_settings_rec(self):
        result = b''
        result += BIFFRecords.PrintHeadersRecord(self.__print_headers).get()
        result += BIFFRecords.PrintGridLinesRecord(self.__print_grid).get()
        result += BIFFRecords.GridSetRecord(self.__grid_set).get()
        result += BIFFRecords.HorizontalPageBreaksRecord(self.__horz_page_breaks).get()
        result += BIFFRecords.VerticalPageBreaksRecord(self.__vert_page_breaks).get()
        result += BIFFRecords.HeaderRecord(self.__header_str).get()
        result += BIFFRecords.FooterRecord(self.__footer_str).get()
        result += BIFFRecords.HCenterRecord(self.__print_centered_horz).get()
        result += BIFFRecords.VCenterRecord(self.__print_centered_vert).get()
        result += BIFFRecords.LeftMarginRecord(self.__left_margin).get()
        result += BIFFRecords.RightMarginRecord(self.__right_margin).get()
        result += BIFFRecords.TopMarginRecord(self.__top_margin).get()
        result += BIFFRecords.BottomMarginRecord(self.__bottom_margin).get()

        setup_page_options =  (self.__print_in_rows & 0x01) << 0
        setup_page_options |=  (self.__portrait & 0x01) << 1
        setup_page_options |=  (0x00 & 0x01) << 2
        setup_page_options |=  (self.__print_not_colour & 0x01) << 3
        setup_page_options |=  (self.__print_draft & 0x01) << 4
        setup_page_options |=  (self.__print_notes & 0x01) << 5
        setup_page_options |=  (0x00 & 0x01) << 6
        setup_page_options |=  (0x01 & 0x01) << 7
        setup_page_options |=  (self.__print_notes_at_end & 0x01) << 9
        setup_page_options |=  (self.__print_omit_errors & 0x03) << 10

        result += BIFFRecords.SetupPageRecord(self.__paper_size_code,
                                self.__print_scaling,
                                self.__start_page_number,
                                self.__fit_width_to_pages,
                                self.__fit_height_to_pages,
                                setup_page_options,
                                self.__print_hres,
                                self.__print_vres,
                                self.__header_margin,
                                self.__footer_margin,
                                self.__copies_num).get()
        return result

    def __protection_rec(self):
        result = b''
        result += BIFFRecords.ProtectRecord(self.__protect).get()
        result += BIFFRecords.ScenProtectRecord(self.__scen_protect).get()
        result += BIFFRecords.WindowProtectRecord(self.__wnd_protect).get()
        result += BIFFRecords.ObjectProtectRecord(self.__obj_protect).get()
        result += BIFFRecords.PasswordRecord(self.__password).get()
        return result

    def get_biff_data(self):
        result = [
            self.__bof_rec(),
            self.__calc_settings_rec(),
            self.__guts_rec(),
            self.__defaultrowheight_rec(),
            self.__wsbool_rec(),
            self.__colinfo_rec(),
            self.__dimensions_rec(),
            self.__print_settings_rec(),
            self.__protection_rec(),
            ]
        if self.row_tempfile:
            self.row_tempfile.flush()
            self.row_tempfile.seek(0)
            result.append(self.row_tempfile.read())
        result.extend([
            self.__row_blocks_rec(),
            self.__merged_rec(),
            self.__bitmaps_rec(),
            self.__window2_rec(),
            self.__panes_rec(),
            self.__eof_rec(),
            ])
        return b''.join(result)

    def flush_row_data(self):
        if self.row_tempfile is None:
            self.row_tempfile = tempfile.TemporaryFile()
        self.row_tempfile.write(self.__row_blocks_rec())
        for rowx in self.__rows:
            self.__flushed_rows[rowx] = 1
        self.__update_row_visible_levels()
        self.__rows = {}



########NEW FILE########
__FILENAME__ = composer

__all__ = ['Composer', 'ComposerError']

from error import MarkedYAMLError
from events import *
from nodes import *

class ComposerError(MarkedYAMLError):
    pass

class Composer(object):

    def __init__(self):
        self.anchors = {}

    def check_node(self):
        # Drop the STREAM-START event.
        if self.check_event(StreamStartEvent):
            self.get_event()

        # If there are more documents available?
        return not self.check_event(StreamEndEvent)

    def get_node(self):
        # Get the root node of the next document.
        if not self.check_event(StreamEndEvent):
            return self.compose_document()

    def get_single_node(self):
        # Drop the STREAM-START event.
        self.get_event()

        # Compose a document if the stream is not empty.
        document = None
        if not self.check_event(StreamEndEvent):
            document = self.compose_document()

        # Ensure that the stream contains no more documents.
        if not self.check_event(StreamEndEvent):
            event = self.get_event()
            raise ComposerError("expected a single document in the stream",
                    document.start_mark, "but found another document",
                    event.start_mark)

        # Drop the STREAM-END event.
        self.get_event()

        return document

    def compose_document(self):
        # Drop the DOCUMENT-START event.
        self.get_event()

        # Compose the root node.
        node = self.compose_node(None, None)

        # Drop the DOCUMENT-END event.
        self.get_event()

        self.anchors = {}
        return node

    def compose_node(self, parent, index):
        if self.check_event(AliasEvent):
            event = self.get_event()
            anchor = event.anchor
            if anchor not in self.anchors:
                raise ComposerError(None, None, "found undefined alias %r"
                        % anchor.encode('utf-8'), event.start_mark)
            return self.anchors[anchor]
        event = self.peek_event()
        anchor = event.anchor
        if anchor is not None:
            if anchor in self.anchors:
                raise ComposerError("found duplicate anchor %r; first occurence"
                        % anchor.encode('utf-8'), self.anchors[anchor].start_mark,
                        "second occurence", event.start_mark)
        self.descend_resolver(parent, index)
        if self.check_event(ScalarEvent):
            node = self.compose_scalar_node(anchor)
        elif self.check_event(SequenceStartEvent):
            node = self.compose_sequence_node(anchor)
        elif self.check_event(MappingStartEvent):
            node = self.compose_mapping_node(anchor)
        self.ascend_resolver()
        return node

    def compose_scalar_node(self, anchor):
        event = self.get_event()
        tag = event.tag
        if tag is None or tag == u'!':
            tag = self.resolve(ScalarNode, event.value, event.implicit)
        node = ScalarNode(tag, event.value,
                event.start_mark, event.end_mark, style=event.style)
        if anchor is not None:
            self.anchors[anchor] = node
        return node

    def compose_sequence_node(self, anchor):
        start_event = self.get_event()
        tag = start_event.tag
        if tag is None or tag == u'!':
            tag = self.resolve(SequenceNode, None, start_event.implicit)
        node = SequenceNode(tag, [],
                start_event.start_mark, None,
                flow_style=start_event.flow_style)
        if anchor is not None:
            self.anchors[anchor] = node
        index = 0
        while not self.check_event(SequenceEndEvent):
            node.value.append(self.compose_node(node, index))
            index += 1
        end_event = self.get_event()
        node.end_mark = end_event.end_mark
        return node

    def compose_mapping_node(self, anchor):
        start_event = self.get_event()
        tag = start_event.tag
        if tag is None or tag == u'!':
            tag = self.resolve(MappingNode, None, start_event.implicit)
        node = MappingNode(tag, [],
                start_event.start_mark, None,
                flow_style=start_event.flow_style)
        if anchor is not None:
            self.anchors[anchor] = node
        while not self.check_event(MappingEndEvent):
            #key_event = self.peek_event()
            item_key = self.compose_node(node, None)
            #if item_key in node.value:
            #    raise ComposerError("while composing a mapping", start_event.start_mark,
            #            "found duplicate key", key_event.start_mark)
            item_value = self.compose_node(node, item_key)
            #node.value[item_key] = item_value
            node.value.append((item_key, item_value))
        end_event = self.get_event()
        node.end_mark = end_event.end_mark
        return node


########NEW FILE########
__FILENAME__ = constructor

__all__ = ['BaseConstructor', 'SafeConstructor', 'Constructor',
    'ConstructorError']

from error import *
from nodes import *

import datetime

try:
    set
except NameError:
    from sets import Set as set

import binascii, re, sys, types

class ConstructorError(MarkedYAMLError):
    pass

class BaseConstructor(object):

    yaml_constructors = {}
    yaml_multi_constructors = {}

    def __init__(self):
        self.constructed_objects = {}
        self.recursive_objects = {}
        self.state_generators = []
        self.deep_construct = False

    def check_data(self):
        # If there are more documents available?
        return self.check_node()

    def get_data(self):
        # Construct and return the next document.
        if self.check_node():
            return self.construct_document(self.get_node())

    def get_single_data(self):
        # Ensure that the stream contains a single document and construct it.
        node = self.get_single_node()
        if node is not None:
            return self.construct_document(node)
        return None

    def construct_document(self, node):
        data = self.construct_object(node)
        while self.state_generators:
            state_generators = self.state_generators
            self.state_generators = []
            for generator in state_generators:
                for dummy in generator:
                    pass
        self.constructed_objects = {}
        self.recursive_objects = {}
        self.deep_construct = False
        return data

    def construct_object(self, node, deep=False):
        if deep:
            old_deep = self.deep_construct
            self.deep_construct = True
        if node in self.constructed_objects:
            return self.constructed_objects[node]
        if node in self.recursive_objects:
            raise ConstructorError(None, None,
                    "found unconstructable recursive node", node.start_mark)
        self.recursive_objects[node] = None
        constructor = None
        tag_suffix = None
        if node.tag in self.yaml_constructors:
            constructor = self.yaml_constructors[node.tag]
        else:
            for tag_prefix in self.yaml_multi_constructors:
                if node.tag.startswith(tag_prefix):
                    tag_suffix = node.tag[len(tag_prefix):]
                    constructor = self.yaml_multi_constructors[tag_prefix]
                    break
            else:
                if None in self.yaml_multi_constructors:
                    tag_suffix = node.tag
                    constructor = self.yaml_multi_constructors[None]
                elif None in self.yaml_constructors:
                    constructor = self.yaml_constructors[None]
                elif isinstance(node, ScalarNode):
                    constructor = self.__class__.construct_scalar
                elif isinstance(node, SequenceNode):
                    constructor = self.__class__.construct_sequence
                elif isinstance(node, MappingNode):
                    constructor = self.__class__.construct_mapping
        if tag_suffix is None:
            data = constructor(self, node)
        else:
            data = constructor(self, tag_suffix, node)
        if isinstance(data, types.GeneratorType):
            generator = data
            data = generator.next()
            if self.deep_construct:
                for dummy in generator:
                    pass
            else:
                self.state_generators.append(generator)
        self.constructed_objects[node] = data
        del self.recursive_objects[node]
        if deep:
            self.deep_construct = old_deep
        return data

    def construct_scalar(self, node):
        if not isinstance(node, ScalarNode):
            raise ConstructorError(None, None,
                    "expected a scalar node, but found %s" % node.id,
                    node.start_mark)
        return node.value

    def construct_sequence(self, node, deep=False):
        if not isinstance(node, SequenceNode):
            raise ConstructorError(None, None,
                    "expected a sequence node, but found %s" % node.id,
                    node.start_mark)
        return [self.construct_object(child, deep=deep)
                for child in node.value]

    def construct_mapping(self, node, deep=False):
        if not isinstance(node, MappingNode):
            raise ConstructorError(None, None,
                    "expected a mapping node, but found %s" % node.id,
                    node.start_mark)
        mapping = {}
        for key_node, value_node in node.value:
            key = self.construct_object(key_node, deep=deep)
            try:
                hash(key)
            except TypeError, exc:
                raise ConstructorError("while constructing a mapping", node.start_mark,
                        "found unacceptable key (%s)" % exc, key_node.start_mark)
            value = self.construct_object(value_node, deep=deep)
            mapping[key] = value
        return mapping

    def construct_pairs(self, node, deep=False):
        if not isinstance(node, MappingNode):
            raise ConstructorError(None, None,
                    "expected a mapping node, but found %s" % node.id,
                    node.start_mark)
        pairs = []
        for key_node, value_node in node.value:
            key = self.construct_object(key_node, deep=deep)
            value = self.construct_object(value_node, deep=deep)
            pairs.append((key, value))
        return pairs

    def add_constructor(cls, tag, constructor):
        if not 'yaml_constructors' in cls.__dict__:
            cls.yaml_constructors = cls.yaml_constructors.copy()
        cls.yaml_constructors[tag] = constructor
    add_constructor = classmethod(add_constructor)

    def add_multi_constructor(cls, tag_prefix, multi_constructor):
        if not 'yaml_multi_constructors' in cls.__dict__:
            cls.yaml_multi_constructors = cls.yaml_multi_constructors.copy()
        cls.yaml_multi_constructors[tag_prefix] = multi_constructor
    add_multi_constructor = classmethod(add_multi_constructor)

class SafeConstructor(BaseConstructor):

    def construct_scalar(self, node):
        if isinstance(node, MappingNode):
            for key_node, value_node in node.value:
                if key_node.tag == u'tag:yaml.org,2002:value':
                    return self.construct_scalar(value_node)
        return BaseConstructor.construct_scalar(self, node)

    def flatten_mapping(self, node):
        merge = []
        index = 0
        while index < len(node.value):
            key_node, value_node = node.value[index]
            if key_node.tag == u'tag:yaml.org,2002:merge':
                del node.value[index]
                if isinstance(value_node, MappingNode):
                    self.flatten_mapping(value_node)
                    merge.extend(value_node.value)
                elif isinstance(value_node, SequenceNode):
                    submerge = []
                    for subnode in value_node.value:
                        if not isinstance(subnode, MappingNode):
                            raise ConstructorError("while constructing a mapping",
                                    node.start_mark,
                                    "expected a mapping for merging, but found %s"
                                    % subnode.id, subnode.start_mark)
                        self.flatten_mapping(subnode)
                        submerge.append(subnode.value)
                    submerge.reverse()
                    for value in submerge:
                        merge.extend(value)
                else:
                    raise ConstructorError("while constructing a mapping", node.start_mark,
                            "expected a mapping or list of mappings for merging, but found %s"
                            % value_node.id, value_node.start_mark)
            elif key_node.tag == u'tag:yaml.org,2002:value':
                key_node.tag = u'tag:yaml.org,2002:str'
                index += 1
            else:
                index += 1
        if merge:
            node.value = merge + node.value

    def construct_mapping(self, node, deep=False):
        if isinstance(node, MappingNode):
            self.flatten_mapping(node)
        return BaseConstructor.construct_mapping(self, node, deep=deep)

    def construct_yaml_null(self, node):
        self.construct_scalar(node)
        return None

    bool_values = {
        u'yes':     True,
        u'no':      False,
        u'true':    True,
        u'false':   False,
        u'on':      True,
        u'off':     False,
    }

    def construct_yaml_bool(self, node):
        value = self.construct_scalar(node)
        return self.bool_values[value.lower()]

    def construct_yaml_int(self, node):
        value = str(self.construct_scalar(node))
        value = value.replace('_', '')
        sign = +1
        if value[0] == '-':
            sign = -1
        if value[0] in '+-':
            value = value[1:]
        if value == '0':
            return 0
        elif value.startswith('0b'):
            return sign*int(value[2:], 2)
        elif value.startswith('0x'):
            return sign*int(value[2:], 16)
        elif value[0] == '0':
            return sign*int(value, 8)
        elif ':' in value:
            digits = [int(part) for part in value.split(':')]
            digits.reverse()
            base = 1
            value = 0
            for digit in digits:
                value += digit*base
                base *= 60
            return sign*value
        else:
            return sign*int(value)

    inf_value = 1e300
    while inf_value != inf_value*inf_value:
        inf_value *= inf_value
    nan_value = -inf_value/inf_value   # Trying to make a quiet NaN (like C99).

    def construct_yaml_float(self, node):
        value = str(self.construct_scalar(node))
        value = value.replace('_', '').lower()
        sign = +1
        if value[0] == '-':
            sign = -1
        if value[0] in '+-':
            value = value[1:]
        if value == '.inf':
            return sign*self.inf_value
        elif value == '.nan':
            return self.nan_value
        elif ':' in value:
            digits = [float(part) for part in value.split(':')]
            digits.reverse()
            base = 1
            value = 0.0
            for digit in digits:
                value += digit*base
                base *= 60
            return sign*value
        else:
            return sign*float(value)

    def construct_yaml_binary(self, node):
        value = self.construct_scalar(node)
        try:
            return str(value).decode('base64')
        except (binascii.Error, UnicodeEncodeError), exc:
            raise ConstructorError(None, None,
                    "failed to decode base64 data: %s" % exc, node.start_mark) 

    timestamp_regexp = re.compile(
            ur'''^(?P<year>[0-9][0-9][0-9][0-9])
                -(?P<month>[0-9][0-9]?)
                -(?P<day>[0-9][0-9]?)
                (?:(?:[Tt]|[ \t]+)
                (?P<hour>[0-9][0-9]?)
                :(?P<minute>[0-9][0-9])
                :(?P<second>[0-9][0-9])
                (?:\.(?P<fraction>[0-9]*))?
                (?:[ \t]*(?P<tz>Z|(?P<tz_sign>[-+])(?P<tz_hour>[0-9][0-9]?)
                (?::(?P<tz_minute>[0-9][0-9]))?))?)?$''', re.X)

    def construct_yaml_timestamp(self, node):
        value = self.construct_scalar(node)
        match = self.timestamp_regexp.match(node.value)
        values = match.groupdict()
        year = int(values['year'])
        month = int(values['month'])
        day = int(values['day'])
        if not values['hour']:
            return datetime.date(year, month, day)
        hour = int(values['hour'])
        minute = int(values['minute'])
        second = int(values['second'])
        fraction = 0
        if values['fraction']:
            fraction = values['fraction'][:6]
            while len(fraction) < 6:
                fraction += '0'
            fraction = int(fraction)
        delta = None
        if values['tz_sign']:
            tz_hour = int(values['tz_hour'])
            tz_minute = int(values['tz_minute'] or 0)
            delta = datetime.timedelta(hours=tz_hour, minutes=tz_minute)
            if values['tz_sign'] == '-':
                delta = -delta
        data = datetime.datetime(year, month, day, hour, minute, second, fraction)
        if delta:
            data -= delta
        return data

    def construct_yaml_omap(self, node):
        # Note: we do not check for duplicate keys, because it's too
        # CPU-expensive.
        omap = []
        yield omap
        if not isinstance(node, SequenceNode):
            raise ConstructorError("while constructing an ordered map", node.start_mark,
                    "expected a sequence, but found %s" % node.id, node.start_mark)
        for subnode in node.value:
            if not isinstance(subnode, MappingNode):
                raise ConstructorError("while constructing an ordered map", node.start_mark,
                        "expected a mapping of length 1, but found %s" % subnode.id,
                        subnode.start_mark)
            if len(subnode.value) != 1:
                raise ConstructorError("while constructing an ordered map", node.start_mark,
                        "expected a single mapping item, but found %d items" % len(subnode.value),
                        subnode.start_mark)
            key_node, value_node = subnode.value[0]
            key = self.construct_object(key_node)
            value = self.construct_object(value_node)
            omap.append((key, value))

    def construct_yaml_pairs(self, node):
        # Note: the same code as `construct_yaml_omap`.
        pairs = []
        yield pairs
        if not isinstance(node, SequenceNode):
            raise ConstructorError("while constructing pairs", node.start_mark,
                    "expected a sequence, but found %s" % node.id, node.start_mark)
        for subnode in node.value:
            if not isinstance(subnode, MappingNode):
                raise ConstructorError("while constructing pairs", node.start_mark,
                        "expected a mapping of length 1, but found %s" % subnode.id,
                        subnode.start_mark)
            if len(subnode.value) != 1:
                raise ConstructorError("while constructing pairs", node.start_mark,
                        "expected a single mapping item, but found %d items" % len(subnode.value),
                        subnode.start_mark)
            key_node, value_node = subnode.value[0]
            key = self.construct_object(key_node)
            value = self.construct_object(value_node)
            pairs.append((key, value))

    def construct_yaml_set(self, node):
        data = set()
        yield data
        value = self.construct_mapping(node)
        data.update(value)

    def construct_yaml_str(self, node):
        value = self.construct_scalar(node)
        try:
            return value.encode('ascii')
        except UnicodeEncodeError:
            return value

    def construct_yaml_seq(self, node):
        data = []
        yield data
        data.extend(self.construct_sequence(node))

    def construct_yaml_map(self, node):
        data = {}
        yield data
        value = self.construct_mapping(node)
        data.update(value)

    def construct_yaml_object(self, node, cls):
        data = cls.__new__(cls)
        yield data
        if hasattr(data, '__setstate__'):
            state = self.construct_mapping(node, deep=True)
            data.__setstate__(state)
        else:
            state = self.construct_mapping(node)
            data.__dict__.update(state)

    def construct_undefined(self, node):
        raise ConstructorError(None, None,
                "could not determine a constructor for the tag %r" % node.tag.encode('utf-8'),
                node.start_mark)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:null',
        SafeConstructor.construct_yaml_null)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:bool',
        SafeConstructor.construct_yaml_bool)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:int',
        SafeConstructor.construct_yaml_int)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:float',
        SafeConstructor.construct_yaml_float)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:binary',
        SafeConstructor.construct_yaml_binary)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:timestamp',
        SafeConstructor.construct_yaml_timestamp)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:omap',
        SafeConstructor.construct_yaml_omap)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:pairs',
        SafeConstructor.construct_yaml_pairs)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:set',
        SafeConstructor.construct_yaml_set)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:str',
        SafeConstructor.construct_yaml_str)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:seq',
        SafeConstructor.construct_yaml_seq)

SafeConstructor.add_constructor(
        u'tag:yaml.org,2002:map',
        SafeConstructor.construct_yaml_map)

SafeConstructor.add_constructor(None,
        SafeConstructor.construct_undefined)

class Constructor(SafeConstructor):

    def construct_python_str(self, node):
        return self.construct_scalar(node).encode('utf-8')

    def construct_python_unicode(self, node):
        return self.construct_scalar(node)

    def construct_python_long(self, node):
        return long(self.construct_yaml_int(node))

    def construct_python_complex(self, node):
       return complex(self.construct_scalar(node))

    def construct_python_tuple(self, node):
        return tuple(self.construct_sequence(node))

    def find_python_module(self, name, mark):
        if not name:
            raise ConstructorError("while constructing a Python module", mark,
                    "expected non-empty name appended to the tag", mark)
        try:
            __import__(name)
        except ImportError, exc:
            raise ConstructorError("while constructing a Python module", mark,
                    "cannot find module %r (%s)" % (name.encode('utf-8'), exc), mark)
        return sys.modules[name]

    def find_python_name(self, name, mark):
        if not name:
            raise ConstructorError("while constructing a Python object", mark,
                    "expected non-empty name appended to the tag", mark)
        if u'.' in name:
            # Python 2.4 only
            #module_name, object_name = name.rsplit('.', 1)
            items = name.split('.')
            object_name = items.pop()
            module_name = '.'.join(items)
        else:
            module_name = '__builtin__'
            object_name = name
        try:
            __import__(module_name)
        except ImportError, exc:
            raise ConstructorError("while constructing a Python object", mark,
                    "cannot find module %r (%s)" % (module_name.encode('utf-8'), exc), mark)
        module = sys.modules[module_name]
        if not hasattr(module, object_name):
            raise ConstructorError("while constructing a Python object", mark,
                    "cannot find %r in the module %r" % (object_name.encode('utf-8'),
                        module.__name__), mark)
        return getattr(module, object_name)

    def construct_python_name(self, suffix, node):
        value = self.construct_scalar(node)
        if value:
            raise ConstructorError("while constructing a Python name", node.start_mark,
                    "expected the empty value, but found %r" % value.encode('utf-8'),
                    node.start_mark)
        return self.find_python_name(suffix, node.start_mark)

    def construct_python_module(self, suffix, node):
        value = self.construct_scalar(node)
        if value:
            raise ConstructorError("while constructing a Python module", node.start_mark,
                    "expected the empty value, but found %r" % value.encode('utf-8'),
                    node.start_mark)
        return self.find_python_module(suffix, node.start_mark)

    class classobj: pass

    def make_python_instance(self, suffix, node,
            args=None, kwds=None, newobj=False):
        if not args:
            args = []
        if not kwds:
            kwds = {}
        cls = self.find_python_name(suffix, node.start_mark)
        if newobj and isinstance(cls, type(self.classobj))  \
                and not args and not kwds:
            instance = self.classobj()
            instance.__class__ = cls
            return instance
        elif newobj and isinstance(cls, type):
            return cls.__new__(cls, *args, **kwds)
        else:
            return cls(*args, **kwds)

    def set_python_instance_state(self, instance, state):
        if hasattr(instance, '__setstate__'):
            instance.__setstate__(state)
        else:
            slotstate = {}
            if isinstance(state, tuple) and len(state) == 2:
                state, slotstate = state
            if hasattr(instance, '__dict__'):
                instance.__dict__.update(state)
            elif state:
                slotstate.update(state)
            for key, value in slotstate.items():
                setattr(object, key, value)

    def construct_python_object(self, suffix, node):
        # Format:
        #   !!python/object:module.name { ... state ... }
        instance = self.make_python_instance(suffix, node, newobj=True)
        yield instance
        deep = hasattr(instance, '__setstate__')
        state = self.construct_mapping(node, deep=deep)
        self.set_python_instance_state(instance, state)

    def construct_python_object_apply(self, suffix, node, newobj=False):
        # Format:
        #   !!python/object/apply       # (or !!python/object/new)
        #   args: [ ... arguments ... ]
        #   kwds: { ... keywords ... }
        #   state: ... state ...
        #   listitems: [ ... listitems ... ]
        #   dictitems: { ... dictitems ... }
        # or short format:
        #   !!python/object/apply [ ... arguments ... ]
        # The difference between !!python/object/apply and !!python/object/new
        # is how an object is created, check make_python_instance for details.
        if isinstance(node, SequenceNode):
            args = self.construct_sequence(node, deep=True)
            kwds = {}
            state = {}
            listitems = []
            dictitems = {}
        else:
            value = self.construct_mapping(node, deep=True)
            args = value.get('args', [])
            kwds = value.get('kwds', {})
            state = value.get('state', {})
            listitems = value.get('listitems', [])
            dictitems = value.get('dictitems', {})
        instance = self.make_python_instance(suffix, node, args, kwds, newobj)
        if state:
            self.set_python_instance_state(instance, state)
        if listitems:
            instance.extend(listitems)
        if dictitems:
            for key in dictitems:
                instance[key] = dictitems[key]
        return instance

    def construct_python_object_new(self, suffix, node):
        return self.construct_python_object_apply(suffix, node, newobj=True)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/none',
    Constructor.construct_yaml_null)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/bool',
    Constructor.construct_yaml_bool)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/str',
    Constructor.construct_python_str)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/unicode',
    Constructor.construct_python_unicode)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/int',
    Constructor.construct_yaml_int)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/long',
    Constructor.construct_python_long)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/float',
    Constructor.construct_yaml_float)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/complex',
    Constructor.construct_python_complex)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/list',
    Constructor.construct_yaml_seq)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/tuple',
    Constructor.construct_python_tuple)

Constructor.add_constructor(
    u'tag:yaml.org,2002:python/dict',
    Constructor.construct_yaml_map)

Constructor.add_multi_constructor(
    u'tag:yaml.org,2002:python/name:',
    Constructor.construct_python_name)

Constructor.add_multi_constructor(
    u'tag:yaml.org,2002:python/module:',
    Constructor.construct_python_module)

Constructor.add_multi_constructor(
    u'tag:yaml.org,2002:python/object:',
    Constructor.construct_python_object)

Constructor.add_multi_constructor(
    u'tag:yaml.org,2002:python/object/apply:',
    Constructor.construct_python_object_apply)

Constructor.add_multi_constructor(
    u'tag:yaml.org,2002:python/object/new:',
    Constructor.construct_python_object_new)


########NEW FILE########
__FILENAME__ = cyaml

__all__ = ['CBaseLoader', 'CSafeLoader', 'CLoader',
        'CBaseDumper', 'CSafeDumper', 'CDumper']

from _yaml import CParser, CEmitter

from constructor import *

from serializer import *
from representer import *

from resolver import *

class CBaseLoader(CParser, BaseConstructor, BaseResolver):

    def __init__(self, stream):
        CParser.__init__(self, stream)
        BaseConstructor.__init__(self)
        BaseResolver.__init__(self)

class CSafeLoader(CParser, SafeConstructor, Resolver):

    def __init__(self, stream):
        CParser.__init__(self, stream)
        SafeConstructor.__init__(self)
        Resolver.__init__(self)

class CLoader(CParser, Constructor, Resolver):

    def __init__(self, stream):
        CParser.__init__(self, stream)
        Constructor.__init__(self)
        Resolver.__init__(self)

class CBaseDumper(CEmitter, BaseRepresenter, BaseResolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        CEmitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width, encoding=encoding,
                allow_unicode=allow_unicode, line_break=line_break,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        Representer.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)

class CSafeDumper(CEmitter, SafeRepresenter, Resolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        CEmitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width, encoding=encoding,
                allow_unicode=allow_unicode, line_break=line_break,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        SafeRepresenter.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)

class CDumper(CEmitter, Serializer, Representer, Resolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        CEmitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width, encoding=encoding,
                allow_unicode=allow_unicode, line_break=line_break,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        Representer.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)


########NEW FILE########
__FILENAME__ = dumper

__all__ = ['BaseDumper', 'SafeDumper', 'Dumper']

from emitter import *
from serializer import *
from representer import *
from resolver import *

class BaseDumper(Emitter, Serializer, BaseRepresenter, BaseResolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        Emitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width,
                allow_unicode=allow_unicode, line_break=line_break)
        Serializer.__init__(self, encoding=encoding,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        Representer.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)

class SafeDumper(Emitter, Serializer, SafeRepresenter, Resolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        Emitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width,
                allow_unicode=allow_unicode, line_break=line_break)
        Serializer.__init__(self, encoding=encoding,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        SafeRepresenter.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)

class Dumper(Emitter, Serializer, Representer, Resolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        Emitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width,
                allow_unicode=allow_unicode, line_break=line_break)
        Serializer.__init__(self, encoding=encoding,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        Representer.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)


########NEW FILE########
__FILENAME__ = emitter

# Emitter expects events obeying the following grammar:
# stream ::= STREAM-START document* STREAM-END
# document ::= DOCUMENT-START node DOCUMENT-END
# node ::= SCALAR | sequence | mapping
# sequence ::= SEQUENCE-START node* SEQUENCE-END
# mapping ::= MAPPING-START (node node)* MAPPING-END

__all__ = ['Emitter', 'EmitterError']

from error import YAMLError
from events import *

class EmitterError(YAMLError):
    pass

class ScalarAnalysis(object):
    def __init__(self, scalar, empty, multiline,
            allow_flow_plain, allow_block_plain,
            allow_single_quoted, allow_double_quoted,
            allow_block):
        self.scalar = scalar
        self.empty = empty
        self.multiline = multiline
        self.allow_flow_plain = allow_flow_plain
        self.allow_block_plain = allow_block_plain
        self.allow_single_quoted = allow_single_quoted
        self.allow_double_quoted = allow_double_quoted
        self.allow_block = allow_block

class Emitter(object):

    DEFAULT_TAG_PREFIXES = {
        u'!' : u'!',
        u'tag:yaml.org,2002:' : u'!!',
    }

    def __init__(self, stream, canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None):

        # The stream should have the methods `write` and possibly `flush`.
        self.stream = stream

        # Encoding can be overriden by STREAM-START.
        self.encoding = None

        # Emitter is a state machine with a stack of states to handle nested
        # structures.
        self.states = []
        self.state = self.expect_stream_start

        # Current event and the event queue.
        self.events = []
        self.event = None

        # The current indentation level and the stack of previous indents.
        self.indents = []
        self.indent = None

        # Flow level.
        self.flow_level = 0

        # Contexts.
        self.root_context = False
        self.sequence_context = False
        self.mapping_context = False
        self.simple_key_context = False

        # Characteristics of the last emitted character:
        #  - current position.
        #  - is it a whitespace?
        #  - is it an indention character
        #    (indentation space, '-', '?', or ':')?
        self.line = 0
        self.column = 0
        self.whitespace = True
        self.indention = True

        # Whether the document requires an explicit document indicator
        self.open_ended = False

        # Formatting details.
        self.canonical = canonical
        self.allow_unicode = allow_unicode
        self.best_indent = 2
        if indent and 1 < indent < 10:
            self.best_indent = indent
        self.best_width = 80
        if width and width > self.best_indent*2:
            self.best_width = width
        self.best_line_break = u'\n'
        if line_break in [u'\r', u'\n', u'\r\n']:
            self.best_line_break = line_break

        # Tag prefixes.
        self.tag_prefixes = None

        # Prepared anchor and tag.
        self.prepared_anchor = None
        self.prepared_tag = None

        # Scalar analysis and style.
        self.analysis = None
        self.style = None

    def emit(self, event):
        self.events.append(event)
        while not self.need_more_events():
            self.event = self.events.pop(0)
            self.state()
            self.event = None

    # In some cases, we wait for a few next events before emitting.

    def need_more_events(self):
        if not self.events:
            return True
        event = self.events[0]
        if isinstance(event, DocumentStartEvent):
            return self.need_events(1)
        elif isinstance(event, SequenceStartEvent):
            return self.need_events(2)
        elif isinstance(event, MappingStartEvent):
            return self.need_events(3)
        else:
            return False

    def need_events(self, count):
        level = 0
        for event in self.events[1:]:
            if isinstance(event, (DocumentStartEvent, CollectionStartEvent)):
                level += 1
            elif isinstance(event, (DocumentEndEvent, CollectionEndEvent)):
                level -= 1
            elif isinstance(event, StreamEndEvent):
                level = -1
            if level < 0:
                return False
        return (len(self.events) < count+1)

    def increase_indent(self, flow=False, indentless=False):
        self.indents.append(self.indent)
        if self.indent is None:
            if flow:
                self.indent = self.best_indent
            else:
                self.indent = 0
        elif not indentless:
            self.indent += self.best_indent

    # States.

    # Stream handlers.

    def expect_stream_start(self):
        if isinstance(self.event, StreamStartEvent):
            if self.event.encoding and not getattr(self.stream, 'encoding', None):
                self.encoding = self.event.encoding
            self.write_stream_start()
            self.state = self.expect_first_document_start
        else:
            raise EmitterError("expected StreamStartEvent, but got %s"
                    % self.event)

    def expect_nothing(self):
        raise EmitterError("expected nothing, but got %s" % self.event)

    # Document handlers.

    def expect_first_document_start(self):
        return self.expect_document_start(first=True)

    def expect_document_start(self, first=False):
        if isinstance(self.event, DocumentStartEvent):
            if (self.event.version or self.event.tags) and self.open_ended:
                self.write_indicator(u'...', True)
                self.write_indent()
            if self.event.version:
                version_text = self.prepare_version(self.event.version)
                self.write_version_directive(version_text)
            self.tag_prefixes = self.DEFAULT_TAG_PREFIXES.copy()
            if self.event.tags:
                handles = self.event.tags.keys()
                handles.sort()
                for handle in handles:
                    prefix = self.event.tags[handle]
                    self.tag_prefixes[prefix] = handle
                    handle_text = self.prepare_tag_handle(handle)
                    prefix_text = self.prepare_tag_prefix(prefix)
                    self.write_tag_directive(handle_text, prefix_text)
            implicit = (first and not self.event.explicit and not self.canonical
                    and not self.event.version and not self.event.tags
                    and not self.check_empty_document())
            if not implicit:
                self.write_indent()
                self.write_indicator(u'---', True)
                if self.canonical:
                    self.write_indent()
            self.state = self.expect_document_root
        elif isinstance(self.event, StreamEndEvent):
            if self.open_ended:
                self.write_indicator(u'...', True)
                self.write_indent()
            self.write_stream_end()
            self.state = self.expect_nothing
        else:
            raise EmitterError("expected DocumentStartEvent, but got %s"
                    % self.event)

    def expect_document_end(self):
        if isinstance(self.event, DocumentEndEvent):
            self.write_indent()
            if self.event.explicit:
                self.write_indicator(u'...', True)
                self.write_indent()
            self.flush_stream()
            self.state = self.expect_document_start
        else:
            raise EmitterError("expected DocumentEndEvent, but got %s"
                    % self.event)

    def expect_document_root(self):
        self.states.append(self.expect_document_end)
        self.expect_node(root=True)

    # Node handlers.

    def expect_node(self, root=False, sequence=False, mapping=False,
            simple_key=False):
        self.root_context = root
        self.sequence_context = sequence
        self.mapping_context = mapping
        self.simple_key_context = simple_key
        if isinstance(self.event, AliasEvent):
            self.expect_alias()
        elif isinstance(self.event, (ScalarEvent, CollectionStartEvent)):
            self.process_anchor(u'&')
            self.process_tag()
            if isinstance(self.event, ScalarEvent):
                self.expect_scalar()
            elif isinstance(self.event, SequenceStartEvent):
                if self.flow_level or self.canonical or self.event.flow_style   \
                        or self.check_empty_sequence():
                    self.expect_flow_sequence()
                else:
                    self.expect_block_sequence()
            elif isinstance(self.event, MappingStartEvent):
                if self.flow_level or self.canonical or self.event.flow_style   \
                        or self.check_empty_mapping():
                    self.expect_flow_mapping()
                else:
                    self.expect_block_mapping()
        else:
            raise EmitterError("expected NodeEvent, but got %s" % self.event)

    def expect_alias(self):
        if self.event.anchor is None:
            raise EmitterError("anchor is not specified for alias")
        self.process_anchor(u'*')
        self.state = self.states.pop()

    def expect_scalar(self):
        self.increase_indent(flow=True)
        self.process_scalar()
        self.indent = self.indents.pop()
        self.state = self.states.pop()

    # Flow sequence handlers.

    def expect_flow_sequence(self):
        self.write_indicator(u'[', True, whitespace=True)
        self.flow_level += 1
        self.increase_indent(flow=True)
        self.state = self.expect_first_flow_sequence_item

    def expect_first_flow_sequence_item(self):
        if isinstance(self.event, SequenceEndEvent):
            self.indent = self.indents.pop()
            self.flow_level -= 1
            self.write_indicator(u']', False)
            self.state = self.states.pop()
        else:
            if self.canonical or self.column > self.best_width:
                self.write_indent()
            self.states.append(self.expect_flow_sequence_item)
            self.expect_node(sequence=True)

    def expect_flow_sequence_item(self):
        if isinstance(self.event, SequenceEndEvent):
            self.indent = self.indents.pop()
            self.flow_level -= 1
            if self.canonical:
                self.write_indicator(u',', False)
                self.write_indent()
            self.write_indicator(u']', False)
            self.state = self.states.pop()
        else:
            self.write_indicator(u',', False)
            if self.canonical or self.column > self.best_width:
                self.write_indent()
            self.states.append(self.expect_flow_sequence_item)
            self.expect_node(sequence=True)

    # Flow mapping handlers.

    def expect_flow_mapping(self):
        self.write_indicator(u'{', True, whitespace=True)
        self.flow_level += 1
        self.increase_indent(flow=True)
        self.state = self.expect_first_flow_mapping_key

    def expect_first_flow_mapping_key(self):
        if isinstance(self.event, MappingEndEvent):
            self.indent = self.indents.pop()
            self.flow_level -= 1
            self.write_indicator(u'}', False)
            self.state = self.states.pop()
        else:
            if self.canonical or self.column > self.best_width:
                self.write_indent()
            if not self.canonical and self.check_simple_key():
                self.states.append(self.expect_flow_mapping_simple_value)
                self.expect_node(mapping=True, simple_key=True)
            else:
                self.write_indicator(u'?', True)
                self.states.append(self.expect_flow_mapping_value)
                self.expect_node(mapping=True)

    def expect_flow_mapping_key(self):
        if isinstance(self.event, MappingEndEvent):
            self.indent = self.indents.pop()
            self.flow_level -= 1
            if self.canonical:
                self.write_indicator(u',', False)
                self.write_indent()
            self.write_indicator(u'}', False)
            self.state = self.states.pop()
        else:
            self.write_indicator(u',', False)
            if self.canonical or self.column > self.best_width:
                self.write_indent()
            if not self.canonical and self.check_simple_key():
                self.states.append(self.expect_flow_mapping_simple_value)
                self.expect_node(mapping=True, simple_key=True)
            else:
                self.write_indicator(u'?', True)
                self.states.append(self.expect_flow_mapping_value)
                self.expect_node(mapping=True)

    def expect_flow_mapping_simple_value(self):
        self.write_indicator(u':', False)
        self.states.append(self.expect_flow_mapping_key)
        self.expect_node(mapping=True)

    def expect_flow_mapping_value(self):
        if self.canonical or self.column > self.best_width:
            self.write_indent()
        self.write_indicator(u':', True)
        self.states.append(self.expect_flow_mapping_key)
        self.expect_node(mapping=True)

    # Block sequence handlers.

    def expect_block_sequence(self):
        indentless = (self.mapping_context and not self.indention)
        self.increase_indent(flow=False, indentless=indentless)
        self.state = self.expect_first_block_sequence_item

    def expect_first_block_sequence_item(self):
        return self.expect_block_sequence_item(first=True)

    def expect_block_sequence_item(self, first=False):
        if not first and isinstance(self.event, SequenceEndEvent):
            self.indent = self.indents.pop()
            self.state = self.states.pop()
        else:
            self.write_indent()
            self.write_indicator(u'-', True, indention=True)
            self.states.append(self.expect_block_sequence_item)
            self.expect_node(sequence=True)

    # Block mapping handlers.

    def expect_block_mapping(self):
        self.increase_indent(flow=False)
        self.state = self.expect_first_block_mapping_key

    def expect_first_block_mapping_key(self):
        return self.expect_block_mapping_key(first=True)

    def expect_block_mapping_key(self, first=False):
        if not first and isinstance(self.event, MappingEndEvent):
            self.indent = self.indents.pop()
            self.state = self.states.pop()
        else:
            self.write_indent()
            if self.check_simple_key():
                self.states.append(self.expect_block_mapping_simple_value)
                self.expect_node(mapping=True, simple_key=True)
            else:
                self.write_indicator(u'?', True, indention=True)
                self.states.append(self.expect_block_mapping_value)
                self.expect_node(mapping=True)

    def expect_block_mapping_simple_value(self):
        self.write_indicator(u':', False)
        self.states.append(self.expect_block_mapping_key)
        self.expect_node(mapping=True)

    def expect_block_mapping_value(self):
        self.write_indent()
        self.write_indicator(u':', True, indention=True)
        self.states.append(self.expect_block_mapping_key)
        self.expect_node(mapping=True)

    # Checkers.

    def check_empty_sequence(self):
        return (isinstance(self.event, SequenceStartEvent) and self.events
                and isinstance(self.events[0], SequenceEndEvent))

    def check_empty_mapping(self):
        return (isinstance(self.event, MappingStartEvent) and self.events
                and isinstance(self.events[0], MappingEndEvent))

    def check_empty_document(self):
        if not isinstance(self.event, DocumentStartEvent) or not self.events:
            return False
        event = self.events[0]
        return (isinstance(event, ScalarEvent) and event.anchor is None
                and event.tag is None and event.implicit and event.value == u'')

    def check_simple_key(self):
        length = 0
        if isinstance(self.event, NodeEvent) and self.event.anchor is not None:
            if self.prepared_anchor is None:
                self.prepared_anchor = self.prepare_anchor(self.event.anchor)
            length += len(self.prepared_anchor)
        if isinstance(self.event, (ScalarEvent, CollectionStartEvent))  \
                and self.event.tag is not None:
            if self.prepared_tag is None:
                self.prepared_tag = self.prepare_tag(self.event.tag)
            length += len(self.prepared_tag)
        if isinstance(self.event, ScalarEvent):
            if self.analysis is None:
                self.analysis = self.analyze_scalar(self.event.value)
            length += len(self.analysis.scalar)
        return (length < 128 and (isinstance(self.event, AliasEvent)
            or (isinstance(self.event, ScalarEvent)
                    and not self.analysis.empty and not self.analysis.multiline)
            or self.check_empty_sequence() or self.check_empty_mapping()))

    # Anchor, Tag, and Scalar processors.

    def process_anchor(self, indicator):
        if self.event.anchor is None:
            self.prepared_anchor = None
            return
        if self.prepared_anchor is None:
            self.prepared_anchor = self.prepare_anchor(self.event.anchor)
        if self.prepared_anchor:
            self.write_indicator(indicator+self.prepared_anchor, True)
        self.prepared_anchor = None

    def process_tag(self):
        tag = self.event.tag
        if isinstance(self.event, ScalarEvent):
            if self.style is None:
                self.style = self.choose_scalar_style()
            if ((not self.canonical or tag is None) and
                ((self.style == '' and self.event.implicit[0])
                        or (self.style != '' and self.event.implicit[1]))):
                self.prepared_tag = None
                return
            if self.event.implicit[0] and tag is None:
                tag = u'!'
                self.prepared_tag = None
        else:
            if (not self.canonical or tag is None) and self.event.implicit:
                self.prepared_tag = None
                return
        if tag is None:
            raise EmitterError("tag is not specified")
        if self.prepared_tag is None:
            self.prepared_tag = self.prepare_tag(tag)
        if self.prepared_tag:
            self.write_indicator(self.prepared_tag, True)
        self.prepared_tag = None

    def choose_scalar_style(self):
        if self.analysis is None:
            self.analysis = self.analyze_scalar(self.event.value)
        if self.event.style == '"' or self.canonical:
            return '"'
        if not self.event.style and self.event.implicit[0]:
            if (not (self.simple_key_context and
                    (self.analysis.empty or self.analysis.multiline))
                and (self.flow_level and self.analysis.allow_flow_plain
                    or (not self.flow_level and self.analysis.allow_block_plain))):
                return ''
        if self.event.style and self.event.style in '|>':
            if (not self.flow_level and not self.simple_key_context
                    and self.analysis.allow_block):
                return self.event.style
        if not self.event.style or self.event.style == '\'':
            if (self.analysis.allow_single_quoted and
                    not (self.simple_key_context and self.analysis.multiline)):
                return '\''
        return '"'

    def process_scalar(self):
        if self.analysis is None:
            self.analysis = self.analyze_scalar(self.event.value)
        if self.style is None:
            self.style = self.choose_scalar_style()
        split = (not self.simple_key_context)
        #if self.analysis.multiline and split    \
        #        and (not self.style or self.style in '\'\"'):
        #    self.write_indent()
        if self.style == '"':
            self.write_double_quoted(self.analysis.scalar, split)
        elif self.style == '\'':
            self.write_single_quoted(self.analysis.scalar, split)
        elif self.style == '>':
            self.write_folded(self.analysis.scalar)
        elif self.style == '|':
            self.write_literal(self.analysis.scalar)
        else:
            self.write_plain(self.analysis.scalar, split)
        self.analysis = None
        self.style = None

    # Analyzers.

    def prepare_version(self, version):
        major, minor = version
        if major != 1:
            raise EmitterError("unsupported YAML version: %d.%d" % (major, minor))
        return u'%d.%d' % (major, minor)

    def prepare_tag_handle(self, handle):
        if not handle:
            raise EmitterError("tag handle must not be empty")
        if handle[0] != u'!' or handle[-1] != u'!':
            raise EmitterError("tag handle must start and end with '!': %r"
                    % (handle.encode('utf-8')))
        for ch in handle[1:-1]:
            if not (u'0' <= ch <= u'9' or u'A' <= ch <= u'Z' or u'a' <= ch <= u'z'  \
                    or ch in u'-_'):
                raise EmitterError("invalid character %r in the tag handle: %r"
                        % (ch.encode('utf-8'), handle.encode('utf-8')))
        return handle

    def prepare_tag_prefix(self, prefix):
        if not prefix:
            raise EmitterError("tag prefix must not be empty")
        chunks = []
        start = end = 0
        if prefix[0] == u'!':
            end = 1
        while end < len(prefix):
            ch = prefix[end]
            if u'0' <= ch <= u'9' or u'A' <= ch <= u'Z' or u'a' <= ch <= u'z'   \
                    or ch in u'-;/?!:@&=+$,_.~*\'()[]':
                end += 1
            else:
                if start < end:
                    chunks.append(prefix[start:end])
                start = end = end+1
                data = ch.encode('utf-8')
                for ch in data:
                    chunks.append(u'%%%02X' % ord(ch))
        if start < end:
            chunks.append(prefix[start:end])
        return u''.join(chunks)

    def prepare_tag(self, tag):
        if not tag:
            raise EmitterError("tag must not be empty")
        if tag == u'!':
            return tag
        handle = None
        suffix = tag
        prefixes = self.tag_prefixes.keys()
        prefixes.sort()
        for prefix in prefixes:
            if tag.startswith(prefix)   \
                    and (prefix == u'!' or len(prefix) < len(tag)):
                handle = self.tag_prefixes[prefix]
                suffix = tag[len(prefix):]
        chunks = []
        start = end = 0
        while end < len(suffix):
            ch = suffix[end]
            if u'0' <= ch <= u'9' or u'A' <= ch <= u'Z' or u'a' <= ch <= u'z'   \
                    or ch in u'-;/?:@&=+$,_.~*\'()[]'   \
                    or (ch == u'!' and handle != u'!'):
                end += 1
            else:
                if start < end:
                    chunks.append(suffix[start:end])
                start = end = end+1
                data = ch.encode('utf-8')
                for ch in data:
                    chunks.append(u'%%%02X' % ord(ch))
        if start < end:
            chunks.append(suffix[start:end])
        suffix_text = u''.join(chunks)
        if handle:
            return u'%s%s' % (handle, suffix_text)
        else:
            return u'!<%s>' % suffix_text

    def prepare_anchor(self, anchor):
        if not anchor:
            raise EmitterError("anchor must not be empty")
        for ch in anchor:
            if not (u'0' <= ch <= u'9' or u'A' <= ch <= u'Z' or u'a' <= ch <= u'z'  \
                    or ch in u'-_'):
                raise EmitterError("invalid character %r in the anchor: %r"
                        % (ch.encode('utf-8'), anchor.encode('utf-8')))
        return anchor

    def analyze_scalar(self, scalar):

        # Empty scalar is a special case.
        if not scalar:
            return ScalarAnalysis(scalar=scalar, empty=True, multiline=False,
                    allow_flow_plain=False, allow_block_plain=True,
                    allow_single_quoted=True, allow_double_quoted=True,
                    allow_block=False)

        # Indicators and special characters.
        block_indicators = False
        flow_indicators = False
        line_breaks = False
        special_characters = False

        # Important whitespace combinations.
        leading_space = False
        leading_break = False
        trailing_space = False
        trailing_break = False
        break_space = False
        space_break = False

        # Check document indicators.
        if scalar.startswith(u'---') or scalar.startswith(u'...'):
            block_indicators = True
            flow_indicators = True

        # First character or preceded by a whitespace.
        preceeded_by_whitespace = True

        # Last character or followed by a whitespace.
        followed_by_whitespace = (len(scalar) == 1 or
                scalar[1] in u'\0 \t\r\n\x85\u2028\u2029')

        # The previous character is a space.
        previous_space = False

        # The previous character is a break.
        previous_break = False

        index = 0
        while index < len(scalar):
            ch = scalar[index]

            # Check for indicators.
            if index == 0:
                # Leading indicators are special characters.
                if ch in u'#,[]{}&*!|>\'\"%@`': 
                    flow_indicators = True
                    block_indicators = True
                if ch in u'?:':
                    flow_indicators = True
                    if followed_by_whitespace:
                        block_indicators = True
                if ch == u'-' and followed_by_whitespace:
                    flow_indicators = True
                    block_indicators = True
            else:
                # Some indicators cannot appear within a scalar as well.
                if ch in u',?[]{}':
                    flow_indicators = True
                if ch == u':':
                    flow_indicators = True
                    if followed_by_whitespace:
                        block_indicators = True
                if ch == u'#' and preceeded_by_whitespace:
                    flow_indicators = True
                    block_indicators = True

            # Check for line breaks, special, and unicode characters.
            if ch in u'\n\x85\u2028\u2029':
                line_breaks = True
            if not (ch == u'\n' or u'\x20' <= ch <= u'\x7E'):
                if (ch == u'\x85' or u'\xA0' <= ch <= u'\uD7FF'
                        or u'\uE000' <= ch <= u'\uFFFD') and ch != u'\uFEFF':
                    unicode_characters = True
                    if not self.allow_unicode:
                        special_characters = True
                else:
                    special_characters = True

            # Detect important whitespace combinations.
            if ch == u' ':
                if index == 0:
                    leading_space = True
                if index == len(scalar)-1:
                    trailing_space = True
                if previous_break:
                    break_space = True
                previous_space = True
                previous_break = False
            elif ch in u'\n\x85\u2028\u2029':
                if index == 0:
                    leading_break = True
                if index == len(scalar)-1:
                    trailing_break = True
                if previous_space:
                    space_break = True
                previous_space = False
                previous_break = True
            else:
                previous_space = False
                previous_break = False

            # Prepare for the next character.
            index += 1
            preceeded_by_whitespace = (ch in u'\0 \t\r\n\x85\u2028\u2029')
            followed_by_whitespace = (index+1 >= len(scalar) or
                    scalar[index+1] in u'\0 \t\r\n\x85\u2028\u2029')

        # Let's decide what styles are allowed.
        allow_flow_plain = True
        allow_block_plain = True
        allow_single_quoted = True
        allow_double_quoted = True
        allow_block = True

        # Leading and trailing whitespaces are bad for plain scalars.
        if (leading_space or leading_break
                or trailing_space or trailing_break):
            allow_flow_plain = allow_block_plain = False

        # We do not permit trailing spaces for block scalars.
        if trailing_space:
            allow_block = False

        # Spaces at the beginning of a new line are only acceptable for block
        # scalars.
        if break_space:
            allow_flow_plain = allow_block_plain = allow_single_quoted = False

        # Spaces followed by breaks, as well as special character are only
        # allowed for double quoted scalars.
        if space_break or special_characters:
            allow_flow_plain = allow_block_plain =  \
            allow_single_quoted = allow_block = False

        # Although the plain scalar writer supports breaks, we never emit
        # multiline plain scalars.
        if line_breaks:
            allow_flow_plain = allow_block_plain = False

        # Flow indicators are forbidden for flow plain scalars.
        if flow_indicators:
            allow_flow_plain = False

        # Block indicators are forbidden for block plain scalars.
        if block_indicators:
            allow_block_plain = False

        return ScalarAnalysis(scalar=scalar,
                empty=False, multiline=line_breaks,
                allow_flow_plain=allow_flow_plain,
                allow_block_plain=allow_block_plain,
                allow_single_quoted=allow_single_quoted,
                allow_double_quoted=allow_double_quoted,
                allow_block=allow_block)

    # Writers.

    def flush_stream(self):
        if hasattr(self.stream, 'flush'):
            self.stream.flush()

    def write_stream_start(self):
        # Write BOM if needed.
        if self.encoding and self.encoding.startswith('utf-16'):
            self.stream.write(u'\uFEFF'.encode(self.encoding))

    def write_stream_end(self):
        self.flush_stream()

    def write_indicator(self, indicator, need_whitespace,
            whitespace=False, indention=False):
        if self.whitespace or not need_whitespace:
            data = indicator
        else:
            data = u' '+indicator
        self.whitespace = whitespace
        self.indention = self.indention and indention
        self.column += len(data)
        self.open_ended = False
        if self.encoding:
            data = data.encode(self.encoding)
        self.stream.write(data)

    def write_indent(self):
        indent = self.indent or 0
        if not self.indention or self.column > indent   \
                or (self.column == indent and not self.whitespace):
            self.write_line_break()
        if self.column < indent:
            self.whitespace = True
            data = u' '*(indent-self.column)
            self.column = indent
            if self.encoding:
                data = data.encode(self.encoding)
            self.stream.write(data)

    def write_line_break(self, data=None):
        if data is None:
            data = self.best_line_break
        self.whitespace = True
        self.indention = True
        self.line += 1
        self.column = 0
        if self.encoding:
            data = data.encode(self.encoding)
        self.stream.write(data)

    def write_version_directive(self, version_text):
        data = u'%%YAML %s' % version_text
        if self.encoding:
            data = data.encode(self.encoding)
        self.stream.write(data)
        self.write_line_break()

    def write_tag_directive(self, handle_text, prefix_text):
        data = u'%%TAG %s %s' % (handle_text, prefix_text)
        if self.encoding:
            data = data.encode(self.encoding)
        self.stream.write(data)
        self.write_line_break()

    # Scalar streams.

    def write_single_quoted(self, text, split=True):
        self.write_indicator(u'\'', True)
        spaces = False
        breaks = False
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if spaces:
                if ch is None or ch != u' ':
                    if start+1 == end and self.column > self.best_width and split   \
                            and start != 0 and end != len(text):
                        self.write_indent()
                    else:
                        data = text[start:end]
                        self.column += len(data)
                        if self.encoding:
                            data = data.encode(self.encoding)
                        self.stream.write(data)
                    start = end
            elif breaks:
                if ch is None or ch not in u'\n\x85\u2028\u2029':
                    if text[start] == u'\n':
                        self.write_line_break()
                    for br in text[start:end]:
                        if br == u'\n':
                            self.write_line_break()
                        else:
                            self.write_line_break(br)
                    self.write_indent()
                    start = end
            else:
                if ch is None or ch in u' \n\x85\u2028\u2029' or ch == u'\'':
                    if start < end:
                        data = text[start:end]
                        self.column += len(data)
                        if self.encoding:
                            data = data.encode(self.encoding)
                        self.stream.write(data)
                        start = end
            if ch == u'\'':
                data = u'\'\''
                self.column += 2
                if self.encoding:
                    data = data.encode(self.encoding)
                self.stream.write(data)
                start = end + 1
            if ch is not None:
                spaces = (ch == u' ')
                breaks = (ch in u'\n\x85\u2028\u2029')
            end += 1
        self.write_indicator(u'\'', False)

    ESCAPE_REPLACEMENTS = {
        u'\0':      u'0',
        u'\x07':    u'a',
        u'\x08':    u'b',
        u'\x09':    u't',
        u'\x0A':    u'n',
        u'\x0B':    u'v',
        u'\x0C':    u'f',
        u'\x0D':    u'r',
        u'\x1B':    u'e',
        u'\"':      u'\"',
        u'\\':      u'\\',
        u'\x85':    u'N',
        u'\xA0':    u'_',
        u'\u2028':  u'L',
        u'\u2029':  u'P',
    }

    def write_double_quoted(self, text, split=True):
        self.write_indicator(u'"', True)
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if ch is None or ch in u'"\\\x85\u2028\u2029\uFEFF' \
                    or not (u'\x20' <= ch <= u'\x7E'
                        or (self.allow_unicode
                            and (u'\xA0' <= ch <= u'\uD7FF'
                                or u'\uE000' <= ch <= u'\uFFFD'))):
                if start < end:
                    data = text[start:end]
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    start = end
                if ch is not None:
                    if ch in self.ESCAPE_REPLACEMENTS:
                        data = u'\\'+self.ESCAPE_REPLACEMENTS[ch]
                    elif ch <= u'\xFF':
                        data = u'\\x%02X' % ord(ch)
                    elif ch <= u'\uFFFF':
                        data = u'\\u%04X' % ord(ch)
                    else:
                        data = u'\\U%08X' % ord(ch)
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    start = end+1
            if 0 < end < len(text)-1 and (ch == u' ' or start >= end)   \
                    and self.column+(end-start) > self.best_width and split:
                data = text[start:end]+u'\\'
                if start < end:
                    start = end
                self.column += len(data)
                if self.encoding:
                    data = data.encode(self.encoding)
                self.stream.write(data)
                self.write_indent()
                self.whitespace = False
                self.indention = False
                if text[start] == u' ':
                    data = u'\\'
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
            end += 1
        self.write_indicator(u'"', False)

    def determine_block_hints(self, text):
        hints = u''
        if text:
            if text[0] in u' \n\x85\u2028\u2029':
                hints += unicode(self.best_indent)
            if text[-1] not in u'\n\x85\u2028\u2029':
                hints += u'-'
            elif len(text) == 1 or text[-2] in u'\n\x85\u2028\u2029':
                hints += u'+'
        return hints

    def write_folded(self, text):
        hints = self.determine_block_hints(text)
        self.write_indicator(u'>'+hints, True)
        if hints[-1:] == u'+':
            self.open_ended = True
        self.write_line_break()
        leading_space = True
        spaces = False
        breaks = True
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if breaks:
                if ch is None or ch not in u'\n\x85\u2028\u2029':
                    if not leading_space and ch is not None and ch != u' '  \
                            and text[start] == u'\n':
                        self.write_line_break()
                    leading_space = (ch == u' ')
                    for br in text[start:end]:
                        if br == u'\n':
                            self.write_line_break()
                        else:
                            self.write_line_break(br)
                    if ch is not None:
                        self.write_indent()
                    start = end
            elif spaces:
                if ch != u' ':
                    if start+1 == end and self.column > self.best_width:
                        self.write_indent()
                    else:
                        data = text[start:end]
                        self.column += len(data)
                        if self.encoding:
                            data = data.encode(self.encoding)
                        self.stream.write(data)
                    start = end
            else:
                if ch is None or ch in u' \n\x85\u2028\u2029':
                    data = text[start:end]
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    if ch is None:
                        self.write_line_break()
                    start = end
            if ch is not None:
                breaks = (ch in u'\n\x85\u2028\u2029')
                spaces = (ch == u' ')
            end += 1

    def write_literal(self, text):
        hints = self.determine_block_hints(text)
        self.write_indicator(u'|'+hints, True)
        if hints[-1:] == u'+':
            self.open_ended = True
        self.write_line_break()
        breaks = True
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if breaks:
                if ch is None or ch not in u'\n\x85\u2028\u2029':
                    for br in text[start:end]:
                        if br == u'\n':
                            self.write_line_break()
                        else:
                            self.write_line_break(br)
                    if ch is not None:
                        self.write_indent()
                    start = end
            else:
                if ch is None or ch in u'\n\x85\u2028\u2029':
                    data = text[start:end]
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    if ch is None:
                        self.write_line_break()
                    start = end
            if ch is not None:
                breaks = (ch in u'\n\x85\u2028\u2029')
            end += 1

    def write_plain(self, text, split=True):
        if self.root_context:
            self.open_ended = True
        if not text:
            return
        if not self.whitespace:
            data = u' '
            self.column += len(data)
            if self.encoding:
                data = data.encode(self.encoding)
            self.stream.write(data)
        self.whitespace = False
        self.indention = False
        spaces = False
        breaks = False
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if spaces:
                if ch != u' ':
                    if start+1 == end and self.column > self.best_width and split:
                        self.write_indent()
                        self.whitespace = False
                        self.indention = False
                    else:
                        data = text[start:end]
                        self.column += len(data)
                        if self.encoding:
                            data = data.encode(self.encoding)
                        self.stream.write(data)
                    start = end
            elif breaks:
                if ch not in u'\n\x85\u2028\u2029':
                    if text[start] == u'\n':
                        self.write_line_break()
                    for br in text[start:end]:
                        if br == u'\n':
                            self.write_line_break()
                        else:
                            self.write_line_break(br)
                    self.write_indent()
                    self.whitespace = False
                    self.indention = False
                    start = end
            else:
                if ch is None or ch in u' \n\x85\u2028\u2029':
                    data = text[start:end]
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    start = end
            if ch is not None:
                spaces = (ch == u' ')
                breaks = (ch in u'\n\x85\u2028\u2029')
            end += 1


########NEW FILE########
__FILENAME__ = error

__all__ = ['Mark', 'YAMLError', 'MarkedYAMLError']

class Mark(object):

    def __init__(self, name, index, line, column, buffer, pointer):
        self.name = name
        self.index = index
        self.line = line
        self.column = column
        self.buffer = buffer
        self.pointer = pointer

    def get_snippet(self, indent=4, max_length=75):
        if self.buffer is None:
            return None
        head = ''
        start = self.pointer
        while start > 0 and self.buffer[start-1] not in u'\0\r\n\x85\u2028\u2029':
            start -= 1
            if self.pointer-start > max_length/2-1:
                head = ' ... '
                start += 5
                break
        tail = ''
        end = self.pointer
        while end < len(self.buffer) and self.buffer[end] not in u'\0\r\n\x85\u2028\u2029':
            end += 1
            if end-self.pointer > max_length/2-1:
                tail = ' ... '
                end -= 5
                break
        snippet = self.buffer[start:end].encode('utf-8')
        return ' '*indent + head + snippet + tail + '\n'  \
                + ' '*(indent+self.pointer-start+len(head)) + '^'

    def __str__(self):
        snippet = self.get_snippet()
        where = "  in \"%s\", line %d, column %d"   \
                % (self.name, self.line+1, self.column+1)
        if snippet is not None:
            where += ":\n"+snippet
        return where

class YAMLError(Exception):
    pass

class MarkedYAMLError(YAMLError):

    def __init__(self, context=None, context_mark=None,
            problem=None, problem_mark=None, note=None):
        self.context = context
        self.context_mark = context_mark
        self.problem = problem
        self.problem_mark = problem_mark
        self.note = note

    def __str__(self):
        lines = []
        if self.context is not None:
            lines.append(self.context)
        if self.context_mark is not None  \
            and (self.problem is None or self.problem_mark is None
                    or self.context_mark.name != self.problem_mark.name
                    or self.context_mark.line != self.problem_mark.line
                    or self.context_mark.column != self.problem_mark.column):
            lines.append(str(self.context_mark))
        if self.problem is not None:
            lines.append(self.problem)
        if self.problem_mark is not None:
            lines.append(str(self.problem_mark))
        if self.note is not None:
            lines.append(self.note)
        return '\n'.join(lines)


########NEW FILE########
__FILENAME__ = events

# Abstract classes.

class Event(object):
    def __init__(self, start_mark=None, end_mark=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
    def __repr__(self):
        attributes = [key for key in ['anchor', 'tag', 'implicit', 'value']
                if hasattr(self, key)]
        arguments = ', '.join(['%s=%r' % (key, getattr(self, key))
                for key in attributes])
        return '%s(%s)' % (self.__class__.__name__, arguments)

class NodeEvent(Event):
    def __init__(self, anchor, start_mark=None, end_mark=None):
        self.anchor = anchor
        self.start_mark = start_mark
        self.end_mark = end_mark

class CollectionStartEvent(NodeEvent):
    def __init__(self, anchor, tag, implicit, start_mark=None, end_mark=None,
            flow_style=None):
        self.anchor = anchor
        self.tag = tag
        self.implicit = implicit
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.flow_style = flow_style

class CollectionEndEvent(Event):
    pass

# Implementations.

class StreamStartEvent(Event):
    def __init__(self, start_mark=None, end_mark=None, encoding=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.encoding = encoding

class StreamEndEvent(Event):
    pass

class DocumentStartEvent(Event):
    def __init__(self, start_mark=None, end_mark=None,
            explicit=None, version=None, tags=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.explicit = explicit
        self.version = version
        self.tags = tags

class DocumentEndEvent(Event):
    def __init__(self, start_mark=None, end_mark=None,
            explicit=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.explicit = explicit

class AliasEvent(NodeEvent):
    pass

class ScalarEvent(NodeEvent):
    def __init__(self, anchor, tag, implicit, value,
            start_mark=None, end_mark=None, style=None):
        self.anchor = anchor
        self.tag = tag
        self.implicit = implicit
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.style = style

class SequenceStartEvent(CollectionStartEvent):
    pass

class SequenceEndEvent(CollectionEndEvent):
    pass

class MappingStartEvent(CollectionStartEvent):
    pass

class MappingEndEvent(CollectionEndEvent):
    pass


########NEW FILE########
__FILENAME__ = loader

__all__ = ['BaseLoader', 'SafeLoader', 'Loader']

from reader import *
from scanner import *
from parser import *
from composer import *
from constructor import *
from resolver import *

class BaseLoader(Reader, Scanner, Parser, Composer, BaseConstructor, BaseResolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        BaseConstructor.__init__(self)
        BaseResolver.__init__(self)

class SafeLoader(Reader, Scanner, Parser, Composer, SafeConstructor, Resolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        SafeConstructor.__init__(self)
        Resolver.__init__(self)

class Loader(Reader, Scanner, Parser, Composer, Constructor, Resolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        Constructor.__init__(self)
        Resolver.__init__(self)


########NEW FILE########
__FILENAME__ = nodes

class Node(object):
    def __init__(self, tag, value, start_mark, end_mark):
        self.tag = tag
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark
    def __repr__(self):
        value = self.value
        #if isinstance(value, list):
        #    if len(value) == 0:
        #        value = '<empty>'
        #    elif len(value) == 1:
        #        value = '<1 item>'
        #    else:
        #        value = '<%d items>' % len(value)
        #else:
        #    if len(value) > 75:
        #        value = repr(value[:70]+u' ... ')
        #    else:
        #        value = repr(value)
        value = repr(value)
        return '%s(tag=%r, value=%s)' % (self.__class__.__name__, self.tag, value)

class ScalarNode(Node):
    id = 'scalar'
    def __init__(self, tag, value,
            start_mark=None, end_mark=None, style=None):
        self.tag = tag
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.style = style

class CollectionNode(Node):
    def __init__(self, tag, value,
            start_mark=None, end_mark=None, flow_style=None):
        self.tag = tag
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.flow_style = flow_style

class SequenceNode(CollectionNode):
    id = 'sequence'

class MappingNode(CollectionNode):
    id = 'mapping'


########NEW FILE########
__FILENAME__ = parser

# The following YAML grammar is LL(1) and is parsed by a recursive descent
# parser.
#
# stream            ::= STREAM-START implicit_document? explicit_document* STREAM-END
# implicit_document ::= block_node DOCUMENT-END*
# explicit_document ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
# block_node_or_indentless_sequence ::=
#                       ALIAS
#                       | properties (block_content | indentless_block_sequence)?
#                       | block_content
#                       | indentless_block_sequence
# block_node        ::= ALIAS
#                       | properties block_content?
#                       | block_content
# flow_node         ::= ALIAS
#                       | properties flow_content?
#                       | flow_content
# properties        ::= TAG ANCHOR? | ANCHOR TAG?
# block_content     ::= block_collection | flow_collection | SCALAR
# flow_content      ::= flow_collection | SCALAR
# block_collection  ::= block_sequence | block_mapping
# flow_collection   ::= flow_sequence | flow_mapping
# block_sequence    ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END
# indentless_sequence   ::= (BLOCK-ENTRY block_node?)+
# block_mapping     ::= BLOCK-MAPPING_START
#                       ((KEY block_node_or_indentless_sequence?)?
#                       (VALUE block_node_or_indentless_sequence?)?)*
#                       BLOCK-END
# flow_sequence     ::= FLOW-SEQUENCE-START
#                       (flow_sequence_entry FLOW-ENTRY)*
#                       flow_sequence_entry?
#                       FLOW-SEQUENCE-END
# flow_sequence_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
# flow_mapping      ::= FLOW-MAPPING-START
#                       (flow_mapping_entry FLOW-ENTRY)*
#                       flow_mapping_entry?
#                       FLOW-MAPPING-END
# flow_mapping_entry    ::= flow_node | KEY flow_node? (VALUE flow_node?)?
#
# FIRST sets:
#
# stream: { STREAM-START }
# explicit_document: { DIRECTIVE DOCUMENT-START }
# implicit_document: FIRST(block_node)
# block_node: { ALIAS TAG ANCHOR SCALAR BLOCK-SEQUENCE-START BLOCK-MAPPING-START FLOW-SEQUENCE-START FLOW-MAPPING-START }
# flow_node: { ALIAS ANCHOR TAG SCALAR FLOW-SEQUENCE-START FLOW-MAPPING-START }
# block_content: { BLOCK-SEQUENCE-START BLOCK-MAPPING-START FLOW-SEQUENCE-START FLOW-MAPPING-START SCALAR }
# flow_content: { FLOW-SEQUENCE-START FLOW-MAPPING-START SCALAR }
# block_collection: { BLOCK-SEQUENCE-START BLOCK-MAPPING-START }
# flow_collection: { FLOW-SEQUENCE-START FLOW-MAPPING-START }
# block_sequence: { BLOCK-SEQUENCE-START }
# block_mapping: { BLOCK-MAPPING-START }
# block_node_or_indentless_sequence: { ALIAS ANCHOR TAG SCALAR BLOCK-SEQUENCE-START BLOCK-MAPPING-START FLOW-SEQUENCE-START FLOW-MAPPING-START BLOCK-ENTRY }
# indentless_sequence: { ENTRY }
# flow_collection: { FLOW-SEQUENCE-START FLOW-MAPPING-START }
# flow_sequence: { FLOW-SEQUENCE-START }
# flow_mapping: { FLOW-MAPPING-START }
# flow_sequence_entry: { ALIAS ANCHOR TAG SCALAR FLOW-SEQUENCE-START FLOW-MAPPING-START KEY }
# flow_mapping_entry: { ALIAS ANCHOR TAG SCALAR FLOW-SEQUENCE-START FLOW-MAPPING-START KEY }

__all__ = ['Parser', 'ParserError']

from error import MarkedYAMLError
from tokens import *
from events import *
from scanner import *

class ParserError(MarkedYAMLError):
    pass

class Parser(object):
    # Since writing a recursive-descendant parser is a straightforward task, we
    # do not give many comments here.

    DEFAULT_TAGS = {
        u'!':   u'!',
        u'!!':  u'tag:yaml.org,2002:',
    }

    def __init__(self):
        self.current_event = None
        self.yaml_version = None
        self.tag_handles = {}
        self.states = []
        self.marks = []
        self.state = self.parse_stream_start

    def check_event(self, *choices):
        # Check the type of the next event.
        if self.current_event is None:
            if self.state:
                self.current_event = self.state()
        if self.current_event is not None:
            if not choices:
                return True
            for choice in choices:
                if isinstance(self.current_event, choice):
                    return True
        return False

    def peek_event(self):
        # Get the next event.
        if self.current_event is None:
            if self.state:
                self.current_event = self.state()
        return self.current_event

    def get_event(self):
        # Get the next event and proceed further.
        if self.current_event is None:
            if self.state:
                self.current_event = self.state()
        value = self.current_event
        self.current_event = None
        return value

    # stream    ::= STREAM-START implicit_document? explicit_document* STREAM-END
    # implicit_document ::= block_node DOCUMENT-END*
    # explicit_document ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*

    def parse_stream_start(self):

        # Parse the stream start.
        token = self.get_token()
        event = StreamStartEvent(token.start_mark, token.end_mark,
                encoding=token.encoding)

        # Prepare the next state.
        self.state = self.parse_implicit_document_start

        return event

    def parse_implicit_document_start(self):

        # Parse an implicit document.
        if not self.check_token(DirectiveToken, DocumentStartToken,
                StreamEndToken):
            self.tag_handles = self.DEFAULT_TAGS
            token = self.peek_token()
            start_mark = end_mark = token.start_mark
            event = DocumentStartEvent(start_mark, end_mark,
                    explicit=False)

            # Prepare the next state.
            self.states.append(self.parse_document_end)
            self.state = self.parse_block_node

            return event

        else:
            return self.parse_document_start()

    def parse_document_start(self):

        # Parse any extra document end indicators.
        while self.check_token(DocumentEndToken):
            self.get_token()

        # Parse an explicit document.
        if not self.check_token(StreamEndToken):
            token = self.peek_token()
            start_mark = token.start_mark
            version, tags = self.process_directives()
            if not self.check_token(DocumentStartToken):
                raise ParserError(None, None,
                        "expected '<document start>', but found %r"
                        % self.peek_token().id,
                        self.peek_token().start_mark)
            token = self.get_token()
            end_mark = token.end_mark
            event = DocumentStartEvent(start_mark, end_mark,
                    explicit=True, version=version, tags=tags)
            self.states.append(self.parse_document_end)
            self.state = self.parse_document_content
        else:
            # Parse the end of the stream.
            token = self.get_token()
            event = StreamEndEvent(token.start_mark, token.end_mark)
            assert not self.states
            assert not self.marks
            self.state = None
        return event

    def parse_document_end(self):

        # Parse the document end.
        token = self.peek_token()
        start_mark = end_mark = token.start_mark
        explicit = False
        if self.check_token(DocumentEndToken):
            token = self.get_token()
            end_mark = token.end_mark
            explicit = True
        event = DocumentEndEvent(start_mark, end_mark,
                explicit=explicit)

        # Prepare the next state.
        self.state = self.parse_document_start

        return event

    def parse_document_content(self):
        if self.check_token(DirectiveToken,
                DocumentStartToken, DocumentEndToken, StreamEndToken):
            event = self.process_empty_scalar(self.peek_token().start_mark)
            self.state = self.states.pop()
            return event
        else:
            return self.parse_block_node()

    def process_directives(self):
        self.yaml_version = None
        self.tag_handles = {}
        while self.check_token(DirectiveToken):
            token = self.get_token()
            if token.name == u'YAML':
                if self.yaml_version is not None:
                    raise ParserError(None, None,
                            "found duplicate YAML directive", token.start_mark)
                major, minor = token.value
                if major != 1:
                    raise ParserError(None, None,
                            "found incompatible YAML document (version 1.* is required)",
                            token.start_mark)
                self.yaml_version = token.value
            elif token.name == u'TAG':
                handle, prefix = token.value
                if handle in self.tag_handles:
                    raise ParserError(None, None,
                            "duplicate tag handle %r" % handle.encode('utf-8'),
                            token.start_mark)
                self.tag_handles[handle] = prefix
        if self.tag_handles:
            value = self.yaml_version, self.tag_handles.copy()
        else:
            value = self.yaml_version, None
        for key in self.DEFAULT_TAGS:
            if key not in self.tag_handles:
                self.tag_handles[key] = self.DEFAULT_TAGS[key]
        return value

    # block_node_or_indentless_sequence ::= ALIAS
    #               | properties (block_content | indentless_block_sequence)?
    #               | block_content
    #               | indentless_block_sequence
    # block_node    ::= ALIAS
    #                   | properties block_content?
    #                   | block_content
    # flow_node     ::= ALIAS
    #                   | properties flow_content?
    #                   | flow_content
    # properties    ::= TAG ANCHOR? | ANCHOR TAG?
    # block_content     ::= block_collection | flow_collection | SCALAR
    # flow_content      ::= flow_collection | SCALAR
    # block_collection  ::= block_sequence | block_mapping
    # flow_collection   ::= flow_sequence | flow_mapping

    def parse_block_node(self):
        return self.parse_node(block=True)

    def parse_flow_node(self):
        return self.parse_node()

    def parse_block_node_or_indentless_sequence(self):
        return self.parse_node(block=True, indentless_sequence=True)

    def parse_node(self, block=False, indentless_sequence=False):
        if self.check_token(AliasToken):
            token = self.get_token()
            event = AliasEvent(token.value, token.start_mark, token.end_mark)
            self.state = self.states.pop()
        else:
            anchor = None
            tag = None
            start_mark = end_mark = tag_mark = None
            if self.check_token(AnchorToken):
                token = self.get_token()
                start_mark = token.start_mark
                end_mark = token.end_mark
                anchor = token.value
                if self.check_token(TagToken):
                    token = self.get_token()
                    tag_mark = token.start_mark
                    end_mark = token.end_mark
                    tag = token.value
            elif self.check_token(TagToken):
                token = self.get_token()
                start_mark = tag_mark = token.start_mark
                end_mark = token.end_mark
                tag = token.value
                if self.check_token(AnchorToken):
                    token = self.get_token()
                    end_mark = token.end_mark
                    anchor = token.value
            if tag is not None:
                handle, suffix = tag
                if handle is not None:
                    if handle not in self.tag_handles:
                        raise ParserError("while parsing a node", start_mark,
                                "found undefined tag handle %r" % handle.encode('utf-8'),
                                tag_mark)
                    tag = self.tag_handles[handle]+suffix
                else:
                    tag = suffix
            #if tag == u'!':
            #    raise ParserError("while parsing a node", start_mark,
            #            "found non-specific tag '!'", tag_mark,
            #            "Please check 'http://pyyaml.org/wiki/YAMLNonSpecificTag' and share your opinion.")
            if start_mark is None:
                start_mark = end_mark = self.peek_token().start_mark
            event = None
            implicit = (tag is None or tag == u'!')
            if indentless_sequence and self.check_token(BlockEntryToken):
                end_mark = self.peek_token().end_mark
                event = SequenceStartEvent(anchor, tag, implicit,
                        start_mark, end_mark)
                self.state = self.parse_indentless_sequence_entry
            else:
                if self.check_token(ScalarToken):
                    token = self.get_token()
                    end_mark = token.end_mark
                    if (token.plain and tag is None) or tag == u'!':
                        implicit = (True, False)
                    elif tag is None:
                        implicit = (False, True)
                    else:
                        implicit = (False, False)
                    event = ScalarEvent(anchor, tag, implicit, token.value,
                            start_mark, end_mark, style=token.style)
                    self.state = self.states.pop()
                elif self.check_token(FlowSequenceStartToken):
                    end_mark = self.peek_token().end_mark
                    event = SequenceStartEvent(anchor, tag, implicit,
                            start_mark, end_mark, flow_style=True)
                    self.state = self.parse_flow_sequence_first_entry
                elif self.check_token(FlowMappingStartToken):
                    end_mark = self.peek_token().end_mark
                    event = MappingStartEvent(anchor, tag, implicit,
                            start_mark, end_mark, flow_style=True)
                    self.state = self.parse_flow_mapping_first_key
                elif block and self.check_token(BlockSequenceStartToken):
                    end_mark = self.peek_token().start_mark
                    event = SequenceStartEvent(anchor, tag, implicit,
                            start_mark, end_mark, flow_style=False)
                    self.state = self.parse_block_sequence_first_entry
                elif block and self.check_token(BlockMappingStartToken):
                    end_mark = self.peek_token().start_mark
                    event = MappingStartEvent(anchor, tag, implicit,
                            start_mark, end_mark, flow_style=False)
                    self.state = self.parse_block_mapping_first_key
                elif anchor is not None or tag is not None:
                    # Empty scalars are allowed even if a tag or an anchor is
                    # specified.
                    event = ScalarEvent(anchor, tag, (implicit, False), u'',
                            start_mark, end_mark)
                    self.state = self.states.pop()
                else:
                    if block:
                        node = 'block'
                    else:
                        node = 'flow'
                    token = self.peek_token()
                    raise ParserError("while parsing a %s node" % node, start_mark,
                            "expected the node content, but found %r" % token.id,
                            token.start_mark)
        return event

    # block_sequence ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END

    def parse_block_sequence_first_entry(self):
        token = self.get_token()
        self.marks.append(token.start_mark)
        return self.parse_block_sequence_entry()

    def parse_block_sequence_entry(self):
        if self.check_token(BlockEntryToken):
            token = self.get_token()
            if not self.check_token(BlockEntryToken, BlockEndToken):
                self.states.append(self.parse_block_sequence_entry)
                return self.parse_block_node()
            else:
                self.state = self.parse_block_sequence_entry
                return self.process_empty_scalar(token.end_mark)
        if not self.check_token(BlockEndToken):
            token = self.peek_token()
            raise ParserError("while parsing a block collection", self.marks[-1],
                    "expected <block end>, but found %r" % token.id, token.start_mark)
        token = self.get_token()
        event = SequenceEndEvent(token.start_mark, token.end_mark)
        self.state = self.states.pop()
        self.marks.pop()
        return event

    # indentless_sequence ::= (BLOCK-ENTRY block_node?)+

    def parse_indentless_sequence_entry(self):
        if self.check_token(BlockEntryToken):
            token = self.get_token()
            if not self.check_token(BlockEntryToken,
                    KeyToken, ValueToken, BlockEndToken):
                self.states.append(self.parse_indentless_sequence_entry)
                return self.parse_block_node()
            else:
                self.state = self.parse_indentless_sequence_entry
                return self.process_empty_scalar(token.end_mark)
        token = self.peek_token()
        event = SequenceEndEvent(token.start_mark, token.start_mark)
        self.state = self.states.pop()
        return event

    # block_mapping     ::= BLOCK-MAPPING_START
    #                       ((KEY block_node_or_indentless_sequence?)?
    #                       (VALUE block_node_or_indentless_sequence?)?)*
    #                       BLOCK-END

    def parse_block_mapping_first_key(self):
        token = self.get_token()
        self.marks.append(token.start_mark)
        return self.parse_block_mapping_key()

    def parse_block_mapping_key(self):
        if self.check_token(KeyToken):
            token = self.get_token()
            if not self.check_token(KeyToken, ValueToken, BlockEndToken):
                self.states.append(self.parse_block_mapping_value)
                return self.parse_block_node_or_indentless_sequence()
            else:
                self.state = self.parse_block_mapping_value
                return self.process_empty_scalar(token.end_mark)
        if not self.check_token(BlockEndToken):
            token = self.peek_token()
            raise ParserError("while parsing a block mapping", self.marks[-1],
                    "expected <block end>, but found %r" % token.id, token.start_mark)
        token = self.get_token()
        event = MappingEndEvent(token.start_mark, token.end_mark)
        self.state = self.states.pop()
        self.marks.pop()
        return event

    def parse_block_mapping_value(self):
        if self.check_token(ValueToken):
            token = self.get_token()
            if not self.check_token(KeyToken, ValueToken, BlockEndToken):
                self.states.append(self.parse_block_mapping_key)
                return self.parse_block_node_or_indentless_sequence()
            else:
                self.state = self.parse_block_mapping_key
                return self.process_empty_scalar(token.end_mark)
        else:
            self.state = self.parse_block_mapping_key
            token = self.peek_token()
            return self.process_empty_scalar(token.start_mark)

    # flow_sequence     ::= FLOW-SEQUENCE-START
    #                       (flow_sequence_entry FLOW-ENTRY)*
    #                       flow_sequence_entry?
    #                       FLOW-SEQUENCE-END
    # flow_sequence_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
    #
    # Note that while production rules for both flow_sequence_entry and
    # flow_mapping_entry are equal, their interpretations are different.
    # For `flow_sequence_entry`, the part `KEY flow_node? (VALUE flow_node?)?`
    # generate an inline mapping (set syntax).

    def parse_flow_sequence_first_entry(self):
        token = self.get_token()
        self.marks.append(token.start_mark)
        return self.parse_flow_sequence_entry(first=True)

    def parse_flow_sequence_entry(self, first=False):
        if not self.check_token(FlowSequenceEndToken):
            if not first:
                if self.check_token(FlowEntryToken):
                    self.get_token()
                else:
                    token = self.peek_token()
                    raise ParserError("while parsing a flow sequence", self.marks[-1],
                            "expected ',' or ']', but got %r" % token.id, token.start_mark)
            
            if self.check_token(KeyToken):
                token = self.peek_token()
                event = MappingStartEvent(None, None, True,
                        token.start_mark, token.end_mark,
                        flow_style=True)
                self.state = self.parse_flow_sequence_entry_mapping_key
                return event
            elif not self.check_token(FlowSequenceEndToken):
                self.states.append(self.parse_flow_sequence_entry)
                return self.parse_flow_node()
        token = self.get_token()
        event = SequenceEndEvent(token.start_mark, token.end_mark)
        self.state = self.states.pop()
        self.marks.pop()
        return event

    def parse_flow_sequence_entry_mapping_key(self):
        token = self.get_token()
        if not self.check_token(ValueToken,
                FlowEntryToken, FlowSequenceEndToken):
            self.states.append(self.parse_flow_sequence_entry_mapping_value)
            return self.parse_flow_node()
        else:
            self.state = self.parse_flow_sequence_entry_mapping_value
            return self.process_empty_scalar(token.end_mark)

    def parse_flow_sequence_entry_mapping_value(self):
        if self.check_token(ValueToken):
            token = self.get_token()
            if not self.check_token(FlowEntryToken, FlowSequenceEndToken):
                self.states.append(self.parse_flow_sequence_entry_mapping_end)
                return self.parse_flow_node()
            else:
                self.state = self.parse_flow_sequence_entry_mapping_end
                return self.process_empty_scalar(token.end_mark)
        else:
            self.state = self.parse_flow_sequence_entry_mapping_end
            token = self.peek_token()
            return self.process_empty_scalar(token.start_mark)

    def parse_flow_sequence_entry_mapping_end(self):
        self.state = self.parse_flow_sequence_entry
        token = self.peek_token()
        return MappingEndEvent(token.start_mark, token.start_mark)

    # flow_mapping  ::= FLOW-MAPPING-START
    #                   (flow_mapping_entry FLOW-ENTRY)*
    #                   flow_mapping_entry?
    #                   FLOW-MAPPING-END
    # flow_mapping_entry    ::= flow_node | KEY flow_node? (VALUE flow_node?)?

    def parse_flow_mapping_first_key(self):
        token = self.get_token()
        self.marks.append(token.start_mark)
        return self.parse_flow_mapping_key(first=True)

    def parse_flow_mapping_key(self, first=False):
        if not self.check_token(FlowMappingEndToken):
            if not first:
                if self.check_token(FlowEntryToken):
                    self.get_token()
                else:
                    token = self.peek_token()
                    raise ParserError("while parsing a flow mapping", self.marks[-1],
                            "expected ',' or '}', but got %r" % token.id, token.start_mark)
            if self.check_token(KeyToken):
                token = self.get_token()
                if not self.check_token(ValueToken,
                        FlowEntryToken, FlowMappingEndToken):
                    self.states.append(self.parse_flow_mapping_value)
                    return self.parse_flow_node()
                else:
                    self.state = self.parse_flow_mapping_value
                    return self.process_empty_scalar(token.end_mark)
            elif not self.check_token(FlowMappingEndToken):
                self.states.append(self.parse_flow_mapping_empty_value)
                return self.parse_flow_node()
        token = self.get_token()
        event = MappingEndEvent(token.start_mark, token.end_mark)
        self.state = self.states.pop()
        self.marks.pop()
        return event

    def parse_flow_mapping_value(self):
        if self.check_token(ValueToken):
            token = self.get_token()
            if not self.check_token(FlowEntryToken, FlowMappingEndToken):
                self.states.append(self.parse_flow_mapping_key)
                return self.parse_flow_node()
            else:
                self.state = self.parse_flow_mapping_key
                return self.process_empty_scalar(token.end_mark)
        else:
            self.state = self.parse_flow_mapping_key
            token = self.peek_token()
            return self.process_empty_scalar(token.start_mark)

    def parse_flow_mapping_empty_value(self):
        self.state = self.parse_flow_mapping_key
        return self.process_empty_scalar(self.peek_token().start_mark)

    def process_empty_scalar(self, mark):
        return ScalarEvent(None, None, (True, False), u'', mark, mark)


########NEW FILE########
__FILENAME__ = reader
# This module contains abstractions for the input stream. You don't have to
# looks further, there are no pretty code.
#
# We define two classes here.
#
#   Mark(source, line, column)
# It's just a record and its only use is producing nice error messages.
# Parser does not use it for any other purposes.
#
#   Reader(source, data)
# Reader determines the encoding of `data` and converts it to unicode.
# Reader provides the following methods and attributes:
#   reader.peek(length=1) - return the next `length` characters
#   reader.forward(length=1) - move the current position to `length` characters.
#   reader.index - the number of the current character.
#   reader.line, stream.column - the line and the column of the current character.

__all__ = ['Reader', 'ReaderError']

from error import YAMLError, Mark

import codecs, re

# Unfortunately, codec functions in Python 2.3 does not support the `finish`
# arguments, so we have to write our own wrappers.

try:
    codecs.utf_8_decode('', 'strict', False)
    from codecs import utf_8_decode, utf_16_le_decode, utf_16_be_decode

except TypeError:

    def utf_16_le_decode(data, errors, finish=False):
        if not finish and len(data) % 2 == 1:
            data = data[:-1]
        return codecs.utf_16_le_decode(data, errors)

    def utf_16_be_decode(data, errors, finish=False):
        if not finish and len(data) % 2 == 1:
            data = data[:-1]
        return codecs.utf_16_be_decode(data, errors)

    def utf_8_decode(data, errors, finish=False):
        if not finish:
            # We are trying to remove a possible incomplete multibyte character
            # from the suffix of the data.
            # The first byte of a multi-byte sequence is in the range 0xc0 to 0xfd.
            # All further bytes are in the range 0x80 to 0xbf.
            # UTF-8 encoded UCS characters may be up to six bytes long.
            count = 0
            while count < 5 and count < len(data)   \
                    and '\x80' <= data[-count-1] <= '\xBF':
                count -= 1
            if count < 5 and count < len(data)  \
                    and '\xC0' <= data[-count-1] <= '\xFD':
                data = data[:-count-1]
        return codecs.utf_8_decode(data, errors)

class ReaderError(YAMLError):

    def __init__(self, name, position, character, encoding, reason):
        self.name = name
        self.character = character
        self.position = position
        self.encoding = encoding
        self.reason = reason

    def __str__(self):
        if isinstance(self.character, str):
            return "'%s' codec can't decode byte #x%02x: %s\n"  \
                    "  in \"%s\", position %d"    \
                    % (self.encoding, ord(self.character), self.reason,
                            self.name, self.position)
        else:
            return "unacceptable character #x%04x: %s\n"    \
                    "  in \"%s\", position %d"    \
                    % (self.character, self.reason,
                            self.name, self.position)

class Reader(object):
    # Reader:
    # - determines the data encoding and converts it to unicode,
    # - checks if characters are in allowed range,
    # - adds '\0' to the end.

    # Reader accepts
    #  - a `str` object,
    #  - a `unicode` object,
    #  - a file-like object with its `read` method returning `str`,
    #  - a file-like object with its `read` method returning `unicode`.

    # Yeah, it's ugly and slow.

    def __init__(self, stream):
        self.name = None
        self.stream = None
        self.stream_pointer = 0
        self.eof = True
        self.buffer = u''
        self.pointer = 0
        self.raw_buffer = None
        self.raw_decode = None
        self.encoding = None
        self.index = 0
        self.line = 0
        self.column = 0
        if isinstance(stream, unicode):
            self.name = "<unicode string>"
            self.check_printable(stream)
            self.buffer = stream+u'\0'
        elif isinstance(stream, str):
            self.name = "<string>"
            self.raw_buffer = stream
            self.determine_encoding()
        else:
            self.stream = stream
            self.name = getattr(stream, 'name', "<file>")
            self.eof = False
            self.raw_buffer = ''
            self.determine_encoding()

    def peek(self, index=0):
        try:
            return self.buffer[self.pointer+index]
        except IndexError:
            self.update(index+1)
            return self.buffer[self.pointer+index]

    def prefix(self, length=1):
        if self.pointer+length >= len(self.buffer):
            self.update(length)
        return self.buffer[self.pointer:self.pointer+length]

    def forward(self, length=1):
        if self.pointer+length+1 >= len(self.buffer):
            self.update(length+1)
        while length:
            ch = self.buffer[self.pointer]
            self.pointer += 1
            self.index += 1
            if ch in u'\n\x85\u2028\u2029'  \
                    or (ch == u'\r' and self.buffer[self.pointer] != u'\n'):
                self.line += 1
                self.column = 0
            elif ch != u'\uFEFF':
                self.column += 1
            length -= 1

    def get_mark(self):
        if self.stream is None:
            return Mark(self.name, self.index, self.line, self.column,
                    self.buffer, self.pointer)
        else:
            return Mark(self.name, self.index, self.line, self.column,
                    None, None)

    def determine_encoding(self):
        while not self.eof and len(self.raw_buffer) < 2:
            self.update_raw()
        if not isinstance(self.raw_buffer, unicode):
            if self.raw_buffer.startswith(codecs.BOM_UTF16_LE):
                self.raw_decode = utf_16_le_decode
                self.encoding = 'utf-16-le'
            elif self.raw_buffer.startswith(codecs.BOM_UTF16_BE):
                self.raw_decode = utf_16_be_decode
                self.encoding = 'utf-16-be'
            else:
                self.raw_decode = utf_8_decode
                self.encoding = 'utf-8'
        self.update(1)

    NON_PRINTABLE = re.compile(u'[^\x09\x0A\x0D\x20-\x7E\x85\xA0-\uD7FF\uE000-\uFFFD]')
    def check_printable(self, data):
        match = self.NON_PRINTABLE.search(data)
        if match:
            character = match.group()
            position = self.index+(len(self.buffer)-self.pointer)+match.start()
            raise ReaderError(self.name, position, ord(character),
                    'unicode', "special characters are not allowed")

    def update(self, length):
        if self.raw_buffer is None:
            return
        self.buffer = self.buffer[self.pointer:]
        self.pointer = 0
        while len(self.buffer) < length:
            if not self.eof:
                self.update_raw()
            if self.raw_decode is not None:
                try:
                    data, converted = self.raw_decode(self.raw_buffer,
                            'strict', self.eof)
                except UnicodeDecodeError, exc:
                    character = exc.object[exc.start]
                    if self.stream is not None:
                        position = self.stream_pointer-len(self.raw_buffer)+exc.start
                    else:
                        position = exc.start
                    raise ReaderError(self.name, position, character,
                            exc.encoding, exc.reason)
            else:
                data = self.raw_buffer
                converted = len(data)
            self.check_printable(data)
            self.buffer += data
            self.raw_buffer = self.raw_buffer[converted:]
            if self.eof:
                self.buffer += u'\0'
                self.raw_buffer = None
                break

    def update_raw(self, size=1024):
        data = self.stream.read(size)
        if data:
            self.raw_buffer += data
            self.stream_pointer += len(data)
        else:
            self.eof = True

#try:
#    import psyco
#    psyco.bind(Reader)
#except ImportError:
#    pass


########NEW FILE########
__FILENAME__ = representer

__all__ = ['BaseRepresenter', 'SafeRepresenter', 'Representer',
    'RepresenterError']

from error import *
from nodes import *

import datetime

try:
    set
except NameError:
    from sets import Set as set

import sys, copy_reg, types

class RepresenterError(YAMLError):
    pass

class BaseRepresenter(object):

    yaml_representers = {}
    yaml_multi_representers = {}

    def __init__(self, default_style=None, default_flow_style=None):
        self.default_style = default_style
        self.default_flow_style = default_flow_style
        self.represented_objects = {}
        self.object_keeper = []
        self.alias_key = None

    def represent(self, data):
        node = self.represent_data(data)
        self.serialize(node)
        self.represented_objects = {}
        self.object_keeper = []
        self.alias_key = None

    def get_classobj_bases(self, cls):
        bases = [cls]
        for base in cls.__bases__:
            bases.extend(self.get_classobj_bases(base))
        return bases

    def represent_data(self, data):
        if self.ignore_aliases(data):
            self.alias_key = None
        else:
            self.alias_key = id(data)
        if self.alias_key is not None:
            if self.alias_key in self.represented_objects:
                node = self.represented_objects[self.alias_key]
                #if node is None:
                #    raise RepresenterError("recursive objects are not allowed: %r" % data)
                return node
            #self.represented_objects[alias_key] = None
            self.object_keeper.append(data)
        data_types = type(data).__mro__
        if type(data) is types.InstanceType:
            data_types = self.get_classobj_bases(data.__class__)+list(data_types)
        if data_types[0] in self.yaml_representers:
            node = self.yaml_representers[data_types[0]](self, data)
        else:
            for data_type in data_types:
                if data_type in self.yaml_multi_representers:
                    node = self.yaml_multi_representers[data_type](self, data)
                    break
            else:
                if None in self.yaml_multi_representers:
                    node = self.yaml_multi_representers[None](self, data)
                elif None in self.yaml_representers:
                    node = self.yaml_representers[None](self, data)
                else:
                    node = ScalarNode(None, unicode(data))
        #if alias_key is not None:
        #    self.represented_objects[alias_key] = node
        return node

    def add_representer(cls, data_type, representer):
        if not 'yaml_representers' in cls.__dict__:
            cls.yaml_representers = cls.yaml_representers.copy()
        cls.yaml_representers[data_type] = representer
    add_representer = classmethod(add_representer)

    def add_multi_representer(cls, data_type, representer):
        if not 'yaml_multi_representers' in cls.__dict__:
            cls.yaml_multi_representers = cls.yaml_multi_representers.copy()
        cls.yaml_multi_representers[data_type] = representer
    add_multi_representer = classmethod(add_multi_representer)

    def represent_scalar(self, tag, value, style=None):
        if style is None:
            style = self.default_style
        node = ScalarNode(tag, value, style=style)
        if self.alias_key is not None:
            self.represented_objects[self.alias_key] = node
        return node

    def represent_sequence(self, tag, sequence, flow_style=None):
        value = []
        node = SequenceNode(tag, value, flow_style=flow_style)
        if self.alias_key is not None:
            self.represented_objects[self.alias_key] = node
        best_style = True
        for item in sequence:
            node_item = self.represent_data(item)
            if not (isinstance(node_item, ScalarNode) and not node_item.style):
                best_style = False
            value.append(node_item)
        if flow_style is None:
            if self.default_flow_style is not None:
                node.flow_style = self.default_flow_style
            else:
                node.flow_style = best_style
        return node

    def represent_mapping(self, tag, mapping, flow_style=None):
        value = []
        node = MappingNode(tag, value, flow_style=flow_style)
        if self.alias_key is not None:
            self.represented_objects[self.alias_key] = node
        best_style = True
        if hasattr(mapping, 'items'):
            mapping = mapping.items()
            mapping.sort()
        for item_key, item_value in mapping:
            node_key = self.represent_data(item_key)
            node_value = self.represent_data(item_value)
            if not (isinstance(node_key, ScalarNode) and not node_key.style):
                best_style = False
            if not (isinstance(node_value, ScalarNode) and not node_value.style):
                best_style = False
            value.append((node_key, node_value))
        if flow_style is None:
            if self.default_flow_style is not None:
                node.flow_style = self.default_flow_style
            else:
                node.flow_style = best_style
        return node

    def ignore_aliases(self, data):
        return False

class SafeRepresenter(BaseRepresenter):

    def ignore_aliases(self, data):
        if data in [None, ()]:
            return True
        if isinstance(data, (str, unicode, bool, int, float)):
            return True

    def represent_none(self, data):
        return self.represent_scalar(u'tag:yaml.org,2002:null',
                u'null')

    def represent_str(self, data):
        tag = None
        style = None
        try:
            data = unicode(data, 'ascii')
            tag = u'tag:yaml.org,2002:str'
        except UnicodeDecodeError:
            try:
                data = unicode(data, 'utf-8')
                tag = u'tag:yaml.org,2002:str'
            except UnicodeDecodeError:
                data = data.encode('base64')
                tag = u'tag:yaml.org,2002:binary'
                style = '|'
        return self.represent_scalar(tag, data, style=style)

    def represent_unicode(self, data):
        return self.represent_scalar(u'tag:yaml.org,2002:str', data)

    def represent_bool(self, data):
        if data:
            value = u'true'
        else:
            value = u'false'
        return self.represent_scalar(u'tag:yaml.org,2002:bool', value)

    def represent_int(self, data):
        return self.represent_scalar(u'tag:yaml.org,2002:int', unicode(data))

    def represent_long(self, data):
        return self.represent_scalar(u'tag:yaml.org,2002:int', unicode(data))

    inf_value = 1e300
    while repr(inf_value) != repr(inf_value*inf_value):
        inf_value *= inf_value

    def represent_float(self, data):
        if data != data or (data == 0.0 and data == 1.0):
            value = u'.nan'
        elif data == self.inf_value:
            value = u'.inf'
        elif data == -self.inf_value:
            value = u'-.inf'
        else:
            value = unicode(repr(data)).lower()
            # Note that in some cases `repr(data)` represents a float number
            # without the decimal parts.  For instance:
            #   >>> repr(1e17)
            #   '1e17'
            # Unfortunately, this is not a valid float representation according
            # to the definition of the `!!float` tag.  We fix this by adding
            # '.0' before the 'e' symbol.
            if u'.' not in value and u'e' in value:
                value = value.replace(u'e', u'.0e', 1)
        return self.represent_scalar(u'tag:yaml.org,2002:float', value)

    def represent_list(self, data):
        #pairs = (len(data) > 0 and isinstance(data, list))
        #if pairs:
        #    for item in data:
        #        if not isinstance(item, tuple) or len(item) != 2:
        #            pairs = False
        #            break
        #if not pairs:
            return self.represent_sequence(u'tag:yaml.org,2002:seq', data)
        #value = []
        #for item_key, item_value in data:
        #    value.append(self.represent_mapping(u'tag:yaml.org,2002:map',
        #        [(item_key, item_value)]))
        #return SequenceNode(u'tag:yaml.org,2002:pairs', value)

    def represent_dict(self, data):
        return self.represent_mapping(u'tag:yaml.org,2002:map', data)

    def represent_set(self, data):
        value = {}
        for key in data:
            value[key] = None
        return self.represent_mapping(u'tag:yaml.org,2002:set', value)

    def represent_date(self, data):
        value = unicode(data.isoformat())
        return self.represent_scalar(u'tag:yaml.org,2002:timestamp', value)

    def represent_datetime(self, data):
        value = unicode(data.isoformat(' '))
        return self.represent_scalar(u'tag:yaml.org,2002:timestamp', value)

    def represent_yaml_object(self, tag, data, cls, flow_style=None):
        if hasattr(data, '__getstate__'):
            state = data.__getstate__()
        else:
            state = data.__dict__.copy()
        return self.represent_mapping(tag, state, flow_style=flow_style)

    def represent_undefined(self, data):
        raise RepresenterError("cannot represent an object: %s" % data)

SafeRepresenter.add_representer(type(None),
        SafeRepresenter.represent_none)

SafeRepresenter.add_representer(str,
        SafeRepresenter.represent_str)

SafeRepresenter.add_representer(unicode,
        SafeRepresenter.represent_unicode)

SafeRepresenter.add_representer(bool,
        SafeRepresenter.represent_bool)

SafeRepresenter.add_representer(int,
        SafeRepresenter.represent_int)

SafeRepresenter.add_representer(long,
        SafeRepresenter.represent_long)

SafeRepresenter.add_representer(float,
        SafeRepresenter.represent_float)

SafeRepresenter.add_representer(list,
        SafeRepresenter.represent_list)

SafeRepresenter.add_representer(tuple,
        SafeRepresenter.represent_list)

SafeRepresenter.add_representer(dict,
        SafeRepresenter.represent_dict)

SafeRepresenter.add_representer(set,
        SafeRepresenter.represent_set)

SafeRepresenter.add_representer(datetime.date,
        SafeRepresenter.represent_date)

SafeRepresenter.add_representer(datetime.datetime,
        SafeRepresenter.represent_datetime)

SafeRepresenter.add_representer(None,
        SafeRepresenter.represent_undefined)

class Representer(SafeRepresenter):

    def represent_str(self, data):
        tag = None
        style = None
        try:
            data = unicode(data, 'ascii')
            tag = u'tag:yaml.org,2002:str'
        except UnicodeDecodeError:
            try:
                data = unicode(data, 'utf-8')
                tag = u'tag:yaml.org,2002:python/str'
            except UnicodeDecodeError:
                data = data.encode('base64')
                tag = u'tag:yaml.org,2002:binary'
                style = '|'
        return self.represent_scalar(tag, data, style=style)

    def represent_unicode(self, data):
        tag = None
        try:
            data.encode('ascii')
            tag = u'tag:yaml.org,2002:python/unicode'
        except UnicodeEncodeError:
            tag = u'tag:yaml.org,2002:str'
        return self.represent_scalar(tag, data)

    def represent_long(self, data):
        tag = u'tag:yaml.org,2002:int'
        if int(data) is not data:
            tag = u'tag:yaml.org,2002:python/long'
        return self.represent_scalar(tag, unicode(data))

    def represent_complex(self, data):
        if data.imag == 0.0:
            data = u'%r' % data.real
        elif data.real == 0.0:
            data = u'%rj' % data.imag
        elif data.imag > 0:
            data = u'%r+%rj' % (data.real, data.imag)
        else:
            data = u'%r%rj' % (data.real, data.imag)
        return self.represent_scalar(u'tag:yaml.org,2002:python/complex', data)

    def represent_tuple(self, data):
        return self.represent_sequence(u'tag:yaml.org,2002:python/tuple', data)

    def represent_name(self, data):
        name = u'%s.%s' % (data.__module__, data.__name__)
        return self.represent_scalar(u'tag:yaml.org,2002:python/name:'+name, u'')

    def represent_module(self, data):
        return self.represent_scalar(
                u'tag:yaml.org,2002:python/module:'+data.__name__, u'')

    def represent_instance(self, data):
        # For instances of classic classes, we use __getinitargs__ and
        # __getstate__ to serialize the data.

        # If data.__getinitargs__ exists, the object must be reconstructed by
        # calling cls(**args), where args is a tuple returned by
        # __getinitargs__. Otherwise, the cls.__init__ method should never be
        # called and the class instance is created by instantiating a trivial
        # class and assigning to the instance's __class__ variable.

        # If data.__getstate__ exists, it returns the state of the object.
        # Otherwise, the state of the object is data.__dict__.

        # We produce either a !!python/object or !!python/object/new node.
        # If data.__getinitargs__ does not exist and state is a dictionary, we
        # produce a !!python/object node . Otherwise we produce a
        # !!python/object/new node.

        cls = data.__class__
        class_name = u'%s.%s' % (cls.__module__, cls.__name__)
        args = None
        state = None
        if hasattr(data, '__getinitargs__'):
            args = list(data.__getinitargs__())
        if hasattr(data, '__getstate__'):
            state = data.__getstate__()
        else:
            state = data.__dict__
        if args is None and isinstance(state, dict):
            return self.represent_mapping(
                    u'tag:yaml.org,2002:python/object:'+class_name, state)
        if isinstance(state, dict) and not state:
            return self.represent_sequence(
                    u'tag:yaml.org,2002:python/object/new:'+class_name, args)
        value = {}
        if args:
            value['args'] = args
        value['state'] = state
        return self.represent_mapping(
                u'tag:yaml.org,2002:python/object/new:'+class_name, value)

    def represent_object(self, data):
        # We use __reduce__ API to save the data. data.__reduce__ returns
        # a tuple of length 2-5:
        #   (function, args, state, listitems, dictitems)

        # For reconstructing, we calls function(*args), then set its state,
        # listitems, and dictitems if they are not None.

        # A special case is when function.__name__ == '__newobj__'. In this
        # case we create the object with args[0].__new__(*args).

        # Another special case is when __reduce__ returns a string - we don't
        # support it.

        # We produce a !!python/object, !!python/object/new or
        # !!python/object/apply node.

        cls = type(data)
        if cls in copy_reg.dispatch_table:
            reduce = copy_reg.dispatch_table[cls](data)
        elif hasattr(data, '__reduce_ex__'):
            reduce = data.__reduce_ex__(2)
        elif hasattr(data, '__reduce__'):
            reduce = data.__reduce__()
        else:
            raise RepresenterError("cannot represent object: %r" % data)
        reduce = (list(reduce)+[None]*5)[:5]
        function, args, state, listitems, dictitems = reduce
        args = list(args)
        if state is None:
            state = {}
        if listitems is not None:
            listitems = list(listitems)
        if dictitems is not None:
            dictitems = dict(dictitems)
        if function.__name__ == '__newobj__':
            function = args[0]
            args = args[1:]
            tag = u'tag:yaml.org,2002:python/object/new:'
            newobj = True
        else:
            tag = u'tag:yaml.org,2002:python/object/apply:'
            newobj = False
        function_name = u'%s.%s' % (function.__module__, function.__name__)
        if not args and not listitems and not dictitems \
                and isinstance(state, dict) and newobj:
            return self.represent_mapping(
                    u'tag:yaml.org,2002:python/object:'+function_name, state)
        if not listitems and not dictitems  \
                and isinstance(state, dict) and not state:
            return self.represent_sequence(tag+function_name, args)
        value = {}
        if args:
            value['args'] = args
        if state or not isinstance(state, dict):
            value['state'] = state
        if listitems:
            value['listitems'] = listitems
        if dictitems:
            value['dictitems'] = dictitems
        return self.represent_mapping(tag+function_name, value)

Representer.add_representer(str,
        Representer.represent_str)

Representer.add_representer(unicode,
        Representer.represent_unicode)

Representer.add_representer(long,
        Representer.represent_long)

Representer.add_representer(complex,
        Representer.represent_complex)

Representer.add_representer(tuple,
        Representer.represent_tuple)

Representer.add_representer(type,
        Representer.represent_name)

Representer.add_representer(types.ClassType,
        Representer.represent_name)

Representer.add_representer(types.FunctionType,
        Representer.represent_name)

Representer.add_representer(types.BuiltinFunctionType,
        Representer.represent_name)

Representer.add_representer(types.ModuleType,
        Representer.represent_module)

Representer.add_multi_representer(types.InstanceType,
        Representer.represent_instance)

Representer.add_multi_representer(object,
        Representer.represent_object)


########NEW FILE########
__FILENAME__ = resolver

__all__ = ['BaseResolver', 'Resolver']

from error import *
from nodes import *

import re

class ResolverError(YAMLError):
    pass

class BaseResolver(object):

    DEFAULT_SCALAR_TAG = u'tag:yaml.org,2002:str'
    DEFAULT_SEQUENCE_TAG = u'tag:yaml.org,2002:seq'
    DEFAULT_MAPPING_TAG = u'tag:yaml.org,2002:map'

    yaml_implicit_resolvers = {}
    yaml_path_resolvers = {}

    def __init__(self):
        self.resolver_exact_paths = []
        self.resolver_prefix_paths = []

    def add_implicit_resolver(cls, tag, regexp, first):
        if not 'yaml_implicit_resolvers' in cls.__dict__:
            cls.yaml_implicit_resolvers = cls.yaml_implicit_resolvers.copy()
        if first is None:
            first = [None]
        for ch in first:
            cls.yaml_implicit_resolvers.setdefault(ch, []).append((tag, regexp))
    add_implicit_resolver = classmethod(add_implicit_resolver)

    def add_path_resolver(cls, tag, path, kind=None):
        # Note: `add_path_resolver` is experimental.  The API could be changed.
        # `new_path` is a pattern that is matched against the path from the
        # root to the node that is being considered.  `node_path` elements are
        # tuples `(node_check, index_check)`.  `node_check` is a node class:
        # `ScalarNode`, `SequenceNode`, `MappingNode` or `None`.  `None`
        # matches any kind of a node.  `index_check` could be `None`, a boolean
        # value, a string value, or a number.  `None` and `False` match against
        # any _value_ of sequence and mapping nodes.  `True` matches against
        # any _key_ of a mapping node.  A string `index_check` matches against
        # a mapping value that corresponds to a scalar key which content is
        # equal to the `index_check` value.  An integer `index_check` matches
        # against a sequence value with the index equal to `index_check`.
        if not 'yaml_path_resolvers' in cls.__dict__:
            cls.yaml_path_resolvers = cls.yaml_path_resolvers.copy()
        new_path = []
        for element in path:
            if isinstance(element, (list, tuple)):
                if len(element) == 2:
                    node_check, index_check = element
                elif len(element) == 1:
                    node_check = element[0]
                    index_check = True
                else:
                    raise ResolverError("Invalid path element: %s" % element)
            else:
                node_check = None
                index_check = element
            if node_check is str:
                node_check = ScalarNode
            elif node_check is list:
                node_check = SequenceNode
            elif node_check is dict:
                node_check = MappingNode
            elif node_check not in [ScalarNode, SequenceNode, MappingNode]  \
                    and not isinstance(node_check, basestring)  \
                    and node_check is not None:
                raise ResolverError("Invalid node checker: %s" % node_check)
            if not isinstance(index_check, (basestring, int))   \
                    and index_check is not None:
                raise ResolverError("Invalid index checker: %s" % index_check)
            new_path.append((node_check, index_check))
        if kind is str:
            kind = ScalarNode
        elif kind is list:
            kind = SequenceNode
        elif kind is dict:
            kind = MappingNode
        elif kind not in [ScalarNode, SequenceNode, MappingNode]    \
                and kind is not None:
            raise ResolverError("Invalid node kind: %s" % kind)
        cls.yaml_path_resolvers[tuple(new_path), kind] = tag
    add_path_resolver = classmethod(add_path_resolver)

    def descend_resolver(self, current_node, current_index):
        if not self.yaml_path_resolvers:
            return
        exact_paths = {}
        prefix_paths = []
        if current_node:
            depth = len(self.resolver_prefix_paths)
            for path, kind in self.resolver_prefix_paths[-1]:
                if self.check_resolver_prefix(depth, path, kind,
                        current_node, current_index):
                    if len(path) > depth:
                        prefix_paths.append((path, kind))
                    else:
                        exact_paths[kind] = self.yaml_path_resolvers[path, kind]
        else:
            for path, kind in self.yaml_path_resolvers:
                if not path:
                    exact_paths[kind] = self.yaml_path_resolvers[path, kind]
                else:
                    prefix_paths.append((path, kind))
        self.resolver_exact_paths.append(exact_paths)
        self.resolver_prefix_paths.append(prefix_paths)

    def ascend_resolver(self):
        if not self.yaml_path_resolvers:
            return
        self.resolver_exact_paths.pop()
        self.resolver_prefix_paths.pop()

    def check_resolver_prefix(self, depth, path, kind,
            current_node, current_index):
        node_check, index_check = path[depth-1]
        if isinstance(node_check, basestring):
            if current_node.tag != node_check:
                return
        elif node_check is not None:
            if not isinstance(current_node, node_check):
                return
        if index_check is True and current_index is not None:
            return
        if (index_check is False or index_check is None)    \
                and current_index is None:
            return
        if isinstance(index_check, basestring):
            if not (isinstance(current_index, ScalarNode)
                    and index_check == current_index.value):
                return
        elif isinstance(index_check, int) and not isinstance(index_check, bool):
            if index_check != current_index:
                return
        return True

    def resolve(self, kind, value, implicit):
        if kind is ScalarNode and implicit[0]:
            if value == u'':
                resolvers = self.yaml_implicit_resolvers.get(u'', [])
            else:
                resolvers = self.yaml_implicit_resolvers.get(value[0], [])
            resolvers += self.yaml_implicit_resolvers.get(None, [])
            for tag, regexp in resolvers:
                if regexp.match(value):
                    return tag
            implicit = implicit[1]
        if self.yaml_path_resolvers:
            exact_paths = self.resolver_exact_paths[-1]
            if kind in exact_paths:
                return exact_paths[kind]
            if None in exact_paths:
                return exact_paths[None]
        if kind is ScalarNode:
            return self.DEFAULT_SCALAR_TAG
        elif kind is SequenceNode:
            return self.DEFAULT_SEQUENCE_TAG
        elif kind is MappingNode:
            return self.DEFAULT_MAPPING_TAG

class Resolver(BaseResolver):
    pass

Resolver.add_implicit_resolver(
        u'tag:yaml.org,2002:bool',
        re.compile(ur'''^(?:yes|Yes|YES|no|No|NO
                    |true|True|TRUE|false|False|FALSE
                    |on|On|ON|off|Off|OFF)$''', re.X),
        list(u'yYnNtTfFoO'))

Resolver.add_implicit_resolver(
        u'tag:yaml.org,2002:float',
        re.compile(ur'''^(?:[-+]?(?:[0-9][0-9_]*)\.[0-9_]*(?:[eE][-+][0-9]+)?
                    |\.[0-9_]+(?:[eE][-+][0-9]+)?
                    |[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*
                    |[-+]?\.(?:inf|Inf|INF)
                    |\.(?:nan|NaN|NAN))$''', re.X),
        list(u'-+0123456789.'))

Resolver.add_implicit_resolver(
        u'tag:yaml.org,2002:int',
        re.compile(ur'''^(?:[-+]?0b[0-1_]+
                    |[-+]?0[0-7_]+
                    |[-+]?(?:0|[1-9][0-9_]*)
                    |[-+]?0x[0-9a-fA-F_]+
                    |[-+]?[1-9][0-9_]*(?::[0-5]?[0-9])+)$''', re.X),
        list(u'-+0123456789'))

Resolver.add_implicit_resolver(
        u'tag:yaml.org,2002:merge',
        re.compile(ur'^(?:<<)$'),
        [u'<'])

Resolver.add_implicit_resolver(
        u'tag:yaml.org,2002:null',
        re.compile(ur'''^(?: ~
                    |null|Null|NULL
                    | )$''', re.X),
        [u'~', u'n', u'N', u''])

Resolver.add_implicit_resolver(
        u'tag:yaml.org,2002:timestamp',
        re.compile(ur'''^(?:[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]
                    |[0-9][0-9][0-9][0-9] -[0-9][0-9]? -[0-9][0-9]?
                     (?:[Tt]|[ \t]+)[0-9][0-9]?
                     :[0-9][0-9] :[0-9][0-9] (?:\.[0-9]*)?
                     (?:[ \t]*(?:Z|[-+][0-9][0-9]?(?::[0-9][0-9])?))?)$''', re.X),
        list(u'0123456789'))

Resolver.add_implicit_resolver(
        u'tag:yaml.org,2002:value',
        re.compile(ur'^(?:=)$'),
        [u'='])

# The following resolver is only for documentation purposes. It cannot work
# because plain scalars cannot start with '!', '&', or '*'.
Resolver.add_implicit_resolver(
        u'tag:yaml.org,2002:yaml',
        re.compile(ur'^(?:!|&|\*)$'),
        list(u'!&*'))


########NEW FILE########
__FILENAME__ = scanner

# Scanner produces tokens of the following types:
# STREAM-START
# STREAM-END
# DIRECTIVE(name, value)
# DOCUMENT-START
# DOCUMENT-END
# BLOCK-SEQUENCE-START
# BLOCK-MAPPING-START
# BLOCK-END
# FLOW-SEQUENCE-START
# FLOW-MAPPING-START
# FLOW-SEQUENCE-END
# FLOW-MAPPING-END
# BLOCK-ENTRY
# FLOW-ENTRY
# KEY
# VALUE
# ALIAS(value)
# ANCHOR(value)
# TAG(value)
# SCALAR(value, plain, style)
#
# Read comments in the Scanner code for more details.
#

__all__ = ['Scanner', 'ScannerError']

from error import MarkedYAMLError
from tokens import *

class ScannerError(MarkedYAMLError):
    pass

class SimpleKey(object):
    # See below simple keys treatment.

    def __init__(self, token_number, required, index, line, column, mark):
        self.token_number = token_number
        self.required = required
        self.index = index
        self.line = line
        self.column = column
        self.mark = mark

class Scanner(object):

    def __init__(self):
        """Initialize the scanner."""
        # It is assumed that Scanner and Reader will have a common descendant.
        # Reader do the dirty work of checking for BOM and converting the
        # input data to Unicode. It also adds NUL to the end.
        #
        # Reader supports the following methods
        #   self.peek(i=0)       # peek the next i-th character
        #   self.prefix(l=1)     # peek the next l characters
        #   self.forward(l=1)    # read the next l characters and move the pointer.

        # Had we reached the end of the stream?
        self.done = False

        # The number of unclosed '{' and '['. `flow_level == 0` means block
        # context.
        self.flow_level = 0

        # List of processed tokens that are not yet emitted.
        self.tokens = []

        # Add the STREAM-START token.
        self.fetch_stream_start()

        # Number of tokens that were emitted through the `get_token` method.
        self.tokens_taken = 0

        # The current indentation level.
        self.indent = -1

        # Past indentation levels.
        self.indents = []

        # Variables related to simple keys treatment.

        # A simple key is a key that is not denoted by the '?' indicator.
        # Example of simple keys:
        #   ---
        #   block simple key: value
        #   ? not a simple key:
        #   : { flow simple key: value }
        # We emit the KEY token before all keys, so when we find a potential
        # simple key, we try to locate the corresponding ':' indicator.
        # Simple keys should be limited to a single line and 1024 characters.

        # Can a simple key start at the current position? A simple key may
        # start:
        # - at the beginning of the line, not counting indentation spaces
        #       (in block context),
        # - after '{', '[', ',' (in the flow context),
        # - after '?', ':', '-' (in the block context).
        # In the block context, this flag also signifies if a block collection
        # may start at the current position.
        self.allow_simple_key = True

        # Keep track of possible simple keys. This is a dictionary. The key
        # is `flow_level`; there can be no more that one possible simple key
        # for each level. The value is a SimpleKey record:
        #   (token_number, required, index, line, column, mark)
        # A simple key may start with ALIAS, ANCHOR, TAG, SCALAR(flow),
        # '[', or '{' tokens.
        self.possible_simple_keys = {}

    # Public methods.

    def check_token(self, *choices):
        # Check if the next token is one of the given types.
        while self.need_more_tokens():
            self.fetch_more_tokens()
        if self.tokens:
            if not choices:
                return True
            for choice in choices:
                if isinstance(self.tokens[0], choice):
                    return True
        return False

    def peek_token(self):
        # Return the next token, but do not delete if from the queue.
        while self.need_more_tokens():
            self.fetch_more_tokens()
        if self.tokens:
            return self.tokens[0]

    def get_token(self):
        # Return the next token.
        while self.need_more_tokens():
            self.fetch_more_tokens()
        if self.tokens:
            self.tokens_taken += 1
            return self.tokens.pop(0)

    # Private methods.

    def need_more_tokens(self):
        if self.done:
            return False
        if not self.tokens:
            return True
        # The current token may be a potential simple key, so we
        # need to look further.
        self.stale_possible_simple_keys()
        if self.next_possible_simple_key() == self.tokens_taken:
            return True

    def fetch_more_tokens(self):

        # Eat whitespaces and comments until we reach the next token.
        self.scan_to_next_token()

        # Remove obsolete possible simple keys.
        self.stale_possible_simple_keys()

        # Compare the current indentation and column. It may add some tokens
        # and decrease the current indentation level.
        self.unwind_indent(self.column)

        # Peek the next character.
        ch = self.peek()

        # Is it the end of stream?
        if ch == u'\0':
            return self.fetch_stream_end()

        # Is it a directive?
        if ch == u'%' and self.check_directive():
            return self.fetch_directive()

        # Is it the document start?
        if ch == u'-' and self.check_document_start():
            return self.fetch_document_start()

        # Is it the document end?
        if ch == u'.' and self.check_document_end():
            return self.fetch_document_end()

        # TODO: support for BOM within a stream.
        #if ch == u'\uFEFF':
        #    return self.fetch_bom()    <-- issue BOMToken

        # Note: the order of the following checks is NOT significant.

        # Is it the flow sequence start indicator?
        if ch == u'[':
            return self.fetch_flow_sequence_start()

        # Is it the flow mapping start indicator?
        if ch == u'{':
            return self.fetch_flow_mapping_start()

        # Is it the flow sequence end indicator?
        if ch == u']':
            return self.fetch_flow_sequence_end()

        # Is it the flow mapping end indicator?
        if ch == u'}':
            return self.fetch_flow_mapping_end()

        # Is it the flow entry indicator?
        if ch == u',':
            return self.fetch_flow_entry()

        # Is it the block entry indicator?
        if ch == u'-' and self.check_block_entry():
            return self.fetch_block_entry()

        # Is it the key indicator?
        if ch == u'?' and self.check_key():
            return self.fetch_key()

        # Is it the value indicator?
        if ch == u':' and self.check_value():
            return self.fetch_value()

        # Is it an alias?
        if ch == u'*':
            return self.fetch_alias()

        # Is it an anchor?
        if ch == u'&':
            return self.fetch_anchor()

        # Is it a tag?
        if ch == u'!':
            return self.fetch_tag()

        # Is it a literal scalar?
        if ch == u'|' and not self.flow_level:
            return self.fetch_literal()

        # Is it a folded scalar?
        if ch == u'>' and not self.flow_level:
            return self.fetch_folded()

        # Is it a single quoted scalar?
        if ch == u'\'':
            return self.fetch_single()

        # Is it a double quoted scalar?
        if ch == u'\"':
            return self.fetch_double()

        # It must be a plain scalar then.
        if self.check_plain():
            return self.fetch_plain()

        # No? It's an error. Let's produce a nice error message.
        raise ScannerError("while scanning for the next token", None,
                "found character %r that cannot start any token"
                % ch.encode('utf-8'), self.get_mark())

    # Simple keys treatment.

    def next_possible_simple_key(self):
        # Return the number of the nearest possible simple key. Actually we
        # don't need to loop through the whole dictionary. We may replace it
        # with the following code:
        #   if not self.possible_simple_keys:
        #       return None
        #   return self.possible_simple_keys[
        #           min(self.possible_simple_keys.keys())].token_number
        min_token_number = None
        for level in self.possible_simple_keys:
            key = self.possible_simple_keys[level]
            if min_token_number is None or key.token_number < min_token_number:
                min_token_number = key.token_number
        return min_token_number

    def stale_possible_simple_keys(self):
        # Remove entries that are no longer possible simple keys. According to
        # the YAML specification, simple keys
        # - should be limited to a single line,
        # - should be no longer than 1024 characters.
        # Disabling this procedure will allow simple keys of any length and
        # height (may cause problems if indentation is broken though).
        for level in self.possible_simple_keys.keys():
            key = self.possible_simple_keys[level]
            if key.line != self.line  \
                    or self.index-key.index > 1024:
                if key.required:
                    raise ScannerError("while scanning a simple key", key.mark,
                            "could not found expected ':'", self.get_mark())
                del self.possible_simple_keys[level]

    def save_possible_simple_key(self):
        # The next token may start a simple key. We check if it's possible
        # and save its position. This function is called for
        #   ALIAS, ANCHOR, TAG, SCALAR(flow), '[', and '{'.

        # Check if a simple key is required at the current position.
        required = not self.flow_level and self.indent == self.column

        # A simple key is required only if it is the first token in the current
        # line. Therefore it is always allowed.
        assert self.allow_simple_key or not required

        # The next token might be a simple key. Let's save it's number and
        # position.
        if self.allow_simple_key:
            self.remove_possible_simple_key()
            token_number = self.tokens_taken+len(self.tokens)
            key = SimpleKey(token_number, required,
                    self.index, self.line, self.column, self.get_mark())
            self.possible_simple_keys[self.flow_level] = key

    def remove_possible_simple_key(self):
        # Remove the saved possible key position at the current flow level.
        if self.flow_level in self.possible_simple_keys:
            key = self.possible_simple_keys[self.flow_level]
            
            if key.required:
                raise ScannerError("while scanning a simple key", key.mark,
                        "could not found expected ':'", self.get_mark())

            del self.possible_simple_keys[self.flow_level]

    # Indentation functions.

    def unwind_indent(self, column):

        ## In flow context, tokens should respect indentation.
        ## Actually the condition should be `self.indent >= column` according to
        ## the spec. But this condition will prohibit intuitively correct
        ## constructions such as
        ## key : {
        ## }
        #if self.flow_level and self.indent > column:
        #    raise ScannerError(None, None,
        #            "invalid intendation or unclosed '[' or '{'",
        #            self.get_mark())

        # In the flow context, indentation is ignored. We make the scanner less
        # restrictive then specification requires.
        if self.flow_level:
            return

        # In block context, we may need to issue the BLOCK-END tokens.
        while self.indent > column:
            mark = self.get_mark()
            self.indent = self.indents.pop()
            self.tokens.append(BlockEndToken(mark, mark))

    def add_indent(self, column):
        # Check if we need to increase indentation.
        if self.indent < column:
            self.indents.append(self.indent)
            self.indent = column
            return True
        return False

    # Fetchers.

    def fetch_stream_start(self):
        # We always add STREAM-START as the first token and STREAM-END as the
        # last token.

        # Read the token.
        mark = self.get_mark()
        
        # Add STREAM-START.
        self.tokens.append(StreamStartToken(mark, mark,
            encoding=self.encoding))
        

    def fetch_stream_end(self):

        # Set the current intendation to -1.
        self.unwind_indent(-1)

        # Reset simple keys.
        self.remove_possible_simple_key()
        self.allow_simple_key = False
        self.possible_simple_keys = {}

        # Read the token.
        mark = self.get_mark()
        
        # Add STREAM-END.
        self.tokens.append(StreamEndToken(mark, mark))

        # The steam is finished.
        self.done = True

    def fetch_directive(self):
        
        # Set the current intendation to -1.
        self.unwind_indent(-1)

        # Reset simple keys.
        self.remove_possible_simple_key()
        self.allow_simple_key = False

        # Scan and add DIRECTIVE.
        self.tokens.append(self.scan_directive())

    def fetch_document_start(self):
        self.fetch_document_indicator(DocumentStartToken)

    def fetch_document_end(self):
        self.fetch_document_indicator(DocumentEndToken)

    def fetch_document_indicator(self, TokenClass):

        # Set the current intendation to -1.
        self.unwind_indent(-1)

        # Reset simple keys. Note that there could not be a block collection
        # after '---'.
        self.remove_possible_simple_key()
        self.allow_simple_key = False

        # Add DOCUMENT-START or DOCUMENT-END.
        start_mark = self.get_mark()
        self.forward(3)
        end_mark = self.get_mark()
        self.tokens.append(TokenClass(start_mark, end_mark))

    def fetch_flow_sequence_start(self):
        self.fetch_flow_collection_start(FlowSequenceStartToken)

    def fetch_flow_mapping_start(self):
        self.fetch_flow_collection_start(FlowMappingStartToken)

    def fetch_flow_collection_start(self, TokenClass):

        # '[' and '{' may start a simple key.
        self.save_possible_simple_key()

        # Increase the flow level.
        self.flow_level += 1

        # Simple keys are allowed after '[' and '{'.
        self.allow_simple_key = True

        # Add FLOW-SEQUENCE-START or FLOW-MAPPING-START.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(TokenClass(start_mark, end_mark))

    def fetch_flow_sequence_end(self):
        self.fetch_flow_collection_end(FlowSequenceEndToken)

    def fetch_flow_mapping_end(self):
        self.fetch_flow_collection_end(FlowMappingEndToken)

    def fetch_flow_collection_end(self, TokenClass):

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Decrease the flow level.
        self.flow_level -= 1

        # No simple keys after ']' or '}'.
        self.allow_simple_key = False

        # Add FLOW-SEQUENCE-END or FLOW-MAPPING-END.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(TokenClass(start_mark, end_mark))

    def fetch_flow_entry(self):

        # Simple keys are allowed after ','.
        self.allow_simple_key = True

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Add FLOW-ENTRY.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(FlowEntryToken(start_mark, end_mark))

    def fetch_block_entry(self):

        # Block context needs additional checks.
        if not self.flow_level:

            # Are we allowed to start a new entry?
            if not self.allow_simple_key:
                raise ScannerError(None, None,
                        "sequence entries are not allowed here",
                        self.get_mark())

            # We may need to add BLOCK-SEQUENCE-START.
            if self.add_indent(self.column):
                mark = self.get_mark()
                self.tokens.append(BlockSequenceStartToken(mark, mark))

        # It's an error for the block entry to occur in the flow context,
        # but we let the parser detect this.
        else:
            pass

        # Simple keys are allowed after '-'.
        self.allow_simple_key = True

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Add BLOCK-ENTRY.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(BlockEntryToken(start_mark, end_mark))

    def fetch_key(self):
        
        # Block context needs additional checks.
        if not self.flow_level:

            # Are we allowed to start a key (not nessesary a simple)?
            if not self.allow_simple_key:
                raise ScannerError(None, None,
                        "mapping keys are not allowed here",
                        self.get_mark())

            # We may need to add BLOCK-MAPPING-START.
            if self.add_indent(self.column):
                mark = self.get_mark()
                self.tokens.append(BlockMappingStartToken(mark, mark))

        # Simple keys are allowed after '?' in the block context.
        self.allow_simple_key = not self.flow_level

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Add KEY.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(KeyToken(start_mark, end_mark))

    def fetch_value(self):

        # Do we determine a simple key?
        if self.flow_level in self.possible_simple_keys:

            # Add KEY.
            key = self.possible_simple_keys[self.flow_level]
            del self.possible_simple_keys[self.flow_level]
            self.tokens.insert(key.token_number-self.tokens_taken,
                    KeyToken(key.mark, key.mark))

            # If this key starts a new block mapping, we need to add
            # BLOCK-MAPPING-START.
            if not self.flow_level:
                if self.add_indent(key.column):
                    self.tokens.insert(key.token_number-self.tokens_taken,
                            BlockMappingStartToken(key.mark, key.mark))

            # There cannot be two simple keys one after another.
            self.allow_simple_key = False

        # It must be a part of a complex key.
        else:
            
            # Block context needs additional checks.
            # (Do we really need them? They will be catched by the parser
            # anyway.)
            if not self.flow_level:

                # We are allowed to start a complex value if and only if
                # we can start a simple key.
                if not self.allow_simple_key:
                    raise ScannerError(None, None,
                            "mapping values are not allowed here",
                            self.get_mark())

            # If this value starts a new block mapping, we need to add
            # BLOCK-MAPPING-START.  It will be detected as an error later by
            # the parser.
            if not self.flow_level:
                if self.add_indent(self.column):
                    mark = self.get_mark()
                    self.tokens.append(BlockMappingStartToken(mark, mark))

            # Simple keys are allowed after ':' in the block context.
            self.allow_simple_key = not self.flow_level

            # Reset possible simple key on the current level.
            self.remove_possible_simple_key()

        # Add VALUE.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(ValueToken(start_mark, end_mark))

    def fetch_alias(self):

        # ALIAS could be a simple key.
        self.save_possible_simple_key()

        # No simple keys after ALIAS.
        self.allow_simple_key = False

        # Scan and add ALIAS.
        self.tokens.append(self.scan_anchor(AliasToken))

    def fetch_anchor(self):

        # ANCHOR could start a simple key.
        self.save_possible_simple_key()

        # No simple keys after ANCHOR.
        self.allow_simple_key = False

        # Scan and add ANCHOR.
        self.tokens.append(self.scan_anchor(AnchorToken))

    def fetch_tag(self):

        # TAG could start a simple key.
        self.save_possible_simple_key()

        # No simple keys after TAG.
        self.allow_simple_key = False

        # Scan and add TAG.
        self.tokens.append(self.scan_tag())

    def fetch_literal(self):
        self.fetch_block_scalar(style='|')

    def fetch_folded(self):
        self.fetch_block_scalar(style='>')

    def fetch_block_scalar(self, style):

        # A simple key may follow a block scalar.
        self.allow_simple_key = True

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Scan and add SCALAR.
        self.tokens.append(self.scan_block_scalar(style))

    def fetch_single(self):
        self.fetch_flow_scalar(style='\'')

    def fetch_double(self):
        self.fetch_flow_scalar(style='"')

    def fetch_flow_scalar(self, style):

        # A flow scalar could be a simple key.
        self.save_possible_simple_key()

        # No simple keys after flow scalars.
        self.allow_simple_key = False

        # Scan and add SCALAR.
        self.tokens.append(self.scan_flow_scalar(style))

    def fetch_plain(self):

        # A plain scalar could be a simple key.
        self.save_possible_simple_key()

        # No simple keys after plain scalars. But note that `scan_plain` will
        # change this flag if the scan is finished at the beginning of the
        # line.
        self.allow_simple_key = False

        # Scan and add SCALAR. May change `allow_simple_key`.
        self.tokens.append(self.scan_plain())

    # Checkers.

    def check_directive(self):

        # DIRECTIVE:        ^ '%' ...
        # The '%' indicator is already checked.
        if self.column == 0:
            return True

    def check_document_start(self):

        # DOCUMENT-START:   ^ '---' (' '|'\n')
        if self.column == 0:
            if self.prefix(3) == u'---'  \
                    and self.peek(3) in u'\0 \t\r\n\x85\u2028\u2029':
                return True

    def check_document_end(self):

        # DOCUMENT-END:     ^ '...' (' '|'\n')
        if self.column == 0:
            if self.prefix(3) == u'...'  \
                    and self.peek(3) in u'\0 \t\r\n\x85\u2028\u2029':
                return True

    def check_block_entry(self):

        # BLOCK-ENTRY:      '-' (' '|'\n')
        return self.peek(1) in u'\0 \t\r\n\x85\u2028\u2029'

    def check_key(self):

        # KEY(flow context):    '?'
        if self.flow_level:
            return True

        # KEY(block context):   '?' (' '|'\n')
        else:
            return self.peek(1) in u'\0 \t\r\n\x85\u2028\u2029'

    def check_value(self):

        # VALUE(flow context):  ':'
        if self.flow_level:
            return True

        # VALUE(block context): ':' (' '|'\n')
        else:
            return self.peek(1) in u'\0 \t\r\n\x85\u2028\u2029'

    def check_plain(self):

        # A plain scalar may start with any non-space character except:
        #   '-', '?', ':', ',', '[', ']', '{', '}',
        #   '#', '&', '*', '!', '|', '>', '\'', '\"',
        #   '%', '@', '`'.
        #
        # It may also start with
        #   '-', '?', ':'
        # if it is followed by a non-space character.
        #
        # Note that we limit the last rule to the block context (except the
        # '-' character) because we want the flow context to be space
        # independent.
        ch = self.peek()
        return ch not in u'\0 \t\r\n\x85\u2028\u2029-?:,[]{}#&*!|>\'\"%@`'  \
                or (self.peek(1) not in u'\0 \t\r\n\x85\u2028\u2029'
                        and (ch == u'-' or (not self.flow_level and ch in u'?:')))

    # Scanners.

    def scan_to_next_token(self):
        # We ignore spaces, line breaks and comments.
        # If we find a line break in the block context, we set the flag
        # `allow_simple_key` on.
        # The byte order mark is stripped if it's the first character in the
        # stream. We do not yet support BOM inside the stream as the
        # specification requires. Any such mark will be considered as a part
        # of the document.
        #
        # TODO: We need to make tab handling rules more sane. A good rule is
        #   Tabs cannot precede tokens
        #   BLOCK-SEQUENCE-START, BLOCK-MAPPING-START, BLOCK-END,
        #   KEY(block), VALUE(block), BLOCK-ENTRY
        # So the checking code is
        #   if <TAB>:
        #       self.allow_simple_keys = False
        # We also need to add the check for `allow_simple_keys == True` to
        # `unwind_indent` before issuing BLOCK-END.
        # Scanners for block, flow, and plain scalars need to be modified.

        if self.index == 0 and self.peek() == u'\uFEFF':
            self.forward()
        found = False
        while not found:
            while self.peek() == u' ':
                self.forward()
            if self.peek() == u'#':
                while self.peek() not in u'\0\r\n\x85\u2028\u2029':
                    self.forward()
            if self.scan_line_break():
                if not self.flow_level:
                    self.allow_simple_key = True
            else:
                found = True

    def scan_directive(self):
        # See the specification for details.
        start_mark = self.get_mark()
        self.forward()
        name = self.scan_directive_name(start_mark)
        value = None
        if name == u'YAML':
            value = self.scan_yaml_directive_value(start_mark)
            end_mark = self.get_mark()
        elif name == u'TAG':
            value = self.scan_tag_directive_value(start_mark)
            end_mark = self.get_mark()
        else:
            end_mark = self.get_mark()
            while self.peek() not in u'\0\r\n\x85\u2028\u2029':
                self.forward()
        self.scan_directive_ignored_line(start_mark)
        return DirectiveToken(name, value, start_mark, end_mark)

    def scan_directive_name(self, start_mark):
        # See the specification for details.
        length = 0
        ch = self.peek(length)
        while u'0' <= ch <= u'9' or u'A' <= ch <= u'Z' or u'a' <= ch <= u'z'    \
                or ch in u'-_':
            length += 1
            ch = self.peek(length)
        if not length:
            raise ScannerError("while scanning a directive", start_mark,
                    "expected alphabetic or numeric character, but found %r"
                    % ch.encode('utf-8'), self.get_mark())
        value = self.prefix(length)
        self.forward(length)
        ch = self.peek()
        if ch not in u'\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected alphabetic or numeric character, but found %r"
                    % ch.encode('utf-8'), self.get_mark())
        return value

    def scan_yaml_directive_value(self, start_mark):
        # See the specification for details.
        while self.peek() == u' ':
            self.forward()
        major = self.scan_yaml_directive_number(start_mark)
        if self.peek() != '.':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected a digit or '.', but found %r"
                    % self.peek().encode('utf-8'),
                    self.get_mark())
        self.forward()
        minor = self.scan_yaml_directive_number(start_mark)
        if self.peek() not in u'\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected a digit or ' ', but found %r"
                    % self.peek().encode('utf-8'),
                    self.get_mark())
        return (major, minor)

    def scan_yaml_directive_number(self, start_mark):
        # See the specification for details.
        ch = self.peek()
        if not (u'0' <= ch <= u'9'):
            raise ScannerError("while scanning a directive", start_mark,
                    "expected a digit, but found %r" % ch.encode('utf-8'),
                    self.get_mark())
        length = 0
        while u'0' <= self.peek(length) <= u'9':
            length += 1
        value = int(self.prefix(length))
        self.forward(length)
        return value

    def scan_tag_directive_value(self, start_mark):
        # See the specification for details.
        while self.peek() == u' ':
            self.forward()
        handle = self.scan_tag_directive_handle(start_mark)
        while self.peek() == u' ':
            self.forward()
        prefix = self.scan_tag_directive_prefix(start_mark)
        return (handle, prefix)

    def scan_tag_directive_handle(self, start_mark):
        # See the specification for details.
        value = self.scan_tag_handle('directive', start_mark)
        ch = self.peek()
        if ch != u' ':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected ' ', but found %r" % ch.encode('utf-8'),
                    self.get_mark())
        return value

    def scan_tag_directive_prefix(self, start_mark):
        # See the specification for details.
        value = self.scan_tag_uri('directive', start_mark)
        ch = self.peek()
        if ch not in u'\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected ' ', but found %r" % ch.encode('utf-8'),
                    self.get_mark())
        return value

    def scan_directive_ignored_line(self, start_mark):
        # See the specification for details.
        while self.peek() == u' ':
            self.forward()
        if self.peek() == u'#':
            while self.peek() not in u'\0\r\n\x85\u2028\u2029':
                self.forward()
        ch = self.peek()
        if ch not in u'\0\r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected a comment or a line break, but found %r"
                        % ch.encode('utf-8'), self.get_mark())
        self.scan_line_break()

    def scan_anchor(self, TokenClass):
        # The specification does not restrict characters for anchors and
        # aliases. This may lead to problems, for instance, the document:
        #   [ *alias, value ]
        # can be interpteted in two ways, as
        #   [ "value" ]
        # and
        #   [ *alias , "value" ]
        # Therefore we restrict aliases to numbers and ASCII letters.
        start_mark = self.get_mark()
        indicator = self.peek()
        if indicator == u'*':
            name = 'alias'
        else:
            name = 'anchor'
        self.forward()
        length = 0
        ch = self.peek(length)
        while u'0' <= ch <= u'9' or u'A' <= ch <= u'Z' or u'a' <= ch <= u'z'    \
                or ch in u'-_':
            length += 1
            ch = self.peek(length)
        if not length:
            raise ScannerError("while scanning an %s" % name, start_mark,
                    "expected alphabetic or numeric character, but found %r"
                    % ch.encode('utf-8'), self.get_mark())
        value = self.prefix(length)
        self.forward(length)
        ch = self.peek()
        if ch not in u'\0 \t\r\n\x85\u2028\u2029?:,]}%@`':
            raise ScannerError("while scanning an %s" % name, start_mark,
                    "expected alphabetic or numeric character, but found %r"
                    % ch.encode('utf-8'), self.get_mark())
        end_mark = self.get_mark()
        return TokenClass(value, start_mark, end_mark)

    def scan_tag(self):
        # See the specification for details.
        start_mark = self.get_mark()
        ch = self.peek(1)
        if ch == u'<':
            handle = None
            self.forward(2)
            suffix = self.scan_tag_uri('tag', start_mark)
            if self.peek() != u'>':
                raise ScannerError("while parsing a tag", start_mark,
                        "expected '>', but found %r" % self.peek().encode('utf-8'),
                        self.get_mark())
            self.forward()
        elif ch in u'\0 \t\r\n\x85\u2028\u2029':
            handle = None
            suffix = u'!'
            self.forward()
        else:
            length = 1
            use_handle = False
            while ch not in u'\0 \r\n\x85\u2028\u2029':
                if ch == u'!':
                    use_handle = True
                    break
                length += 1
                ch = self.peek(length)
            handle = u'!'
            if use_handle:
                handle = self.scan_tag_handle('tag', start_mark)
            else:
                handle = u'!'
                self.forward()
            suffix = self.scan_tag_uri('tag', start_mark)
        ch = self.peek()
        if ch not in u'\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a tag", start_mark,
                    "expected ' ', but found %r" % ch.encode('utf-8'),
                    self.get_mark())
        value = (handle, suffix)
        end_mark = self.get_mark()
        return TagToken(value, start_mark, end_mark)

    def scan_block_scalar(self, style):
        # See the specification for details.

        if style == '>':
            folded = True
        else:
            folded = False

        chunks = []
        start_mark = self.get_mark()

        # Scan the header.
        self.forward()
        chomping, increment = self.scan_block_scalar_indicators(start_mark)
        self.scan_block_scalar_ignored_line(start_mark)

        # Determine the indentation level and go to the first non-empty line.
        min_indent = self.indent+1
        if min_indent < 1:
            min_indent = 1
        if increment is None:
            breaks, max_indent, end_mark = self.scan_block_scalar_indentation()
            indent = max(min_indent, max_indent)
        else:
            indent = min_indent+increment-1
            breaks, end_mark = self.scan_block_scalar_breaks(indent)
        line_break = u''

        # Scan the inner part of the block scalar.
        while self.column == indent and self.peek() != u'\0':
            chunks.extend(breaks)
            leading_non_space = self.peek() not in u' \t'
            length = 0
            while self.peek(length) not in u'\0\r\n\x85\u2028\u2029':
                length += 1
            chunks.append(self.prefix(length))
            self.forward(length)
            line_break = self.scan_line_break()
            breaks, end_mark = self.scan_block_scalar_breaks(indent)
            if self.column == indent and self.peek() != u'\0':

                # Unfortunately, folding rules are ambiguous.
                #
                # This is the folding according to the specification:
                
                if folded and line_break == u'\n'   \
                        and leading_non_space and self.peek() not in u' \t':
                    if not breaks:
                        chunks.append(u' ')
                else:
                    chunks.append(line_break)
                
                # This is Clark Evans's interpretation (also in the spec
                # examples):
                #
                #if folded and line_break == u'\n':
                #    if not breaks:
                #        if self.peek() not in ' \t':
                #            chunks.append(u' ')
                #        else:
                #            chunks.append(line_break)
                #else:
                #    chunks.append(line_break)
            else:
                break

        # Chomp the tail.
        if chomping is not False:
            chunks.append(line_break)
        if chomping is True:
            chunks.extend(breaks)

        # We are done.
        return ScalarToken(u''.join(chunks), False, start_mark, end_mark,
                style)

    def scan_block_scalar_indicators(self, start_mark):
        # See the specification for details.
        chomping = None
        increment = None
        ch = self.peek()
        if ch in u'+-':
            if ch == '+':
                chomping = True
            else:
                chomping = False
            self.forward()
            ch = self.peek()
            if ch in u'0123456789':
                increment = int(ch)
                if increment == 0:
                    raise ScannerError("while scanning a block scalar", start_mark,
                            "expected indentation indicator in the range 1-9, but found 0",
                            self.get_mark())
                self.forward()
        elif ch in u'0123456789':
            increment = int(ch)
            if increment == 0:
                raise ScannerError("while scanning a block scalar", start_mark,
                        "expected indentation indicator in the range 1-9, but found 0",
                        self.get_mark())
            self.forward()
            ch = self.peek()
            if ch in u'+-':
                if ch == '+':
                    chomping = True
                else:
                    chomping = False
                self.forward()
        ch = self.peek()
        if ch not in u'\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a block scalar", start_mark,
                    "expected chomping or indentation indicators, but found %r"
                        % ch.encode('utf-8'), self.get_mark())
        return chomping, increment

    def scan_block_scalar_ignored_line(self, start_mark):
        # See the specification for details.
        while self.peek() == u' ':
            self.forward()
        if self.peek() == u'#':
            while self.peek() not in u'\0\r\n\x85\u2028\u2029':
                self.forward()
        ch = self.peek()
        if ch not in u'\0\r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a block scalar", start_mark,
                    "expected a comment or a line break, but found %r"
                        % ch.encode('utf-8'), self.get_mark())
        self.scan_line_break()

    def scan_block_scalar_indentation(self):
        # See the specification for details.
        chunks = []
        max_indent = 0
        end_mark = self.get_mark()
        while self.peek() in u' \r\n\x85\u2028\u2029':
            if self.peek() != u' ':
                chunks.append(self.scan_line_break())
                end_mark = self.get_mark()
            else:
                self.forward()
                if self.column > max_indent:
                    max_indent = self.column
        return chunks, max_indent, end_mark

    def scan_block_scalar_breaks(self, indent):
        # See the specification for details.
        chunks = []
        end_mark = self.get_mark()
        while self.column < indent and self.peek() == u' ':
            self.forward()
        while self.peek() in u'\r\n\x85\u2028\u2029':
            chunks.append(self.scan_line_break())
            end_mark = self.get_mark()
            while self.column < indent and self.peek() == u' ':
                self.forward()
        return chunks, end_mark

    def scan_flow_scalar(self, style):
        # See the specification for details.
        # Note that we loose indentation rules for quoted scalars. Quoted
        # scalars don't need to adhere indentation because " and ' clearly
        # mark the beginning and the end of them. Therefore we are less
        # restrictive then the specification requires. We only need to check
        # that document separators are not included in scalars.
        if style == '"':
            double = True
        else:
            double = False
        chunks = []
        start_mark = self.get_mark()
        quote = self.peek()
        self.forward()
        chunks.extend(self.scan_flow_scalar_non_spaces(double, start_mark))
        while self.peek() != quote:
            chunks.extend(self.scan_flow_scalar_spaces(double, start_mark))
            chunks.extend(self.scan_flow_scalar_non_spaces(double, start_mark))
        self.forward()
        end_mark = self.get_mark()
        return ScalarToken(u''.join(chunks), False, start_mark, end_mark,
                style)

    ESCAPE_REPLACEMENTS = {
        u'0':   u'\0',
        u'a':   u'\x07',
        u'b':   u'\x08',
        u't':   u'\x09',
        u'\t':  u'\x09',
        u'n':   u'\x0A',
        u'v':   u'\x0B',
        u'f':   u'\x0C',
        u'r':   u'\x0D',
        u'e':   u'\x1B',
        u' ':   u'\x20',
        u'\"':  u'\"',
        u'\\':  u'\\',
        u'N':   u'\x85',
        u'_':   u'\xA0',
        u'L':   u'\u2028',
        u'P':   u'\u2029',
    }

    ESCAPE_CODES = {
        u'x':   2,
        u'u':   4,
        u'U':   8,
    }

    def scan_flow_scalar_non_spaces(self, double, start_mark):
        # See the specification for details.
        chunks = []
        while True:
            length = 0
            while self.peek(length) not in u'\'\"\\\0 \t\r\n\x85\u2028\u2029':
                length += 1
            if length:
                chunks.append(self.prefix(length))
                self.forward(length)
            ch = self.peek()
            if not double and ch == u'\'' and self.peek(1) == u'\'':
                chunks.append(u'\'')
                self.forward(2)
            elif (double and ch == u'\'') or (not double and ch in u'\"\\'):
                chunks.append(ch)
                self.forward()
            elif double and ch == u'\\':
                self.forward()
                ch = self.peek()
                if ch in self.ESCAPE_REPLACEMENTS:
                    chunks.append(self.ESCAPE_REPLACEMENTS[ch])
                    self.forward()
                elif ch in self.ESCAPE_CODES:
                    length = self.ESCAPE_CODES[ch]
                    self.forward()
                    for k in range(length):
                        if self.peek(k) not in u'0123456789ABCDEFabcdef':
                            raise ScannerError("while scanning a double-quoted scalar", start_mark,
                                    "expected escape sequence of %d hexdecimal numbers, but found %r" %
                                        (length, self.peek(k).encode('utf-8')), self.get_mark())
                    code = int(self.prefix(length), 16)
                    chunks.append(unichr(code))
                    self.forward(length)
                elif ch in u'\r\n\x85\u2028\u2029':
                    self.scan_line_break()
                    chunks.extend(self.scan_flow_scalar_breaks(double, start_mark))
                else:
                    raise ScannerError("while scanning a double-quoted scalar", start_mark,
                            "found unknown escape character %r" % ch.encode('utf-8'), self.get_mark())
            else:
                return chunks

    def scan_flow_scalar_spaces(self, double, start_mark):
        # See the specification for details.
        chunks = []
        length = 0
        while self.peek(length) in u' \t':
            length += 1
        whitespaces = self.prefix(length)
        self.forward(length)
        ch = self.peek()
        if ch == u'\0':
            raise ScannerError("while scanning a quoted scalar", start_mark,
                    "found unexpected end of stream", self.get_mark())
        elif ch in u'\r\n\x85\u2028\u2029':
            line_break = self.scan_line_break()
            breaks = self.scan_flow_scalar_breaks(double, start_mark)
            if line_break != u'\n':
                chunks.append(line_break)
            elif not breaks:
                chunks.append(u' ')
            chunks.extend(breaks)
        else:
            chunks.append(whitespaces)
        return chunks

    def scan_flow_scalar_breaks(self, double, start_mark):
        # See the specification for details.
        chunks = []
        while True:
            # Instead of checking indentation, we check for document
            # separators.
            prefix = self.prefix(3)
            if (prefix == u'---' or prefix == u'...')   \
                    and self.peek(3) in u'\0 \t\r\n\x85\u2028\u2029':
                raise ScannerError("while scanning a quoted scalar", start_mark,
                        "found unexpected document separator", self.get_mark())
            while self.peek() in u' \t':
                self.forward()
            if self.peek() in u'\r\n\x85\u2028\u2029':
                chunks.append(self.scan_line_break())
            else:
                return chunks

    def scan_plain(self):
        # See the specification for details.
        # We add an additional restriction for the flow context:
        #   plain scalars in the flow context cannot contain ',', ':' and '?'.
        # We also keep track of the `allow_simple_key` flag here.
        # Indentation rules are loosed for the flow context.
        chunks = []
        start_mark = self.get_mark()
        end_mark = start_mark
        indent = self.indent+1
        # We allow zero indentation for scalars, but then we need to check for
        # document separators at the beginning of the line.
        #if indent == 0:
        #    indent = 1
        spaces = []
        while True:
            length = 0
            if self.peek() == u'#':
                break
            while True:
                ch = self.peek(length)
                if ch in u'\0 \t\r\n\x85\u2028\u2029'   \
                        or (not self.flow_level and ch == u':' and
                                self.peek(length+1) in u'\0 \t\r\n\x85\u2028\u2029') \
                        or (self.flow_level and ch in u',:?[]{}'):
                    break
                length += 1
            # It's not clear what we should do with ':' in the flow context.
            if (self.flow_level and ch == u':'
                    and self.peek(length+1) not in u'\0 \t\r\n\x85\u2028\u2029,[]{}'):
                self.forward(length)
                raise ScannerError("while scanning a plain scalar", start_mark,
                    "found unexpected ':'", self.get_mark(),
                    "Please check http://pyyaml.org/wiki/YAMLColonInFlowContext for details.")
            if length == 0:
                break
            self.allow_simple_key = False
            chunks.extend(spaces)
            chunks.append(self.prefix(length))
            self.forward(length)
            end_mark = self.get_mark()
            spaces = self.scan_plain_spaces(indent, start_mark)
            if not spaces or self.peek() == u'#' \
                    or (not self.flow_level and self.column < indent):
                break
        return ScalarToken(u''.join(chunks), True, start_mark, end_mark)

    def scan_plain_spaces(self, indent, start_mark):
        # See the specification for details.
        # The specification is really confusing about tabs in plain scalars.
        # We just forbid them completely. Do not use tabs in YAML!
        chunks = []
        length = 0
        while self.peek(length) in u' ':
            length += 1
        whitespaces = self.prefix(length)
        self.forward(length)
        ch = self.peek()
        if ch in u'\r\n\x85\u2028\u2029':
            line_break = self.scan_line_break()
            self.allow_simple_key = True
            prefix = self.prefix(3)
            if (prefix == u'---' or prefix == u'...')   \
                    and self.peek(3) in u'\0 \t\r\n\x85\u2028\u2029':
                return
            breaks = []
            while self.peek() in u' \r\n\x85\u2028\u2029':
                if self.peek() == ' ':
                    self.forward()
                else:
                    breaks.append(self.scan_line_break())
                    prefix = self.prefix(3)
                    if (prefix == u'---' or prefix == u'...')   \
                            and self.peek(3) in u'\0 \t\r\n\x85\u2028\u2029':
                        return
            if line_break != u'\n':
                chunks.append(line_break)
            elif not breaks:
                chunks.append(u' ')
            chunks.extend(breaks)
        elif whitespaces:
            chunks.append(whitespaces)
        return chunks

    def scan_tag_handle(self, name, start_mark):
        # See the specification for details.
        # For some strange reasons, the specification does not allow '_' in
        # tag handles. I have allowed it anyway.
        ch = self.peek()
        if ch != u'!':
            raise ScannerError("while scanning a %s" % name, start_mark,
                    "expected '!', but found %r" % ch.encode('utf-8'),
                    self.get_mark())
        length = 1
        ch = self.peek(length)
        if ch != u' ':
            while u'0' <= ch <= u'9' or u'A' <= ch <= u'Z' or u'a' <= ch <= u'z'    \
                    or ch in u'-_':
                length += 1
                ch = self.peek(length)
            if ch != u'!':
                self.forward(length)
                raise ScannerError("while scanning a %s" % name, start_mark,
                        "expected '!', but found %r" % ch.encode('utf-8'),
                        self.get_mark())
            length += 1
        value = self.prefix(length)
        self.forward(length)
        return value

    def scan_tag_uri(self, name, start_mark):
        # See the specification for details.
        # Note: we do not check if URI is well-formed.
        chunks = []
        length = 0
        ch = self.peek(length)
        while u'0' <= ch <= u'9' or u'A' <= ch <= u'Z' or u'a' <= ch <= u'z'    \
                or ch in u'-;/?:@&=+$,_.!~*\'()[]%':
            if ch == u'%':
                chunks.append(self.prefix(length))
                self.forward(length)
                length = 0
                chunks.append(self.scan_uri_escapes(name, start_mark))
            else:
                length += 1
            ch = self.peek(length)
        if length:
            chunks.append(self.prefix(length))
            self.forward(length)
            length = 0
        if not chunks:
            raise ScannerError("while parsing a %s" % name, start_mark,
                    "expected URI, but found %r" % ch.encode('utf-8'),
                    self.get_mark())
        return u''.join(chunks)

    def scan_uri_escapes(self, name, start_mark):
        # See the specification for details.
        bytes = []
        mark = self.get_mark()
        while self.peek() == u'%':
            self.forward()
            for k in range(2):
                if self.peek(k) not in u'0123456789ABCDEFabcdef':
                    raise ScannerError("while scanning a %s" % name, start_mark,
                            "expected URI escape sequence of 2 hexdecimal numbers, but found %r" %
                                (self.peek(k).encode('utf-8')), self.get_mark())
            bytes.append(chr(int(self.prefix(2), 16)))
            self.forward(2)
        try:
            value = unicode(''.join(bytes), 'utf-8')
        except UnicodeDecodeError, exc:
            raise ScannerError("while scanning a %s" % name, start_mark, str(exc), mark)
        return value

    def scan_line_break(self):
        # Transforms:
        #   '\r\n'      :   '\n'
        #   '\r'        :   '\n'
        #   '\n'        :   '\n'
        #   '\x85'      :   '\n'
        #   '\u2028'    :   '\u2028'
        #   '\u2029     :   '\u2029'
        #   default     :   ''
        ch = self.peek()
        if ch in u'\r\n\x85':
            if self.prefix(2) == u'\r\n':
                self.forward(2)
            else:
                self.forward()
            return u'\n'
        elif ch in u'\u2028\u2029':
            self.forward()
            return ch
        return u''

#try:
#    import psyco
#    psyco.bind(Scanner)
#except ImportError:
#    pass


########NEW FILE########
__FILENAME__ = serializer

__all__ = ['Serializer', 'SerializerError']

from error import YAMLError
from events import *
from nodes import *

class SerializerError(YAMLError):
    pass

class Serializer(object):

    ANCHOR_TEMPLATE = u'id%03d'

    def __init__(self, encoding=None,
            explicit_start=None, explicit_end=None, version=None, tags=None):
        self.use_encoding = encoding
        self.use_explicit_start = explicit_start
        self.use_explicit_end = explicit_end
        self.use_version = version
        self.use_tags = tags
        self.serialized_nodes = {}
        self.anchors = {}
        self.last_anchor_id = 0
        self.closed = None

    def open(self):
        if self.closed is None:
            self.emit(StreamStartEvent(encoding=self.use_encoding))
            self.closed = False
        elif self.closed:
            raise SerializerError("serializer is closed")
        else:
            raise SerializerError("serializer is already opened")

    def close(self):
        if self.closed is None:
            raise SerializerError("serializer is not opened")
        elif not self.closed:
            self.emit(StreamEndEvent())
            self.closed = True

    #def __del__(self):
    #    self.close()

    def serialize(self, node):
        if self.closed is None:
            raise SerializerError("serializer is not opened")
        elif self.closed:
            raise SerializerError("serializer is closed")
        self.emit(DocumentStartEvent(explicit=self.use_explicit_start,
            version=self.use_version, tags=self.use_tags))
        self.anchor_node(node)
        self.serialize_node(node, None, None)
        self.emit(DocumentEndEvent(explicit=self.use_explicit_end))
        self.serialized_nodes = {}
        self.anchors = {}
        self.last_anchor_id = 0

    def anchor_node(self, node):
        if node in self.anchors:
            if self.anchors[node] is None:
                self.anchors[node] = self.generate_anchor(node)
        else:
            self.anchors[node] = None
            if isinstance(node, SequenceNode):
                for item in node.value:
                    self.anchor_node(item)
            elif isinstance(node, MappingNode):
                for key, value in node.value:
                    self.anchor_node(key)
                    self.anchor_node(value)

    def generate_anchor(self, node):
        self.last_anchor_id += 1
        return self.ANCHOR_TEMPLATE % self.last_anchor_id

    def serialize_node(self, node, parent, index):
        alias = self.anchors[node]
        if node in self.serialized_nodes:
            self.emit(AliasEvent(alias))
        else:
            self.serialized_nodes[node] = True
            self.descend_resolver(parent, index)
            if isinstance(node, ScalarNode):
                detected_tag = self.resolve(ScalarNode, node.value, (True, False))
                default_tag = self.resolve(ScalarNode, node.value, (False, True))
                implicit = (node.tag == detected_tag), (node.tag == default_tag)
                self.emit(ScalarEvent(alias, node.tag, implicit, node.value,
                    style=node.style))
            elif isinstance(node, SequenceNode):
                implicit = (node.tag
                            == self.resolve(SequenceNode, node.value, True))
                self.emit(SequenceStartEvent(alias, node.tag, implicit,
                    flow_style=node.flow_style))
                index = 0
                for item in node.value:
                    self.serialize_node(item, node, index)
                    index += 1
                self.emit(SequenceEndEvent())
            elif isinstance(node, MappingNode):
                implicit = (node.tag
                            == self.resolve(MappingNode, node.value, True))
                self.emit(MappingStartEvent(alias, node.tag, implicit,
                    flow_style=node.flow_style))
                for key, value in node.value:
                    self.serialize_node(key, node, None)
                    self.serialize_node(value, node, key)
                self.emit(MappingEndEvent())
            self.ascend_resolver()


########NEW FILE########
__FILENAME__ = tokens

class Token(object):
    def __init__(self, start_mark, end_mark):
        self.start_mark = start_mark
        self.end_mark = end_mark
    def __repr__(self):
        attributes = [key for key in self.__dict__
                if not key.endswith('_mark')]
        attributes.sort()
        arguments = ', '.join(['%s=%r' % (key, getattr(self, key))
                for key in attributes])
        return '%s(%s)' % (self.__class__.__name__, arguments)

#class BOMToken(Token):
#    id = '<byte order mark>'

class DirectiveToken(Token):
    id = '<directive>'
    def __init__(self, name, value, start_mark, end_mark):
        self.name = name
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark

class DocumentStartToken(Token):
    id = '<document start>'

class DocumentEndToken(Token):
    id = '<document end>'

class StreamStartToken(Token):
    id = '<stream start>'
    def __init__(self, start_mark=None, end_mark=None,
            encoding=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.encoding = encoding

class StreamEndToken(Token):
    id = '<stream end>'

class BlockSequenceStartToken(Token):
    id = '<block sequence start>'

class BlockMappingStartToken(Token):
    id = '<block mapping start>'

class BlockEndToken(Token):
    id = '<block end>'

class FlowSequenceStartToken(Token):
    id = '['

class FlowMappingStartToken(Token):
    id = '{'

class FlowSequenceEndToken(Token):
    id = ']'

class FlowMappingEndToken(Token):
    id = '}'

class KeyToken(Token):
    id = '?'

class ValueToken(Token):
    id = ':'

class BlockEntryToken(Token):
    id = '-'

class FlowEntryToken(Token):
    id = ','

class AliasToken(Token):
    id = '<alias>'
    def __init__(self, value, start_mark, end_mark):
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark

class AnchorToken(Token):
    id = '<anchor>'
    def __init__(self, value, start_mark, end_mark):
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark

class TagToken(Token):
    id = '<tag>'
    def __init__(self, value, start_mark, end_mark):
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark

class ScalarToken(Token):
    id = '<scalar>'
    def __init__(self, value, plain, start_mark, end_mark, style=None):
        self.value = value
        self.plain = plain
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.style = style


########NEW FILE########
__FILENAME__ = composer

__all__ = ['Composer', 'ComposerError']

from .error import MarkedYAMLError
from .events import *
from .nodes import *

class ComposerError(MarkedYAMLError):
    pass

class Composer:

    def __init__(self):
        self.anchors = {}

    def check_node(self):
        # Drop the STREAM-START event.
        if self.check_event(StreamStartEvent):
            self.get_event()

        # If there are more documents available?
        return not self.check_event(StreamEndEvent)

    def get_node(self):
        # Get the root node of the next document.
        if not self.check_event(StreamEndEvent):
            return self.compose_document()

    def get_single_node(self):
        # Drop the STREAM-START event.
        self.get_event()

        # Compose a document if the stream is not empty.
        document = None
        if not self.check_event(StreamEndEvent):
            document = self.compose_document()

        # Ensure that the stream contains no more documents.
        if not self.check_event(StreamEndEvent):
            event = self.get_event()
            raise ComposerError("expected a single document in the stream",
                    document.start_mark, "but found another document",
                    event.start_mark)

        # Drop the STREAM-END event.
        self.get_event()

        return document

    def compose_document(self):
        # Drop the DOCUMENT-START event.
        self.get_event()

        # Compose the root node.
        node = self.compose_node(None, None)

        # Drop the DOCUMENT-END event.
        self.get_event()

        self.anchors = {}
        return node

    def compose_node(self, parent, index):
        if self.check_event(AliasEvent):
            event = self.get_event()
            anchor = event.anchor
            if anchor not in self.anchors:
                raise ComposerError(None, None, "found undefined alias %r"
                        % anchor, event.start_mark)
            return self.anchors[anchor]
        event = self.peek_event()
        anchor = event.anchor
        if anchor is not None:
            if anchor in self.anchors:
                raise ComposerError("found duplicate anchor %r; first occurence"
                        % anchor, self.anchors[anchor].start_mark,
                        "second occurence", event.start_mark)
        self.descend_resolver(parent, index)
        if self.check_event(ScalarEvent):
            node = self.compose_scalar_node(anchor)
        elif self.check_event(SequenceStartEvent):
            node = self.compose_sequence_node(anchor)
        elif self.check_event(MappingStartEvent):
            node = self.compose_mapping_node(anchor)
        self.ascend_resolver()
        return node

    def compose_scalar_node(self, anchor):
        event = self.get_event()
        tag = event.tag
        if tag is None or tag == '!':
            tag = self.resolve(ScalarNode, event.value, event.implicit)
        node = ScalarNode(tag, event.value,
                event.start_mark, event.end_mark, style=event.style)
        if anchor is not None:
            self.anchors[anchor] = node
        return node

    def compose_sequence_node(self, anchor):
        start_event = self.get_event()
        tag = start_event.tag
        if tag is None or tag == '!':
            tag = self.resolve(SequenceNode, None, start_event.implicit)
        node = SequenceNode(tag, [],
                start_event.start_mark, None,
                flow_style=start_event.flow_style)
        if anchor is not None:
            self.anchors[anchor] = node
        index = 0
        while not self.check_event(SequenceEndEvent):
            node.value.append(self.compose_node(node, index))
            index += 1
        end_event = self.get_event()
        node.end_mark = end_event.end_mark
        return node

    def compose_mapping_node(self, anchor):
        start_event = self.get_event()
        tag = start_event.tag
        if tag is None or tag == '!':
            tag = self.resolve(MappingNode, None, start_event.implicit)
        node = MappingNode(tag, [],
                start_event.start_mark, None,
                flow_style=start_event.flow_style)
        if anchor is not None:
            self.anchors[anchor] = node
        while not self.check_event(MappingEndEvent):
            #key_event = self.peek_event()
            item_key = self.compose_node(node, None)
            #if item_key in node.value:
            #    raise ComposerError("while composing a mapping", start_event.start_mark,
            #            "found duplicate key", key_event.start_mark)
            item_value = self.compose_node(node, item_key)
            #node.value[item_key] = item_value
            node.value.append((item_key, item_value))
        end_event = self.get_event()
        node.end_mark = end_event.end_mark
        return node


########NEW FILE########
__FILENAME__ = constructor

__all__ = ['BaseConstructor', 'SafeConstructor', 'Constructor',
    'ConstructorError']

from .error import *
from .nodes import *

import collections, datetime, base64, binascii, re, sys, types

class ConstructorError(MarkedYAMLError):
    pass

class BaseConstructor:

    yaml_constructors = {}
    yaml_multi_constructors = {}

    def __init__(self):
        self.constructed_objects = {}
        self.recursive_objects = {}
        self.state_generators = []
        self.deep_construct = False

    def check_data(self):
        # If there are more documents available?
        return self.check_node()

    def get_data(self):
        # Construct and return the next document.
        if self.check_node():
            return self.construct_document(self.get_node())

    def get_single_data(self):
        # Ensure that the stream contains a single document and construct it.
        node = self.get_single_node()
        if node is not None:
            return self.construct_document(node)
        return None

    def construct_document(self, node):
        data = self.construct_object(node)
        while self.state_generators:
            state_generators = self.state_generators
            self.state_generators = []
            for generator in state_generators:
                for dummy in generator:
                    pass
        self.constructed_objects = {}
        self.recursive_objects = {}
        self.deep_construct = False
        return data

    def construct_object(self, node, deep=False):
        if deep:
            old_deep = self.deep_construct
            self.deep_construct = True
        if node in self.constructed_objects:
            return self.constructed_objects[node]
        if node in self.recursive_objects:
            raise ConstructorError(None, None,
                    "found unconstructable recursive node", node.start_mark)
        self.recursive_objects[node] = None
        constructor = None
        tag_suffix = None
        if node.tag in self.yaml_constructors:
            constructor = self.yaml_constructors[node.tag]
        else:
            for tag_prefix in self.yaml_multi_constructors:
                if node.tag.startswith(tag_prefix):
                    tag_suffix = node.tag[len(tag_prefix):]
                    constructor = self.yaml_multi_constructors[tag_prefix]
                    break
            else:
                if None in self.yaml_multi_constructors:
                    tag_suffix = node.tag
                    constructor = self.yaml_multi_constructors[None]
                elif None in self.yaml_constructors:
                    constructor = self.yaml_constructors[None]
                elif isinstance(node, ScalarNode):
                    constructor = self.__class__.construct_scalar
                elif isinstance(node, SequenceNode):
                    constructor = self.__class__.construct_sequence
                elif isinstance(node, MappingNode):
                    constructor = self.__class__.construct_mapping
        if tag_suffix is None:
            data = constructor(self, node)
        else:
            data = constructor(self, tag_suffix, node)
        if isinstance(data, types.GeneratorType):
            generator = data
            data = next(generator)
            if self.deep_construct:
                for dummy in generator:
                    pass
            else:
                self.state_generators.append(generator)
        self.constructed_objects[node] = data
        del self.recursive_objects[node]
        if deep:
            self.deep_construct = old_deep
        return data

    def construct_scalar(self, node):
        if not isinstance(node, ScalarNode):
            raise ConstructorError(None, None,
                    "expected a scalar node, but found %s" % node.id,
                    node.start_mark)
        return node.value

    def construct_sequence(self, node, deep=False):
        if not isinstance(node, SequenceNode):
            raise ConstructorError(None, None,
                    "expected a sequence node, but found %s" % node.id,
                    node.start_mark)
        return [self.construct_object(child, deep=deep)
                for child in node.value]

    def construct_mapping(self, node, deep=False):
        if not isinstance(node, MappingNode):
            raise ConstructorError(None, None,
                    "expected a mapping node, but found %s" % node.id,
                    node.start_mark)
        mapping = {}
        for key_node, value_node in node.value:
            key = self.construct_object(key_node, deep=deep)
            if not isinstance(key, collections.Hashable):
                raise ConstructorError("while constructing a mapping", node.start_mark,
                        "found unhashable key", key_node.start_mark)
            value = self.construct_object(value_node, deep=deep)
            mapping[key] = value
        return mapping

    def construct_pairs(self, node, deep=False):
        if not isinstance(node, MappingNode):
            raise ConstructorError(None, None,
                    "expected a mapping node, but found %s" % node.id,
                    node.start_mark)
        pairs = []
        for key_node, value_node in node.value:
            key = self.construct_object(key_node, deep=deep)
            value = self.construct_object(value_node, deep=deep)
            pairs.append((key, value))
        return pairs

    @classmethod
    def add_constructor(cls, tag, constructor):
        if not 'yaml_constructors' in cls.__dict__:
            cls.yaml_constructors = cls.yaml_constructors.copy()
        cls.yaml_constructors[tag] = constructor

    @classmethod
    def add_multi_constructor(cls, tag_prefix, multi_constructor):
        if not 'yaml_multi_constructors' in cls.__dict__:
            cls.yaml_multi_constructors = cls.yaml_multi_constructors.copy()
        cls.yaml_multi_constructors[tag_prefix] = multi_constructor

class SafeConstructor(BaseConstructor):

    def construct_scalar(self, node):
        if isinstance(node, MappingNode):
            for key_node, value_node in node.value:
                if key_node.tag == 'tag:yaml.org,2002:value':
                    return self.construct_scalar(value_node)
        return super().construct_scalar(node)

    def flatten_mapping(self, node):
        merge = []
        index = 0
        while index < len(node.value):
            key_node, value_node = node.value[index]
            if key_node.tag == 'tag:yaml.org,2002:merge':
                del node.value[index]
                if isinstance(value_node, MappingNode):
                    self.flatten_mapping(value_node)
                    merge.extend(value_node.value)
                elif isinstance(value_node, SequenceNode):
                    submerge = []
                    for subnode in value_node.value:
                        if not isinstance(subnode, MappingNode):
                            raise ConstructorError("while constructing a mapping",
                                    node.start_mark,
                                    "expected a mapping for merging, but found %s"
                                    % subnode.id, subnode.start_mark)
                        self.flatten_mapping(subnode)
                        submerge.append(subnode.value)
                    submerge.reverse()
                    for value in submerge:
                        merge.extend(value)
                else:
                    raise ConstructorError("while constructing a mapping", node.start_mark,
                            "expected a mapping or list of mappings for merging, but found %s"
                            % value_node.id, value_node.start_mark)
            elif key_node.tag == 'tag:yaml.org,2002:value':
                key_node.tag = 'tag:yaml.org,2002:str'
                index += 1
            else:
                index += 1
        if merge:
            node.value = merge + node.value

    def construct_mapping(self, node, deep=False):
        if isinstance(node, MappingNode):
            self.flatten_mapping(node)
        return super().construct_mapping(node, deep=deep)

    def construct_yaml_null(self, node):
        self.construct_scalar(node)
        return None

    bool_values = {
        'yes':      True,
        'no':       False,
        'true':     True,
        'false':    False,
        'on':       True,
        'off':      False,
    }

    def construct_yaml_bool(self, node):
        value = self.construct_scalar(node)
        return self.bool_values[value.lower()]

    def construct_yaml_int(self, node):
        value = self.construct_scalar(node)
        value = value.replace('_', '')
        sign = +1
        if value[0] == '-':
            sign = -1
        if value[0] in '+-':
            value = value[1:]
        if value == '0':
            return 0
        elif value.startswith('0b'):
            return sign*int(value[2:], 2)
        elif value.startswith('0x'):
            return sign*int(value[2:], 16)
        elif value[0] == '0':
            return sign*int(value, 8)
        elif ':' in value:
            digits = [int(part) for part in value.split(':')]
            digits.reverse()
            base = 1
            value = 0
            for digit in digits:
                value += digit*base
                base *= 60
            return sign*value
        else:
            return sign*int(value)

    inf_value = 1e300
    while inf_value != inf_value*inf_value:
        inf_value *= inf_value
    nan_value = -inf_value/inf_value   # Trying to make a quiet NaN (like C99).

    def construct_yaml_float(self, node):
        value = self.construct_scalar(node)
        value = value.replace('_', '').lower()
        sign = +1
        if value[0] == '-':
            sign = -1
        if value[0] in '+-':
            value = value[1:]
        if value == '.inf':
            return sign*self.inf_value
        elif value == '.nan':
            return self.nan_value
        elif ':' in value:
            digits = [float(part) for part in value.split(':')]
            digits.reverse()
            base = 1
            value = 0.0
            for digit in digits:
                value += digit*base
                base *= 60
            return sign*value
        else:
            return sign*float(value)

    def construct_yaml_binary(self, node):
        try:
            value = self.construct_scalar(node).encode('ascii')
        except UnicodeEncodeError as exc:
            raise ConstructorError(None, None,
                    "failed to convert base64 data into ascii: %s" % exc,
                    node.start_mark)
        try:
            if hasattr(base64, 'decodebytes'):
                return base64.decodebytes(value)
            else:
                return base64.decodestring(value)
        except binascii.Error as exc:
            raise ConstructorError(None, None,
                    "failed to decode base64 data: %s" % exc, node.start_mark)

    timestamp_regexp = re.compile(
            r'''^(?P<year>[0-9][0-9][0-9][0-9])
                -(?P<month>[0-9][0-9]?)
                -(?P<day>[0-9][0-9]?)
                (?:(?:[Tt]|[ \t]+)
                (?P<hour>[0-9][0-9]?)
                :(?P<minute>[0-9][0-9])
                :(?P<second>[0-9][0-9])
                (?:\.(?P<fraction>[0-9]*))?
                (?:[ \t]*(?P<tz>Z|(?P<tz_sign>[-+])(?P<tz_hour>[0-9][0-9]?)
                (?::(?P<tz_minute>[0-9][0-9]))?))?)?$''', re.X)

    def construct_yaml_timestamp(self, node):
        value = self.construct_scalar(node)
        match = self.timestamp_regexp.match(node.value)
        values = match.groupdict()
        year = int(values['year'])
        month = int(values['month'])
        day = int(values['day'])
        if not values['hour']:
            return datetime.date(year, month, day)
        hour = int(values['hour'])
        minute = int(values['minute'])
        second = int(values['second'])
        fraction = 0
        if values['fraction']:
            fraction = values['fraction'][:6]
            while len(fraction) < 6:
                fraction += '0'
            fraction = int(fraction)
        delta = None
        if values['tz_sign']:
            tz_hour = int(values['tz_hour'])
            tz_minute = int(values['tz_minute'] or 0)
            delta = datetime.timedelta(hours=tz_hour, minutes=tz_minute)
            if values['tz_sign'] == '-':
                delta = -delta
        data = datetime.datetime(year, month, day, hour, minute, second, fraction)
        if delta:
            data -= delta
        return data

    def construct_yaml_omap(self, node):
        # Note: we do not check for duplicate keys, because it's too
        # CPU-expensive.
        omap = []
        yield omap
        if not isinstance(node, SequenceNode):
            raise ConstructorError("while constructing an ordered map", node.start_mark,
                    "expected a sequence, but found %s" % node.id, node.start_mark)
        for subnode in node.value:
            if not isinstance(subnode, MappingNode):
                raise ConstructorError("while constructing an ordered map", node.start_mark,
                        "expected a mapping of length 1, but found %s" % subnode.id,
                        subnode.start_mark)
            if len(subnode.value) != 1:
                raise ConstructorError("while constructing an ordered map", node.start_mark,
                        "expected a single mapping item, but found %d items" % len(subnode.value),
                        subnode.start_mark)
            key_node, value_node = subnode.value[0]
            key = self.construct_object(key_node)
            value = self.construct_object(value_node)
            omap.append((key, value))

    def construct_yaml_pairs(self, node):
        # Note: the same code as `construct_yaml_omap`.
        pairs = []
        yield pairs
        if not isinstance(node, SequenceNode):
            raise ConstructorError("while constructing pairs", node.start_mark,
                    "expected a sequence, but found %s" % node.id, node.start_mark)
        for subnode in node.value:
            if not isinstance(subnode, MappingNode):
                raise ConstructorError("while constructing pairs", node.start_mark,
                        "expected a mapping of length 1, but found %s" % subnode.id,
                        subnode.start_mark)
            if len(subnode.value) != 1:
                raise ConstructorError("while constructing pairs", node.start_mark,
                        "expected a single mapping item, but found %d items" % len(subnode.value),
                        subnode.start_mark)
            key_node, value_node = subnode.value[0]
            key = self.construct_object(key_node)
            value = self.construct_object(value_node)
            pairs.append((key, value))

    def construct_yaml_set(self, node):
        data = set()
        yield data
        value = self.construct_mapping(node)
        data.update(value)

    def construct_yaml_str(self, node):
        return self.construct_scalar(node)

    def construct_yaml_seq(self, node):
        data = []
        yield data
        data.extend(self.construct_sequence(node))

    def construct_yaml_map(self, node):
        data = {}
        yield data
        value = self.construct_mapping(node)
        data.update(value)

    def construct_yaml_object(self, node, cls):
        data = cls.__new__(cls)
        yield data
        if hasattr(data, '__setstate__'):
            state = self.construct_mapping(node, deep=True)
            data.__setstate__(state)
        else:
            state = self.construct_mapping(node)
            data.__dict__.update(state)

    def construct_undefined(self, node):
        raise ConstructorError(None, None,
                "could not determine a constructor for the tag %r" % node.tag,
                node.start_mark)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:null',
        SafeConstructor.construct_yaml_null)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:bool',
        SafeConstructor.construct_yaml_bool)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:int',
        SafeConstructor.construct_yaml_int)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:float',
        SafeConstructor.construct_yaml_float)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:binary',
        SafeConstructor.construct_yaml_binary)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:timestamp',
        SafeConstructor.construct_yaml_timestamp)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:omap',
        SafeConstructor.construct_yaml_omap)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:pairs',
        SafeConstructor.construct_yaml_pairs)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:set',
        SafeConstructor.construct_yaml_set)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:str',
        SafeConstructor.construct_yaml_str)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:seq',
        SafeConstructor.construct_yaml_seq)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:map',
        SafeConstructor.construct_yaml_map)

SafeConstructor.add_constructor(None,
        SafeConstructor.construct_undefined)

class Constructor(SafeConstructor):

    def construct_python_str(self, node):
        return self.construct_scalar(node)

    def construct_python_unicode(self, node):
        return self.construct_scalar(node)

    def construct_python_bytes(self, node):
        try:
            value = self.construct_scalar(node).encode('ascii')
        except UnicodeEncodeError as exc:
            raise ConstructorError(None, None,
                    "failed to convert base64 data into ascii: %s" % exc,
                    node.start_mark)
        try:
            if hasattr(base64, 'decodebytes'):
                return base64.decodebytes(value)
            else:
                return base64.decodestring(value)
        except binascii.Error as exc:
            raise ConstructorError(None, None,
                    "failed to decode base64 data: %s" % exc, node.start_mark)

    def construct_python_long(self, node):
        return self.construct_yaml_int(node)

    def construct_python_complex(self, node):
       return complex(self.construct_scalar(node))

    def construct_python_tuple(self, node):
        return tuple(self.construct_sequence(node))

    def find_python_module(self, name, mark):
        if not name:
            raise ConstructorError("while constructing a Python module", mark,
                    "expected non-empty name appended to the tag", mark)
        try:
            __import__(name)
        except ImportError as exc:
            raise ConstructorError("while constructing a Python module", mark,
                    "cannot find module %r (%s)" % (name, exc), mark)
        return sys.modules[name]

    def find_python_name(self, name, mark):
        if not name:
            raise ConstructorError("while constructing a Python object", mark,
                    "expected non-empty name appended to the tag", mark)
        if '.' in name:
            module_name, object_name = name.rsplit('.', 1)
        else:
            module_name = 'builtins'
            object_name = name
        try:
            __import__(module_name)
        except ImportError as exc:
            raise ConstructorError("while constructing a Python object", mark,
                    "cannot find module %r (%s)" % (module_name, exc), mark)
        module = sys.modules[module_name]
        if not hasattr(module, object_name):
            raise ConstructorError("while constructing a Python object", mark,
                    "cannot find %r in the module %r"
                    % (object_name, module.__name__), mark)
        return getattr(module, object_name)

    def construct_python_name(self, suffix, node):
        value = self.construct_scalar(node)
        if value:
            raise ConstructorError("while constructing a Python name", node.start_mark,
                    "expected the empty value, but found %r" % value, node.start_mark)
        return self.find_python_name(suffix, node.start_mark)

    def construct_python_module(self, suffix, node):
        value = self.construct_scalar(node)
        if value:
            raise ConstructorError("while constructing a Python module", node.start_mark,
                    "expected the empty value, but found %r" % value, node.start_mark)
        return self.find_python_module(suffix, node.start_mark)

    def make_python_instance(self, suffix, node,
            args=None, kwds=None, newobj=False):
        if not args:
            args = []
        if not kwds:
            kwds = {}
        cls = self.find_python_name(suffix, node.start_mark)
        if newobj and isinstance(cls, type):
            return cls.__new__(cls, *args, **kwds)
        else:
            return cls(*args, **kwds)

    def set_python_instance_state(self, instance, state):
        if hasattr(instance, '__setstate__'):
            instance.__setstate__(state)
        else:
            slotstate = {}
            if isinstance(state, tuple) and len(state) == 2:
                state, slotstate = state
            if hasattr(instance, '__dict__'):
                instance.__dict__.update(state)
            elif state:
                slotstate.update(state)
            for key, value in slotstate.items():
                setattr(object, key, value)

    def construct_python_object(self, suffix, node):
        # Format:
        #   !!python/object:module.name { ... state ... }
        instance = self.make_python_instance(suffix, node, newobj=True)
        yield instance
        deep = hasattr(instance, '__setstate__')
        state = self.construct_mapping(node, deep=deep)
        self.set_python_instance_state(instance, state)

    def construct_python_object_apply(self, suffix, node, newobj=False):
        # Format:
        #   !!python/object/apply       # (or !!python/object/new)
        #   args: [ ... arguments ... ]
        #   kwds: { ... keywords ... }
        #   state: ... state ...
        #   listitems: [ ... listitems ... ]
        #   dictitems: { ... dictitems ... }
        # or short format:
        #   !!python/object/apply [ ... arguments ... ]
        # The difference between !!python/object/apply and !!python/object/new
        # is how an object is created, check make_python_instance for details.
        if isinstance(node, SequenceNode):
            args = self.construct_sequence(node, deep=True)
            kwds = {}
            state = {}
            listitems = []
            dictitems = {}
        else:
            value = self.construct_mapping(node, deep=True)
            args = value.get('args', [])
            kwds = value.get('kwds', {})
            state = value.get('state', {})
            listitems = value.get('listitems', [])
            dictitems = value.get('dictitems', {})
        instance = self.make_python_instance(suffix, node, args, kwds, newobj)
        if state:
            self.set_python_instance_state(instance, state)
        if listitems:
            instance.extend(listitems)
        if dictitems:
            for key in dictitems:
                instance[key] = dictitems[key]
        return instance

    def construct_python_object_new(self, suffix, node):
        return self.construct_python_object_apply(suffix, node, newobj=True)

Constructor.add_constructor(
    'tag:yaml.org,2002:python/none',
    Constructor.construct_yaml_null)

Constructor.add_constructor(
    'tag:yaml.org,2002:python/bool',
    Constructor.construct_yaml_bool)

Constructor.add_constructor(
    'tag:yaml.org,2002:python/str',
    Constructor.construct_python_str)

Constructor.add_constructor(
    'tag:yaml.org,2002:python/unicode',
    Constructor.construct_python_unicode)

Constructor.add_constructor(
    'tag:yaml.org,2002:python/bytes',
    Constructor.construct_python_bytes)

Constructor.add_constructor(
    'tag:yaml.org,2002:python/int',
    Constructor.construct_yaml_int)

Constructor.add_constructor(
    'tag:yaml.org,2002:python/long',
    Constructor.construct_python_long)

Constructor.add_constructor(
    'tag:yaml.org,2002:python/float',
    Constructor.construct_yaml_float)

Constructor.add_constructor(
    'tag:yaml.org,2002:python/complex',
    Constructor.construct_python_complex)

Constructor.add_constructor(
    'tag:yaml.org,2002:python/list',
    Constructor.construct_yaml_seq)

Constructor.add_constructor(
    'tag:yaml.org,2002:python/tuple',
    Constructor.construct_python_tuple)

Constructor.add_constructor(
    'tag:yaml.org,2002:python/dict',
    Constructor.construct_yaml_map)

Constructor.add_multi_constructor(
    'tag:yaml.org,2002:python/name:',
    Constructor.construct_python_name)

Constructor.add_multi_constructor(
    'tag:yaml.org,2002:python/module:',
    Constructor.construct_python_module)

Constructor.add_multi_constructor(
    'tag:yaml.org,2002:python/object:',
    Constructor.construct_python_object)

Constructor.add_multi_constructor(
    'tag:yaml.org,2002:python/object/apply:',
    Constructor.construct_python_object_apply)

Constructor.add_multi_constructor(
    'tag:yaml.org,2002:python/object/new:',
    Constructor.construct_python_object_new)


########NEW FILE########
__FILENAME__ = cyaml

__all__ = ['CBaseLoader', 'CSafeLoader', 'CLoader',
        'CBaseDumper', 'CSafeDumper', 'CDumper']

from _yaml import CParser, CEmitter

from .constructor import *

from .serializer import *
from .representer import *

from .resolver import *

class CBaseLoader(CParser, BaseConstructor, BaseResolver):

    def __init__(self, stream):
        CParser.__init__(self, stream)
        BaseConstructor.__init__(self)
        BaseResolver.__init__(self)

class CSafeLoader(CParser, SafeConstructor, Resolver):

    def __init__(self, stream):
        CParser.__init__(self, stream)
        SafeConstructor.__init__(self)
        Resolver.__init__(self)

class CLoader(CParser, Constructor, Resolver):

    def __init__(self, stream):
        CParser.__init__(self, stream)
        Constructor.__init__(self)
        Resolver.__init__(self)

class CBaseDumper(CEmitter, BaseRepresenter, BaseResolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        CEmitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width, encoding=encoding,
                allow_unicode=allow_unicode, line_break=line_break,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        Representer.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)

class CSafeDumper(CEmitter, SafeRepresenter, Resolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        CEmitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width, encoding=encoding,
                allow_unicode=allow_unicode, line_break=line_break,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        SafeRepresenter.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)

class CDumper(CEmitter, Serializer, Representer, Resolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        CEmitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width, encoding=encoding,
                allow_unicode=allow_unicode, line_break=line_break,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        Representer.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)


########NEW FILE########
__FILENAME__ = dumper

__all__ = ['BaseDumper', 'SafeDumper', 'Dumper']

from .emitter import *
from .serializer import *
from .representer import *
from .resolver import *

class BaseDumper(Emitter, Serializer, BaseRepresenter, BaseResolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        Emitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width,
                allow_unicode=allow_unicode, line_break=line_break)
        Serializer.__init__(self, encoding=encoding,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        Representer.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)

class SafeDumper(Emitter, Serializer, SafeRepresenter, Resolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        Emitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width,
                allow_unicode=allow_unicode, line_break=line_break)
        Serializer.__init__(self, encoding=encoding,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        SafeRepresenter.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)

class Dumper(Emitter, Serializer, Representer, Resolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=None,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        Emitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width,
                allow_unicode=allow_unicode, line_break=line_break)
        Serializer.__init__(self, encoding=encoding,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        Representer.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)


########NEW FILE########
__FILENAME__ = emitter

# Emitter expects events obeying the following grammar:
# stream ::= STREAM-START document* STREAM-END
# document ::= DOCUMENT-START node DOCUMENT-END
# node ::= SCALAR | sequence | mapping
# sequence ::= SEQUENCE-START node* SEQUENCE-END
# mapping ::= MAPPING-START (node node)* MAPPING-END

__all__ = ['Emitter', 'EmitterError']

from .error import YAMLError
from .events import *

class EmitterError(YAMLError):
    pass

class ScalarAnalysis:
    def __init__(self, scalar, empty, multiline,
            allow_flow_plain, allow_block_plain,
            allow_single_quoted, allow_double_quoted,
            allow_block):
        self.scalar = scalar
        self.empty = empty
        self.multiline = multiline
        self.allow_flow_plain = allow_flow_plain
        self.allow_block_plain = allow_block_plain
        self.allow_single_quoted = allow_single_quoted
        self.allow_double_quoted = allow_double_quoted
        self.allow_block = allow_block

class Emitter:

    DEFAULT_TAG_PREFIXES = {
        '!' : '!',
        'tag:yaml.org,2002:' : '!!',
    }

    def __init__(self, stream, canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None):

        # The stream should have the methods `write` and possibly `flush`.
        self.stream = stream

        # Encoding can be overriden by STREAM-START.
        self.encoding = None

        # Emitter is a state machine with a stack of states to handle nested
        # structures.
        self.states = []
        self.state = self.expect_stream_start

        # Current event and the event queue.
        self.events = []
        self.event = None

        # The current indentation level and the stack of previous indents.
        self.indents = []
        self.indent = None

        # Flow level.
        self.flow_level = 0

        # Contexts.
        self.root_context = False
        self.sequence_context = False
        self.mapping_context = False
        self.simple_key_context = False

        # Characteristics of the last emitted character:
        #  - current position.
        #  - is it a whitespace?
        #  - is it an indention character
        #    (indentation space, '-', '?', or ':')?
        self.line = 0
        self.column = 0
        self.whitespace = True
        self.indention = True

        # Whether the document requires an explicit document indicator
        self.open_ended = False

        # Formatting details.
        self.canonical = canonical
        self.allow_unicode = allow_unicode
        self.best_indent = 2
        if indent and 1 < indent < 10:
            self.best_indent = indent
        self.best_width = 80
        if width and width > self.best_indent*2:
            self.best_width = width
        self.best_line_break = '\n'
        if line_break in ['\r', '\n', '\r\n']:
            self.best_line_break = line_break

        # Tag prefixes.
        self.tag_prefixes = None

        # Prepared anchor and tag.
        self.prepared_anchor = None
        self.prepared_tag = None

        # Scalar analysis and style.
        self.analysis = None
        self.style = None

    def emit(self, event):
        self.events.append(event)
        while not self.need_more_events():
            self.event = self.events.pop(0)
            self.state()
            self.event = None

    # In some cases, we wait for a few next events before emitting.

    def need_more_events(self):
        if not self.events:
            return True
        event = self.events[0]
        if isinstance(event, DocumentStartEvent):
            return self.need_events(1)
        elif isinstance(event, SequenceStartEvent):
            return self.need_events(2)
        elif isinstance(event, MappingStartEvent):
            return self.need_events(3)
        else:
            return False

    def need_events(self, count):
        level = 0
        for event in self.events[1:]:
            if isinstance(event, (DocumentStartEvent, CollectionStartEvent)):
                level += 1
            elif isinstance(event, (DocumentEndEvent, CollectionEndEvent)):
                level -= 1
            elif isinstance(event, StreamEndEvent):
                level = -1
            if level < 0:
                return False
        return (len(self.events) < count+1)

    def increase_indent(self, flow=False, indentless=False):
        self.indents.append(self.indent)
        if self.indent is None:
            if flow:
                self.indent = self.best_indent
            else:
                self.indent = 0
        elif not indentless:
            self.indent += self.best_indent

    # States.

    # Stream handlers.

    def expect_stream_start(self):
        if isinstance(self.event, StreamStartEvent):
            if self.event.encoding and not hasattr(self.stream, 'encoding'):
                self.encoding = self.event.encoding
            self.write_stream_start()
            self.state = self.expect_first_document_start
        else:
            raise EmitterError("expected StreamStartEvent, but got %s"
                    % self.event)

    def expect_nothing(self):
        raise EmitterError("expected nothing, but got %s" % self.event)

    # Document handlers.

    def expect_first_document_start(self):
        return self.expect_document_start(first=True)

    def expect_document_start(self, first=False):
        if isinstance(self.event, DocumentStartEvent):
            if (self.event.version or self.event.tags) and self.open_ended:
                self.write_indicator('...', True)
                self.write_indent()
            if self.event.version:
                version_text = self.prepare_version(self.event.version)
                self.write_version_directive(version_text)
            self.tag_prefixes = self.DEFAULT_TAG_PREFIXES.copy()
            if self.event.tags:
                handles = sorted(self.event.tags.keys())
                for handle in handles:
                    prefix = self.event.tags[handle]
                    self.tag_prefixes[prefix] = handle
                    handle_text = self.prepare_tag_handle(handle)
                    prefix_text = self.prepare_tag_prefix(prefix)
                    self.write_tag_directive(handle_text, prefix_text)
            implicit = (first and not self.event.explicit and not self.canonical
                    and not self.event.version and not self.event.tags
                    and not self.check_empty_document())
            if not implicit:
                self.write_indent()
                self.write_indicator('---', True)
                if self.canonical:
                    self.write_indent()
            self.state = self.expect_document_root
        elif isinstance(self.event, StreamEndEvent):
            if self.open_ended:
                self.write_indicator('...', True)
                self.write_indent()
            self.write_stream_end()
            self.state = self.expect_nothing
        else:
            raise EmitterError("expected DocumentStartEvent, but got %s"
                    % self.event)

    def expect_document_end(self):
        if isinstance(self.event, DocumentEndEvent):
            self.write_indent()
            if self.event.explicit:
                self.write_indicator('...', True)
                self.write_indent()
            self.flush_stream()
            self.state = self.expect_document_start
        else:
            raise EmitterError("expected DocumentEndEvent, but got %s"
                    % self.event)

    def expect_document_root(self):
        self.states.append(self.expect_document_end)
        self.expect_node(root=True)

    # Node handlers.

    def expect_node(self, root=False, sequence=False, mapping=False,
            simple_key=False):
        self.root_context = root
        self.sequence_context = sequence
        self.mapping_context = mapping
        self.simple_key_context = simple_key
        if isinstance(self.event, AliasEvent):
            self.expect_alias()
        elif isinstance(self.event, (ScalarEvent, CollectionStartEvent)):
            self.process_anchor('&')
            self.process_tag()
            if isinstance(self.event, ScalarEvent):
                self.expect_scalar()
            elif isinstance(self.event, SequenceStartEvent):
                if self.flow_level or self.canonical or self.event.flow_style   \
                        or self.check_empty_sequence():
                    self.expect_flow_sequence()
                else:
                    self.expect_block_sequence()
            elif isinstance(self.event, MappingStartEvent):
                if self.flow_level or self.canonical or self.event.flow_style   \
                        or self.check_empty_mapping():
                    self.expect_flow_mapping()
                else:
                    self.expect_block_mapping()
        else:
            raise EmitterError("expected NodeEvent, but got %s" % self.event)

    def expect_alias(self):
        if self.event.anchor is None:
            raise EmitterError("anchor is not specified for alias")
        self.process_anchor('*')
        self.state = self.states.pop()

    def expect_scalar(self):
        self.increase_indent(flow=True)
        self.process_scalar()
        self.indent = self.indents.pop()
        self.state = self.states.pop()

    # Flow sequence handlers.

    def expect_flow_sequence(self):
        self.write_indicator('[', True, whitespace=True)
        self.flow_level += 1
        self.increase_indent(flow=True)
        self.state = self.expect_first_flow_sequence_item

    def expect_first_flow_sequence_item(self):
        if isinstance(self.event, SequenceEndEvent):
            self.indent = self.indents.pop()
            self.flow_level -= 1
            self.write_indicator(']', False)
            self.state = self.states.pop()
        else:
            if self.canonical or self.column > self.best_width:
                self.write_indent()
            self.states.append(self.expect_flow_sequence_item)
            self.expect_node(sequence=True)

    def expect_flow_sequence_item(self):
        if isinstance(self.event, SequenceEndEvent):
            self.indent = self.indents.pop()
            self.flow_level -= 1
            if self.canonical:
                self.write_indicator(',', False)
                self.write_indent()
            self.write_indicator(']', False)
            self.state = self.states.pop()
        else:
            self.write_indicator(',', False)
            if self.canonical or self.column > self.best_width:
                self.write_indent()
            self.states.append(self.expect_flow_sequence_item)
            self.expect_node(sequence=True)

    # Flow mapping handlers.

    def expect_flow_mapping(self):
        self.write_indicator('{', True, whitespace=True)
        self.flow_level += 1
        self.increase_indent(flow=True)
        self.state = self.expect_first_flow_mapping_key

    def expect_first_flow_mapping_key(self):
        if isinstance(self.event, MappingEndEvent):
            self.indent = self.indents.pop()
            self.flow_level -= 1
            self.write_indicator('}', False)
            self.state = self.states.pop()
        else:
            if self.canonical or self.column > self.best_width:
                self.write_indent()
            if not self.canonical and self.check_simple_key():
                self.states.append(self.expect_flow_mapping_simple_value)
                self.expect_node(mapping=True, simple_key=True)
            else:
                self.write_indicator('?', True)
                self.states.append(self.expect_flow_mapping_value)
                self.expect_node(mapping=True)

    def expect_flow_mapping_key(self):
        if isinstance(self.event, MappingEndEvent):
            self.indent = self.indents.pop()
            self.flow_level -= 1
            if self.canonical:
                self.write_indicator(',', False)
                self.write_indent()
            self.write_indicator('}', False)
            self.state = self.states.pop()
        else:
            self.write_indicator(',', False)
            if self.canonical or self.column > self.best_width:
                self.write_indent()
            if not self.canonical and self.check_simple_key():
                self.states.append(self.expect_flow_mapping_simple_value)
                self.expect_node(mapping=True, simple_key=True)
            else:
                self.write_indicator('?', True)
                self.states.append(self.expect_flow_mapping_value)
                self.expect_node(mapping=True)

    def expect_flow_mapping_simple_value(self):
        self.write_indicator(':', False)
        self.states.append(self.expect_flow_mapping_key)
        self.expect_node(mapping=True)

    def expect_flow_mapping_value(self):
        if self.canonical or self.column > self.best_width:
            self.write_indent()
        self.write_indicator(':', True)
        self.states.append(self.expect_flow_mapping_key)
        self.expect_node(mapping=True)

    # Block sequence handlers.

    def expect_block_sequence(self):
        indentless = (self.mapping_context and not self.indention)
        self.increase_indent(flow=False, indentless=indentless)
        self.state = self.expect_first_block_sequence_item

    def expect_first_block_sequence_item(self):
        return self.expect_block_sequence_item(first=True)

    def expect_block_sequence_item(self, first=False):
        if not first and isinstance(self.event, SequenceEndEvent):
            self.indent = self.indents.pop()
            self.state = self.states.pop()
        else:
            self.write_indent()
            self.write_indicator('-', True, indention=True)
            self.states.append(self.expect_block_sequence_item)
            self.expect_node(sequence=True)

    # Block mapping handlers.

    def expect_block_mapping(self):
        self.increase_indent(flow=False)
        self.state = self.expect_first_block_mapping_key

    def expect_first_block_mapping_key(self):
        return self.expect_block_mapping_key(first=True)

    def expect_block_mapping_key(self, first=False):
        if not first and isinstance(self.event, MappingEndEvent):
            self.indent = self.indents.pop()
            self.state = self.states.pop()
        else:
            self.write_indent()
            if self.check_simple_key():
                self.states.append(self.expect_block_mapping_simple_value)
                self.expect_node(mapping=True, simple_key=True)
            else:
                self.write_indicator('?', True, indention=True)
                self.states.append(self.expect_block_mapping_value)
                self.expect_node(mapping=True)

    def expect_block_mapping_simple_value(self):
        self.write_indicator(':', False)
        self.states.append(self.expect_block_mapping_key)
        self.expect_node(mapping=True)

    def expect_block_mapping_value(self):
        self.write_indent()
        self.write_indicator(':', True, indention=True)
        self.states.append(self.expect_block_mapping_key)
        self.expect_node(mapping=True)

    # Checkers.

    def check_empty_sequence(self):
        return (isinstance(self.event, SequenceStartEvent) and self.events
                and isinstance(self.events[0], SequenceEndEvent))

    def check_empty_mapping(self):
        return (isinstance(self.event, MappingStartEvent) and self.events
                and isinstance(self.events[0], MappingEndEvent))

    def check_empty_document(self):
        if not isinstance(self.event, DocumentStartEvent) or not self.events:
            return False
        event = self.events[0]
        return (isinstance(event, ScalarEvent) and event.anchor is None
                and event.tag is None and event.implicit and event.value == '')

    def check_simple_key(self):
        length = 0
        if isinstance(self.event, NodeEvent) and self.event.anchor is not None:
            if self.prepared_anchor is None:
                self.prepared_anchor = self.prepare_anchor(self.event.anchor)
            length += len(self.prepared_anchor)
        if isinstance(self.event, (ScalarEvent, CollectionStartEvent))  \
                and self.event.tag is not None:
            if self.prepared_tag is None:
                self.prepared_tag = self.prepare_tag(self.event.tag)
            length += len(self.prepared_tag)
        if isinstance(self.event, ScalarEvent):
            if self.analysis is None:
                self.analysis = self.analyze_scalar(self.event.value)
            length += len(self.analysis.scalar)
        return (length < 128 and (isinstance(self.event, AliasEvent)
            or (isinstance(self.event, ScalarEvent)
                    and not self.analysis.empty and not self.analysis.multiline)
            or self.check_empty_sequence() or self.check_empty_mapping()))

    # Anchor, Tag, and Scalar processors.

    def process_anchor(self, indicator):
        if self.event.anchor is None:
            self.prepared_anchor = None
            return
        if self.prepared_anchor is None:
            self.prepared_anchor = self.prepare_anchor(self.event.anchor)
        if self.prepared_anchor:
            self.write_indicator(indicator+self.prepared_anchor, True)
        self.prepared_anchor = None

    def process_tag(self):
        tag = self.event.tag
        if isinstance(self.event, ScalarEvent):
            if self.style is None:
                self.style = self.choose_scalar_style()
            if ((not self.canonical or tag is None) and
                ((self.style == '' and self.event.implicit[0])
                        or (self.style != '' and self.event.implicit[1]))):
                self.prepared_tag = None
                return
            if self.event.implicit[0] and tag is None:
                tag = '!'
                self.prepared_tag = None
        else:
            if (not self.canonical or tag is None) and self.event.implicit:
                self.prepared_tag = None
                return
        if tag is None:
            raise EmitterError("tag is not specified")
        if self.prepared_tag is None:
            self.prepared_tag = self.prepare_tag(tag)
        if self.prepared_tag:
            self.write_indicator(self.prepared_tag, True)
        self.prepared_tag = None

    def choose_scalar_style(self):
        if self.analysis is None:
            self.analysis = self.analyze_scalar(self.event.value)
        if self.event.style == '"' or self.canonical:
            return '"'
        if not self.event.style and self.event.implicit[0]:
            if (not (self.simple_key_context and
                    (self.analysis.empty or self.analysis.multiline))
                and (self.flow_level and self.analysis.allow_flow_plain
                    or (not self.flow_level and self.analysis.allow_block_plain))):
                return ''
        if self.event.style and self.event.style in '|>':
            if (not self.flow_level and not self.simple_key_context
                    and self.analysis.allow_block):
                return self.event.style
        if not self.event.style or self.event.style == '\'':
            if (self.analysis.allow_single_quoted and
                    not (self.simple_key_context and self.analysis.multiline)):
                return '\''
        return '"'

    def process_scalar(self):
        if self.analysis is None:
            self.analysis = self.analyze_scalar(self.event.value)
        if self.style is None:
            self.style = self.choose_scalar_style()
        split = (not self.simple_key_context)
        #if self.analysis.multiline and split    \
        #        and (not self.style or self.style in '\'\"'):
        #    self.write_indent()
        if self.style == '"':
            self.write_double_quoted(self.analysis.scalar, split)
        elif self.style == '\'':
            self.write_single_quoted(self.analysis.scalar, split)
        elif self.style == '>':
            self.write_folded(self.analysis.scalar)
        elif self.style == '|':
            self.write_literal(self.analysis.scalar)
        else:
            self.write_plain(self.analysis.scalar, split)
        self.analysis = None
        self.style = None

    # Analyzers.

    def prepare_version(self, version):
        major, minor = version
        if major != 1:
            raise EmitterError("unsupported YAML version: %d.%d" % (major, minor))
        return '%d.%d' % (major, minor)

    def prepare_tag_handle(self, handle):
        if not handle:
            raise EmitterError("tag handle must not be empty")
        if handle[0] != '!' or handle[-1] != '!':
            raise EmitterError("tag handle must start and end with '!': %r" % handle)
        for ch in handle[1:-1]:
            if not ('0' <= ch <= '9' or 'A' <= ch <= 'Z' or 'a' <= ch <= 'z'    \
                    or ch in '-_'):
                raise EmitterError("invalid character %r in the tag handle: %r"
                        % (ch, handle))
        return handle

    def prepare_tag_prefix(self, prefix):
        if not prefix:
            raise EmitterError("tag prefix must not be empty")
        chunks = []
        start = end = 0
        if prefix[0] == '!':
            end = 1
        while end < len(prefix):
            ch = prefix[end]
            if '0' <= ch <= '9' or 'A' <= ch <= 'Z' or 'a' <= ch <= 'z' \
                    or ch in '-;/?!:@&=+$,_.~*\'()[]':
                end += 1
            else:
                if start < end:
                    chunks.append(prefix[start:end])
                start = end = end+1
                data = ch.encode('utf-8')
                for ch in data:
                    chunks.append('%%%02X' % ord(ch))
        if start < end:
            chunks.append(prefix[start:end])
        return ''.join(chunks)

    def prepare_tag(self, tag):
        if not tag:
            raise EmitterError("tag must not be empty")
        if tag == '!':
            return tag
        handle = None
        suffix = tag
        prefixes = sorted(self.tag_prefixes.keys())
        for prefix in prefixes:
            if tag.startswith(prefix)   \
                    and (prefix == '!' or len(prefix) < len(tag)):
                handle = self.tag_prefixes[prefix]
                suffix = tag[len(prefix):]
        chunks = []
        start = end = 0
        while end < len(suffix):
            ch = suffix[end]
            if '0' <= ch <= '9' or 'A' <= ch <= 'Z' or 'a' <= ch <= 'z' \
                    or ch in '-;/?:@&=+$,_.~*\'()[]'   \
                    or (ch == '!' and handle != '!'):
                end += 1
            else:
                if start < end:
                    chunks.append(suffix[start:end])
                start = end = end+1
                data = ch.encode('utf-8')
                for ch in data:
                    chunks.append('%%%02X' % ord(ch))
        if start < end:
            chunks.append(suffix[start:end])
        suffix_text = ''.join(chunks)
        if handle:
            return '%s%s' % (handle, suffix_text)
        else:
            return '!<%s>' % suffix_text

    def prepare_anchor(self, anchor):
        if not anchor:
            raise EmitterError("anchor must not be empty")
        for ch in anchor:
            if not ('0' <= ch <= '9' or 'A' <= ch <= 'Z' or 'a' <= ch <= 'z'    \
                    or ch in '-_'):
                raise EmitterError("invalid character %r in the anchor: %r"
                        % (ch, anchor))
        return anchor

    def analyze_scalar(self, scalar):

        # Empty scalar is a special case.
        if not scalar:
            return ScalarAnalysis(scalar=scalar, empty=True, multiline=False,
                    allow_flow_plain=False, allow_block_plain=True,
                    allow_single_quoted=True, allow_double_quoted=True,
                    allow_block=False)

        # Indicators and special characters.
        block_indicators = False
        flow_indicators = False
        line_breaks = False
        special_characters = False

        # Important whitespace combinations.
        leading_space = False
        leading_break = False
        trailing_space = False
        trailing_break = False
        break_space = False
        space_break = False

        # Check document indicators.
        if scalar.startswith('---') or scalar.startswith('...'):
            block_indicators = True
            flow_indicators = True

        # First character or preceded by a whitespace.
        preceeded_by_whitespace = True

        # Last character or followed by a whitespace.
        followed_by_whitespace = (len(scalar) == 1 or
                scalar[1] in '\0 \t\r\n\x85\u2028\u2029')

        # The previous character is a space.
        previous_space = False

        # The previous character is a break.
        previous_break = False

        index = 0
        while index < len(scalar):
            ch = scalar[index]

            # Check for indicators.
            if index == 0:
                # Leading indicators are special characters.
                if ch in '#,[]{}&*!|>\'\"%@`': 
                    flow_indicators = True
                    block_indicators = True
                if ch in '?:':
                    flow_indicators = True
                    if followed_by_whitespace:
                        block_indicators = True
                if ch == '-' and followed_by_whitespace:
                    flow_indicators = True
                    block_indicators = True
            else:
                # Some indicators cannot appear within a scalar as well.
                if ch in ',?[]{}':
                    flow_indicators = True
                if ch == ':':
                    flow_indicators = True
                    if followed_by_whitespace:
                        block_indicators = True
                if ch == '#' and preceeded_by_whitespace:
                    flow_indicators = True
                    block_indicators = True

            # Check for line breaks, special, and unicode characters.
            if ch in '\n\x85\u2028\u2029':
                line_breaks = True
            if not (ch == '\n' or '\x20' <= ch <= '\x7E'):
                if (ch == '\x85' or '\xA0' <= ch <= '\uD7FF'
                        or '\uE000' <= ch <= '\uFFFD') and ch != '\uFEFF':
                    unicode_characters = True
                    if not self.allow_unicode:
                        special_characters = True
                else:
                    special_characters = True

            # Detect important whitespace combinations.
            if ch == ' ':
                if index == 0:
                    leading_space = True
                if index == len(scalar)-1:
                    trailing_space = True
                if previous_break:
                    break_space = True
                previous_space = True
                previous_break = False
            elif ch in '\n\x85\u2028\u2029':
                if index == 0:
                    leading_break = True
                if index == len(scalar)-1:
                    trailing_break = True
                if previous_space:
                    space_break = True
                previous_space = False
                previous_break = True
            else:
                previous_space = False
                previous_break = False

            # Prepare for the next character.
            index += 1
            preceeded_by_whitespace = (ch in '\0 \t\r\n\x85\u2028\u2029')
            followed_by_whitespace = (index+1 >= len(scalar) or
                    scalar[index+1] in '\0 \t\r\n\x85\u2028\u2029')

        # Let's decide what styles are allowed.
        allow_flow_plain = True
        allow_block_plain = True
        allow_single_quoted = True
        allow_double_quoted = True
        allow_block = True

        # Leading and trailing whitespaces are bad for plain scalars.
        if (leading_space or leading_break
                or trailing_space or trailing_break):
            allow_flow_plain = allow_block_plain = False

        # We do not permit trailing spaces for block scalars.
        if trailing_space:
            allow_block = False

        # Spaces at the beginning of a new line are only acceptable for block
        # scalars.
        if break_space:
            allow_flow_plain = allow_block_plain = allow_single_quoted = False

        # Spaces followed by breaks, as well as special character are only
        # allowed for double quoted scalars.
        if space_break or special_characters:
            allow_flow_plain = allow_block_plain =  \
            allow_single_quoted = allow_block = False

        # Although the plain scalar writer supports breaks, we never emit
        # multiline plain scalars.
        if line_breaks:
            allow_flow_plain = allow_block_plain = False

        # Flow indicators are forbidden for flow plain scalars.
        if flow_indicators:
            allow_flow_plain = False

        # Block indicators are forbidden for block plain scalars.
        if block_indicators:
            allow_block_plain = False

        return ScalarAnalysis(scalar=scalar,
                empty=False, multiline=line_breaks,
                allow_flow_plain=allow_flow_plain,
                allow_block_plain=allow_block_plain,
                allow_single_quoted=allow_single_quoted,
                allow_double_quoted=allow_double_quoted,
                allow_block=allow_block)

    # Writers.

    def flush_stream(self):
        if hasattr(self.stream, 'flush'):
            self.stream.flush()

    def write_stream_start(self):
        # Write BOM if needed.
        if self.encoding and self.encoding.startswith('utf-16'):
            self.stream.write('\uFEFF'.encode(self.encoding))

    def write_stream_end(self):
        self.flush_stream()

    def write_indicator(self, indicator, need_whitespace,
            whitespace=False, indention=False):
        if self.whitespace or not need_whitespace:
            data = indicator
        else:
            data = ' '+indicator
        self.whitespace = whitespace
        self.indention = self.indention and indention
        self.column += len(data)
        self.open_ended = False
        if self.encoding:
            data = data.encode(self.encoding)
        self.stream.write(data)

    def write_indent(self):
        indent = self.indent or 0
        if not self.indention or self.column > indent   \
                or (self.column == indent and not self.whitespace):
            self.write_line_break()
        if self.column < indent:
            self.whitespace = True
            data = ' '*(indent-self.column)
            self.column = indent
            if self.encoding:
                data = data.encode(self.encoding)
            self.stream.write(data)

    def write_line_break(self, data=None):
        if data is None:
            data = self.best_line_break
        self.whitespace = True
        self.indention = True
        self.line += 1
        self.column = 0
        if self.encoding:
            data = data.encode(self.encoding)
        self.stream.write(data)

    def write_version_directive(self, version_text):
        data = '%%YAML %s' % version_text
        if self.encoding:
            data = data.encode(self.encoding)
        self.stream.write(data)
        self.write_line_break()

    def write_tag_directive(self, handle_text, prefix_text):
        data = '%%TAG %s %s' % (handle_text, prefix_text)
        if self.encoding:
            data = data.encode(self.encoding)
        self.stream.write(data)
        self.write_line_break()

    # Scalar streams.

    def write_single_quoted(self, text, split=True):
        self.write_indicator('\'', True)
        spaces = False
        breaks = False
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if spaces:
                if ch is None or ch != ' ':
                    if start+1 == end and self.column > self.best_width and split   \
                            and start != 0 and end != len(text):
                        self.write_indent()
                    else:
                        data = text[start:end]
                        self.column += len(data)
                        if self.encoding:
                            data = data.encode(self.encoding)
                        self.stream.write(data)
                    start = end
            elif breaks:
                if ch is None or ch not in '\n\x85\u2028\u2029':
                    if text[start] == '\n':
                        self.write_line_break()
                    for br in text[start:end]:
                        if br == '\n':
                            self.write_line_break()
                        else:
                            self.write_line_break(br)
                    self.write_indent()
                    start = end
            else:
                if ch is None or ch in ' \n\x85\u2028\u2029' or ch == '\'':
                    if start < end:
                        data = text[start:end]
                        self.column += len(data)
                        if self.encoding:
                            data = data.encode(self.encoding)
                        self.stream.write(data)
                        start = end
            if ch == '\'':
                data = '\'\''
                self.column += 2
                if self.encoding:
                    data = data.encode(self.encoding)
                self.stream.write(data)
                start = end + 1
            if ch is not None:
                spaces = (ch == ' ')
                breaks = (ch in '\n\x85\u2028\u2029')
            end += 1
        self.write_indicator('\'', False)

    ESCAPE_REPLACEMENTS = {
        '\0':       '0',
        '\x07':     'a',
        '\x08':     'b',
        '\x09':     't',
        '\x0A':     'n',
        '\x0B':     'v',
        '\x0C':     'f',
        '\x0D':     'r',
        '\x1B':     'e',
        '\"':       '\"',
        '\\':       '\\',
        '\x85':     'N',
        '\xA0':     '_',
        '\u2028':   'L',
        '\u2029':   'P',
    }

    def write_double_quoted(self, text, split=True):
        self.write_indicator('"', True)
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if ch is None or ch in '"\\\x85\u2028\u2029\uFEFF' \
                    or not ('\x20' <= ch <= '\x7E'
                        or (self.allow_unicode
                            and ('\xA0' <= ch <= '\uD7FF'
                                or '\uE000' <= ch <= '\uFFFD'))):
                if start < end:
                    data = text[start:end]
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    start = end
                if ch is not None:
                    if ch in self.ESCAPE_REPLACEMENTS:
                        data = '\\'+self.ESCAPE_REPLACEMENTS[ch]
                    elif ch <= '\xFF':
                        data = '\\x%02X' % ord(ch)
                    elif ch <= '\uFFFF':
                        data = '\\u%04X' % ord(ch)
                    else:
                        data = '\\U%08X' % ord(ch)
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    start = end+1
            if 0 < end < len(text)-1 and (ch == ' ' or start >= end)    \
                    and self.column+(end-start) > self.best_width and split:
                data = text[start:end]+'\\'
                if start < end:
                    start = end
                self.column += len(data)
                if self.encoding:
                    data = data.encode(self.encoding)
                self.stream.write(data)
                self.write_indent()
                self.whitespace = False
                self.indention = False
                if text[start] == ' ':
                    data = '\\'
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
            end += 1
        self.write_indicator('"', False)

    def determine_block_hints(self, text):
        hints = ''
        if text:
            if text[0] in ' \n\x85\u2028\u2029':
                hints += str(self.best_indent)
            if text[-1] not in '\n\x85\u2028\u2029':
                hints += '-'
            elif len(text) == 1 or text[-2] in '\n\x85\u2028\u2029':
                hints += '+'
        return hints

    def write_folded(self, text):
        hints = self.determine_block_hints(text)
        self.write_indicator('>'+hints, True)
        if hints[-1:] == '+':
            self.open_ended = True
        self.write_line_break()
        leading_space = True
        spaces = False
        breaks = True
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if breaks:
                if ch is None or ch not in '\n\x85\u2028\u2029':
                    if not leading_space and ch is not None and ch != ' '   \
                            and text[start] == '\n':
                        self.write_line_break()
                    leading_space = (ch == ' ')
                    for br in text[start:end]:
                        if br == '\n':
                            self.write_line_break()
                        else:
                            self.write_line_break(br)
                    if ch is not None:
                        self.write_indent()
                    start = end
            elif spaces:
                if ch != ' ':
                    if start+1 == end and self.column > self.best_width:
                        self.write_indent()
                    else:
                        data = text[start:end]
                        self.column += len(data)
                        if self.encoding:
                            data = data.encode(self.encoding)
                        self.stream.write(data)
                    start = end
            else:
                if ch is None or ch in ' \n\x85\u2028\u2029':
                    data = text[start:end]
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    if ch is None:
                        self.write_line_break()
                    start = end
            if ch is not None:
                breaks = (ch in '\n\x85\u2028\u2029')
                spaces = (ch == ' ')
            end += 1

    def write_literal(self, text):
        hints = self.determine_block_hints(text)
        self.write_indicator('|'+hints, True)
        if hints[-1:] == '+':
            self.open_ended = True
        self.write_line_break()
        breaks = True
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if breaks:
                if ch is None or ch not in '\n\x85\u2028\u2029':
                    for br in text[start:end]:
                        if br == '\n':
                            self.write_line_break()
                        else:
                            self.write_line_break(br)
                    if ch is not None:
                        self.write_indent()
                    start = end
            else:
                if ch is None or ch in '\n\x85\u2028\u2029':
                    data = text[start:end]
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    if ch is None:
                        self.write_line_break()
                    start = end
            if ch is not None:
                breaks = (ch in '\n\x85\u2028\u2029')
            end += 1

    def write_plain(self, text, split=True):
        if self.root_context:
            self.open_ended = True
        if not text:
            return
        if not self.whitespace:
            data = ' '
            self.column += len(data)
            if self.encoding:
                data = data.encode(self.encoding)
            self.stream.write(data)
        self.whitespace = False
        self.indention = False
        spaces = False
        breaks = False
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if spaces:
                if ch != ' ':
                    if start+1 == end and self.column > self.best_width and split:
                        self.write_indent()
                        self.whitespace = False
                        self.indention = False
                    else:
                        data = text[start:end]
                        self.column += len(data)
                        if self.encoding:
                            data = data.encode(self.encoding)
                        self.stream.write(data)
                    start = end
            elif breaks:
                if ch not in '\n\x85\u2028\u2029':
                    if text[start] == '\n':
                        self.write_line_break()
                    for br in text[start:end]:
                        if br == '\n':
                            self.write_line_break()
                        else:
                            self.write_line_break(br)
                    self.write_indent()
                    self.whitespace = False
                    self.indention = False
                    start = end
            else:
                if ch is None or ch in ' \n\x85\u2028\u2029':
                    data = text[start:end]
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    start = end
            if ch is not None:
                spaces = (ch == ' ')
                breaks = (ch in '\n\x85\u2028\u2029')
            end += 1


########NEW FILE########
__FILENAME__ = error

__all__ = ['Mark', 'YAMLError', 'MarkedYAMLError']

class Mark:

    def __init__(self, name, index, line, column, buffer, pointer):
        self.name = name
        self.index = index
        self.line = line
        self.column = column
        self.buffer = buffer
        self.pointer = pointer

    def get_snippet(self, indent=4, max_length=75):
        if self.buffer is None:
            return None
        head = ''
        start = self.pointer
        while start > 0 and self.buffer[start-1] not in '\0\r\n\x85\u2028\u2029':
            start -= 1
            if self.pointer-start > max_length/2-1:
                head = ' ... '
                start += 5
                break
        tail = ''
        end = self.pointer
        while end < len(self.buffer) and self.buffer[end] not in '\0\r\n\x85\u2028\u2029':
            end += 1
            if end-self.pointer > max_length/2-1:
                tail = ' ... '
                end -= 5
                break
        snippet = self.buffer[start:end]
        return ' '*indent + head + snippet + tail + '\n'  \
                + ' '*(indent+self.pointer-start+len(head)) + '^'

    def __str__(self):
        snippet = self.get_snippet()
        where = "  in \"%s\", line %d, column %d"   \
                % (self.name, self.line+1, self.column+1)
        if snippet is not None:
            where += ":\n"+snippet
        return where

class YAMLError(Exception):
    pass

class MarkedYAMLError(YAMLError):

    def __init__(self, context=None, context_mark=None,
            problem=None, problem_mark=None, note=None):
        self.context = context
        self.context_mark = context_mark
        self.problem = problem
        self.problem_mark = problem_mark
        self.note = note

    def __str__(self):
        lines = []
        if self.context is not None:
            lines.append(self.context)
        if self.context_mark is not None  \
            and (self.problem is None or self.problem_mark is None
                    or self.context_mark.name != self.problem_mark.name
                    or self.context_mark.line != self.problem_mark.line
                    or self.context_mark.column != self.problem_mark.column):
            lines.append(str(self.context_mark))
        if self.problem is not None:
            lines.append(self.problem)
        if self.problem_mark is not None:
            lines.append(str(self.problem_mark))
        if self.note is not None:
            lines.append(self.note)
        return '\n'.join(lines)


########NEW FILE########
__FILENAME__ = events

# Abstract classes.

class Event(object):
    def __init__(self, start_mark=None, end_mark=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
    def __repr__(self):
        attributes = [key for key in ['anchor', 'tag', 'implicit', 'value']
                if hasattr(self, key)]
        arguments = ', '.join(['%s=%r' % (key, getattr(self, key))
                for key in attributes])
        return '%s(%s)' % (self.__class__.__name__, arguments)

class NodeEvent(Event):
    def __init__(self, anchor, start_mark=None, end_mark=None):
        self.anchor = anchor
        self.start_mark = start_mark
        self.end_mark = end_mark

class CollectionStartEvent(NodeEvent):
    def __init__(self, anchor, tag, implicit, start_mark=None, end_mark=None,
            flow_style=None):
        self.anchor = anchor
        self.tag = tag
        self.implicit = implicit
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.flow_style = flow_style

class CollectionEndEvent(Event):
    pass

# Implementations.

class StreamStartEvent(Event):
    def __init__(self, start_mark=None, end_mark=None, encoding=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.encoding = encoding

class StreamEndEvent(Event):
    pass

class DocumentStartEvent(Event):
    def __init__(self, start_mark=None, end_mark=None,
            explicit=None, version=None, tags=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.explicit = explicit
        self.version = version
        self.tags = tags

class DocumentEndEvent(Event):
    def __init__(self, start_mark=None, end_mark=None,
            explicit=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.explicit = explicit

class AliasEvent(NodeEvent):
    pass

class ScalarEvent(NodeEvent):
    def __init__(self, anchor, tag, implicit, value,
            start_mark=None, end_mark=None, style=None):
        self.anchor = anchor
        self.tag = tag
        self.implicit = implicit
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.style = style

class SequenceStartEvent(CollectionStartEvent):
    pass

class SequenceEndEvent(CollectionEndEvent):
    pass

class MappingStartEvent(CollectionStartEvent):
    pass

class MappingEndEvent(CollectionEndEvent):
    pass


########NEW FILE########
__FILENAME__ = loader

__all__ = ['BaseLoader', 'SafeLoader', 'Loader']

from .reader import *
from .scanner import *
from .parser import *
from .composer import *
from .constructor import *
from .resolver import *

class BaseLoader(Reader, Scanner, Parser, Composer, BaseConstructor, BaseResolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        BaseConstructor.__init__(self)
        BaseResolver.__init__(self)

class SafeLoader(Reader, Scanner, Parser, Composer, SafeConstructor, Resolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        SafeConstructor.__init__(self)
        Resolver.__init__(self)

class Loader(Reader, Scanner, Parser, Composer, Constructor, Resolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        Constructor.__init__(self)
        Resolver.__init__(self)


########NEW FILE########
__FILENAME__ = nodes

class Node(object):
    def __init__(self, tag, value, start_mark, end_mark):
        self.tag = tag
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark
    def __repr__(self):
        value = self.value
        #if isinstance(value, list):
        #    if len(value) == 0:
        #        value = '<empty>'
        #    elif len(value) == 1:
        #        value = '<1 item>'
        #    else:
        #        value = '<%d items>' % len(value)
        #else:
        #    if len(value) > 75:
        #        value = repr(value[:70]+u' ... ')
        #    else:
        #        value = repr(value)
        value = repr(value)
        return '%s(tag=%r, value=%s)' % (self.__class__.__name__, self.tag, value)

class ScalarNode(Node):
    id = 'scalar'
    def __init__(self, tag, value,
            start_mark=None, end_mark=None, style=None):
        self.tag = tag
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.style = style

class CollectionNode(Node):
    def __init__(self, tag, value,
            start_mark=None, end_mark=None, flow_style=None):
        self.tag = tag
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.flow_style = flow_style

class SequenceNode(CollectionNode):
    id = 'sequence'

class MappingNode(CollectionNode):
    id = 'mapping'


########NEW FILE########
__FILENAME__ = parser

# The following YAML grammar is LL(1) and is parsed by a recursive descent
# parser.
#
# stream            ::= STREAM-START implicit_document? explicit_document* STREAM-END
# implicit_document ::= block_node DOCUMENT-END*
# explicit_document ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
# block_node_or_indentless_sequence ::=
#                       ALIAS
#                       | properties (block_content | indentless_block_sequence)?
#                       | block_content
#                       | indentless_block_sequence
# block_node        ::= ALIAS
#                       | properties block_content?
#                       | block_content
# flow_node         ::= ALIAS
#                       | properties flow_content?
#                       | flow_content
# properties        ::= TAG ANCHOR? | ANCHOR TAG?
# block_content     ::= block_collection | flow_collection | SCALAR
# flow_content      ::= flow_collection | SCALAR
# block_collection  ::= block_sequence | block_mapping
# flow_collection   ::= flow_sequence | flow_mapping
# block_sequence    ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END
# indentless_sequence   ::= (BLOCK-ENTRY block_node?)+
# block_mapping     ::= BLOCK-MAPPING_START
#                       ((KEY block_node_or_indentless_sequence?)?
#                       (VALUE block_node_or_indentless_sequence?)?)*
#                       BLOCK-END
# flow_sequence     ::= FLOW-SEQUENCE-START
#                       (flow_sequence_entry FLOW-ENTRY)*
#                       flow_sequence_entry?
#                       FLOW-SEQUENCE-END
# flow_sequence_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
# flow_mapping      ::= FLOW-MAPPING-START
#                       (flow_mapping_entry FLOW-ENTRY)*
#                       flow_mapping_entry?
#                       FLOW-MAPPING-END
# flow_mapping_entry    ::= flow_node | KEY flow_node? (VALUE flow_node?)?
#
# FIRST sets:
#
# stream: { STREAM-START }
# explicit_document: { DIRECTIVE DOCUMENT-START }
# implicit_document: FIRST(block_node)
# block_node: { ALIAS TAG ANCHOR SCALAR BLOCK-SEQUENCE-START BLOCK-MAPPING-START FLOW-SEQUENCE-START FLOW-MAPPING-START }
# flow_node: { ALIAS ANCHOR TAG SCALAR FLOW-SEQUENCE-START FLOW-MAPPING-START }
# block_content: { BLOCK-SEQUENCE-START BLOCK-MAPPING-START FLOW-SEQUENCE-START FLOW-MAPPING-START SCALAR }
# flow_content: { FLOW-SEQUENCE-START FLOW-MAPPING-START SCALAR }
# block_collection: { BLOCK-SEQUENCE-START BLOCK-MAPPING-START }
# flow_collection: { FLOW-SEQUENCE-START FLOW-MAPPING-START }
# block_sequence: { BLOCK-SEQUENCE-START }
# block_mapping: { BLOCK-MAPPING-START }
# block_node_or_indentless_sequence: { ALIAS ANCHOR TAG SCALAR BLOCK-SEQUENCE-START BLOCK-MAPPING-START FLOW-SEQUENCE-START FLOW-MAPPING-START BLOCK-ENTRY }
# indentless_sequence: { ENTRY }
# flow_collection: { FLOW-SEQUENCE-START FLOW-MAPPING-START }
# flow_sequence: { FLOW-SEQUENCE-START }
# flow_mapping: { FLOW-MAPPING-START }
# flow_sequence_entry: { ALIAS ANCHOR TAG SCALAR FLOW-SEQUENCE-START FLOW-MAPPING-START KEY }
# flow_mapping_entry: { ALIAS ANCHOR TAG SCALAR FLOW-SEQUENCE-START FLOW-MAPPING-START KEY }

__all__ = ['Parser', 'ParserError']

from .error import MarkedYAMLError
from .tokens import *
from .events import *
from .scanner import *

class ParserError(MarkedYAMLError):
    pass

class Parser:
    # Since writing a recursive-descendant parser is a straightforward task, we
    # do not give many comments here.

    DEFAULT_TAGS = {
        '!':   '!',
        '!!':  'tag:yaml.org,2002:',
    }

    def __init__(self):
        self.current_event = None
        self.yaml_version = None
        self.tag_handles = {}
        self.states = []
        self.marks = []
        self.state = self.parse_stream_start

    def check_event(self, *choices):
        # Check the type of the next event.
        if self.current_event is None:
            if self.state:
                self.current_event = self.state()
        if self.current_event is not None:
            if not choices:
                return True
            for choice in choices:
                if isinstance(self.current_event, choice):
                    return True
        return False

    def peek_event(self):
        # Get the next event.
        if self.current_event is None:
            if self.state:
                self.current_event = self.state()
        return self.current_event

    def get_event(self):
        # Get the next event and proceed further.
        if self.current_event is None:
            if self.state:
                self.current_event = self.state()
        value = self.current_event
        self.current_event = None
        return value

    # stream    ::= STREAM-START implicit_document? explicit_document* STREAM-END
    # implicit_document ::= block_node DOCUMENT-END*
    # explicit_document ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*

    def parse_stream_start(self):

        # Parse the stream start.
        token = self.get_token()
        event = StreamStartEvent(token.start_mark, token.end_mark,
                encoding=token.encoding)

        # Prepare the next state.
        self.state = self.parse_implicit_document_start

        return event

    def parse_implicit_document_start(self):

        # Parse an implicit document.
        if not self.check_token(DirectiveToken, DocumentStartToken,
                StreamEndToken):
            self.tag_handles = self.DEFAULT_TAGS
            token = self.peek_token()
            start_mark = end_mark = token.start_mark
            event = DocumentStartEvent(start_mark, end_mark,
                    explicit=False)

            # Prepare the next state.
            self.states.append(self.parse_document_end)
            self.state = self.parse_block_node

            return event

        else:
            return self.parse_document_start()

    def parse_document_start(self):

        # Parse any extra document end indicators.
        while self.check_token(DocumentEndToken):
            self.get_token()

        # Parse an explicit document.
        if not self.check_token(StreamEndToken):
            token = self.peek_token()
            start_mark = token.start_mark
            version, tags = self.process_directives()
            if not self.check_token(DocumentStartToken):
                raise ParserError(None, None,
                        "expected '<document start>', but found %r"
                        % self.peek_token().id,
                        self.peek_token().start_mark)
            token = self.get_token()
            end_mark = token.end_mark
            event = DocumentStartEvent(start_mark, end_mark,
                    explicit=True, version=version, tags=tags)
            self.states.append(self.parse_document_end)
            self.state = self.parse_document_content
        else:
            # Parse the end of the stream.
            token = self.get_token()
            event = StreamEndEvent(token.start_mark, token.end_mark)
            assert not self.states
            assert not self.marks
            self.state = None
        return event

    def parse_document_end(self):

        # Parse the document end.
        token = self.peek_token()
        start_mark = end_mark = token.start_mark
        explicit = False
        if self.check_token(DocumentEndToken):
            token = self.get_token()
            end_mark = token.end_mark
            explicit = True
        event = DocumentEndEvent(start_mark, end_mark,
                explicit=explicit)

        # Prepare the next state.
        self.state = self.parse_document_start

        return event

    def parse_document_content(self):
        if self.check_token(DirectiveToken,
                DocumentStartToken, DocumentEndToken, StreamEndToken):
            event = self.process_empty_scalar(self.peek_token().start_mark)
            self.state = self.states.pop()
            return event
        else:
            return self.parse_block_node()

    def process_directives(self):
        self.yaml_version = None
        self.tag_handles = {}
        while self.check_token(DirectiveToken):
            token = self.get_token()
            if token.name == 'YAML':
                if self.yaml_version is not None:
                    raise ParserError(None, None,
                            "found duplicate YAML directive", token.start_mark)
                major, minor = token.value
                if major != 1:
                    raise ParserError(None, None,
                            "found incompatible YAML document (version 1.* is required)",
                            token.start_mark)
                self.yaml_version = token.value
            elif token.name == 'TAG':
                handle, prefix = token.value
                if handle in self.tag_handles:
                    raise ParserError(None, None,
                            "duplicate tag handle %r" % handle,
                            token.start_mark)
                self.tag_handles[handle] = prefix
        if self.tag_handles:
            value = self.yaml_version, self.tag_handles.copy()
        else:
            value = self.yaml_version, None
        for key in self.DEFAULT_TAGS:
            if key not in self.tag_handles:
                self.tag_handles[key] = self.DEFAULT_TAGS[key]
        return value

    # block_node_or_indentless_sequence ::= ALIAS
    #               | properties (block_content | indentless_block_sequence)?
    #               | block_content
    #               | indentless_block_sequence
    # block_node    ::= ALIAS
    #                   | properties block_content?
    #                   | block_content
    # flow_node     ::= ALIAS
    #                   | properties flow_content?
    #                   | flow_content
    # properties    ::= TAG ANCHOR? | ANCHOR TAG?
    # block_content     ::= block_collection | flow_collection | SCALAR
    # flow_content      ::= flow_collection | SCALAR
    # block_collection  ::= block_sequence | block_mapping
    # flow_collection   ::= flow_sequence | flow_mapping

    def parse_block_node(self):
        return self.parse_node(block=True)

    def parse_flow_node(self):
        return self.parse_node()

    def parse_block_node_or_indentless_sequence(self):
        return self.parse_node(block=True, indentless_sequence=True)

    def parse_node(self, block=False, indentless_sequence=False):
        if self.check_token(AliasToken):
            token = self.get_token()
            event = AliasEvent(token.value, token.start_mark, token.end_mark)
            self.state = self.states.pop()
        else:
            anchor = None
            tag = None
            start_mark = end_mark = tag_mark = None
            if self.check_token(AnchorToken):
                token = self.get_token()
                start_mark = token.start_mark
                end_mark = token.end_mark
                anchor = token.value
                if self.check_token(TagToken):
                    token = self.get_token()
                    tag_mark = token.start_mark
                    end_mark = token.end_mark
                    tag = token.value
            elif self.check_token(TagToken):
                token = self.get_token()
                start_mark = tag_mark = token.start_mark
                end_mark = token.end_mark
                tag = token.value
                if self.check_token(AnchorToken):
                    token = self.get_token()
                    end_mark = token.end_mark
                    anchor = token.value
            if tag is not None:
                handle, suffix = tag
                if handle is not None:
                    if handle not in self.tag_handles:
                        raise ParserError("while parsing a node", start_mark,
                                "found undefined tag handle %r" % handle,
                                tag_mark)
                    tag = self.tag_handles[handle]+suffix
                else:
                    tag = suffix
            #if tag == '!':
            #    raise ParserError("while parsing a node", start_mark,
            #            "found non-specific tag '!'", tag_mark,
            #            "Please check 'http://pyyaml.org/wiki/YAMLNonSpecificTag' and share your opinion.")
            if start_mark is None:
                start_mark = end_mark = self.peek_token().start_mark
            event = None
            implicit = (tag is None or tag == '!')
            if indentless_sequence and self.check_token(BlockEntryToken):
                end_mark = self.peek_token().end_mark
                event = SequenceStartEvent(anchor, tag, implicit,
                        start_mark, end_mark)
                self.state = self.parse_indentless_sequence_entry
            else:
                if self.check_token(ScalarToken):
                    token = self.get_token()
                    end_mark = token.end_mark
                    if (token.plain and tag is None) or tag == '!':
                        implicit = (True, False)
                    elif tag is None:
                        implicit = (False, True)
                    else:
                        implicit = (False, False)
                    event = ScalarEvent(anchor, tag, implicit, token.value,
                            start_mark, end_mark, style=token.style)
                    self.state = self.states.pop()
                elif self.check_token(FlowSequenceStartToken):
                    end_mark = self.peek_token().end_mark
                    event = SequenceStartEvent(anchor, tag, implicit,
                            start_mark, end_mark, flow_style=True)
                    self.state = self.parse_flow_sequence_first_entry
                elif self.check_token(FlowMappingStartToken):
                    end_mark = self.peek_token().end_mark
                    event = MappingStartEvent(anchor, tag, implicit,
                            start_mark, end_mark, flow_style=True)
                    self.state = self.parse_flow_mapping_first_key
                elif block and self.check_token(BlockSequenceStartToken):
                    end_mark = self.peek_token().start_mark
                    event = SequenceStartEvent(anchor, tag, implicit,
                            start_mark, end_mark, flow_style=False)
                    self.state = self.parse_block_sequence_first_entry
                elif block and self.check_token(BlockMappingStartToken):
                    end_mark = self.peek_token().start_mark
                    event = MappingStartEvent(anchor, tag, implicit,
                            start_mark, end_mark, flow_style=False)
                    self.state = self.parse_block_mapping_first_key
                elif anchor is not None or tag is not None:
                    # Empty scalars are allowed even if a tag or an anchor is
                    # specified.
                    event = ScalarEvent(anchor, tag, (implicit, False), '',
                            start_mark, end_mark)
                    self.state = self.states.pop()
                else:
                    if block:
                        node = 'block'
                    else:
                        node = 'flow'
                    token = self.peek_token()
                    raise ParserError("while parsing a %s node" % node, start_mark,
                            "expected the node content, but found %r" % token.id,
                            token.start_mark)
        return event

    # block_sequence ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END

    def parse_block_sequence_first_entry(self):
        token = self.get_token()
        self.marks.append(token.start_mark)
        return self.parse_block_sequence_entry()

    def parse_block_sequence_entry(self):
        if self.check_token(BlockEntryToken):
            token = self.get_token()
            if not self.check_token(BlockEntryToken, BlockEndToken):
                self.states.append(self.parse_block_sequence_entry)
                return self.parse_block_node()
            else:
                self.state = self.parse_block_sequence_entry
                return self.process_empty_scalar(token.end_mark)
        if not self.check_token(BlockEndToken):
            token = self.peek_token()
            raise ParserError("while parsing a block collection", self.marks[-1],
                    "expected <block end>, but found %r" % token.id, token.start_mark)
        token = self.get_token()
        event = SequenceEndEvent(token.start_mark, token.end_mark)
        self.state = self.states.pop()
        self.marks.pop()
        return event

    # indentless_sequence ::= (BLOCK-ENTRY block_node?)+

    def parse_indentless_sequence_entry(self):
        if self.check_token(BlockEntryToken):
            token = self.get_token()
            if not self.check_token(BlockEntryToken,
                    KeyToken, ValueToken, BlockEndToken):
                self.states.append(self.parse_indentless_sequence_entry)
                return self.parse_block_node()
            else:
                self.state = self.parse_indentless_sequence_entry
                return self.process_empty_scalar(token.end_mark)
        token = self.peek_token()
        event = SequenceEndEvent(token.start_mark, token.start_mark)
        self.state = self.states.pop()
        return event

    # block_mapping     ::= BLOCK-MAPPING_START
    #                       ((KEY block_node_or_indentless_sequence?)?
    #                       (VALUE block_node_or_indentless_sequence?)?)*
    #                       BLOCK-END

    def parse_block_mapping_first_key(self):
        token = self.get_token()
        self.marks.append(token.start_mark)
        return self.parse_block_mapping_key()

    def parse_block_mapping_key(self):
        if self.check_token(KeyToken):
            token = self.get_token()
            if not self.check_token(KeyToken, ValueToken, BlockEndToken):
                self.states.append(self.parse_block_mapping_value)
                return self.parse_block_node_or_indentless_sequence()
            else:
                self.state = self.parse_block_mapping_value
                return self.process_empty_scalar(token.end_mark)
        if not self.check_token(BlockEndToken):
            token = self.peek_token()
            raise ParserError("while parsing a block mapping", self.marks[-1],
                    "expected <block end>, but found %r" % token.id, token.start_mark)
        token = self.get_token()
        event = MappingEndEvent(token.start_mark, token.end_mark)
        self.state = self.states.pop()
        self.marks.pop()
        return event

    def parse_block_mapping_value(self):
        if self.check_token(ValueToken):
            token = self.get_token()
            if not self.check_token(KeyToken, ValueToken, BlockEndToken):
                self.states.append(self.parse_block_mapping_key)
                return self.parse_block_node_or_indentless_sequence()
            else:
                self.state = self.parse_block_mapping_key
                return self.process_empty_scalar(token.end_mark)
        else:
            self.state = self.parse_block_mapping_key
            token = self.peek_token()
            return self.process_empty_scalar(token.start_mark)

    # flow_sequence     ::= FLOW-SEQUENCE-START
    #                       (flow_sequence_entry FLOW-ENTRY)*
    #                       flow_sequence_entry?
    #                       FLOW-SEQUENCE-END
    # flow_sequence_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
    #
    # Note that while production rules for both flow_sequence_entry and
    # flow_mapping_entry are equal, their interpretations are different.
    # For `flow_sequence_entry`, the part `KEY flow_node? (VALUE flow_node?)?`
    # generate an inline mapping (set syntax).

    def parse_flow_sequence_first_entry(self):
        token = self.get_token()
        self.marks.append(token.start_mark)
        return self.parse_flow_sequence_entry(first=True)

    def parse_flow_sequence_entry(self, first=False):
        if not self.check_token(FlowSequenceEndToken):
            if not first:
                if self.check_token(FlowEntryToken):
                    self.get_token()
                else:
                    token = self.peek_token()
                    raise ParserError("while parsing a flow sequence", self.marks[-1],
                            "expected ',' or ']', but got %r" % token.id, token.start_mark)
            
            if self.check_token(KeyToken):
                token = self.peek_token()
                event = MappingStartEvent(None, None, True,
                        token.start_mark, token.end_mark,
                        flow_style=True)
                self.state = self.parse_flow_sequence_entry_mapping_key
                return event
            elif not self.check_token(FlowSequenceEndToken):
                self.states.append(self.parse_flow_sequence_entry)
                return self.parse_flow_node()
        token = self.get_token()
        event = SequenceEndEvent(token.start_mark, token.end_mark)
        self.state = self.states.pop()
        self.marks.pop()
        return event

    def parse_flow_sequence_entry_mapping_key(self):
        token = self.get_token()
        if not self.check_token(ValueToken,
                FlowEntryToken, FlowSequenceEndToken):
            self.states.append(self.parse_flow_sequence_entry_mapping_value)
            return self.parse_flow_node()
        else:
            self.state = self.parse_flow_sequence_entry_mapping_value
            return self.process_empty_scalar(token.end_mark)

    def parse_flow_sequence_entry_mapping_value(self):
        if self.check_token(ValueToken):
            token = self.get_token()
            if not self.check_token(FlowEntryToken, FlowSequenceEndToken):
                self.states.append(self.parse_flow_sequence_entry_mapping_end)
                return self.parse_flow_node()
            else:
                self.state = self.parse_flow_sequence_entry_mapping_end
                return self.process_empty_scalar(token.end_mark)
        else:
            self.state = self.parse_flow_sequence_entry_mapping_end
            token = self.peek_token()
            return self.process_empty_scalar(token.start_mark)

    def parse_flow_sequence_entry_mapping_end(self):
        self.state = self.parse_flow_sequence_entry
        token = self.peek_token()
        return MappingEndEvent(token.start_mark, token.start_mark)

    # flow_mapping  ::= FLOW-MAPPING-START
    #                   (flow_mapping_entry FLOW-ENTRY)*
    #                   flow_mapping_entry?
    #                   FLOW-MAPPING-END
    # flow_mapping_entry    ::= flow_node | KEY flow_node? (VALUE flow_node?)?

    def parse_flow_mapping_first_key(self):
        token = self.get_token()
        self.marks.append(token.start_mark)
        return self.parse_flow_mapping_key(first=True)

    def parse_flow_mapping_key(self, first=False):
        if not self.check_token(FlowMappingEndToken):
            if not first:
                if self.check_token(FlowEntryToken):
                    self.get_token()
                else:
                    token = self.peek_token()
                    raise ParserError("while parsing a flow mapping", self.marks[-1],
                            "expected ',' or '}', but got %r" % token.id, token.start_mark)
            if self.check_token(KeyToken):
                token = self.get_token()
                if not self.check_token(ValueToken,
                        FlowEntryToken, FlowMappingEndToken):
                    self.states.append(self.parse_flow_mapping_value)
                    return self.parse_flow_node()
                else:
                    self.state = self.parse_flow_mapping_value
                    return self.process_empty_scalar(token.end_mark)
            elif not self.check_token(FlowMappingEndToken):
                self.states.append(self.parse_flow_mapping_empty_value)
                return self.parse_flow_node()
        token = self.get_token()
        event = MappingEndEvent(token.start_mark, token.end_mark)
        self.state = self.states.pop()
        self.marks.pop()
        return event

    def parse_flow_mapping_value(self):
        if self.check_token(ValueToken):
            token = self.get_token()
            if not self.check_token(FlowEntryToken, FlowMappingEndToken):
                self.states.append(self.parse_flow_mapping_key)
                return self.parse_flow_node()
            else:
                self.state = self.parse_flow_mapping_key
                return self.process_empty_scalar(token.end_mark)
        else:
            self.state = self.parse_flow_mapping_key
            token = self.peek_token()
            return self.process_empty_scalar(token.start_mark)

    def parse_flow_mapping_empty_value(self):
        self.state = self.parse_flow_mapping_key
        return self.process_empty_scalar(self.peek_token().start_mark)

    def process_empty_scalar(self, mark):
        return ScalarEvent(None, None, (True, False), '', mark, mark)


########NEW FILE########
__FILENAME__ = reader
# This module contains abstractions for the input stream. You don't have to
# looks further, there are no pretty code.
#
# We define two classes here.
#
#   Mark(source, line, column)
# It's just a record and its only use is producing nice error messages.
# Parser does not use it for any other purposes.
#
#   Reader(source, data)
# Reader determines the encoding of `data` and converts it to unicode.
# Reader provides the following methods and attributes:
#   reader.peek(length=1) - return the next `length` characters
#   reader.forward(length=1) - move the current position to `length` characters.
#   reader.index - the number of the current character.
#   reader.line, stream.column - the line and the column of the current character.

__all__ = ['Reader', 'ReaderError']

from .error import YAMLError, Mark

import codecs, re

class ReaderError(YAMLError):

    def __init__(self, name, position, character, encoding, reason):
        self.name = name
        self.character = character
        self.position = position
        self.encoding = encoding
        self.reason = reason

    def __str__(self):
        if isinstance(self.character, bytes):
            return "'%s' codec can't decode byte #x%02x: %s\n"  \
                    "  in \"%s\", position %d"    \
                    % (self.encoding, ord(self.character), self.reason,
                            self.name, self.position)
        else:
            return "unacceptable character #x%04x: %s\n"    \
                    "  in \"%s\", position %d"    \
                    % (self.character, self.reason,
                            self.name, self.position)

class Reader(object):
    # Reader:
    # - determines the data encoding and converts it to a unicode string,
    # - checks if characters are in allowed range,
    # - adds '\0' to the end.

    # Reader accepts
    #  - a `bytes` object,
    #  - a `str` object,
    #  - a file-like object with its `read` method returning `str`,
    #  - a file-like object with its `read` method returning `unicode`.

    # Yeah, it's ugly and slow.

    def __init__(self, stream):
        self.name = None
        self.stream = None
        self.stream_pointer = 0
        self.eof = True
        self.buffer = ''
        self.pointer = 0
        self.raw_buffer = None
        self.raw_decode = None
        self.encoding = None
        self.index = 0
        self.line = 0
        self.column = 0
        if isinstance(stream, str):
            self.name = "<unicode string>"
            self.check_printable(stream)
            self.buffer = stream+'\0'
        elif isinstance(stream, bytes):
            self.name = "<byte string>"
            self.raw_buffer = stream
            self.determine_encoding()
        else:
            self.stream = stream
            self.name = getattr(stream, 'name', "<file>")
            self.eof = False
            self.raw_buffer = None
            self.determine_encoding()

    def peek(self, index=0):
        try:
            return self.buffer[self.pointer+index]
        except IndexError:
            self.update(index+1)
            return self.buffer[self.pointer+index]

    def prefix(self, length=1):
        if self.pointer+length >= len(self.buffer):
            self.update(length)
        return self.buffer[self.pointer:self.pointer+length]

    def forward(self, length=1):
        if self.pointer+length+1 >= len(self.buffer):
            self.update(length+1)
        while length:
            ch = self.buffer[self.pointer]
            self.pointer += 1
            self.index += 1
            if ch in '\n\x85\u2028\u2029'  \
                    or (ch == '\r' and self.buffer[self.pointer] != '\n'):
                self.line += 1
                self.column = 0
            elif ch != '\uFEFF':
                self.column += 1
            length -= 1

    def get_mark(self):
        if self.stream is None:
            return Mark(self.name, self.index, self.line, self.column,
                    self.buffer, self.pointer)
        else:
            return Mark(self.name, self.index, self.line, self.column,
                    None, None)

    def determine_encoding(self):
        while not self.eof and (self.raw_buffer is None or len(self.raw_buffer) < 2):
            self.update_raw()
        if isinstance(self.raw_buffer, bytes):
            if self.raw_buffer.startswith(codecs.BOM_UTF16_LE):
                self.raw_decode = codecs.utf_16_le_decode
                self.encoding = 'utf-16-le'
            elif self.raw_buffer.startswith(codecs.BOM_UTF16_BE):
                self.raw_decode = codecs.utf_16_be_decode
                self.encoding = 'utf-16-be'
            else:
                self.raw_decode = codecs.utf_8_decode
                self.encoding = 'utf-8'
        self.update(1)

    NON_PRINTABLE = re.compile('[^\x09\x0A\x0D\x20-\x7E\x85\xA0-\uD7FF\uE000-\uFFFD]')
    def check_printable(self, data):
        match = self.NON_PRINTABLE.search(data)
        if match:
            character = match.group()
            position = self.index+(len(self.buffer)-self.pointer)+match.start()
            raise ReaderError(self.name, position, ord(character),
                    'unicode', "special characters are not allowed")

    def update(self, length):
        if self.raw_buffer is None:
            return
        self.buffer = self.buffer[self.pointer:]
        self.pointer = 0
        while len(self.buffer) < length:
            if not self.eof:
                self.update_raw()
            if self.raw_decode is not None:
                try:
                    data, converted = self.raw_decode(self.raw_buffer,
                            'strict', self.eof)
                except UnicodeDecodeError as exc:
                    character = self.raw_buffer[exc.start]
                    if self.stream is not None:
                        position = self.stream_pointer-len(self.raw_buffer)+exc.start
                    else:
                        position = exc.start
                    raise ReaderError(self.name, position, character,
                            exc.encoding, exc.reason)
            else:
                data = self.raw_buffer
                converted = len(data)
            self.check_printable(data)
            self.buffer += data
            self.raw_buffer = self.raw_buffer[converted:]
            if self.eof:
                self.buffer += '\0'
                self.raw_buffer = None
                break

    def update_raw(self, size=4096):
        data = self.stream.read(size)
        if self.raw_buffer is None:
            self.raw_buffer = data
        else:
            self.raw_buffer += data
        self.stream_pointer += len(data)
        if not data:
            self.eof = True

#try:
#    import psyco
#    psyco.bind(Reader)
#except ImportError:
#    pass


########NEW FILE########
__FILENAME__ = representer

__all__ = ['BaseRepresenter', 'SafeRepresenter', 'Representer',
    'RepresenterError']

from .error import *
from .nodes import *

import datetime, sys, copyreg, types, base64

class RepresenterError(YAMLError):
    pass

class BaseRepresenter:

    yaml_representers = {}
    yaml_multi_representers = {}

    def __init__(self, default_style=None, default_flow_style=None):
        self.default_style = default_style
        self.default_flow_style = default_flow_style
        self.represented_objects = {}
        self.object_keeper = []
        self.alias_key = None

    def represent(self, data):
        node = self.represent_data(data)
        self.serialize(node)
        self.represented_objects = {}
        self.object_keeper = []
        self.alias_key = None

    def represent_data(self, data):
        if self.ignore_aliases(data):
            self.alias_key = None
        else:
            self.alias_key = id(data)
        if self.alias_key is not None:
            if self.alias_key in self.represented_objects:
                node = self.represented_objects[self.alias_key]
                #if node is None:
                #    raise RepresenterError("recursive objects are not allowed: %r" % data)
                return node
            #self.represented_objects[alias_key] = None
            self.object_keeper.append(data)
        data_types = type(data).__mro__
        if data_types[0] in self.yaml_representers:
            node = self.yaml_representers[data_types[0]](self, data)
        else:
            for data_type in data_types:
                if data_type in self.yaml_multi_representers:
                    node = self.yaml_multi_representers[data_type](self, data)
                    break
            else:
                if None in self.yaml_multi_representers:
                    node = self.yaml_multi_representers[None](self, data)
                elif None in self.yaml_representers:
                    node = self.yaml_representers[None](self, data)
                else:
                    node = ScalarNode(None, str(data))
        #if alias_key is not None:
        #    self.represented_objects[alias_key] = node
        return node

    @classmethod
    def add_representer(cls, data_type, representer):
        if not 'yaml_representers' in cls.__dict__:
            cls.yaml_representers = cls.yaml_representers.copy()
        cls.yaml_representers[data_type] = representer

    @classmethod
    def add_multi_representer(cls, data_type, representer):
        if not 'yaml_multi_representers' in cls.__dict__:
            cls.yaml_multi_representers = cls.yaml_multi_representers.copy()
        cls.yaml_multi_representers[data_type] = representer

    def represent_scalar(self, tag, value, style=None):
        if style is None:
            style = self.default_style
        node = ScalarNode(tag, value, style=style)
        if self.alias_key is not None:
            self.represented_objects[self.alias_key] = node
        return node

    def represent_sequence(self, tag, sequence, flow_style=None):
        value = []
        node = SequenceNode(tag, value, flow_style=flow_style)
        if self.alias_key is not None:
            self.represented_objects[self.alias_key] = node
        best_style = True
        for item in sequence:
            node_item = self.represent_data(item)
            if not (isinstance(node_item, ScalarNode) and not node_item.style):
                best_style = False
            value.append(node_item)
        if flow_style is None:
            if self.default_flow_style is not None:
                node.flow_style = self.default_flow_style
            else:
                node.flow_style = best_style
        return node

    def represent_mapping(self, tag, mapping, flow_style=None):
        value = []
        node = MappingNode(tag, value, flow_style=flow_style)
        if self.alias_key is not None:
            self.represented_objects[self.alias_key] = node
        best_style = True
        if hasattr(mapping, 'items'):
            mapping = list(mapping.items())
            try:
                mapping = sorted(mapping)
            except TypeError:
                pass
        for item_key, item_value in mapping:
            node_key = self.represent_data(item_key)
            node_value = self.represent_data(item_value)
            if not (isinstance(node_key, ScalarNode) and not node_key.style):
                best_style = False
            if not (isinstance(node_value, ScalarNode) and not node_value.style):
                best_style = False
            value.append((node_key, node_value))
        if flow_style is None:
            if self.default_flow_style is not None:
                node.flow_style = self.default_flow_style
            else:
                node.flow_style = best_style
        return node

    def ignore_aliases(self, data):
        return False

class SafeRepresenter(BaseRepresenter):

    def ignore_aliases(self, data):
        if data in [None, ()]:
            return True
        if isinstance(data, (str, bytes, bool, int, float)):
            return True

    def represent_none(self, data):
        return self.represent_scalar('tag:yaml.org,2002:null', 'null')

    def represent_str(self, data):
        return self.represent_scalar('tag:yaml.org,2002:str', data)

    def represent_binary(self, data):
        if hasattr(base64, 'encodebytes'):
            data = base64.encodebytes(data).decode('ascii')
        else:
            data = base64.encodestring(data).decode('ascii')
        return self.represent_scalar('tag:yaml.org,2002:binary', data, style='|')

    def represent_bool(self, data):
        if data:
            value = 'true'
        else:
            value = 'false'
        return self.represent_scalar('tag:yaml.org,2002:bool', value)

    def represent_int(self, data):
        return self.represent_scalar('tag:yaml.org,2002:int', str(data))

    inf_value = 1e300
    while repr(inf_value) != repr(inf_value*inf_value):
        inf_value *= inf_value

    def represent_float(self, data):
        if data != data or (data == 0.0 and data == 1.0):
            value = '.nan'
        elif data == self.inf_value:
            value = '.inf'
        elif data == -self.inf_value:
            value = '-.inf'
        else:
            value = repr(data).lower()
            # Note that in some cases `repr(data)` represents a float number
            # without the decimal parts.  For instance:
            #   >>> repr(1e17)
            #   '1e17'
            # Unfortunately, this is not a valid float representation according
            # to the definition of the `!!float` tag.  We fix this by adding
            # '.0' before the 'e' symbol.
            if '.' not in value and 'e' in value:
                value = value.replace('e', '.0e', 1)
        return self.represent_scalar('tag:yaml.org,2002:float', value)

    def represent_list(self, data):
        #pairs = (len(data) > 0 and isinstance(data, list))
        #if pairs:
        #    for item in data:
        #        if not isinstance(item, tuple) or len(item) != 2:
        #            pairs = False
        #            break
        #if not pairs:
            return self.represent_sequence('tag:yaml.org,2002:seq', data)
        #value = []
        #for item_key, item_value in data:
        #    value.append(self.represent_mapping(u'tag:yaml.org,2002:map',
        #        [(item_key, item_value)]))
        #return SequenceNode(u'tag:yaml.org,2002:pairs', value)

    def represent_dict(self, data):
        return self.represent_mapping('tag:yaml.org,2002:map', data)

    def represent_set(self, data):
        value = {}
        for key in data:
            value[key] = None
        return self.represent_mapping('tag:yaml.org,2002:set', value)

    def represent_date(self, data):
        value = data.isoformat()
        return self.represent_scalar('tag:yaml.org,2002:timestamp', value)

    def represent_datetime(self, data):
        value = data.isoformat(' ')
        return self.represent_scalar('tag:yaml.org,2002:timestamp', value)

    def represent_yaml_object(self, tag, data, cls, flow_style=None):
        if hasattr(data, '__getstate__'):
            state = data.__getstate__()
        else:
            state = data.__dict__.copy()
        return self.represent_mapping(tag, state, flow_style=flow_style)

    def represent_undefined(self, data):
        raise RepresenterError("cannot represent an object: %s" % data)

SafeRepresenter.add_representer(type(None),
        SafeRepresenter.represent_none)

SafeRepresenter.add_representer(str,
        SafeRepresenter.represent_str)

SafeRepresenter.add_representer(bytes,
        SafeRepresenter.represent_binary)

SafeRepresenter.add_representer(bool,
        SafeRepresenter.represent_bool)

SafeRepresenter.add_representer(int,
        SafeRepresenter.represent_int)

SafeRepresenter.add_representer(float,
        SafeRepresenter.represent_float)

SafeRepresenter.add_representer(list,
        SafeRepresenter.represent_list)

SafeRepresenter.add_representer(tuple,
        SafeRepresenter.represent_list)

SafeRepresenter.add_representer(dict,
        SafeRepresenter.represent_dict)

SafeRepresenter.add_representer(set,
        SafeRepresenter.represent_set)

SafeRepresenter.add_representer(datetime.date,
        SafeRepresenter.represent_date)

SafeRepresenter.add_representer(datetime.datetime,
        SafeRepresenter.represent_datetime)

SafeRepresenter.add_representer(None,
        SafeRepresenter.represent_undefined)

class Representer(SafeRepresenter):

    def represent_complex(self, data):
        if data.imag == 0.0:
            data = '%r' % data.real
        elif data.real == 0.0:
            data = '%rj' % data.imag
        elif data.imag > 0:
            data = '%r+%rj' % (data.real, data.imag)
        else:
            data = '%r%rj' % (data.real, data.imag)
        return self.represent_scalar('tag:yaml.org,2002:python/complex', data)

    def represent_tuple(self, data):
        return self.represent_sequence('tag:yaml.org,2002:python/tuple', data)

    def represent_name(self, data):
        name = '%s.%s' % (data.__module__, data.__name__)
        return self.represent_scalar('tag:yaml.org,2002:python/name:'+name, '')

    def represent_module(self, data):
        return self.represent_scalar(
                'tag:yaml.org,2002:python/module:'+data.__name__, '')

    def represent_object(self, data):
        # We use __reduce__ API to save the data. data.__reduce__ returns
        # a tuple of length 2-5:
        #   (function, args, state, listitems, dictitems)

        # For reconstructing, we calls function(*args), then set its state,
        # listitems, and dictitems if they are not None.

        # A special case is when function.__name__ == '__newobj__'. In this
        # case we create the object with args[0].__new__(*args).

        # Another special case is when __reduce__ returns a string - we don't
        # support it.

        # We produce a !!python/object, !!python/object/new or
        # !!python/object/apply node.

        cls = type(data)
        if cls in copyreg.dispatch_table:
            reduce = copyreg.dispatch_table[cls](data)
        elif hasattr(data, '__reduce_ex__'):
            reduce = data.__reduce_ex__(2)
        elif hasattr(data, '__reduce__'):
            reduce = data.__reduce__()
        else:
            raise RepresenterError("cannot represent object: %r" % data)
        reduce = (list(reduce)+[None]*5)[:5]
        function, args, state, listitems, dictitems = reduce
        args = list(args)
        if state is None:
            state = {}
        if listitems is not None:
            listitems = list(listitems)
        if dictitems is not None:
            dictitems = dict(dictitems)
        if function.__name__ == '__newobj__':
            function = args[0]
            args = args[1:]
            tag = 'tag:yaml.org,2002:python/object/new:'
            newobj = True
        else:
            tag = 'tag:yaml.org,2002:python/object/apply:'
            newobj = False
        function_name = '%s.%s' % (function.__module__, function.__name__)
        if not args and not listitems and not dictitems \
                and isinstance(state, dict) and newobj:
            return self.represent_mapping(
                    'tag:yaml.org,2002:python/object:'+function_name, state)
        if not listitems and not dictitems  \
                and isinstance(state, dict) and not state:
            return self.represent_sequence(tag+function_name, args)
        value = {}
        if args:
            value['args'] = args
        if state or not isinstance(state, dict):
            value['state'] = state
        if listitems:
            value['listitems'] = listitems
        if dictitems:
            value['dictitems'] = dictitems
        return self.represent_mapping(tag+function_name, value)

Representer.add_representer(complex,
        Representer.represent_complex)

Representer.add_representer(tuple,
        Representer.represent_tuple)

Representer.add_representer(type,
        Representer.represent_name)

Representer.add_representer(types.FunctionType,
        Representer.represent_name)

Representer.add_representer(types.BuiltinFunctionType,
        Representer.represent_name)

Representer.add_representer(types.ModuleType,
        Representer.represent_module)

Representer.add_multi_representer(object,
        Representer.represent_object)


########NEW FILE########
__FILENAME__ = resolver

__all__ = ['BaseResolver', 'Resolver']

from .error import *
from .nodes import *

import re

class ResolverError(YAMLError):
    pass

class BaseResolver:

    DEFAULT_SCALAR_TAG = 'tag:yaml.org,2002:str'
    DEFAULT_SEQUENCE_TAG = 'tag:yaml.org,2002:seq'
    DEFAULT_MAPPING_TAG = 'tag:yaml.org,2002:map'

    yaml_implicit_resolvers = {}
    yaml_path_resolvers = {}

    def __init__(self):
        self.resolver_exact_paths = []
        self.resolver_prefix_paths = []

    @classmethod
    def add_implicit_resolver(cls, tag, regexp, first):
        if not 'yaml_implicit_resolvers' in cls.__dict__:
            cls.yaml_implicit_resolvers = cls.yaml_implicit_resolvers.copy()
        if first is None:
            first = [None]
        for ch in first:
            cls.yaml_implicit_resolvers.setdefault(ch, []).append((tag, regexp))

    @classmethod
    def add_path_resolver(cls, tag, path, kind=None):
        # Note: `add_path_resolver` is experimental.  The API could be changed.
        # `new_path` is a pattern that is matched against the path from the
        # root to the node that is being considered.  `node_path` elements are
        # tuples `(node_check, index_check)`.  `node_check` is a node class:
        # `ScalarNode`, `SequenceNode`, `MappingNode` or `None`.  `None`
        # matches any kind of a node.  `index_check` could be `None`, a boolean
        # value, a string value, or a number.  `None` and `False` match against
        # any _value_ of sequence and mapping nodes.  `True` matches against
        # any _key_ of a mapping node.  A string `index_check` matches against
        # a mapping value that corresponds to a scalar key which content is
        # equal to the `index_check` value.  An integer `index_check` matches
        # against a sequence value with the index equal to `index_check`.
        if not 'yaml_path_resolvers' in cls.__dict__:
            cls.yaml_path_resolvers = cls.yaml_path_resolvers.copy()
        new_path = []
        for element in path:
            if isinstance(element, (list, tuple)):
                if len(element) == 2:
                    node_check, index_check = element
                elif len(element) == 1:
                    node_check = element[0]
                    index_check = True
                else:
                    raise ResolverError("Invalid path element: %s" % element)
            else:
                node_check = None
                index_check = element
            if node_check is str:
                node_check = ScalarNode
            elif node_check is list:
                node_check = SequenceNode
            elif node_check is dict:
                node_check = MappingNode
            elif node_check not in [ScalarNode, SequenceNode, MappingNode]  \
                    and not isinstance(node_check, str) \
                    and node_check is not None:
                raise ResolverError("Invalid node checker: %s" % node_check)
            if not isinstance(index_check, (str, int))  \
                    and index_check is not None:
                raise ResolverError("Invalid index checker: %s" % index_check)
            new_path.append((node_check, index_check))
        if kind is str:
            kind = ScalarNode
        elif kind is list:
            kind = SequenceNode
        elif kind is dict:
            kind = MappingNode
        elif kind not in [ScalarNode, SequenceNode, MappingNode]    \
                and kind is not None:
            raise ResolverError("Invalid node kind: %s" % kind)
        cls.yaml_path_resolvers[tuple(new_path), kind] = tag

    def descend_resolver(self, current_node, current_index):
        if not self.yaml_path_resolvers:
            return
        exact_paths = {}
        prefix_paths = []
        if current_node:
            depth = len(self.resolver_prefix_paths)
            for path, kind in self.resolver_prefix_paths[-1]:
                if self.check_resolver_prefix(depth, path, kind,
                        current_node, current_index):
                    if len(path) > depth:
                        prefix_paths.append((path, kind))
                    else:
                        exact_paths[kind] = self.yaml_path_resolvers[path, kind]
        else:
            for path, kind in self.yaml_path_resolvers:
                if not path:
                    exact_paths[kind] = self.yaml_path_resolvers[path, kind]
                else:
                    prefix_paths.append((path, kind))
        self.resolver_exact_paths.append(exact_paths)
        self.resolver_prefix_paths.append(prefix_paths)

    def ascend_resolver(self):
        if not self.yaml_path_resolvers:
            return
        self.resolver_exact_paths.pop()
        self.resolver_prefix_paths.pop()

    def check_resolver_prefix(self, depth, path, kind,
            current_node, current_index):
        node_check, index_check = path[depth-1]
        if isinstance(node_check, str):
            if current_node.tag != node_check:
                return
        elif node_check is not None:
            if not isinstance(current_node, node_check):
                return
        if index_check is True and current_index is not None:
            return
        if (index_check is False or index_check is None)    \
                and current_index is None:
            return
        if isinstance(index_check, str):
            if not (isinstance(current_index, ScalarNode)
                    and index_check == current_index.value):
                return
        elif isinstance(index_check, int) and not isinstance(index_check, bool):
            if index_check != current_index:
                return
        return True

    def resolve(self, kind, value, implicit):
        if kind is ScalarNode and implicit[0]:
            if value == '':
                resolvers = self.yaml_implicit_resolvers.get('', [])
            else:
                resolvers = self.yaml_implicit_resolvers.get(value[0], [])
            resolvers += self.yaml_implicit_resolvers.get(None, [])
            for tag, regexp in resolvers:
                if regexp.match(value):
                    return tag
            implicit = implicit[1]
        if self.yaml_path_resolvers:
            exact_paths = self.resolver_exact_paths[-1]
            if kind in exact_paths:
                return exact_paths[kind]
            if None in exact_paths:
                return exact_paths[None]
        if kind is ScalarNode:
            return self.DEFAULT_SCALAR_TAG
        elif kind is SequenceNode:
            return self.DEFAULT_SEQUENCE_TAG
        elif kind is MappingNode:
            return self.DEFAULT_MAPPING_TAG

class Resolver(BaseResolver):
    pass

Resolver.add_implicit_resolver(
        'tag:yaml.org,2002:bool',
        re.compile(r'''^(?:yes|Yes|YES|no|No|NO
                    |true|True|TRUE|false|False|FALSE
                    |on|On|ON|off|Off|OFF)$''', re.X),
        list('yYnNtTfFoO'))

Resolver.add_implicit_resolver(
        'tag:yaml.org,2002:float',
        re.compile(r'''^(?:[-+]?(?:[0-9][0-9_]*)\.[0-9_]*(?:[eE][-+][0-9]+)?
                    |\.[0-9_]+(?:[eE][-+][0-9]+)?
                    |[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*
                    |[-+]?\.(?:inf|Inf|INF)
                    |\.(?:nan|NaN|NAN))$''', re.X),
        list('-+0123456789.'))

Resolver.add_implicit_resolver(
        'tag:yaml.org,2002:int',
        re.compile(r'''^(?:[-+]?0b[0-1_]+
                    |[-+]?0[0-7_]+
                    |[-+]?(?:0|[1-9][0-9_]*)
                    |[-+]?0x[0-9a-fA-F_]+
                    |[-+]?[1-9][0-9_]*(?::[0-5]?[0-9])+)$''', re.X),
        list('-+0123456789'))

Resolver.add_implicit_resolver(
        'tag:yaml.org,2002:merge',
        re.compile(r'^(?:<<)$'),
        ['<'])

Resolver.add_implicit_resolver(
        'tag:yaml.org,2002:null',
        re.compile(r'''^(?: ~
                    |null|Null|NULL
                    | )$''', re.X),
        ['~', 'n', 'N', ''])

Resolver.add_implicit_resolver(
        'tag:yaml.org,2002:timestamp',
        re.compile(r'''^(?:[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]
                    |[0-9][0-9][0-9][0-9] -[0-9][0-9]? -[0-9][0-9]?
                     (?:[Tt]|[ \t]+)[0-9][0-9]?
                     :[0-9][0-9] :[0-9][0-9] (?:\.[0-9]*)?
                     (?:[ \t]*(?:Z|[-+][0-9][0-9]?(?::[0-9][0-9])?))?)$''', re.X),
        list('0123456789'))

Resolver.add_implicit_resolver(
        'tag:yaml.org,2002:value',
        re.compile(r'^(?:=)$'),
        ['='])

# The following resolver is only for documentation purposes. It cannot work
# because plain scalars cannot start with '!', '&', or '*'.
Resolver.add_implicit_resolver(
        'tag:yaml.org,2002:yaml',
        re.compile(r'^(?:!|&|\*)$'),
        list('!&*'))


########NEW FILE########
__FILENAME__ = scanner

# Scanner produces tokens of the following types:
# STREAM-START
# STREAM-END
# DIRECTIVE(name, value)
# DOCUMENT-START
# DOCUMENT-END
# BLOCK-SEQUENCE-START
# BLOCK-MAPPING-START
# BLOCK-END
# FLOW-SEQUENCE-START
# FLOW-MAPPING-START
# FLOW-SEQUENCE-END
# FLOW-MAPPING-END
# BLOCK-ENTRY
# FLOW-ENTRY
# KEY
# VALUE
# ALIAS(value)
# ANCHOR(value)
# TAG(value)
# SCALAR(value, plain, style)
#
# Read comments in the Scanner code for more details.
#

__all__ = ['Scanner', 'ScannerError']

from .error import MarkedYAMLError
from .tokens import *

class ScannerError(MarkedYAMLError):
    pass

class SimpleKey:
    # See below simple keys treatment.

    def __init__(self, token_number, required, index, line, column, mark):
        self.token_number = token_number
        self.required = required
        self.index = index
        self.line = line
        self.column = column
        self.mark = mark

class Scanner:

    def __init__(self):
        """Initialize the scanner."""
        # It is assumed that Scanner and Reader will have a common descendant.
        # Reader do the dirty work of checking for BOM and converting the
        # input data to Unicode. It also adds NUL to the end.
        #
        # Reader supports the following methods
        #   self.peek(i=0)       # peek the next i-th character
        #   self.prefix(l=1)     # peek the next l characters
        #   self.forward(l=1)    # read the next l characters and move the pointer.

        # Had we reached the end of the stream?
        self.done = False

        # The number of unclosed '{' and '['. `flow_level == 0` means block
        # context.
        self.flow_level = 0

        # List of processed tokens that are not yet emitted.
        self.tokens = []

        # Add the STREAM-START token.
        self.fetch_stream_start()

        # Number of tokens that were emitted through the `get_token` method.
        self.tokens_taken = 0

        # The current indentation level.
        self.indent = -1

        # Past indentation levels.
        self.indents = []

        # Variables related to simple keys treatment.

        # A simple key is a key that is not denoted by the '?' indicator.
        # Example of simple keys:
        #   ---
        #   block simple key: value
        #   ? not a simple key:
        #   : { flow simple key: value }
        # We emit the KEY token before all keys, so when we find a potential
        # simple key, we try to locate the corresponding ':' indicator.
        # Simple keys should be limited to a single line and 1024 characters.

        # Can a simple key start at the current position? A simple key may
        # start:
        # - at the beginning of the line, not counting indentation spaces
        #       (in block context),
        # - after '{', '[', ',' (in the flow context),
        # - after '?', ':', '-' (in the block context).
        # In the block context, this flag also signifies if a block collection
        # may start at the current position.
        self.allow_simple_key = True

        # Keep track of possible simple keys. This is a dictionary. The key
        # is `flow_level`; there can be no more that one possible simple key
        # for each level. The value is a SimpleKey record:
        #   (token_number, required, index, line, column, mark)
        # A simple key may start with ALIAS, ANCHOR, TAG, SCALAR(flow),
        # '[', or '{' tokens.
        self.possible_simple_keys = {}

    # Public methods.

    def check_token(self, *choices):
        # Check if the next token is one of the given types.
        while self.need_more_tokens():
            self.fetch_more_tokens()
        if self.tokens:
            if not choices:
                return True
            for choice in choices:
                if isinstance(self.tokens[0], choice):
                    return True
        return False

    def peek_token(self):
        # Return the next token, but do not delete if from the queue.
        while self.need_more_tokens():
            self.fetch_more_tokens()
        if self.tokens:
            return self.tokens[0]

    def get_token(self):
        # Return the next token.
        while self.need_more_tokens():
            self.fetch_more_tokens()
        if self.tokens:
            self.tokens_taken += 1
            return self.tokens.pop(0)

    # Private methods.

    def need_more_tokens(self):
        if self.done:
            return False
        if not self.tokens:
            return True
        # The current token may be a potential simple key, so we
        # need to look further.
        self.stale_possible_simple_keys()
        if self.next_possible_simple_key() == self.tokens_taken:
            return True

    def fetch_more_tokens(self):

        # Eat whitespaces and comments until we reach the next token.
        self.scan_to_next_token()

        # Remove obsolete possible simple keys.
        self.stale_possible_simple_keys()

        # Compare the current indentation and column. It may add some tokens
        # and decrease the current indentation level.
        self.unwind_indent(self.column)

        # Peek the next character.
        ch = self.peek()

        # Is it the end of stream?
        if ch == '\0':
            return self.fetch_stream_end()

        # Is it a directive?
        if ch == '%' and self.check_directive():
            return self.fetch_directive()

        # Is it the document start?
        if ch == '-' and self.check_document_start():
            return self.fetch_document_start()

        # Is it the document end?
        if ch == '.' and self.check_document_end():
            return self.fetch_document_end()

        # TODO: support for BOM within a stream.
        #if ch == '\uFEFF':
        #    return self.fetch_bom()    <-- issue BOMToken

        # Note: the order of the following checks is NOT significant.

        # Is it the flow sequence start indicator?
        if ch == '[':
            return self.fetch_flow_sequence_start()

        # Is it the flow mapping start indicator?
        if ch == '{':
            return self.fetch_flow_mapping_start()

        # Is it the flow sequence end indicator?
        if ch == ']':
            return self.fetch_flow_sequence_end()

        # Is it the flow mapping end indicator?
        if ch == '}':
            return self.fetch_flow_mapping_end()

        # Is it the flow entry indicator?
        if ch == ',':
            return self.fetch_flow_entry()

        # Is it the block entry indicator?
        if ch == '-' and self.check_block_entry():
            return self.fetch_block_entry()

        # Is it the key indicator?
        if ch == '?' and self.check_key():
            return self.fetch_key()

        # Is it the value indicator?
        if ch == ':' and self.check_value():
            return self.fetch_value()

        # Is it an alias?
        if ch == '*':
            return self.fetch_alias()

        # Is it an anchor?
        if ch == '&':
            return self.fetch_anchor()

        # Is it a tag?
        if ch == '!':
            return self.fetch_tag()

        # Is it a literal scalar?
        if ch == '|' and not self.flow_level:
            return self.fetch_literal()

        # Is it a folded scalar?
        if ch == '>' and not self.flow_level:
            return self.fetch_folded()

        # Is it a single quoted scalar?
        if ch == '\'':
            return self.fetch_single()

        # Is it a double quoted scalar?
        if ch == '\"':
            return self.fetch_double()

        # It must be a plain scalar then.
        if self.check_plain():
            return self.fetch_plain()

        # No? It's an error. Let's produce a nice error message.
        raise ScannerError("while scanning for the next token", None,
                "found character %r that cannot start any token" % ch,
                self.get_mark())

    # Simple keys treatment.

    def next_possible_simple_key(self):
        # Return the number of the nearest possible simple key. Actually we
        # don't need to loop through the whole dictionary. We may replace it
        # with the following code:
        #   if not self.possible_simple_keys:
        #       return None
        #   return self.possible_simple_keys[
        #           min(self.possible_simple_keys.keys())].token_number
        min_token_number = None
        for level in self.possible_simple_keys:
            key = self.possible_simple_keys[level]
            if min_token_number is None or key.token_number < min_token_number:
                min_token_number = key.token_number
        return min_token_number

    def stale_possible_simple_keys(self):
        # Remove entries that are no longer possible simple keys. According to
        # the YAML specification, simple keys
        # - should be limited to a single line,
        # - should be no longer than 1024 characters.
        # Disabling this procedure will allow simple keys of any length and
        # height (may cause problems if indentation is broken though).
        for level in list(self.possible_simple_keys):
            key = self.possible_simple_keys[level]
            if key.line != self.line  \
                    or self.index-key.index > 1024:
                if key.required:
                    raise ScannerError("while scanning a simple key", key.mark,
                            "could not found expected ':'", self.get_mark())
                del self.possible_simple_keys[level]

    def save_possible_simple_key(self):
        # The next token may start a simple key. We check if it's possible
        # and save its position. This function is called for
        #   ALIAS, ANCHOR, TAG, SCALAR(flow), '[', and '{'.

        # Check if a simple key is required at the current position.
        required = not self.flow_level and self.indent == self.column

        # A simple key is required only if it is the first token in the current
        # line. Therefore it is always allowed.
        assert self.allow_simple_key or not required

        # The next token might be a simple key. Let's save it's number and
        # position.
        if self.allow_simple_key:
            self.remove_possible_simple_key()
            token_number = self.tokens_taken+len(self.tokens)
            key = SimpleKey(token_number, required,
                    self.index, self.line, self.column, self.get_mark())
            self.possible_simple_keys[self.flow_level] = key

    def remove_possible_simple_key(self):
        # Remove the saved possible key position at the current flow level.
        if self.flow_level in self.possible_simple_keys:
            key = self.possible_simple_keys[self.flow_level]
            
            if key.required:
                raise ScannerError("while scanning a simple key", key.mark,
                        "could not found expected ':'", self.get_mark())

            del self.possible_simple_keys[self.flow_level]

    # Indentation functions.

    def unwind_indent(self, column):

        ## In flow context, tokens should respect indentation.
        ## Actually the condition should be `self.indent >= column` according to
        ## the spec. But this condition will prohibit intuitively correct
        ## constructions such as
        ## key : {
        ## }
        #if self.flow_level and self.indent > column:
        #    raise ScannerError(None, None,
        #            "invalid intendation or unclosed '[' or '{'",
        #            self.get_mark())

        # In the flow context, indentation is ignored. We make the scanner less
        # restrictive then specification requires.
        if self.flow_level:
            return

        # In block context, we may need to issue the BLOCK-END tokens.
        while self.indent > column:
            mark = self.get_mark()
            self.indent = self.indents.pop()
            self.tokens.append(BlockEndToken(mark, mark))

    def add_indent(self, column):
        # Check if we need to increase indentation.
        if self.indent < column:
            self.indents.append(self.indent)
            self.indent = column
            return True
        return False

    # Fetchers.

    def fetch_stream_start(self):
        # We always add STREAM-START as the first token and STREAM-END as the
        # last token.

        # Read the token.
        mark = self.get_mark()
        
        # Add STREAM-START.
        self.tokens.append(StreamStartToken(mark, mark,
            encoding=self.encoding))
        

    def fetch_stream_end(self):

        # Set the current intendation to -1.
        self.unwind_indent(-1)

        # Reset simple keys.
        self.remove_possible_simple_key()
        self.allow_simple_key = False
        self.possible_simple_keys = {}

        # Read the token.
        mark = self.get_mark()
        
        # Add STREAM-END.
        self.tokens.append(StreamEndToken(mark, mark))

        # The steam is finished.
        self.done = True

    def fetch_directive(self):
        
        # Set the current intendation to -1.
        self.unwind_indent(-1)

        # Reset simple keys.
        self.remove_possible_simple_key()
        self.allow_simple_key = False

        # Scan and add DIRECTIVE.
        self.tokens.append(self.scan_directive())

    def fetch_document_start(self):
        self.fetch_document_indicator(DocumentStartToken)

    def fetch_document_end(self):
        self.fetch_document_indicator(DocumentEndToken)

    def fetch_document_indicator(self, TokenClass):

        # Set the current intendation to -1.
        self.unwind_indent(-1)

        # Reset simple keys. Note that there could not be a block collection
        # after '---'.
        self.remove_possible_simple_key()
        self.allow_simple_key = False

        # Add DOCUMENT-START or DOCUMENT-END.
        start_mark = self.get_mark()
        self.forward(3)
        end_mark = self.get_mark()
        self.tokens.append(TokenClass(start_mark, end_mark))

    def fetch_flow_sequence_start(self):
        self.fetch_flow_collection_start(FlowSequenceStartToken)

    def fetch_flow_mapping_start(self):
        self.fetch_flow_collection_start(FlowMappingStartToken)

    def fetch_flow_collection_start(self, TokenClass):

        # '[' and '{' may start a simple key.
        self.save_possible_simple_key()

        # Increase the flow level.
        self.flow_level += 1

        # Simple keys are allowed after '[' and '{'.
        self.allow_simple_key = True

        # Add FLOW-SEQUENCE-START or FLOW-MAPPING-START.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(TokenClass(start_mark, end_mark))

    def fetch_flow_sequence_end(self):
        self.fetch_flow_collection_end(FlowSequenceEndToken)

    def fetch_flow_mapping_end(self):
        self.fetch_flow_collection_end(FlowMappingEndToken)

    def fetch_flow_collection_end(self, TokenClass):

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Decrease the flow level.
        self.flow_level -= 1

        # No simple keys after ']' or '}'.
        self.allow_simple_key = False

        # Add FLOW-SEQUENCE-END or FLOW-MAPPING-END.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(TokenClass(start_mark, end_mark))

    def fetch_flow_entry(self):

        # Simple keys are allowed after ','.
        self.allow_simple_key = True

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Add FLOW-ENTRY.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(FlowEntryToken(start_mark, end_mark))

    def fetch_block_entry(self):

        # Block context needs additional checks.
        if not self.flow_level:

            # Are we allowed to start a new entry?
            if not self.allow_simple_key:
                raise ScannerError(None, None,
                        "sequence entries are not allowed here",
                        self.get_mark())

            # We may need to add BLOCK-SEQUENCE-START.
            if self.add_indent(self.column):
                mark = self.get_mark()
                self.tokens.append(BlockSequenceStartToken(mark, mark))

        # It's an error for the block entry to occur in the flow context,
        # but we let the parser detect this.
        else:
            pass

        # Simple keys are allowed after '-'.
        self.allow_simple_key = True

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Add BLOCK-ENTRY.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(BlockEntryToken(start_mark, end_mark))

    def fetch_key(self):
        
        # Block context needs additional checks.
        if not self.flow_level:

            # Are we allowed to start a key (not nessesary a simple)?
            if not self.allow_simple_key:
                raise ScannerError(None, None,
                        "mapping keys are not allowed here",
                        self.get_mark())

            # We may need to add BLOCK-MAPPING-START.
            if self.add_indent(self.column):
                mark = self.get_mark()
                self.tokens.append(BlockMappingStartToken(mark, mark))

        # Simple keys are allowed after '?' in the block context.
        self.allow_simple_key = not self.flow_level

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Add KEY.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(KeyToken(start_mark, end_mark))

    def fetch_value(self):

        # Do we determine a simple key?
        if self.flow_level in self.possible_simple_keys:

            # Add KEY.
            key = self.possible_simple_keys[self.flow_level]
            del self.possible_simple_keys[self.flow_level]
            self.tokens.insert(key.token_number-self.tokens_taken,
                    KeyToken(key.mark, key.mark))

            # If this key starts a new block mapping, we need to add
            # BLOCK-MAPPING-START.
            if not self.flow_level:
                if self.add_indent(key.column):
                    self.tokens.insert(key.token_number-self.tokens_taken,
                            BlockMappingStartToken(key.mark, key.mark))

            # There cannot be two simple keys one after another.
            self.allow_simple_key = False

        # It must be a part of a complex key.
        else:
            
            # Block context needs additional checks.
            # (Do we really need them? They will be catched by the parser
            # anyway.)
            if not self.flow_level:

                # We are allowed to start a complex value if and only if
                # we can start a simple key.
                if not self.allow_simple_key:
                    raise ScannerError(None, None,
                            "mapping values are not allowed here",
                            self.get_mark())

            # If this value starts a new block mapping, we need to add
            # BLOCK-MAPPING-START.  It will be detected as an error later by
            # the parser.
            if not self.flow_level:
                if self.add_indent(self.column):
                    mark = self.get_mark()
                    self.tokens.append(BlockMappingStartToken(mark, mark))

            # Simple keys are allowed after ':' in the block context.
            self.allow_simple_key = not self.flow_level

            # Reset possible simple key on the current level.
            self.remove_possible_simple_key()

        # Add VALUE.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(ValueToken(start_mark, end_mark))

    def fetch_alias(self):

        # ALIAS could be a simple key.
        self.save_possible_simple_key()

        # No simple keys after ALIAS.
        self.allow_simple_key = False

        # Scan and add ALIAS.
        self.tokens.append(self.scan_anchor(AliasToken))

    def fetch_anchor(self):

        # ANCHOR could start a simple key.
        self.save_possible_simple_key()

        # No simple keys after ANCHOR.
        self.allow_simple_key = False

        # Scan and add ANCHOR.
        self.tokens.append(self.scan_anchor(AnchorToken))

    def fetch_tag(self):

        # TAG could start a simple key.
        self.save_possible_simple_key()

        # No simple keys after TAG.
        self.allow_simple_key = False

        # Scan and add TAG.
        self.tokens.append(self.scan_tag())

    def fetch_literal(self):
        self.fetch_block_scalar(style='|')

    def fetch_folded(self):
        self.fetch_block_scalar(style='>')

    def fetch_block_scalar(self, style):

        # A simple key may follow a block scalar.
        self.allow_simple_key = True

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Scan and add SCALAR.
        self.tokens.append(self.scan_block_scalar(style))

    def fetch_single(self):
        self.fetch_flow_scalar(style='\'')

    def fetch_double(self):
        self.fetch_flow_scalar(style='"')

    def fetch_flow_scalar(self, style):

        # A flow scalar could be a simple key.
        self.save_possible_simple_key()

        # No simple keys after flow scalars.
        self.allow_simple_key = False

        # Scan and add SCALAR.
        self.tokens.append(self.scan_flow_scalar(style))

    def fetch_plain(self):

        # A plain scalar could be a simple key.
        self.save_possible_simple_key()

        # No simple keys after plain scalars. But note that `scan_plain` will
        # change this flag if the scan is finished at the beginning of the
        # line.
        self.allow_simple_key = False

        # Scan and add SCALAR. May change `allow_simple_key`.
        self.tokens.append(self.scan_plain())

    # Checkers.

    def check_directive(self):

        # DIRECTIVE:        ^ '%' ...
        # The '%' indicator is already checked.
        if self.column == 0:
            return True

    def check_document_start(self):

        # DOCUMENT-START:   ^ '---' (' '|'\n')
        if self.column == 0:
            if self.prefix(3) == '---'  \
                    and self.peek(3) in '\0 \t\r\n\x85\u2028\u2029':
                return True

    def check_document_end(self):

        # DOCUMENT-END:     ^ '...' (' '|'\n')
        if self.column == 0:
            if self.prefix(3) == '...'  \
                    and self.peek(3) in '\0 \t\r\n\x85\u2028\u2029':
                return True

    def check_block_entry(self):

        # BLOCK-ENTRY:      '-' (' '|'\n')
        return self.peek(1) in '\0 \t\r\n\x85\u2028\u2029'

    def check_key(self):

        # KEY(flow context):    '?'
        if self.flow_level:
            return True

        # KEY(block context):   '?' (' '|'\n')
        else:
            return self.peek(1) in '\0 \t\r\n\x85\u2028\u2029'

    def check_value(self):

        # VALUE(flow context):  ':'
        if self.flow_level:
            return True

        # VALUE(block context): ':' (' '|'\n')
        else:
            return self.peek(1) in '\0 \t\r\n\x85\u2028\u2029'

    def check_plain(self):

        # A plain scalar may start with any non-space character except:
        #   '-', '?', ':', ',', '[', ']', '{', '}',
        #   '#', '&', '*', '!', '|', '>', '\'', '\"',
        #   '%', '@', '`'.
        #
        # It may also start with
        #   '-', '?', ':'
        # if it is followed by a non-space character.
        #
        # Note that we limit the last rule to the block context (except the
        # '-' character) because we want the flow context to be space
        # independent.
        ch = self.peek()
        return ch not in '\0 \t\r\n\x85\u2028\u2029-?:,[]{}#&*!|>\'\"%@`'  \
                or (self.peek(1) not in '\0 \t\r\n\x85\u2028\u2029'
                        and (ch == '-' or (not self.flow_level and ch in '?:')))

    # Scanners.

    def scan_to_next_token(self):
        # We ignore spaces, line breaks and comments.
        # If we find a line break in the block context, we set the flag
        # `allow_simple_key` on.
        # The byte order mark is stripped if it's the first character in the
        # stream. We do not yet support BOM inside the stream as the
        # specification requires. Any such mark will be considered as a part
        # of the document.
        #
        # TODO: We need to make tab handling rules more sane. A good rule is
        #   Tabs cannot precede tokens
        #   BLOCK-SEQUENCE-START, BLOCK-MAPPING-START, BLOCK-END,
        #   KEY(block), VALUE(block), BLOCK-ENTRY
        # So the checking code is
        #   if <TAB>:
        #       self.allow_simple_keys = False
        # We also need to add the check for `allow_simple_keys == True` to
        # `unwind_indent` before issuing BLOCK-END.
        # Scanners for block, flow, and plain scalars need to be modified.

        if self.index == 0 and self.peek() == '\uFEFF':
            self.forward()
        found = False
        while not found:
            while self.peek() == ' ':
                self.forward()
            if self.peek() == '#':
                while self.peek() not in '\0\r\n\x85\u2028\u2029':
                    self.forward()
            if self.scan_line_break():
                if not self.flow_level:
                    self.allow_simple_key = True
            else:
                found = True

    def scan_directive(self):
        # See the specification for details.
        start_mark = self.get_mark()
        self.forward()
        name = self.scan_directive_name(start_mark)
        value = None
        if name == 'YAML':
            value = self.scan_yaml_directive_value(start_mark)
            end_mark = self.get_mark()
        elif name == 'TAG':
            value = self.scan_tag_directive_value(start_mark)
            end_mark = self.get_mark()
        else:
            end_mark = self.get_mark()
            while self.peek() not in '\0\r\n\x85\u2028\u2029':
                self.forward()
        self.scan_directive_ignored_line(start_mark)
        return DirectiveToken(name, value, start_mark, end_mark)

    def scan_directive_name(self, start_mark):
        # See the specification for details.
        length = 0
        ch = self.peek(length)
        while '0' <= ch <= '9' or 'A' <= ch <= 'Z' or 'a' <= ch <= 'z'  \
                or ch in '-_':
            length += 1
            ch = self.peek(length)
        if not length:
            raise ScannerError("while scanning a directive", start_mark,
                    "expected alphabetic or numeric character, but found %r"
                    % ch, self.get_mark())
        value = self.prefix(length)
        self.forward(length)
        ch = self.peek()
        if ch not in '\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected alphabetic or numeric character, but found %r"
                    % ch, self.get_mark())
        return value

    def scan_yaml_directive_value(self, start_mark):
        # See the specification for details.
        while self.peek() == ' ':
            self.forward()
        major = self.scan_yaml_directive_number(start_mark)
        if self.peek() != '.':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected a digit or '.', but found %r" % self.peek(),
                    self.get_mark())
        self.forward()
        minor = self.scan_yaml_directive_number(start_mark)
        if self.peek() not in '\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected a digit or ' ', but found %r" % self.peek(),
                    self.get_mark())
        return (major, minor)

    def scan_yaml_directive_number(self, start_mark):
        # See the specification for details.
        ch = self.peek()
        if not ('0' <= ch <= '9'):
            raise ScannerError("while scanning a directive", start_mark,
                    "expected a digit, but found %r" % ch, self.get_mark())
        length = 0
        while '0' <= self.peek(length) <= '9':
            length += 1
        value = int(self.prefix(length))
        self.forward(length)
        return value

    def scan_tag_directive_value(self, start_mark):
        # See the specification for details.
        while self.peek() == ' ':
            self.forward()
        handle = self.scan_tag_directive_handle(start_mark)
        while self.peek() == ' ':
            self.forward()
        prefix = self.scan_tag_directive_prefix(start_mark)
        return (handle, prefix)

    def scan_tag_directive_handle(self, start_mark):
        # See the specification for details.
        value = self.scan_tag_handle('directive', start_mark)
        ch = self.peek()
        if ch != ' ':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected ' ', but found %r" % ch, self.get_mark())
        return value

    def scan_tag_directive_prefix(self, start_mark):
        # See the specification for details.
        value = self.scan_tag_uri('directive', start_mark)
        ch = self.peek()
        if ch not in '\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected ' ', but found %r" % ch, self.get_mark())
        return value

    def scan_directive_ignored_line(self, start_mark):
        # See the specification for details.
        while self.peek() == ' ':
            self.forward()
        if self.peek() == '#':
            while self.peek() not in '\0\r\n\x85\u2028\u2029':
                self.forward()
        ch = self.peek()
        if ch not in '\0\r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected a comment or a line break, but found %r"
                        % ch, self.get_mark())
        self.scan_line_break()

    def scan_anchor(self, TokenClass):
        # The specification does not restrict characters for anchors and
        # aliases. This may lead to problems, for instance, the document:
        #   [ *alias, value ]
        # can be interpteted in two ways, as
        #   [ "value" ]
        # and
        #   [ *alias , "value" ]
        # Therefore we restrict aliases to numbers and ASCII letters.
        start_mark = self.get_mark()
        indicator = self.peek()
        if indicator == '*':
            name = 'alias'
        else:
            name = 'anchor'
        self.forward()
        length = 0
        ch = self.peek(length)
        while '0' <= ch <= '9' or 'A' <= ch <= 'Z' or 'a' <= ch <= 'z'  \
                or ch in '-_':
            length += 1
            ch = self.peek(length)
        if not length:
            raise ScannerError("while scanning an %s" % name, start_mark,
                    "expected alphabetic or numeric character, but found %r"
                    % ch, self.get_mark())
        value = self.prefix(length)
        self.forward(length)
        ch = self.peek()
        if ch not in '\0 \t\r\n\x85\u2028\u2029?:,]}%@`':
            raise ScannerError("while scanning an %s" % name, start_mark,
                    "expected alphabetic or numeric character, but found %r"
                    % ch, self.get_mark())
        end_mark = self.get_mark()
        return TokenClass(value, start_mark, end_mark)

    def scan_tag(self):
        # See the specification for details.
        start_mark = self.get_mark()
        ch = self.peek(1)
        if ch == '<':
            handle = None
            self.forward(2)
            suffix = self.scan_tag_uri('tag', start_mark)
            if self.peek() != '>':
                raise ScannerError("while parsing a tag", start_mark,
                        "expected '>', but found %r" % self.peek(),
                        self.get_mark())
            self.forward()
        elif ch in '\0 \t\r\n\x85\u2028\u2029':
            handle = None
            suffix = '!'
            self.forward()
        else:
            length = 1
            use_handle = False
            while ch not in '\0 \r\n\x85\u2028\u2029':
                if ch == '!':
                    use_handle = True
                    break
                length += 1
                ch = self.peek(length)
            handle = '!'
            if use_handle:
                handle = self.scan_tag_handle('tag', start_mark)
            else:
                handle = '!'
                self.forward()
            suffix = self.scan_tag_uri('tag', start_mark)
        ch = self.peek()
        if ch not in '\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a tag", start_mark,
                    "expected ' ', but found %r" % ch, self.get_mark())
        value = (handle, suffix)
        end_mark = self.get_mark()
        return TagToken(value, start_mark, end_mark)

    def scan_block_scalar(self, style):
        # See the specification for details.

        if style == '>':
            folded = True
        else:
            folded = False

        chunks = []
        start_mark = self.get_mark()

        # Scan the header.
        self.forward()
        chomping, increment = self.scan_block_scalar_indicators(start_mark)
        self.scan_block_scalar_ignored_line(start_mark)

        # Determine the indentation level and go to the first non-empty line.
        min_indent = self.indent+1
        if min_indent < 1:
            min_indent = 1
        if increment is None:
            breaks, max_indent, end_mark = self.scan_block_scalar_indentation()
            indent = max(min_indent, max_indent)
        else:
            indent = min_indent+increment-1
            breaks, end_mark = self.scan_block_scalar_breaks(indent)
        line_break = ''

        # Scan the inner part of the block scalar.
        while self.column == indent and self.peek() != '\0':
            chunks.extend(breaks)
            leading_non_space = self.peek() not in ' \t'
            length = 0
            while self.peek(length) not in '\0\r\n\x85\u2028\u2029':
                length += 1
            chunks.append(self.prefix(length))
            self.forward(length)
            line_break = self.scan_line_break()
            breaks, end_mark = self.scan_block_scalar_breaks(indent)
            if self.column == indent and self.peek() != '\0':

                # Unfortunately, folding rules are ambiguous.
                #
                # This is the folding according to the specification:
                
                if folded and line_break == '\n'    \
                        and leading_non_space and self.peek() not in ' \t':
                    if not breaks:
                        chunks.append(' ')
                else:
                    chunks.append(line_break)
                
                # This is Clark Evans's interpretation (also in the spec
                # examples):
                #
                #if folded and line_break == '\n':
                #    if not breaks:
                #        if self.peek() not in ' \t':
                #            chunks.append(' ')
                #        else:
                #            chunks.append(line_break)
                #else:
                #    chunks.append(line_break)
            else:
                break

        # Chomp the tail.
        if chomping is not False:
            chunks.append(line_break)
        if chomping is True:
            chunks.extend(breaks)

        # We are done.
        return ScalarToken(''.join(chunks), False, start_mark, end_mark,
                style)

    def scan_block_scalar_indicators(self, start_mark):
        # See the specification for details.
        chomping = None
        increment = None
        ch = self.peek()
        if ch in '+-':
            if ch == '+':
                chomping = True
            else:
                chomping = False
            self.forward()
            ch = self.peek()
            if ch in '0123456789':
                increment = int(ch)
                if increment == 0:
                    raise ScannerError("while scanning a block scalar", start_mark,
                            "expected indentation indicator in the range 1-9, but found 0",
                            self.get_mark())
                self.forward()
        elif ch in '0123456789':
            increment = int(ch)
            if increment == 0:
                raise ScannerError("while scanning a block scalar", start_mark,
                        "expected indentation indicator in the range 1-9, but found 0",
                        self.get_mark())
            self.forward()
            ch = self.peek()
            if ch in '+-':
                if ch == '+':
                    chomping = True
                else:
                    chomping = False
                self.forward()
        ch = self.peek()
        if ch not in '\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a block scalar", start_mark,
                    "expected chomping or indentation indicators, but found %r"
                    % ch, self.get_mark())
        return chomping, increment

    def scan_block_scalar_ignored_line(self, start_mark):
        # See the specification for details.
        while self.peek() == ' ':
            self.forward()
        if self.peek() == '#':
            while self.peek() not in '\0\r\n\x85\u2028\u2029':
                self.forward()
        ch = self.peek()
        if ch not in '\0\r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a block scalar", start_mark,
                    "expected a comment or a line break, but found %r" % ch,
                    self.get_mark())
        self.scan_line_break()

    def scan_block_scalar_indentation(self):
        # See the specification for details.
        chunks = []
        max_indent = 0
        end_mark = self.get_mark()
        while self.peek() in ' \r\n\x85\u2028\u2029':
            if self.peek() != ' ':
                chunks.append(self.scan_line_break())
                end_mark = self.get_mark()
            else:
                self.forward()
                if self.column > max_indent:
                    max_indent = self.column
        return chunks, max_indent, end_mark

    def scan_block_scalar_breaks(self, indent):
        # See the specification for details.
        chunks = []
        end_mark = self.get_mark()
        while self.column < indent and self.peek() == ' ':
            self.forward()
        while self.peek() in '\r\n\x85\u2028\u2029':
            chunks.append(self.scan_line_break())
            end_mark = self.get_mark()
            while self.column < indent and self.peek() == ' ':
                self.forward()
        return chunks, end_mark

    def scan_flow_scalar(self, style):
        # See the specification for details.
        # Note that we loose indentation rules for quoted scalars. Quoted
        # scalars don't need to adhere indentation because " and ' clearly
        # mark the beginning and the end of them. Therefore we are less
        # restrictive then the specification requires. We only need to check
        # that document separators are not included in scalars.
        if style == '"':
            double = True
        else:
            double = False
        chunks = []
        start_mark = self.get_mark()
        quote = self.peek()
        self.forward()
        chunks.extend(self.scan_flow_scalar_non_spaces(double, start_mark))
        while self.peek() != quote:
            chunks.extend(self.scan_flow_scalar_spaces(double, start_mark))
            chunks.extend(self.scan_flow_scalar_non_spaces(double, start_mark))
        self.forward()
        end_mark = self.get_mark()
        return ScalarToken(''.join(chunks), False, start_mark, end_mark,
                style)

    ESCAPE_REPLACEMENTS = {
        '0':    '\0',
        'a':    '\x07',
        'b':    '\x08',
        't':    '\x09',
        '\t':   '\x09',
        'n':    '\x0A',
        'v':    '\x0B',
        'f':    '\x0C',
        'r':    '\x0D',
        'e':    '\x1B',
        ' ':    '\x20',
        '\"':   '\"',
        '\\':   '\\',
        'N':    '\x85',
        '_':    '\xA0',
        'L':    '\u2028',
        'P':    '\u2029',
    }

    ESCAPE_CODES = {
        'x':    2,
        'u':    4,
        'U':    8,
    }

    def scan_flow_scalar_non_spaces(self, double, start_mark):
        # See the specification for details.
        chunks = []
        while True:
            length = 0
            while self.peek(length) not in '\'\"\\\0 \t\r\n\x85\u2028\u2029':
                length += 1
            if length:
                chunks.append(self.prefix(length))
                self.forward(length)
            ch = self.peek()
            if not double and ch == '\'' and self.peek(1) == '\'':
                chunks.append('\'')
                self.forward(2)
            elif (double and ch == '\'') or (not double and ch in '\"\\'):
                chunks.append(ch)
                self.forward()
            elif double and ch == '\\':
                self.forward()
                ch = self.peek()
                if ch in self.ESCAPE_REPLACEMENTS:
                    chunks.append(self.ESCAPE_REPLACEMENTS[ch])
                    self.forward()
                elif ch in self.ESCAPE_CODES:
                    length = self.ESCAPE_CODES[ch]
                    self.forward()
                    for k in range(length):
                        if self.peek(k) not in '0123456789ABCDEFabcdef':
                            raise ScannerError("while scanning a double-quoted scalar", start_mark,
                                    "expected escape sequence of %d hexdecimal numbers, but found %r" %
                                        (length, self.peek(k)), self.get_mark())
                    code = int(self.prefix(length), 16)
                    chunks.append(chr(code))
                    self.forward(length)
                elif ch in '\r\n\x85\u2028\u2029':
                    self.scan_line_break()
                    chunks.extend(self.scan_flow_scalar_breaks(double, start_mark))
                else:
                    raise ScannerError("while scanning a double-quoted scalar", start_mark,
                            "found unknown escape character %r" % ch, self.get_mark())
            else:
                return chunks

    def scan_flow_scalar_spaces(self, double, start_mark):
        # See the specification for details.
        chunks = []
        length = 0
        while self.peek(length) in ' \t':
            length += 1
        whitespaces = self.prefix(length)
        self.forward(length)
        ch = self.peek()
        if ch == '\0':
            raise ScannerError("while scanning a quoted scalar", start_mark,
                    "found unexpected end of stream", self.get_mark())
        elif ch in '\r\n\x85\u2028\u2029':
            line_break = self.scan_line_break()
            breaks = self.scan_flow_scalar_breaks(double, start_mark)
            if line_break != '\n':
                chunks.append(line_break)
            elif not breaks:
                chunks.append(' ')
            chunks.extend(breaks)
        else:
            chunks.append(whitespaces)
        return chunks

    def scan_flow_scalar_breaks(self, double, start_mark):
        # See the specification for details.
        chunks = []
        while True:
            # Instead of checking indentation, we check for document
            # separators.
            prefix = self.prefix(3)
            if (prefix == '---' or prefix == '...')   \
                    and self.peek(3) in '\0 \t\r\n\x85\u2028\u2029':
                raise ScannerError("while scanning a quoted scalar", start_mark,
                        "found unexpected document separator", self.get_mark())
            while self.peek() in ' \t':
                self.forward()
            if self.peek() in '\r\n\x85\u2028\u2029':
                chunks.append(self.scan_line_break())
            else:
                return chunks

    def scan_plain(self):
        # See the specification for details.
        # We add an additional restriction for the flow context:
        #   plain scalars in the flow context cannot contain ',', ':' and '?'.
        # We also keep track of the `allow_simple_key` flag here.
        # Indentation rules are loosed for the flow context.
        chunks = []
        start_mark = self.get_mark()
        end_mark = start_mark
        indent = self.indent+1
        # We allow zero indentation for scalars, but then we need to check for
        # document separators at the beginning of the line.
        #if indent == 0:
        #    indent = 1
        spaces = []
        while True:
            length = 0
            if self.peek() == '#':
                break
            while True:
                ch = self.peek(length)
                if ch in '\0 \t\r\n\x85\u2028\u2029'    \
                        or (not self.flow_level and ch == ':' and
                                self.peek(length+1) in '\0 \t\r\n\x85\u2028\u2029') \
                        or (self.flow_level and ch in ',:?[]{}'):
                    break
                length += 1
            # It's not clear what we should do with ':' in the flow context.
            if (self.flow_level and ch == ':'
                    and self.peek(length+1) not in '\0 \t\r\n\x85\u2028\u2029,[]{}'):
                self.forward(length)
                raise ScannerError("while scanning a plain scalar", start_mark,
                    "found unexpected ':'", self.get_mark(),
                    "Please check http://pyyaml.org/wiki/YAMLColonInFlowContext for details.")
            if length == 0:
                break
            self.allow_simple_key = False
            chunks.extend(spaces)
            chunks.append(self.prefix(length))
            self.forward(length)
            end_mark = self.get_mark()
            spaces = self.scan_plain_spaces(indent, start_mark)
            if not spaces or self.peek() == '#' \
                    or (not self.flow_level and self.column < indent):
                break
        return ScalarToken(''.join(chunks), True, start_mark, end_mark)

    def scan_plain_spaces(self, indent, start_mark):
        # See the specification for details.
        # The specification is really confusing about tabs in plain scalars.
        # We just forbid them completely. Do not use tabs in YAML!
        chunks = []
        length = 0
        while self.peek(length) in ' ':
            length += 1
        whitespaces = self.prefix(length)
        self.forward(length)
        ch = self.peek()
        if ch in '\r\n\x85\u2028\u2029':
            line_break = self.scan_line_break()
            self.allow_simple_key = True
            prefix = self.prefix(3)
            if (prefix == '---' or prefix == '...')   \
                    and self.peek(3) in '\0 \t\r\n\x85\u2028\u2029':
                return
            breaks = []
            while self.peek() in ' \r\n\x85\u2028\u2029':
                if self.peek() == ' ':
                    self.forward()
                else:
                    breaks.append(self.scan_line_break())
                    prefix = self.prefix(3)
                    if (prefix == '---' or prefix == '...')   \
                            and self.peek(3) in '\0 \t\r\n\x85\u2028\u2029':
                        return
            if line_break != '\n':
                chunks.append(line_break)
            elif not breaks:
                chunks.append(' ')
            chunks.extend(breaks)
        elif whitespaces:
            chunks.append(whitespaces)
        return chunks

    def scan_tag_handle(self, name, start_mark):
        # See the specification for details.
        # For some strange reasons, the specification does not allow '_' in
        # tag handles. I have allowed it anyway.
        ch = self.peek()
        if ch != '!':
            raise ScannerError("while scanning a %s" % name, start_mark,
                    "expected '!', but found %r" % ch, self.get_mark())
        length = 1
        ch = self.peek(length)
        if ch != ' ':
            while '0' <= ch <= '9' or 'A' <= ch <= 'Z' or 'a' <= ch <= 'z'  \
                    or ch in '-_':
                length += 1
                ch = self.peek(length)
            if ch != '!':
                self.forward(length)
                raise ScannerError("while scanning a %s" % name, start_mark,
                        "expected '!', but found %r" % ch, self.get_mark())
            length += 1
        value = self.prefix(length)
        self.forward(length)
        return value

    def scan_tag_uri(self, name, start_mark):
        # See the specification for details.
        # Note: we do not check if URI is well-formed.
        chunks = []
        length = 0
        ch = self.peek(length)
        while '0' <= ch <= '9' or 'A' <= ch <= 'Z' or 'a' <= ch <= 'z'  \
                or ch in '-;/?:@&=+$,_.!~*\'()[]%':
            if ch == '%':
                chunks.append(self.prefix(length))
                self.forward(length)
                length = 0
                chunks.append(self.scan_uri_escapes(name, start_mark))
            else:
                length += 1
            ch = self.peek(length)
        if length:
            chunks.append(self.prefix(length))
            self.forward(length)
            length = 0
        if not chunks:
            raise ScannerError("while parsing a %s" % name, start_mark,
                    "expected URI, but found %r" % ch, self.get_mark())
        return ''.join(chunks)

    def scan_uri_escapes(self, name, start_mark):
        # See the specification for details.
        codes = []
        mark = self.get_mark()
        while self.peek() == '%':
            self.forward()
            for k in range(2):
                if self.peek(k) not in '0123456789ABCDEFabcdef':
                    raise ScannerError("while scanning a %s" % name, start_mark,
                            "expected URI escape sequence of 2 hexdecimal numbers, but found %r"
                            % self.peek(k), self.get_mark())
            codes.append(int(self.prefix(2), 16))
            self.forward(2)
        try:
            value = bytes(codes).decode('utf-8')
        except UnicodeDecodeError as exc:
            raise ScannerError("while scanning a %s" % name, start_mark, str(exc), mark)
        return value

    def scan_line_break(self):
        # Transforms:
        #   '\r\n'      :   '\n'
        #   '\r'        :   '\n'
        #   '\n'        :   '\n'
        #   '\x85'      :   '\n'
        #   '\u2028'    :   '\u2028'
        #   '\u2029     :   '\u2029'
        #   default     :   ''
        ch = self.peek()
        if ch in '\r\n\x85':
            if self.prefix(2) == '\r\n':
                self.forward(2)
            else:
                self.forward()
            return '\n'
        elif ch in '\u2028\u2029':
            self.forward()
            return ch
        return ''

#try:
#    import psyco
#    psyco.bind(Scanner)
#except ImportError:
#    pass


########NEW FILE########
__FILENAME__ = serializer

__all__ = ['Serializer', 'SerializerError']

from .error import YAMLError
from .events import *
from .nodes import *

class SerializerError(YAMLError):
    pass

class Serializer:

    ANCHOR_TEMPLATE = 'id%03d'

    def __init__(self, encoding=None,
            explicit_start=None, explicit_end=None, version=None, tags=None):
        self.use_encoding = encoding
        self.use_explicit_start = explicit_start
        self.use_explicit_end = explicit_end
        self.use_version = version
        self.use_tags = tags
        self.serialized_nodes = {}
        self.anchors = {}
        self.last_anchor_id = 0
        self.closed = None

    def open(self):
        if self.closed is None:
            self.emit(StreamStartEvent(encoding=self.use_encoding))
            self.closed = False
        elif self.closed:
            raise SerializerError("serializer is closed")
        else:
            raise SerializerError("serializer is already opened")

    def close(self):
        if self.closed is None:
            raise SerializerError("serializer is not opened")
        elif not self.closed:
            self.emit(StreamEndEvent())
            self.closed = True

    #def __del__(self):
    #    self.close()

    def serialize(self, node):
        if self.closed is None:
            raise SerializerError("serializer is not opened")
        elif self.closed:
            raise SerializerError("serializer is closed")
        self.emit(DocumentStartEvent(explicit=self.use_explicit_start,
            version=self.use_version, tags=self.use_tags))
        self.anchor_node(node)
        self.serialize_node(node, None, None)
        self.emit(DocumentEndEvent(explicit=self.use_explicit_end))
        self.serialized_nodes = {}
        self.anchors = {}
        self.last_anchor_id = 0

    def anchor_node(self, node):
        if node in self.anchors:
            if self.anchors[node] is None:
                self.anchors[node] = self.generate_anchor(node)
        else:
            self.anchors[node] = None
            if isinstance(node, SequenceNode):
                for item in node.value:
                    self.anchor_node(item)
            elif isinstance(node, MappingNode):
                for key, value in node.value:
                    self.anchor_node(key)
                    self.anchor_node(value)

    def generate_anchor(self, node):
        self.last_anchor_id += 1
        return self.ANCHOR_TEMPLATE % self.last_anchor_id

    def serialize_node(self, node, parent, index):
        alias = self.anchors[node]
        if node in self.serialized_nodes:
            self.emit(AliasEvent(alias))
        else:
            self.serialized_nodes[node] = True
            self.descend_resolver(parent, index)
            if isinstance(node, ScalarNode):
                detected_tag = self.resolve(ScalarNode, node.value, (True, False))
                default_tag = self.resolve(ScalarNode, node.value, (False, True))
                implicit = (node.tag == detected_tag), (node.tag == default_tag)
                self.emit(ScalarEvent(alias, node.tag, implicit, node.value,
                    style=node.style))
            elif isinstance(node, SequenceNode):
                implicit = (node.tag
                            == self.resolve(SequenceNode, node.value, True))
                self.emit(SequenceStartEvent(alias, node.tag, implicit,
                    flow_style=node.flow_style))
                index = 0
                for item in node.value:
                    self.serialize_node(item, node, index)
                    index += 1
                self.emit(SequenceEndEvent())
            elif isinstance(node, MappingNode):
                implicit = (node.tag
                            == self.resolve(MappingNode, node.value, True))
                self.emit(MappingStartEvent(alias, node.tag, implicit,
                    flow_style=node.flow_style))
                for key, value in node.value:
                    self.serialize_node(key, node, None)
                    self.serialize_node(value, node, key)
                self.emit(MappingEndEvent())
            self.ascend_resolver()


########NEW FILE########
__FILENAME__ = tokens

class Token(object):
    def __init__(self, start_mark, end_mark):
        self.start_mark = start_mark
        self.end_mark = end_mark
    def __repr__(self):
        attributes = [key for key in self.__dict__
                if not key.endswith('_mark')]
        attributes.sort()
        arguments = ', '.join(['%s=%r' % (key, getattr(self, key))
                for key in attributes])
        return '%s(%s)' % (self.__class__.__name__, arguments)

#class BOMToken(Token):
#    id = '<byte order mark>'

class DirectiveToken(Token):
    id = '<directive>'
    def __init__(self, name, value, start_mark, end_mark):
        self.name = name
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark

class DocumentStartToken(Token):
    id = '<document start>'

class DocumentEndToken(Token):
    id = '<document end>'

class StreamStartToken(Token):
    id = '<stream start>'
    def __init__(self, start_mark=None, end_mark=None,
            encoding=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.encoding = encoding

class StreamEndToken(Token):
    id = '<stream end>'

class BlockSequenceStartToken(Token):
    id = '<block sequence start>'

class BlockMappingStartToken(Token):
    id = '<block mapping start>'

class BlockEndToken(Token):
    id = '<block end>'

class FlowSequenceStartToken(Token):
    id = '['

class FlowMappingStartToken(Token):
    id = '{'

class FlowSequenceEndToken(Token):
    id = ']'

class FlowMappingEndToken(Token):
    id = '}'

class KeyToken(Token):
    id = '?'

class ValueToken(Token):
    id = ':'

class BlockEntryToken(Token):
    id = '-'

class FlowEntryToken(Token):
    id = ','

class AliasToken(Token):
    id = '<alias>'
    def __init__(self, value, start_mark, end_mark):
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark

class AnchorToken(Token):
    id = '<anchor>'
    def __init__(self, value, start_mark, end_mark):
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark

class TagToken(Token):
    id = '<tag>'
    def __init__(self, value, start_mark, end_mark):
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark

class ScalarToken(Token):
    id = '<scalar>'
    def __init__(self, value, plain, start_mark, end_mark, style=None):
        self.value = value
        self.plain = plain
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.style = style


########NEW FILE########
__FILENAME__ = test_tablib
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Tests for Tablib."""

import json
import unittest
import sys
import os
import tablib
from tablib.compat import markup, unicode, is_py3





class TablibTestCase(unittest.TestCase):
    """Tablib test cases."""

    def setUp(self):
        """Create simple data set with headers."""

        global data, book

        data = tablib.Dataset()
        book = tablib.Databook()

        self.headers = ('first_name', 'last_name', 'gpa')
        self.john = ('John', 'Adams', 90)
        self.george = ('George', 'Washington', 67)
        self.tom = ('Thomas', 'Jefferson', 50)

        self.founders = tablib.Dataset(headers=self.headers, title='Founders')
        self.founders.append(self.john)
        self.founders.append(self.george)
        self.founders.append(self.tom)


    def tearDown(self):
        """Teardown."""
        pass


    def test_empty_append(self):
        """Verify append() correctly adds tuple with no headers."""
        new_row = (1, 2, 3)
        data.append(new_row)

        # Verify width/data
        self.assertTrue(data.width == len(new_row))
        self.assertTrue(data[0] == new_row)


    def test_empty_append_with_headers(self):
        """Verify append() correctly detects mismatch of number of
        headers and data.
        """
        data.headers = ['first', 'second']
        new_row = (1, 2, 3, 4)

        self.assertRaises(tablib.InvalidDimensions, data.append, new_row)

    def test_set_headers_with_incorrect_dimension(self):
        """Verify headers correctly detects mismatch of number of
        headers and data.
        """

        data.append(self.john)

        def set_header_callable():
            data.headers = ['first_name']

        self.assertRaises(tablib.InvalidDimensions, set_header_callable)


    def test_add_column(self):
        """Verify adding column works with/without headers."""

        data.append(['kenneth'])
        data.append(['bessie'])

        new_col = ['reitz', 'monke']

        data.append_col(new_col)

        self.assertEqual(data[0], ('kenneth', 'reitz'))
        self.assertEqual(data.width, 2)

        # With Headers
        data.headers = ('fname', 'lname')
        new_col = [21, 22]
        data.append_col(new_col, header='age')

        self.assertEqual(data['age'], new_col)


    def test_add_column_no_data_no_headers(self):
        """Verify adding new column with no headers."""

        new_col = ('reitz', 'monke')

        data.append_col(new_col)

        self.assertEqual(data[0], tuple([new_col[0]]))
        self.assertEqual(data.width, 1)
        self.assertEqual(data.height, len(new_col))


    def test_add_column_with_header_ignored(self):
        """Verify append_col() ignores the header if data.headers has
        not previously been set
        """

        new_col = ('reitz', 'monke')

        data.append_col(new_col, header='first_name')

        self.assertEqual(data[0], tuple([new_col[0]]))
        self.assertEqual(data.width, 1)
        self.assertEqual(data.height, len(new_col))
        self.assertEqual(data.headers, None)


    def test_add_column_with_header_and_headers_only_exist(self):
        """Verify append_col() with header correctly detects mismatch when
        headers exist but there is no existing row data
        """

        data.headers = ['first_name']
        #no data

        new_col = ('allen')

        def append_col_callable():
            data.append_col(new_col, header='middle_name')

        self.assertRaises(tablib.InvalidDimensions, append_col_callable)


    def test_add_column_with_header_and_data_exists(self):
        """Verify append_col() works when headers and rows exists"""

        data.headers = self.headers
        data.append(self.john)

        new_col = [10];

        data.append_col(new_col, header='age')

        self.assertEqual(data.height, 1)
        self.assertEqual(data.width, len(self.john) + 1)
        self.assertEqual(data['age'], new_col)
        self.assertEqual(len(data.headers), len(self.headers) + 1)


    def test_add_callable_column(self):
        """Verify adding column with values specified as callable."""

        new_col = lambda x: x[0]

        self.founders.append_col(new_col, header='first_again')


    def test_header_slicing(self):
        """Verify slicing by headers."""

        self.assertEqual(self.founders['first_name'],
            [self.john[0], self.george[0], self.tom[0]])

        self.assertEqual(self.founders['last_name'],
            [self.john[1], self.george[1], self.tom[1]])

        self.assertEqual(self.founders['gpa'],
            [self.john[2], self.george[2], self.tom[2]])


    def test_get_col(self):
        """Verify getting columns by index"""

        self.assertEqual(
            self.founders.get_col(list(self.headers).index('first_name')),
            [self.john[0], self.george[0], self.tom[0]])

        self.assertEqual(
            self.founders.get_col(list(self.headers).index('last_name')),
            [self.john[1], self.george[1], self.tom[1]])

        self.assertEqual(
            self.founders.get_col(list(self.headers).index('gpa')),
            [self.john[2], self.george[2], self.tom[2]])


    def test_data_slicing(self):
        """Verify slicing by data."""

        # Slice individual rows
        self.assertEqual(self.founders[0], self.john)
        self.assertEqual(self.founders[:1], [self.john])
        self.assertEqual(self.founders[1:2], [self.george])
        self.assertEqual(self.founders[-1], self.tom)
        self.assertEqual(self.founders[3:], [])

        # Slice multiple rows
        self.assertEqual(self.founders[:], [self.john, self.george, self.tom])
        self.assertEqual(self.founders[0:2], [self.john, self.george])
        self.assertEqual(self.founders[1:3], [self.george, self.tom])
        self.assertEqual(self.founders[2:], [self.tom])


    def test_delete(self):
        """Verify deleting from dataset works."""

        # Delete from front of object
        del self.founders[0]
        self.assertEqual(self.founders[:], [self.george, self.tom])

        # Verify dimensions, width should NOT change
        self.assertEqual(self.founders.height, 2)
        self.assertEqual(self.founders.width, 3)

        # Delete from back of object
        del self.founders[1]
        self.assertEqual(self.founders[:], [self.george])

        # Verify dimensions, width should NOT change
        self.assertEqual(self.founders.height, 1)
        self.assertEqual(self.founders.width, 3)

        # Delete from invalid index
        self.assertRaises(IndexError, self.founders.__delitem__, 3)


    def test_csv_export(self):
        """Verify exporting dataset object as CSV."""

        # Build up the csv string with headers first, followed by each row
        csv = ''
        for col in self.headers:
            csv += col + ','

        csv = csv.strip(',') + '\r\n'

        for founder in self.founders:
            for col in founder:
                csv += str(col) + ','
            csv = csv.strip(',') + '\r\n'

        self.assertEqual(csv, self.founders.csv)


    def test_tsv_export(self):
        """Verify exporting dataset object as TSV."""

        # Build up the tsv string with headers first, followed by each row
        tsv = ''
        for col in self.headers:
            tsv += col + '\t'

        tsv = tsv.strip('\t') + '\r\n'

        for founder in self.founders:
            for col in founder:
                tsv += str(col) + '\t'
            tsv = tsv.strip('\t') + '\r\n'

        self.assertEqual(tsv, self.founders.tsv)


    def test_html_export(self):
        """HTML export"""

        html = markup.page()
        html.table.open()
        html.thead.open()

        html.tr(markup.oneliner.th(self.founders.headers))
        html.thead.close()

        for founder in self.founders:

            html.tr(markup.oneliner.td(founder))

        html.table.close()
        html = str(html)

        self.assertEqual(html, self.founders.html)


    def test_html_export_none_value(self):
        """HTML export"""

        html = markup.page()
        html.table.open()
        html.thead.open()

        html.tr(markup.oneliner.th(['foo','', 'bar']))
        html.thead.close()

        html.tr(markup.oneliner.td(['foo','', 'bar']))

        html.table.close()
        html = str(html)

        headers = ['foo', None, 'bar'];
        d = tablib.Dataset(['foo', None, 'bar'], headers=headers)

        self.assertEqual(html, d.html)


    def test_unicode_append(self):
        """Passes in a single unicode character and exports."""

        if is_py3:
            new_row = ('', '')
        else:
            exec("new_row = (u'', u'')")


        data.append(new_row)

        data.json
        data.yaml
        data.csv
        data.tsv
        data.xls
        data.xlsx
        data.ods
        data.html


    def test_book_export_no_exceptions(self):
        """Test that various exports don't error out."""

        book = tablib.Databook()
        book.add_sheet(data)

        book.json
        book.yaml
        book.xls
        book.xlsx
        book.ods


    def test_json_import_set(self):
        """Generate and import JSON set serialization."""
        data.append(self.john)
        data.append(self.george)
        data.headers = self.headers

        _json = data.json

        data.json = _json

        self.assertEqual(json.loads(_json), json.loads(data.json))


    def test_json_import_book(self):
        """Generate and import JSON book serialization."""
        data.append(self.john)
        data.append(self.george)
        data.headers = self.headers

        book.add_sheet(data)
        _json = book.json

        book.json = _json

        self.assertEqual(json.loads(_json), json.loads(book.json))


    def test_yaml_import_set(self):
        """Generate and import YAML set serialization."""
        data.append(self.john)
        data.append(self.george)
        data.headers = self.headers

        _yaml = data.yaml

        data.yaml = _yaml

        self.assertEqual(_yaml, data.yaml)


    def test_yaml_import_book(self):
        """Generate and import YAML book serialization."""
        data.append(self.john)
        data.append(self.george)
        data.headers = self.headers

        book.add_sheet(data)
        _yaml = book.yaml

        book.yaml = _yaml

        self.assertEqual(_yaml, book.yaml)


    def test_csv_import_set(self):
        """Generate and import CSV set serialization."""
        data.append(self.john)
        data.append(self.george)
        data.headers = self.headers

        _csv = data.csv

        data.csv = _csv

        self.assertEqual(_csv, data.csv)


    def test_csv_import_set_with_spaces(self):
        """Generate and import CSV set serialization when row values have
        spaces."""
        data.append(('Bill Gates', 'Microsoft'))
        data.append(('Steve Jobs', 'Apple'))
        data.headers = ('Name', 'Company')

        _csv = data.csv

        data.csv = _csv

        self.assertEqual(_csv, data.csv)


    def test_csv_import_set_with_newlines(self):
        """Generate and import CSV set serialization when row values have
        newlines."""
        data.append(('Markdown\n=======',
                     'A cool language\n\nwith paragraphs'))
        data.append(('reStructedText\n==============',
                     'Another cool language\n\nwith paragraphs'))
        data.headers = ('title', 'body')

        _csv = data.csv

        data.csv = _csv

        self.assertEqual(_csv, data.csv)


    def test_tsv_import_set(self):
        """Generate and import TSV set serialization."""
        data.append(self.john)
        data.append(self.george)
        data.headers = self.headers

        _tsv = data.tsv

        data.tsv = _tsv

        self.assertEqual(_tsv, data.tsv)


    def test_csv_format_detect(self):
        """Test CSV format detection."""

        _csv = (
            '1,2,3\n'
            '4,5,6\n'
            '7,8,9\n'
        )
        _bunk = (
            ''
        )

        self.assertTrue(tablib.formats.csv.detect(_csv))
        self.assertFalse(tablib.formats.csv.detect(_bunk))


    def test_tsv_format_detect(self):
        """Test TSV format detection."""

        _tsv = (
            '1\t2\t3\n'
            '4\t5\t6\n'
            '7\t8\t9\n'
        )
        _bunk = (
            ''
        )

        self.assertTrue(tablib.formats.tsv.detect(_tsv))
        self.assertFalse(tablib.formats.tsv.detect(_bunk))


    def test_json_format_detect(self):
        """Test JSON format detection."""

        _json = '[{"last_name": "Adams","age": 90,"first_name": "John"}]'
        _bunk = (
            ''
        )

        self.assertTrue(tablib.formats.json.detect(_json))
        self.assertFalse(tablib.formats.json.detect(_bunk))


    def test_yaml_format_detect(self):
        """Test YAML format detection."""

        _yaml = '- {age: 90, first_name: John, last_name: Adams}'
        _tsv = 'foo\tbar'
        _bunk = (
            '---///\n\n\n'
        )

        self.assertTrue(tablib.formats.yaml.detect(_yaml))
        self.assertFalse(tablib.formats.yaml.detect(_bunk))
        self.assertFalse(tablib.formats.yaml.detect(_tsv))


    def test_auto_format_detect(self):
        """Test auto format detection."""

        _yaml = '- {age: 90, first_name: John, last_name: Adams}'
        _json = '[{"last_name": "Adams","age": 90,"first_name": "John"}]'
        _csv = '1,2,3\n4,5,6\n7,8,9\n'
        _tsv = '1\t2\t3\n4\t5\t6\n7\t8\t9\n'
        _bunk = '---///\n\n\n'

        self.assertEqual(tablib.detect(_yaml)[0], tablib.formats.yaml)
        self.assertEqual(tablib.detect(_csv)[0], tablib.formats.csv)
        self.assertEqual(tablib.detect(_tsv)[0], tablib.formats.tsv)
        self.assertEqual(tablib.detect(_json)[0], tablib.formats.json)
        self.assertEqual(tablib.detect(_bunk)[0], None)


    def test_transpose(self):
        """Transpose a dataset."""

        transposed_founders = self.founders.transpose()
        first_row = transposed_founders[0]
        second_row = transposed_founders[1]

        self.assertEqual(transposed_founders.headers,
                  ["first_name","John", "George", "Thomas"])
        self.assertEqual(first_row,
                   ("last_name","Adams", "Washington", "Jefferson"))
        self.assertEqual(second_row,
                   ("gpa",90, 67, 50))


    def test_row_stacking(self):
        """Row stacking."""

        to_join = tablib.Dataset(headers=self.founders.headers)

        for row in self.founders:
            to_join.append(row=row)

        row_stacked = self.founders.stack(to_join)

        for column in row_stacked.headers:

            original_data = self.founders[column]
            expected_data = original_data + original_data
            self.assertEqual(row_stacked[column], expected_data)


    def test_column_stacking(self):
        """Column stacking"""

        to_join = tablib.Dataset(headers=self.founders.headers)

        for row in self.founders:
            to_join.append(row=row)

        column_stacked = self.founders.stack_cols(to_join)

        for index, row in enumerate(column_stacked):

            original_data = self.founders[index]
            expected_data = original_data + original_data
            self.assertEqual(row, expected_data)

        self.assertEqual(column_stacked[0],
                   ("John", "Adams", 90, "John", "Adams", 90))


    def test_sorting(self):
        """Sort columns."""

        sorted_data = self.founders.sort(col="first_name")
        self.assertEqual(sorted_data.title, 'Founders')

        first_row = sorted_data[0]
        second_row = sorted_data[2]
        third_row = sorted_data[1]
        expected_first = self.founders[1]
        expected_second = self.founders[2]
        expected_third = self.founders[0]

        self.assertEqual(first_row, expected_first)
        self.assertEqual(second_row, expected_second)
        self.assertEqual(third_row, expected_third)


    def test_wipe(self):
        """Purge a dataset."""

        new_row = (1, 2, 3)
        data.append(new_row)

        # Verify width/data
        self.assertTrue(data.width == len(new_row))
        self.assertTrue(data[0] == new_row)

        data.wipe()
        new_row = (1, 2, 3, 4)
        data.append(new_row)
        self.assertTrue(data.width == len(new_row))
        self.assertTrue(data[0] == new_row)


    def test_formatters(self):
        """Confirm formatters are being triggered."""

        def _formatter(cell_value):
            return str(cell_value).upper()

        self.founders.add_formatter('last_name', _formatter)

        for name in [r['last_name'] for r in self.founders.dict]:
            self.assertTrue(name.isupper())

    def test_unicode_csv(self):
        """Check if unicode in csv export doesn't raise."""

        data = tablib.Dataset()

        if sys.version_info[0] > 2:
            data.append(['\xfc', '\xfd'])
        else:
            exec("data.append([u'\xfc', u'\xfd'])")


        data.csv

    def test_csv_column_select(self):
        """Build up a CSV and test selecting a column"""

        data = tablib.Dataset()
        data.csv = self.founders.csv

        headers = data.headers
        self.assertTrue(isinstance(headers[0], unicode))

        orig_first_name = self.founders[self.headers[0]]
        csv_first_name = data[headers[0]]
        self.assertEqual(orig_first_name, csv_first_name)


    def test_csv_column_delete(self):
        """Build up a CSV and test deleting a column"""

        data = tablib.Dataset()
        data.csv = self.founders.csv

        target_header = data.headers[0]
        self.assertTrue(isinstance(target_header, unicode))

        del data[target_header]

        self.assertTrue(target_header not in data.headers)

    def test_csv_column_sort(self):
        """Build up a CSV and test sorting a column by name"""

        data = tablib.Dataset()
        data.csv = self.founders.csv

        orig_target_header = self.founders.headers[1]
        target_header = data.headers[1]

        self.founders.sort(orig_target_header)
        data.sort(target_header)

        self.assertEqual(self.founders[orig_target_header], data[target_header])

    def test_unicode_renders_markdown_table(self):
        # add another entry to test right field width for
        # integer
        self.founders.append(('Old', 'Man', 100500))

        self.assertEqual(
            """
first_name|last_name |gpa   
----------|----------|------
John      |Adams     |90    
George    |Washington|67    
Thomas    |Jefferson |50    
Old       |Man       |100500
""".strip(),
            unicode(self.founders)
        )


    def test_databook_add_sheet_accepts_only_dataset_instances(self):
        class NotDataset(object):
            def append(self, item):
                pass

        dataset = NotDataset()
        dataset.append(self.john)

        self.assertRaises(tablib.InvalidDatasetType, book.add_sheet, dataset)


    def test_databook_add_sheet_accepts_dataset_subclasses(self):
        class DatasetSubclass(tablib.Dataset):
            pass

        # just checking if subclass of tablib.Dataset can be added to Databook
        dataset = DatasetSubclass()
        dataset.append(self.john)
        dataset.append(self.tom)

        try:
            book.add_sheet(dataset)
        except tablib.InvalidDatasetType:
            self.fail("Subclass of tablib.Dataset should be accepted by Databook.add_sheet")

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = toy
# -*- coding: utf-8 -*-

import tablib

d = tablib.Dataset()

with open('/Users/kreitz/Desktop/test.json') as f:
    d.json = f.read()

# del d[900:]

# print d.height

print len(d.ods)


########NEW FILE########
