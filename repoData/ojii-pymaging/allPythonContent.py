__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Pymaging documentation build configuration file, created by
# sphinx-quickstart on Mon Mar 12 10:51:31 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.intersphinx']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Pymaging'
copyright = u'2012, Jonas Obrist'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.0'
# The full version, including alpha/beta/rc tags.
release = '0.0.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Pymagingdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Pymaging.tex', u'Pymaging Documentation',
   u'Jonas Obrist', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pymaging', u'Pymaging Documentation',
     [u'Jonas Obrist'], 1)
]

intersphinx_mapping = {
    'python': ('http://docs.python.org/3.2', None),
    'distribute': ('http://packages.python.org/distribute/', None),
}


########NEW FILE########
__FILENAME__ = affine
from math import pi, cos, sin

_IDENTITY = (1, 0, 0, 0, 1, 0, 0, 0, 1)


class AffineTransform(object):
    """
    2-dimensional affine-transform implementation in pure python.

    Initialise with a tuple (a, b, c, d, e, f, g, h, i), representing
    the affine transform given by the following matrix:
        | a b c |
        | d e f |
        | g h i |
    """

    def __init__(self, matrix=_IDENTITY):
        if len(matrix) == 3:
            # accept 3x3 tuples
            matrix = matrix[0] + matrix[1] + matrix[2]
        if len(matrix) != 9:
            raise ValueError("AffineTransform expects a 9-tuple, or a 3x3 tuple")
        self.matrix = tuple(matrix)

    def __repr__(self):
        return '%s(\n  %g, %g, %g,\n  %g, %g, %g,\n  %g, %g, %g\n)' % (
            (self.__class__.__name__,) + self.matrix
        )

    def __eq__(self, other):
        if not hasattr(other, 'matrix'):
            return False
        return self.matrix == other.matrix

    def __mul__(self, other):
        """
        Multiply this affine transformation by something.
        Accepts:
            * another AffineTransform:
                ``A * B``
            * a scalar:
                ``A * 3``
        """
        if not isinstance(other, AffineTransform):
            if isinstance(other, (tuple, list)):
                if len(other) not in (2, 3):
                    raise ValueError(
                        "AffineTransform can only be multiplied by vectors of length 2 or 3"
                    )
                sm = self.matrix
                if len(other) == 3:
                    return (
                        other[0] * sm[0] + other[1] * sm[3] + other[2] * sm[6],
                        other[0] * sm[1] + other[1] * sm[4] + other[2] * sm[7],
                        other[0] * sm[2] + other[1] * sm[5] + other[2] * sm[8],
                    )
                else:
                    return (
                        other[0] * sm[0] + other[1] * sm[3] + sm[6],
                        other[0] * sm[1] + other[1] * sm[4] + sm[7],
                    )
            # scalars: accept any arg we can convert to float
            try:
                s = float(other)
            except (ValueError, TypeError):
                # this will throw a TypeError (unsupported operand type)
                return NotImplemented
            # scalar multiplications are the same as scale matrix multiplications
            other = AffineTransform((
                s, 0, 0,
                0, s, 0,
                0, 0, s,
            ))

        sm = self.matrix
        om = other.matrix
        return AffineTransform((
            sm[0] * om[0] + sm[1] * om[3] + sm[2] * om[6],
            sm[0] * om[1] + sm[1] * om[4] + sm[2] * om[7],
            sm[0] * om[2] + sm[1] * om[5] + sm[2] * om[8],
            sm[3] * om[0] + sm[4] * om[3] + sm[5] * om[6],
            sm[3] * om[1] + sm[4] * om[4] + sm[5] * om[7],
            sm[3] * om[2] + sm[4] * om[5] + sm[5] * om[8],
            sm[6] * om[0] + sm[7] * om[3] + sm[8] * om[6],
            sm[6] * om[1] + sm[7] * om[4] + sm[8] * om[7],
            sm[6] * om[2] + sm[7] * om[5] + sm[8] * om[8],
        ))

    def __rmul__(self, other):
        if not isinstance(other, AffineTransform):
            if not isinstance(other, (tuple, list)):
                # support commutative multiplying for scalars
                # (i.e. 3 * A == A * 3)
                return self.__mul__(other)
        return NotImplemented

    def __truediv__(self, other):
        if isinstance(other, AffineTransform):
            return self * other.inverse()
        else:
            # scalar division
            return self * (1.0 / other)
    __div__ = __truediv__

    def _determinant(self):
        """
        Returns the determinant of this 3x3 matrix.
        """
        # http://en.wikipedia.org/wiki/Inverse_matrix#Inversion_of_3.C3.973_matrices
        a, b, c, d, e, f, g, h, k = self.matrix
        return (
            a * (e * k - f * h)
            - b * (k * d - f * g)
            + c * (d * h - e * g)
        )

    def inverse(self):
        """
        Returns an AffineTransform which represents this AffineTransform's inverse.
        """
        det = self._determinant()
        if det == 0:
            # this can happen for instance if you divide by a transform whose
            # matrix is filled with zeroes.
            raise ValueError("This AffineTransform doesn't have a valid inverse.")

        # http://en.wikipedia.org/wiki/Inverse_matrix#Inversion_of_3.C3.973_matrices
        a, b, c, d, e, f, g, h, k = self.matrix
        return (1.0 / det) * AffineTransform((
            e * k - f * h, c * h - b * k, b * f - c * e,
            f * g - d * k, a * k - c * g, c * d - a * f,
            d * h - e * g, g * b - a * h, a * e - b * d,
        ))

    def rotate(self, degrees, clockwise=False):
        """
        Returns an AffineTransform which is rotated by the given number
        of degrees. Anticlockwise unless clockwise=True is given.
        """
        degrees %= 360
        if clockwise:
            degrees = 360 - degrees
        theta = degrees * pi / 180.0

        # HACK: limited precision of floats means rotate() operations
        # often cause numbers like 1.2246467991473532e-16.
        # So we round() those to 15 decimal digits. Better solution welcome :/
        rotation = AffineTransform((
            round(cos(theta), 15), round(-sin(theta), 15), 0,
            round(sin(theta), 15), round(cos(theta), 15), 0,
            0, 0, 1,
        ))
        return self * rotation

    def scale(self, x_factor, y_factor=None):
        if y_factor is None:
            y_factor = x_factor
        return self * AffineTransform((
            x_factor, 0, 0,
            0, y_factor, 0,
            0, 0, 1,
        ))

    def translate(self, dx, dy):
        return self * AffineTransform((
            1, 0, 0,
            0, 1, 0,
            dx, dy, 1,
        ))

########NEW FILE########
__FILENAME__ = colors
# -*- coding: utf-8 -*-
# Copyright (c) 2012, Jonas Obrist
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#    * Neither the name of the Jonas Obrist nor the
#      names of its contributors may be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL JONAS OBRIST BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
from __future__ import division
from collections import namedtuple


def _mixin_alpha(colors, alpha):
    ratio = alpha / 255
    return [int(round(color *  ratio)) for color in colors]

class Color(object):
    __slots__ = 'red', 'green', 'blue', 'alpha'

    def __init__(self, red, green, blue, alpha=255):
        self.red = red
        self.green = green
        self.blue = blue
        self.alpha = alpha

    def __str__(self):
        return 'Color: r:%s, g:%s, b:%s, a:%s' % (self.red, self.green, self.blue, self.alpha)

    def __repr__(self):
        return '<%s>' % self

    def __hash__(self):
        return hash((self.red, self.green, self.blue, self.alpha))

    def __eq__(self, other):
        return (
            self.red == other.red and
            self.green == other.green and
            self.blue == other.blue and
            self.alpha == other.alpha
        )

    @classmethod
    def from_pixel(cls, pixel):
        """
        Convert a pixel (list of 3-4 values) to a Color instance.
        """
        assert len(pixel) in (3,4), "Color.from_pixel only supports 3 and 4 value pixels"
        return cls(*map(int, list(pixel)))

    @classmethod
    def from_hexcode(cls, hexcode):
        """
        Convert hexcode to RGB/RGBA.
        """
        hexcode = hexcode.strip('#')
        assert len(hexcode) in (3,4,6,8), "Hex codes must be 3, 4, 6 or 8 characters long"
        if len(hexcode) in (3,4):
            hexcode = ''.join(x*2 for x in hexcode)
        return cls(*[int(''.join(x), 16) for x in zip(hexcode[::2], hexcode[1::2])])

    def get_for_brightness(self, brightness):
        """
        Brightness is a float between 0 and 1
        """
        return Color(self.red, self.green, self.blue, int(round((self.alpha + 1) * brightness)) - 1)

    def cover_with(self, cover_color):
        """
        Mix the two colors respecting their alpha value.

        Puts cover_color over itself compositing the colors using the alpha
        values.
        """
        # fastpath for solid colors
        if cover_color.alpha == 255:
            return Color(cover_color.red, cover_color.green, cover_color.blue, cover_color.alpha)

        srca = cover_color.alpha / 255
        dsta = self.alpha / 255
        outa = srca + dsta * (1 - srca)

        srcr, srcg, srcb = cover_color.red, cover_color.green, cover_color.blue
        dstr, dstg, dstb = self.red, self.green, self.blue

        outr = (srcr * srca + dstr * dsta * (1 - srca)) / outa
        outg = (srcg * srca + dstg * dsta * (1 - srca)) / outa
        outb = (srcb * srca + dstb * dsta * (1 - srca)) / outa

        red = int(round(outr))
        green = int(round(outg))
        blue = int(round(outb))
        alpha = int(round(outa * 255))

        return Color(red, green, blue, alpha)


    def to_pixel(self, pixelsize):
        """
        Convert to pixel (list of 3-4 values)
        """
        assert pixelsize in (3,4), "Color.to_pixel only supports 3 and 4 value pixels"
        if pixelsize == 3:
            return _mixin_alpha([self.red, self.green, self.blue], self.alpha)
        else:
            return [self.red, self.green, self.blue, self.alpha]

    def to_hexcode(self):
        """
        Convert to RGBA hexcode
        """
        return ''.join(hex(x)[2:] for x in (self.red, self.green, self.blue, self.alpha))


ColorType = namedtuple('ColorType', 'length alpha')

RGB = ColorType(3, False)
RGBA = ColorType(4, True)

########NEW FILE########
__FILENAME__ = exceptions
# -*- coding: utf-8 -*-
# Copyright (c) 2012, Jonas Obrist
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#    * Neither the name of the Jonas Obrist nor the
#      names of its contributors may be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL JONAS OBRIST BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


class PymagingException(Exception): pass

class FormatNotSupported(PymagingException): pass
class InvalidColor(PymagingException): pass

########NEW FILE########
__FILENAME__ = formats
# -*- coding: utf-8 -*-
# Copyright (c) 2012, Jonas Obrist
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#    * Neither the name of the Jonas Obrist nor the
#      names of its contributors may be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL JONAS OBRIST BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
from collections import namedtuple
import threading

Format = namedtuple('Format', 'open save extensions')



class FormatRegistry(object):
    # Use the Borg pattern to share state between all instances. Details at
    # http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/66531.
    __shared_state = dict(
        names = {},
        formats = [],

        # -- Everything below here is only used when populating the registry --
        loaded = False,
        write_lock = threading.RLock(),
    )

    def __init__(self):
        self.__dict__ = self.__shared_state
    
    def _populate(self):
        if self.loaded:
            return
        with self.write_lock:
            import pkg_resources
            for entry_point in pkg_resources.iter_entry_points('pymaging.formats'):
                format = entry_point.load()
                self.register(format)
            self.loaded = True
    
    def register(self, format):
        self.formats.append(format)
        for extension in format.extensions:
            self.names[extension] = format
        
    def get_format_objects(self):
        self._populate()
        return self.formats
    
    def get_format(self, format):
        self._populate()
        return self.names.get(format, None)

registry = FormatRegistry()
get_format_objects = registry.get_format_objects
get_format = registry.get_format
register = registry.register

########NEW FILE########
__FILENAME__ = helpers
# -*- coding: utf-8 -*-
# Copyright (c) 2012, Jonas Obrist
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#    * Neither the name of the Jonas Obrist nor the
#      names of its contributors may be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL JONAS OBRIST BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
from math import ceil


def get_transformed_dimensions(transform, box):
    """
    Takes an affine transform and a four-tuple of (x0, y0, x1, y1)
    coordinates.
    Transforms each corner of the given box, and returns the
    (width, height) of the transformed box.
    """
    (x0, y0, x1, y1) = box
    xs = []
    ys = []
    for corner in (
        (x0, y0),
        (x1, y0),
        (x0, y1),
        (x1, y1),
    ):
        x, y = transform * corner
        xs.append(x)
        ys.append(y)

    return int(ceil(max(xs))) - int(min(xs)), int(ceil(max(ys))) - int(min(ys))

########NEW FILE########
__FILENAME__ = image
# -*- coding: utf-8 -*-
# Copyright (c) 2012, Jonas Obrist
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#    * Neither the name of the Jonas Obrist nor the
#      names of its contributors may be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL JONAS OBRIST BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
import array
from pymaging.colors import Color
from pymaging.affine import AffineTransform
from pymaging.exceptions import FormatNotSupported, InvalidColor
from pymaging.formats import get_format, get_format_objects
from pymaging.helpers import get_transformed_dimensions
from pymaging.pixelarray import get_pixel_array
from pymaging.resample import nearest
import os



class Image(object):
    def __init__(self, mode, width, height, loader, meta=None):
        self.mode = mode
        self.width = width
        self.height = height
        self.loader = loader
        self.meta = meta
        self._pixelarray = None
        self._palette = None
        self.reverse_palette = None

    @property
    def pixels(self):
        self.load()
        return self._pixelarray

    @property
    def pixelsize(self):
        return self.pixels.pixelsize

    @property
    def palette(self):
        self.load()
        return self._palette

    #==========================================================================
    # Constructors
    #==========================================================================

    @classmethod
    def open(cls, fileobj):
        for format in get_format_objects():
            image = format.open(fileobj)
            if image:
                return image
        raise FormatNotSupported()

    @classmethod
    def open_from_path(cls, filepath):
        with open(filepath, 'rb') as fobj:
            return cls.open(fobj)

    @classmethod
    def new(cls, mode, width, height, background_color, palette=None, meta=None):
        color = background_color.to_pixel(mode.length)
        pixel_array = get_pixel_array(array.array('B', color) * width * height, width, height, mode.length)
        return LoadedImage(mode, width, height, pixel_array, palette=palette, meta=meta)

    def load(self):
        if self._pixelarray is not None:
            return
        self._pixelarray, self._palette = self.loader()

    #==========================================================================
    # Saving
    #==========================================================================

    def save(self, fileobj, format):
        format_object = get_format(format)
        if not format_object:
            raise FormatNotSupported(format)
        format_object.save(self, fileobj)

    def save_to_path(self, filepath, format=None):
        if not format:
            format = os.path.splitext(filepath)[1][1:]
        with open(filepath, 'wb') as fobj:
            self.save(fobj, format)

    #==========================================================================
    # Helpers
    #==========================================================================

    def get_reverse_palette(self):
        if self.reverse_palette is None:
            self._fill_reverse_palette()
        return self.reverse_palette

    def _fill_reverse_palette(self):
        self.reverse_palette = {}
        if not self.palette:
            return
        for index, color in enumerate(self.palette):
            color_obj = Color.from_pixel(color)
            color_obj.to_hexcode()
            self.reverse_palette[color_obj] = index

    def _copy(self, pixels, **kwargs):
        defaults = {
            'mode': self.mode,
            'width': self.width,
            'height': self.height,
            'palette': self.palette,
            'meta': self.meta,
        }
        defaults.update(kwargs)
        defaults['pixels'] = pixels
        return LoadedImage(**defaults)

    #==========================================================================
    # Geometry Operations
    #==========================================================================

    def resize(self, width, height, resample_algorithm=nearest, resize_canvas=True):
        pixels = resample_algorithm.resize(
            self, width, height, resize_canvas=resize_canvas
        )
        return self._copy(pixels)

    def affine(self, transform, resample_algorithm=nearest, resize_canvas=True):
        """
        Returns a copy of this image transformed by the given
        AffineTransform.
        """
        pixels = resample_algorithm.affine(
            self,
            transform,
            resize_canvas=resize_canvas,
        )
        return self._copy(pixels)

    def rotate(self, degrees, clockwise=False, resample_algorithm=nearest, resize_canvas=True):
        """
        Returns the image obtained by rotating this image by the
        given number of degrees.
        Anticlockwise unless clockwise=True is given.
        """
        # translate to the origin first, then rotate, then translate back
        transform = AffineTransform()
        transform = transform.translate(self.width * -0.5, self.height * -0.5)
        transform = transform.rotate(degrees, clockwise=clockwise)

        width, height = self.width, self.height
        if resize_canvas:
            # determine new width
            width, height = get_transformed_dimensions(transform, (0, 0, width, height))

        transform = transform.translate(width * 0.5, height * 0.5)

        pixels = resample_algorithm.affine(self, transform, resize_canvas=resize_canvas)

        return self._copy(pixels)

    def get_pixel(self, x, y):
        try:
            raw_pixel = self.pixels.get(x, y)
        except IndexError:
            raise IndexError("Pixel (%d, %d) not in image" % (x, y))
        if self.pixelsize == 1 and self.palette:
            return self.palette[raw_pixel[0]]
        else:
            return raw_pixel

    def get_color(self, x, y):
        return Color.from_pixel(self.get_pixel(x, y))

    def set_color(self, x, y, color):
        if color.alpha != 255:
            base = self.get_color(x, y)
            color = base.cover_with(color)
        if self.reverse_palette and self.pixelsize == 1:
            if color not in self.reverse_palette:
                raise InvalidColor(str(color))
            index = self.reverse_palette[color]
            self.pixels.set(x, y, [index])
        else:
            self.pixels.set(x, y, color.to_pixel(self.pixelsize))

    def flip_top_bottom(self):
        """
        Vertically flips the pixels of source into target
        """
        pixels = self.pixels.copy_flipped_top_bottom()
        return self._copy(pixels)

    def flip_left_right(self):
        """
        Horizontally flips the pixels of source into target
        """
        return self._copy(pixels=self.pixels.copy_flipped_left_right())

    def crop(self, width, height, padding_top, padding_left):
        new_pixels = self.pixels.copy()
        new_pixels.remove_lines(0, padding_top)
        new_pixels.remove_lines(height, new_pixels.height - height)
        new_pixels.remove_columns(0, padding_left)
        new_pixels.remove_columns(width, new_pixels.width - width)
        return self._copy(new_pixels, width=width, height=height)

    #==========================================================================
    # Manipulation
    #==========================================================================

    def draw(self, shape, color):
        for x, y, pixelcolor in shape.iter_pixels(color):
            self.set_color(x, y, pixelcolor)

    def blit(self, padding_top, padding_left, image):
        """
        Puts the image given on top of this image with the given padding
        """
        # there *must* be a better/faster way to do this:
        # TODO: check that palettes etc match.
        # TODO: fastpath this by copying the array if pixelsize is identical/palette is the same
        for x in range(min([image.width, self.width - padding_left])):
            for y in range(min([image.height, self.height- padding_top])):
                self.set_color(padding_left + x, padding_top + y, image.get_color(x, y))



class LoadedImage(Image):
    def __init__(self, mode, width, height, pixels, palette=None, meta=None):
        self.mode = mode
        self.width = width
        self.height = height
        self.format = format
        self.loader = lambda:None
        self.meta = meta
        self._pixelarray = pixels
        self._palette = palette
        self.reverse_palette = None
########NEW FILE########
__FILENAME__ = pixelarray
# -*- coding: utf-8 -*-
import array
import copy


class GenericPixelArray(object):
    def __init__(self, data, width, height, pixelsize):
        self.data = data
        self.width = width
        self.height = height
        self.pixelsize = pixelsize
        self._precalculate()

    def __repr__(self):
        nice_pixels = '\n'.join([' '.join(['%%%dd' % self.pixelsize % x for x in self.data[i * self.line_length:(i + 1) * self.line_length]]) for i in range(self.height)])
        return '\n%s\n(width=%s, height=%s, pixelsize=%s)' % (nice_pixels, self.width, self.height, self.pixelsize)

    def __eq__(self, other):
        """
        Mostly used for testing
        """
        return self.data == other.data and self.width == other.width and self.height == other.height and self.pixelsize == other.pixelsize

    def _precalculate(self):
        """
        Precalculate some values, this must be called whenever self.width, self.height or self.pixelsize is changed.
        """
        self.line_length = self.width * self.pixelsize
        self.size = self.line_length * self.height

    def _translate(self, x, y):
        """
        Translates a x/y coordinate into the start index.
        """
        return (y * self.line_length) + (x * self.pixelsize)

    def get(self, x, y):
        """
        Returns the pixel (a tuple of length `self.pixelsize`) from the pixel array at x/y
        """
        start = self._translate(x, y)
        return [self.data[start+i] for i in range(self.pixelsize)]

    def set(self, x, y, pixel):
        """
        Sets the pixel (a tuple of length `self.pixelsize`) to the pixel array at x/y
        """
        start = self._translate(x, y)
        for i in range(self.pixelsize):
            self.data[start + i] = pixel[i]

    def copy_flipped_top_bottom(self):
        """
        Flip the lines from top to bottom into a new copy of this pixel array
        """
        newarr = array.array('B', [0]) *  self.size
        for i in range(self.height):
            dst_start = i * self.line_length
            dst_end = dst_start + self.line_length
            src_start = ((self.height - i) * self.line_length) - self.line_length
            src_end = src_start + self.line_length
            newarr[dst_start:dst_end] = self.data[src_start:src_end]
        return get_pixel_array(newarr, self.width, self.height, self.pixelsize)

    def copy_flipped_left_right(self):
        """
        Flip the lines from left to right into a new copy of this pixel array
        """
        new_pixel_array = get_pixel_array(array.array('B', [0]) *  self.size, 
                                          self.width, self.height, self.pixelsize)
        for y in range(self.height):
            for dst_x in range(self.width):
                src_x = self.width - dst_x - 1
                new_pixel_array.set(dst_x, y, self.get(src_x, y))
        return new_pixel_array

    def copy(self):
        return get_pixel_array(copy.copy(self.data), self.width, self.height, self.pixelsize)

    def remove_lines(self, offset, amount):
        """
        Removes `amount` lines from the pixel array starting at line `offset`.
        """
        if not amount:
            return
        start = self.line_length * offset
        end = start + (amount * self.line_length)
        self.height -= amount
        del self.data[start:end]
        self._precalculate()

    def remove_columns(self, offset, amount):
        """
        Removes `amount` columns from the pixel array starting at column `offset`.
        """
        if not amount:
            return
        start = offset * self.pixelsize
        end = start + (amount * self.pixelsize)
        # reversed is used because otherwise line_start would be all messed up.
        for i in reversed(range(self.height)):
            line_start = i * self.line_length
            del self.data[line_start+start:line_start+end]
        self.width -= amount
        self._precalculate()

    def add_lines(self, offset, amount, fill=0):
        """
        Adds `amount` lines to the pixel array starting at `offset` and fills them with `fill`.
        """
        if not amount:
            return
            # special case for adding to the end of the array:
        if offset == self.height:
            self.data.extend(array.array(self.data.typecode, [fill] *  self.line_length * amount))
        else:
            start = offset * self.line_length
            self.data[start:start] = array.array(self.data.typecode, [fill] *  self.line_length * amount)
        self.height += amount
        self._precalculate()

    def add_columns(self, offset, amount, fill=0):
        """
        Adds `amount` columns to the pixel array starting at `offset` and fills them with `fill`.
        """
        if not amount:
            return
        start = offset * self.pixelsize
        for i in reversed(range(self.height)):
            line_start = (i * self.line_length) + start
            self.data[line_start:line_start] = array.array(self.data.typecode, [fill] * self.pixelsize * amount)
        self.width += amount
        self._precalculate()


class PixelArray1(GenericPixelArray):
    def __init__(self, data, width, height):
        super(PixelArray1, self).__init__(data, width, height, 1)

    def get(self, x, y):
        """
        Returns the pixel (a tuple of length `self.pixelsize`) from the pixel array at x/y
        """
        start = self._translate(x, y)
        return [self.data[start]]

    def set(self, x, y, pixel):
        """
        Sets the pixel (a tuple of length `self.pixelsize`) to the pixel array at x/y
        """
        start = self._translate(x, y)
        self.data[start] = pixel[0]


class PixelArray2(GenericPixelArray):
    def __init__(self, data, width, height):
        super(PixelArray2, self).__init__(data, width, height, 2)

    def get(self, x, y):
        """
        Returns the pixel (a tuple of length `self.pixelsize`) from the pixel array at x/y
        """
        start = self._translate(x, y)
        return [self.data[start], self.data[start + 1]]

    def set(self, x, y, pixel):
        """
        Sets the pixel (a tuple of length `self.pixelsize`) to the pixel array at x/y
        """
        start = self._translate(x, y)
        self.data[start] = pixel[0]
        self.data[start + 1] = pixel[1]


class PixelArray3(GenericPixelArray):
    def __init__(self, data, width, height):
        super(PixelArray3, self).__init__(data, width, height, 3)

    def get(self, x, y):
        """
        Returns the pixel (a tuple of length `self.pixelsize`) from the pixel array at x/y
        """
        start = self._translate(x, y)
        return [self.data[start], self.data[start + 1], self.data[start + 2]]

    def set(self, x, y, pixel):
        """
        Sets the pixel (a tuple of length `self.pixelsize`) to the pixel array at x/y
        """
        start = self._translate(x, y)
        self.data[start] = pixel[0]
        self.data[start + 1] = pixel[1]
        self.data[start + 2] = pixel[2]


class PixelArray4(GenericPixelArray):
    def __init__(self, data, width, height):
        super(PixelArray4, self).__init__(data, width, height, 4)

    def get(self, x, y):
        """
        Returns the pixel (a tuple of length `self.pixelsize`) from the pixel array at x/y
        """
        start = self._translate(x, y)
        return [self.data[start], self.data[start + 1], self.data[start + 2], self.data[start + 3]]

    def set(self, x, y, pixel):
        """
        Sets the pixel (a tuple of length `self.pixelsize`) to the pixel array at x/y
        """
        start = self._translate(x, y)
        self.data[start] = pixel[0]
        self.data[start + 1] = pixel[1]
        self.data[start + 2] = pixel[2]
        self.data[start + 3] = pixel[3]


def get_pixel_array(data, width, height, pixelsize):
    if pixelsize == 1:
        return PixelArray1(data, width, height)
    elif pixelsize == 2:
        return PixelArray2(data, width, height)
    elif pixelsize == 3:
        return PixelArray3(data, width, height)
    elif pixelsize == 4:
        return PixelArray4(data, width, height)
    else:
        return GenericPixelArray(data, width, height, pixelsize)

########NEW FILE########
__FILENAME__ = resample
# -*- coding: utf-8 -*-
# Copyright (c) 2012, Jonas Obrist
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#    * Neither the name of the Jonas Obrist nor the
#      names of its contributors may be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL JONAS OBRIST BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
from abc import ABCMeta, abstractmethod

from pymaging.pixelarray import get_pixel_array

__all__ = ('nearest', 'bilinear', 'Resampler')

from pymaging.affine import AffineTransform
from pymaging.helpers import get_transformed_dimensions
from pymaging.utils import fdiv
import array


class Resampler(object):
    __metaclass__ = ABCMeta

    @abstractmethod
    def _get_value(self, source, source_x, source_y, dx, dy):
        pass

    def affine(self, source, transform, resize_canvas=True):
        if resize_canvas:
            # get image dimensions
            width, height = get_transformed_dimensions(
                transform,
                (0, 0, source.width, source.height)
            )
        else:
            width = source.width
            height = source.height

        pixelsize = source.pixelsize

        # transparent or black background
        background = [0] * pixelsize

        # we want to go from dest coords to src coords:
        transform = transform.inverse()

        # Optimisation:
        # Because affine transforms have no perspective component,
        # the *gradient* of each source row/column must be constant.
        # So, we can calculate the source coordinates for each corner,
        # and then interpolate for each pixel, instead of doing a
        # matrix multiplication for each pixel.

        x_range = range(width)
        y_range = range(height)
        new_array = source.pixels.copy()

        for y in y_range:
            # the 0.5's mean we use the center of each pixel
            row_x0, row_y0 = transform * (0.5, y + 0.5)
            row_x1, row_y1 = transform * (width + 0.5, y + 0.5)

            dx = float(row_x1 - row_x0) / source.width
            dy = float(row_y1 - row_y0) / source.width

            for x in x_range:
                source_x = int(row_x0 + dx * x)
                source_y = int(row_y0 + dy * x)

                new_array.set(x, y,
                    self._get_value(source, source_x, source_y, dx, dy)
                    or background
                )
        return new_array

    def resize(self, source, width, height, resize_canvas=True):
        transform = AffineTransform().scale(
            width / float(source.width),
            height / float(source.height)
        )
        return self.affine(source, transform, resize_canvas=resize_canvas)


class Nearest(Resampler):

    def _get_value(self, source, source_x, source_y, dx, dy):
        if source_x < 0 or source_y < 0 or \
                    source_x >= source.width or source_y >= source.height:
            return None
        else:
            return source.pixels.get(source_y, source_x)

    def resize(self, source, width, height, resize_canvas=True):
        if not resize_canvas:
            # this optimised implementation doesn't deal with this.
            # so delegate to affine()
            return super(Nearest, self).resize(
                source, width, height, resize_canvas=resize_canvas
            )
        pixels = array.array('B')
        pixelsize = source.pixelsize

        x_ratio = fdiv(source.width, width)  # get the x-axis ratio
        y_ratio = fdiv(source.height, height)  # get the y-axis ratio

        y_range = range(height)  # an iterator over the indices of all lines (y-axis)
        x_range = range(width)  # an iterator over the indices of all rows (x-axis)
        for y in y_range:
            y += 0.5  # use the center of each pixel
            source_y = int(y * y_ratio)  # get the source line
            for x in x_range:
                x += 0.5  # use the center of each pixel
                source_x = int(x * x_ratio)  # get the source row
                pixels.extend(source.pixels.get(source_x, source_y))
        return get_pixel_array(pixels, width, height, pixelsize)


class Bilinear(Resampler):

    def _get_value(self, source, source_x, source_y, dx, dy):
        if source_x < 0 or source_y < 0 or \
                    source_x >= source.width or source_y >= source.height:
            return None

        source_y_i = int(source_y)
        source_x_i = int(source_x)

        weight_y0 = 1 - abs(source_y - source_y_i)
        weight_x0 = 1 - abs(source_x - source_x_i)

        pixelsize = source.pixelsize
        channel_sums = [0.0] * pixelsize
        has_alpha = source.mode.alpha
        color_channels_range = range(pixelsize - 1 if has_alpha else pixelsize)

        # populate <=4 nearest src_pixels, taking care not to go off
        # the edge of the image.
        src_pixels = [source.get_pixel(source_x_i, source_y_i), None, None, None]
        next_x = int(source_x + dx)
        next_y = int(source_x + dy)

        if next_x < source.width and next_x >= 0:
            src_pixels[1] = source.get_pixel(int(next_x), source_y_i)
        else:
            weight_x0 = 1
        if next_y < source.height and next_y >= 0:
            src_pixels[2] = source.get_pixel(source_x_i, next_y)
            if next_x < source.width and next_x >= 0:
                src_pixels[3] = source.get_pixel(next_x, next_y)
        else:
            weight_y0 = 1

        for i, src_pixel in enumerate(src_pixels):
            if src_pixel is None:
                continue
            weight_x = (1 - weight_x0) if (i % 2) else weight_x0
            weight_y = (1 - weight_y0) if (i // 2) else weight_y0
            alpha_weight = weight_x * weight_y
            color_weight = alpha_weight
            alpha = 255
            if has_alpha:
                alpha = src_pixel[-1]
                if not alpha:
                    continue
                color_weight *= (alpha / 255.0)
            for channel_index, channel_value in zip(color_channels_range, src_pixel):
                channel_sums[channel_index] += color_weight * channel_value

            if has_alpha:
                channel_sums[-1] += alpha_weight * alpha
        if has_alpha:
            total_alpha_multiplier = channel_sums[-1] / 255.0
            if total_alpha_multiplier:  # (avoid div/0)
                for channel_index in color_channels_range:
                    channel_sums[channel_index] /= total_alpha_multiplier

        return [int(round(s)) for s in channel_sums]

    def resize(self, source, width, height, resize_canvas=True):
        if not resize_canvas:
            # this optimised implementation doesn't deal with this.
            # so delegate to affine()
            return super(Bilinear, self).resize(
                source, width, height, resize_canvas=resize_canvas
            )
        x_ratio = fdiv(source.width, width)  # get the x-axis ratio
        y_ratio = fdiv(source.height, height)  # get the y-axis ratio
        pixelsize = source.pixelsize
        pixels = array.array('B')

        if source.palette:
            raise NotImplementedError("Resampling of paletted images is not yet supported")

        if x_ratio < 1 and y_ratio < 1:
            if not (width % source.width) and not (height % source.height):
                # optimisation: if doing a perfect upscale,
                # can just use nearest neighbor (it's much faster)
                return nearest.resize(source, width, height)

        has_alpha = source.mode.alpha
        color_channels_range = range(pixelsize - 1 if has_alpha else pixelsize)

        y_range = range(height)  # an iterator over the indices of all lines (y-axis)
        x_range = range(width)  # an iterator over the indices of all rows (x-axis)
        for y in y_range:
            src_y = (y + 0.5) * y_ratio - 0.5  # use the center of each pixel
            src_y_i = int(src_y)

            weight_y0 = 1 - abs(src_y - src_y_i)

            for x in x_range:
                src_x = (x + 0.5) * x_ratio - 0.5
                src_x_i = int(src_x)

                weight_x0 = 1 - abs(src_x - src_x_i)

                channel_sums = [0.0] * pixelsize

                # populate <=4 nearest src_pixels, taking care not to go off
                # the edge of the image.
                src_pixels = [source.get_color(src_y_i, src_x_i), None, None, None]
                if src_x_i + 1 < source.width:
                    src_pixels[1] = source.get_color(src_y_i, src_x_i + 1)
                else:
                    weight_x0 = 1
                if src_y_i + 1 < source.height:
                    src_pixels[2] = source.get_color(src_y_i + 1, src_x_i)
                    if src_x_i + 1 < source.height:
                        src_pixels[3] = source.get_color(src_y_i + 1, src_x_i + 1)
                else:
                    weight_y0 = 1

                for i, src_pixel in enumerate(src_pixels):
                    if src_pixel is None:
                        continue
                    src_pixel = src_pixel.to_pixel(pixelsize)
                    weight_x = (1 - weight_x0) if (i % 2) else weight_x0
                    weight_y = (1 - weight_y0) if (i // 2) else weight_y0
                    alpha_weight = weight_x * weight_y
                    color_weight = alpha_weight
                    alpha = 255
                    if has_alpha:
                        alpha = src_pixel[-1]
                        if not alpha:
                            continue
                        color_weight *= (alpha / 255.0)
                    for channel_index, channel_value in zip(color_channels_range, src_pixel):
                        channel_sums[channel_index] += color_weight * channel_value

                    if has_alpha:
                        channel_sums[-1] += alpha_weight * alpha
                if has_alpha:
                    total_alpha_multiplier = channel_sums[-1] / 255.0
                    if total_alpha_multiplier:  # (avoid div/0)
                        for channel_index in color_channels_range:
                            channel_sums[channel_index] /= total_alpha_multiplier
                pixels.extend([int(round(s)) for s in channel_sums])
        return get_pixel_array(pixels, width, height, pixelsize)


nearest = Nearest()
bilinear = Bilinear()

########NEW FILE########
__FILENAME__ = shapes
# -*- coding: utf-8 -*-
# Copyright (c) 2012, Jonas Obrist
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#    * Neither the name of the Jonas Obrist nor the
#      names of its contributors may be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL JONAS OBRIST BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from pymaging.utils import fdiv
import math


class BaseShape(object):
    def iter_pixels(self, color):
        raise StopIteration()


class Pixel(BaseShape):
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    def iter_pixels(self, color):
        yield self.x, self.y, color


class Line(Pixel):
    """
    Use Bresenham Line Algorithm (http://en.wikipedia.org/wiki/Bresenham's_line_algorithm):
    
    function line(x0, x1, y0, y1)
        boolean steep := abs(y1 - y0) > abs(x1 - x0)
        if steep then
            swap(x0, y0)
            swap(x1, y1)
        if x0 > x1 then
            swap(x0, x1)
            swap(y0, y1)
        int deltax := x1 - x0
        int deltay := abs(y1 - y0)
        real error := 0
        real deltaerr := deltay / deltax
        int ystep
        int y := y0
        if y0 < y1 then ystep := 1 else ystep := -1
        for x from x0 to x1
            if steep then plot(y,x) else plot(x,y)
            error := error + deltaerr
            if error  0.5 then
                y := y + ystep
                error := error - 1.0
    """
    def __init__(self, start_x, start_y, end_x, end_y):
        self.start_x = start_x
        self.start_y = start_y
        self.end_x = end_x
        self.end_y = end_y
        steep = abs(self.end_y - self.start_y) > abs(self.end_x - self.start_x)
        if steep:
            x0, y0 = self.start_y, self.start_x
            x1, y1 = self.end_y, self.end_x
        else:
            x0, y0 = self.start_x, self.start_y
            x1, y1 = self.end_x, self.end_y
        if x0 > x1:
            x0, x1 = x1, x0
            y0, y1 = y1, y0
        
        self.x0, self.x1, self.y0, self.y1 = x0, x1, y0, y1
        
        delta_x = x1 - x0
        delta_y = abs(y1 - y0)
        self.error = 0.0
        self.delta_error = fdiv(delta_y, delta_x)
        if y0 < y1:
            self.ystep = 1
        else:
            self.ystep = -1
        
        self.y = y0
        
        self.iterator = self.steep_iterator if steep else self.normal_iterator
        
    def steep_iterator(self):
        for x in range(self.x0, self.x1):
            yield self.y, x
            self.shift()
        yield self.y1, self.x1
        
    def normal_iterator(self):
        for x in range(self.x0, self.x1):
            yield x, self.y
            self.shift()
        yield self.x1, self.y1
    
    def shift(self):
        self.error += self.delta_error
        if self.error >= 0.5:
            self.y += self.ystep
            self.error -= 1.0
    
    def iter_pixels(self, color):
        for x, y in self.iterator():
            yield x, y, color


# For AntiAliasedLin
_round = lambda x: int(round(x))
_ipart = int # integer part of x
_fpart = lambda x: x - math.floor(x) # fractional part of x
_rfpart = lambda x: 1 - _fpart(x)

class AntiAliasedLine(Line):
    def __init__(self, start_x, start_y, end_x, end_y):
        self.start_x = start_x
        self.start_y = start_y
        self.end_x = end_x
        self.end_y = end_y

    def iter_pixels(self, color):
        """
        Use Xiaolin Wu's line algorithm: http://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm
        
        function plot(x, y, c) is
            plot the pixel at (x, y) with brightness c (where 0  c  1)
        
        function ipart(x) is
            return integer part of x
        
        function round(x) is
            return ipart(x + 0.5)
        
        function fpart(x) is
            return fractional part of x
        
        function rfpart(x) is
            return 1 - fpart(x)
        
        function drawLine(x1,y1,x2,y2) is
            dx = x2 - x1
            dy = y2 - y1
            if abs(dx) < abs(dy) then                 
              swap x1, y1
              swap x2, y2
              swap dx, dy
            end if
            if x2 < x1
              swap x1, x2
              swap y1, y2
            end if
            gradient = dy / dx
            
            // handle first endpoint
            xend = round(x1)
            yend = y1 + gradient * (xend - x1)
            xgap = rfpart(x1 + 0.5)
            xpxl1 = xend  // this will be used in the main loop
            ypxl1 = ipart(yend)
            plot(xpxl1, ypxl1, rfpart(yend) * xgap)
            plot(xpxl1, ypxl1 + 1, fpart(yend) * xgap)
            intery = yend + gradient // first y-intersection for the main loop
            
            // handle second endpoint
            xend = round (x2)
            yend = y2 + gradient * (xend - x2)
            xgap = fpart(x2 + 0.5)
            xpxl2 = xend  // this will be used in the main loop
            ypxl2 = ipart (yend)
            plot (xpxl2, ypxl2, rfpart (yend) * xgap)
            plot (xpxl2, ypxl2 + 1, fpart (yend) * xgap)
            
            // main loop
            for x from xpxl1 + 1 to xpxl2 - 1 do
                plot (x, ipart (intery), rfpart (intery))
                plot (x, ipart (intery) + 1, fpart (intery))
                intery = intery + gradient
        end function
        """
        def _plot(x, y, c):
            """
            plot the pixel at (x, y) with brightness c (where 0  c  1)
            """
            return int(x), int(y), color.get_for_brightness(c)
        dx = self.end_x - self.start_x
        dy = self.end_y - self.start_y
        x1, x2, y1, y2 = self.start_x, self.end_x, self.start_y, self.end_y
        if abs(dx) > abs(dy):
            x1, y1 = y1, x1
            x2, y2 = y2, x2
            dx, dy = dy, dx
        if x2 < x1:
            x1, x2 = x2, x1
            y1, y2 = y2, y1
        
        gradient = fdiv(dy, dx)
        
        xend = round(x1)
        yend = y1 + gradient * (xend - x1)
        xgap = _rfpart(x1 + 0.5)
        xpxl1 = xend 
        ypxl1 = _ipart(yend)
        yield _plot(xpxl1, ypxl1, _rfpart(yend) * xgap)
        yield _plot(xpxl1, ypxl1 + 1, _fpart(yend) * xgap)
        
        intery = yend + gradient
        
        xend = _round(x2)
        yend = y2 + gradient *  (xend - x2)
        xgap = _fpart(x2 + 0.5)
        xpxl2 = xend
        ypxl2 = _ipart(yend)
        yield _plot(xpxl2, ypxl2, _rfpart(yend) * xgap)
        yield _plot(xpxl2, ypxl2 + 1, _fpart(yend) * xgap)
        
        for x in range (xpxl1 + 1, xpxl2 - 1):
            yield _plot(x, _ipart(intery), _rfpart(intery))
            yield _plot(x, _ipart(intery) + 1, _fpart(intery))
            intery += gradient

########NEW FILE########
__FILENAME__ = test_affine
import unittest

from pymaging.affine import AffineTransform


class TestAffineTransform(unittest.TestCase):
    ## constructors
    def test_constructor_identity(self):
        a = AffineTransform()
        self.assertEqual(a.matrix, (1, 0, 0, 0, 1, 0, 0, 0, 1))

    def test_constructor_9tuple(self):
        a = AffineTransform((1, 2, 3, 4, 5, 6, 7, 8, 9))
        self.assertEqual(a.matrix, (1, 2, 3, 4, 5, 6, 7, 8, 9))

        self.assertRaises(ValueError, AffineTransform, (1, 2, 3, 4, 5, 6, 7, 8))

    def test_constructor_3x3tuple(self):
        a = AffineTransform(((1, 2, 3), (4, 5, 6), (7, 8, 9)))
        self.assertEqual(a.matrix, (1, 2, 3, 4, 5, 6, 7, 8, 9))

        self.assertRaises(ValueError, AffineTransform, ((1, 2, 3), (4, 5, 6)))
        self.assertRaises(ValueError, AffineTransform, ((1, 2), (3, 4), (5, 6)))

    def test_inverse(self):
        # identity inverse
        self.assertEqual(AffineTransform().inverse(), AffineTransform())

        self.assertEqual(
            AffineTransform((2, 0, 0, 0, 2, 0, 0, 0, 2)).inverse(),
            AffineTransform((0.5, 0, 0, 0, 0.5, 0, 0, 0, 0.5))
        )

        # inverted A*0 = A/0, which is an error
        self.assertRaises(ValueError, (AffineTransform() * 0).inverse)

    # binary operators
    def test_mult_scalar(self):
        a = AffineTransform() * 2
        self.assertEqual(a.matrix, (2, 0, 0, 0, 2, 0, 0, 0, 2))

        a = AffineTransform() * -1
        self.assertEqual(a.matrix, (-1, 0, 0, 0, -1, 0, 0, 0, -1))

    def test_rmult_scalar(self):
        a = 2 * AffineTransform()
        self.assertEqual(a.matrix, (2, 0, 0, 0, 2, 0, 0, 0, 2))

        a = -1 * AffineTransform()
        self.assertEqual(a.matrix, (-1, 0, 0, 0, -1, 0, 0, 0, -1))

    def test_div_scalar(self):
        a = AffineTransform() / 2
        self.assertEqual(a.matrix, (0.5, 0, 0, 0, 0.5, 0, 0, 0, 0.5))

    def test_mult_affine(self):
        a = AffineTransform() * 2
        b = AffineTransform() * 3
        self.assertEqual((a * b).matrix, (6, 0, 0, 0, 6, 0, 0, 0, 6))

    def test_div_affine(self):
        a = AffineTransform() * 8
        b = AffineTransform() * 2
        self.assertEqual((a / b).matrix, (4, 0, 0, 0, 4, 0, 0, 0, 4))

    def test_mult_vector(self):
        a = AffineTransform() * 2
        self.assertEqual(a * (1, 2), (2, 4))
        self.assertEqual(a * (1, 2, 3), (2, 4, 6))

        self.assertRaises(ValueError, lambda: a * (1,))
        self.assertRaises(ValueError, lambda: a * (1, 2, 3, 4))
        self.assertRaises(ValueError, lambda: a * (1, 2, 3, 4))

        self.assertRaises(TypeError, lambda: (1, 2, 3) * a)

    # simple transformations
    def test_translate(self):
        a = AffineTransform()
        t = a.translate(3, 4)
        self.assertEqual(t.matrix, (1, 0, 0, 0, 1, 0, 3, 4, 1))
        self.assertEqual(t.translate(3, 4).matrix, (1, 0, 0, 0, 1, 0, 6, 8, 1))

    def test_rotate(self):
        a = AffineTransform()
        self.assertEqual(a.rotate(0), a)
        self.assertEqual(a.rotate(360), a)

        self.assertEqual(a.rotate(90), a.rotate(270, clockwise=True))

        self.assertEqual(a.rotate(90), AffineTransform((0, -1, 0, 1, 0, 0, 0, 0, 1)))

    # some chain multiplications
    def test_chained_translate_rotate(self):
        a = AffineTransform()
        # translate by (3, 4). rotate by 90 degrees
        t = a.translate(3, 4).rotate(90)
        self.assertEqual(t.matrix, (0, -1, 0, 1, 0, 0, 4, -3, 1))

    def test_chained_translate_rotate_translate(self):
        a = AffineTransform()
        # translate by (3, 4). rotate by 90 degrees. then translate back.
        t = a.translate(3, 4).rotate(90).translate(-3, -4)
        self.assertEqual(t.matrix, (0, -1, 0, 1, 0, 0, 1, -7, 1))

########NEW FILE########
__FILENAME__ = test_basic
# Copyright (c) 2012, Jonas Obrist
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#    * Neither the name of the Jonas Obrist nor the
#      names of its contributors may be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL JONAS OBRIST BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
from __future__ import absolute_import
from pymaging.colors import Color, RGBA
from pymaging.exceptions import FormatNotSupported
from pymaging.formats import register, Format
from pymaging.image import Image
from pymaging.shapes import Line, Pixel
from pymaging.test_utils import PymagingBaseTestCase, image_factory, pixel_array_factory
from pymaging.webcolors import Red, Green, Blue, Black, White, Lime
try: # pragma: no-cover
    # 2.x
    from StringIO import StringIO
except ImportError: # pragma: no-cover
    # 3.x
    from io import StringIO


class BasicTests(PymagingBaseTestCase):
    def _get_fake_image(self):
        return image_factory([
            [Red, Green, Blue],
            [Green, Blue, Red],
            [Blue, Red, Green],
        ])

    def test_open_invalid_image(self):
        self.assertRaises(FormatNotSupported, Image.open, StringIO(''))

    def test_crop(self):
        img = self._get_fake_image()
        img.crop(1, 1, 1, 1)

    def test_flip_left_right(self):
        img = self._get_fake_image()
        l2r = img.flip_left_right()
        self.assertImage(l2r, [
            [Blue, Green, Red],
            [Red, Blue, Green],
            [Green, Red, Blue],
        ])

    def test_flip_top_bottom(self):
        img = self._get_fake_image()
        t2b = img.flip_top_bottom()
        self.assertImage(t2b, [
            [Blue, Red, Green],
            [Green, Blue, Red],
            [Red, Green, Blue],
        ])

    def test_get_pixel(self):
        img = self._get_fake_image()
        color = img.get_color(0, 0)
        self.assertEqual(color, Red)

    def test_set_pixel(self):
        img = image_factory([
            [Black, Black],
            [Black, Black],
        ])
        img.set_color(0, 0, White)
        self.assertImage(img, [
            [White, Black],
            [Black, Black],
        ])

    def test_color_mix_with(self):
        base = Red
        color = Lime.get_for_brightness(0.5)
        result = base.cover_with(color)
        self.assertEqual(result, Color(128, 127, 0, 255))

    def test_color_mix_with_fastpath(self):
        base = Red
        color = Lime
        result = base.cover_with(color)
        self.assertEqual(result, Lime)

    def test_new(self):
        img = Image.new(RGBA, 5, 5, Black)
        self.assertImage(img, [
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            ])



class DrawTests(PymagingBaseTestCase):
    def test_draw_pixel(self):
        img = image_factory([
            [Black, Black],
            [Black, Black],
        ])
        pixel = Pixel(0, 0)
        img.draw(pixel, White)
        self.assertImage(img, [
            [White, Black],
            [Black, Black],
        ])

    def test_alpha_mixing(self):
        img = image_factory([[Red]])
        semi_transparent_green = Lime.get_for_brightness(0.5)
        img.draw(Pixel(0, 0), semi_transparent_green)
        result = img.get_color(0, 0)
        self.assertEqual(result, Color(128, 127, 0, 255))

    def test_draw_line_topleft_bottomright(self):
        img = image_factory([
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
        ])
        line = Line(0, 0, 4, 4)
        img.draw(line, White)
        self.assertImage(img, [
            [White, Black, Black, Black, Black],
            [Black, White, Black, Black, Black],
            [Black, Black, White, Black, Black],
            [Black, Black, Black, White, Black],
            [Black, Black, Black, Black, White],
        ])

    def test_draw_line_bottomright_topleft(self):
        img = image_factory([
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
        ])
        line = Line(4, 4, 0, 0)
        img.draw(line, White)
        self.assertImage(img, [
            [White, Black, Black, Black, Black],
            [Black, White, Black, Black, Black],
            [Black, Black, White, Black, Black],
            [Black, Black, Black, White, Black],
            [Black, Black, Black, Black, White],
        ])

    def test_draw_line_bottomleft_topright(self):
        img = image_factory([
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
        ])
        line = Line(0, 4, 4, 0)
        img.draw(line, White)
        self.assertImage(img, [
            [Black, Black, Black, Black, White],
            [Black, Black, Black, White, Black],
            [Black, Black, White, Black, Black],
            [Black, White, Black, Black, Black],
            [White, Black, Black, Black, Black],
        ])

    def test_draw_line_topright_bottomleft(self):
        img = image_factory([
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
        ])
        line = Line(4, 0, 0, 4)
        img.draw(line, White)
        self.assertImage(img, [
            [Black, Black, Black, Black, White],
            [Black, Black, Black, White, Black],
            [Black, Black, White, Black, Black],
            [Black, White, Black, Black, Black],
            [White, Black, Black, Black, Black],
        ])

    def test_draw_line_steep(self):
        img = image_factory([
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
        ])
        line = Line(0, 0, 1, 4)
        img.draw(line, White)
        self.assertImage(img, [
            [White, Black, Black, Black, Black],
            [White, Black, Black, Black, Black],
            [Black, White, Black, Black, Black],
            [Black, White, Black, Black, Black],
            [Black, White, Black, Black, Black],
        ])

    def test_blit_simple(self):
        main = image_factory([
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
        ])
        other =image_factory([
            [White, White, White],
            [White, White, White],
            [White, White, White],
        ])
        main.blit(1, 1, other)
        self.assertImage(main, [
            [Black, Black, Black, Black, Black],
            [Black, White, White, White, Black],
            [Black, White, White, White, Black],
            [Black, White, White, White, Black],
            [Black, Black, Black, Black, Black],
        ])

    def test_blit_partial(self):
        main = image_factory([
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
        ])
        other =image_factory([
            [White, White, White],
            [White, White, White],
            [White, White, White],
        ])
        main.blit(3, 3, other)
        self.assertImage(main, [
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, Black, Black],
            [Black, Black, Black, White, White],
            [Black, Black, Black, White, White],
        ])

    def test_delayed_loading(self):
        pixel_array = pixel_array_factory([
            [Black]
        ])
        class Loader(object):
            def __init__(self):
                self.callcount = 0

            def __call__(self):
                self.callcount += 1
                return pixel_array, None
        loader = Loader()
        image = Image(RGBA, 1, 1, loader)
        self.assertEqual(loader.callcount, 0)
        image.set_color(0, 0, White)
        self.assertEqual(loader.callcount, 1)
        image.flip_left_right()
        self.assertEqual(loader.callcount, 1)

    def test_format_registration(self):
        def loader():
            return pixel_array_factory([[Black]]), None
        def open_image(fobj):
            return Image(
                RGBA,
                1,
                1,
                loader,
            )
        def save_image(image, fobj):
            fobj.write('saved')
        register(Format(open_image, save_image, ['test']))
        img = Image.open(StringIO())
        self.assertIsInstance(img, Image)
        self.assertEqual(img.width, 1)
        self.assertEqual(img.height, 1)
        self.assertEqual(img.get_color(0, 0), Black)
        sio = StringIO()
        img.save(sio, 'test')
        self.assertEqual(sio.getvalue(), 'saved')


########NEW FILE########
__FILENAME__ = test_colors
import unittest

from pymaging.colors import Color

def ctuple(c):
    return c.red, c.green, c.blue, c.alpha

class TestColor(unittest.TestCase):
    ## constructors
    def test_constructor(self):
        c = Color(10, 20, 30)
        self.assertEqual(c.red, 10)
        self.assertEqual(c.alpha, 255)

    def test_from_pixel(self):
        c = Color.from_pixel([10, 20, 30])
        self.assertEqual(ctuple(c), (10, 20, 30, 255))

        c = Color.from_pixel([10, 20, 30, 40])
        self.assertEqual(ctuple(c), (10, 20, 30, 40))

    def test_from_hexcode(self):
        c = Color.from_hexcode('feef1510')
        self.assertEqual(ctuple(c), (254, 239, 21, 16))

        c = Color.from_hexcode('123')
        self.assertEqual(ctuple(c), (17, 34, 51, 255))

########NEW FILE########
__FILENAME__ = test_resampling
# Copyright (c) 2012, Jonas Obrist
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#    * Neither the name of the Jonas Obrist nor the
#      names of its contributors may be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL JONAS OBRIST BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
from pymaging.tests.test_basic import PymagingBaseTestCase, image_factory
from pymaging.colors import Color
from pymaging.webcolors import Red, Green, Blue
from pymaging.resample import bilinear


transparent = Color(0, 0, 0, 0)


class NearestResamplingTests(PymagingBaseTestCase):
    def test_resize_nearest_down(self):
        img = image_factory([
            [Red, Green, Blue],
            [Green, Blue, Red],
            [Blue, Red, Green],
        ])
        img = img.resize(2, 2)
        self.assertImage(img, [
            [Red, Blue],
            [Blue, Green],
        ])

    def test_resize_nearest_down_transparent(self):
        img = image_factory([
            [Red, Green, Blue],
            [Green, Blue, Red],
            [Blue, Red, transparent],
        ])
        img = img.resize(2, 2)
        self.assertImage(img, [
            [Red, Blue],
            [Blue, transparent],
        ])

    def test_resize_nearest_up(self):
        img = image_factory([
            [Red, Blue],
            [Blue, Green],
        ])
        img = img.resize(4, 4)
        self.assertImage(img, [
            [Red, Red, Blue, Blue],
            [Red, Red, Blue, Blue],
            [Blue, Blue, Green, Green],
            [Blue, Blue, Green, Green],
        ])

    def test_affine_rotate_nearest_90(self):
        img = image_factory([
            [Red, Blue],
            [Blue, Blue],
        ])
        img = img.rotate(90)
        self.assertImage(img, [
            [Blue, Blue],
            [Red, Blue],
        ])

    def test_transparent_background(self):
        img = image_factory([
            [Red, Red, Blue, Blue],
            [Red, Red, Blue, Blue],
            [Blue, Blue, Red, Red],
            [Blue, Blue, Red, Red],
        ])
        img = img.resize(2, 2, resize_canvas=False)
        self.assertImage(img, [
            [Red, Blue, transparent, transparent],
            [Blue, Red, transparent, transparent],
            [transparent, transparent, transparent, transparent],
            [transparent, transparent, transparent, transparent],
        ])


class ResizeBilinearResamplingTests(PymagingBaseTestCase):
    def test_resize_bilinear_down_simple(self):
        img = image_factory([
            [Red, Blue],
            [Blue, Green],
        ])
        img = img.resize(1, 1, resample_algorithm=bilinear)
        self.assertImage(img, [
            # all the colors blended equally
            [Color(64, 32, 128, 255)]
        ])

    def test_resize_bilinear_down_proportional(self):
        img = image_factory([
            [Red, Red, Blue],
            [Red, Red, Blue],
            [Blue, Blue, Blue],
        ])
        img = img.resize(2, 2, resample_algorithm=bilinear)
        self.assertImage(img, [
            [Red, Color(64, 0, 191, 255)],
            [Color(64, 0, 191, 255), Color(16, 0, 239, 255)],
        ])

    def test_resize_bilinear_down_simple_transparent(self):
        img = image_factory([
            [Red, Blue],
            [Blue, transparent],
        ])
        img = img.resize(1, 1, resample_algorithm=bilinear)

        #  - the alpha values get blended equally.
        #  - all non-alpha channels get multiplied by their alpha, so the
        #    transparent pixel does not contribute to the result.
        self.assertImage(img, [
            [Color(85, 0, 170, 191)]
        ])

    def test_resize_bilinear_down_simple_completely_transparent(self):
        img = image_factory([
            [transparent, transparent],
            [transparent, transparent],
        ])
        img = img.resize(1, 1, resample_algorithm=bilinear)

        # testing this because a naive implementation can cause div/0 error
        self.assertImage(img, [
            [Color(0, 0, 0, 0)]
        ])

    def test_resize_bilinear_down_proportional_transparent(self):
        img = image_factory([
            [Red, Red, transparent],
            [Red, Red, transparent],
            [transparent, transparent, transparent],
        ])
        img = img.resize(2, 2, resample_algorithm=bilinear)

        #  - the alpha values get blended equally.
        #  - all non-alpha channels get multiplied by their alpha, so the
        #    transparent pixel does not contribute to the result.
        self.assertImage(img, [
            [Red, Color(255, 0, 0, 64)],
            [Color(255, 0, 0, 64), Color(255, 0, 0, 16)],
        ])

    def test_resize_bilinear_no_change(self):
        img = image_factory([
            [Red, Blue],
            [Blue, Green],
        ])
        img = img.resize(2, 2, resample_algorithm=bilinear)
        self.assertImage(img, [
            [Red, Blue],
            [Blue, Green],
        ])

    def test_resize_bilinear_up_simple(self):
        img = image_factory([
            [Red, Blue],
            [Blue, Green],
        ])
        img = img.resize(4, 4, resample_algorithm=bilinear)
        self.assertImage(img, [
            [Red, Red, Blue, Blue],
            [Red, Red, Blue, Blue],
            [Blue, Blue, Green, Green],
            [Blue, Blue, Green, Green],
        ])

    def test_resize_bilinear_up_proportional(self):
        img = image_factory([
            [Red, Blue],
            [Blue, Green],
        ])
        img = img.resize(3, 3, resample_algorithm=bilinear)
        self.assertImage(img, [
            [Color(177, 4, 71, 255), Color(106, 11, 128, 255), Color(0, 21, 212, 255)],
            [Color(106, 11, 128, 255), Color(64, 32, 128, 255), Color(0, 64, 128, 255)],
            [Color(0, 21, 212, 255), Color(0, 64, 128, 255), Color(0, 128, 0, 255)],
        ])

    def test_affine_rotate_bilinear_90(self):
        img = image_factory([
            [Red, Blue],
            [Blue, Blue],
        ])
        img = img.rotate(90, resample_algorithm=bilinear)
        self.assertImage(img, [
            [Blue, Blue],
            [Red, Blue],
        ])

########NEW FILE########
__FILENAME__ = test_utils
# -*- coding: utf-8 -*-
import unittest
import array
from pymaging.colors import ColorType
from pymaging.image import Image
from pymaging.pixelarray import get_pixel_array

def pixel_array_factory(colors, alpha=True):
    height = len(colors)
    width = len(colors[0]) if height else 0
    pixel_size = 4 if alpha else 3
    pixel_array = get_pixel_array(array.array('B', [0] * width * height * pixel_size), width, height, pixel_size)
    for y in range(height):
        for x in range(width):
            pixel_array.set(x, y, colors[y][x].to_pixel(pixel_size))
    return pixel_array

def image_factory(colors, alpha=True):
    height = len(colors)
    width = len(colors[0]) if height else 0
    pixel_size = 4 if alpha else 3
    pixel_array = pixel_array_factory(colors, alpha)
    def loader():
        return pixel_array, None
    return Image(ColorType(pixel_size, alpha), width, height, loader)


if hasattr(unittest.TestCase, 'assertIsInstance'):
    class _Compat: pass
else:
    class _Compat:
        def assertIsInstance(self, obj, cls, msg=None):
            if not isinstance(obj, cls):
                standardMsg = '%s is not an instance of %r' % (safe_repr(obj), cls)
                self.fail(self._formatMessage(msg, standardMsg))


class PymagingBaseTestCase(unittest.TestCase, _Compat):
    def assertImage(self, img, colors, alpha=True):
        check = image_factory(colors, alpha)
        self.assertEqual(img.pixels, check.pixels)


########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
# Copyright (c) 2012, Jonas Obrist
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#    * Neither the name of the Jonas Obrist nor the
#      names of its contributors may be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL JONAS OBRIST BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
import os

def fdiv(a, b):
    return float(a) / float(b)


def get_test_file(testfile, fname):
    return os.path.join(os.path.dirname(testfile), 'testdata', fname)
get_test_file.__test__ = False # nose...

########NEW FILE########
__FILENAME__ = webcolors
# -*- coding: utf-8 -*-
# Copyright (c) 2012, Jonas Obrist
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#    * Neither the name of the Jonas Obrist nor the
#      names of its contributors may be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL JONAS OBRIST BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
from pymaging.colors import Color


# List of web color names taken from http://en.wikipedia.org/wiki/Web_colors 

IndianRed = Color(205, 92, 92, 255)
LightCoral = Color(240, 128, 128, 255)
Salmon = Color(250, 128, 114, 255)
DarkSalmon = Color(233, 150, 122, 255)
LightSalmon = Color(255, 160, 122, 255)
Red = Color(255, 0, 0, 255)
Crimson = Color(220, 20, 60, 255)
FireBrick = Color(178, 34, 34, 255)
DarkRed = Color(139, 0, 0, 255)
Pink = Color(255, 192, 203, 255)
LightPink = Color(255, 182, 193, 255)
HotPink = Color(255, 105, 180, 255)
DeepPink = Color(255, 20, 147, 255)
MediumVioletRed = Color(199, 21, 133, 255)
PaleVioletRed = Color(219, 112, 147, 255)
LightSalmon = Color(255, 160, 122, 255)
Coral = Color(255, 127, 80, 255)
Tomato = Color(255, 99, 71, 255)
OrangeRed = Color(255, 69, 0, 255)
DarkOrange = Color(255, 140, 0, 255)
Orange = Color(255, 165, 0, 255)
Gold = Color(255, 215, 0, 255)
Yellow = Color(255, 255, 0, 255)
LightYellow = Color(255, 255, 224, 255)
LemonChiffon = Color(255, 250, 205, 255)
LightGoldenrodYellow = Color(250, 250, 210, 255)
PapayaWhip = Color(255, 239, 213, 255)
Moccasin = Color(255, 228, 181, 255)
PeachPuff = Color(255, 218, 185, 255)
PaleGoldenrod = Color(238, 232, 170, 255)
Khaki = Color(240, 230, 140, 255)
DarkKhaki = Color(189, 183, 107, 255)
Lavender = Color(230, 230, 250, 255)
Thistle = Color(216, 191, 216, 255)
Plum = Color(221, 160, 221, 255)
Violet = Color(238, 130, 238, 255)
Orchid = Color(218, 112, 214, 255)
Fuchsia = Color(255, 0, 255, 255)
Magenta = Color(255, 0, 255, 255)
MediumOrchid = Color(186, 85, 211, 255)
MediumPurple = Color(147, 112, 219, 255)
BlueViolet = Color(138, 43, 226, 255)
DarkViolet = Color(148, 0, 211, 255)
DarkOrchid = Color(153, 50, 204, 255)
DarkMagenta = Color(139, 0, 139, 255)
Purple = Color(128, 0, 128, 255)
Indigo = Color(75, 0, 130, 255)
DarkSlateBlue = Color(72, 61, 139, 255)
SlateBlue = Color(106, 90, 205, 255)
MediumSlateBlue = Color(123, 104, 238, 255)
GreenYellow = Color(173, 255, 47, 255)
Chartreuse = Color(127, 255, 0, 255)
LawnGreen = Color(124, 252, 0, 255)
Lime = Color(0, 255, 0, 255)
LimeGreen = Color(50, 205, 50, 255)
PaleGreen = Color(152, 251, 152, 255)
LightGreen = Color(144, 238, 144, 255)
MediumSpringGreen = Color(0, 250, 154, 255)
SpringGreen = Color(0, 255, 127, 255)
MediumSeaGreen = Color(60, 179, 113, 255)
SeaGreen = Color(46, 139, 87, 255)
ForestGreen = Color(34, 139, 34, 255)
Green = Color(0, 128, 0, 255)
DarkGreen = Color(0, 100, 0, 255)
YellowGreen = Color(154, 205, 50, 255)
OliveDrab = Color(107, 142, 35, 255)
Olive = Color(128, 128, 0, 255)
DarkOliveGreen = Color(85, 107, 47, 255)
MediumAquamarine = Color(102, 205, 170, 255)
DarkSeaGreen = Color(143, 188, 143, 255)
LightSeaGreen = Color(32, 178, 170, 255)
DarkCyan = Color(0, 139, 139, 255)
Teal = Color(0, 128, 128, 255)
Aqua = Color(0, 255, 255, 255)
Cyan = Color(0, 255, 255, 255)
LightCyan = Color(224, 255, 255, 255)
PaleTurquoise = Color(175, 238, 238, 255)
Aquamarine = Color(127, 255, 212, 255)
Turquoise = Color(64, 224, 208, 255)
MediumTurquoise = Color(72, 209, 204, 255)
DarkTurquoise = Color(0, 206, 209, 255)
CadetBlue = Color(95, 158, 160, 255)
SteelBlue = Color(70, 130, 180, 255)
LightSteelBlue = Color(176, 196, 222, 255)
PowderBlue = Color(176, 224, 230, 255)
LightBlue = Color(173, 216, 230, 255)
SkyBlue = Color(135, 206, 235, 255)
LightSkyBlue = Color(135, 206, 250, 255)
DeepSkyBlue = Color(0, 191, 255, 255)
DodgerBlue = Color(30, 144, 255, 255)
CornflowerBlue = Color(100, 149, 237, 255)
RoyalBlue = Color(65, 105, 225, 255)
Blue = Color(0, 0, 255, 255)
MediumBlue = Color(0, 0, 205, 255)
DarkBlue = Color(0, 0, 139, 255)
Navy = Color(0, 0, 128, 255)
MidnightBlue = Color(25, 25, 112, 255)
Cornsilk = Color(255, 248, 220, 255)
BlanchedAlmond = Color(255, 235, 205, 255)
Bisque = Color(255, 228, 196, 255)
NavajoWhite = Color(255, 222, 173, 255)
Wheat = Color(245, 222, 179, 255)
BurlyWood = Color(222, 184, 135, 255)
Tan = Color(210, 180, 140, 255)
RosyBrown = Color(188, 143, 143, 255)
SandyBrown = Color(244, 164, 96, 255)
Goldenrod = Color(218, 165, 32, 255)
DarkGoldenrod = Color(184, 134, 11, 255)
Peru = Color(205, 133, 63, 255)
Chocolate = Color(210, 105, 30, 255)
SaddleBrown = Color(139, 69, 19, 255)
Sienna = Color(160, 82, 45, 255)
Brown = Color(165, 42, 42, 255)
Maroon = Color(128, 0, 0, 255)
White = Color(255, 255, 255, 255)
Snow = Color(255, 250, 250, 255)
Honeydew = Color(240, 255, 240, 255)
MintCream = Color(245, 255, 250, 255)
Azure = Color(240, 255, 255, 255)
AliceBlue = Color(240, 248, 255, 255)
GhostWhite = Color(248, 248, 255, 255)
WhiteSmoke = Color(245, 245, 245, 255)
Seashell = Color(255, 245, 238, 255)
Beige = Color(245, 245, 220, 255)
OldLace = Color(253, 245, 230, 255)
FloralWhite = Color(255, 250, 240, 255)
Ivory = Color(255, 255, 240, 255)
AntiqueWhite = Color(250, 235, 215, 255)
Linen = Color(250, 240, 230, 255)
LavenderBlush = Color(255, 240, 245, 255)
MistyRose = Color(255, 228, 225, 255)
Gainsboro = Color(220, 220, 220, 255)
LightGrey = Color(211, 211, 211, 255)
Silver = Color(192, 192, 192, 255)
DarkGray = Color(169, 169, 169, 255)
Gray = Color(128, 128, 128, 255)
DimGray = Color(105, 105, 105, 255)
LightSlateGray = Color(119, 136, 153, 255)
SlateGray = Color(112, 128, 144, 255)
DarkSlateGray = Color(47, 79, 79, 255)
Black = Color(0, 0, 0, 255)
    
########NEW FILE########
