__FILENAME__ = architecture
#!/usr/bin/env python
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

#!/usr/bin/env python
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from academicmarkdown import build
import sys
import os
import imp
import re
import subprocess
import inspect

tmpl_doc = u"""
%(openexp)s

%(libopensesame)s

%(libqtopensesame)s

"""

obj_doc = u"%(header)s - [%(name)s](%(src)s)\n"

def ingit(path):
	
	"""
	Checks whether a given path is part of the Git repository.
	
	Returns:
	True if the file is in Git, False otherwise.
	"""
	
	cmd = u'git ls-files %s --error-unmatch' % path
	try:
		subprocess.check_call(cmd.split())
	except:
		return False
	return True

def objcontains(obj):
	
	"""
	Generates a description of an objects contents, i.e. functions and classes.
	
	Arguments:
	obj		--	An object.
	
	Returns:
	A documentation string.
	"""
	
	l = []
	for i in dir(obj):
		o = getattr(obj, i)
		if inspect.isclass(o):
			l.append(u'class: `%s`' % i)
		elif inspect.isfunction(o):
			l.append(u'function: `%s()`' % i)
	if len(l) == 0:
		return u''
	return u'Provides (may include functions and classes imported from other modules):\n\n- ' + u'\n- '.join(sorted(l)) + '\n'

def docstr(obj):
	
	"""
	Retrieves the docstring for an object.
	
	Arguments:
	obj		--	An object.
	
	Returns:
	A docstring.
	"""

	doc = u''
	if obj.__doc__ == None:
		return u'Auto-generated object.'
	for r in re.finditer(u'<DOC>(.*?)</DOC>', obj.__doc__, re.M|re.S):
		doc += r.groups()[0]
	if len(doc) == 0:
		doc = u'No docstring specified.'
	return doc

def docmod(path, lvl=0):
	
	"""
	Documents a module.
	
	Arguments:
	path 	--	The path to the module.
	
	Keyword arguments:
	lvl		--	The depth in the hierarchy. (default=2)
	
	Returns:
	A full documentation string.
	"""
	
	name = os.path.basename(path)[:-3]
	full_name = path[:-3].replace(u'/', '.')	
	header = u'\t' * lvl
	src = u'https://github.com/smathot/OpenSesame/blob/master/%s' % path
	sys.path.append(os.path.abspath(os.path.dirname(path)))
	try:
		mod = imp.load_source(name, path)
		doc = docstr(mod)
		contains = objcontains(mod)
	except:
		doc = u'Failed to import module.'
		contains = u''
	sys.path.pop()
	md = obj_doc % {u'header' : header, u'name' : name, u'full_name' : \
		full_name, u'doc' : doc, u'src': src, u'type' : u'module', \
		u'contains' : contains}
	return md

def docpkg(folder, lvl=0):
	
	"""
	Documents a package.
	
	Arguments:
	path 	--	The path to the package.
	
	Keyword arguments:
	lvl		--	The depth in the hierarchy. (default=2)
	
	Returns:
	A full documentation string.
	"""	
	
	md = u''
	
	path = os.path.join(folder, u'__init__.py')
	name = os.path.basename(folder)
	full_name = folder.replace(u'/', '.')
	header = u'\t' * lvl
	src = u'https://github.com/smathot/OpenSesame/blob/master/%s' % path
	if not os.path.exists(path) or not ingit(path):
		return md
	sys.path.append(os.path.abspath(folder))
	pkg = imp.load_source(u'dummy', path)
	sys.path.pop()
	doc = docstr(pkg)
	contains = objcontains(pkg)
	md += obj_doc % {u'header' : header, u'name' : name, u'full_name' : \
		full_name, u'doc' : doc, u'src': src, u'type' : u'package', \
		u'contains' : contains}
	# Document modules
	for fname in sorted(os.listdir(folder)):
		path = os.path.join(folder, fname)
		if path.endswith(u'.py') and fname != u'__init__.py' and ingit(path):
			md += docmod(path, lvl+1)
	# Document packages
	for fname in sorted(os.listdir(folder)):
		path = os.path.join(folder, fname)
		if os.path.isdir(path):
			md += docpkg(path, lvl+1)
	return md
		
md = tmpl_doc % {
	u'openexp' : docpkg(u'openexp'),
	u'libopensesame' : docpkg(u'libopensesame'),
	u'libqtopensesame' : docpkg(u'libqtopensesame'),
	}

html = build.HTML(md, standalone=False)
open(u'../osdoc/content/_includes/architecture', u'w').write(html)
########NEW FILE########
__FILENAME__ = check_ts
#!/usr/bin/env python
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
import xml.etree.ElementTree as ET

for ts in os.listdir('resources/ts'):
	if not ts.endswith('.ts'):
		continue
	print
	print 'Checking %s' % ts
	print
	tree = ET.parse('resources/ts/%s' % ts)
	root = tree.getroot()
	for context in root:
		for msg in context:
			if len(msg) == 0:
				continue
			src = msg[1].text
			tra = msg[2].text
			if tra == None:
				continue
			if src.count('%s') != tra.count('%s') or src.count('%d') != \
				tra.count('%d') or src.count('%f') != tra.count('%f'):
				print '*** Wildcard mismatch!'
				print '\t', src
				print '\t', tra



########NEW FILE########
__FILENAME__ = code_check
#!/usr/bin/env python
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import re
import os

# A regular expression that (purportedly) detects all Python strings in the code
# From:
# http://code.activestate.com/recipes/475109-regular-expression-for-python-string-literals/
regex_str = (r"""
[uU]?[rR]?
  (?:              # Single-quote (') strings
  '''(?:                 # Tripple-quoted can contain...
      [^']               | # a non-quote
      \\'                | # a backslashed quote
      '{1,2}(?!')          # one or two quotes
    )*''' |
  '(?:                   # Non-tripple quoted can contain...
     [^']                | # a non-quote
     \\'                   # a backslashded quote
   )*'(?!') | """+
r'''               # Double-quote (") strings
  """(?:                 # Tripple-quoted can contain...
      [^"]               | # a non-quote
      \\"                | # a backslashed single
      "{1,2}(?!")          # one or two quotes
    )*""" |
  "(?:                   # Non-tripple quoted can contain...
     [^"]                | # a non-quote
     \\"                   # a backslashded quote
   )*"(?!")
)''')

# A regular expression that detects all translatables in the code
regex_trans = re.compile(r'_\(%s\)' % regex_str, re.VERBOSE)

translatables = []
n_files = 0

def detect_translatables(path):

	"""
	Scans a Python script for translatables and adds these to the list of
	translatables

	Arguments:
	path -- the path to Python script
	"""

	global translatables
	s = open(path).read()
	for i in regex_trans.findall(s):
		translatables.append(i[2:-1])

def encode_translatables(path='dev-scripts/translatables.py'):

	"""
	Writes all translatables to a Python script, which can be interpreted by
	pylupdate4

	Arguments:
	path -- the path to the Python script that is generated
	"""

	global translatables
	f = open(path, 'w')
	f.write('class script:\n\tdef _():\n')
	for t in translatables:
		f.write('\t\tself.tr(%s)\n' % t)
	f.close()
	print('%d translatables written to %s' % (len(translatables), path))

def validate(path):

	"""
	Checks whether a Python script is valid, i.e. starts with a proper Encoding
	message etc.

	Arguments:
	path -- the path to Python script
	"""
	s = open(path).readline().strip()
	if s not in ('#-*- coding:utf-8 -*-', '# -*- coding: utf-8 -*-'):
		print('no-utf8: %s' % path)

def parse_file(path, translate=True):

	"""
	Processes a single file

	Arguments:
	path -- the path to Python script

	Keyword arguments:
	translate -- indicates whether the script should be checked for
				 translatables (default=True)
	"""

	global n_files
	n_files += 1
	validate(path)
	if translate:
		detect_translatables(path)

def parse_folder(path, translate=True):

	"""
	Processes a single folder

	Arguments:
	path -- the path to the folder

	Keyword arguments:
	translate -- indicates whether the folder should be checked for
				 translatables (default=True)
	"""

	for f in os.listdir(path):
		_path = os.path.join(path, f)
		if os.path.isdir(_path):
			parse_folder(_path, translate)
		elif f in ['qtopensesame'] or os.path.splitext(_path)[1] == '.py':
			parse_file(_path, translate)

parse_folder('libqtopensesame')
parse_folder('libopensesame', translate=False)
parse_folder('openexp', translate=False)
encode_translatables()
print('Parsed %d files' % n_files)

########NEW FILE########
__FILENAME__ = docstruct
#!/usr/bin/env python
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from academicmarkdown import build
import sys
import os
import imp
import re
import subprocess
import inspect

tmpl_doc = u"""

## Overview

%%--
toc:
 mindepth: 2
 maxdepth: 10
 exclude: [Overview]
--%%

%(openexp)s

%(libopensesame)s

%(libqtopensesame)s

"""

obj_doc = u"""
%(header)s %(name)s

%(doc)s

%(contains)s

More info:

- Type: %(type)s
- Full name: `%(full_name)s`
- Source: <%(src)s>

"""

def ingit(path):
	
	"""
	Checks whether a given path is part of the Git repository.
	
	Returns:
	True if the file is in Git, False otherwise.
	"""
	
	cmd = u'git ls-files %s --error-unmatch' % path
	try:
		subprocess.check_call(cmd.split())
	except:
		return False
	return True

def objcontains(obj):
	
	"""
	Generates a description of an objects contents, i.e. functions and classes.
	
	Arguments:
	obj		--	An object.
	
	Returns:
	A documentation string.
	"""
	
	l = []
	for i in dir(obj):
		o = getattr(obj, i)
		if inspect.isclass(o):
			l.append(u'class: `%s`' % i)
		elif inspect.isfunction(o):
			l.append(u'function: `%s()`' % i)
	if len(l) == 0:
		return u''
	return u'Provides (may include functions and classes imported from other modules):\n\n- ' + u'\n- '.join(sorted(l)) + '\n'

def docstr(obj):
	
	"""
	Retrieves the docstring for an object.
	
	Arguments:
	obj		--	An object.
	
	Returns:
	A docstring.
	"""

	doc = u''
	if obj.__doc__ == None:
		return u'Auto-generated object.'
	for r in re.finditer(u'<DOC>(.*?)</DOC>', obj.__doc__, re.M|re.S):
		doc += r.groups()[0]
	if len(doc) == 0:
		doc = u'No docstring specified.'
	return doc

def docmod(path, lvl=2):
	
	"""
	Documents a module.
	
	Arguments:
	path 	--	The path to the module.
	
	Keyword arguments:
	lvl		--	The depth in the hierarchy. (default=2)
	
	Returns:
	A full documentation string.
	"""
	
	name = os.path.basename(path)[:-3]
	full_name = path[:-3].replace(u'/', '.')	
	header = u'#' * lvl
	src = u'https://github.com/smathot/OpenSesame/blob/master/%s' % path
	sys.path.append(os.path.abspath(os.path.dirname(path)))
	try:
		mod = imp.load_source(name, path)
		doc = docstr(mod)
		contains = objcontains(mod)
	except:
		doc = u'Failed to import module.'
		contains = u''
	sys.path.pop()
	md = obj_doc % {u'header' : header, u'name' : name, u'full_name' : \
		full_name, u'doc' : doc, u'src': src, u'type' : u'module', \
		u'contains' : contains}
	return md

def docpkg(folder, lvl=2):
	
	"""
	Documents a package.
	
	Arguments:
	path 	--	The path to the package.
	
	Keyword arguments:
	lvl		--	The depth in the hierarchy. (default=2)
	
	Returns:
	A full documentation string.
	"""	
	
	md = u''
	
	path = os.path.join(folder, u'__init__.py')
	name = os.path.basename(folder)
	full_name = folder.replace(u'/', '.')
	header = u'#' * lvl
	src = u'https://github.com/smathot/OpenSesame/blob/master/%s' % path
	if not os.path.exists(path) or not ingit(path):
		return md
	sys.path.append(os.path.abspath(folder))
	pkg = imp.load_source(u'dummy', path)
	sys.path.pop()
	doc = docstr(pkg)
	contains = objcontains(pkg)
	md += obj_doc % {u'header' : header, u'name' : name, u'full_name' : \
		full_name, u'doc' : doc, u'src': src, u'type' : u'package', \
		u'contains' : contains}
	# Document modules
	for fname in sorted(os.listdir(folder)):
		path = os.path.join(folder, fname)
		if path.endswith(u'.py') and fname != u'__init__.py' and ingit(path):
			md += docmod(path, lvl+1)
	# Document packages
	for fname in sorted(os.listdir(folder)):
		path = os.path.join(folder, fname)
		if os.path.isdir(path):
			md += docpkg(path, lvl+1)
	return md
		
md = tmpl_doc % {
	u'openexp' : docpkg(u'openexp'),
	u'libopensesame' : docpkg(u'libopensesame'),
	u'libqtopensesame' : docpkg(u'libqtopensesame'),
	}
	
build.HTML(md, '../osdoc/content/_includes/source-code-structure', standalone= \
	False)
build.PDF(md, 'docstruct.pdf')
build.MD(md, 'docstruct.md')
########NEW FILE########
__FILENAME__ = item-help
#!/usr/bin/env python
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
from academicmarkdown import build
from libopensesame import misc

md = u"""

<div class='page-notification'>This page is generated automatically from item-specific help pages. These pages can be viewed in OpenSesame by clicking on the help icon in the top-right of the tab area.</div>

## Overview

%%--
toc:
 mindepth: 2
 exclude: [Overview]
--%%

## Commonly used items

%s

## Plug-ins

%s

"""

plugin_msg = u"\n<div class='page-notification'>This is a plug-in and may not be installed by default. For plug-in installation instructions, see <a href='/plug-ins/installation'>here</a>.</div>\n"

exclude_list = [u'general.md', u'variables.md', u'stdout.md', u'missing.md',
	u'auto_example.md', u'remote_logger.md', u'pool.md', u'video_player.md']

def collect(folder):

	"""
	Recursively collects a list of Markdown help files from a specified folder.

	Arguments:
	folder		--	The source folder.

	Returns:
	A list of path names of help files.
	"""

	src = []
	for fname in os.listdir(folder):
		path = os.path.join(folder, fname)
		if os.path.isdir(path):
			print('Entering %s' % path)
			src += collect(path)
			continue
		if fname in exclude_list or not fname.endswith(u'.md'):
			continue
		print('Adding %s' % path)
		src.append(path)
	return sorted(src)

def helpify(folder, msg=u''):

	"""
	Recursively builds a help page from Markdown help files in a source folder.

	Arguments:
	folder		--	The source folder.

	Keyword arguments:
	msg			--	An informative message to include after each help file.

	Returns:
	A help page.
	"""

	src = collect(folder)
	md = u''
	for path in src:
		_md = u'\n' + msg + open(path).read().decode(u'utf-8') + u'\n<hr />\n'
		_md = _md.replace(u'\n#', u'\n###')
		md += _md
	return md

md = md % (helpify(u'help'), helpify(u'plugins', plugin_msg))
html = build.HTML(md, standalone=False)
open('../osdoc/content/_includes/item-help', 'w').write(html.encode('utf-8'))

########NEW FILE########
__FILENAME__ = update-hidden
#!/usr/bin/env python
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
hiddenExts = '.pyc', '.pyo'
def updateHidden(folder):

	"""
	Scans a folder and adds all files of a particular type to the .hidden file,
	to avoid a cluttered view in Nautilus

	Arguments:
	folder -- the folder to process
	"""

	print('Scanning', folder)
	f = open(os.path.join(folder, '.hidden'), 'w')
	for fname in os.listdir(folder):
		if fname[0] == '.':
			continue
		path = os.path.join(folder, fname)
		if os.path.isdir(path):
			updateHidden(path)
		elif os.path.splitext(fname)[1] in hiddenExts:
			print('Hiding', fname)
			f.write(fname+'\n')
	f.close()

updateHidden('.')

########NEW FILE########
__FILENAME__ = debug
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.

# About

Provides printing of debug output, which is only shown when OpenSesame is
started in debug mode by passing the `--debug` command-line argument, optionally
with a full stacktrace if the `--stack` argument is passed as well. To print
debug output, simply use the following structure:

	from libopensesame import debug
	debug.print(u'This is a debug message')
"""

import sys
import os.path

def parse_stack(st):

	"""
	Generates a nice looking stacktrace for a single item.

	Returns:
	A string of the stacktrace item
	"""

	return u'%s(%d).%s' % (os.path.basename(st[1]), st[2], st[3])

def format_stack(st, skip=0):

	"""
	Generates a nice looking full stracktrace.

	Returns:
	A string corresponding to the stacktrace.
	"""

	st = st[skip:]
	st.reverse()
	i = 1
	s = u''
	while len(st) > 0:
		s += u' %.3d\t%s\n' % (i, parse_stack(st.pop()))
		i += 1
	return s

def msg(msg=u'', reason=None):

	"""
	Prints a debugging message. Respects the --debug and --stack parameters.

	Keyword arguments:
	msg 	--	A debug message. (default=u'')
	reason	--	A specific reason for the message. (default=None)
	"""

	global stack, max_stack
	st = inspect.stack()
	if reason != None:
		print(u'[%s]' % reason)
	# The terminal may not like anythin but plain ASCII
	if isinstance(msg, str):
		msg = msg.decode(u'utf-8', u'ignore')
	try:
		print(u'%s: %s' % (parse_stack(st[1]), msg))
	except:
		# This should not happen!
		print(u'%s: Failed to print message to debug window' % \
			parse_stack(st[1]))
	if stack:
		print(format_stack(st, skip=2))

enabled = '--debug' in sys.argv or '-d' in sys.argv
if enabled:
	import inspect
	stack = '--stack' in sys.argv or '-s' in sys.argv
	if stack:
		msg(u'debug mode enabled (stacktrace on)')
	else:
		msg(u'debug mode enabled (stacktrace off)')
else:
	# Replace the message function with a dummy function to turn off debugging
	# output
	stack = False
	msg = lambda msg=None, reason=None: None

########NEW FILE########
__FILENAME__ = exceptions
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.

# About

Provides the `osexception` class for throwing OpenSesame-specific exceptions.

	from libopensesame.exceptions import osexception
	raise osexception(u'This is a custom exception!')
"""

import re
from libopensesame.misc import escape_html
from libopensesame import debug
import traceback
import inspect
import sys

class osexception(Exception):
	
	"""
	A general Exception class for exceptions that occur within OpenSesame.
	Ideally, only `osexception`s should occur, all other exceptions indicate
	a (usually harmless) bug somewhere.
	"""

	def __init__(self, msg, exception=None, **info):
		
		"""
		Constructor.
		
		Arguments:
		msg		--	An Exception message.
		
		Keyword arguments:
		exception	--	An exception that was intercepted or None for
						self-generated exceptions. (default=None)
		**info		--	A dictionary with optional additional info for the
						exception.
		"""
		
		super(osexception, self).__init__(msg)
		# Create both HTML and plain text representations of the Exception.
		self._html = u'<b>%s</b><br />\n' % msg
		self._plaintext = u'\n%s\n\n' % msg
		self.enc = u'utf-8'
		# If an Exception is passed, i.e. if we are catching an Exception,
		# summarize this exception here.
		self.exception = exception
		if self.exception != None:
			info[u'exception type'] = self.exception.__class__.__name__ \
				.decode(self.enc, u'ignore')
			info[u'exception message'] = self.exception.message.decode( \
				self.enc, u'ignore')
			try:
				# This is a hacky way to extract the line number from the
				# stacktrace. Since it's not clear whether this is fullproof,
				# we try-except it for now.
				info[u'line'] = traceback.extract_tb(sys.exc_info()[2])[-1][1]
				# Inline script items automatically add the source encoding as
				# the first line. Therefore, the reported line is always one
				# after the actual line, and we need to substract 1.
				if u'item' in info and info[u'item'] == u'inline_script':
					info[u'line'] -= 1
			except:
				pass
		# List any additional information that was passed
		for key, val in info.items():
			self._html += u'<i>%s</i>: %s<br />\n' % (key, val)
			self._plaintext += u'%s: %s\n' % (key, val)
		# If an Exception is passed, we should include a traceback.
		if self.exception == None:
			return
		tb = traceback.format_exc(self.exception).decode(self.enc, u'ignore')
		self._html += u'<br /><b>Traceback (also in debug window)</b>:<br />\n'
		self._plaintext += u'\nTraceback:\n'
		for l in tb.split(u'\n')[1:]:
			# It is confusing that the contents of the inline script are
			# described as <string>, so replace that. In addition, we need to
			# decrease the line numer by 1, to compensate for the extra (hidden)
			# source-encoding line that the inline script has.
			if u'item' in info and info[u'item'] == u'inline_script':
				for g in re.finditer( \
					u'File "<string>", line (?P<linenr>\d+),', l):
					try:
						l = l.replace(g.group(), u'Inline_script, line %d,' % \
							(int(g.group(u'linenr'))-1))
					except:
						debug.msg(u'Failed to correct inline_script exception')
			self._html += escape_html(l) + u'<br />\n'
			self._plaintext += l + u'\n'
			
	def __unicode__(self):
		
		"""
		Returns:
		A unicode representation of the exception in plaintext.
		"""
		
		return self._plaintext

	def __str__(self):
		
		"""
		Returns:
		A string representation of the exception in plaintext.
		"""

		return self._plaintext.encode(u'utf-8')
	
	def plaintext(self):
		
		"""
		Returns:
		A string representation of the exception in plaintext.
		"""
		
		return unicode(self)
	
	def html(self):
		
		"""
		Returns:
		A unicode representation of the exception in HTML format.
		"""
		
		return self._html

# For backwards compatibility, we should also define the old Exception classes
runtime_error = osexception
script_error = osexception
form_error = osexception

########NEW FILE########
__FILENAME__ = experiment
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import misc, item, plugins, debug
import os.path
import shutil
import sys
import time
import tarfile
import tempfile
import codecs

# Contains a list of all pool folders, which need to be removed on program exit
pool_folders = []

class experiment(item.item):

	"""The main experiment class, which is the first item to be called"""

	def __init__(self, name=u'experiment', string=None, pool_folder=None, experiment_path=None, fullscreen=False, auto_response=False, logfile=u'defaultlog.csv', subject_nr=0):

		"""<DOC>
		Constructor. The experiment is created automatically be OpenSesame and #
		you will generally not need to create it yourself.

		Keyword arguments:
		name 			--	The name of the experiment. (default=u'experiment')
		string 			--	A string containing the experiment definition. #
							(default=None)
		pool_folder		--	A specific folder to be used for the file pool. #
							(default=None)
		experiment_path	--	The path of the experiment file. (default=None)
		fullscreen		--	Indicates whether the experiment should be #
							executed in fullscreen. (default=False)
		auto_response	--	Indicates whether auto-response mode should be #
							enabled. (default=False)
		logfile			--	The logfile path. (default=u'defaultlog.csv')
		subject_nr		--	The subject number. (default=0)
		</DOC>"""

		global pool_folders

		self.items = {}
		self.running = False
		self.auto_response = auto_response
		self.plugin_folder = u'plugins'
		self.start_response_interval = None
		self.cleanup_functions = []
		self.restart = False
		self.title = u'My Experiment'
		self.transparent_variables = u'no'
		self.bidi = u'no'

		# Set default variables
		self.start = u'experiment'

		# Sound parameters
		self.sound_freq = 48000
		self.sound_sample_size = -16 # Negative values mean signed
		self.sound_channels = 2
		self.sound_buf_size = 512
		self.resources = {}

		# Backend parameters
		self.canvas_backend = u'xpyriment'
		self.keyboard_backend = u'legacy'
		self.mouse_backend = u'xpyriment'
		self.sampler_backend = u'legacy'
		self.synth_backend = u'legacy'

		# Save the date and time, and the version of OpenSesame
		self.datetime = time.strftime(u'%c').decode(self.encoding, u'ignore')
		self.opensesame_version = misc.version
		self.opensesame_codename = misc.codename

		# Display parameters
		self.width = 1024
		self.height = 768
		self.background = u'black'
		self.foreground = u'white'
		self.fullscreen = fullscreen

		# Font parameters
		self.font_size = 18
		self.font_family = u'mono'
		self.font_italic = u'no'
		self.font_bold = u'no'
		self.font_underline = u'no'

		# Logfile parameters
		self._log = None
		self.logfile = logfile

		# This is some duplication of the option parser in qtopensesame,
		# but nevertheless keep it so we don't need qtopensesame
		self.debug = debug.enabled
		self._stack = debug.stack

		# Pool folder
		if pool_folder == None:
			# On some systems tempfile.mkdtemp() triggers a UnicodeDecodeError.
			# This is resolved by passing the dir explicitly as a Unicode
			# string. This fix has been adapted from:
			# - <http://bugs.python.org/issue1681974>
			self.pool_folder = tempfile.mkdtemp(suffix= \
				u'.opensesame_pool', dir=tempfile.gettempdir().decode( \
				encoding=misc.filesystem_encoding()))
			pool_folders.append(self.pool_folder)
			debug.msg(u'creating new pool folder')
		else:
			debug.msg(u'reusing existing pool folder')
			self.pool_folder = pool_folder
		debug.msg(u'pool folder is \'%s\'' % self.pool_folder)

		string = self.open(string)
		item.item.__init__(self, name, self, string)

		# Default subject info
		self.set_subject(subject_nr)
		# Restore experiment path
		if experiment_path != None:
			self.fallback_pool_folder = os.path.join(experiment_path, u'__pool__')
			self.experiment_path = experiment_path
		else:
			self.fallback_pool_folder = None

	def module_container(self):

		"""Specify the module that contains the item modules"""

		return u'libopensesame'

	def item_prefix(self):

		"""
		A prefix for the plug-in classes, so that [prefix][plugin] class is used
		instead of the [plugin] class.
		"""

		return u''

	def set_subject(self, nr):

		"""<DOC>
		Sets the subject number and parity (even/ odd). This function is #
		called automatically when an experiment is started, so you do not #
		generally need to call it yourself.

		Arguments:
		nr	--	The subject nr.

		Example:
		>>> exp.set_subject(1)
		>>> print('Subject nr = %d' % exp.get('subject_nr'))
		>>> print('Subject parity = %s' % exp.get('subject_parity'))
		</DOC>"""

		# Set the subject nr and parity
		self.set(u'subject_nr', nr)
		if nr % 2 == 0:
			self.set(u'subject_parity', u'even')
		else:
			self.set(u'subject_parity', u'odd')

	def read_definition(self, s):

		"""
		Extracts a the definition of a single item from the string.

		Arguments:
		s	--	The definition string.

		Returns:
		A (str, str) tuple with the full string minus the definition string
		and the definition string.
		"""

		# Read the string until the end of the definition
		def_str = u''
		line = next(s, None)
		if line == None:
			return None, u''
		get_next = False
		while True:
			if len(line) > 0:
				if line[0] != u'\t':
					break
				else:
					def_str += line + u'\n'
			line = next(s, None)
			if line == None:
				break
		return line, def_str

	def parse_definition(self, item_type, item_name, string):

		"""
		Initializes a single definition, using the string, and adds it to the
		dictionary of items.

		Arguments:
		item_type	--	The item's type.
		item_name	--	The item's name.
		string		--	The item's definition string.
		"""

		if plugins.is_plugin(item_type):
			# Load a plug-in
			try:
				item = plugins.load_plugin(item_type, item_name, self, \
					string, self.item_prefix())
			except Exception as e:
				raise osexception(u"Failed to load plugin '%s'" % \
					item_type, exception=e)
			self.items[item_name] = item
		else:
			# Load one of the core items
			debug.msg(u"loading core item '%s' from '%s'" % (item_type, \
				self.module_container()))
			item_module = __import__(u'%s.%s' % (self.module_container(), \
				item_type), fromlist=[u'dummy'])
			item_class = getattr(item_module, item_type)
			item = item_class(item_name, self, string)
			self.items[item_name] = item

	def from_string(self, string):

		"""
		Reads the entire experiment from a string.

		Arguments:
		string	--	The definition string.
		"""

		debug.msg(u"building experiment")
		s = iter(string.split("\n"));
		line = next(s, None)
		while line != None:
			get_next = True
			try:
				l = self.split(line)
			except ValueError as e:
				raise osexception( \
					u"Failed to parse script. Maybe it contains illegal characters or unclosed quotes?", \
					exception=e)
			if len(l) > 0:
				self.parse_variable(line)
				# Parse definitions
				if l[0] == u"define":
					if len(l) != 3:
						raise osexception( \
							u'Failed to parse definition', line=line)
					item_type = l[1]
					item_name = self.sanitize(l[2])
					line, def_str = self.read_definition(s)
					get_next = False
					self.parse_definition(item_type, item_name, def_str)
			# Advance to next line
			if get_next:
				line = next(s, None)

	def run(self):

		"""Runs the experiment."""

		self.save_state()
		self.running = True
		self.init_display()
		self.init_sound()
		self.init_log()
		self.reset_feedback()

		print(u"experiment.run(): experiment started at %s" % time.ctime())

		if self.start in self.items:
			self.items[self.start].prepare()
			self.items[self.start].run()
		else:
			raise osexception( \
				"Could not find item '%s', which is the entry point of the experiment" \
				% self.start)

		print(u"experiment.run(): experiment finished at %s" % time.ctime())

		self.end()

	def cleanup(self):

		"""Calls all the cleanup functions."""

		while len(self.cleanup_functions) > 0:
			func = self.cleanup_functions.pop()
			debug.msg(u"calling cleanup function")
			func()

	def end(self):

		"""Nicely ends the experiment."""

		from openexp import sampler, canvas
		self.running = False
		try:
			self._log.flush()
			os.fsync(self._log)
			self._log.close()
		except:
			pass
		sampler.close_sound(self)
		canvas.close_display(self)
		self.cleanup()
		self.restore_state()

	def to_string(self):

		"""
		Encodes the experiment into a string.

		Returns:
		A Unicode definition string for the experiment.
		"""

		s = u'# Generated by OpenSesame %s (%s)\n' % (misc.version, \
			misc.codename) + \
			u'# %s (%s)\n' % (time.ctime(), os.name) + \
			u'# <http://www.cogsci.nl/opensesame>\n\n'
		for var in self.variables:
			s += self.variable_to_string(var)
		s += u'\n'
		for item in sorted(self.items):
			s += self.items[item].to_string() + u'\n'
		return s

	def resource(self, name):

		"""
		Retrieves a file from the resources folder.

		Arguments:
		name	--	The file name.

		Returns:
		A Unicode string with the full path to the file in the resources
		folder.
		"""

		name = self.unistr(name)
		if self != None:
			if name in self.resources:
				return self.resources[name]
			if os.path.exists(self.get_file(name)):
				return self.get_file(name)
		path = misc.resource(name)
		if path == None:
			raise Exception( \
				u"The resource '%s' could not be found in libopensesame.experiment.resource()" \
				% name)
		return path

	def get_file(self, path):

		"""<DOC>
		Returns the path to a file. First checks if the file is in the file pool #
		and then the folder of the current experiment (if any), or in the #
		`__pool__` subfolder of the current experiment. Otherwise, simply #
		returns the path.

		Arguments:
		path	--	The filename.

		Returns:
		The full path to the file.

		Example:
		>>> image_path = exp.get_file('my_image.png')
		>>> my_canvas = exp.offline_canvas()
		>>> my_canvas.image(image_path)
		</DOC>"""

		path = self.unistr(path)
		if path.strip() == u'':
			raise osexception(
				u"An empty string was passed to experiment.get_file(). Please "
				u"specify a valid filename.")
		if os.path.exists(os.path.join(self.pool_folder, path)):
			return os.path.join(self.pool_folder, path)
		if self.experiment_path != None:
			if os.path.exists(os.path.join(self.experiment_path, path)):
				return os.path.join(self.experiment_path, path)
			if self.fallback_pool_folder != None and os.path.exists(
				os.path.join(self.experiment_path, self.fallback_pool_folder,
				path)):
				return os.path.join(self.experiment_path,
					self.fallback_pool_folder, path)
		return path

	def file_in_pool(self, path):

		"""<DOC>
		Checks if a file is in the file pool.

		Returns:
		A Boolean indicating if the file is in the pool.

		Example:
		>>> if not exp.file_in_pool('my_image.png'):
		>>> 	print('my_image.png could not be found!')
		>>> else:
		>>> 	image_path = exp.get_file('my_image.png')
		>>> 	my_canvas = exp.offline_canvas()
		>>> 	my_canvas.image(image_path)
		</DOC>"""

		return os.path.exists(self.get_file(path))

	def save(self, path, overwrite=False):

		"""
		Saves the experiment to file. If no extension is provided,
		.opensesame.tar.gz is chosen by default.

		Arguments:
		path		--	The target file to save to.

		Keyword arguments:
		overwrite	--	A boolean indicating if existing files should be
						overwritten. (default=False)

		Returns:
		The path on successfull saving or False otherwise.
		"""

		if isinstance(path, str):
			path = path.decode(self.encoding)
		debug.msg(u'asked to save "%s"' % path)
		# Determine the extension
		ext = os.path.splitext(path)[1].lower()
		# If the extension is .opensesame, save the script as plain text
		if ext == u'.opensesame':
			if os.path.exists(path) and not overwrite:
				return False
			debug.msg(u'saving as .opensesame file')
			f = open(path, u'w')
			f.write(self.usanitize(self.to_string()))
			f.close()
			self.experiment_path = os.path.dirname(path)
			return path
		# Use the .opensesame.tar.gz extension by default
		if path[-len(u'.opensesame.tar.gz'):] != u'.opensesame.tar.gz':
			path += u'.opensesame.tar.gz'
		if os.path.exists(path) and not overwrite:
			return False
		debug.msg(u"saving as .opensesame.tar.gz file")
		# Write the script to a text file
		script = self.to_string()
		script_path = os.path.join(self.pool_folder, u'script.opensesame')
		f = open(script_path, u"w")
		f.write(self.usanitize(script))
		f.close()
		# Create the archive in a a temporary folder and move it afterwards.
		# This hack is needed, because tarfile fails on a Unicode path.
		tmp_path = tempfile.mktemp(suffix=u'.opensesame.tar.gz')
		tar = tarfile.open(tmp_path, u'w:gz')
		tar.add(script_path, u'script.opensesame')
		os.remove(script_path)
		# We also create a temporary pool folder, where all the filenames are
		# Unicode sanitized to ASCII format. Again, this is necessary to deal
		# with poor Unicode support in .tar.gz.
		tmp_pool = tempfile.mkdtemp(suffix=u'.opensesame.pool')
		for fname in os.listdir(self.pool_folder):
			sname = self.usanitize(fname)
			shutil.copyfile(os.path.join(self.pool_folder, fname), \
				os.path.join(tmp_pool, sname))
		tar.add(tmp_pool, u'pool', True)
		tar.close()
		# Move the file to the intended location
		shutil.move(tmp_path, path)
		self.experiment_path = os.path.dirname(path)
		return path

	def open(self, src):

		"""
		If the path exists, open the file, extract the pool and return the
		contents of the script.opensesame. Otherwise just return the input
		string, because it probably was a definition to begin with.

		Arguments:
		src		--	A definition string or a file to be opened.

		Returns:
		A unicode defition string.
		"""

		# If the path is not a path at all, but a string containing
		# the script, return it. Also, convert the path back to Unicode before
		# returning.
		if not os.path.exists(src):
			debug.msg(u'opening from unicode string')
			self.experiment_path = None
			if isinstance(src, unicode):
				return src
			return src.decode(self.encoding, u'replace')
		# If the file is a regular text script,
		# read it and return it
		ext = u'.opensesame.tar.gz'
		if src[-len(ext):] != ext:
			debug.msg(u'opening .opensesame file')
			self.experiment_path = os.path.dirname(src)
			return self.unsanitize(open(src, u'rU').read())
		debug.msg(u"opening .opensesame.tar.gz file")
		# If the file is a .tar.gz archive, extract the pool to the pool folder
		# and return the contents of opensesame.script.
		tar = tarfile.open(src, u'r:gz')
		for name in tar.getnames():
			# Here, all paths except name are Unicode. In addition, fname is
			# Unicode unsanitized, because the files as saved are Unicode
			# sanitized (see save()).
			uname = name.decode(self.encoding)
			folder, fname = os.path.split(uname)
			fname = self.unsanitize(fname)
			if folder == u"pool":
				debug.msg(u"extracting '%s'" % uname)
				tar.extract(name, self.pool_folder.encode( \
					misc.filesystem_encoding()))
				os.rename(os.path.join(self.pool_folder, uname), \
					os.path.join(self.pool_folder, fname))
				os.rmdir(os.path.join(self.pool_folder, folder))
		script_path = os.path.join(self.pool_folder, u"script.opensesame")
		tar.extract(u"script.opensesame", self.pool_folder)
		script = self.unsanitize(open(script_path, u"rU").read())
		os.remove(script_path)
		self.experiment_path = os.path.dirname(src)
		return script

	def reset_feedback(self):

		"""Resets the feedback variables (acc, avg_rt, etc.)."""

		self.total_responses = 0
		self.total_correct = 0
		self.total_response_time = 0
		self.avg_rt = u"undefined"
		self.average_response_time = u"undefined"
		self.accuracy = u"undefined"
		self.acc = u"undefined"

	def var_info(self):

		"""
		Returns a list of (name, value) tuples with variable descriptions
		for the main experiment.

		Returns:
		A list of tuples.
		"""

		l = []
		for var in self.variables:
			l.append( (var, self.variables[var]) )
		return l

	def var_list(self, filt=u''):

		"""
		Returns a list of (name, value, description) tuples with variable
		descriptions for all items

		Keyword arguments:
		filt	--	A search string to filter by. (default=u'')

		Returns:
		A list of tupless
		"""

		l = []
		# Create a dictionary of items that also includes the experiment
		item_dict = dict(self.items.items() + [(u'global', self)]).items()
		seen = []
		for item_name, item in item_dict:
			# Create a dictionary of variables that includes the broadcasted
			# ones as wel as the indirectly registered ones (using item.set())
			var_dict = item.var_info() + item.variables.items()
			for var, val in var_dict:
				if var not in seen and (filt in var.lower() or filt in \
					self.unistr(val).lower() or filt in item_name.lower()):
					l.append( (var, val, item_name) )
					seen.append(var)
		return l

	def init_sound(self):

		"""Intializes the sound backend."""

		from openexp import sampler
		sampler.init_sound(self)

	def init_display(self):

		"""Initializes the canvas backend."""

		from openexp import canvas
		canvas.init_display(self)

	def init_log(self):

		"""Opens the logile."""

		# Do not open the logfile if it's already open
		if self._log != None:
			return
		# If only a filename is present, we interpret this filename as relative
		# to the experiment folder, instead of relative to the current working
		# directory.
		if os.path.basename(self.logfile) == self.logfile and \
			self.experiment_path != None:
			self.logfile = os.path.join(self.experiment_path, self.logfile)
		# Open the logfile
		self._log = codecs.open(self.logfile, u'w', encoding=self.encoding)
		print(u"experiment.init_log(): using '%s' as logfile (%s)" % \
			(self.logfile, self.encoding))

	def save_state(self):

		"""
		Saves the system state so that it can be restored after the experiment.
		"""

		from libopensesame import inline_script
		inline_script.save_state()

	def restore_state(self):

		"""Restores the system to the state as saved by save_state()."""

		from libopensesame import inline_script
		inline_script.restore_state()

	def _sleep_func(self, ms):

		"""
		Sleeps for a specific time.

		* This is a stub that should be replaced by a proper function by the
		  canvas backend. See openexp._canvas.legacy.init_display()

		Arguments:
		ms	--	The sleep duration.
		"""

		raise osexception( \
			u"experiment._sleep_func(): This function should be set by the canvas backend.")

	def _time_func(self):

		"""
		Gets the time.

		* This is a stub that should be replaced by a proper function by the
		  canvas backend. See openexp._canvas.legacy.init_display()

		Returns:
		A timestamp in milliseconds. Depending on the backend, this may be an
		int or a float.
		"""

		raise osexception( \
			u"experiment._time_func(): This function should be set by the canvas backend.")


def clean_up(verbose=False):

	"""
	Cleans up the temporary pool folders.

	Keyword arguments:
	verbose		--	A boolean indicating if debugging output should be given.
					(default=False)
	"""

	from openexp import canvas
	global pool_folders
	if verbose:
		print(u"experiment.clean_up()")

	for path in pool_folders:
		if verbose:
			print(u"experiment.clean_up(): removing '%s'" % path)
		try:
			shutil.rmtree(path)
		except:
			if verbose:
				print(u"experiment.clean_up(): failed to remove '%s'" % path)
	canvas.clean_up(verbose)



########NEW FILE########
__FILENAME__ = feedback
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import sketchpad

class feedback(sketchpad.sketchpad):

	description = u'Provides feedback to the participant'

	def __init__(self, name, experiment, string=None):

		"""
		Constructor

		Arguments:
		name 		--	The item name
		experiment 	--	The experiment object.

		Keyword arguments:
		string		--	A definition string. (default=None)
		"""

		self.reset_variables = u'yes'
		sketchpad.sketchpad.__init__(self, name, experiment, string)

	def prepare(self):

		"""Prepares the item."""

		pass

	def run(self):

		"""Runs the item."""

		sketchpad.sketchpad.prepare(self)
		not sketchpad.sketchpad.run(self)
		if self.reset_variables == u'yes':
			self.experiment.reset_feedback()


########NEW FILE########
__FILENAME__ = generic_response
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import random
import openexp.keyboard
import openexp.mouse
from libopensesame import debug
from libopensesame.exceptions import osexception

class generic_response:

	"""
	Deals with overlapping functionality for items that are able to process a
	reponse.
	"""

	auto_response = u"a"
	process_feedback = False

	def prepare_timeout(self):

		"""Prepares the response timeout"""

		if self.get(u"timeout") == u"infinite":
			self._timeout = None
		else:
			try:
				self._timeout = int(self.get(u"timeout"))
			except:
				raise osexception( \
					u"'%s' is not a valid timeout in keyboard_response '%s'. Expecting a positive integer or 'infinite'." \
					% (self.get(u"timeout"), self.name))
			if self._timeout < 0:
				raise osexception( \
					u"'%s' is not a valid timeout in keyboard_response '%s'. Expecting a positive integer or 'infinite'." \
					% (self.get(u"timeout"), self.name))

	def auto_responder(self, dev=u'keyboard'):

		"""
		Mimicks participant responses.

		Keyword arguments:
		dev		--	The device that should be simulated. (default=u'keyboard')

		Returns:
		A simulated (response_time, response) tuple
		"""

		if self._timeout == None:
			self.sleep(random.randint(200, 1000))
		else:
			self.sleep(random.randint(min(self._timeout, 200), self._timeout))

		if self._allowed_responses == None:
			resp = self.auto_response
		else:
			resp = random.choice(self._allowed_responses)

		debug.msg(u"generic_response.auto_responder(): responding '%s'" % resp)
		if dev == u'mouse':
			pos = random.randint(0, self.get(u'width')), random.randint( \
				0, self.get(u'height'))
			return resp, pos, self.time()
		return resp, self.time()

	def auto_responder_mouse(self):

		"""An ugly hack to make auto-response work for mouse_response items."""

		return self.auto_responder(dev=u'mouse')

	def process_response_keypress(self, retval):

		"""Process a keypress response"""

		self.experiment.start_response_interval = self.sri
		key, self.experiment.end_response_interval = retval
		self.experiment.response = self.sanitize(key)
		self.synonyms = self._keyboard.synonyms(self.experiment.response)

	def process_response_mouseclick(self, retval):

		"""Process a mouseclick response"""

		self.experiment.start_response_interval = self.sri
		self.experiment.response, pos, self.experiment.end_response_interval = \
			retval
		self.synonyms = self._mouse.synonyms(self.experiment.response)
		if pos != None:
			self.experiment.cursor_x = pos[0]
			self.experiment.cursor_y = pos[1]
		else:
			self.experiment.cursor_x = u'NA'
			self.experiment.cursor_y = u'NA'

	def process_response(self):

		"""A generic method for handling response collection"""

		# Wait for a fixed duration
		retval = self._duration_func()
		self.synonyms = None

		# If the duration function did not give any kind of return value
		# there is no response to process
		if retval == None:
			return

		process_func = u"process_response_%s" % self.get(u"duration")
		if hasattr(self, process_func):
			getattr(self, process_func)(retval)
		else:
			raise osexception( \
				u"Don't know how to process responses for duration '%s' in item '%s'" \
				% (self.get(u"duration"), self.name))

		self.response_bookkeeping()

	def response_bookkeeping(self):

		"""Do some bookkeeping for the response"""

		# The respone and response_time variables are always set, for every
		# response item
		self.experiment.set(u"response_time", \
			self.experiment.end_response_interval - \
			self.experiment.start_response_interval)
		self.experiment.set(u"response_%s" % self.get(u"name"), \
			self.get(u"response"))
		self.experiment.set(u"response_time_%s" % self.get(u"name"), \
			self.get(u"response_time"))
		self.experiment.start_response_interval = None

		# But correctness information is only set for dedicated response items,
		# such as keyboard_response items, because otherwise we might confound
		# the feedback
		if self.process_feedback:
			debug.msg(u"processing feedback for '%s'" % self.name)
			if self.has(u"correct_response"):
				# If a correct_response has been defined, we use it to determine
				# accuracy etc.
				correct_response = self.get(u"correct_response")
				if hasattr(self, u"synonyms") and self.synonyms != None:
					if correct_response in self.synonyms or \
						self.unistr(correct_response) in self.synonyms:
						self.experiment.correct = 1
						self.experiment.total_correct += 1
					else:
						self.experiment.correct = 0
				else:
					if self.experiment.response in (correct_response, \
						self.unistr(correct_response)):
						self.experiment.correct = 1
						self.experiment.total_correct += 1
					else:
						self.experiment.correct = 0
			else:
				# If a correct_response hasn't been defined, we simply set
				# correct to undefined
				self.experiment.correct = u"undefined"
			# Do some response bookkeeping
			self.experiment.total_response_time += self.experiment.response_time
			self.experiment.total_responses += 1
			self.experiment.set(u"acc", 100.0 * self.experiment.total_correct / \
				self.experiment.total_responses)
			self.experiment.set(u"avg_rt", self.experiment.total_response_time / \
				self.experiment.total_responses)
			self.experiment.set(u"accuracy", self.experiment.acc)
			self.experiment.set(u"average_response_time", self.experiment.avg_rt)
			self.experiment.set(u"correct_%s" % self.get(u"name"), \
				self.get(u"correct"))

	def set_sri(self, reset=False):

		"""
		Sets the start of the response interval

		Keyword arguments:
		reset -- determines whether the start of the response interval should
				 be reset to the start of the current item (default=False)
		"""

		if reset:
			self.sri = self.get(u"time_%s" % self.name)
			self.experiment.start_response_interval = self.get("time_%s" % \
				self.name)

		if self.experiment.start_response_interval == None:
			self.sri = self.get(u"time_%s" % self.name)
		else:
			self.sri = self.experiment.start_response_interval

	def prepare_timeout(self):

		"""Prepare the response timeout"""

		# Set the timeout
		if not self.has(u"timeout") or self.get(u"timeout") == u"infinite":
			self._timeout = None
		else:
			try:
				self._timeout = int(self.get(u"timeout"))
			except:
				raise osexception( \
					u"'%s' is not a valid timeout in item '%s'. Expecting a positive integer or 'infinite'." \
					% (self.get(u"timeout"), self.name))
			if self._timeout < 0:
				raise osexception( \
					u"'%s' is not a valid timeout in item '%s'. Expecting a positive integer or 'infinite'." \
					% (self.get(u"timeout"), self.name))

	def prepare_allowed_responses(self):

		"""Prepare the allowed responses"""

		# Prepare the allowed responses
		dur = self.get(u"duration")
		if self.has(u"allowed_responses"):
			if dur == u"keypress":

				# Prepare valid keypress responses
				l = self.experiment.unistr(self.get(u"allowed_responses")).split( \
					u";")
				self._allowed_responses = l

			elif dur == u"mouseclick":

				# Prepare valid mouseclick responses
				self._allowed_responses = []
				for r in self.experiment.unistr(self.get( \
					u"allowed_responses")).split(";"):
					if r in self.resp_codes.values():
						for code, resp in self.resp_codes.items():
							if resp == r:
								self._allowed_responses.append(code)
					else:
						try:
							r = int(r)
							if r in self.resp_codes:
								self._allowed_responses.append(r)
							else:
								raise osexception( \
									u"Unknown allowed_response '%s' in mouse_response item '%s'" \
									% (r, self.name))
						except Exception as e:
							raise osexception( \
								u"Unknown allowed_response '%s' in mouse_response item '%s'" \
								% (r, self.name), exception=e)

			# If allowed responses are provided, the list should not be empty
			if len(self._allowed_responses) == 0:
				raise osexception( \
					u"'%s' are not valid allowed responses in keyboard_response '%s'" \
					% (self.get(u"allowed_responses"), self.name))
		else:
			self._allowed_responses = None

	def prepare_duration(self):

		"""Prepare the duration"""

		if type(self.get(u"duration")) == int:

			# Prepare a duration in milliseconds
			self._duration = int(self.get(u"duration"))
			if self._duration == 0:
				self._duration_func = self.dummy
			else:
				self._duration_func = self.sleep_for_duration

		else:

			# Prepare a special duration, such as 'keypress', which are
			# handles by special functions
			prepare_func = u"prepare_duration_%s" % self.get(u"duration")
			if hasattr(self, prepare_func):
				getattr(self, prepare_func)()
			else:
				raise osexception( \
					u"'%s' is not a valid duration in item '%s'" % \
					(self.get(u"duration"), self.name))

	def prepare_duration_keypress(self):

		"""Prepare a keypress duration"""

		self._keyboard = openexp.keyboard.keyboard(self.experiment)
		if self.experiment.auto_response:
			self._duration_func = self.auto_responder
		else:
			self._keyboard.set_timeout(self._timeout)
			self._keyboard.set_keylist(self._allowed_responses)
			self._duration_func = self._keyboard.get_key

	def prepare_duration_mouseclick(self):

		"""Prepare a mouseclick duration"""

		self._mouse = openexp.mouse.mouse(self.experiment)
		if self.experiment.auto_response:
			self._duration_func = self.auto_responder_mouse
		else:
			# Prepare mouseclick
			self._mouse.set_timeout(self._timeout)
			self._mouse.set_buttonlist(self._allowed_responses)
			self._duration_func = self._mouse.get_click

	def prepare(self):

		"""A generic method for preparing a response item"""

		self.prepare_timeout()
		self.prepare_allowed_responses()
		self.prepare_duration()

	def sleep_for_duration(self):

		"""Sleep for a specified time"""

		self.sleep(self._duration)

	def var_info(self):

		"""
		Return a list of dictionaries with variable descriptions

		Returns:
		A list of (name, description) tuples
		"""

		l = []
		l.append( (u"response", u"[Depends on response]") )
		l.append( (u"response_time", u"[Depends on response]") )
		l.append( (u"response_%s" % self.get(u"name", _eval=False), \
			u"[Depends on response]") )
		l.append( ("response_time_%s" % self.get(u"name", _eval=False), \
			u"[Depends on response]") )
		if self.process_feedback:
			l.append( (u"correct", u"[Depends on response]") )
			l.append( (u"correct_%s" % self.get(u"name", _eval=False), \
				u"[Depends on response]") )
			l.append( (u"average_response_time", u"[Depends on response]") )
			l.append( (u"avg_rt", u"[Depends on response]") )
			l.append( (u"accuracy", u"[Depends on response]") )
			l.append( (u"acc", u"[Depends on response]") )
		return l

########NEW FILE########
__FILENAME__ = html
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
from HTMLParser import HTMLParser
from libopensesame import debug

try:
	from bidi.algorithm import get_display as bidi_func
except:
	debug.msg( \
		u'Failed to import bidi. Bi-directional-text support will not be available', \
		reason=u'warning')
	bidi_func = None

class html(HTMLParser):

	"""
	A simple HTML parser that deals with a subset of HTML tags and renders text
	onto an openexp canvas. Currently, the following tags are supported: <b>,
	<i>, <br />, and <span>. For <span> you can pass size and style keywords.
	"""

	valid_end_tags = u'i', u'b', u'u', u'span'
	valid_start_tags = u'i', u'b', u'u', u'span', u'br'
	
	def handle_data(self, data):

		"""
		Receive a single piece of text that has the same style

		Arguments:
		data -- a data string
		"""

		style = self.style()
		while len(data) > 0:
			i = data[1:].find(u' ')
			if i < 0:
				break
			word = data[:i+1]
			data = data[i+1:]
			self.paragraph.append( (word, style) )
		self.paragraph.append( (data, style) )

	def handle_endtag(self, tag):

		"""
		Handle a closing tag

		Arguments:
		tag -- the closing tag
		"""

		if tag not in self.valid_end_tags:
			return

		if self.current_tag != tag:
			debug.msg(u'Warning: expecting closing tag for %s, got %s' % \
				(self.current_tag, tag), reason=u'warning')

		self.pop_style()

	def handle_starttag(self, tag, attrs):

		"""
		Handle an opening tag

		Arguments:
		tag -- the closing tag
		attrs -- the tag attributes
		"""

		if tag not in self.valid_start_tags:
			return

		if tag == u'br':
			self.text.append(self.paragraph)
			self.paragraph = []
			return

		self.current_tag = tag

		if tag == u'span':
			style = {}
			for var, val in attrs:
				style[str(var)] = val
			self.push_style(**style)
		elif tag == u'b':
			self.push_style(bold=True)
		elif tag == u'i':
			self.push_style(italic=True)
		elif tag == u'u':
			self.push_style(underline=True)
		else:
			debug.msg(u'Unrecognized tag: %s' % tag)

	def render(self, text, x, y, canvas, max_width=None, center=False, \
		color=None, bidi=False, html=True):

		"""
		Renders an HTML formatted string onto a canvas.

		Arguments:
		text		-- 	The text string.
		x			--	The left-most coordinate.
		y			--	The top coordinate.
		canvas		--	An openexp canvas.

		Keyword arguments:
		max_width 	--	The maximum width, after which line wrapping should
						occur, or None to wrap at screen edge. (default=None)
		center 		--	Indicates whether the text should be center aligned.
						(default=False)
		color		--	Indicates the color of the text or None for canvas
						default. (default=None)
		bidi		--	Indicates whether bi-directional text support should be
						enabled. (default=False)
		html		--	Indicates whether HTML should be parsed. (default=True)
		"""

		# Make sure that it's a string
		text = canvas.experiment.unistr(text)
		debug.msg(text)
		# Parse bi-directional strings
		if bidi and bidi_func != None:
			text = bidi_func(text)
		# Convert line breaks to HTML break tags
		text = text.replace(os.linesep, u'<br />').replace(u'\n', u'<br />')

		# Initialize the style
		self.canvas = canvas
		self.default_style = {
			u'style' : canvas.font_style,
			u'bold' : canvas.font_bold,
			u'italic' : canvas.font_italic,
			u'color' : canvas.fgcolor,
			u'size' : canvas.font_size,
			u'underline' : canvas.font_underline
			}
		backup_style = self.default_style.copy()

		# Optionally override color
		if color != None:
			self.default_style[u'color'] = color

		# Set the maximum width
		if max_width == None:
			max_x = canvas.experiment.width
		else:
			if center:
				max_x = x + max_width/2
			else:
				max_x = x + max_width

		# First parse the HTML
		self.text = []
		self.paragraph = []
		self.style_stack = []
		self.current_tag = None
		self.push_style()

		# Optionally parse HTML
		if html:
			self.feed(text)
		else:
			self.handle_data(text)
		self.text.append(self.paragraph)

		# If we want to center the next, we need a dry run to calculate all the
		# line lengths and determine the vertical and horizontal offset for each
		# line
		if center:
			l_x_offset = []
			_y = y
			for paragraph in self.text:
				_x = x
				dy = canvas.text_size(u'dummy')[1]
				for word, style in paragraph:

					# Set the style
					canvas.set_font(style[u'style'], int(style[u'size']), \
						bold=style[u'bold'], italic=style[u'italic'], \
						underline=style[u'underline'])

					# Line wrap if we run out of the screen
					dx, dy = canvas.text_size(word)
					if _x+dx > max_x + (max_x-x):
						l_x_offset.append(-(_x-x)/2)
						_x = x
						_y += dy
						dx = canvas.text_size(word.lstrip())[0]
						word = word.lstrip()

					# Draw!
					_x += dx
				l_x_offset.append(-(_x-x)/2)
				_y += dy
			l_x_offset.reverse()
			y_offset = -(_y-y)/2

		# Now render it onto the canvas
		if center:
			_y = y+y_offset
		else:
			_y = y
		for paragraph in self.text:
			if center:
				_x = x+l_x_offset.pop()
			else:
				_x = x
			dy = canvas.text_size(u'dummy')[1]
			for word, style in paragraph:

				# Set the style
				canvas.set_font(style[u'style'], int(style[u'size']), \
					bold=style[u'bold'], italic=style[u'italic'], underline= \
					style[u'underline'])
				canvas.set_fgcolor(style[u'color'])

				# Line wrap if we run out of the screen
				dx, dy = canvas.text_size(word)
				if _x+dx > max_x:
					if center:
						_x = x+l_x_offset.pop()
					else:
						_x = x
					_y += dy
					dx = canvas.text_size(word.lstrip())[0]
					word = word.lstrip()

				# Draw!
				canvas._text(word, _x, _y)
				_x += dx
			_y += dy

		# Restore the canvas font and colors
		canvas.set_fgcolor(backup_style[u'color'])
		canvas.set_font(backup_style[u'style'], int(backup_style[u'size']), \
			bold=backup_style[u'bold'], italic=backup_style[u'italic'])

	def pop_style(self):

		"""Pop a style from the style stack"""

		self.style_stack.pop()
		if len(self.style_stack) == 0:
			self.push_style()

	def push_style(self, **keywords):

		"""
		Push a new style onto the style stack

		Keyword arguments:
		**keywords -- a keyword dictionary with style attributes
		"""

		if len(self.style_stack) == 0:
			current_style = self.default_style.copy()
		else:
			current_style = self.style_stack[-1].copy()
		for tag, val in keywords.iteritems():
			current_style[tag] = val
		self.style_stack.append(current_style)

	def style(self):

		"""
		Get the current style

		Returns:
		A style dictionary
		"""

		return self.style_stack[-1].copy()

########NEW FILE########
__FILENAME__ = inline_script
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import re
from libopensesame import item
from openexp import canvas
from libopensesame.exceptions import osexception

_globals = {}

class inline_script(item.item):

	"""Allows users to use Python code in their experiments"""

	description = u'Executes Python code'

	def __init__(self, name, experiment, string=None):

		"""<DOC>
		Constructor. You will generally not create an inline_script item #
		yourself, but use OpenSesame to create a body for the prepare() and #
		run() functions.

		Arguments:
		name		--	The name of the item.
		experiment 	--	The experiment.

		Keyword arguments:
		string		--	An item definition string (default=None).
		</DOC>"""

		self._prepare = u''
		self._run = u''
		self._var_info = None
		item.item.__init__(self, name, experiment, string)

	def copy_sketchpad(self, sketchpad_name):

		"""<DOC>
		Creates a canvas that is a copy from the canvas of a sketchpad item.

		Arguments:
		sketchpad_name	--	The name of the sketchpad.

		Returns:
		An openexp canvas.

		Example:
		>>> my_canvas = self.copy_sketchpad('my_sketchpad')
		</DOC>"""

		c = self.offline_canvas()
		c.copy(self.experiment.items[sketchpad_name].canvas)
		return c

	def offline_canvas(self, auto_prepare=True):

		"""<DOC>
		Creates an empty canvas.

		Keyword arguments:
		auto_prepare 	--	See canvas documentation. (default=True)

		Returns:
		An openexp canvas.

		Example:
		>>> my_canvas = self.offline_canvas()
		</DOC>"""

		return canvas.canvas(self.experiment, self.get(u'background'), \
			self.get(u'foreground'), auto_prepare=auto_prepare)

	def prepare(self):

		"""<DOC>
		Executes the prepare script. The code that you enter in the 'prepare' #
		tab of an inline_script item in the GUI is used as a body for this #
		function.
		</DOC>"""

		global _globals, _locals

		item.item.prepare(self)
		if self.experiment.transparent_variables == u'yes':
			self.start_transparency()
		# Convenience variables need to be registered as globals. By specifying
		# a __name__, the script will function as a module, so that e.g. import
		# statements do not suffer from locality.
		if u'exp' not in _globals:
			_globals[u'exp'] = self.experiment
			_globals[u'win'] = self.experiment.window
			_globals[u'__name__'] = u'myname'
		# 'self' must always be registered, otherwise we get confusions between
		# the various inline_script items.
		_globals[u'self'] = self
		# Prepend source encoding (PEP 0263) and encode scripts. This is
		# necessary, because the exec statement doesn't take kindly to Unicode.
		_prepare = (u'#-*- coding:%s -*-\n' % self.encoding + self._prepare) \
			.encode(self.encoding)
		_run = (u'#-*- coding:%s -*-\n' % self.encoding + self._run) \
			.encode(self.encoding)
		# Compile prepare script
		try:
			self.cprepare = compile(_prepare, u'<string>', u'exec')
		except Exception as e:
			raise osexception(u'Failed to compile inline script', item= \
				self.name, phase=u'prepare', exception=e)
		# Compile run script
		try:
			self.crun = compile(_run, u'<string>', u'exec')
		except Exception as e:
			raise osexception(u'Failed to compile inline script', item= \
				self.name, phase=u'run', exception=e)
		# Run prepare script
		try:
			exec(self.cprepare, _globals)
		except Exception as e:
			raise osexception(u'Error while executing inline script', item= \
				self.name, phase=u'prepare', exception=e)
		if self.experiment.transparent_variables == u'yes':
			self.end_transparency()

	def run(self):

		"""<DOC>
		Executes the run script. The code that you enter in the 'run' tab of #
		an inline_script item in the GUI is used as a body for this function.
		</DOC>"""

		global _globals, _locals
		self.set_item_onset()
		# 'self' must always be registered, otherwise we get confusions between
		# the various inline_script items.
		_globals[u'self'] = self
		if self.experiment.transparent_variables == u'yes':
			self.start_transparency()
		try:
			exec(self.crun, _globals)
		except Exception as e:
			raise osexception(u'Error while executing inline script', item= \
				self.name, phase=u'run', exception=e)
		if self.experiment.transparent_variables == u'yes':
			self.end_transparency()

	def var_info(self):

		"""
		Gives a list of dictionaries with variable descriptions.

		Returns:
		A list of (variable, description) tuples.
		"""

		# Don't parse the script if it isn't necessary, since
		# regular expressions are a bit slow
		if self._var_info != None:
			return self._var_info

		l = item.item.var_info(self)

		m = re.findall( \
			u"self.experiment.set\(\"(\w+)\"(\s*),(\s*)(\"*)([^\"\)]*)(\"*)", \
			self._prepare + self._run) \
			+ re.findall( \
			u"self.experiment.set\('(\w+)'(\s*),(\s*)('*)([^'\)]*)('*)", \
			self._prepare + self._run) \
			+ re.findall( \
			u"exp.set\(\"(\w+)\"(\s*),(\s*)(\"*)([^\"\)]*)(\"*)", \
			self._prepare + self._run) \
			+ re.findall( \
			u"exp.set\('(\w+)'(\s*),(\s*)('*)([^'\)]*)('*)", \
			self._prepare + self._run)

		for var, s1, s2, q1, val, q2 in m:
			if q1 != u'"':
				val = u'[Set to \'%s\']' % val
			l.append( (var, val) )
		self._var_info = l

		return l

	def start_transparency(self):

		"""
		Registers all experiment variables in the locals dictionary. This allows
		the user to interact with the experimental variables without needing
		to call `exp.set()`.
		"""

		global _globals
		for var, val in self.experiment.var_info():
			_globals[var] = val

	def end_transparency(self):

		"""
		Sets all local variables, so that the user doesn't have explicitly have
		to call `exp.set()`.
		"""

		global _globals
		for var, val in _globals.items():
			if isinstance(val, basestring) or isinstance(val, float) or \
				isinstance(val, int):
				self.experiment.set(var, val)

def restore_state():

	"""Restores the system state."""

	global _globals
	_globals = {}

def save_state():

	"""Saves the system state."""

	# Currently does nothing.
	pass

########NEW FILE########
__FILENAME__ = item
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import openexp.mouse
import openexp.keyboard
from libopensesame.exceptions import osexception
from libopensesame import debug, regexp
import string
import os
import sys
import pygame

class item(object):

	"""Abstract class that serves as the basis for all OpenSesame items."""

	encoding = u'utf-8'

	def __init__(self, name, experiment, string=None):

		"""
		Constructor.

		Arguments:
		name 		--	The name of the item.
		experiment 	--	The experiment object.

		Keyword arguments:
		string		--	An definition string. (default=None).
		"""

		self.name = name
		self.experiment = experiment
		self.debug = debug.enabled
		self.count = 0
		# A number of keywords are reserved, which means that they cannot be
		# used as variable names
		self.reserved_words = [u'experiment', u'variables', u'comments', \
			u'item_type']
		for attr in dir(item):
			if hasattr(getattr(item, attr), u'__call__'):
				self.reserved_words.append(attr)

		self._get_lock = None
		# item_type shouldn't be explicitly set anymore.
		if hasattr(self, u'item_type'):
			debug.msg(u'item_type has been set explicitly in item "%s"' % \
			self.name, reason=u'deprecation')
		# Deduce item_type from class name
		prefix = self.experiment.item_prefix()
		self.item_type = unicode(self.__class__.__name__)
		if self.item_type.startswith(prefix):
			self.item_type = self.item_type[len(prefix):]
		if not hasattr(self, u'description'):
			self.description = u'Default description'
		if not hasattr(self, u'round_decimals'):
			self.round_decimals = 2
		self.variables = {}
		self.comments = []
		if string != None:
			self.from_string(string)

	def prepare(self):

		"""Implements the prepare phase of the item."""

		self.time = self.experiment._time_func
		self.sleep = self.experiment._sleep_func
		self.experiment.set(u'count_%s' % self.name, self.count)
		self.count += 1

	def run(self):

		"""Implements the run phase of the item."""

		pass

	def parse_variable(self, line):

		"""
		Reads a single variable from a single definition line.

		Arguments:
		line	--	A single definition line.

		Returns:
		True on succes, False on failure.
		"""

		# It is a little ugly to call parse_comment() here, but otherwise
		# all from_string() derivatives need to be modified
		if self.parse_comment(line):
			return True
		l = self.split(line.strip())
		if len(l) > 0 and l[0] == u'set':
			if len(l) != 3:
				raise osexception( \
					u'Error parsing variable definition: "%s"' % line)
			else:
				self.set(l[1], l[2])
				return True
		return False

	def parse_keywords(self, line, unsanitize=False, _eval=False):

		"""
		Parses keywords, e.g. 'my_keyword=my_value'.

		Arguments:
		line		--	A single definition line.

		Keyword arguments:
		unsanitize	--	DEPRECATED KEYWORD.
		_eval		--	Indicates whether the values should be evaluated.
						(default=False)

		Returns:
		A value dictionary with keywords as keys and values as values.
		"""

		# Parse keywords
		l = self.split(line.strip())
		keywords = {}
		for i in l:
			j = i.find(u'=')
			if j != -1:
				# UGLY HACK: if the string appears to be plain text,
				# rather than a keyword, for example something like
				# 'accuracy = [acc]%', do not parse it as a keyword-
				# value pair. The string needs to occur only once in
				# the full line, both quoted and unquoted.
				q = u'"%s"' % i
				if line.count(q) == 1 and line.count(i) == 1:
					debug.msg( \
						u'"%s" does not appear to be a keyword-value pair in string "%s"' \
						% (i, line))
				else:
					var = str(i[:j])
					val = self.auto_type(i[j+1:])
					if _eval:
						val = self.eval_text(val)
					keywords[var] = val
		return keywords

	def parse_line(self, line):

		"""
		Allows for arbitrary line parsing, for item-specific requirements.

		Arguments:
		line	--	A single definition line.
		"""

		pass

	def parse_comment(self, line):

		"""
		Parses comments from a single definition line, indicated by # // or '.

		Arguments:
		line	--	A single definition line.

		Returns:
		True on succes, False on failure.
		"""

		line = line.strip()
		if len(line) > 0 and line[0] == u'#':
			self.comments.append(line[1:])
			return True
		elif len(line) > 1 and line[0:2] == u'//':
			self.comments.append(line[2:])
			return True
		return False

	def set_response(self, response=None, response_time=None, correct=None):

		"""<DOC>
		Processes a response in such a way that feedback variables are updated #
		as well.

		Keyword arguments:
		response		--	The response value. (default=None)
		response_time	--	The response time. (default=None)
		correct			--	The correctness value. (default=None)

		Example:
		>>> from openexp.keyboard import keyboard
		>>> my_keyboard = keyboard(exp)
		>>> t1 = self.time()
		>>> button, timestamp = my_keyboard.get_key()
		>>> if button == 'left':
		>>> 	correct = 1
		>>> else:
		>>> 	correct = 0
		>>> rt = timestamp - t1
		>>> self.set_response(response=button, response_time=rt, \
		>>> 	correct=correct)
		</DOC>"""

		# Handle response variables.
		self.experiment.set(u'total_responses', self.experiment.get( \
			u'total_responses') + 1)
		self.experiment.set(u'response', response)
		self.experiment.set(u'response_time', response_time)
		if response_time != None:
			if type(response_time) not in (int, float):
				raise osexception(u'response should be a numeric value or None')
			self.experiment.set(u'total_response_time', self.experiment.get( \
			u'total_response_time') + self.get(u'response_time'))
		if correct != None:
			if correct not in (0, 1, True, False, None):
				raise osexception( \
					u'correct should be 0, 1, True, False, or None')
			if correct:
				self.experiment.set(u'total_correct', self.experiment.get( \
					u'total_correct') + 1)
				self.experiment.set(u'correct', 1)
			else:
				self.experiment.set(u'correct', 0)
		# Set feedback variables
		self.experiment.set(u'acc', 100.0 * self.experiment.get( \
			u'total_correct') / self.experiment.get(u'total_responses'))
		self.experiment.set(u'avg_rt', self.experiment.get( \
			u'total_response_time') / self.experiment.get(u'total_responses'))
		self.experiment.set(u'accuracy', self.experiment.get(u'acc'))
		self.experiment.set(u'average_response_time', self.experiment.get( \
			u'avg_rt'))
		# Copy the response variables to variables with a name suffix.
		self.experiment.set(u'correct_%s' % self.get(u'name'), \
			self.experiment.get(u'correct'))
		self.experiment.set(u'response_%s' % self.get(u'name'), \
			self.experiment.get(u'response'))
		self.experiment.set(u'response_time_%s' % self.get(u'name'), \
			self.experiment.get(u'response_time'))

	def variable_to_string(self, var):

		"""
		Encodes a variable into a definition string.

		Arguments:
		var		--	The variable to encode.

		Returns:
		A definition string.
		"""

		val = self.unistr(self.variables[var])
		# Multiline variables are stored as a block
		if u'\n' in val or u'"' in val:
			s = u'__%s__\n' % var
			for l in val.split(u'\n'):
				s += '\t%s\n' % l
			while s[-1] in (u'\t', u'\n'):
				s = s[:-1]
			s += u'\n\t__end__\n'
			return s
		# Regular variables
		else:
			return u'set %s "%s"\n' % (var, val)

	def from_string(self, string):

		"""
		Parses the item from a definition string.

		Arguments:
		string	--	The definition string.
		"""

		debug.msg()
		textblock_var = None
		self.variables = {}
		for line in string.split(u'\n'):
			line_stripped = line.strip()
			# The end of a textblock
			if line_stripped == u'__end__':
				if textblock_var == None:
					self.experiment.notify( \
						u'It appears that a textblock has been closed without being opened. The most likely reason is that you have used the string "__end__", which has a special meaning for OpenSesame.')
				else:
					self.set(textblock_var, textblock_val)
					textblock_var = None
			# The beginning of a textblock. A new textblock is only started when
			# a textblock is not already ongoing, and only if the textblock
			# start is of the format __VARNAME__
			elif line_stripped[:2] == u'__' and line_stripped[-2:] == u'__' \
				and textblock_var == None:
				textblock_var = line_stripped[2:-2]
				if textblock_var in self.reserved_words:
					textblock_var = u'_' + textblock_var
				if textblock_var != u'':
					textblock_val = u''
				else:
					textblock_var = None
				# We cannot just strip the multiline code, because that may mess
				# up indentation. So we have to detect if the string is indented
				# based on the opening __varname__ line.
				strip_tab = line[0] == u'\t'
			# Collect the contents of a textblock
			elif textblock_var != None:
				if strip_tab:
					textblock_val += line[1:] + u'\n'
				else:
					textblock_val += line + u'\n'
			# Parse regular variables
			elif not self.parse_variable(line):
				self.parse_line(line)

	def to_string(self, item_type=None):

		"""
		Encodes the item into an OpenSesame definition string.

		Keyword arguments:
		item_type	--	The type of the item or None for autodetect.
						(default=None)

		Returns:
		The unicode definition string
		"""

		if item_type == None:
			item_type = self.item_type
		s = u'define %s %s\n' % (item_type, self.name)
		for comment in self.comments:
			s += u'\t# %s\n' % comment.strip()
		for var in self.variables:
			s += u'\t' + self.variable_to_string(var)
		return s

	def resolution(self):

		"""<DOC>
		Returns the display resolution and check whether the resolution is valid.

		Note: The meaning of 'resolution' depends on the back-end. For example, #
		the legacy and OpenGL back-ends change the actual resolution of the #
		display, whereas the other back-ends do not alter the actual display #
		resolution, 	but create a 'virtual display' with the requested resolution #
		that is presented in the center of the display.

		Returns:
		A (width, height) tuple
		</DOC>"""

		w = self.get(u'width')
		h = self.get(u'height')
		if type(w) != int or type(h) != int:
			raise osexception( \
				u'(%s, %s) is not a valid resolution' % (w, h))
		return w, h

	def set(self, var, val):

		"""<DOC>
		Sets an OpenSesame variable.

		If you want to set a variable so that it is available in other items as #
		well (such as the logger item, so you can log the variable), you need #
		to use the set() function from the experiment. So, in an inline_script #
		item you would generally set a variable with exp.set(), rather #
		than self.set().

		Please note that you can only set simple variable types (str, unicode, #
		float, and int). If you use the set function to save an object, it will #
		be converted to a string representation. To make complex variables #
		globally accessible in your experiment, please use the global keyword.

		The type of the value can be anything. However, see get() for an #
		explanation of how data-types are handled.

		Arguments:
		var -- The name of an OpenSesame variable.
		val -- The value.

		Example:
		>>> exp.set('my_timestamp', self.time())
		</DOC>"""

		# Make sure the variable name and the value are of the correct types
		var = self.unistr(var)
		val = self.auto_type(val)
		# Check whether the variable name is valid
		if regexp.sanitize_var_name.sub(u'_', var) != var:
			raise osexception( \
				u'"%s" is not a valid variable name. Variable names must consist of alphanumeric characters and underscores, and may not start with a digit.' \
				% var)
		# Check whether the variable name is not protected
		if var in self.reserved_words:
			raise osexception( \
				u'"%s" is a reserved keyword (i.e. it has a special meaning for OpenSesame), and therefore cannot be used as a variable name. Sorry!' \
				% var)

		# Register the variables
		setattr(self, var, val)
		self.variables[var] = val

	def unset(self, var):

		"""<DOC>
		Unsets (forgets) an OpenSesame variable.

		Arguments:
		var -- The name of an OpenSesame variable.

		Example:
		>>> self.set('var', 'Hello world!')
		>>> print(self.get('var')) # Prints 'Hello world!'
		>>> self.unset('variable_to_forget')
		>>> print(self.get('var')) # Gives error!
		</DOC>"""

		var = self.unistr(var)
		if var in self.variables:
			del self.variables[var]
		try:
			delattr(self, var)
		except:
			pass

	def get(self, var, _eval=True):

		"""<DOC>
		Returns the value of an OpenSesame variable. Checks first if the #
		variable exists 'locally' in the item and, if not, checks if the #
		variable exists 'globally' in the experiment.

		The type of the returned value can be int, float, or unicode #
		(string). The appropriate type is automatically selected, e.g. '10' #
		is returned as int, '10.1' as float, and 'some text' as unicode.

		The _eval parameter is used to specify whether the value of the #
		variable should be evaluated, in case it contains references to other #
		variables. This is best illustrated by example 2 below.

		Arguments:
		var -- The name of an OpenSesame variable.
		_eval -- Indicates whether the variable should be evaluated, i.e. #
				 whether containing variables should be processed #
				 (default=True).

		Exceptions:
		A osexception is raised if the variable is not found.

		Returns:
		The value.

		Example:
		>>> if self.get('cue') == 'valid':
		>>>		print('This is a validly cued trial')

		Example 2:
		>>> exp.set('var1', 'I like [var2]')
		>>> exp.set('var2', 'OpenSesame')
		>>> print(self.get('var1')) # prints 'I like OpenSesame'
		>>> print(self.get('var1', _eval=False)) # prints 'I like [var2]'

		</DOC>"""

		var = self.unistr(var)
		# Avoid recursion
		if var == self._get_lock:
			raise osexception( \
				u"Recursion detected! Is variable '%s' defined in terms of itself (e.g., 'var = [var]') in item '%s'" \
				% (var, self.name))
		# Get the variable
		if hasattr(self, var):
			val = getattr(self, var)
		else:
			try:
				val = getattr(self.experiment, var)
			except:
				raise osexception( \
					u"Variable '%s' is not set in item '%s'.<br /><br />You are trying to use a variable that does not exist. Make sure that you have spelled and capitalized the variable name correctly. You may wish to use the variable inspector (Control + I) to find the intended variable." \
					% (var, self.name))
		if _eval:
			# Lock to avoid recursion and start evaluating possible variables
			self._get_lock = var
			val = self.eval_text(val)
			self._get_lock = None
			# Done!
		return val

	def get_check(self, var, default=None, valid=None, _eval=True):

		"""<DOC>
		Similar to get(), but falls back to a default if the variable has not #
		been set. It also raises an error if the value is not part of the valid #
		list.

		Arguments:
		var -- The name of an OpenSesame variable
		default -- A default 'fallback' value or None for no fallback, in which #
				   case an exception is rased if the value does not exist.
		valid -- A list of allowed values (or None for no restrictions). An #
				 exception is raised if the value is not an allowed value.
		_eval -- Indicates whether the variable should be evaluated, i.e. #
				 whether containing variables should be processed (default=True).

		Exceptions:
		Raises a osexception if the variable is not defined and there is no #
		default value, or if the variable value is not part of the 'valid' list.

		Returns:
		The value

		Example:
		>>> if self.get_check('cue', default='invalid') == 'valid':
		>>>		print('This is a validly-cued trial')
		</DOC>"""

		if default == None:
			val = self.get(var, _eval=_eval)
		elif self.has(var):
			val = self.get(var, _eval=_eval)
		else:
			val = default
		if valid != None and val not in valid:
			raise osexception( \
				u"Variable '%s' is '%s', expecting '%s'" % (var, val, \
				u" or ".join(valid)))
		return val

	def has(self, var):

		"""<DOC>
		Checks if an OpenSesame variable exists, either in the item or in the #
		experiment.

		Arguments:
		var -- The name of an OpenSesame variable.

		Returns:
		True if the variable exists, False if not.

		Example:
		>>> if not self.has('response'):
		>>> 	print('No response has been collected yet')

		</DOC>"""

		var = self.unistr(var)
		return hasattr(self, var) or hasattr(self.experiment, var)

	def get_refs(self, text):

		"""<DOC>
		Returns a list of variables that are referred to by a string of text.

		Arguments:
		text -- A string of text.

		Returns:
		A list of variable names or an empty list if the string contains no #
		references.

		Example:
		>>> print(self.get_refs('There are [two] [references] here'))
		>>> # Prints ['two', 'references']
		</DOC>"""

		text = self.unistr(text)

		l = []
		start = -1
		while True:
			# Find the start and end of a variable definition
			start = text.find(u'[', start + 1)
			if start < 0:
				break
			end = text.find(u']', start + 1)
			if end < 0:
				raise osexception( \
					u"Missing closing bracket ']' in string '%s', in item '%s'" \
					% (text, self.name))
			var = text[start+1:end]
			l.append(var)
			var = var[end:]
		return l

	def auto_type(self, val):

		"""<DOC>
		Converts a value into the 'best fitting' or 'simplest' type that is #
		compatible with the value.

		Arguments:
		val -- A value.

		Returns:
		The same value converted to the 'best fitting' type.

		Example:
		>>> print(type(self.auto_type('1'))) # Prints 'int'
		>>> print(type(self.auto_type('1.1'))) # Prints 'float'
		>>> print(type(self.auto_type('some text'))) # Prints 'unicode'
		>>> # Note: Boolean values are converted to 'yes' / 'no' and are
		>>> # therefore also returned as unicode objects.
		>>> print(type(self.auto_type(True))) # Prints 'unicode'
		</DOC>"""

		# Booleans are converted to True/ False
		if type(val) == bool:
			if val:
				return u'yes'
			else:
				return u'no'
		# Try to convert the value to a numeric type
		try:
			# Check if the value can be converted to an int without loosing
			# precision. If so, convert to int
			if int(float(val)) == float(val):
				return int(float(val))
			# Else convert to float
			else:
				return float(val)
		except:
			# Else, fall back to unicde
			return self.unistr(val)

	def set_item_onset(self, time=None):

		"""
		Set a timestamp for the item's executions

		Keyword arguments:
		time -- the timestamp or None to use the current time (default = None)
		"""

		if time == None:
			time = self.time()
		setattr(self.experiment, u'time_%s' % self.name, time)

	def dummy(self, **args):

		"""
		Dummy function

		Keyword arguments:
		arguments -- accepts all keywords for compatibility
		"""

		pass

	def eval_text(self, text, round_float=False, soft_ignore=False, quote_str=False):

		"""<DOC>
		Evaluates a string of text, so that all variable references (e.g., #
		'[var]') are replaced by values.

		Arguments:
		text -- The text to be evaluated.

		Keyword arguments:
		round_float -- A Boolean indicating whether float values should be #
					   rounded to a precision of [round_decimals]. #
					   round_decimals is an OpenSesame variable that has a #
					   default value of 2. (Default=False)
		soft_ignore -- A Boolean indicating whether missing variables should be #
					   ignored, rather than cause an exception (default=False).
		quote_str -- A Boolean indicating whether string variables should be #
					 surrounded by single quotes (default=False).

		Returns:
		The evaluated text.

		Example:
		>>> exp.set('var', 'evaluated')
		>>> # Prints 'This string has been evaluated
		>>> print(self.eval_text('This string has been [var]'))
		</DOC>"""

		# Only unicode needs to be evaluated
		text = self.auto_type(text)
		if type(text) != unicode:
			return text

		# Prepare a template for rounding floats
		if round_float:
			float_template = u'%%.%sf' % self.get("round_decimals")
		# Find and replace all variables in the text
		while True:
			m = regexp.find_variable.search(text)
			if m == None:
				break
			var = m.group(0)[1:-1]
			if not soft_ignore or self.has(var):
				val = self.get(var)
				# Quote strings if necessary
				if type(val) == unicode and quote_str:
					val = u"'" + val + u"'"
				# Round floats
				elif round_float and type(val) == float:
					val = float_template % val
				else:
					val = self.unistr(val)
				text = text.replace(m.group(0), val, 1)
		return self.auto_type(text)

	def compile_cond(self, cond, bytecode=True):

		"""
		Create Python code for a given conditional statement

		Arguments:
		cond -- the conditional statement (e.g., '[correct] = 1')

		Keyword arguments:
		bytecode -- a boolean indicating whether the generated code should be
					byte compiled (default = True)

		Returns:
		Python code (possibly byte compiled) that reflects the conditional
		statement
		"""

		src = cond

		# If the conditional statement is preceded by a '=', it is interpreted as
		# Python code, like 'self.get("correct") == 1'. In this case we only have
		# to strip the preceding space
		if len(src) > 0 and src[0] == u'=':
			code = src[1:]
			debug.msg(u'Python-style conditional statement: %s' % code)

		# Otherwise, it is interpreted as a traditional run if statement, like
		# '[correct] = 1'
		else:
			operators = u"!=", u"==", u"=", u"<", u">", u">=", u"<=", u"+", \
				u"-", u"(", u")", u"/", u"*", u"%", u"~", u"**", u"^"
			op_chars = u"!", u"=", u"=", u"<", u">", u"+", u"-", u"(", u")", \
				u"/", u"*", u"%", u"~", u"*", u"^"
			whitespace = u" ", u"\t", u"\n"
			keywords = u"and", u"or", u"is", u"not", u"true", u"false"
			capitalize = u"true", u"false", u"none"

			# Try to fix missing spaces
			redo = True
			while redo:
				redo = False
				for i in range(len(cond)):
					if cond[i] in op_chars:
						if i != 0 and cond[i-1] not in op_chars + whitespace:
							cond = cond[:i] + " " + cond[i:]
							redo = True
							break
						if i < len(cond)-1 and cond[i+1] not in \
							op_chars+whitespace:
							cond = cond[:i+1] + " " + cond[i+1:]
							redo = True
							break

			# Rebuild the conditional string
			l = []
			i = 0
			for word in self.split(cond):
				if len(word) > 2 and word[0] == "[" and word[-1] == "]":
					l.append(u"self.get('%s')" % word[1:-1])
				elif word == u"=":
					l.append(u"==")
				elif word.lower() == u"always":
					l.append(u"True")
				elif word.lower() == u"never":
					l.append(u"False")
				elif word.lower() in operators + keywords:
					if word.lower() in capitalize:
						l.append(word.capitalize())
					else:
						l.append(word.lower())
				else:
					val = self.auto_type(word)
					if type(val) == unicode:
						l.append(u"\"%s\"" % word)
					else:
						l.append(self.unistr(word))
				i += 1

			code = u" ".join(l)
			if code != u"True":
				debug.msg(u"'%s' => '%s'" % (src, code))

		# Optionally compile the conditional statement to bytecode and return
		if not bytecode:
			return code
		try:
			bytecode = compile(code, u"<conditional statement>", u"eval")
		except:
			raise osexception( \
				u"'%s' is not a valid conditional statement in sequence item '%s'" \
				% (cond, self.name))
		return bytecode

	def var_info(self):

		"""
		Give a list of dictionaries with variable descriptions

		Returns:
		A list of (variable, description) tuples
		"""

		return [ (u"time_%s" % self.name, u"[Timestamp of last item call]"), \
			(u"count_%s" % self.name, u"[Number of item calls]") ]

	def sanitize(self, s, strict=False, allow_vars=True):

		"""<DOC>
		Removes invalid characters (notably quotes) from the string.

		Arguments:
		s -- The string (unicode or str) to be sanitized.

		Keyword arguments:
		strict -- If True, all except underscores and alphanumeric characters are
				  stripped (default=False).
		allow_vars -- If True, square brackets are not sanitized, so you can use
					  variables (default=True).

		Returns:
		A sanitized unicode string

		Example:
		>>> # Prints 'Universit Aix-Marseille'
		>>> print(self.sanitize('\"Universit Aix-Marseille\"'))
		>>> # Prints 'UniversitAixMarseille'
		>>> print(self.sanitize('\"Universit Aix-Marseille\""', strict=True))
		</DOC>"""

		s = self.unistr(s)
		if strict:
			if allow_vars:
				return regexp.sanitize_strict_vars.sub(u'', s)
			return regexp.sanitize_strict_novars.sub(u'', s)
		return regexp.sanitize_loose.sub(u'', s)

	def usanitize(self, s, strict=False):

		"""
		Convert all special characters to U+XXXX notation, so that the resulting
		string can be treated as plain ASCII text.

		Arguments:
		s -- A unicode string to be santized

		Keyword arguments:
		strict -- if True, special characters are ignored rather than recoded
				  (default=False)

		Returns:
		A regular Python string with all special characters replaced by U+XXXX
		notation
		"""

		if not isinstance(s, unicode):
			raise osexception( \
				u'usanitize() expects first argument to be unicode, not "%s"' \
				% type(s))

		_s = ''
		for ch in s:
			# Encode non ASCII and slash characters
			if ord(ch) > 127 or ord(ch) == 92:
				if not strict:
					_s += 'U+%.4X' % ord(ch)
			else:
				_s += ch
		return _s.replace(os.linesep, '\n')


	def unsanitize(self, s):

		"""
		Converts the U+XXXX notation back to actual Unicode encoding

		Arguments:
		s -- a regular string to be unsanitized

		Returns:
		A unicode string with special characters
		"""

		if not isinstance(s, basestring):
			raise osexception( \
			u'unsanitize() expects first argument to be unicode or str, not "%s"' \
			% type(s))
		s = self.unistr(s)
		while True:
			m = regexp.unsanitize.search(s)
			if m == None:
				break
			s = s.replace(m.group(0), unichr(int(m.group(1), 16)), 1)
		return s

	def unistr(self, val):

		"""
		Converts a variable type into a unicode string. This function is mostly
		necessary to make sure that normal strings with special characters are
		correctly encoded into unicode, and don't result in TypeErrors.

		Arguments:
		val -- a value of any types

		Returns:
		A unicode string
		"""

		# Unicode strings cannot (and need not) be encoded again
		if isinstance(val, unicode):
			return val
		# Regular strings need to be encoded using the correct encoding
		if isinstance(val, str):
			return unicode(val, encoding=self.encoding, errors=u'replace')
		# Numeric values are encoded right away
		if isinstance(val, int) or isinstance(val, float):
			return unicode(val)
		# Some types need to be converted to unicode, but require the encoding
		# and errors parameters. Notable examples are Exceptions, which have
		# strange characters under some locales, such as French. It even appears
		# that, at least in some cases, they have to be encodeed to str first.
		# Presumably, there is a better way to do this, but for now this at
		# least gives sensible results.
		try:
			return unicode(str(val), encoding=self.encoding, errors=u'replace')
		except:
			pass
		# For other types, the unicode representation doesn't require a specific
		# encoding. This mostly applies to non-stringy things, such as integers.
		return unicode(val)

	def split(self, u):

		"""
		Splits a unicode string in the same way as shlex.split(). Unfortunately,
		shlex doesn't handle unicode properly, so this wrapper function is
		required.

		Arguments:
		u -- a unicode string

		Returns:
		A list of unicode strings, split as described here:
		http://docs.python.org/library/shlex.html#shlex.split
		"""

		import shlex
		try:
			return [chunk.decode(self.encoding) for chunk in shlex.split( \
				u.encode(self.encoding))]
		except Exception as e:
			raise osexception( \
				u'Failed to parse line "%s". Is there a closing quotation missing?' \
				% u, exception=e)

	def color_check(self, col):

		"""<DOC>
		Checks whether a string is a valid color name.

		Arguments:
		col -- The color to check.

		Exceptions:
		Raises a osexception if col is not a valid color.

		Example:
		>>> # Ok
		>>> print(self.color_check('red'))
		>>> # Ok
		>>> print(self.color_check('#FFFFFF'))
		>>> # Raises osexception
		>>> print(self.color_check('this is not a color'))
		</DOC>"""

		try:
			if type(col) == unicode:
				col = str(col)
			pygame.Color(col)
		except Exception as e:
			raise osexception( \
				u"'%s' is not a valid color. See http://www.w3schools.com/html/html_colornames.asp for an overview of valid color names" \
				% self.unistr(col), exception=e)

	def sleep(self, ms):

		"""<DOC>
		Sleeps for a specified duration.

		Arguments:
		ms -- An integer value specifying the duration in milliseconds.

		Example:
		>>> self.sleep(1000) # Sleeps one second
		</DOC>"""

		# This function is set by item.prepare()
		raise osexception( \
			u'item.sleep(): This function should be set by the canvas backend.')

	def time(self):

		"""<DOC>
		Returns the current time.

		Returns:
		A timestamp of the current time.

		Example:
		>>> print('The time is %s' % self.time())
		</DOC>"""

		# This function is set by item.prepare()
		raise osexception( \
			u"item.time(): This function should be set by the canvas backend.")

	def log(self, msg):

		"""<DOC>
		Writes a message to the log file. Note that using the log() function in #
		combination with a logger item may result in messy log files.

		msg -- A message.

		Example:
		>>> self.log('TIMESTAMP = %s' % self.time())
		</DOC>"""

		self.experiment._log.write(u'%s\n' % msg)

	def flush_log(self):

		"""<DOC>
		Forces any pending write operations to the log file to be written to #
		disk.

		Example:
		>>> self.log('TRIAL FINISHED')
		>>> self.flush_log()
		</DOC>"""

		self.experiment._log.flush()
		os.fsync(self.experiment._log)


########NEW FILE########
__FILENAME__ = keyboard_response
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import item, generic_response
import openexp.keyboard

class keyboard_response(item.item, generic_response.generic_response):

	"""An item for collection keyboard responses"""

	description = u'Collects keyboard responses'

	def __init__(self, name, experiment, string=None):

		"""
		Constructor.

		Arguments:
		name 		--	The name of the item.
		experiment 	--	The experiment.

		Keyword arguments:
		string		-- 	The item definition string. (default=None)
		"""

		self.flush = u'yes'
		self.timeout = u'infinite'
		self.auto_response = u'space'
		self.duration = u'keypress'
		self.process_feedback = True
		item.item.__init__(self, name, experiment, string)

	def prepare(self):

		"""Prepares the item."""

		item.item.prepare(self)
		generic_response.generic_response.prepare(self)
		self._flush = self.get(u'flush') == u'yes'

	def run(self):

		"""Runs the item."""

		# Record the onset of the current item
		self.set_item_onset()
		# Flush responses, to make sure that earlier responses
		# are not carried over
		if self._flush:
			self._keyboard.flush()
		self.set_sri()
		self.process_response()

	def var_info(self):
		
		"""
		Gives a list of dictionaries with variable descriptions.

		Returns:
		A list of (name, description) tuples.
		"""		

		return item.item.var_info(self) + \
			generic_response.generic_response.var_info(self)

########NEW FILE########
__FILENAME__ = logger
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import item, debug

class logger(item.item):

	"""The logger item logs variables to a plain text .csv file"""

	description = u'Logs experimental data'

	def __init__(self, name, experiment, string=None):

		"""
		Constructor.

		Arguments:
		name		--	The name of the item.
		experiment 	--	The experiment.

		Keyword arguments:
		string		--	An item definition string (default=None).
		"""

		self.logvars = []
		self.log_started = False
		self.use_quotes = u'yes'
		self.auto_log = u'yes'
		self.ignore_missing = u'yes' # This means that missing variables should
									# be ignored in the sense that they are
									# assigned the value 'NA'. They are included
									# in the logfile.
		item.item.__init__(self, name, experiment, string)

	def run(self):

		"""Log the selected variables"""

		self.set_item_onset()
		if not self.log_started:
			self.log_started = True
			# If auto logging is enabled, collect all variables
			if self.get(u'auto_log') == u'yes':
				self.logvars = []
				for logvar, val, item in self.experiment.var_list():
					if (self.has(logvar) or self.get(u'ignore_missing') == \
						u'yes') and logvar not in self.logvars:
						self.logvars.append(logvar)
						debug.msg(u'auto-logging "%s"' % logvar)
			# Sort the logvars to ascertain a consistent ordering
			self.logvars.sort()
			# Draw the first line with variables
			self.log(u','.join(self.logvars))

		l = []
		for var in self.logvars:
			try:
				val = self.unistr(self.get(var))
			except osexception as e:
				if self.get(u'ignore_missing') == u'yes':
					val = u'NA'
				else:
					raise osexception( \
						u"Logger '%s' tries to log the variable '%s', but this variable is not available. Please deselect '%s' in logger '%s' or enable the 'Use NA for variables that have not been set' option." \
						% (self.name, var, var, self.name))
			l.append(val)

		if self.get(u'use_quotes') == u'yes':
			self.log(u'"' + (u'","'.join(l)) + u'"')
		else:
			self.log(u",".join(l))

	def from_string(self, string):

		"""
		Parse the logger from a definition string

		Arguments:
		string -- definition string
		"""

		self.logvars = []
		for line in string.split(u'\n'):
			self.parse_variable(line)
			l = self.split(line)
			if len(l) > 1 and l[0] == u'log':
				self.logvars.append(l[1])

	def to_string(self):

		"""
		Encode the logger back into a definition string

		Returns:
		A definition string
		"""

		s = item.item.to_string(self, u'logger')
		for logvar in self.logvars:
			s += u'\tlog "%s"\n' % logvar
		return s


########NEW FILE########
__FILENAME__ = loop
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import item, debug
import openexp.keyboard
from random import *
from math import *

class loop(item.item):

	"""A loop item runs a single other item multiple times"""

	description = u'Repeatedly runs another item'

	def __init__(self, name, experiment, string = None):

		"""
		Constructor.

		Arguments:
		name		--	The name of the item.
		experiment 	--	The experiment.

		Keyword arguments:
		string		--	An item definition string (default=None).
		"""

		self.cycles = 1
		self.repeat = 1
		self.skip = 0
		self.offset = u'no'
		self.matrix = {}
		self.order = u'random'
		self.item = u''
		self.break_if = u''
		item.item.__init__(self, name, experiment, string)

	def from_string(self, string):

		"""
		Creates a loop from a definition in a string.

		Arguments:
		string 		--	An item definition string.
		"""

		for i in string.split(u'\n'):
			self.parse_variable(i)
			# Extract the item to run
			i = self.split(i.strip())
			if len(i) > 0:
				if i[0] == u'run' and len(i) > 1:
					self.item = i[1]
				if i[0] == u'setcycle' and len(i) > 3:
					cycle = int(i[1])
					var = i[2]
					val = i[3]
					try:
						if int(val) == float(val):
							val = int(val)
						else:
							val = float(val)
					except:
						pass
					if cycle not in self.matrix:
						self.matrix[cycle] = {}
					self.matrix[cycle][var] = val

	def run(self):

		"""Runs the loop."""

		self.set_item_onset()

		# Prepare the break if condition
		if self.break_if != u'':
			self._break_if = self.compile_cond(self.break_if)
		else:
			self._break_if = None

		# First generate a list of cycle numbers
		l = []
		# Walk through all complete repeats
		whole_repeats = int(self.get(u'repeat'))
		for j in range(whole_repeats):
			for i in range(self.get(u'cycles')):
				l.append(i)

		# Add the leftover repeats
		partial_repeats = self.get(u'repeat') - whole_repeats
		if partial_repeats > 0:
			all_cycles = range(self.get(u'cycles'))
			_sample = sample(all_cycles, int(len(all_cycles) * partial_repeats))
			for i in _sample:
				l.append(i)

		# Randomize the list if necessary
		if self.order == u'random':
			shuffle(l)

		# In sequential order, the offset and the skip are relevant
		else:
			if len(l) < self.skip:
				raise osexception( \
					u'The value of skip is too high in loop item "%s":: You cannot skip more cycles than there are.' \
					% self.name)
			if self.offset == u'yes':
				l = l[self.skip:] + l[:self.skip]
			else:
				l = l[self.skip:]

		# Create a keyboard to flush responses between cycles
		self._keyboard = openexp.keyboard.keyboard(self.experiment)

		# Make sure the item to run exists
		if self.item not in self.experiment.items:
			raise osexception( \
				u"Could not find item '%s', which is called by loop item '%s'" \
				% (self.item, self.name))

		# And run!
		_item = self.experiment.items[self.item]
		while len(l) > 0:
			cycle = l.pop(0)
			self.apply_cycle(cycle)
			if self._break_if != None and eval(self._break_if):
				break
			self.experiment.set(u'repeat_cycle', 0)
			_item.prepare()
			_item.run()
			if self.experiment.get(u'repeat_cycle'):
				debug.msg(u'repeating cycle %d' % cycle)
				l.append(cycle)
				if self.order == u'random':
					shuffle(l)

	def apply_cycle(self, cycle):

		"""
		Sets all the loop variables according to the cycle.

		Arguments:
		cycle 		--	The cycle nr.
		"""

		# If the cycle is not defined, we don't have to do anything
		if cycle not in self.matrix:
			return
		# Otherwise apply all variables from the cycle
		for var in self.matrix[cycle]:
			val = self.matrix[cycle][var]
			# By starting with an "=" sign, users can incorporate a
			# Python statement, for example to call functions from
			# the random or math module
			if type(val) == unicode and len(val) > 1 and val[0] == "=":
				try:
					val = eval(val[1:])
				except Exception as e:
					raise osexception( \
						u"Failed to evaluate '%s' in loop item '%s': %s" \
						% (val[1:], self.name, e))
			# Set it!
			self.experiment.set(var, val)

	def to_string(self):

		"""
		Creates a definition string for the loop.

		Returns:
		A definition string.
		"""

		s = item.item.to_string(self, u'loop')
		for i in self.matrix:
			for var in self.matrix[i]:
				s += u'\tsetcycle %d %s "%s"\n' % (i, var, self.matrix[i][var])
		s += u'\trun %s\n' % self.item
		return s

	def var_info(self):

		"""
		Describes the variables specific to the loop.

		Returns:
		A list of (variable name, description) tuples.
		"""

		l = item.item.var_info(self)
		var_list = {}
		for i in self.matrix:
			for var in self.matrix[i]:
				if var not in var_list:
					var_list[var] = []
				var_list[var].append(self.unistr(self.matrix[i][var]))
		for var in var_list:
			l.append( (var, u'[' + u', '.join(var_list[var]) + u']'))
		return l


########NEW FILE########
__FILENAME__ = misc
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
import os.path
import sys

version = u'2.8.2~pre3'
codename = u'Gutsy Gibson'

use_global_resources = '--no-global-resources' not in sys.argv
from libopensesame import debug

def change_working_dir():

	"""A horrifyingly ugly hack to change the working directory under Windows"""

	import libqtopensesame.qtopensesame

	if os.name == "nt":
		try:
			# Extract the part of the description containing the path
			s = unicode(libqtopensesame.qtopensesame)
			i = s.find(u'from \'') + 6
			j = s.find(u'\'>\'') - 1
			s = s[i:j]
			# Go up the tree until the path of the current script
			while not os.path.exists(os.path.join(s, u'opensesame')) and \
				not os.path.exists(os.path.join(s, u'opensesame.exe'))and \
				not os.path.exists(os.path.join(s, u'opensesamerun')) and \
				not os.path.exists(os.path.join(s, u'opensesamerun.exe')):
				s = os.path.dirname(s)
			os.chdir(s)
			if s not in sys.path:
				sys.path.append(s)
			debug.msg(s)
		except Exception as e:
			debug.msg(u'failed to change working directory: %s' % e)

def opensesamerun_options():

	"""Parse the command line options for opensesamerun"""

	import optparse
	global version, codename

	parser = optparse.OptionParser( \
		u'usage: opensesamerun [experiment] [options]', version=u'%s \'%s\'' % \
		(version, codename))

	parser.set_defaults(subject=0)
	parser.set_defaults(logfile=None)
	parser.set_defaults(debug=False)
	parser.set_defaults(fullscreen=False)
	parser.set_defaults(pylink=False)
	parser.set_defaults(width=1024)
	parser.set_defaults(height=768)
	parser.set_defaults(custom_resolution=False)
	group = optparse.OptionGroup(parser, u'Subject and log file options')
	group.add_option(u"-s", u"--subject", action=u"store", dest=u"subject", \
		help=u"Subject number")
	group.add_option(u"-l", u"--logfile", action=u"store", dest=u"logfile", \
		help=u"Logfile")
	parser.add_option_group(group)
	group = optparse.OptionGroup(parser, u"Display options")
	group.add_option(u"-f", u"--fullscreen", action=u"store_true", dest= \
		"fullscreen", help=u"Run fullscreen")
	group.add_option(u"-c", u"--custom_resolution", action=u"store_true", \
		dest=u"custom_resolution", help= \
		u"Do not use the display resolution specified in the experiment file")
	group.add_option(u"-w", u"--width", action=u"store", dest=u"width", help= \
		u"Display width")
	group.add_option(u"-e", u"--height", action=u"store", dest=u"height", \
		help=u"Display height")
	parser.add_option_group(group)
	group = optparse.OptionGroup(parser, u"Miscellaneous options")
	group.add_option(u"-d", u"--debug", action=u"store_true", dest=u"debug", \
		help=u"Print lots of debugging messages to the standard output")
	group.add_option(u"--stack", action=u"store_true", dest=u"stack", help= \
		u"Print stack information")
	parser.add_option_group(group)
	group = optparse.OptionGroup(parser, u"Miscellaneous options")
	group.add_option(u"--pylink", action=u"store_true", dest=u"pylink", help= \
		u"Load PyLink before PyGame (necessary for using the Eyelink plug-ins in non-dummy mode)")
	parser.add_option_group(group)
	options, args = parser.parse_args(sys.argv)

	# Set the default logfile based on the subject nr
	if options.logfile == None:
		options.logfile = u"subject%s.csv" % options.subject

	if len(sys.argv) > 1 and os.path.exists:
		options.experiment = sys.argv[1]
	else:
		options.experiment = u""

	try:
		options.subject = int(options.subject)
	except:
		parser.error(u"Subject (-s / --subject) should be numeric")

	try:
		options.width = int(options.width)
	except:
		parser.error(u"Width (-w / --width) should be numeric")

	try:
		options.height = int(options.height)
	except:
		parser.error(u"Height (-e / --height) should be numeric")

	return options

def opensesamerun_ready(options):

	"""
	Check if the opensesamerun options are sufficiently complete to run the
	experiment

	Arguments:
	options -- a dictionary containing the options

	Returns:
	True or False, depending on whether the options are sufficient
	"""

	# Check if the experiment exists
	if not os.path.exists(options.experiment):
		return False

	# Check if the logfile is writable
	try:
		open(options.logfile, u"w")
	except:
		return False

	# Ready to run!
	return True

def messagebox(title, msg):

	"""
	Presents a simple tk messagebox

	Arguments:
	title -- the title of the messagebox
	msg -- the message
	"""

	import Tkinter
	root = Tkinter.Tk()
	root.title(title)
	l = Tkinter.Label(root, text=msg, justify=Tkinter.LEFT, padx=8, pady=8, \
		wraplength=300)
	l.pack()
	b = Tkinter.Button(root, text=u"Ok", command=root.quit)
	b.pack(side=Tkinter.RIGHT)
	root.mainloop()

def strip_tags(s):

	"""
	Strip html tags from a string and convert breaks to newlines.

	Arguments:
	s -- the string to be stripped

	Returns:
	The stripped string
	"""

	import re
	return re.compile(r'<.*?>').sub('', unicode(s).replace("<br />", \
		"\n").replace("<br>", "\n"))

def resource(name):

	"""
	A hacky way to get a resource using the functionality from openexp

	Arguments:
	name	--	The name of the requested resource. If this is a regular string
				it is assumed to be encoded as utf-8.

	Returns:
	A Unicode string with the full path to the resource.
	"""

	global use_global_resources

	if isinstance(name, str):
		name = name.decode(u'utf-8')
	path = os.path.join(u'resources', name)
	if os.path.exists(path):
		return os.path.join(u'resources', name)
	if os.name == u'posix' and use_global_resources:
		path = u'/usr/share/opensesame/resources/%s' % name
		if os.path.exists(path):
			return path
	return None

def home_folder():

	"""
	Determines the home folder.

	Returns:
	A path to the home folder.
	"""

	import platform
	if platform.system() == u"Windows":
		home_folder = os.environ[u"APPDATA"]
	elif platform.system() == u"Darwin":
		home_folder = os.environ[u"HOME"]
	elif platform.system() == u"Linux":
		home_folder = os.environ[u"HOME"]
	else:
		home_folder = os.environ[u"HOME"]
	if isinstance(home_folder, str):
		home_folder = home_folder.decode(filesystem_encoding())
	return home_folder

def opensesame_folder():

	"""
	Determines the folder that contains the OpenSesame executable. This is only
	applicable under Windows.

	Returns:
	The OpenSesame folder or None if the os is not Windows.
	"""

	if os.name != u'nt':
		return None
	# Determines the directory name of the script or the directory name
	# of the executable after being packaged with py2exe. This has to be
	# done so the child process can find all relevant modules too.
	# See http://www.py2exe.org/index.cgi/HowToDetermineIfRunningFromExe
	#
	# There are two scenarios: Either OpenSesame is run from a frozen state,
	# in which case the OpenSesame folder is the folder containing the
	# executable, or OpenSesame is run from source, in which case we go to
	# the OpenSesame folder by going two levels up from the __file__ folder.
	import imp
	if (hasattr(sys, u'frozen') or hasattr(sys, u'importers') or \
		imp.is_frozen(u'__main__')):
		path = os.path.dirname(sys.executable).decode( \
			sys.getfilesystemencoding())
	else:
		# To get the opensesame folder, simply jump to levels up
		path = os.path.dirname(__file__).decode( \
			sys.getfilesystemencoding())
		path = os.path.normpath(os.path.join(path, u'..'))
	return path

def module_versions():

	"""
	Get version info

	Returns:
	A string with version numbers
	"""

	from PyQt4 import QtCore

	s = u"OpenSesame %s" % version
	s += u"\nPython %s" % sys.version

	# OpenCV
	try:
		import cv
		s += u'\nOpenCV is available (version is unknown)'
	except:
		s += u'\nOpenCV is not available'

	# OpenCV 2
	try:
		import cv2
		if hasattr(cv2, u'__version__'):
			ver = cv2.__version__
		else:
			ver = u'(version unknown)'
		s += u'\nOpenCV2 %s' % ver
	except:
		s += u'\nOpenCV 2 is not available'

	# QProgEdit
	try:
		import QProgEdit
		s += u'\nQProgedit %s' % QProgEdit.version
	except:
		s += u'\nQProgEdit is not available'

	# Expyriment
	try:
		_out = sys.stdout
		sys.stdout = open(os.devnull, 'w')
		import expyriment
		sys.stdout = _out
		s += u'\nExpyriment %s' % expyriment.get_version()
	except:
		s += u'\nExpyriment is not available (or version is unknown)'

	# NumPy
	try:
		import numpy
		s += u'\nNumPy %s' % numpy.version.version
	except:
		s += u'\nNumPy is not available (or version is unknown)'

	# OpenCV
	try:
		from PIL import Image
		s += u'\nPIL is available (version is unknown)'
	except:
		s += u'\nPIL is not available'

	# PsychoPy
	try:
		import psychopy
		s += u"\nPsychoPy %s" % psychopy.__version__
	except:
		s += "\nPsychoPy not available (or version is unknown)"

	# PyAudio
	try:
		import pyaudio
		s += u"\nPyAudio %s" % pyaudio.__version__
	except:
		s += u"\nPyAudio not available (or version is unknown)"

	# PyGame
	try:
		import pygame
		s += u"\nPyGame %s" % pygame.ver
	except:
		s += u"\nPyGame not available (or version is unknown)"

	# Pyglet
	try:
		import pyglet
		s += u"\nPyglet %s" % pyglet.version
	except:
		s += u"\nPyglet not available (or version is unknown)"

	# PyOpenGL
	try:
		import OpenGL
		s += u"\nPyOpenGL %s" % OpenGL.__version__
	except:
		s += u"\nPyOpenGL not available (or version is unknown)"

	# PyQt
	s += u"\nPyQt %s" % QtCore.PYQT_VERSION_STR

	# PySerial
	try:
		import serial
		s += u'\nPySerial %s' % serial.VERSION
	except:
		s += u'\nPySerial not available (or version is unknown)'

	# python-bidi
	try:
		import bidi
		s += u'\npython-bidi %s' % bidi.VERSION
	except:
		s += u'\npython-bidi is not available'


	# python-markdown
	try:
		import markdown
		s += u'\npython-markdown %s' % markdown.version
	except:
		s += u'\npython-markdown is not available'

	# SciPy
	try:
		import scipy
		s += u'\nSciPy %s' % scipy.version.version
	except:
		s += u'\nScipy is not available (or version is unknown)'

	return s

def open_url(url):

	"""
	Open a URL in an OS specific way. The URL can be a file, website, etc.

	Arguments:
	url -- a url
	"""

	debug.msg(url)
	import platform
	import subprocess
	if platform.system() == u"Linux":
		pid = subprocess.Popen([u"xdg-open", url]).pid
	elif platform.system() == u"Darwin":
		pid = subprocess.Popen(["open", url]).pid
	elif platform.system() == u"Windows":
		try:
			os.startfile(url)
		except:
			debug.msg(u"Failed to open '%s'" % url, reason=u"warning")
	else:
		debug.msg(u"Failed to open '%s'" % url, reason=u"warning")

def filesystem_encoding():

	"""
	Gets the current file system encoding. This wrapper is necessary, because
	sys.getfilesystemencoding() returns None on Android.

	Returns:
	A string with the file system encoding, such as 'utf-8' or 'mdcs'
	"""

	enc = sys.getfilesystemencoding()
	if enc == None:
		enc = u'utf-8'
	return enc

def strip_html(s):

	"""
	Strips basic HTML tags from a string.

	Arguments:
	s		--	A string to strip.

	Returns:
	A stripped string.
	"""

	s = s.replace(u'<br />', u'\n')
	for tag in [u'<i>', u'</i>', u'<b>', u'</b>']:
		s = s.replace(tag, u'')
	return s

def escape_html(s):

	"""
	Escapes a string so that it can be displayed as HTML. This is useful for
	example for tracebacks, which use <> characters.

	Arguments:
	s	--	A string to escape. We assume Unicode input. str objects may cause
			decoding errors.

	Returns:
	An escaped string.
	"""

	# Note that we need to replace the '&' first, otherwise we'll start escaping
	# the escaped characters.
	l = [(u'&', u'&amp;'), (u' ', u'&nbsp;'), (u'\t', \
		u'&nbsp;&nbsp;&nbsp;&nbsp;'), (u'<', u'&lt;'), (u'>', u'&gt;')]
	for orig, new in l:
		s = s.replace(orig, new)
	return s

########NEW FILE########
__FILENAME__ = mouse_response
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import item, generic_response
import openexp.mouse

class mouse_response(item.item, generic_response.generic_response):

	"""An item for collection keyboard responses"""	

	description = u'Collects mouse responses'

	def __init__(self, name, experiment, string=None):

		"""
		Constructor.

		Arguments:
		name 		--	The name of the item.
		experiment 	--	The experiment.

		Keyword arguments:
		string		-- 	The item definition string. (default=None)
		"""

		self.flush = u'yes'
		self.show_cursor = u'yes'
		self.timeout = u'infinite'
		self.auto_response = 1
		self.duration = u'mouseclick'
		self.process_feedback = True				

		self.resp_codes = {}
		self.resp_codes[None] = u'timeout'
		self.resp_codes[1] = u'left_button'
		self.resp_codes[2] = u'middle_button'
		self.resp_codes[3] = u'right_button'
		self.resp_codes[4] = u'scroll_up'
		self.resp_codes[5] = u'scroll_down'

		item.item.__init__(self, name, experiment, string)

	def prepare(self):

		"""Prepares the item."""

		item.item.prepare(self)
		generic_response.generic_response.prepare(self)
		self._flush = self.get(u'flush') == u'yes'
					
	def run(self):

		"""Runs the item."""

		# Record the onset of the current item
		self.set_item_onset()
		# Show cursor if necessary
		if self.show_cursor == u'yes':
			self._mouse.set_visible(True)
		# Flush responses, to make sure that earlier responses are not carried
		# over.
		if self._flush:
			self._mouse.flush()			
		self.set_sri()
		self.process_response()
		self._mouse.set_visible(False)

	def var_info(self):

		"""
		Gives a list of dictionaries with variable descriptions.

		Returns:
		A list of (name, description) tuples.
		"""

		l = item.item.var_info(self) + \
			generic_response.generic_response.var_info(self)
		l.append( (u'cursor_x', u'[Depends on response]') )
		l.append( (u'cursor_y', u'[Depends on response]') )
		return l


########NEW FILE########
__FILENAME__ = plugins
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
import sys
import json
from libopensesame import debug, misc

# Caching variables
_list = None
_folders = {}
_properties = {}

# The plug-ins can be either source or bytecode. Usually they will be source,
# but some distributions (notably the runtime for Android) will automatically
# compile everything to bytecode.
src_templates = [u'%s.py']
bytecode_templates = [u'%s.pyo', u'%s.pyc']

def plugin_folders(only_existing=True):

	"""
	Returns a list of plugin folders.

	Keywords arguments:
	only_existing	--	Specifies if only existing folders should be returned.
						(default=True)

	Returns:
	A list of folders.
	"""

	l = []

	# For all platforms, the plugins folder relative to the working directory
	# should be searched
	path = os.path.join(os.getcwdu(), u'plugins')
	if not only_existing or os.path.exists(path):
		l.append(path)

	if os.name == u'posix' and u'HOME' in os.environ:
		# Regular Linux distributions. TODO: How well does this apply to Mac OS?
		path = os.path.join(os.environ[u'HOME'], u'.opensesame', u'plugins')
		if not only_existing or os.path.exists(path):
			l.append(path)
		path = u'/usr/share/opensesame/plugins'
		if not only_existing or os.path.exists(path):
			l.append(path)

	elif os.name == u'posix' and u'HOME' not in os.environ:
		# Android can be recognized by the fact that the HOME variable is not
		# available. We can simply use the relative path `plugins`, which will
		# (always?) point to `/data/data/nl.cogsci.nl/opensesame/files/plugins`
		path = u'plugins'
		if not only_existing or os.path.exists(path):
			l.append(path)

	elif os.name == u'nt':
		# Windows
		path = os.path.join(os.environ[u'APPDATA'].decode( \
			misc.filesystem_encoding()), u'.opensesame', u'plugins')
		if not only_existing or os.path.exists(path):
			l.append(path)

	return l

def is_plugin(item_type):

	"""
	Checks if a given item type corresponds to a plugin.

	Returns:
	True if the item_type is a plugin, False otherwise.
	"""

	return plugin_folder(item_type) != None

def plugin_disabled(plugin):

	"""
	Checks if a plugin has been disabled. If the config module cannot be loaded
	the return value is False.

	Arguments:
	plugin	--	The plugin to check.

	Returns:
	True if the plugin has been disabled, False otherwise.
	"""

	from libqtopensesame.misc import config
	return plugin in config.get_config(u'disabled_plugins').split(u';')

def plugin_property(plugin, _property, default=0):

	"""
	Returns a property of a plug-in.

	Arguments:
	plugin		--	The name of the plugin.
	_property	--	The name of the property.

	Keywords arguments:
	default		--	A default property value. (default=0)

	Returns:
	The property value.
	"""

	global _properties
	if plugin in _properties and _property in _properties[plugin]:
		return _properties[plugin][_property]
	if plugin not in _properties:
		_properties[plugin] = {}
	info_txt = os.path.join(plugin_folder(plugin), u'info.txt')
	info_json = os.path.join(plugin_folder(plugin), u'info.json')
	# New-style plug-ins, using info.json
	if os.path.exists(info_json):
		try:
			_json = json.load(open(info_json))
		except:
			debug.msg(u'Failed to parse %s' % info_json)
			_json = {}
		if _property in _json:
			return _json[_property]
	# Old-style plug-ins, using info.txt
	elif os.path.exists(info_txt):
		for l in open(info_txt, u'r'):
			a = l.split(":")
			if len(a) == 2 and a[0] == _property:
				val = a[1].strip()
				try:
					val = int(val)
				finally:
					_properties[plugin][_property] = val
					return val
		_properties[plugin][_property] = default
	else:
		debug.msg( \
			u'Failed to read plug-in information (%s) from info.[txt|json]' \
			% plugin)
	return default

def plugin_category(plugin):

	"""
	Returns the category of a plugin.

	Returns:
	A category.
	"""

	return plugin_property(plugin, u'category', default=u'Miscellaneous')

def list_plugins(filter_disabled=True):

	"""
	Returns a list of plugins.

	Returns:
	A list of plugins (item_types).
	"""

	global _list
	if _list != None:
		return [plugin for plugin in _list if not (filter_disabled and \
			plugin_disabled(plugin))]

	plugins = []
	for folder in plugin_folders():
		for plugin in os.listdir(folder):
			if is_plugin(plugin):
				_plugin = plugin, plugin_property(plugin, u'priority')
				if _plugin not in plugins:
					plugins.append(_plugin)

	# Sort (inversely) by priority
	plugins.sort(key=lambda p: -p[1])
	_list = [plugin[0] for plugin in plugins]
	return [plugin for plugin in _list if not (filter_disabled and \
		plugin_disabled(plugin))]

def plugin_folder(plugin):

	"""
	Returns the folder of a plugin

	Arguments:
	plugin -- the name of the plugin

	Returns:
	The folder of the plugin
	"""

	global _folders

	if plugin in _folders:
		return _folders[plugin]
	for folder in plugin_folders():
		plugin = str(plugin)
		for tmpl in src_templates + bytecode_templates:
			if os.path.exists(os.path.join(folder, plugin, tmpl % plugin)):
				f = os.path.join(folder, plugin)
				_folders[plugin] = f
				return f
	return None

def plugin_icon_large(plugin):

	"""
	Return the large icon for a plugin

	Arguments:
	plugin -- the name of the plugin

	Returns:
	The full path to an icon
	"""

	return os.path.join(plugin_folder(plugin), u'%s_large.png' % plugin)

def plugin_icon_small(plugin):

	"""
	Return the small icon for a plugin

	Arguments:
	plugin -- the name of the plugin

	Returns:
	The full path to an icon
	"""

	return os.path.join(plugin_folder(plugin), u'%s.png' % plugin)

def import_plugin(plugin):

	"""
	Imports plugin module

	Arguments:
	plugin -- the name of the plugin
	"""

	import imp
	plugin = str(plugin)
	for tmpl in src_templates:
		if os.path.exists(os.path.join(plugin_folder(plugin), tmpl % plugin)):
			path = os.path.join(plugin_folder(plugin), tmpl % plugin).encode( \
				misc.filesystem_encoding())
			return imp.load_source(plugin, path)
	for tmpl in bytecode_templates:
		if os.path.exists(os.path.join(plugin_folder(plugin), tmpl % plugin)):
			path = os.path.join(plugin_folder(plugin), tmpl % plugin).encode( \
				misc.filesystem_encoding())
			return imp.load_compiled(plugin, path)

def load_plugin(plugin, item_name, experiment, string, prefix=u''):

	"""
	Returns an instance of the plugin.

	Arguments:
	plugin		--	The name of the plugin.
	item_name	--	Yhe name of the item (plugin instance).
	experiment	--	The experiment object.
	string		--	A definition string.

	Keywords arguments:
	prefix		--	A class prefix to allow switching between [plugin] and
					qt[plugin]. (default=u'')

	Returns:
	An item (plugin instance).
	"""

	item_module = import_plugin(plugin)
	item_class = getattr(item_module, prefix+plugin)
	item = item_class(item_name, experiment, string)
	return item

def load_cls(path, cls, mod, pkg=None):

	"""
	Dynamically loads a module from a path and return a class from the module

	Arguments:
	path		--	A folder or file name. If a filename is specified, the
					file's directory will be used as path.
	cls			--	The class name.
	mod			--	The name of a module, which corresponds to the name of the
					source file without the `.py` extension.
	pkg			--	The module's package. This is effectively a subfolder that
					is added to the path. (default=None)

	Returns:
	A Python class.
	"""

	mod = load_mod(path, mod, pkg)
	return getattr(mod, cls)

def load_mod(path, mod, pkg=None):

	"""
	Dynamically loads a module from a path.

	Arguments:
	path		--	A folder or file name. If a filename is specified, the
					file's directory will be used as path.
	mod			--	The name of a module, which corresponds to the name of the
					source file without the `.py` extension.
	pkg			--	The module's package. This is effectively a subfolder that
					is added to the path. (default=None)

	Returns:
	A Python module.
	"""

	import imp
	if isinstance(path, str):
		path = path.decode(sys.getfilesystemencoding())
	if not os.path.isdir(path):
		path = os.path.dirname(path)
	if pkg != None:
		path = os.path.join(path, pkg)
	path = os.path.join(path, mod+u'.py')
	debug.msg(u'loading module from %s' % path)
	return imp.load_source(mod, path.encode(sys.getfilesystemencoding()))

########NEW FILE########
__FILENAME__ = regexp
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import re

# Strict no-variables is used to remove all characters except
# alphanumeric ones
sanitize_strict_novars = re.compile(r'[^\w]')		

# Strict with variables is used to remove all characters except
# alphanumeric ones and [] signs that indicate variables
sanitize_strict_vars = re.compile(r'[^\w\[\]]')		
# Loose is used to remove double-quotes, slashes, and newlines
sanitize_loose = re.compile(r'[\n\"\\]')		

# Unsanitization is used to replace U+XXXX unicode notation
unsanitize = re.compile( \
	r'U\+([A-F0-9]{4})')

# Used to find variables in a string
find_variable = re.compile(r'\[\w+\]')

# Used to convert arbitrary strings into valid Python variable names
sanitize_var_name = re.compile('\W|^(?=\d)')

########NEW FILE########
__FILENAME__ = sampler
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import item, generic_response, debug
import openexp.sampler

class sampler(item.item, generic_response.generic_response):

	"""Sound playback item"""

	description = u'Plays a sound file in .wav or .ogg format'

	def __init__(self, name, experiment, string = None):

		"""
		Constructor.

		Arguments:
		name 		--	The name of the item.
		experiment 	--	The experiment.

		Keyword arguments:
		string		-- 	The item definition string. (default=None)
		"""

		self.sample = u''
		self.pan = 0
		self.pitch = 1
		self.fade_in = 0
		self.volume = 1.0
		self.stop_after = 0
		self.duration = u'sound'
		self.block = False
		item.item.__init__(self, name, experiment, string)

	def prepare_duration_sound(self):

		"""Sets the duration function for 'sound' duration."""

		self.block = True
		self._duration_func = self.dummy

	def prepare(self):

		"""Prepares for playback."""

		item.item.prepare(self)
		if self.sample.strip() == u'':
			raise osexception( \
				u'No sample has been specified in sampler "%s"' % self.name)
		sample = self.experiment.get_file(self.eval_text(self.sample))
		if debug.enabled:
			self.sampler = openexp.sampler.sampler(self.experiment, sample)
		else:
			try:
				self.sampler = openexp.sampler.sampler(self.experiment, sample)
			except Exception as e:
				raise osexception( \
					u'Failed to load sample in sampler "%s": %s' % (self.name, \
					e))

		pan = self.get(u'pan')
		if pan == -20:
			pan = u'left'
		elif pan == 20:
			pan = u'right'

		self.sampler.pan(pan)
		self.sampler.volume(self.get(u'volume'))
		self.sampler.pitch(self.get(u'pitch'))
		self.sampler.fade_in(self.get(u'fade_in'))
		self.sampler.stop_after(self.get(u'stop_after'))
		generic_response.generic_response.prepare(self)

	def run(self):

		"""Plays the sample."""

		self.set_item_onset()
		self.set_sri()
		self.sampler.play(self.block)
		self.process_response()

	def var_info(self):

		"""
		Give a list of dictionaries with variable descriptions

		Returns:
		A list of (name, description) tuples
		"""

		return item.item.var_info(self) + \
			generic_response.generic_response.var_info(self)

########NEW FILE########
__FILENAME__ = sequence
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import item
import openexp.keyboard

class sequence(item.item):

	"""The sequence item"""

	description = u'Runs a number of items in sequence'

	def __init__(self, name, experiment, string=None):

		"""
		Constructor.

		Arguments:
		name 		--	The name of the item.
		experiment 	--	The experiment.

		Keyword arguments:
		string		-- 	The item definition string. (default=None)
		"""

		self.items = []
		self.flush_keyboard = u'yes'
		item.item.__init__(self, name, experiment, string)

	def run(self):

		"""Runs the sequence."""

		self.set_item_onset()
		# Optionally flush the responses to catch escape presses
		if self._keyboard != None:
			self._keyboard.flush()
		for item, cond in self._items:
			if eval(cond):
				self.experiment.items[item].run()

	def parse_run(self, i):

		"""
		Parses a run line from the definition script.

		Arguments:
		i 		-- 	A list of words, corresponding to a single script line.

		Returns:
		An (item_name, conditional) tuple.
		"""

		name = i[1]
		cond = u'always'
		if len(i) > 2:
			cond = i[2]
		return i[1], cond

	def from_string(self, string):

		"""
		Parses a definition string.

		Arguments:
		string 	--	A definition string.
		"""

		for i in string.split(u'\n'):
			self.parse_variable(i)
			i = self.split(i.strip())
			if len(i) > 0:
				if i[0] == u'run' and len(i) > 1:
					self.items.append(self.parse_run(i))

	def prepare(self):

		"""Prepares the sequence."""

		item.item.prepare(self)
		if self.get(u'flush_keyboard') == u'yes':
			# Create a keyboard to flush responses at the start of the run phase
			self._keyboard = openexp.keyboard.keyboard(self.experiment)
		else:
			self._keyboard = None
		self._items = []
		for _item, cond in self.items:
			if _item not in self.experiment.items:
				raise osexception( \
					u"Could not find item '%s', which is called by sequence item '%s'" \
					% (_item, self.name))
			self.experiment.items[_item].prepare()
			self._items.append( (_item, self.compile_cond(cond)) )

	def to_string(self):

		"""
		Encodes the sequence as a definition string.

		Returns:
		A definition string.
		"""

		s = item.item.to_string(self, self.item_type)
		for _item, cond in self.items:
			s += u'\trun %s "%s"\n' % (_item, cond)
		return s


########NEW FILE########
__FILENAME__ = sketchpad
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import item, generic_response, debug
import openexp.canvas

class sketchpad(item.item, generic_response.generic_response):

	"""
	Sketchpad item

	TODO
	The term 'item' is used for sketchpad 'elements'. This is confusing, because
	'item' is also used for the higher level items, such as sketchpads. This
	terminology should be changed. Furthermore, the sketchpad elements should
	ideally be handled by separate classes, rather than the chaotic ad-hoc
	implementation here and in the libqtopensesame.widgets.sketchpad_widget.
	"""

	description = u'Displays stimuli'

	def __init__(self, name, experiment, string=None):

		"""
		Constructor.

		Arguments:
		name 		--	The name of the item.
		experiment 	--	The experiment.

		Keyword arguments:
		string		-- 	The item definition string. (default=None)
		"""

		self.duration = "keypress"
		self.start_response_interval = "no"
		self.items = []
		self.numeric_attrs = "x", "y", "x1", "y1", "r", "w", "h", "scale", \
			"font_size", "penwidth", "arrow_size", "center", "fill", "orient", \
			"freq", "phase", "stdev", "size"
		item.item.__init__(self, name, experiment, string)

	def unfix_coordinates(self, item):

		"""
		Interprets the coordinates based on whether 'coordinates' is set to
		absolute or relative. Raw coordinates -> Raw/ relative

		Arguments:
		item -- a sketchpad element

		Returns:
		The 'unfixed' sketchpad element
		"""

		item = item.copy()
		for var in item:
			if type(item[var]) in (int, float):
				if var in ["x", "x1", "x2"]:
					item[var] -= self.get("width") / 2
				if var in ["y", "y1", "y2"]:
					item[var] -= self.get("height") / 2
		return item

	def fix_coordinates(self, item):

		"""
		Interprets the coordinates based on whether 'coordinates' is set to
		absolute or relative. Raw/ relative -> Raw coordinates

		Arguments:
		item -- a sketchpad element

		Returns:
		The 'fixed' sketchpad element
		"""

		item = item.copy()
		for var in item:
			if type(item[var]) in (int, float):
				if var in ["x", "x1", "x2"]:
					item[var] += self.get("width") / 2
				if var in ["y", "y1", "y2"]:
					item[var] += self.get("height") / 2
		return item

	def check_type(self, item):

		"""
		Checks whether the attributes of an element are valid

		Arguments:
		item -- a sketchpad element

		Exceptions:
		Throws a osexception if an attribute which should be numeric is not
		"""

		for attr in item:
			if attr in self.numeric_attrs and type(item[attr]) == str:
				raise osexception( \
					"'%s' should be numeric, not '%s', in sketchpad '%s'" % \
					(attr, item[attr], self.name))

	def prepare(self):

		"""
		Draw the canvas, so we can show it without delay in the run phase

		Returns:
		True on success, False on failure
		"""

		item.item.prepare(self)

		# Build the canvas. Do not catch errors in debug mode
		if debug.enabled:
			self.canvas = openexp.canvas.canvas(self.experiment, \
				self.get("background"), self.get("foreground"), auto_prepare=False)
		else:
			try:
				self.canvas = openexp.canvas.canvas(self.experiment, \
					self.get("background"), self.get("foreground"), auto_prepare= \
					False)
			except ValueError as e:
				raise osexception( \
					"Failed to create a canvas. This could be because the foreground or background color is not valid.")

		# Walk through all items and only shown the if the show-if criterion is
		# met (if any)
		for _item in self.items:
			if eval(self.compile_cond(_item["show_if"])):

				# Replace all variables by the actual values. In text, floats should
				# be rounded, but not in other variables
				tmp = {}
				for var in _item:
					if var == "text":
						tmp[var] = self.eval_text(_item[var], round_float=True)
					else:
						tmp[var] = self.eval_text(_item[var])

				# Check if the types are proper
				self.check_type(tmp)

				# Translate the coordinates to absolute (if necessary)
				_item = self.fix_coordinates(tmp)

				# Set the foreground color and the penwidth
				try:
					self.canvas.set_fgcolor(_item["color"])
				except ValueError as e:
					raise osexception( \
						"'%s' is not a valid color in sketchpad '%s'" % \
						(_item["color"], self.name))
				self.canvas.set_penwidth(_item["penwidth"])

				# Draw the items
				if _item["type"] == "rect":
					self.canvas.rect(_item["x"], _item["y"], _item["w"], \
						_item["h"], _item["fill"] == 1)

				elif _item["type"] == "circle":
					self.canvas.ellipse(_item["x"]-0.5*_item["r"], \
						_item["y"]-0.5*_item["r"], _item["r"], _item["r"], \
						_item["fill"] == 1)

				elif _item["type"] == "ellipse":
					self.canvas.ellipse(_item["x"], _item["y"], _item["w"], \
						_item["h"], _item["fill"] == 1)

				elif _item["type"] == "fixdot":
					self.canvas.fixdot(_item["x"], _item["y"])

				elif _item["type"] == "arrow":
					self.canvas.arrow(_item["x1"], _item["y1"], _item["x2"], \
						_item["y2"], _item["arrow_size"])

				elif _item["type"] == "line":
					self.canvas.line(_item["x1"], _item["y1"], _item["x2"], \
						_item["y2"])

				elif _item["type"] == "textline":
					self.canvas.set_font(_item["font_family"], \
						_item["font_size"], _item['font_italic'] == 'yes', \
						_item['font_bold'] == 'yes')
					self.canvas.text(_item["text"], _item["center"] == 1, \
						_item["x"], _item["y"], html=_item["html"]==u"yes")

				elif _item["type"] == "image":
					try:
						self.canvas.image(self.experiment.get_file( \
							_item["file"]), _item["center"] == 1, _item["x"], \
							_item["y"], _item["scale"])
					except osexception as e:

						# Drawing an image can fail because the image format is
						# not recognized or because the image file cannot be
						# found
						if self.experiment.file_in_pool(_item["file"]):
							raise osexception( \
								"'%s' is not a supported image format in sketchpad '%s'" \
								% (_item["file"], self.name))
						else:
							raise osexception( \
								"'%s' could not be found in sketchpad '%s'. Make sure that the file is present in the file pool (or specify the full location of the image in the script editor)." \
								% (_item["file"], self.name))

				elif _item["type"] == "gabor":
					self.canvas.gabor(_item["x"], _item["y"], _item["orient"], \
						_item["freq"], _item["env"], _item["size"], \
						_item["stdev"], _item["phase"], _item["color1"], \
						_item["color2"], _item["bgmode"])
				elif _item["type"] == "noise":
					self.canvas.noise_patch(_item["x"], _item["y"], \
						_item["env"], _item["size"], _item["stdev"], \
						_item["color1"], _item["color2"], _item["bgmode"])

		if self.start_response_interval == "yes":
			self._reset = True
		else:
			self._reset = False

		self.canvas.prepare()
		generic_response.generic_response.prepare(self)

		return True

	def run(self):

		"""
		Show the canvas

		Returns:
		True on success, False on failure
		"""

		self.set_item_onset(self.canvas.show())
		self.set_sri(self._reset)
		self.process_response()
		return True

	def parse_item(self, l, line):

		"""
		A generic parse attribute, which reads the definition of an element

		Arguments:
		l -- a list of words
		line -- the definition line

		Returns:
		A sketchpad element
		"""

		item = {}

		item["penwidth"] = 1
		item["color"] = self.get("foreground", _eval=False)
		item["type"] = u"undefined"
		item["fill"] = 0
		item["arrow_size"] = 20
		item["center"] = 1
		item["scale"] = 1.0
		item["font_family"] = self.get('font_family', _eval=False)
		item["font_size"] = self.get('font_size', _eval=False)
		item["font_italic"] = self.get('font_italic', _eval=False)
		item["font_bold"] = self.get('font_bold', _eval=False)

		item["orient"] = 0
		item["freq"] = 0.1
		item["env"] = u"gaussian"
		item["size"] = 96
		item["stdev"] = 12
		item["phase"] = 0
		item["color1"] = u"white"
		item["color2"] = u"black"
		item["bgmode"] = u"avg"
		item["html"] = u"yes"

		item["show_if"] = u"always"

		for i in l:

			j = i.find("=")
			if j != -1:

				# UGLY HACK: if the string appears to be plain text,
				# rather than a keyword, for example something like
				# 'accuracy = [acc]%', do not parse it as a keyword-
				# value pair. The string needs to occur only once in
				# the full line, both quoted and unquoted.
				q = "\"" + i + "\""
				if line.count(q) == 1 and line.count(i) == 1:
					debug.msg("'%s' does not appear to be a keyword-value pair in string '%s'" \
						% (i, line))
				else:
					var = i[:j]
					val = i[j+1:]
					item[var] = self.auto_type(val)
		return item

	def parse_rect_ellipse(self, line, l, item, item_type):

		"""
		Parse a rectangle

		Arguments:
		line -- a definition line
		l -- a definition list
		item -- sketchpad element to finish
		item_type -- type of the current item

		Returns:
		A finished sketchpad element
		"""

		if len(l) < 6:
			raise osexception("Invalid draw %s command '%s', expecting 'draw %s [x] [y] [w] [h]'" \
				% (item_type, line, item_type))
		item["type"] = item_type
		item["x"] = self.auto_type(l[2])
		item["y"] = self.auto_type(l[3])
		item["w"] = self.auto_type(l[4])
		item["h"] = self.auto_type(l[5])
		return item

	def parse_circle(self, line, l, item):

		"""
		Parse a circle

		Arguments:
		line -- a definition line
		l -- a definition list
		item -- sketchpad element to finish

		Returns:
		A finished sketchpad element
		"""

		if len(l) < 5:
			raise osexception("Invalid draw circle command '%s', expecting 'draw circle [x] [y] [r]'" \
				% line)

		item["type"] = u"circle"
		item["x"] = self.auto_type(l[2])
		item["y"] = self.auto_type(l[3])
		item["r"] = self.auto_type(l[4])

		return item

	def parse_fixdot(self, line, l, item):

		"""
		Parse fixation dot

		Arguments:
		line -- a definition line
		l -- a definition list
		item -- sketchpad element to finish

		Returns:
		A finished sketchpad element
		"""

		item["type"] = u"fixdot"
		if len(l) > 3:
			item["x"] = self.auto_type(l[2])
			item["y"] = self.auto_type(l[3])
		else:
			item["x"] = self.get("width") / 2
			item["y"] = self.get("height") / 2
		return item

	def parse_line_arrow(self, line, l, item, item_type):

		"""
		Parse a line or arrow

		Arguments:
		line -- a definition line
		l -- a definition list
		item -- sketchpad element to finish
		item_type -- type of the current item

		Returns:
		A finished sketchpad element
		"""

		if len(l) < 6:
			raise osexception("Invalid draw %s command '%s', expecting 'draw %s [x1] [y1] [x2] [y2]'" \
				% (item_type, line, item_type))

		item["type"] = item_type

		item["x1"] = self.auto_type(l[2])
		item["y1"] = self.auto_type(l[3])
		item["x2"] = self.auto_type(l[4])
		item["y2"] = self.auto_type(l[5])

		return item

	def parse_textline(self, line, l, item):

		"""
		Parse text

		Arguments:
		line -- a definition line
		l -- a definition list
		item -- sketchpad element to finish

		Returns:
		A finished sketchpad element
		"""

		if len(l) < 3:
			raise osexception("Invalid draw textline command '%s', expecting 'draw textline [x] [y] [text]' or 'draw textline [text]'" \
				% line)
		item["type"] = u"textline"
		try:
			item["x"] = self.auto_type(l[2])
			item["y"] = self.auto_type(l[3])
			item["text"] = l[4]
		except:
			item["x"] = self.get("width") / 2
			item["y"] = self.get("height") / 2
			item["text"] = l[2]
		return item

	def parse_image(self, line, l, item):

		"""
		Parse image

		Arguments:
		line -- a definition line
		l -- a definition list
		item -- sketchpad element to finish

		Returns:
		A finished sketchpad element
		"""

		if len(l) < 3:
			raise osexception("Invalid draw image command '%s', expecting 'draw image [x] [y] [file]' or 'draw textline [file]'" \
				% line)
		item["type"] = u"image"
		try:
			item["x"] = self.auto_type(l[2])
			item["y"] = self.auto_type(l[3])
			item["file"] = l[4]
		except:
			item["x"] = self.get("width") / 2
			item["y"] = self.get("height") / 2
			item["file"] = l[2]
		return item

	def parse_gabor(self, line, l, item):

		"""
		Parse Gabor patch

		Arguments:
		line -- a definition line
		l -- a definition list
		item -- sketchpad element to finish

		Returns:
		A finished sketchpad element
		"""

		if len(l) < 4:
			raise osexception("Invalid draw image command '%s', expecting 'draw gabor [x] [y] [orient] [freq]'" \
				% line)
		item["type"] = u"gabor"
		item["x"] = self.auto_type(l[2])
		item["y"] = self.auto_type(l[3])
		return item

	def parse_noise(self, line, l, item):

		"""
		Parse noise patch

		Arguments:
		line -- a definition line
		l -- a definition list
		item -- sketchpad element to finish

		Returns:
		A finished sketchpad element
		"""

		if len(l) < 4:
			raise osexception("Invalid draw image command '%s', expecting 'draw noise [x] [y]'" \
				% line)
		item["type"] = u"noise"
		item["x"] = self.auto_type(l[2])
		item["y"] = self.auto_type(l[3])
		return item

	def from_string(self, string):

		"""
		Read a sketchpad from string

		Arguments:
		string -- the unicode string containing the sketchpad definition
		"""

		for line in string.split(u'\n'):
			if not self.parse_variable(line):
				l = self.split(line)
				if len(l) > 0:
					if l[0] == u'draw':
						if len(l) == 1:
							raise osexception( \
								"Incomplete draw command '%s'" % line)
						item = self.parse_item(l, line)
						if l[1] in ("circle",):
							item = self.parse_circle(line, l, item)
						elif l[1] in ("rectangle", "rect"):
							item = self.parse_rect_ellipse(line, l, item, \
								"rect")
						elif l[1] in ("fixdot", "fixation"):
							item = self.parse_fixdot(line, l, item)
						elif l[1] in ("ellipse", "oval"):
							item = self.parse_rect_ellipse(line, l, item, \
								"ellipse")
						elif l[1] in ("arrow",):
							item = self.parse_line_arrow(line, l, item, "arrow")
						elif l[1] in ("line",):
							item = self.parse_line_arrow(line, l, item, "line")
						elif l[1] in ("textline",):
							item = self.parse_textline(line, l, item)
						elif l[1] in ("image", "bitmap"):
							item = self.parse_image(line, l, item)
						elif l[1] in ("gabor"):
							item = self.parse_gabor(line, l, item)
						elif l[1] in ("noise"):
							item = self.parse_noise(line, l, item)
						else:
							raise osexception( \
								"Unknown draw command '%s'" % line)
						self.items.append(item)
					else:
						raise osexception("Unknown command '%s'" \
							% line)

	def relativize(self, item, compensation, varlist):

		"""
		Reset coordinates so that 0, 0 is the center
		"""

		for var in varlist:
			if var in item:
				item[var] -= compensation
		return item

	def item_to_string(self, _item):

		"""
		Encode an element as string

		Arguments:
		_item -- the sketchpad element

		Returns:
		A definition unicode string
		"""

		if _item["type"] == "rect":
			return u"draw rect %s %s %s %s fill=%s penwidth=%s color=%s show_if=\"%s\"" \
				% (_item["x"], _item["y"], _item["w"], _item["h"], \
				_item["fill"], _item["penwidth"], _item["color"], \
				_item["show_if"])

		elif _item["type"] == "circle":
			return u"draw circle %s %s %s fill=%s penwidth=%s color=%s show_if=\"%s\"" \
				% (_item["x"], _item["y"], _item["r"], _item["fill"], \
				_item["penwidth"], _item["color"], _item["show_if"])

		elif _item["type"] == "ellipse":
			return u"draw ellipse %s %s %s %s fill=%s penwidth=%s color=%s show_if=\"%s\"" \
				% (_item["x"], _item["y"], _item["w"], _item["h"], \
				_item["fill"], _item["penwidth"], _item["color"], \
				_item["show_if"])

		elif _item["type"] == "fixdot":
			return u"draw fixdot %s %s color=%s show_if=\"%s\"" % (_item["x"], \
				_item["y"], _item["color"], _item["show_if"])

		elif _item["type"] == "arrow":
			return u"draw arrow %s %s %s %s penwidth=%s color=%s arrow_size=%s show_if=\"%s\"" \
				% (_item["x1"], _item["y1"], _item["x2"], _item["y2"], \
				_item["penwidth"], _item["color"], _item["arrow_size"], \
				_item["show_if"])

		elif _item["type"] == "line":
			return u"draw line %s %s %s %s penwidth=%s color=%s show_if=\"%s\"" \
				% (_item["x1"], _item["y1"], _item["x2"], _item["y2"], \
				_item["penwidth"], _item["color"], _item["show_if"])

		elif _item["type"] == "textline":
			return u"draw textline %s %s \"%s\" center=%s color=%s font_family=\"%s\" font_size=%s font_italic=%s font_bold=%s show_if=\"%s\" html=\"%s\"" \
				% (_item["x"], _item["y"], \
				self.experiment.sanitize(_item["text"]), _item["center"], \
				_item["color"], _item["font_family"], _item["font_size"], \
				_item["font_italic"], _item["font_bold"], _item["show_if"], \
				_item["html"])

		elif _item["type"] == "image":
			return u"draw image %s %s \"%s\" scale=%s center=%s show_if=\"%s\"" \
				% (_item["x"], _item["y"], _item["file"], _item["scale"], \
				_item["center"], _item["show_if"])

		elif _item["type"] == "gabor":
			return u"draw gabor %(x)s %(y)s orient=%(orient)s freq=%(freq)s env=%(env)s size=%(size)s stdev=%(stdev)s phase=%(phase)s color1=%(color1)s color2=%(color2)s bgmode=%(bgmode)s show_if=\"%(show_if)s\"" \
				% _item

		elif _item["type"] == "noise":
			return u"draw noise %(x)s %(y)s env=%(env)s size=%(size)s stdev=%(stdev)s color1=%(color1)s color2=%(color2)s bgmode=%(bgmode)s show_if=\"%(show_if)s\"" \
				% _item

	def to_string(self):

		"""
		Encode sketchpad as string

		Returns:
		A definition string
		"""

		s = item.item.to_string(self, self.item_type)
		for _item in self.items:
			s += u"\t%s\n" % self.item_to_string(_item)
		return s

	def var_info(self):

		"""
		Return a list of dictionaries with variable descriptions

		Returns:
		A list of (name, description) tuples
		"""

		l = item.item.var_info(self)
		if self.get("duration", _eval=False) in ["keypress", "mouseclick"]:
			l += generic_response.generic_response.var_info(self)
		return l

########NEW FILE########
__FILENAME__ = synth
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import sampler, item, generic_response
import openexp.synth

class synth(sampler.sampler, item.item):

	"""Plays a synthesized sound"""

	description = u'A basic sound synthesizer'

	def __init__(self, name, experiment, string = None):
	
		"""
		Constructor.

		Arguments:
		name 		--	The name of the item.
		experiment 	--	The experiment.

		Keyword arguments:
		string		-- 	The item definition string. (default=None)
		"""

		self.item_type = u'synth'
		self.freq = 440
		self.length = 100
		self.osc = u'sine'
		self.pan = 0		
		self.attack = 0
		self.decay = 5
		self.volume = 1.0
		self.duration = u'sound'
		self.block = False
		item.item.__init__(self, name, experiment, string)	
		
	def prepare(self):
	
		"""Prepares for playback."""

		item.item.prepare(self)
		try:
			self.sampler = openexp.synth.synth(self.experiment, \
				self.get(u'osc'), self.get(u'freq'), self.get(u'length'), \
				self.get(u'attack'), self.get(u'decay'))
		except Exception as e:
			raise osexception( \
				u"Failed to generate sound in synth '%s': %s" % (self.name, e))
		pan = self.get(u'pan')
		if pan == -20:
			pan = u'left'
		elif pan == 20:
			pan = u'right'
		self.sampler.pan(pan)
		self.sampler.volume(self.get(u'volume'))
		generic_response.generic_response.prepare(self)

########NEW FILE########
__FILENAME__ = type_check
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception

def float_list(l, desc, min_len=None, max_len=None):
	
	"""
	Converts a variable to a list of floats if possible.
	
	Arguments:
	a		--	The variable to convert.
	desc	--	A description to clarify the osexception.
	
	Keyword arguments:
	min_len	--	The minimum length of the list. (default=None)
	max_len	--	The maximum length of the list. (default=None)
	
	Raises:
	A osexception if the variable could not be converted.
	
	Returns:
	A list of floats.
	"""
		
	try:
		l = list(l)
	except:
		raise osexception( \
			u'Expecting a list or compatible type not "%s" for "%s"' % (l, \
				desc))
	if min_len != None and len(l) < min_len:
		raise osexception( \
			u'Expecting a list of at least %d items for "%s"' % (min_len, desc))
	if max_len != None and len(l) > max_len:
		raise osexception( \
			u'Expecting a list of at most %d items for "%s"' % (max_len, desc))
	return l
########NEW FILE########
__FILENAME__ = button
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from label import label

class button(label):

	"""A simple text button"""

	def __init__(self, form, text=u'button', frame=True, center=True, var=None):
	
		"""<DOC>
		Constructor
		
		Arguments:
		form -- The parent form.
		
		Keyword arguments:
		text -- Button text (default='button').
		frame -- Indicates whether a frame should be drawn around the widget
				 (default=False).
		center -- Indicates whether the text should be centered (default=False).
		var -- The name of the experimental variable that should be used to log
			   the widget status (default=None).
		</DOC>"""	
	
		label.__init__(self, form, text, frame=frame, center=center)
		self.type = u'button'
		self.var = var
		self.set_var(False)
				
	def on_mouse_click(self, pos):
	
		"""<DOC>
		Is called whenever the user clicks on the widget. Returns the button #
		text.
		
		Arguments:
		pos -- An (x, y) tuple.
		</DOC>"""		
	
		self.set_var(True)
		return self.text

########NEW FILE########
__FILENAME__ = checkbox
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from libqtopensesame.misc import _
from libopensesame.exceptions import osexception
from button import button

class checkbox(button):

	"""A checkbox widget"""

	def __init__(self, form, text=u'checkbox', frame=False, group=None, checked=False, click_accepts=False, var=None):
	
		"""<DOC>
		Constructor.
		
		Arguments:
		form -- The parent form.
				
		Keyword arguments:
		text -- Checkbox text (default=u'checkbox').
		frame -- Indicates whether a frame should be drawn around the widget #
				 (default=False).
		group -- If a group is specified, checking one checkbox from the group #
				 will uncheck all other checkboxes in that group. Checkboxes #
				 that are part of a group cannot be unchecked, except by clicking #
				 on another checkbox in the group. The group keyword also #
				 affects how variables are stored (see the var keyword). #
				 (default=None).
		checked -- The checked state of the checkbox (default=False).
		click_accepts -- Indicates whether a click press should accept and #
					     close the form (default=False).
		var -- The name of the experimental variable that should be used to log #
			   the widget status. This variable will contain a semi-colon #
			   separated list of the text of all checked checkboxes in the #
			   same group, or 'no' if no checkbox in the group is checked. For #
			   the purpose of the variable, all checkboxes that are not part #
			   of a group are placed in the same group. For more information #
			   about the use of response variables in forms, see the form #
			   documentation page. (default=None).
		</DOC>"""	
		
		if isinstance(checked, basestring):
			checked = checked == u'yes'
		if isinstance(click_accepts, basestring):
			click_accepts = click_accepts == u'yes'
		button.__init__(self, form, text, frame=frame, center=False)
		self.type = u'checkbox'
		self.group = group		
		self.box_size = 16
		self.box_pad = self.x_pad
		self.x_pad += self.x_pad + self.box_size
		self.var = var
		self.click_accepts = click_accepts
		self.set_checked(checked)
				
	def on_mouse_click(self, pos):
	
		"""<DOC>
		Is called whenever the user clicks on the widget. Toggles the state of #
		the checkbox.
		
		Arguments:
		pos		--	An (x, y) tuple.
		</DOC>"""
	
		if self.group != None:
			# If the checkbox is part of a group than checking it will uncheck
			# all other checkboxes in the group, and check the current one
			for widget in self.form.widgets:
				if widget != None and widget.type == u'checkbox' and \
					widget.group == self.group and self.group != None:
					widget.set_checked(False)
			self.set_checked(True)
		else:
			# If the checkbox is not part of a group then checking it will
			# toggle its check status
			self.set_checked(not self.checked)
								
		if self.click_accepts:
			return self.text
				
	def render(self):
	
		"""<DOC>
		Draws the widget.
		</DOC>"""	
	
		x, y, w, h = self.rect
		self.form.theme_engine.box(x+self.box_pad, y+self.y_pad, \
			checked=self.checked)
		self.draw_text(self.text)
		
	def set_checked(self, checked=True):
	
		"""<DOC>
		Sets the checked status of the checkbox.
		
		Keyword arguments:
		checked	--	The checked status. (default=True)
		</DOC>"""
		
		self.checked = checked
		self.set_var(checked)
				
	def set_var(self, val, var=None):
	
		"""<DOC>
		Sets an experimental variable.
		
		Arguments:
		val		--	A value.
		
		Keyword arguments:
		var		--	A variable name, or None to use widget default.
					(default=None)
		</DOC>"""
		
		if var == None:
			var = self.var
		if var == None:
			return
		
		# Set the response variable
		l_val = []
				
		# When this function is called via the constructor, the checkbox is not
		# yet part of the form. Therefore, we need to add it explicitly to the
		# widget list.
		widget_list = self.form.widgets[:]
		if self not in self.form.widgets:
			widget_list += [self]
		
		for widget in widget_list:
			if widget != None and widget.type == u'checkbox' and \
				widget.var == self.var:
				if widget.group != self.group and self.group != None:
					raise osexception(_( \
						u'All checkbox widgets without a group or within the same group should have the same variable.'))
				if widget.checked or widget.checked == u'yes':
					l_val.append(self.form.experiment.unistr(widget.text))
		val = u';'.join(l_val)
		if val == u'':
			val = u'no'
		self.form.experiment.set(var, val)		


########NEW FILE########
__FILENAME__ = form
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import type_check
from libopensesame.exceptions import osexception
from openexp.canvas import canvas
from openexp.mouse import mouse

class form:

	"""Implements a single form that acts as a container for widgets"""

	def __init__(self, experiment, cols=2, rows=2, spacing=10, margins=(100, 100, 100, 100), theme=u'gray', item=None):

		"""<DOC>
		Constructor

		Arguments:
		experiment -- An OpenSesame experiment.

		Keyword arguments:
		cols -- The number of columns (as int) or a list that specifies the #
				number and relative size of the columns. For example, '[1,2,1]' #
				will create 3 columns where the middle one is twice as large as #
				the outer ones (default=2).
		rows -- Analogous to 'cols' (default=2).
		spacing -- The amount of empty space between the widgets (default=10).
		margins -- The amount of empty space around the form. This is specified #
				   as a list, like so [top-margin, right-margin, bottom-margin, #
				   left-margin] (default=[100, 100, 100, 100]).
		theme -- The theme for the widgets (default='gray').
		item -- The item of which the form is part (default=None).
		</DOC>"""

		# Normalize the column and row sizes so that they add up to 1
		if type(cols) == int:
			self.cols = [1./cols]*cols
		else:
			cols = type_check.float_list(cols, u'form columns', min_len=1)
			self.cols = [float(c)/sum(cols) for c in cols]
		if type(rows) == int:
			self.rows = [1./rows]*rows
		else:
			rows = type_check.float_list(rows, u'form rows', min_len=1)
			self.rows = [float(r)/sum(rows) for r in rows]

		self.experiment = experiment
		if item != None:
			self.item = item
		else:
			self.item = experiment
		self.width = experiment.get(u'width')
		self.height = experiment.get(u'height')
		self.spacing = spacing
		self.margins = type_check.float_list(margins, u'form margins', \
			min_len=4, max_len=4)
		n_cells = len(self.cols)*len(self.rows)
		self.widgets = [None]*n_cells
		self.span = [(1,1)]*n_cells
		self.canvas = canvas(self.experiment, auto_prepare=False, fgcolor= \
			self.item.get(u'foreground'), bgcolor=self.item.get( \
			u'background'))

		if theme == u'gray':
			from themes.gray import gray
			self.theme_engine = gray(self)
		else:
			from themes.plain import plain
			self.theme_engine = plain(self)

	def _exec(self, focus_widget=None):

		"""<DOC>
		Executes the form.

		Keyword arguments:
		focus_widget -- A widget that is in the form and should receive a #
						virtual mouse click when the form is opened. This allows #
						you to activate a text_input right away, for example, so #
						that the user doesn't have to click on it anymore.

		Returns:
		Gives the return value of the form, which depends on how the user has #
		interacted with the widgets. For example, if the user has pressed a #
		button, the button text will be returned.
		</DOC>"""

		i = 0
		self.mouse = mouse(self.experiment)
		if focus_widget != None:
			self.render()
			resp = focus_widget.on_mouse_click(None)
			if resp != None:
				return
		while True:
			self.render()
			button, xy, time = self.mouse.get_click(visible=True)
			pos = self.xy_to_index(xy)
			if pos != None:
				w = self.widgets[pos]
				if w != None:
					resp = self.widgets[pos].on_mouse_click(xy)
					if resp != None:
						return resp

	def cell_index(self, pos):

		"""<DOC>
		Converts a position to a cell index. A cell index corresponds to the #
		number of the cell in the form, from left-to-right, top-to-bottom.

		Arguments:
		pos -- A position, which can be an index (int) or a column, row tuple.

		Returns:
		A cell index
		</DOC>"""

		if type(pos) == int:
			return pos
		if type(pos) in (tuple, list) and len(pos) == 2:
			return pos[1]*len(self.cols)+pos[0]
		raise osexception(u'%s is an invalid position in the form' % pos)

	def validate_geometry(self):

		"""
		Checks whether the form has a valid geometry.

		Exceptions:
		osexception		--	When the geometry is invalid.
		"""

		for index1 in range(len(self.widgets)):
			if self.widgets[index1] == None:
				continue
			l = self.get_cell(index1)
			colspan, rowspan = self.span[index1]
			for col in range(l[0], l[0]+colspan):
				for row in range(l[1], l[1]+rowspan):
					index2 = self.cell_index((col, row))
					if index1 == index2:
						continue
					if len(self.widgets) <= index2:
						raise osexception( \
							u'The widget at position (%d, %s) falls outside of your form' \
							% (l[0], l[1]))
					if self.widgets[index2] != None:
						raise osexception( \
							u'The widget at position (%d, %d) overlaps with another widget' \
							% (l[0], l[1]))

	def get_cell(self, index):

		"""
		Returns the position of a widget

		Arguments:
		index -- the index of the widget

		Returns:
		A (column, row, column_span, row_span) tuple
		"""

		index = self.cell_index(index)
		col = index % len(self.cols)
		row = index / len(self.cols)
		colspan, rowspan = self.span[index]
		return col, row, colspan, rowspan

	def get_rect(self, index):

		"""
		Returns the boundary area for a given cell

		Arguments:
		index -- a cell index

		Returns:
		A (left, top, width, height) tuple
		"""

		col = index % len(self.cols)
		row = index / len(self.cols)
		colspan, rowspan = self.span[index]
		effective_width = self.width-self.margins[1]-self.margins[3]
		effective_height = self.height-self.margins[0]-self.margins[2]
		x1 = effective_width*sum(self.cols[:col])+self.spacing
		y1 = effective_height*sum(self.rows[:row])+self.spacing
		x2 = effective_width*sum(self.cols[:col+colspan])-self.spacing
		y2 = effective_height*sum(self.rows[:row+rowspan])-self.spacing
		w = x2-x1
		h = y2-y1
		if w <= 0 or h <= 0:
			raise osexception( \
				u'There is not enough space to show some form widgets. Please modify the form geometry!')
		return x1+self.margins[3], y1+self.margins[0], w, h

	def render(self):

		"""<DOC>
		Draws the form and all the widgets in it.
		</DOC>"""

		self.validate_geometry()
		self.canvas.clear()
		for widget in self.widgets:
			if widget != None:
				widget.render()
		self.canvas.show()

	def set_widget(self, widget, pos, colspan=1, rowspan=1):

		"""<DOC>
		Adds a widget to the form.

		Arguments:
		widget -- The widget to add.
		pos -- The position to add the widget, which can be an index or a
			   (column, row) tuple.

		Keyword arguments:
		colspan -- The number of columns that the widget should span (default=1).
		rowspan -- The number of rows that the widget should span (default=1).
		</DOC>"""

		index = self.cell_index(pos)
		if index >= len(self.widgets):
			raise osexception( \
				u'Widget position (%s, %s) is outside of the form' % pos)
		if type(colspan) != int or colspan < 1 or colspan > len(self.cols):
			raise osexception( \
				u'Column span %s is invalid (i.e. too large, too small, or not a number)' \
				% colspan)
		if type(rowspan) != int or rowspan < 1 or rowspan > len(self.rows):
			raise osexception( \
				u'Row span %s is invalid (i.e. too large, too small, or not a number)' \
				% rowspan)
		self.widgets[index] = widget
		self.span[index] = colspan, rowspan
		widget.set_rect(self.get_rect(index))

	def xy_to_index(self, xy):

		"""<DOC>
		Converts a coordinate in pixels to a cell index. This allows you to #
		determine on which widget a user has clicked.

		Arguments:
		xy -- An (x,y) tuple.

		Returns:
		A cell index.
		</DOC>"""

		for index in range(len(self.widgets)):
			x, y, w, h = self.get_rect(index)
			if x <= xy[0] and x+w >= xy[0] and y <= xy[1] and y+h >= xy[1]:
				return index
		return None

########NEW FILE########
__FILENAME__ = image
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from widget import widget
try: # Try both import statements
	from PIL import Image
except:
	import Image
from libopensesame.exceptions import osexception
import os

class image(widget):

	"""A simple non-interactive image widget"""

	def __init__(self, form, path=None, adjust=True, frame=False):
	
		"""<DOC>
		Constructor.
		
		Arguments:
		form -- The parent form.
		
		Keyword arguments:
		path -- The full path to the image (default=None).
		adjust -- Indicates whether the image should be scaled according to the #
				  size of the widget (default=True).
		frame -- Indicates whether a frame should be drawn around the widget #
				 (default=False).
		</DOC>"""		
	
		if type(adjust) != bool:
			adjust = adjust == u'yes'			
		if type(frame) != bool:
			frame = frame == u'yes'						
	
		widget.__init__(self, form)
		self.adjust = adjust
		self.frame = frame
		self.path = path
		self.type = u'image'
				
	def render(self):
	
		"""<DOC>
		Draws the widget.
		</DOC>"""	
	
		if not os.path.exists(self.path):
			raise osexception( \
				u'No valid path has been specified in image widget')
		
		x, y, w, h = self.rect
		x += w/2
		y += h/2
		self.form.canvas.image(self.path, x=x, y=y, scale=self.scale, \
			center=True)
		if self.frame:
			self.draw_frame(self.rect)

	def set_rect(self, rect):
	
		"""<DOC>
		Sets the widget geometry.
		
		Arguments:
		rect -- A (left, top, width, height) tuple.
		</DOC>"""	
	
		self.rect = rect	
		if self.adjust:
			x, y, w, h = self.rect
			try:
				img = Image.open(self.path)
				img_w, img_h = img.size
			except:				
				try:
					import pygame
					img = pygame.image.load(self.path)
				except:
					raise osexception( \
						u'Failed to open image "%s". Perhaps the file is not an image, or the image format is not supported.' \
						% self.path)
				img_w, img_h = img.get_width()			
			scale_x = 1.*w/img_w
			scale_y = 1.*h/img_h
			self.scale = min(scale_x, scale_y)
		else:
			self.scale = 1
		
		
		
		

########NEW FILE########
__FILENAME__ = image_button
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from image import image

class image_button(image):

	"""A simple image button"""

	def __init__(self, form, path=None, adjust=True, frame=False, image_id=None, var=None):
	
		"""<DOC>
		Constructor.
		
		Arguments:
		form -- The parent form.
		
		Keyword arguments:
		path -- The full path to the image (default=None).				
		adjust -- Indicates whether the image should be scaled according to the #
				  size of the widget (default=True).
		frame -- Indicates whether a frame should be drawn around the widget #
				 (default=False).
		image_id -- An id to identify the image when it is clicked. If None, the #
					path to the image is used as id (default=None).
		var -- The name of the experimental variable that should be used to log #
			   the widget status (default=None).					
		</DOC>"""		
	
		image.__init__(self, form, path, adjust=adjust, frame=frame)
		if image_id == None:
			self.image_id = path
		else:
			self.image_id = image_id
		self.type = u'image_button'
		self.var = var
		self.set_var(False)				
				
	def on_mouse_click(self, pos):
	
		"""<DOC>
		Is called whenever the user clicks on the widget. Returns the image_id #
		or the path to the image if no image_id has been specified.
		
		Arguments:
		pos -- An (x, y) tuple.
		</DOC>"""	
	
		self.set_var(True)
		return self.image_id


########NEW FILE########
__FILENAME__ = label
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

import textwrap
from widget import widget

class label(widget):

	"""A simple non-interactive text label"""

	def __init__(self, form, text=u'label', frame=False, center=True):

		"""<DOC>
		Constructor.
		
		Arguments:
		form -- The parent form.

		Keyword arguments:
		text -- A string of text (default='label').
		frame -- Indicates whether a frame should be drawn around the widget #
				 (default=False).
		center -- Indicates whether the text should be centered (default=True).
		</DOC>"""

		if type(frame) != bool:
			frame = frame == u'yes'
		if type(center) != bool:
			center = center == u'yes'

		widget.__init__(self, form)
		self.type = u'label'
		self.text = text
		self.frame = frame
		self.center = center
		self.x_pad = 8
		self.y_pad = 8
		self.tab_str = u'    ' # Replace tab characters by four spaces

	def draw_text(self, text, html=True):

		"""<DOC>
		Draws text in the widget.
		
		Arguments:
		text -- The text to draw.
		
		Keyword arguments:
		html -- Indicates whether HTML should be parsed (default=True).
		</DOC>"""

		if self.form.item != None:
			text = self.form.item.eval_text(text)
		else:
			text = self.form.experiment.eval_text(text)
		text = self.form.experiment.unistr(text).replace(u'\t', self.tab_str)
		x, y, w, h = self.rect
		if self.center:
			x += w/2
			y += h/2
		else:
			x += self.x_pad
			y += self.y_pad
		w -= 2*self.x_pad
		self.form.canvas.text(text, center=self.center, x=x, y=y, max_width=w, \
			html=html)

	def render(self):

		"""<DOC>
		Draws the widget.
		</DOC>"""	

		if self.frame:
			self.draw_frame(self.rect)
		self.draw_text(self.text)


########NEW FILE########
__FILENAME__ = rating_scale
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import debug
from widget import widget

class rating_scale(widget):

	"""A simple rating scale/ Likert widget"""

	def __init__(self, form, nodes=5, click_accepts=False, orientation=u'horizontal', var=None, default=None):
	
		"""<DOC>
		Constructor.
		
		Arguments:
		form			--	The parent form.
		
		Keyword arguments:
		nodes			--	The number of nodes or a list of node identifiers (e.g., #
							['yes', 'no', 'maybe']. If a list is passed the rating scale #
							will have labels, otherwise it will just have boxes #
							(default=5).
		click_accepts	--	Indicates whether the form should close when a value #
							is selected (default=False).
		orientation		--	'horizontal' indicates a horizontally oriented
							rating scale, 'vertical' indicates a vertically
							oriented rating scale. (default=u'horizontal')
		var				--	The name of the experimental variable that should be used to log #
							the widget status. The value that is logged is the number of #
							the node that was selected, with the first node being 0. If no #
							nodes were selected, the value is 'None'. For more information #
							about the use of response variables in forms, see the form #
							documentation page.(default=None).
		default			--	The node that is selected by default, or None to #
							select no node. The value corresponds to the node #
							number, where 0 is the first node. (default=None)
		</DOC>"""	
		
		if isinstance(click_accepts, basestring):
			click_accepts = click_accepts == u'yes'
		
		widget.__init__(self, form)
		self.type = u'rating_scale'
		self.box_size = 16
		self.click_accepts = click_accepts
		self.pos_list = []
		self.var = var
		self.orientation = orientation
		if type(nodes) == int:
			self.nodes = [u'']*nodes
		elif isinstance(nodes, basestring):
			self.nodes = nodes.split(u';')
		else:
			self.nodes = nodes
		self.set_value(default)
			
	def on_mouse_click(self, pos):
	
		"""<DOC>
		Is called whenever the user clicks on the widget. Selects the correct #
		value from the scale and optionally closes the form.
		
		Arguments:
		pos -- An (x, y) tuple.
		</DOC>"""		
	
	
		x, y = pos
		i = 0
		for _x, _y in self.pos_list:
			if x >= _x and x <= _x+self.box_size and y >= _y and y <= \
				_y+self.box_size:
				self.set_value(i)
				if self.click_accepts:
					return i	
				break
			i += 1
		
	def render(self):
	
		"""<DOC>
		Draws the widget.
		</DOC>"""	

		x, y, w, h = self.rect
		cx = x+w/2
		cy = y+h/2		
		_h = self.form.theme_engine.box_size()		
		if self.orientation == u'horizontal':
			# Some ugly maths, but basically it evenly spaces the checkboxes and
			# draws a frame around it.
			dx = (1*w-3*_h)/(len(self.nodes)-1)
			self.form.theme_engine.frame(x, cy-.5*_h, w, 2*_h, style=u'light')
			_x = x+_h
			i = 0
			for node in self.nodes:
				self.form.theme_engine.box(_x, cy, checked=(self.value == i))
				text_height = self.form.canvas.text_size(node)[1]
				self.form.canvas.text(node, center=True, x=_x+self.box_size/2, \
					y=cy-text_height)
				self.pos_list.append( (_x, cy) )
				_x += dx
				i += 1
		elif self.orientation == u'vertical':
			dy = (1*h-3*_h)/(len(self.nodes)-1)
			self.form.theme_engine.frame(cx-.5*_h, y, 2*_h, h, style=u'light')
			_y = y+_h
			i = 0
			for node in self.nodes:
				self.form.theme_engine.box(cx, _y, checked=(self.value == i))
				text_width = self.form.canvas.text_size(node)[0]
				self.form.canvas.text(node, center=True, x=cx-text_width,
					y=_y+self.box_size/2)
				self.pos_list.append( (cx, _y) )
				_y += dy
				i += 1
		else:
			raise osexception( \
				u'rating_scale orientation must be "horizontal" or "vertical", not "%s"' % \
				self.orientation)
			
	def set_value(self, val):
	
		"""<DOC>
		Sets the rating scale value.
		
		Arguments:
		val -- The value.
		</DOC>"""
		
		if val != None and (val >= len(self.nodes) or val < 0):
			raise osexception( \
				u'Trying to select a non-existing node (%s). Did you specify an incorrect default value?' \
				% val)
		self.value = val
		self.set_var(val)

########NEW FILE########
__FILENAME__ = text_input
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from label import label
from openexp.keyboard import keyboard

class text_input(label):

	"""A multiline text input widget"""

	def __init__(self, form, text=u'', frame=True, center=False, stub=u'Type here ...', return_accepts=False, var=None):
	
		"""<DOC>
		Constructor.
		
		Arguments:
		form -- The parent form.
		
		Keyword arguments:
		text -- The text to start with (default=u'').
		frame -- Indicates whether a frame should be drawn around the widget
				 (default=False).
		center -- Indicates whether the text should be centered (default=False).
		stub -- A text string that should be shown whenever the user has not
				entered any text (default=u'Type here ...').
		return_accepts -- Indicates whether a return press should accept and
						  close the form (default=False).
		var -- The name of the experimental variable that should be used to log
			   the widget status (default=None).
		</DOC>"""
		
		if type(return_accepts) != bool:
			return_accepts = return_accepts == u'yes'
	
		label.__init__(self, form, text, frame=frame, center=center)
		self.type = u'text_input'		
		self.stub = self.form.experiment.unistr(stub)
		self.prompt = u'_'
		self.return_accepts = return_accepts
		self.var = var
		self.text = self.form.experiment.unistr(text)
		self.set_var(text)
		
	def render(self):
	
		"""<DOC>
		Draws the widget.
		</DOC>"""	

		if self.frame:
			if self.focus:
				self.draw_frame(self.rect, style=u'active')
			else:
				self.draw_frame(self.rect, style=u'light')
		if self.text == '' and not self.focus:
			self.draw_text(self.stub, html=False)	
		elif self.focus:
			self.draw_text(self.text+self.prompt, html=False)	
		else:
			self.draw_text(self.text, html=False)	
				
	def on_mouse_click(self, pos):
	
		"""<DOC>
		Is called whenever the user clicks on the widget. Activates the text #
		input for typing text.
		
		Arguments:
		pos -- An (x, y) tuple.
		</DOC>"""	
		
		self.focus = True
		my_keyboard = keyboard(self.form.experiment)
		while True:		
			self.form.render()		
			resp, time = my_keyboard.get_key()
			try:
				o = ord(resp)
			except:
				o = None
			if resp == u'space':			
				self.text += ' '
			elif resp == u'backspace' or o == 8:
				self.text = self.text[:-1]
			elif resp == u'tab':
				self.focus = False
				return None
			elif resp == u'return':
				if self.return_accepts:
					return self.text
				else:
					self.focus = False
					return None
			elif len(resp) == 1:
				self.text += resp
			self.set_var(self.text)
						

########NEW FILE########
__FILENAME__ = gray
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
from plain import plain

class gray(plain):

	def __init__(self, form):
	
		plain.__init__(self, form)
		self.box_checked_image = self.form.experiment.resource(os.path.join( \
			'widgets', 'gray', 'box-checked.png'))
		self.box_unchecked_image = self.form.experiment.resource(os.path.join( \
			'widgets', 'gray', 'box-unchecked.png'))			

	def box(self, x, y, checked=False):
			
		if checked:
			self.form.canvas.image(self.box_checked_image, center=False, x=x, \
				y=y)
		else:
			self.form.canvas.image(self.box_unchecked_image, center=False, \
				x=x, y=y)

	def frame(self, x, y, w, h, style='normal'):
	
		if style in ('normal', 'active'):
			self.form.canvas.rect(x, y, w, h, color='#2e3436')
		self.form.canvas.line(x+1, y+1, x+w-2, y+1, color='#babdb6')
		self.form.canvas.line(x+1, y+1, x+1, y+h-2, color='#babdb6')								
		self.form.canvas.line(x+1, y+h-2, x+w-2, y+h-2, color='#555753')
		self.form.canvas.line(x+w-2, y+1, x+w-2, y+h-2, color='#555753')		
		if style == 'normal':
			self.form.canvas.rect(x+2, y+2, w-4, h-4, color='#888a85', fill=True)
		

########NEW FILE########
__FILENAME__ = plain
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

class plain:

	def __init__(self, form):
	
		self.form = form
		
	def box(self, x, y, checked=False):
	
		self.form.canvas.rect(x, y, 16, 16, fill=checked)
		
	def box_size(self):
	
		return 16
		
	def frame(self, x, y, w, h, style='normal'):
	
		self.form.canvas.rect(x, y, w, h)
			

########NEW FILE########
__FILENAME__ = widget
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from form import form as _form
from libopensesame.exceptions import osexception

class widget:

	"""The base class for all other widgets"""

	def __init__(self, form):

		"""<DOC>
		Constructor.

		Arguments:
		form -- The parent form.
		</DOC>"""

		self.type = u'widget'
		self.form = form
		self.rect = None
		self.focus = False
		self.var = None

		# Check if the form parameter is valid
		if not isinstance(form, _form):
			raise osexception( \
				u'The first parameter passed to the constructor of a form widget should be a form, not "%s"' \
				% form)

	def draw_frame(self, rect=None, style=u'normal'):

		"""<DOC>
		Draws a simple frame around the widget.

		Keyword arguments:
		rect -- A (left, top, width, height) tuple for the frame geometry or
				None to use the widget geometry (default=None).
		style -- 'normal', 'active', 'light' (default='normal').
		</DOC>"""

		x, y, w, h = rect
		self.form.theme_engine.frame(x, y, w, h, style=style)

	def on_mouse_click(self, pos):

		"""<DOC>
		Is called whenever the user clicks on the widget

		Arguments:
		pos -- An (x, y) tuple
		</DOC>"""

		pass

	def render(self):

		"""<DOC>
		Draws the widget.
		</DOC>"""

		if self.focus:
			self.draw_frame(self.rect, focus=True)
		else:
			self.draw_frame(self.rect)

	def set_rect(self, rect):

		"""<DOC>
		Sets the widget geometry.

		Arguments:
		rect -- A (left, top, width, height) tuple.
		</DOC>"""

		self.rect = rect

	def set_var(self, val, var=None):

		"""<DOC>
		Sets an experimental variable.

		Arguments:
		val -- A value.

		Keyword arguments:
		var -- A variable name, or None to use widget default (default=None).
		</DOC>"""

		if var == None:
			var = self.var
		if var == None:
			return
		self.form.experiment.set(var, val)

########NEW FILE########
__FILENAME__ = plugin_action
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

__author__ = "Sebastiaan Mathot"
__license__ = "GPLv3"

from PyQt4 import QtGui
from libopensesame import plugins

class plugin_action(QtGui.QAction):

	"""Menu action for a plugin"""

	def __init__(self, main_window, menu, plugin):

		"""
		Constructor

		Arguments:
		main_window -- the main window
		menu -- the menu into which the action should be inserted
		plugin -- the name of the plugin
		"""

		self.main_window = main_window
		icon = QtGui.QIcon(plugins.plugin_icon_large(plugin))
		self.plugin = plugin
		QtGui.QAction.__init__(self, icon, "Add %s" % plugin, menu)
		self.triggered.connect(self.add_plugin)

	def add_plugin(self, dummy = None):

		"""
		Start a drag to add the plugin to the experiment

		Keyword arguments:
		dummy -- a dummy argument passed by the signal handler (default=None)
		"""

		self.main_window.drag_item(self.plugin)

########NEW FILE########
__FILENAME__ = recent_action
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

__author__ = "Sebastiaan Mathot"
__license__ = "GPLv3"

from PyQt4 import QtGui
import os.path

class recent_action(QtGui.QAction):

	"""Menu action for a recently opened file"""

	def __init__(self, path, main_window, menu):

		"""
		Constructor

		Arguments:
		path -- path to the recent file
		main_window -- the main window
		menu -- the menu into which the action should be inserted
		"""

		QtGui.QAction.__init__(self, os.path.basename(path), menu)
		self.main_window = main_window
		self.triggered.connect(self.open_file)
		self.path = path

	def open_file(self, dummy = None):

		"""
		Open the file

		Keyword arguments:
		dummy -- a dummy argument passed by the signal handler (default=None)
		"""

		self.main_window.open_file(path=self.path)

########NEW FILE########
__FILENAME__ = new_loop_sequence_dialog
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt4 import QtCore, QtGui
from libqtopensesame.ui import new_loop_sequence_ui

class new_loop_sequence_dialog(QtGui.QDialog):

	"""Dialog to select an item-to-run for a new sequence or loop item"""

	def __init__(self, parent, experiment, item_type, _parent):

		"""
		Constructor
		
		Arguments:
		parent -- the parent QWidget
		experiment -- the experiment object
		item_type -- 'sequence' or 'loop'
		_parent -- the parent item, i.e. the item above the current item in the
				   experiment hierarchy		
		"""	
	
		QtGui.QDialog.__init__(self, parent)
		self.experiment = experiment
		self._parent = _parent
		self.ui = new_loop_sequence_ui.Ui_new_loop_sequence_dialog()
		self.ui.setupUi(self)
		self.experiment.main_window.theme.apply_theme(self)		
		self.ui.label_icon.setPixmap( \
			self.experiment.main_window.theme.qpixmap(item_type))
		self.action = "cancel"		
		QtCore.QObject.connect(self.ui.button_new, QtCore.SIGNAL("clicked()"), \
			self.new_item)
		QtCore.QObject.connect(self.ui.button_select, \
			QtCore.SIGNAL("clicked()"), self.select_item)
		
		if item_type == "loop":
			s = "A loop needs another item to run, usually a sequence. You can create a new item or select an existing item to add to the loop."
			select = "sequence"
		else:
			s = "A sequence needs at least one other item to run, such as a sketchpad. You can create a new item or select an existing item to add to the sequence."
			select = "sketchpad"
			
		self.ui.label_explanation.setText(s)
		
		self.experiment.item_type_combobox(True, True, self.ui.combobox_new, \
			select)
		
		# The parents list is excluded from the list of possible children, but
		# this list if empty if there are no parents or the parent is the main
		# experiment sequence
		if self._parent == None or _parent not in self.experiment.items:
			parents = []
		else:
			parents = self.experiment.items[_parent].parents()
		self.experiment.item_combobox(None, parents, self.ui.combobox_select)		
					
	def new_item(self):
	
		self.action = "new"
		self.item_type = unicode(self.ui.combobox_new.currentText())		
		self.accept()

	def select_item(self):
	
		self.action = "select"
		self.item_name = unicode(self.ui.combobox_select.currentText())		
		self.accept()


########NEW FILE########
__FILENAME__ = replace_dialog
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt4 import QtGui, QtCore
from libqtopensesame.ui import replace_dialog_ui
from libqtopensesame.misc import config, _

class replace_dialog(QtGui.QDialog):

	"""A search/ replace dialog"""

	def __init__(self, parent=None):

		"""
		Constructor

		Keywords arguments:
		parent -- the parent QWidget
		"""

		QtGui.QDialog.__init__(self, parent)
		self.edit = parent.edit
		self.ui = replace_dialog_ui.Ui_replace_dialog()
		self.ui.setupUi(self)
		parent.experiment.main_window.theme.apply_theme(self)
		self.adjustSize()
		self.ui.edit_search.setText(parent.search.text())
		self.ui.button_search.clicked.connect(self.search)
		self.ui.button_replace.clicked.connect(self.replace)
		self.ui.button_replace_all.clicked.connect(self.replace_all)

	def search(self):

		"""
		Select text matching the search term

		Returns:
		True if the string was found, False otherwise
		"""

		return self.parent().perform_search(term=self.ui.edit_search.text())

	def replace(self):

		"""Replace the current selection with the replace term"""

		self.parent().edit.replace(self.ui.edit_replace.text())

	def replace_all(self):

		"""
		Iteratively replace all occurences of the search term with the
		replace term
		"""

		if self.ui.edit_search.text().toLower() in \
			self.ui.edit_replace.text().toLower():
			QtGui.QMessageBox.information(self, _("Oops!"), \
				_("The replacement string cannot contain the search string."))
			return
		i = 0
		while self.search():
			i += 1
			self.replace()
		QtGui.QMessageBox.information(self, _("Replace all"), \
			_("%d occurence(s) have been replaced" % i))
########NEW FILE########
__FILENAME__ = sketchpad_dialog
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt4 import QtCore, QtGui
from libqtopensesame.widgets import sketchpad_widget

class sketchpad_dialog(QtGui.QDialog):

	"""This dialog is the pop-out version of the sketchpad_widget"""

	def __init__(self, parent, sketchpad):
	
		"""
		Constructor
		
		Arguments:
		parent -- parent QWidget
		
		Keyword arguments:
		sketchpad -- sketchpad item
		"""
	
		QtGui.QDialog.__init__(self, parent, \
			QtCore.Qt.WindowMinMaxButtonsHint | QtCore.Qt.WindowCloseButtonHint)
		self.sketchpad = sketchpad
		self.tools_widget = sketchpad_widget.sketchpad_widget(self.sketchpad, \
			parent=self, embed=False)							
		self.close_button = QtGui.QPushButton( \
			self.sketchpad.experiment.icon("close"), "Close")
		self.close_button.setIconSize(QtCore.QSize(16,16))
		QtCore.QObject.connect(self.close_button, QtCore.SIGNAL("clicked()"), \
			self.accept)			
		self.hbox = QtGui.QHBoxLayout()
		self.hbox.addStretch()
		self.hbox.addWidget(self.close_button)
		self.hbox.setContentsMargins(0, 0, 0, 0)		
		self.hbox_widget = QtGui.QWidget()
		self.hbox_widget.setLayout(self.hbox)		
		self.vbox = QtGui.QVBoxLayout()
		self.vbox.addWidget(self.tools_widget)
		self.vbox.addWidget(self.hbox_widget)					
		self.setLayout(self.vbox)

########NEW FILE########
__FILENAME__ = experiment
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import debug
import libopensesame.experiment
import libopensesame.plugins
from PyQt4 import QtCore, QtGui
import os.path

class experiment(libopensesame.experiment.experiment):

	"""Contains various GUI controls for the experiment"""

	def __init__(self, main_window, name, string=None, pool_folder=None):

		"""
		Constructor.

		Arguments:
		main_window	--	The main window object.
		name		--	The name of the experiment.

		Keyword arguments:
		string		--	A definition string for the experiment or None to
						start with an empty experiment. (default=None)
		pool_folder	--	A path to be used for the file pool or None to use a
						system-specific temporary folder. (default=None)
		"""

		self.main_window = main_window
		self.ui = self.main_window.ui
		self.unused_items = []
		self.core_items = u"loop", u"sequence", u"sketchpad", u"feedback", \
			u"sampler", u"synth", u"keyboard_response", u"mouse_response", \
			u"logger", u"inline_script"
		libopensesame.experiment.experiment.__init__(self, name, string, \
			pool_folder)

	def help(self, name):

		"""
		Returns the full path to a help file.

		Arguments:
		name	--	The name of the help file. (e.g., "sequence.html")

		Returns:
		The full path to the help file or an empty string if the help file was
		not found.
		"""

		# Check in the subfolder of the current path, which is
		# where the helpfile will be on Windows
		path = os.path.join(u'help', name)
		if os.path.exists(path):
			return path
		# Check in the shared folders
		if os.name == u'posix':
			path = u'/usr/share/opensesame/help/%s' % name
			if os.path.exists(path):
				return path
		# Fall back to the resource folder if the help
		# file is not found
		try:
			return self.resource(name)
		except:
			pass
		# Return an empty string if not found
		return u''

	def module_container(self):

		"""
		Specifies the module that is used to get items from.

		Returns:
		u'libqtopensesame.items'
		"""

		return u'libqtopensesame.items'

	def item_prefix(self):

		"""
		Specifies a prefix that should be added to classes for plugins.

		Returns:
		u'qt'
		"""

		return u'qt'

	def build_item_tree(self, toplevel=None, items=[]):

		"""
		Constructs an item tree.

		Keyword arguments:
		toplevel	--	The toplevel widget. (default=None)
		items		--	A list of items that have already been added, to
						prevent recursion. (default=[])

		Returns:
		An updated list of items that have been added.
		"""

		self.ui.itemtree.clear()
		items = []

		# First build the tree of the experiment
		widget = QtGui.QTreeWidgetItem(self.ui.itemtree)
		widget.setText(0, self.title)
		widget.setIcon(0, self.icon("os-experiment"))
		widget.setToolTip(0, "General options")
		widget.name = "__general__"
		self.ui.itemtree.insertTopLevelItem(0, widget)

		if self.start in self.items:
			items.append(self.items[self.start])
			self.items[self.start].build_item_tree(widget, items)
		widget.setExpanded(True)

		# Next build a tree with left over items
		self.unused_widget = QtGui.QTreeWidgetItem(self.ui.itemtree)
		self.unused_widget.setText(0, "Unused items")
		self.unused_widget.setIcon(0, self.icon("unused"))
		self.unused_widget.name = "__unused__"
		self.unused_widget.setToolTip(0, "Unused items")
		self.unused_widget.setToolTip(1, "Unused items")
		self.ui.itemtree.insertTopLevelItem(1, widget)

		self.unused_items = []
		c = 0
		for i in self.items:
			if self.items[i] not in items:
				self.unused_items.append(i)
				self.items[i].build_item_tree(self.unused_widget, items)
				c += 1
		self.unused_widget.setExpanded(False)

		font = QtGui.QFont()
		font.setPointSize(8)
		font.setItalic(True)

		if c > 0:
			self.unused_widget.setText(1, "contains items")
		else:
			self.unused_widget.setText(1, "empty")
		self.unused_widget.setFont(1, font)

		return items

	def rename(self, from_name, to_name):

		"""
		Renames an item.

		Arguments:
		from_name	--	The old name.
		to_name		--	The new name.
		"""

		to_name = self.sanitize(to_name, True)
		debug.msg("from '%s' to '%s'" % (from_name, to_name))

		# Make sure the entry point is updated when renamed
		if self.get("start") == from_name:
			self.set("start", to_name)

		# This only changes the name in the object, it doesn't update the GUI
		# in case a tab is opened
		for item in self.items:
			self.items[item].rename(from_name, to_name)
		new_items = {}
		for item in self.items:
			if item == from_name:
				new_items[to_name] = self.items[item]
			else:
				new_items[item] = self.items[item]
		self.items = new_items

		# Walk through all open tabs to re-open them when needed
		for i in range(self.experiment.ui.tabwidget.count()):
			w = self.experiment.ui.tabwidget.widget(i)
			if hasattr(w, "__edit_item__") and w.__edit_item__ == from_name:
				self.experiment.ui.tabwidget.setTabText(i, to_name)
				self.items[to_name].header.restore_name(False)
				w.edit_item = to_name
			if hasattr(w, "__script_item__") and w.__script_item__ == from_name:
				w.script_item = to_name
				self.experiment.ui.tabwidget.setTabText(i, to_name)
				self.items[to_name].script_widget()

		self.main_window.refresh()

	def check_name(self, name):

		"""
		Checks whether a given name is valid. Reasons for not being valid
		are invalid characters or a conflict with an existing name..

		Arguments:
		name	--	The name to check.

		Returns:
		True if the name is allowed, False otherwise.
		"""

		if name.strip() == u'':
			return u'Empty names are not allowed.'
		if name.lower() in [item.lower() for item in self.items.keys()]:
			return u'An item with that name already exists.'
		if name != self.sanitize(name, strict=True, allow_vars=False):
			return u'Name contains special characters. Only alphanumeric characters and underscores are allowed.'
		return True

	def delete(self, item_name, item_parent=None, index=None):

		"""
		Deletes an item.

		Arguments:
		item_name		--	The name of the item to be deleted.

		Keywords arguments:
		item_parent		--	The parent item. (default=None)
		index			--	The index of the item in the parent sequence, if
							applicable. (default=None)
		"""

		if self.start == item_name:
			self.notify( \
				u'You cannot delete the entry point of the experiment!')
			return
		for item in self.items:
			self.items[item].delete(item_name, item_parent, index)
		self.main_window.refresh()
		self.main_window.close_item_tab(item_name)

	def unique_name(self, name):

		"""
		Returns a unique name that resembles the desired name.

		Arguments:
		name	--	The desired name.

		Returns:
		A unique name.
		"""

		for item in self.items:
			if item == name:
				name = u'_' + name
				return self.unique_name(name)
		return name

	def icon(self, name):

		"""
		Returns a QIcon for a given name (such as an item type).

		Arguments:
		name	--	A name. (e.g., u'sequence')

		Returns:
		A QIcon.
		"""


		# TODO This hack is necessary to avoid breaking compatibility with the
		# old resources system, but plug-ins should not do this anymore!
		if (name+u'.png') in self.resources:
			return QtGui.QIcon(self.resource(name+u'.png'))
		return self.main_window.theme.qicon(name)

	def label_image(self, name):

		"""
		Returns a QLabel for a given name (such as an item type).

		Arguments:
		name	--	A name. (e.g., u'sequence')

		Returns:
		A QLabel.
		"""

		# TODO This hack is necessary to avoid breaking compatibility with the
		# old resources system, but plug-ins should not do this anymore!
		if (name+u'_large.png') in self.resources:
			l = QtGui.QLabel()
			l.setPixmap(QtGui.QPixmap(self.resource(name+u'_large.png')))
			return l
		return self.main_window.theme.qlabel(name)

	def item_combobox(self, select=None, exclude=[], c=None):

		"""
		Returns a QComboBox that contains all the items of the experiment.

		Keyword arguments:
		select	--	The item to be selected initially or None to select
					nothing. (default=None)
		exclude	--	A list of items that should not be included in the list.
					(default=[])
		c		--	A QComboBox that should be cleared and re-filled.
					(default=None)

		Returns:
		A QComboBox.
		"""

		if c == None:
			index = 0
			c = QtGui.QComboBox(self.ui.centralwidget)
		else:
			index = max(0, c.currentIndex())
			c.clear()
		i = 0
		# If we are trying to select a non-existing item, add a dummy entry to
		# the combobox
		if select != None and select not in self.experiment.items:
			c.addItem(u'[Please select an item]')
			c.setCurrentIndex(0)
			c.setItemIcon(i, self.icon(u'down'))
			i += 1
		# Add all existing items (except excluded) in alphabetical order
		for item in sorted(self.experiment.items):
			if item not in exclude:
				item_type = self.experiment.items[item].item_type
				c.addItem(item)
				c.setItemIcon(i, self.icon(self.experiment.items[item].item_type))
				if self.experiment.items[item].name == select:
					index = i
				i += 1
		c.setCurrentIndex(index)
		return c

	def item_type_combobox(self, core_items=True, plugins=True, c=None, \
		select=None):

		"""
		Returns a combobox with all the item types and plug-ins.

		Keyword arguments:
		core_items	--	A boolean indicating whether core items should be
						included. (default=True)
		plugins		--	A boolean indicating whether plug-ins should be
						inculuded. (default=True)
		c			--	A QComboBox that should be cleared and re-filled.
						(default=None)
		select		--	The item type that should be selected initially.
						(default=None)

		Returns:
		A QComboBox
		"""

		if c == None:
			c = QtGui.QComboBox(self.ui.centralwidget)
		else:
			c.clear()
		i = 0
		# Add all core items in alphabetical order.
		for item in sorted(self.core_items):
			c.addItem(item)
			c.setItemIcon(i, self.icon(item))
			if item == select:
				c.setCurrentIndex(i)
			i += 1
		if core_items and plugins:
			c.addItem(u'')
			i += 1
		# Add all plug-ins in alphabetical order. We need to sort the list here
		# because `list_plugins()` sorts by priority.
		for plugin in sorted(libopensesame.plugins.list_plugins()):
			c.addItem(plugin)
			c.setItemIcon(i, QtGui.QIcon( \
				libopensesame.plugins.plugin_icon_small(plugin)))
			if plugin == select:
				c.setCurrentIndex(i)
			i += 1
		return c

	def combobox_text_select(self, combobox, text):

		"""
		Finds a text in a combobox and selects the corresponding item.

		Arguments:
		combobox	--	A QComboBox.
		text		--	A text string to select, if a match is found.
		"""

		combobox.setCurrentIndex(0)
		for i in range(combobox.count()):
			if unicode(combobox.itemText(i)) == text:
				combobox.setCurrentIndex(i)
				break

	def notify(self, msg, title=None, icon=None):

		"""
		Presents a default notification dialog.

		Arguments:
		msg		--	The message to be shown.

		Keyword arguments:
		title	--	A title message or None for default title. (default=None)
		icon	--	A custom icon or None for default icon. (default=None)
		"""

		from libqtopensesame.ui import notification_dialog_ui
		a = QtGui.QDialog(self.main_window)
		a.ui = notification_dialog_ui.Ui_notification_dialog()
		a.ui.setupUi(a)
		self.main_window.theme.apply_theme(a)
		a.ui.textedit_notification.setHtml(self.unistr(msg))
		if title != None:
			a.ui.label_title.setText(title)
		if icon != None:
			a.ui.label_notification.setPixmap(self.main_window.theme.qpixmap( \
				icon))
		a.adjustSize()
		a.show()

	def text_input(self, title, message=None, content=u''):

		"""
		Pops up a text input dialog.

		Arguments:
		title		--	The title for the dialog.

		Keywords arguments:
		message		--	A text message. (default=None)
		contents	--	The initial contents. (default=u'')

		Returns:
		A string of text or None if cancel was pressed.
		"""

		from libqtopensesame.ui import text_input_dialog_ui
		a = QtGui.QDialog(self.main_window)
		a.ui = text_input_dialog_ui.Ui_text_input_dialog()
		a.ui.setupUi(a)
		self.main_window.theme.apply_theme(a)
		if message != None:
			a.ui.label_message.setText(message)
		a.ui.textedit_input.setPlainText(content)
		a.ui.textedit_input.setFont(self.monospace())
		a.adjustSize()
		if a.exec_() == QtGui.QDialog.Accepted:
			return unicode(a.ui.textedit_input.toPlainText())
		return None

	def colorpicker(self, title=u'Pick a color', initial_color=None):

		"""
		Pops up a colorpicker dialog and returns a color in hexadecimal RGB
		notation.

		Keywords arguments:
		title			--	Title of the dialog. (default=u'Pick a color')
		initial_color	--	The color to start with. (default=None)

		Returns:
		A color string or None if the dialog was canceled.
		"""

		try:
			self.color_check(initial_color)
		except:
			initial_color = u'white'
		color = QtGui.QColorDialog.getColor(QtGui.QColor(initial_color), \
			self.main_window, title)
		if color.isValid():
			return self.sanitize(color.name())
		return None

	def monospace(self):

		"""
		Returns the system-specific default monospace font.

		Returns:
		A QFont.
		"""

		if os.name == u'posix':
			font_family = u'mono'
		else:
			font_family = u'courier'
		font = QtGui.QFont(font_family)
		font.setFixedPitch(True)
		return font

	def clear_widget(self, widget):

		"""
		Explicitly clears the layout in a widget. This is necessary in some
		weird cases.

		Arguments:
		widget	--	The QWidget to be cleared.
		"""

		if widget != None:
			layout = widget.layout()
			if layout != None:
				while layout.count() > 0:
					item = layout.takeAt(0)
					if not item:
						continue
					w = item.widget()
					self.clear_widget(w)
					if w:
						w.deleteLater()
						QtCore.QCoreApplication.sendPostedEvents(w, QtCore.QEvent.DeferredDelete)


########NEW FILE########
__FILENAME__ = feedback
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import libopensesame.feedback
from libqtopensesame.items import qtplugin, feedpad
from libqtopensesame.widgets import sketchpad_widget
from PyQt4 import QtCore, QtGui

class feedback(libopensesame.feedback.feedback, feedpad.feedpad, \
	qtplugin.qtplugin):

	"""The GUI for the feedback item"""

	def __init__(self, name, experiment, string=None):

		"""
		Constructor

		Arguments:
		name -- the name of the item
		experiment -- an instance of libopensesame.experiment

		Keyword arguments:
		string -- a string with the item definition (default = None)
		"""

		libopensesame.feedback.feedback.__init__(self, name, experiment, string)
		qtplugin.qtplugin.__init__(self)

	def apply_edit_changes(self):

		"""Apply changes to the controls"""
		
		if not qtplugin.qtplugin.apply_edit_changes(self, False) or self.lock:
			return False
		self.experiment.main_window.refresh(self.name)
		return True			

	def edit_widget(self):

		"""Update the controls based on the items settings"""
		
		self.lock = True
		qtplugin.qtplugin.edit_widget(self)
		self.lock = False
		self.tools_widget.refresh()
		return self._edit_widget

	def init_edit_widget(self):

		"""Construct the edit widget that contains the controls"""
		
		qtplugin.qtplugin.init_edit_widget(self, False)
		
		self.add_line_edit_control('duration', 'Duration', tooltip= \
			'A numeric value (duration in milliseconds), "keypress", or "mouseclick"')
		self.add_checkbox_control('reset_variables', 'Reset feedback variables',
			tooltip='Reset feedback variables, such as "accuracy" and "avg_rt"')
		self.popout_button = QtGui.QPushButton(self.experiment.icon( \
			self.item_type), 'Open editor in new window')
		self.popout_button.setIconSize(QtCore.QSize(16,16))
		self.popout_button.setToolTip( \
			"Open the sketchpad editor in a new window")
		QtCore.QObject.connect(self.popout_button, QtCore.SIGNAL("clicked()"), \
			self.popout)
		self.add_control('', self.popout_button,
			'Open the feedback editor in a new window')
		self.tools_widget = sketchpad_widget.sketchpad_widget(self)
		self.edit_vbox.addWidget(self.tools_widget)		



########NEW FILE########
__FILENAME__ = feedpad
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import debug
from libqtopensesame.dialogs import sketchpad_dialog
from libqtopensesame.items import qtitem
from libqtopensesame.misc import _

class feedpad:

	"""GUI controls that are common to the sketchpad and the feedback item"""

	def popout(self):

		"""Open a new window for the drawing tool"""

		a = sketchpad_dialog.sketchpad_dialog( \
			self.experiment.ui.centralwidget, self);
		a.exec_()
		self.apply_edit_changes()

	def static_items(self):

		"""
		Returns a list of items which are 'static' in the sense that they don't
		contain variables that make it hard to draw them onto a sketchpad.
		Variables in text and show_if properties are allowed.

		Returns:
		A list of static items
		"""

		l = []
		for item in self.items:
			static = True
			for var in item:
				if var != "text" and var != "show_if" and type(item[var]) == \
					unicode and item[var].find("[") >= 0:
					debug.msg("variable property: %s = %s" % (var, item[var]))
					static = False
			if static:
				l.append(item)
		return l

	def items_out_of_bounds(self):

		"""
		Returns a count of items that are 'out of bounds' in the sense that the
		coordinates fall outside of the screen boundaries.

		Returns:
		The nr of items the are out of bounds
		"""

		xc = self.get("width")/2
		yc = self.get("height")/2
		return sum( ["x" in i and "y" in i
			and ( (type(i["x"]) not in (str, unicode) and abs(i["x"]) > xc)
			or (type(i["y"]) not in (str, unicode) and abs(i["y"]) > yc) )
			for i in self.items] )



########NEW FILE########
__FILENAME__ = inline_script
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import debug, misc
import libopensesame.inline_script
from libqtopensesame.items import qtitem
from libqtopensesame.misc import _, config
from libqtopensesame.misc.config import cfg
import random
import re
import sys
from PyQt4 import QtCore, QtGui

class inline_script(libopensesame.inline_script.inline_script, qtitem.qtitem):

	"""The inline_script GUI controls"""

	def __init__(self, name, experiment, string=None):

		"""
		Constructor.

		Arguments:
		name 		--	The item name.
		experiment	--	The experiment object.

		Keywords arguments:
		string		--	A definition string. (default=None)
		"""

		libopensesame.inline_script.inline_script.__init__(self, name, \
			experiment, string)
		qtitem.qtitem.__init__(self)
		self.lock = False
		self._var_info = None

	def apply_edit_changes(self, **args):

		"""
		Applies the controls.

		Keywords arguments:
		args	--	A dictionary to accept unused keyword arguments.
		"""

		qtitem.qtitem.apply_edit_changes(self, False)
		sp = self.qprogedit.text(index=0)
		sr = self.qprogedit.text(index=1)
		self.set(u'_prepare', sp)
		self.set(u'_run', sr)
		self.lock = True
		self._var_info = None
		self.experiment.main_window.refresh(self.name)
		self.lock = False

	def init_edit_widget(self):

		"""Constructs the GUI controls."""
		
		from QProgEdit import QTabManager
		qtitem.qtitem.init_edit_widget(self, False)
		self.qprogedit = QTabManager(handler=self.apply_edit_changes, \
			defaultLang=u'Python', cfg=cfg, focusOutHandler= \
			self.apply_edit_changes)
		self.qprogedit.addTab(u'Prepare')
		self.qprogedit.addTab(u'Run')
		# Switch to the run phase, unless there is only content for the prepare
		# phase.
		if self._run == u'' and self._prepare != u'':
			self.qprogedit.setCurrentIndex(0)
		else:
			self.qprogedit.setCurrentIndex(1)
		self.edit_vbox.addWidget(self.qprogedit)

	def edit_widget(self):

		"""
		Updates the GUI controls.

		Returns:
		The control QWidget.
		"""

		qtitem.qtitem.edit_widget(self, False)
		if not self.lock:
			self.qprogedit.setText(self._prepare, index=0)
			self.qprogedit.setText(self._run, index=1)
		return self._edit_widget

	def get_ready(self):

		"""Applies pending script changes."""

		if self.qprogedit.isModified():
			debug.msg(u'applying pending script changes')
			self.apply_edit_changes(catch=False)
			return True
		return qtitem.qtitem.get_ready(self)


########NEW FILE########
__FILENAME__ = keyboard_response
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import libopensesame.keyboard_response
from libqtopensesame.items import qtplugin
from libqtopensesame.misc import _
from openexp.keyboard import keyboard
from PyQt4 import QtCore, QtGui
import cgi

class keyboard_response(libopensesame.keyboard_response.keyboard_response, \
	qtplugin.qtplugin):

	"""keyboard_response item GUI"""

	def __init__(self, name, experiment, string=None):
	
		"""
		Constructor
		
		Arguments:
		name -- item name
		experiment -- experiment instance	
		
		Keywords arguments:
		string -- a definition string (default=None)	
		"""
		
		libopensesame.keyboard_response.keyboard_response.__init__(self, name, \
			experiment, string)
		qtplugin.qtplugin.__init__(self)	
		
	def apply_edit_changes(self):
	
		"""Apply controls"""
		
		if not qtplugin.qtplugin.apply_edit_changes(self, False) or self.lock:
			return False
		self.experiment.main_window.refresh(self.name)
		return True		

	def init_edit_widget(self):
	
		"""Initialize controls"""

		self.lock = True
		qtplugin.qtplugin.init_edit_widget(self, False)
		
		# Use auto-controls for most stuff
		self.add_line_edit_control('correct_response', 'Correct response',
			tooltip='Set the correct response')
		self.add_line_edit_control('allowed_responses', 'Allowed responses',
			tooltip='Set the allowed responses seperated by a semi-colon, e.g., "z;/"' \
			)
		self.add_line_edit_control('timeout', 'Timeout',
			tooltip='Set the response timeout in milliseconds, or "infinite"')
		self.add_checkbox_control('flush', 'Flush pending keypresses',
			tooltip='Flush pending keypresses')
			
		# List available keys
		button_list_keys = QtGui.QPushButton(self.experiment.icon("info"), \
			"List available keys")
		button_list_keys.setIconSize(QtCore.QSize(16,16))
		button_list_keys.clicked.connect(self.list_keys)		
		self.add_control('', button_list_keys, 'List available keys')
							
		self.edit_vbox.addStretch()
		self.lock = True		
							
	def edit_widget(self):
	
		"""
		Update controls
		
		Returns:
		Controls QWidget
		"""

		self.lock = True
		qtplugin.qtplugin.edit_widget(self)
		self.lock = False
		return self._edit_widget
		
	def list_keys(self):
	
		"""Show a dialog with available key names"""
		
		my_keyboard = keyboard(self.experiment)
		s = _('The following key names are valid:<br />') \
			+ '<br />'.join(my_keyboard.valid_keys())
		self.experiment.notify(s)
	

########NEW FILE########
__FILENAME__ = logger
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import debug
import libopensesame.logger
from libqtopensesame.items import qtitem
from libqtopensesame.misc import _
from PyQt4 import QtCore, QtGui

class logger(libopensesame.logger.logger, qtitem.qtitem):

	"""GUI controls for the logger item"""

	def __init__(self, name, experiment, string = None):

		"""
		Constructor

		Arguments:
		name -- the name of the item
		experiment -- the experiment

		Keyword arguments:
		string -- the definition string for the item (default = None)
		"""

		libopensesame.logger.logger.__init__(self, name, experiment, string)
		qtitem.qtitem.__init__(self)

	def init_edit_widget(self):

		"""Construct the edit_widget that contains the controls"""

		self.lock = True # Lock to prevent recursion

		qtitem.qtitem.init_edit_widget(self, False)
		self.edit_grid_widget.hide()

		# The loop table with corresponding buttons
		self.logvar_table = QtGui.QTableWidget(255, 3)
		self.logvar_table.horizontalHeader().setStretchLastSection(True)
		self.logvar_table.verticalHeader().setVisible(False)
		self.logvar_table.setGridStyle(QtCore.Qt.NoPen)
		self.logvar_table.setAlternatingRowColors(True)
		self.logvar_table.setColumnWidth(0, 24)
		self.logvar_table.setColumnWidth(1, 300)

		vbox = QtGui.QVBoxLayout()
		vbox.setContentsMargins(0, 0, 0, 0)

		button_add = QtGui.QPushButton(self.experiment.icon("add"), \
			_('Add custom variable'))
		button_add.clicked.connect(self.add_custom)
		button_add.setToolTip(_('Add an arbitrary variable by name'))
		button_suggest = QtGui.QPushButton(self.experiment.icon("apply"), \
			_('Smart select'))
		button_suggest.clicked.connect(self.suggest_variables)
		button_suggest.setToolTip( \
			"Automatically select (likely) relevant variables")
		button_select_all = QtGui.QPushButton(self.experiment.icon("apply"), \
			_('Select all'))
		button_select_all.clicked.connect(self.select_all)
		button_select_all.setToolTip(_('Select all variables'))
		button_deselect_all = QtGui.QPushButton(self.experiment.icon("clear"), \
			_('Deselect all'))
		button_deselect_all.clicked.connect(self.deselect_all)
		button_deselect_all.setToolTip(_('Deselect all variables'))
		hbox = QtGui.QHBoxLayout()
		hbox.addWidget(button_select_all)
		hbox.addWidget(button_deselect_all)
		hbox.addStretch()
		hbox.addWidget(button_suggest)
		hbox.addWidget(button_add)
		hbox.setMargin(0)

		self.logvar_buttons = QtGui.QWidget()
		self.logvar_buttons.setLayout(hbox)
		self.checkbox_ignore_missing = QtGui.QCheckBox( \
			_('Include variables with missing values'))			
		self.checkbox_ignore_missing.stateChanged.connect( \
			self.apply_edit_changes)
		self.checkbox_auto_log = QtGui.QCheckBox( \
			_('Automatically detect and log all variables'))
		self.checkbox_auto_log.stateChanged.connect(self.apply_edit_changes)
		self.checkbox_use_quotes = QtGui.QCheckBox(_('Put quotes around values'))
		self.checkbox_use_quotes.stateChanged.connect(self.apply_edit_changes)
		vbox.addWidget(self.checkbox_ignore_missing)
		vbox.addWidget(self.checkbox_auto_log)
		vbox.addWidget(self.checkbox_use_quotes)
		vbox.addWidget(self.logvar_buttons)
		vbox.addWidget(self.logvar_table)

		widget = QtGui.QWidget()
		widget.setLayout(vbox)

		self.edit_vbox.addWidget(widget)
		self.lock = False # Unlock

	def edit_widget(self):

		"""
		Update the edit_widget to reflect changes in the item

		Returns:
		The edit widget
		"""

		self.lock = True
		qtitem.qtitem.edit_widget(self)

		if self.get("auto_log") == "yes":
			self.checkbox_auto_log.setChecked(True)
			self.logvar_buttons.setDisabled(True)
			self.logvar_table.setDisabled(True)
		else:
			self.checkbox_auto_log.setChecked(False)
			self.logvar_buttons.setEnabled(True)
			self.logvar_table.setEnabled(True)

		self.checkbox_ignore_missing.setChecked( \
			self.get("ignore_missing") == "yes")
		self.checkbox_use_quotes.setChecked(self.get("use_quotes") == "yes")

		self.logvar_table.setRowCount(0)
		self.logvar_table.setHorizontalHeaderItem(0, QtGui.QTableWidgetItem(""))
		self.logvar_table.setHorizontalHeaderItem(1, QtGui.QTableWidgetItem( \
			"Variable"))
		self.logvar_table.setHorizontalHeaderItem(2, QtGui.QTableWidgetItem( \
			"Source item(s)"))

		# Fill the table
		row = 0
		var_rows = {}
		all_vars = []
		for var, val, item in self.experiment.var_list():

			# Only add a new row if the variable isn't already in the table
			if var not in all_vars:

				all_vars.append(var)
				var_rows[var] = row
				checkbox = QtGui.QCheckBox()
				checkbox.var = var
				checkbox.stateChanged.connect(self.apply_edit_changes)
				if var in self.logvars:
					checkbox.setChecked(True)

				self.logvar_table.insertRow(row)
				self.logvar_table.setCellWidget(row, 0, checkbox)
				self.logvar_table.setCellWidget(row, 1, QtGui.QLabel(var))
				self.logvar_table.setCellWidget(row, 2, QtGui.QLabel(item))
				row += 1

			# .. otherwise change the source item(s) column
			else:

				label = self.logvar_table.cellWidget(var_rows[var], 2)
				label.setText(label.text() + "; " + item)

		for var in self.logvars:
			if var not in all_vars:
				checkbox = QtGui.QCheckBox()
				checkbox.var = var
				checkbox.stateChanged.connect(self.apply_edit_changes)
				checkbox.setChecked(True)
				self.logvar_table.insertRow(row)
				self.logvar_table.setCellWidget(row, 0, checkbox)
				self.logvar_table.setCellWidget(row, 1, QtGui.QLabel(var))
				self.logvar_table.setCellWidget(row, 2, QtGui.QLabel("custom"))
				row += 1

		self.lock = False
		return self._edit_widget

	def apply_edit_changes(self, dummy = None):

		"""
		Update the item to match the edit_widget

		Keyword arguments:
		dummy -- a dummy argument passed by the signal handler (default = None)
		"""

		if not qtitem.qtitem.apply_edit_changes(self, False) or self.lock:
			return

		if self.checkbox_auto_log.isChecked():
			self.set("auto_log", "yes")
			self.logvar_buttons.setDisabled(True)
			self.logvar_table.setDisabled(True)
		else:
			self.set("auto_log", "no")
			self.logvar_buttons.setDisabled(False)
			self.logvar_table.setDisabled(False)

		if self.checkbox_ignore_missing.isChecked():
			self.set("ignore_missing", "yes")
		else:
			self.set("ignore_missing", "no")

		if self.checkbox_use_quotes.isChecked():
			self.set("use_quotes", "yes")
		else:
			self.set("use_quotes", "no")

		self.logvars = []
		for row in range(self.logvar_table.rowCount()):
			checkbox = self.logvar_table.cellWidget(row, 0)

			if checkbox != None:
				if checkbox.isChecked():
					self.logvars.append(checkbox.var)

		self.experiment.main_window.refresh(self.name, refresh_edit = False)

	def suggest_variables(self):

		"""
		Smart select all variables that should probably be logged. Variables in
		unused items are ignored.
		"""

		i = 0
		for item in self.experiment.items:
			if item in self.experiment.unused_items:
				debug.msg("ignoring variables from '%s'" % item)
				continue
			if self.experiment.items[item].item_type in ("loop", \
				"keyboard_response", "mouse_response"):
				for var, val in self.experiment.items[item].var_info():
					if var not in self.logvars and var != "time_%s" % item and \
						var != "count_%s" % item:
						self.logvars.append(var)
			if self.experiment.items[item].item_type == "sequence":
				for var, val in self.experiment.items[item].var_info():
					if var not in self.logvars and var == "count_%s" % item:
						self.logvars.append(var)

		self.edit_widget()
		self.experiment.main_window.refresh(self.name)

	def select_all(self):

		"""Select all variables"""

		for var, val, item in self.experiment.var_list():
			if var not in self.logvars:
				self.logvars.append(var)
		self.edit_widget()
		self.experiment.main_window.refresh(self.name)

	def deselect_all(self):

		"""Deselect all variables"""

		self.logvars = []
		self.edit_widget()
		self.experiment.main_window.refresh(self.name)

	def add_custom(self):

		"""Select a custom variable by name that is not recognized"""

		var, ok = QtGui.QInputDialog.getText( \
			self.experiment.main_window.ui.centralwidget, \
			"Add custom variable", "Which variable do you wish to log?")
		if ok:
			var = self.experiment.sanitize(var, strict=True, allow_vars=False)
			if var == "":
				self.experiment.notify( \
					"The variable name you entered was not valid. A variable name may consist of characters, numbers and underscores.")
				return
			if var not in self.logvars:
				self.logvars.append(var)
				self.edit_widget()
				self.experiment.main_window.refresh(self.name)

	def rename_var(self, item, from_name, to_name):

		"""
		A notification that a variable has been renamed

		Arguments:
		item -- the item doing the renaming
		from_name -- the old variable name
		to_name -- the new variable name
		"""

		if from_name in self.logvars:
			debug.msg("'%s' has been renamed to '%s'" % (from_name, to_name))
			resp = QtGui.QMessageBox.question(self.experiment.main_window, \
				"Use new name in logger?",
				"Do you want to use the new name in the logger item '%s' as well?" \
				% self.name,
				QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)
			if resp == QtGui.QMessageBox.No:
				return
			self.logvars.remove(from_name)
			self.logvars.append(to_name)
			self.edit_widget()


########NEW FILE########
__FILENAME__ = loop
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import copy
import libopensesame.loop
from libqtopensesame.items import qtitem
from libqtopensesame.misc import _
from libqtopensesame.misc.config import cfg
from libqtopensesame.ui import loop_wizard_dialog_ui, loop_widget_ui
from libqtopensesame.widgets import loop_table
from libopensesame import debug
from PyQt4 import QtCore, QtGui

class loop(libopensesame.loop.loop, qtitem.qtitem):

	"""The GUI for the loop item"""

	def __init__(self, name, experiment, string=None):

		"""
		Constructor.

		Arguments:
		name		--	Name of the item.
		experiment	-- 	The experiment object.

		Keyword arguments:
		string		--	The definition string. (default=None)
		"""

		libopensesame.loop.loop.__init__(self, name, experiment, string)
		qtitem.qtitem.__init__(self)
		self.sanity_criteria[u'cycles'] = {u'type' : int, u'msg' : \
			u'Must be a integer numeric value'}

	def rename(self, from_name, to_name):

		"""
		Handles an item rename.

		Arguments:
		from_name	--	The old name of the item to be renamed.
		to_name		--	The new name of the item to be renamed.
		"""

		qtitem.qtitem.rename(self, from_name, to_name)
		if self.item == from_name:
			self.item = to_name

	def delete(self, item_name, item_parent=None, index=None):

		"""
		Deletes an item.

		Arguments:
		item_name		--	The name of the item to be deleted.

		Keywords arguments:
		item_parent		--	The parent item. (default=None)
		index			--	The index of the item in the parent. (default=None)
		"""

		if self.item == item_name and item_parent == self.name:
			self.item = u""

	def add_cyclevar(self):

		"""Presents a dialog and add a variable,"""

		var_name, ok = QtGui.QInputDialog.getText(self.loop_table, \
			_(u'New variable'), \
			_(u'Enter a variable name, optionally followed by a default value (i.e., \"varname defaultvalue\")'))

		if ok:
			l = self.cyclevar_list()
			var_name = unicode(var_name)

			# Split by space, because a name may be followed by a default value
			_l = var_name.split()
			if len(_l) > 1:
				default = _l[1]
				var_name = _l[0]
			else:
				default = ""

			# Check for valid variable names
			var_name = self.experiment.sanitize(var_name, strict=True, \
				allow_vars=False)
			if var_name == u"":
				self.experiment.notify( \
					u"Variable names must consist of alphanumeric characters and underscores, and must not be empty")
				return

			# Check if the variable already exists
			if l != None and var_name in l:
				self.experiment.notify( \
					_(u"A variable with the name '%s' already exists") \
						% var_name)
				return

			for i in range(self.cycles):
				if i not in self.matrix:
					self.matrix[i] = {}
				self.matrix[i][var_name] = default

			self.refresh_loop_table()
			self.apply_edit_changes()

	def cyclevar_list(self):

		"""
		Returns a list of variables.

		Returns:
		A list of variable names
		"""

		var_list = []
		for i in self.matrix:
			for var in self.matrix[i]:
				if var not in var_list:
					var_list.append(var)
		if len(var_list) == 0:
			return None
		return var_list


	def rename_var(self, item, from_name, to_name):

		"""
		Processes a notification that a variable has been renamed.

		Arguments:
		item		--	The item doing the renaming.
		from_name	--	The old variable name.
		to_name		--	The new variable name.
		"""

		# Only accept renames from this item
		if item != self.name:
			return
		for i in self.matrix:
			if from_name in self.matrix[i]:
				val = self.matrix[i][from_name]
				del self.matrix[i][from_name]
				self.matrix[i][to_name] = val

	def rename_cyclevar(self):

		"""Presents a dialog and rename a variable."""

		var_list = self.cyclevar_list()
		if var_list == None:
			return

		old_var, ok = QtGui.QInputDialog.getItem( \
			self.experiment.ui.centralwidget, _(u"Rename variable"), \
			_(u"Which variable do you want to rename?"), var_list, \
			editable=False)
		if ok:
			_new_var, ok = QtGui.QInputDialog.getText(self.loop_table, \
				_(u'New variable'), _(u'Enter a new variable name'), text=old_var)
			if ok and _new_var != old_var:
				old_var = unicode(old_var)
				new_var = self.experiment.sanitize(_new_var, strict=True, \
					allow_vars=False)
				if _new_var != new_var or new_var == "":
					self.experiment.notify( \
						_(u"Please use only letters, numbers and underscores"))
					return
				if new_var in var_list:
					self.experiment.notify( \
						_(u"A variable with the name '%s' already exists") % \
						new_var)
					return
			for item in self.experiment.items.values():
				item.rename_var(self.name, old_var, new_var)
			self.refresh_loop_table()
			self.apply_edit_changes()

	def remove_cyclevar(self):

		"""Presents a dialog and remove a variable."""

		var_list = self.cyclevar_list()
		if var_list == None:
			return

		var, ok = QtGui.QInputDialog.getItem(self.experiment.ui.centralwidget, \
			_(u"Remove variable"), _(u"Which variable do you want to remove?"), \
			var_list)
		if ok:
			var = unicode(var)
			for i in self.matrix:
				if var in self.matrix[i]:
					del self.matrix[i][var]

			self.refresh_loop_table()
			self.apply_edit_changes()

	def cyclevar_count(self):

		"""
		Counts the number of variables in the loop,

		Returns:
		The number of variables in the loop.
		"""

		l = []
		c = 0
		for cycle in self.matrix:
			for var in self.matrix[cycle]:
				if var not in l:
					l.append(var)
					c += 1
		return c

	def cycle_count(self):

		"""
		Counts the number of cycles, which is the maximum of the table length
		and the 'cycles' variables.

		Returns:
		The number of cycles.
		"""

		if type(self.cycles) != int:
			return 0
		return max(self.cycles, len(self.matrix))

	def set_cycle_count(self, cycles, confirm=True):

		"""
		Sets the nr of cycles and truncates data if necessary.

		Arguments:
		cycles		--	The number of cycles.

		Keyword arguments:
		confirm		--	Indicates whether confirmation is required before data
						is removed from the table. (default=True)
		"""

		debug.msg(u"cycles = %s" % cycles)
		cont = True
		while cont:
			cont = False
			for i in self.matrix:
				if i >= cycles:

					# Check if the cells that will be removed are not empty
					empty = True
					for var in self.matrix[i]:
						if self.matrix[i][var] != u"":
							empty = False

					# Ask for confirmation (only the first time)
					if not empty and confirm:
						resp = QtGui.QMessageBox.question( \
							self.experiment.ui.centralwidget, \
							_(u"Remove cycles?"), \
							_(u"By reducing the number of cycles, data will be lost from the table. Do you wish to continue?"), \
							QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)
						if resp == QtGui.QMessageBox.No:
							return
						confirm = False

					# Delete the cycle and restart the loop
					del self.matrix[i]
					cont = True
					break

		self.set(u"cycles", cycles)

	def call_count(self):

		"""
		Returns the number of times that the target item is called in total,
		which depends on the repeat and cycles.

		Returns:
		The number of calls or 0 if the number of calls could not be determined.
		"""

		try:
			if self.order == u"sequential" and self.offset != u"yes":
				return int(self.cycles * self.repeat - self.skip)
			return int(self.cycles * self.repeat)
		except:
			return 0

	def refresh_summary(self):

		"""Refreshes the cycle count summary."""

		cc = self.call_count()
		if self.order == u'sequential' and self.offset != u'yes':
			s = _(u"<b>%s</b> will be called <b>%s</b> x <b>%s</b> - <b>%s</b> = <b>%s</b> times in <b>%s</b> order") \
				% (self.item, self.cycles, self.repeat, self.skip, cc, \
				self.order)
		else:
			s = _(u"<b>%s</b> will be called <b>%s</b> x <b>%s</b> = <b>%s</b> times in <b>%s</b> order") \
				% (self.item, self.cycles, self.repeat, cc, self.order)
		if self.order == u"sequential" and self.skip > 0:
			s += _(u" starting at cycle <b>%s</b>") % self.skip
			if self.offset == u"yes" and self.skip >= cc:
				s += _(u" <font color='red'><b>(too many cycles skipped)</b></font>")
		if cc < 1:
			s += _(u" <font color='red'><b>(zero, negative, or unknown length)</b></font>")
		self.loop_widget.ui.label_summary.setText(u"<small>%s</small>" % s)

	def refresh_loop_table(self, lock=True):

		"""
		Rebuilds the loop table.

		Keyword arguments:
		lock	--	A boolean indicating whether the item should be locked to
					prevent recursion. (default=True)
		"""

		if lock:
			self.lock = True

		# Don't crash if the cycle variable is variable, simply provide an
		# error message (due to the sanity check) and disable the loop table.
		if type(self.cycles) != int:
			self.loop_table.setEnabled(False)
			self.lock = False
			return
		self.loop_table.setEnabled(True)

		# Don't clear and resize the table if this is not necessary, because
		# this makes the cursor jump
		if self.loop_table.rowCount() != self.cycles or \
			self.loop_table.columnCount() != self.cyclevar_count():
			self.loop_table.clear()
			self.loop_table.setRowCount(self.cycles)
			self.loop_table.setColumnCount(self.cyclevar_count())

		# Determine the order in which the columns are displayed
		column_order = []
		if self.cyclevar_list() != None:
			if self.has(u"column_order"):
				for var in self.unistr(self.get(u"column_order")).split(u";"):
					if var in self.cyclevar_list():
						column_order.append(var)
			for var in self.cyclevar_list():
				if var not in column_order:
					column_order.append(var)

		# Create the column headers
		i = 0
		for var in column_order:
			self.loop_table.setHorizontalHeaderItem(i, \
				QtGui.QTableWidgetItem(var))
			i += 1

		# Fill the table
		var_columns = {}
		new_column = 0
		for cycle in self.matrix:
			for var in self.matrix[cycle]:
				col = column_order.index(var)
				self.loop_table.setItem(cycle, col, \
					QtGui.QTableWidgetItem(self.experiment.unistr( \
						self.matrix[cycle][var])))

		# Store the number of cycles and the column order
		self.set(u"cycles", max(self.get(u"cycles"), self.cycle_count()))
		self.set(u"column_order", u";".join(column_order))

		if lock:
			self.lock = False

	def wizard_process(self, d, l=[]):

		"""
		Rebuilds the loop table based on a dictionary of variables and levels.

		Arguments:
		d	--	A dictionary of variables and levels.

		Keyword arguments:
		l	--	A list of variables and values. (default=[])
		"""

		if len(d) == 0:
			for var, val in l:
				if self.i not in self.matrix:
					self.matrix[self.i] = {}
				self.matrix[self.i][var] = val
			self.i += 1
			return
		var = d.keys()[0]
		for val in d[var]:
			_d = copy.copy(d)
			del _d[var]
			self.wizard_process(_d, l + [(var, val)])

	def wizard(self):

		"""Presents the variable wizard dialog."""

		icons = {}
		icons[u"cut"] = self.experiment.icon(u"cut")
		icons[u"copy"] = self.experiment.icon(u"copy")
		icons[u"paste"] = self.experiment.icon(u"paste")
		icons[u"clear"] = self.experiment.icon(u"clear")

		# Set up the wizard dialog
		a = QtGui.QDialog(self.experiment.main_window.ui.centralwidget)
		a.ui = loop_wizard_dialog_ui.Ui_loop_wizard_dialog()
		a.ui.setupUi(a)
		self.experiment.main_window.theme.apply_theme(a)
		a.ui.table_example.build_context_menu(icons)
		a.ui.table_wizard.build_context_menu(icons)
		a.ui.table_example.hide()
		a.ui.table_wizard.setRowCount(255)
		a.ui.table_wizard.setColumnCount(255)

		a.ui.table_wizard.set_contents(cfg.loop_wizard)
		if a.exec_() == QtGui.QDialog.Accepted:
			cfg.loop_wizard = a.ui.table_wizard.get_contents()
			debug.msg(u"filling loop table")
			# First read the table into a dictionary of variables
			var_dict = {}
			for col in range(a.ui.table_wizard.columnCount()):
				var = None
				for row in range(a.ui.table_wizard.rowCount()):
					item = a.ui.table_wizard.item(row, col)
					if item == None:
						break
					s = unicode(item.text())
					if s == u'':
						break
					if row == 0:
						var = self.experiment.sanitize(s, True)
						var_dict[var] = []
					elif var != None:
						var_dict[var].append(s)

			# If the variable wizard was not parsed correctly, provide a
			# notification and do nothin
			if len(var_dict) == 0:
				self.experiment.notify(
					_(u'You provided an empty or invalid variable definition. For an example of a valid variable definition, open the variable wizard and select "Show example".'))
				return

			# Then fill the loop table
			self.i = 0
			self.matrix = {}
			self.wizard_process(var_dict)
			self.set_cycle_count(len(self.matrix))
			self.lock = True
			self.loop_widget.ui.spin_cycles.setValue(self.cycle_count())
			self.lock = False
			self.refresh_loop_table()
			self.refresh_summary()

	def init_edit_widget(self):

		"""Builds the loop controls."""

		self.lock = True

		qtitem.qtitem.init_edit_widget(self, False)
		self.loop_widget = QtGui.QWidget()
		self.loop_widget.ui = loop_widget_ui.Ui_loop_widget()
		self.loop_widget.ui.setupUi(self.loop_widget)
		self.experiment.main_window.theme.apply_theme(self.loop_widget)
		self.loop_widget.ui.widget_advanced.hide()

		self.edit_vbox.addWidget(self.loop_widget)

		self.auto_add_widget(self.loop_widget.ui.spin_cycles)
		self.auto_add_widget(self.loop_widget.ui.spin_repeat, u"repeat")
		self.auto_add_widget(self.loop_widget.ui.spin_skip, u"skip")
		self.auto_add_widget(self.loop_widget.ui.combobox_order, u"order")
		self.auto_add_widget(self.loop_widget.ui.checkbox_offset, u"offset")
		# The break-if box needs to be validated, so we don't add it to the
		# auto widgets.
		self.loop_widget.ui.edit_break_if.editingFinished.connect( \
			self.apply_edit_changes)
		# The item combobox needs special treatment, because it's changes
		# must be visible in the item tree as well
		self.loop_widget.ui.combobox_item.currentIndexChanged.connect( \
			self.apply_item_change)

		self.loop_widget.ui.button_add_cyclevar.clicked.connect( \
			self.add_cyclevar)
		self.loop_widget.ui.button_rename_cyclevar.clicked.connect( \
			self.rename_cyclevar)
		self.loop_widget.ui.button_remove_cyclevar.clicked.connect( \
			self.remove_cyclevar)
		self.loop_widget.ui.button_wizard.clicked.connect(self.wizard)
		self.loop_widget.ui.button_apply_weights.clicked.connect( \
			self.apply_weights)

		self.loop_widget.ui.combobox_order.setItemIcon(0, \
			self.experiment.icon(u"random"))
		self.loop_widget.ui.combobox_order.setItemIcon(1, \
			self.experiment.icon(u"sequential"))

		self.loop_table = loop_table.loop_table(self, self.cycles, \
			self.cyclevar_count())
		self.edit_vbox.addWidget(self.loop_table)

		self.lock = False
		return self._edit_widget

	def edit_widget(self):

		"""Set the loop controls from the variables"""

		self.lock = True
		debug.msg()
		# Update the item combobox
		self.experiment.item_combobox(self.item, self.parents(), \
			self.loop_widget.ui.combobox_item)
		qtitem.qtitem.edit_widget(self)
		self.refresh_loop_table(lock=False)
		self.loop_widget.ui.spin_cycles.setValue(self.cycle_count())

		if self.get(u"order") == u"random":
			self.loop_widget.ui.label_skip.setDisabled(True)
			self.loop_widget.ui.spin_skip.setDisabled(True)
			self.loop_widget.ui.checkbox_offset.setDisabled(True)
		else:
			self.loop_widget.ui.label_skip.setDisabled(False)
			self.loop_widget.ui.spin_skip.setDisabled(False)
			self.loop_widget.ui.checkbox_offset.setDisabled( \
				type(self.skip) != int or self.skip < 1)
		self.refresh_summary()
		self.lock = False
		return self._edit_widget

	def apply_weights(self):

		"""Repeat certain cycles based on the value in a particular column"""

		var_list = self.cyclevar_list()
		if var_list == None:
			return

		weight_var, ok = QtGui.QInputDialog.getItem( \
			self.experiment.ui.centralwidget, _(u"Apply weight"), \
			_(u"Which variable contains the weights?"), var_list, \
			editable=False)
		if not ok:
			return

		self.matrix = {}
		_row = 0
		for row in range(self.loop_table.rowCount()):
			self.matrix[_row] = {}
			weight = 1
			for col in range(self.loop_table.columnCount()):
				var = unicode(self.loop_table.horizontalHeaderItem(col).text())
				cell = self.loop_table.item(row, col)
				if cell == None:
					val = u''
				else:
					val = unicode(self.loop_table.item(row, col).text())
				if var == weight_var:
					try:
						weight = int(val)
					except:
						weight = 1
				self.matrix[_row][var] = val
			if weight <= 0:
				del self.matrix[_row]
			else:
				_row += 1
				while weight > 1:
					weight -= 1
					if _row-1 in self.matrix:
						self.matrix[_row] = self.matrix[_row-1]
					_row += 1
		self.set_cycle_count(_row)
		self.edit_widget()

	def apply_item_change(self):

		"""Applies a change to the item to run."""

		item = unicode(self.loop_widget.ui.combobox_item.currentText())
		debug.msg(item)
		self.set(u'item', item)
		self.experiment.main_window.dispatch.event_structure_change.emit( \
			self.name)

	def apply_edit_changes(self, dummy=None):

		"""
		Sets the variables from the controls.

		Keyword arguments:
		dummy	-- A dummy argument passed by the signal handler. (default=None)
		"""

		if self.lock or not qtitem.qtitem.apply_edit_changes(self, False):
			return
		self.lock = True
		# Validate and set the break-if statement
		break_if = self.clean_cond(self.loop_widget.ui.edit_break_if.text(), \
			default=u'never')
		self.loop_widget.ui.edit_break_if.setText(break_if)
		self.set(u'break_if', break_if)
		# Walk through the loop table and apply all changes
		self.matrix = {}
		for row in range(self.loop_table.rowCount()):
			self.matrix[row] = {}
			for col in range(self.loop_table.columnCount()):
				var = unicode(self.loop_table.horizontalHeaderItem(col).text())
				cell = self.loop_table.item(row, col)
				if cell == None:
					val = u''
				else:
					val = unicode(self.loop_table.item(row, col).text())
				if not self.sanitize_check(val):
					val = self.sanitize(val)
				self.matrix[row][var] = val
		row = self.loop_table.currentRow()
		column = self.loop_table.currentColumn()
		self.set_cycle_count(self.loop_widget.ui.spin_cycles.value())
		self.refresh_loop_table()
		self.loop_table.setCurrentCell(row, column)
		self.lock = False
		self.edit_widget()

	def build_item_tree(self, toplevel, items):

		"""
		Constructs an item tree.

		Keyword arguments:
		toplevel		--	The toplevel widget. (default=None)
		items			--	A list of items that have been added, to prevent
							recursion. (default=[])

		Returns:
		An updated list of items that have been added.
		"""

		widget = self.item_tree_widget(toplevel)
		toplevel.addChild(widget)
		if self.item in self.experiment.items and self.item != None and \
			self.item.strip() != "":
			if self.experiment.items[self.item] not in items:
				items.append(self.experiment.items[self.item])
			self.experiment.items[self.item].build_item_tree(widget, items)
		widget.setExpanded(True)
		return items

	def is_offspring(self, item):

		"""
		Checks if the item is offspring of the current item.

		Arguments:
		item	--	The potential offspring.

		Returns:
		True if the passed item is offspring, False otherwise.
		"""

		return self.item == item or (self.item in self.experiment.items and \
			self.experiment.items[self.item].is_offspring(item))


########NEW FILE########
__FILENAME__ = mouse_response
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import libopensesame.mouse_response
from libqtopensesame.items import qtplugin
from PyQt4 import QtCore, QtGui

class mouse_response(libopensesame.mouse_response.mouse_response, \
	qtplugin.qtplugin):

	"""mouse_response item GUI"""

	def __init__(self, name, experiment, string=None):
	
		"""
		Constructor
		
		Arguments:
		name -- item name
		experiment -- experiment instance	
		
		Keywords arguments:
		string -- a definition string (default=None)	
		"""		
		libopensesame.mouse_response.mouse_response.__init__(self, name, \
			experiment, string)
		qtplugin.qtplugin.__init__(self)

	def apply_edit_changes(self):
	
		"""Apply controls"""
		
		if not qtplugin.qtplugin.apply_edit_changes(self, False) or self.lock:
			return False
		self.experiment.main_window.refresh(self.name)
		return True		

	def init_edit_widget(self):
	
		"""Initialize controls"""
		
		self.lock = True
		qtplugin.qtplugin.init_edit_widget(self, False)		
		# Use auto-controls for most stuff
		self.add_line_edit_control('correct_response', 'Correct response',
			tooltip='Set the correct response')
		self.add_line_edit_control('allowed_responses', 'Allowed responses',
			tooltip='Set the allowed responses seperated by a semi-colon, e.g., "left_button;right_button"' \
			)
		self.add_line_edit_control('timeout', 'Timeout',
			tooltip='Set the response timeout in milliseconds, or "infinite"')
		self.add_checkbox_control('show_cursor', 'Visible mouse cursor',
			tooltip='If checked, the mouse cursor will be visible')			
		self.add_checkbox_control('flush', 'Flush pending mouse clicks',
			tooltip='Flush pending mouse clicks')			
		self.add_text( \
			'<small><i><b>Note:</b> Change the "custom cursor" option in the backend settings to switch between the system cursor and the custom OpenSesame cursor</i></small>' \
			)			
		self.edit_vbox.addStretch()
		self.lock = True							
							
	def edit_widget(self):
	
		"""
		Update controls
		
		Returns:
		Controls QWidget
		"""
		
		self.lock = True
		qtplugin.qtplugin.edit_widget(self)
		self.lock = False
		return self._edit_widget


########NEW FILE########
__FILENAME__ = qtautoplugin
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
from libqtopensesame.items.qtplugin import qtplugin
from libqtopensesame.misc import _

class qtautoplugin(qtplugin):

	"""A class that processes auto-plugins defined in a JSON file"""
	
	def __init__(self, plugin_file):
		
		qtplugin.__init__(self, plugin_file)				
					
	def init_edit_widget(self):

		"""Construct the GUI controls based on info.json"""

		# Import json only when required, as it is not necessary for the
		# runtime environment and may be not available on all platforms,
		# notably Android.
		import json
	
		self.lock = True
		qtplugin.init_edit_widget(self, False)		
		# Load info.json
		json_path = os.path.join(self.plugin_folder, u'info.json')
		self.json = json.load(open(json_path))				
		# Some options are required. Which options are requires depends on the
		# specific widget.
		required  = [
			([u'checkbox', u'color_edit', u'combobox', u'editor', u'filepool', \
				u'line_edit', u'spinbox', u'text'], [u'label']),
			([u'checkbox', u'color_edit', u'combobox', u'editor', u'filepool', \
				u'line_edit', u'spinbox'], [u'var']),
			([u'spinbox', u'slider'], [u'min_val', u'max_val']),
			([u'combobox'], [u'options']),
			]
		# Keywords are optional parameters that are set to some default if they
		# are not specified.
		keywords = {
			u'tooltip' : None,
			u'min_width' : None,
			u'prefix' : u'',
			u'suffix' : u'',
			u'left_label' : u'min.',
			u'right_label' : u'max.',
			u'syntax' : False
			}
		# This indicates whether we should pad the controls with a stretch at
		# the end.
		need_stretch = True
		for c in self.json[u'controls']:			
			# Check whether all required options have been specified
			if u'type' not in c:
				raise Exception(_( \
					u'You must specify "type" for %s controls in info.json') \
					% option)
			for types, options in required:
				if c[u'type'] in types:
					for option in options:
						if option not in c:
							raise Exception(_( \
								u'You must specify "%s" for %s controls in info.json') \
								% (option, c[u'type']))
			# Set missing keywords to None
			for keyword, default in keywords.iteritems():
				if keyword not in c:
					c[keyword] = default
			# Parse checkbox
			if c[u'type'] == u'checkbox':
				widget = self.add_checkbox_control(c[u'var'], c[u'label'], \
					tooltip=c[u'tooltip'])
			# Parse color_edit
			elif c[u'type'] == u'color_edit':
				widget = self.add_color_edit_control(c[u'var'], c[u'label'], \
					tooltip=c[u'tooltip'], min_width=c[u'min_width'])
			# Parse combobox
			elif c[u'type'] == u'combobox':
				widget = self.add_combobox_control(c[u'var'], c[u'label'], \
					c[u'options'], tooltip=c[u'tooltip'])
			# Parse editor
			elif c[u'type'] == u'editor':
				widget = self.add_editor_control(c[u'var'], c[u'label'], \
					syntax=c[u'syntax'], tooltip=c[u'tooltip'])
				need_stretch = False
			# Parse filepool
			elif c[u'type'] == u'filepool':
				widget = self.add_filepool_control(c[u'var'], c[u'label'], \
					tooltip=c[u'tooltip'])
			# Parse line_edit
			elif c[u'type'] == u'line_edit':
				widget = self.add_line_edit_control(c[u'var'], c[u'label'], \
					tooltip=c[u'tooltip'], min_width=c[u'min_width'])
			# Parse spinbox
			elif c[u'type'] == u'spinbox':
				widget = self.add_spinbox_control(c[u'var'], c[u'label'], \
					c[u'min_val'], c[u'max_val'], prefix=c[u'prefix'], suffix= \
					c[u'suffix'], tooltip=c[u'tooltip'])
			# Parse slider
			elif c[u'type'] == u'slider':
				widget = self.add_slider_control(c[u'var'], c[u'label'], \
					c[u'min_val'], c[u'max_val'], left_label=c[u'left_label'], \
					right_label=c[u'right_label'], tooltip=c[u'tooltip'])
			# Parse text
			elif c[u'type'] == u'text':
				widget = self.add_text(c[u'label'])
			else:
				raise Exception(_(u'"%s" is not a valid qtautoplugin control') \
					% controls[u'type'])
			# Add the widget as an item property when the 'name' option is
			# specified.
			if u'name' in c:
				if hasattr(self, c[u'name']):
					raise Exception(_( \
						u'Name "%s" is already taken in qtautoplugin control') \
						% c[u'name'])
				setattr(self, c[u'name'], widget)
		if need_stretch:
			self.add_stretch()
		self.lock = True

	def apply_edit_changes(self):

		"""Applies the controls. I.e. sets the variables from the controls."""

		if not qtplugin.apply_edit_changes(self, False) or self.lock:
			return False
		self.experiment.main_window.refresh(self.name)
		return True

	def edit_widget(self):

		"""Sets the controls based on the variables."""

		self.lock = True
		qtplugin.edit_widget(self)
		self.lock = False
		return self._edit_widget	
	
########NEW FILE########
__FILENAME__ = qtitem
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt4 import QtCore, QtGui
import os.path
import sip
from libopensesame.exceptions import osexception
from libopensesame import debug, item
from libqtopensesame.widgets import header_widget, user_hint_widget
from libqtopensesame.misc import _
from libqtopensesame.misc.config import cfg

class qtitem(QtCore.QObject):

	"""Base class for the GUI controls of other items"""

	def __init__(self):

		"""Constructor"""

		QtCore.QObject.__init__(self)

		# The auto-widgets are stored in name -> (var, widget) dictionaries
		self.auto_line_edit = {}
		self.auto_combobox = {}
		self.auto_spinbox = {}
		self.auto_slider = {}
		self.auto_editor = {}
		self.auto_checkbox = {}
		self.sanity_criteria = {}

		self.init_edit_widget()
		self.init_script_widget()
		self.script_tab = None
		self.lock = False
		self.edit_mode = u'edit'

		debug.msg(u'created %s' % self.name)

	def open_help_tab(self, page=None):

		"""Opens a help tab."""

		self.experiment.main_window.ui.tabwidget.open_help(self.item_type)

	def open_tab(self):

		"""Opens the correct tab based on the current edit mode"""

		if self.edit_mode == u'edit':
			self.open_edit_tab()
		else:
			self.open_script_tab()

	def init_edit_widget(self, stretch=True):

		"""Build the GUI controls"""

		# Header widget
		self.header = header_widget.header_widget(self)
		self.user_hint_widget = user_hint_widget.user_hint_widget( \
			self.experiment.main_window, self)
		self.header_hbox = QtGui.QHBoxLayout()
		self.header_hbox.addWidget(self.experiment.label_image(self.item_type))
		self.header_hbox.addWidget(self.header)
		self.header_hbox.addStretch()
		self.header_hbox.setContentsMargins(0, 5, 0, 10)

		# Edit script button
		button = QtGui.QPushButton(self.experiment.icon(u"script"), u"")
		button.setToolTip(_(u"Edit script"))
		button.setIconSize(QtCore.QSize(16, 16))
		QtCore.QObject.connect(button, QtCore.SIGNAL(u"clicked()"), \
			self.open_script_tab)
		self.header_hbox.addWidget(button)

		# Help button
		button = QtGui.QPushButton(self.experiment.icon(u"help"), u"")
		button.setToolTip(_(u"Tell me more about the %s item") % self.item_type)
		button.setIconSize(QtCore.QSize(16, 16))
		QtCore.QObject.connect(button, QtCore.SIGNAL(u"clicked()"), \
			self.open_help_tab)
		self.header_hbox.addWidget(button)

		self.header_widget = QtGui.QWidget()
		self.header_widget.setLayout(self.header_hbox)

		# The edit_grid is the layout that contains the actual controls for the
		# items.
		self.edit_grid = QtGui.QGridLayout()
		self.edit_grid.setColumnStretch(2, 2)
		self.edit_grid_widget = QtGui.QWidget()
		self.edit_grid.setMargin(0)
		self.edit_grid_widget.setLayout(self.edit_grid)

		# The edit_vbox contains the edit_grid and the header widget
		self.edit_vbox = QtGui.QVBoxLayout()
		self.edit_vbox.setMargin(5)
		self.edit_vbox.addWidget(self.header_widget)
		self.edit_vbox.addWidget(self.user_hint_widget)
		self.edit_vbox.addWidget(self.edit_grid_widget)
		if stretch:
			self.edit_vbox.addStretch()
		self._edit_widget = QtGui.QWidget()
		self._edit_widget.setLayout(self.edit_vbox)
		self._edit_widget.__edit_item__ = self.name

		return self._edit_widget

	def edit_widget(self, stretch=True):

		"""
		A dummy edit widget, to be overridden.

		Keywords arguments:
		stretch		--	DEPRECATED (default=True)
		"""

		if not stretch:
			debug.msg(u"passing the stretch argument is deprecated", \
				reason=u"deprecation")
		self.user_hint_widget.clear()
		self.header.restore_name(False)
		self.header.refresh()
		self._edit_widget.__edit_item__ = self.name
		if not self.sanity_check():
			self.open_script_tab()
			return
		self.auto_edit_widget()
		self.user_hint_widget.refresh()
		return self._edit_widget

	def apply_name_change(self, rebuild=True):

		"""
		Apply an item name change

		Keywords arguments:
		rebuild -- a deprecated argument (default=True)
		"""

		debug.msg()

		# Sanitize the name, check if it is new and valid, and if so, rename
		new_name = self.experiment.sanitize(self.header.edit_name.text(), \
			strict=True, allow_vars=False)
		if new_name.lower() != self.name.lower():
			valid = self.experiment.check_name(new_name)
			if valid != True:
				self.experiment.notify(valid)
				self.header.edit_name.setText(self.name)
				return
		old_name = self.name
		self.name = new_name
		self._edit_widget.__edit_item__	= new_name
		self.experiment.main_window.dispatch.event_name_change.emit(old_name, \
			new_name)

	def apply_edit_changes(self, rebuild=True):

		"""
		Applies the GUI controls.

		Keywords arguments:
		rebuild	--	Specifies whether the overview area (item list) should be
					rebuild. (default=True)
		"""

		debug.msg(self.name)
		if self.experiment.main_window.lock_refresh:
			debug.msg(u"skipping, because refresh in progress")
			return False
		self.auto_apply_edit_changes()
		self.set(u"description", \
			self.experiment.sanitize(unicode( \
				self.header.edit_desc.text()).strip()))
		if self.description == u"":
			self.description = u"No description"
		self.header.label_desc.setText(self.description)
		self.experiment.main_window.dispatch.event_simple_change.emit(self.name)
		return True

	def close_edit_tab(self, index=None):

		"""
		Closes the edit tab (does nothing by default).

		Keywords arguments:
		index	--	The index of the tab in the tab area. (default=None)
		"""

		pass

	def open_edit_tab(self, index=None, focus=True):

		"""
		Opens the GUI control tab, or switches to the tab if it was already
		open.

		Keywords arguments:
		index	--	The index of the tab (if open). (default=None)
		focus	--	Indicates whether the tab should receive focus.
					(default=True)
		"""

		debug.msg(u"%s (#%s)" % (self.name, hash(self)))

		# Switch to edit mode and close the script tab if it was open
		self.edit_mode = u"edit"
		for i in range(self.experiment.ui.tabwidget.count()):
			w = self.experiment.ui.tabwidget.widget(i)
			if hasattr(w, u"__script_item__") and w.__script_item__ == \
				self.name:
				self.experiment.ui.tabwidget.removeTab(i)
				if index == None:
					index = i
				break

		# Focus the edit tab, instead of reopening, if it was already open
		for i in range(self.experiment.ui.tabwidget.count()):
			w = self.experiment.ui.tabwidget.widget(i)
			if hasattr(w, u"__edit_item__") and w.__edit_item__ == self.name:
				index = i

		# Refresh the controls on the tab. In debug mode don't catch any errors
		if debug.enabled:
			widget = self.edit_widget()
		else:
			try:
				widget = self.edit_widget()
			except Exception as e:
				self.experiment.notify(_(u"%s (Edit the script to fix this)") \
					% e)
				self.open_script_tab()
				return

		# Open the tab or focus the tab if it was already open
		if index == None:
			self.edit_tab_index = self.experiment.ui.tabwidget.addTab(widget, \
				self.experiment.icon(self.item_type), u"%s" % self.name)
		else:
			self.experiment.ui.tabwidget.insertTab(index, widget, \
				self.experiment.icon(self.item_type), u"%s" % self.name)
			self.edit_tab_index = index
		if focus:
			self.experiment.ui.tabwidget.setCurrentIndex(self.edit_tab_index)

	def apply_script_and_close(self):

		"""Applies script changes and opens the edit tab"""

		self.apply_script_changes(mode=u'edit')
		self.experiment.main_window.select_item(self.name)

	def apply_script_changes(self, rebuild=True, catch=True, mode=u'script'):

		"""
		Applies changes to the script, by regenerating the item from the script.

		Keywords arguments:
		rebuild	--	Specifies whether the overview area (item list) should be
					rebuild. (default=True)
		catch	--	Indicates whether exceptions should be caught and shown in a
					notification dialog (True) or not be caught (False).
					(default=True)
		mode	--	Indicates whether the item should re-open in edit or script
					mode. (default=u'script')
		"""

		debug.msg(self.name)
		script = self.script_qprogedit.text()
		# Create a new item and make it a clone of the current item
		item = self.experiment.main_window.add_item(self.item_type, False, \
			name=self.name, interactive=False)
		if catch:
			try:
				self.experiment.items[item].from_string(script)
			except Exception as e:
				self.experiment.notify(unicode(e))
				return
		else:
			self.experiment.items[item].from_string(script)
		self.experiment.items[item].name = self.name
		# Replace the current item
		self.experiment.items[self.name] = self.experiment.items[item]
		del self.experiment.items[item]
		self.experiment.items[self.name].init_script_widget()
		self.experiment.items[self.name].edit_mode = mode
		self.experiment.main_window.dispatch.event_script_change.emit(self.name)
		# The logic here is pretty complex, and is more-or-less a hack until the
		# event handling code has been improved. Basically, if we want to apply
		# the script and stay in script mode, we have to re-open the script tab,
		# because the entire item is re-generated. This new tab has to be
		# inserted in place of (i.e. with the same index as) the old tab, which
		# has to be removed. We always refocus the tab, but if the tab doesn't
		# actually have focus, we refocus the original tab. This is necessary
		# to avoid repainting artifacts.
		#
		# See also this issue:
		# - <https://github.com/smathot/OpenSesame/issues/219>
		if mode == u'script':
			currentIndex = self.experiment.ui.tabwidget.currentIndex()
			for i in range(self.experiment.ui.tabwidget.count()):
				w = self.experiment.ui.tabwidget.widget(i)
				if hasattr(w, u'__script_item__') and w.__script_item__ == \
					self.name:
					if i == currentIndex:
						focus = True
					else:
						focus = False
					self.experiment.items[self.name].open_script_tab(index=i, \
						focus=True)
					self.experiment.ui.tabwidget.removeTab(i+1)
					if not focus:
						self.experiment.ui.tabwidget.setCurrentIndex( \
							currentIndex)
					break

	def strip_script_line(self, s):

		"""
		Strips unwanted characters from a line of script

		Arguments:
		s -- a line of script

		Returns:
		A stripped line of script
		"""

		if len(s) > 0 and s[0] == u"\t":
			return s[1:] + u"\n"
		return s + u"\n"

	def init_script_widget(self):

		"""Build the script tab"""

		from QProgEdit import QTabManager
		self.script_qprogedit = QTabManager(handler= \
			self.apply_script_and_close, defaultLang=u'OpenSesame', \
			handlerButtonText=_(u'Apply and close script editor'), \
			focusOutHandler=self.apply_script_changes, cfg=cfg)
		self.script_qprogedit.addTab(u'Script')

		hbox = QtGui.QHBoxLayout()
		hbox.addWidget(self.experiment.label_image(self.item_type))
		self.script_header = QtGui.QLabel()
		hbox.addWidget(self.script_header)
		hbox.addStretch()
		hbox.setContentsMargins(0,0,0,0)
		hwidget = QtGui.QWidget()
		hwidget.setLayout(hbox)

		vbox = QtGui.QVBoxLayout()
		vbox.addWidget(hwidget)
		vbox.addWidget(self.script_qprogedit)
		self._script_widget = QtGui.QWidget()
		self._script_widget.setLayout(vbox)
		self._script_widget.__script_item__ = self.name

	def script_widget(self):

		"""
		Update the script tab

		Returns:
		The QWidget containing the script tab
		"""

		self.script_header.setText( \
			_(u"Editing script for <b>%s</b> - %s") % (self.name, \
			self.item_type))
		script = u""
		for s in self.to_string().split(u"\n")[1:]:
			script += self.strip_script_line(s)
		self.script_qprogedit.setText(script)
		self._script_widget.__script_item__ = self.name
		return self._script_widget

	def open_script_tab(self, index=None, focus=True):

		"""
		Open/ show the script tab

		Keywords arguments:
		index -- the index of the tab (if it is already open) (default=None)
		focus -- indicates whether the tab should receive focus (default=True)
		"""

		debug.msg(u"%s (#%s)" % (self.name, hash(self)))
		self.edit_mode = u"script"

		# Close the edit tab
		for i in range(self.experiment.ui.tabwidget.count()):
			w = self.experiment.ui.tabwidget.widget(i)
			if hasattr(w, u"__edit_item__") and w.__edit_item__ == self.name:
				self.experiment.ui.tabwidget.removeTab(i)
				if index == None:
					index = i
				break

		for i in range(self.experiment.ui.tabwidget.count()):
			w = self.experiment.ui.tabwidget.widget(i)
			if hasattr(w, u"__script_item__") and w.__script_item__ == self.name:
				index = i
		if index == None:
			self.script_tab_index = self.experiment.ui.tabwidget.addTab( \
				self.script_widget(), self.experiment.icon(u"script"), u"%s" \
				% self.name)
		else:
			self.script_tab_index = index
			self.experiment.ui.tabwidget.insertTab(index, \
				self.script_widget(), self.experiment.icon(u"script"), u"%s" \
				% self.name)
		if focus:
			self.experiment.ui.tabwidget.setCurrentIndex(self.script_tab_index)

	def close_script_tab(self, index=None):

		"""
		Close the script tab (does nothing by defaut)

		Keywords arguments:
		index -- the index of the tab in the tab area (default=None)
		"""

		pass

	def rename(self, from_name, to_name):

		"""
		Handle the renaming of an item (not necesarrily the currnet item)

		Arguments:
		from_name -- the old item name
		to_name -- the new item name
		"""

		if self.name == from_name:
			self.name = to_name

	def delete(self, item_name, item_parent=None, index=None):

		"""
		Delete an item (not necessarily the current one)

		Arguments:
		item_name -- the name of the item to be deleted

		Keywords arguments:
		item_parent -- the parent item (default=None)
		index -- the index of the item in the parent (default=None)
		"""

		pass

	def rename_var(self, item, from_name, to_name):

		"""
		A notification that a variable has been renamed

		Arguments:
		item -- the item doing the renaming
		from_name -- the old variable name
		to_name -- the new variable name
		"""

		pass

	def item_tree_widget(self, toplevel, icon=None, name=None, tooltip=None):

		"""
		Create a single item tree widget

		Arguments:
		toplevel -- the toplevel item

		Keyword arguments:
		icon -- an icon name or None for default (default=None)
		name -- the name of the item or None for default (default=None)
		tooltip -- the tooltip or None for default (default=None)

		Returns:
		A QTreeWidgetItem
		"""

		if name == None:
			name = self.name
		if icon == None:
			icon = self.item_type
		if tooltip == None:
			tooltip = _(u"Type: %s\nDescription: %s") % (self.item_type, \
				self.description)
		font = QtGui.QFont()
		font.setPointSize(8)
		font.setItalic(True)
		widget = QtGui.QTreeWidgetItem(toplevel)
		widget.setText(0, name)
		widget.setIcon(0, self.experiment.icon(icon))
		widget.name = name
		widget.setToolTip(0, tooltip)
		return widget

	def build_item_tree(self, toplevel=None, items=[]):

		"""
		Construct an item tree

		Keyword arguments:
		toplevel -- the toplevel widget (default = None)
		items -- a list of items that have been added, to prevent recursion
				 (default=[])
		"""

		toplevel.addChild(self.item_tree_widget(toplevel))

	def is_offspring(self, item):

		"""
		Checks if the item is offspring of the current item, in the sense that
		the current item is contained by the item

		Arguments:
		item -- the potential offspring

		Returns:
		True if the current item is offspring of the item, False otherwise
		"""

		return False

	def parents(self):

		"""
		Creates a list of all the items	that the current sequences is connected
		to upstream

		Returns:
		A list of item names
		"""

		l = [self.name]
		for item in self.experiment.items:
			if self.experiment.items[item].is_offspring(self.name):
				l.append(item)
		return l

	def variable_vars(self, exclude=[]):

		"""
		Determines if one of the variables of the current item is defined in
		terms of another variable

		Keywords arguments:
		exclude -- a list of variables that should not be checked

		Returns:
		True if there are variably defined variables, False otherwise
		"""

		for var in self.variables:
			if var not in exclude:
				val = self.variables[var]
				if isinstance(val, basestring) and u'[' in val:
					return True
		return False

	def get_ready(self):

		"""
		This function should be overridden to do any last-minute stuff that
		and item should do before an experiment is actually run, such as
		applying pending script changes.

		Returns:
		True if some action has been taken, False if nothing was done
		"""

		if self.script_qprogedit.isModified():
			debug.msg(u'applying pending script changes')
			self.apply_script_changes(catch=False)
			return True
		return False

	def auto_edit_widget(self):

		"""Update the GUI controls based on the auto-widgets"""

		debug.msg()
		for var, edit in self.auto_line_edit.iteritems():
			edit.editingFinished.disconnect()
			if self.has(var):
				edit.setText(self.unistr(self.get(var, _eval=False)))
			else:
				edit.setText(u'')
			edit.editingFinished.connect(self.apply_edit_changes)

		for var, combobox in self.auto_combobox.iteritems():
			combobox.currentIndexChanged.disconnect()
			val = self.get_check(var, _eval=False, default=u'')
			i = combobox.findText(self.unistr(self.get(var, _eval=False)))
			# Set the combobox to the select item
			if i >= 0:
				combobox.setDisabled(False)
				combobox.setCurrentIndex(i)
			# If no value was specified, set the combobox to a blank item
			elif val == u'':
				combobox.setDisabled(False)
				combobox.setCurrentIndex(-1)
			# If an unknown value has been specified, notify the user
			else:
				combobox.setDisabled(True)
				self.user_hint_widget.add_user_hint(_(u'"%s" is set to a '
					u'variable or unknown value and can only be edited through '
					u'the script.' % var))
			combobox.currentIndexChanged.connect(self.apply_edit_changes)

		for var, spinbox in self.auto_spinbox.iteritems():
			spinbox.editingFinished.disconnect()
			if self.has(var):
				val = self.get(var, _eval=False)
				if type(val) in (float, int):
					try:
						spinbox.setValue(val)
					except Exception as e:
						self.experiment.notify(_( \
							u"Failed to set control '%s': %s") % (var, e))
				else:
					spinbox.setDisabled(True)
					self.user_hint_widget.add_user_hint(_( \
						u'"%s" is defined using variables and can only be edited through the script.' \
						% var))
			spinbox.editingFinished.connect(self.apply_edit_changes)

		for var, slider in self.auto_slider.iteritems():
			slider.valueChanged.disconnect()
			if self.has(var):
				val = self.get(var, _eval=False)
				if type(val) in (float, int):
					try:
						slider.setValue(val)
					except Exception as e:
						self.experiment.notify(_( \
							u"Failed to set control '%s': %s") % (var, e))
				else:
					slider.setDisabled(True)
					self.user_hint_widget.add_user_hint(_( \
						u'"%s" is defined using variables and can only be edited through the script.' \
						% var))
			slider.valueChanged.connect(self.apply_edit_changes)

		for var, checkbox in self.auto_checkbox.iteritems():
			checkbox.toggled.disconnect()
			if self.has(var):
				try:
					checkbox.setChecked(self.get(var, _eval=False) == u"yes")
				except Exception as e:
					self.experiment.notify(_(u"Failed to set control '%s': %s") \
						% (var, e))
			checkbox.toggled.connect(self.apply_edit_changes)

		for var, qprogedit in self.auto_editor.iteritems():
			if self.has(var):
				try:
					qprogedit.setText(self.unistr(self.get(var, _eval=False)))
				except Exception as e:
					self.experiment.notify(_(u"Failed to set control '%s': %s") \
						% (var, e))

	def sanitize_check(self, s, strict=False, allow_vars=True, notify=True):

		"""
		Checks whether a string is sane (i.e. unchanged by sanitize()) and
		optionally presents a warning.

		Arguments:
		s			--	The string to check.

		Keyword arguments:
		strict		--	See sanitize().
		allow_vars	--	See sanitize().
		notify		--	Indicates whether a notification should be presented if
						the string is not sane.

		Returns:
		True if s is sane, False otherwise.
		"""

		sane = s == self.sanitize(s, strict=strict, allow_vars=allow_vars)
		if not sane and notify:
			if strict:
				self.experiment.notify(
					_(u'All non-alphanumeric characters except underscores have been stripped'))
			else:
				self.experiment.notify(
					_(u'The following characters are not allowed and have been stripped: double-quote ("), backslash (\), and newline'))
		return sane

	def sanity_check(self):

		"""
		Checks whether all variables match prespecified criteria and fall back
		to the script editor otherwise. This is usefull to check that certain
		variables are numeric, etc.
		"""

		debug.msg()
		errors = []
		for var_name, criteria in self.sanity_criteria.items():
			msg = _(u"Invalid or missing value for variable '%s' (edit script to fix this)") \
				% var_name
			if u'msg' in criteria:
				msg += u': ' + criteria[u'msg']
			if not self.has(var_name) and u'required' in criteria and \
				criteria[u'required']:
				self.experiment.notify(msg)
				return False
			else:
				var = self.get(var_name, _eval=False)
				if u'type' in criteria:
					_type = criteria[u'type']
					if type(_type) != list:
						_type = [_type]
				 	if type(var) not in _type:
						self.experiment.notify(msg)
						return False
				if u'func' in criteria:
					if not criteria[u'func'](var):
						self.experiment.notify(msg)
						return False
		return True

	def auto_apply_edit_changes(self, rebuild=True):

		"""
		Apply the auto-widget controls

		Keyword arguments:
		rebuild -- deprecated (does nothing) (default=True)
		"""

		debug.msg()
		for var, edit in self.auto_line_edit.iteritems():
			if edit.isEnabled() and isinstance(var, basestring):
				val = unicode(edit.text()).strip()
				if val != u"":
					self.set(var, val)

				# If the variable has no value, we assign a default value if it
				# has been specified, and unset it otherwise.
				elif hasattr(edit, u"default"):
					self.set(var, edit.default)
				else:
					self.unset(var)

		for var, combobox in self.auto_combobox.iteritems():
			if combobox.isEnabled() and isinstance(var, basestring):
				self.set(var, unicode(combobox.currentText()))

		for var, spinbox in self.auto_spinbox.iteritems():
			if spinbox.isEnabled() and isinstance(var, basestring):
				self.set(var, spinbox.value())

		for var, slider in self.auto_slider.iteritems():
			if slider.isEnabled() and isinstance(var, basestring):
				self.set(var, slider.value())

		for var, checkbox in self.auto_checkbox.iteritems():
			if checkbox.isEnabled() and isinstance(var, basestring):
				if checkbox.isChecked():
					val = u"yes"
				else:
					val = u"no"
				self.set(var, val)

		for var, qprogedit in self.auto_editor.iteritems():
			if isinstance(var, basestring):
				self.set(var, qprogedit.text())

		return True

	def auto_add_widget(self, widget, var=None):

		"""
		Add a widget to the list of auto-widgets

		Arguments:
		widget -- a QWidget

		Keyword arguments:
		var -- the variable to be linked to the widget (default=None)
		"""

		# Use the object id as a fallback name
		if var == None:
			var = id(widget)
		debug.msg(var)

		if isinstance(widget, QtGui.QSpinBox) or isinstance(widget, \
			QtGui.QDoubleSpinBox):
			widget.editingFinished.connect(self.apply_edit_changes)
			self.auto_spinbox[var] = widget

		elif isinstance(widget, QtGui.QComboBox):
			widget.currentIndexChanged.connect(self.apply_edit_changes)
			self.auto_combobox[var] = widget

		elif isinstance(widget, QtGui.QSlider):
			widget.editingFinished.connect(self.apply_edit_changes)
			self.auto_slider[var] = widget

		elif isinstance(widget, QtGui.QLineEdit):
			widget.editingFinished.connect(self.apply_edit_changes)
			self.auto_line_edit[var] = widget

		elif isinstance(widget, QtGui.QCheckBox):
			widget.toggled.connect(self.apply_edit_changes)
			self.auto_checkbox[var] = widget

		else:
			raise Exception(u"Cannot auto-add widget of type %s" % widget)

	def clean_cond(self, cond, default=u'always'):

		"""
		Cleans a conditional statement. May raise a dialog box if problems are
		encountered.

		Arguments:
		cond	--	A (potentially filthy) conditional statement.

		Keyword arguments:
		default	--	A default value to use for empty

		Returns:
		cond	--	A clean conditional statement conditional statements.
					(default=u'always')
		"""

		cond = self.unistr(cond)
		if not self.sanitize_check(cond):
			cond = self.sanitize(cond)
		if cond.strip() == u'':
			cond = default
		try:
			self.compile_cond(cond)
		except osexception as e:
			self.experiment.notify( \
				u'Failed to compile conditional statement "%s": %s' % (cond, e))
		return cond

########NEW FILE########
__FILENAME__ = qtplugin
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
import sys
from PyQt4 import QtCore, QtGui
from libqtopensesame.items import qtitem
from libqtopensesame.misc import _
from libqtopensesame.widgets import color_edit, pool_widget
from libopensesame import debug, misc
from libqtopensesame.misc.config import cfg

class qtplugin(qtitem.qtitem):

	"""Provides basic functionality for plugin GUIs"""

	def __init__(self, plugin_file=None):

		"""
		Constructor.

		Arguments:
		plugin_file		-- The path to the plugin script. (default=None)
		"""

		if plugin_file != None:
			# The __file__ variable is generally a str, which will cause unicode
			# errors. Therefore, convert this here if necessary.
			if isinstance(plugin_file, str):
				plugin_file = plugin_file.decode(misc.filesystem_encoding())
			# These lines makes sure that the icons and help file are recognized
			# by OpenSesame.
			self.plugin_folder = os.path.dirname(plugin_file)
			self.experiment.resources[u'%s.png' % self.item_type] = \
				os.path.join(self.plugin_folder, u'%s.png' % self.item_type)
			self.experiment.resources[u'%s_large.png' % self.item_type] = \
				os.path.join(self.plugin_folder, u'%s_large.png' \
				% self.item_type)
			self.experiment.resources[u'%s.html' % self.item_type] = \
				os.path.join(self.plugin_folder, u'%s.html' \
				% self.item_type)
			self.experiment.resources[u'%s.md' % self.item_type] = \
				os.path.join(self.plugin_folder, u'%s.md' \
				% self.item_type)
		self.lock = False
		qtitem.qtitem.__init__(self)

	def edit_widget(self):

		"""Updates the GUI controls."""

		qtitem.qtitem.edit_widget(self)
		self.auto_edit_widget()

	def apply_edit_changes(self, rebuild=True):

		"""
		Applies the controls.

		Keyword arguments:
		rebuild		-- DEPRECATED
		"""

		return qtitem.qtitem.apply_edit_changes(self, rebuild) and \
			self.auto_apply_edit_changes(rebuild)

	def add_control(self, label, widget, tooltip=None, min_width=None):

		"""
		Adds a generic control QWidget.

		Arguments:
		label		--	A text label.
		widget		--	A control QWidget.

		Keyword arguments:
		tooltip		--	A tooltip text. (default=None)
		min_width	--	A minimum width for the widget. (default=None)
		"""

		if tooltip != None:
			try:
				widget.setToolTip(_(tooltip))
			except:
				pass
		if type(min_width) == int:
			widget.setMinimumWidth(min_width)
		row = self.edit_grid.rowCount()
		self.edit_grid.addWidget(QtGui.QLabel(_(label)), row, 0)
		self.edit_grid.addWidget(widget, row, 1)

	def add_line_edit_control(self, var, label, tooltip=None, default=None, \
		min_width=None):

		"""
		Adds a QLineEdit control that is linked to a variable.

		Arguments:
		var			--	Name of the associated variable.
		label 		--	Label text.

		Keyword arguments:
		tooltip 	--	A tooltip text. (default=None)
		default 	--	DEPRECATED
		min_width 	--	A minimum width for the widget. (default=None)

		Returns:
		A QLineEdit widget.
		"""

		edit = QtGui.QLineEdit()
		edit.editingFinished.connect(self.apply_edit_changes)
		self.add_control(label, edit, tooltip, min_width)
		if var != None:
			self.auto_line_edit[var] = edit
		return edit

	def add_checkbox_control(self, var, label, tooltip=None):

		"""
		Adds a QCheckBox control that is linked to a variable.

		Arguments:
		var			--	Name of the associated variable.
		label 		--	Label text.

		Keyword arguments:
		tooltip 	--	A tooltip text. (default=None)

		Returns:
		A QCheckBox widget.
		"""

		checkbox = QtGui.QCheckBox(_(label))
		checkbox.toggled.connect(self.apply_edit_changes)
		self.add_control('', checkbox, tooltip)
		if var != None:
			self.auto_checkbox[var] = checkbox
		return checkbox

	def add_color_edit_control(self, var, label, tooltip=None, default=None, \
		min_width=None):

		"""
		Adds a colorpicker control, consisting of a QLineEdit and QColorDialog.
		Some basic checking is done to ascertain that only valid color names or
		variably defined entries are accepted.

		Arguments:
		var			--	Name of the associated variable.
		label 		--	Label text.

		Keyword arguments:
		tooltip 	--	A tooltip text. (default=None)
		default 	--	DEPRECATED
		min_width 	--	A minimum width for the widget. (default=None)

		Returns:
		A color_edit widget.
		"""

		edit = color_edit.color_edit()
		edit.initialize(self.experiment)
		QtCore.QObject.connect(edit, QtCore.SIGNAL('set_color'), \
			self.apply_edit_changes)
		self.add_control(label, edit, tooltip, min_width)
		if var != None:
			self.auto_line_edit[var] = edit
		return edit

	def add_combobox_control(self, var, label, options, tooltip=None):

		"""
		Adds a QComboBox control that is linked to a variable.

		Arguments:
		var			-- 	Name of the associated variable.
		label 		--	Label text.
		options 	--	A list of options.

		Keyword arguments:
		tooltip 	--	A tooltip text. (default=None)

		Returns:
		A QComboBox widget.
		"""

		combobox = QtGui.QComboBox()
		for o in options:
			combobox.addItem(o)
		combobox.currentIndexChanged.connect(self.apply_edit_changes)
		self.add_control(label, combobox, tooltip)
		if var != None:
			self.auto_combobox[var] = combobox
		return combobox

	def add_spinbox_control(self, var, label, min_val, max_val, prefix=u'', \
		suffix=u'', tooltip=None):

		"""
		Adds a QSpinBox control that is linked to a variable.

		Arguments:
		var			-- 	Name of the associated variable.
		label 		-- 	Label text.
		min_val 	-- 	A minimum value.
		max_val 	-- 	A maximum value.

		Keyword arguments:
		prefix 		-- 	A prefix text. (default=u'')
		suffix 		-- 	A suffix text. (default=u'')
		tooltip 	-- 	A tooltip text. (default=None)

		Returns:
		A QSpinBox widget.
		"""

		spinbox = QtGui.QSpinBox()
		spinbox.setMinimum(min_val)
		spinbox.setMaximum(max_val)
		spinbox.editingFinished.connect(self.apply_edit_changes)
		if prefix != u'':
			spinbox.setPrefix(prefix)
		if suffix != u'':
			spinbox.setSuffix(suffix)
		self.add_control(label, spinbox, tooltip)
		if var != None:
			self.auto_spinbox[var] = spinbox
		return spinbox

	def add_slider_control(self, var, label, min_val, max_val, left_label=u'', \
		right_label=u'', tooltip=None, default=None):

		"""
		Adds a QSlider control that is linked to a variable.

		Arguments:
		var			--	Name of the associated variable.
		label 		--	Label text.
		min_val 	--	A minimum value.
		max_val 	--	A maximum value.

		Keyword arguments:
		left_label 	--	A label for the left side (default="")
		right_label	--	A label for the right side (default="")
		tooltip		--	A tooltip text. (default=None)
		default		--	DEPRECATED

		Returns:
		A QSlider widget.
		"""

		slider = QtGui.QSlider(QtCore.Qt.Horizontal)
		slider.setFocusPolicy(QtCore.Qt.NoFocus)
		slider.setGeometry(30, 40, 100, 30)
		slider.setRange(min_val, max_val)
		slider.setSingleStep(1000)
		#Take care of layout
		layout = QtGui.QHBoxLayout()
		layout.setMargin(0)
		layout.setSpacing(5)
		if left_label:
			llabel = QtGui.QLabel()
			llabel.setText(left_label)
			layout.addWidget(llabel)
		layout.addWidget(slider)
		if right_label:
			rlabel = QtGui.QLabel()
			rlabel.setText(right_label)
			layout.addWidget(rlabel)
		slider.valueChanged.connect(self.apply_edit_changes)
		if var != None:
			self.auto_slider[var] = slider
		widget = QtGui.QWidget()
		widget.setLayout(layout)
		self.add_control(label, widget, tooltip)
		return slider

	def add_filepool_control(self, var, label, click_func=None, tooltip=None, \
		default=None):

		"""
		Adds a control to select a file from the file pool, and is linked to a
		variable.

		Arguments:
		var			--	Name of the associated variable.
		label 		--	Label text.

		Keyword arguments:
		click_func 	--	A custom function to be called when a file is selected.
						If no click_func is specified, file selection will be
						handled automatically. (default=None)
		tooltip 	--	A tooltip text. (default=None)
		default		--	DEPRECATED

		Returns:
		A QLineEdit widget that contains the path of the selected file.
		"""

		edit = QtGui.QLineEdit()
		edit.editingFinished.connect(self.apply_edit_changes)
		if var != None:
			self.auto_line_edit[var] = edit
		if click_func == None:
			click_func = self.browse_pool_func(edit)
		button = QtGui.QPushButton(self.experiment.icon(u'browse'), u'Browse')
		button.setIconSize(QtCore.QSize(16, 16))
		button.clicked.connect(click_func)
		hbox = QtGui.QHBoxLayout()
		hbox.setMargin(0)
		hbox.addWidget(edit)
		hbox.addWidget(button)
		widget = QtGui.QWidget()
		widget.setLayout(hbox)
		self.add_control(label, widget, tooltip)
		return edit

	def add_editor_control(self, var, label, syntax=False, tooltip=None, \
		default=None):

		"""
		Adds a QProgEdit that is linked to a variable.

		Arguments:
		var			--	Name of the associated variable.
		label 		--	Label text.

		Keyword arguments:
		syntax 		--	A boolean indicating whether Python syntax highlighting
						should be activated. (default=False)
		tooltip		--	A tooltip text. (default=None)
		default		--	DEPRECATED

		Returns:
		A QProgEdit widget.
		"""

		from QProgEdit import QTabManager
		if syntax:
			lang = u'python'
		else:
			lang = u'text'
		qprogedit = QTabManager(handler=self.apply_edit_changes, defaultLang= \
			lang, cfg=cfg, focusOutHandler=self.apply_edit_changes)
		qprogedit.addTab(label)
		if var != None:
			self.auto_editor[var] = qprogedit
		self.edit_vbox.addWidget(qprogedit)
		return qprogedit

	def add_text(self, msg):

		"""
		Adds a non-interactive QLabel for description purposes.

		Arguments:
		msg		--	A text message.

		Returns:
		A QLabel widget.
		"""

		row = self.edit_grid.rowCount()
		label = QtGui.QLabel(_(msg))
		label.setWordWrap(True)
		self.edit_vbox.addWidget(label)
		return label

	def add_stretch(self):

		"""Pad empty space below the controls"""

		self.edit_vbox.addStretch()

	def apply_button(self, label=u'Apply', icon=u'apply', \
		tooltip=u'Apply changes'):

		"""
		Returns a right-outlined apply QPushButton. The widget is not added
		automatically to the controls. I.e. you need to implement your own
		connections to make the button functional.

		Keyword arguments:
		label		-- A label text. (default=u'Apply')
		icon		-- An icon name. (default=u'Apply')
		tooltip		-- A tooltip text. (default=u'Apply changes')

		Returns:
		A QPushButton widget.
		"""

		button_apply = QtGui.QPushButton(_(label))
		button_apply.setIcon(self.experiment.icon(icon))
		button_apply.setIconSize(QtCore.QSize(16, 16))
		button_apply.clicked.connect(self.apply_edit_changes)
		button_apply.setToolTip(tooltip)
		hbox = QtGui.QHBoxLayout()
		hbox.setContentsMargins(0, 0, 0, 0)
		hbox.addStretch()
		hbox.addWidget(button_apply)
		widget = QtGui.QWidget()
		widget.setLayout(hbox)
		return widget

	def browse_pool_func(self, edit_widget):

		"""
		Returns a function to present a file dialog to browse the file pool.

		Arguments:
		edit_widget		--	A QLineEdit widget.

		Returns:
		A function that presents a filepool dialog and sets the edit_widget.
		"""

		def browse_pool():
			s = pool_widget.select_from_pool(self.experiment.main_window)
			if unicode(s) == "":
				return
			edit_widget.setText(s)
			self.apply_edit_changes()
		return browse_pool

	def get_ready(self):

		"""
		Applies pending script changes.

		Returns:
		True if changes have been made, False otherwise.
		"""

		for var, qprogedit in self.auto_editor.iteritems():
			if qprogedit.isModified():
				debug.msg(u'applying pending editor changes')
				self.apply_edit_changes()
				return True
		return qtitem.qtitem.get_ready(self)


########NEW FILE########
__FILENAME__ = sampler
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import libopensesame.sampler
from libqtopensesame.misc import _
from libqtopensesame.items import qtitem
from libqtopensesame.ui import sampler_widget_ui
from libqtopensesame.widgets import pool_widget
from PyQt4 import QtCore, QtGui

class sampler(libopensesame.sampler.sampler, qtitem.qtitem):

	"""GUI controls for the sampler item"""

	def __init__(self, name, experiment, string=None):
	
		"""
		Constructor
		
		Arguments:
		name -- the item name
		experiment -- the experiment
		
		Keywords arguments:
		string -- definition string (default=None)
		"""
		
		libopensesame.sampler.sampler.__init__(self, name, experiment, string)
		qtitem.qtitem.__init__(self)	
		self.lock = False			
				
	def init_edit_widget(self):
	
		"""Build the GUI controls"""
		
		qtitem.qtitem.init_edit_widget(self, False)
				
		self.sampler_widget = QtGui.QWidget()
		self.sampler_widget.ui = sampler_widget_ui.Ui_sampler_widget()
		self.sampler_widget.ui.setupUi(self.sampler_widget)
		self.experiment.main_window.theme.apply_theme(self.sampler_widget)
		
		self.sampler_widget.ui.spin_pan.valueChanged.connect( \
			self.apply_edit_changes)
		self.sampler_widget.ui.spin_volume.valueChanged.connect( \
			self.apply_edit_changes)
		self.sampler_widget.ui.spin_pitch.valueChanged.connect( \
			self.apply_edit_changes)
		self.sampler_widget.ui.spin_stop_after.valueChanged.connect( \
			self.apply_edit_changes)		
		self.sampler_widget.ui.spin_fade_in.valueChanged.connect( \
			self.apply_edit_changes)
		self.sampler_widget.ui.edit_duration.editingFinished.connect( \
			self.apply_edit_changes)		
		self.sampler_widget.ui.edit_sample.editingFinished.connect( \
			self.apply_edit_changes)			
		self.sampler_widget.ui.button_browse_sample.clicked.connect( \
			self.browse_sample)
		self.sampler_widget.ui.dial_pan.valueChanged.connect(self.apply_dials)
		self.sampler_widget.ui.dial_volume.valueChanged.connect( \
			self.apply_dials)
		self.sampler_widget.ui.dial_pitch.valueChanged.connect(self.apply_dials)
							
		self.edit_vbox.addWidget(self.sampler_widget)
		self.edit_vbox.addStretch()
					
	def browse_sample(self):
	
		"""Present a file dialog to browse for the sample"""
		
		s = pool_widget.select_from_pool(self.experiment.main_window)
		if unicode(s) == "":
			return			
		self.sampler_widget.ui.edit_sample.setText(s)
		self.apply_edit_changes()
		
	def edit_widget(self):
	
		"""
		Refresh the GUI controls
		
		Returns:
		A QWidget with the controls
		"""	
		
		self.lock = True		
		qtitem.qtitem.edit_widget(self)						
		if self.variable_vars(["sample", "duration"]):			
			self.user_hint_widget.add_user_hint(_( \
				'The controls are disabled, because one of the settings is defined using variables.'))
			self.user_hint_widget.refresh()
			self.sampler_widget.ui.frame_controls.setVisible(False)			
		else:		
			self.sampler_widget.ui.frame_controls.setVisible(True)					
			self.sampler_widget.ui.edit_sample.setText(self.unistr(self.get( \
				'sample', _eval=False)))
			self.sampler_widget.ui.edit_duration.setText(self.unistr(self.get( \
				'duration', _eval=False)))		
			self.sampler_widget.ui.spin_pan.setValue(self.get('pan', _eval= \
				False))
			self.sampler_widget.ui.spin_volume.setValue(100.0 * self.get( \
				'volume', _eval=False))
			self.sampler_widget.ui.spin_pitch.setValue(100.0 * self.get( \
				'pitch', _eval=False))
			self.sampler_widget.ui.spin_fade_in.setValue(self.get('fade_in', \
				_eval=False))
			self.sampler_widget.ui.spin_stop_after.setValue(self.get( \
				'stop_after', _eval=False))
			self.sampler_widget.ui.dial_pan.setValue(self.get('pan', _eval= \
				False))
			self.sampler_widget.ui.dial_volume.setValue(100.0 * self.get( \
				'volume', _eval=False))
			self.sampler_widget.ui.dial_pitch.setValue(100.0 * self.get( \
				'pitch', _eval=False))
		self.lock = False		
		return self._edit_widget

	def apply_edit_changes(self, dummy1=None, dummy2=None):
	
		"""
		Apply the GUI controls
		
		Keywords arguments:
		dummy1 -- a dummy argument (default=None)
		dummy2 -- a dummy argument (default=None)
		"""	
		
		if not qtitem.qtitem.apply_edit_changes(self, False) or self.lock:
			return		
		self.set("sample", unicode(self.sampler_widget.ui.edit_sample.text()))		
		dur = self.sanitize(self.sampler_widget.ui.edit_duration.text(), \
			strict=True)
		if dur == "":
			dur = "sound"
		self.set("duration", dur)					
		self.set("pan", self.sampler_widget.ui.spin_pan.value())
		self.set("pitch", .01 * self.sampler_widget.ui.spin_pitch.value())
		self.set("volume", .01 * self.sampler_widget.ui.spin_volume.value())
		self.set("fade_in", self.sampler_widget.ui.spin_fade_in.value())
		self.set("stop_after", self.sampler_widget.ui.spin_stop_after.value())
		
		self.experiment.main_window.refresh(self.name)			
						
	def apply_dials(self, dummy=None):
	
		"""
		Set the spinbox values based on the dials
		
		Keywords arguments:
		dummy -- a dummy argument (default=None)
		"""
		
		if self.lock:
			return
		self.set("pan", self.sampler_widget.ui.dial_pan.value())
		self.set("pitch", .01 * self.sampler_widget.ui.dial_pitch.value())
		self.set("volume", .01 * self.sampler_widget.ui.dial_volume.value())		
		self.edit_widget()

########NEW FILE########
__FILENAME__ = sequence
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import libopensesame.sequence
import libopensesame.plugins
from libqtopensesame.items import qtitem
from libqtopensesame.widgets import draggables
from libqtopensesame.misc import _
from PyQt4 import QtCore, QtGui
import sip

class action_button(QtGui.QPushButton):

	"""Used for the up/ down/ remove buttons in the sequence item list"""

	def __init__(self, sequence, icon, string, parent=None, tooltip=None):

		"""
		Constructor.

		Arguments:
		sequence	--	A sequence item.
		icon		--	The icon to be used.
		string		--	The text for the button.

		Keyword arguments:
		parent		--	A parent widget. (default=None)
		tooltip		--	A tooltip. (default=None)
		"""

		QtGui.QPushButton.__init__(self, icon, u'', parent)
		self.setToolTip(string)
		self.sequence = sequence
		self.setIconSize(QtCore.QSize(16, 16))
		self.clicked.connect(self.action)
		if tooltip != None:
			self.setToolTip(tooltip)

	def action(self):

		"""Handles a button click."""

		cmd, row = self.data
		if cmd == u"add":
			if row == u"existing":
				item = unicode(self.sequence.combobox_items.currentText())
				self.sequence.items.append( (item, u"always") )
			elif row == "new":
				item_type = unicode( \
					self.sequence.combobox_item_type.currentText())
				# The separator has been selected
				if item_type == "":
					return
				# The sequence and loop are a bit different, because they need
				# an extra dialog when they are created
				if item_type in (u"sequence", u"loop"):
					item = getattr(self.sequence.experiment.main_window, \
						u'add_%s' % item_type)(False, self.sequence.name)
				else:
					item = self.sequence.experiment.main_window.add_item( \
						item_type, False)
				# If the item has been created, add it to the sequence
				# and select it.
				if item != None:
					self.sequence.items.append( (item, u"always") )
					self.sequence.experiment.main_window.refresh( \
						self.sequence.name)
					self.sequence.experiment.main_window.select_item( \
						self.sequence.name)
				return
		self.sequence.experiment.main_window.refresh(self.sequence.name)

class sequence(libopensesame.sequence.sequence, qtitem.qtitem):

	"""GUI controls for the sequence item"""

	def __init__(self, name, experiment, string=None):

		"""
		Constructor.

		Arguments:
		name 		--	The item name.
		experiment	--	An instance of libopensesame.experiment.

		Keyword arguments:
		string		--	A string with the item definition. (default=None)
		"""

		self._active = True
		libopensesame.sequence.sequence.__init__(self, name, experiment, string)
		qtitem.qtitem.__init__(self)

	def action_button(self, icon, label, data, tooltip=None):

		"""
		Creates a simple pushbutton with a specific function.

		Arguments:
		icon	--	The icon.
		label	--	The label.
		data	--	A (function, parameter) tuple, such as ("add", "existing").

		Keyword arguments:
		tooltip --	A button tooltip. (default=None)

		Returns:
		An action_button instance.
		"""

		b = action_button(self, self.experiment.icon(icon), label, \
			tooltip=tooltip)
		b.data = data
		return b

	def init_edit_widget(self):

		"""Constructs the edit_widget that contains the controls."""

		qtitem.qtitem.init_edit_widget(self, False)
		# Flush keyboard checkbox
		self.checkbox_flush_keyboard = QtGui.QCheckBox( \
			_(u"Flush pending key presses at sequence start"))
		self.checkbox_flush_keyboard.toggled.connect(self.apply_edit_changes)
		form_layout = QtGui.QFormLayout()
		form_layout.setContentsMargins(0, 0, 0, 0)
		form_layout.addRow(self.checkbox_flush_keyboard)
		form_widget = QtGui.QWidget()
		form_widget.setLayout(form_layout)
		self.edit_vbox.addWidget(form_widget)
		self.combobox_item_type = self.experiment.item_type_combobox()
		self.combobox_items = QtGui.QComboBox()
		self.frame_empty = QtGui.QFrame()
		self.frame_empty.setFrameStyle(QtGui.QFrame.Panel)
		l = QtGui.QHBoxLayout()
		self.frame_empty.setLayout(l)
		l.addWidget(self.experiment.label_image(u"info"))
		l.addWidget(QtGui.QLabel(_(u"The %s is empty" % self.item_type)))
		l.addStretch()
		self.button_existing = self.action_button(u"button_select", \
			_(u"Append existing item to sequence"), (u"add",u"existing"))
		self.button_new = self.action_button(u"button_new", \
			_(u"Create and append  new item to sequence"), (u"add", u"new"))
		grid = QtGui.QGridLayout()
		grid.setMargin(0)
		grid.addWidget(QtGui.QLabel(_(u"Append existing item")), 0, 0)
		grid.addWidget(self.combobox_items, 0, 1)
		grid.addWidget(self.button_existing, 0, 2)
		grid.addWidget(QtGui.QLabel(_(u"Append new item")), 1, 0)
		grid.addWidget(self.combobox_item_type, 1, 1)
		grid.addWidget(self.button_new, 1, 2)
		grid.setColumnStretch(3, 10)
		self.draggable_list = draggables.draggable_list(self)
		scroll_area = QtGui.QScrollArea()
		scroll_area.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
		scroll_area.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
		scroll_area.setWidgetResizable(True)
		scroll_area.setWidget(self.draggable_list)
		self.edit_vbox.addWidget(self.frame_empty)
		self.edit_vbox.addWidget(scroll_area)
		grid_widget = QtGui.QFrame()
		grid_widget.setLayout(grid)
		self.edit_vbox.addWidget(grid_widget)
		return self._edit_widget

	def edit_widget(self):

		"""
		Updates the edit_widget to reflect changes in the item.

		Returns:
		The edit widget.
		"""

		if not self._active:
			return self._edit_widget
		self._active = False
		qtitem.qtitem.edit_widget(self)
		self.experiment.item_combobox(None, self.parents(), self.combobox_items)
		if self.combobox_items.count() == 0:
			self.combobox_items.setDisabled(True)
			self.button_existing.setDisabled(True)
		else:
			self.combobox_items.setDisabled(False)
			self.button_existing.setDisabled(False)
		self.checkbox_flush_keyboard.setChecked( \
			self.get(u"flush_keyboard") == u"yes")
		self.draggable_list.refresh()
		self.frame_empty.setVisible(len(self.items) == 0)
		self._active = True
		return self._edit_widget

	def apply_edit_changes(self):

		"""Applies the controls."""

		if not self._active:
			return
		qtitem.qtitem.apply_edit_changes(self)
		if self.checkbox_flush_keyboard.isChecked():
			self.set(u"flush_keyboard", u"yes")
		else:
			self.set(u"flush_keyboard", u"no")

	def move(self, from_index, to_index):

		"""
		Swaps two items from the sequence.

		Arguments:
		from_index	--	The old index.
		to_index	--	The new index.
		"""

		self.items.insert(to_index, self.items.pop(from_index))
		self.experiment.main_window.refresh(self.name)
		self.experiment.main_window.set_unsaved()

	def set_run_if(self, index, s):

		"""
		Change the 'run if' statement of an item.

		Arguments:
		index	--	The index of the item.
		s		--	The new run-if statement.
		"""

		s = self.clean_cond(s)
		if s != self.items[index][1]:
			self.items[index] = self.items[index][0], s
			self.experiment.main_window.refresh(self.name)
			self.experiment.main_window.set_unsaved()

	def rename(self, from_name, to_name):

		"""
		Renames an item.

		Arguments:
		from_name	--	The old name.
		to_name		--	The new name.
		"""

		qtitem.qtitem.rename(self, from_name, to_name)
		new_items = []
		for item, cond in self.items:
			if item == from_name:
				new_items.append( (to_name, cond) )
			else:
				new_items.append( (item, cond) )
		self.items = new_items

	def delete(self, item_name, item_parent=None, index=None):

		"""
		Deletes an item from the sequence.

		Arguments:
		item_name	--	The name of the item to be deleted.

		Keywords arguments:
		item_parent	--	The parent item. (default=None)
		index		--	The index of the item in the parent. (default=None)
		"""

		if item_parent == None or (item_parent == self.name and index == None):
			redo = True
			while redo:
				redo = False
				for i in range(len(self.items)):
					if self.items[i][0] == item_name:
						self.items = self.items[:i]+self.items[i+1:]
						redo = True
						break
		elif item_parent == self.name and index != None:
			if self.items[index][0] == item_name:
				self.items = self.items[:index]+self.items[index+1:]

	def build_item_tree(self, toplevel, items):

		"""
		Constructs the item tree.

		Arguments:
		toplevel	--	The toplevel widget.
		items		--	A list of items that have already been added to the item
						tree. (to avoid recursion)

		Returns:
		The updated list of added items.
		"""

		widget = self.item_tree_widget(toplevel)
		toplevel.addChild(widget)
		for item, cond in self.items:
			if item in self.experiment.items and self.experiment.items[item] \
				not in items:
				items.append(self.experiment.items[item])
		for item, cond in self.items:
			if item in self.experiment.items:
				self.experiment.items[item].build_item_tree(widget, items)
		widget.setExpanded(True)
		return items

	def is_offspring(self, item):

		"""
		Checks if the item is offspring of the current item.

		Arguments:
		item	--	The item to be checked.

		Returns:
		True if the item is offspring of the current item, False otherwise.
		"""

		for i, cond in self.items:
			if i == item or (i in self.experiment.items and \
				self.experiment.items[i].is_offspring(item)):
				return True
		return False

########NEW FILE########
__FILENAME__ = sketchpad
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import libopensesame.sketchpad
from libqtopensesame.items import qtplugin, feedpad
from libqtopensesame.widgets import sketchpad_widget
from libqtopensesame.dialogs import sketchpad_dialog
from PyQt4 import QtCore, QtGui

class sketchpad(libopensesame.sketchpad.sketchpad, feedpad.feedpad, \
	qtplugin.qtplugin):

	"""The GUI controls for the sketchpad"""

	def __init__(self, name, experiment, string=None):

		"""
		Constructor

		Arguments:
		name -- the name of the item
		experiment -- an instance of libopensesame.experiment

		Keyword arguments:
		string -- a string with the item definition (default = None)
		"""

		libopensesame.sketchpad.sketchpad.__init__(self, name, experiment, \
			string)
		qtplugin.qtplugin.__init__(self)

	def apply_edit_changes(self):

		"""Apply changes to the controls"""
		
		if not qtplugin.qtplugin.apply_edit_changes(self, False) or self.lock:
			return False
		self.experiment.main_window.refresh(self.name)
		return True			

	def edit_widget(self):

		"""Update the controls based on the items settings"""
		
		self.lock = True
		qtplugin.qtplugin.edit_widget(self)
		self.lock = False
		self.tools_widget.refresh()
		return self._edit_widget		

	def init_edit_widget(self):

		"""Construct the edit widget that contains the controls"""

		qtplugin.qtplugin.init_edit_widget(self, False)		
		self.add_line_edit_control('duration', 'Duration', tooltip= \
			'A numeric value (duration in milliseconds), "keypress", or "mouseclick"' \
			)
		self.popout_button = QtGui.QPushButton(self.experiment.icon( \
			self.item_type), "Open editor in new window")
		self.popout_button.setIconSize(QtCore.QSize(16,16))
		self.popout_button.setToolTip( \
			"Open the sketchpad editor in a new window")
		QtCore.QObject.connect(self.popout_button, \
			QtCore.SIGNAL("clicked()"), self.popout)
		self.add_control('', self.popout_button, 
			'Open the sketchpad editor in a new window')
		self.tools_widget = sketchpad_widget.sketchpad_widget(self)
		self.edit_vbox.addWidget(self.tools_widget)


########NEW FILE########
__FILENAME__ = synth
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import libopensesame.synth
from libqtopensesame.misc import _
from libqtopensesame.items import qtitem
from libqtopensesame.ui import synth_widget_ui
from PyQt4 import QtCore, QtGui

class synth(libopensesame.synth.synth, qtitem.qtitem):

	"""GUI controls for the synth item"""

	def __init__(self, name, experiment, string = None):
	
		"""
		Constructor
		
		Arguments:
		name -- the item name
		experiment -- the experiment
		
		Keywords arguments:
		string -- definition string (default=None)
		"""
		
		libopensesame.synth.synth.__init__(self, name, experiment, string)
		qtitem.qtitem.__init__(self)					
		self.lock = False
						
	def init_edit_widget(self):
	
		"""Build the GUI controls"""
		
		qtitem.qtitem.init_edit_widget(self, False)				
		self.synth_widget = QtGui.QWidget()
		self.synth_widget.ui = synth_widget_ui.Ui_synth_widget()
		self.synth_widget.ui.setupUi(self.synth_widget)
		self.experiment.main_window.theme.apply_theme(self.synth_widget)
		self.synth_widget.ui.spin_attack.valueChanged.connect( \
			self.apply_edit_changes)
		self.synth_widget.ui.spin_decay.valueChanged.connect( \
			self.apply_edit_changes)
		self.synth_widget.ui.spin_pan.valueChanged.connect( \
			self.apply_edit_changes)
		self.synth_widget.ui.spin_volume.valueChanged.connect( \
			self.apply_edit_changes)
		self.synth_widget.ui.spin_length.valueChanged.connect( \
			self.apply_edit_changes)				
		self.synth_widget.ui.edit_freq.editingFinished.connect( \
			self.apply_edit_changes)		
		self.synth_widget.ui.edit_duration.editingFinished.connect( \
			self.apply_edit_changes)		
		self.synth_widget.ui.dial_attack.valueChanged.connect(self.apply_dials)
		self.synth_widget.ui.dial_decay.valueChanged.connect(self.apply_dials)	
		self.synth_widget.ui.dial_pan.valueChanged.connect(self.apply_dials)
		self.synth_widget.ui.dial_volume.valueChanged.connect(self.apply_dials)		
		self.synth_widget.ui.button_sine.clicked.connect(self.set_sine)
		self.synth_widget.ui.button_saw.clicked.connect(self.set_saw)
		self.synth_widget.ui.button_square.clicked.connect(self.set_square)
		self.synth_widget.ui.button_white_noise.clicked.connect( \
			self.set_white_noise)							
		self.edit_vbox.addWidget(self.synth_widget)
		self.edit_vbox.addStretch()
		
	def set_sine(self):
	
		"""Select the sine oscillator"""
		
		self.synth_widget.ui.button_sine.setChecked(True)
		self.synth_widget.ui.button_saw.setChecked(False)
		self.synth_widget.ui.button_square.setChecked(False)
		self.synth_widget.ui.button_white_noise.setChecked(False)
		
		self.set("osc", "sine")
		self.apply_edit_changes()
		
	def set_saw(self):
	
		"""Select the saw oscillator"""

		self.synth_widget.ui.button_sine.setChecked(False)
		self.synth_widget.ui.button_saw.setChecked(True)
		self.synth_widget.ui.button_square.setChecked(False)
		self.synth_widget.ui.button_white_noise.setChecked(False)
		
		self.set("osc", "saw")
		self.apply_edit_changes()
		
	def set_square(self):
	
		"""Select the square oscillator"""

		self.synth_widget.ui.button_sine.setChecked(False)
		self.synth_widget.ui.button_saw.setChecked(False)
		self.synth_widget.ui.button_square.setChecked(True)
		self.synth_widget.ui.button_white_noise.setChecked(False)
		
		self.set("osc", "square")
		self.apply_edit_changes()
		
	def set_white_noise(self):
	
		"""Select the white noise oscillator"""

		self.synth_widget.ui.button_sine.setChecked(False)
		self.synth_widget.ui.button_saw.setChecked(False)
		self.synth_widget.ui.button_square.setChecked(False)
		self.synth_widget.ui.button_white_noise.setChecked(True)
		
		self.set("osc", "white_noise")
		self.apply_edit_changes()
						
	def edit_widget(self):
	
		"""Refresh the GUI controls"""	
		
		self.lock = True		
		
		qtitem.qtitem.edit_widget(self, False)		
				
		if self.variable_vars(["duration", "freq"]):			
			self.synth_widget.ui.frame_controls.setVisible(False)
			self.user_hint_widget.add_user_hint(_( \
				'The controls are disabled, because one of the settings is defined using variables.'))
			self.user_hint_widget.refresh()			
		else:
		
			self.synth_widget.ui.frame_controls.setVisible(True)				
			self.synth_widget.ui.edit_freq.setText(self.unistr(self.get( \
				'freq', _eval=False)))		
			self.synth_widget.ui.edit_duration.setText(self.unistr(self.get( \
				'duration', _eval=False)))
			self.synth_widget.ui.spin_attack.setValue(self.get("attack", \
				_eval=False))
			self.synth_widget.ui.spin_decay.setValue(self.get("decay", _eval= \
				False))		
			self.synth_widget.ui.spin_pan.setValue(self.get("pan", _eval=False))
			self.synth_widget.ui.spin_volume.setValue(100.0 * self.get( \
				"volume", _eval=False))
			self.synth_widget.ui.spin_length.setValue(self.get("length", \
				_eval=False))
			self.synth_widget.ui.dial_attack.setValue(self.get("attack", \
				_eval=False))
			self.synth_widget.ui.dial_decay.setValue(self.get("decay", \
				_eval=False))
			self.synth_widget.ui.dial_pan.setValue(self.get("pan", _eval= \
				False))
			self.synth_widget.ui.dial_volume.setValue(100.0 * self.get( \
				"volume", _eval=False))									
			self.synth_widget.ui.button_sine.setChecked(self.get("osc", \
				_eval=False) == "sine")
			self.synth_widget.ui.button_saw.setChecked(self.get("osc", _eval= \
				False) == "saw")
			self.synth_widget.ui.button_square.setChecked(self.get("osc", \
				_eval=False) == "square")
			self.synth_widget.ui.button_white_noise.setChecked(self.get( \
				"osc", _eval=False) == "white_noise")
			
		self.lock = False
			
		return self._edit_widget


	def apply_edit_changes(self, dummy1=None, dummy2=None):
	
		"""
		Apply the GUI controls
		
		Keywords arguments:
		dummy1 -- a dummy argument (default=None)
		dummy2 -- a dummy argument (default=None)
		"""	
		
		if not qtitem.qtitem.apply_edit_changes(self) or self.lock:
			return
			
		self.set("freq", self.sanitize(self.synth_widget.ui.edit_freq.text(), \
			strict=True))		
		dur = self.sanitize(self.synth_widget.ui.edit_duration.text(), \
			strict=True)
		if dur == "":
			dur = "sound"
		self.set("duration", dur)		

		self.set("attack", self.synth_widget.ui.spin_attack.value())
		self.set("decay", self.synth_widget.ui.spin_decay.value())		
		self.set("pan", self.synth_widget.ui.spin_pan.value())
		self.set("volume", .01 * self.synth_widget.ui.spin_volume.value())
		self.set("length", self.synth_widget.ui.spin_length.value())
		
		if self.synth_widget.ui.button_sine.isChecked():
			self.set("osc", "sine")
		elif self.synth_widget.ui.button_saw.isChecked():
			self.set("osc", "saw")
		elif self.synth_widget.ui.button_square.isChecked():
			self.set("osc", "square")
		else:
			self.set("osc", "white_noise")
		
		self.experiment.main_window.refresh(self.name)			
						
	def apply_dials(self, dummy=None):
	
		"""
		Set the spinbox values based on the dials
		
		Keywords arguments:
		dummy -- a dummy argument (default=None)
		"""
		
		if self.lock:
			return		
		self.set("attack", self.synth_widget.ui.dial_attack.value())
		self.set("decay", self.synth_widget.ui.dial_decay.value())
		self.set("pan", self.synth_widget.ui.dial_pan.value())
		self.set("volume", .01 * self.synth_widget.ui.dial_volume.value())		
		self.edit_widget()

########NEW FILE########
__FILENAME__ = config
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.

# About

This module is used to maintain configuration settings. There is a old and a new
style API. The new one is obviously preferred for new code. When this module is
first loaded, a single instance of the `config` class is instantiated, whicn is
subsequently used for all configuration getting and setting (i.e. a singleton
design pattern).

Old style:

	from libqtopensesame.misc import config
	config.set_config('my_setting', 'my_value')
	print(config.get_config('my_setting'))

New style:

	from libqtopensesame.misc.config import cfg
	cfg.my_setting = 'my_value' # set
	print(cfg.my_setting) # get
"""

from libopensesame.exceptions import osexception
from PyQt4 import QtCore
import libopensesame.misc
from libopensesame import debug
import platform
import sip
if sip.getapi(u'QString') == 2:
	QtCore.QStringList = list

class config(object):

	config = {
		u"cfg_ver" : 0,
		u"_initial_window_geometry" : QtCore.QByteArray(),
		u"_initial_window_state" : QtCore.QByteArray(),
		u"auto_update_check" : True,
		u"auto_response" : False,
		u"autosave_interval" : 10 * 60 * 1000,
		u"autosave_max_age" : 7,
		u"default_logfile_folder" : libopensesame.misc.home_folder(),
		u"default_pool_folder" : libopensesame.misc.home_folder(),
		u"disabled_plugins" : "",
		u"file_dialog_path" : "",
		u"immediate_rename" : False,
		u"locale" : u"default",
		u"loop_wizard" : QtCore.QStringList(),
		u"onetabmode" : True,
		u"qProgEditCommentShortcut" : u'Ctrl+M',
		u"qProgEditUncommentShortcut" : u'Ctrl+Shift+M',
		u'qProgEditFontFamily' : u'Monospace',
		u'qProgEditFontSize' : 10,
		u'qProgEditLineNumbers' : True,
		u'qProgEditHighlightCurrentLine' : False,
		u'qProgEditHighlightMatchingBrackets' : True,
		u'qProgEditWordWrapMarker' : 80,
		u'qProgEditWordWrap' : True,
		u'qProgEditTabWidth' : 4,
		u'qProgEditAutoIndent' : True,
		u'qProgEditShowEol' : False,
		u'qProgEditShowWhitespace' : False,
		u'qProgEditShowIndent' : False,
		u'qProgEditShowFolding' : True,
		u'qProgEditAutoComplete' : True,
		u'qProgEditColorScheme' : u'Default',
		u'qProgEditValidate' : True,
		u"quick_run_logfile": u"quickrun.csv",
		u"recent_files" : u"",
		u"shortcut_itemtree" : u"Ctrl+1",
		u"shortcut_tabwidget" : u"Ctrl+2",
		u"shortcut_stdout" : u"Ctrl+3",
		u"shortcut_pool" : u"Ctrl+4",
		u"shortcut_variables" : u"Ctrl+5",
		u"style" : u"",
		u"theme" : u"default",
		u"toolbar_size" : 32,
		u"toolbar_text" : False,
		u"runner" : u"multiprocess",
		u"opensesamerun_exec" : u"",
		u"pos" : QtCore.QPoint(200, 200),
		u"size" : QtCore.QSize(1000, 600),
		u"url_website" : u"http://www.cogsci.nl/opensesame",
		u"url_facebook" : u"http://www.facebook.com/cognitivescience",
		u"url_twitter" : u"http://www.twitter.com/cogscinl",
		u"version_check_url" : \
			u"http://files.cogsci.nl/software/opensesame/MOST_RECENT_VERSION.TXT"
		}

	# OS specific override settings
	config_linux = {
		u"theme" : u"gnome"
		}
	config_mac = {}
	config_windows = {
		u'qProgEditFontFamily' : u'Courier New'
		}

	def __init__(self):

		"""Constructor"""

		# Determine the sip api that is used, because this depends on whether
		# or not IPython is loaded
		object.__setattr__(self, u'api', sip.getapi(u'QString'))
		if self.api not in (1,2):
			raise Exception(u'config: unknown api %s' % self.api)

		# Apply OS specific override settings
		if platform.system() == u"Windows":
			for key, value in self.config_windows.iteritems():
				self.config[key] = value
		elif platform.system() == u"Darwin":
			for key, value in self.config_mac.iteritems():
				self.config[key] = value
		elif platform.system() == u"Linux":
			for key, value in self.config_linux.iteritems():
				self.config[key] = value

	def __getattr__(self, setting):

		"""
		A getter for settings, to allow for easy access

		Argument:
		setting -- the setting to get
		"""

		if setting not in self.config:
			raise osexception(u'The setting "%s" does not exist' \
				% setting)
		return self.config[setting]

	def __setattr__(self, setting, value):

		"""
		A setter for settings, to allow for easy access

		Argument:
		setting -- the setting to set
		value -- the value to set
		"""
		if setting not in self.config:
			raise osexception(u'The setting "%s" does not exist' \
				% setting)
		self.config[setting] = value
		self.config[u'cfg_ver'] += 1

	def parse_cmdline_args(self, args):

		"""
		Apply settings that were specified on the command line. The expected
		format is as follows: [name]=[val];[name]=[val];...

		Arguments:
		args -- the string of command line arguments
		"""

		if args == None:
			return

		for arg in args.split(u";"):
			a = arg.split(u"=")
			if len(a) == 2:

				# Automagically determine the data type
				if a[1] == u"True":
					val = True
				elif a[1] == u"False":
					val = False
				else:
					try:
						val = int(a[1])
					except:
						try:
							val = float(a[1])
						except:
							val = a[1]

				# Apply the argument
				try:
					self.__setattr__(a[0], val)
					debug.msg(u"%s = %s" % (a[0], val))
				except:
					debug.msg(u"Failed to parse argument: %s" % arg)

	def restore(self, qsettings):

		"""
		Restore settings from a QSettings

		Arguments:
		qsettings -- a QSettings instance
		"""

		for setting, default in self.config.items():
			value = qsettings.value(setting, default)

			# The older (default) api requires an explicit type conversion
			if self.api == 1:
				if type(default) == bool:
					value = value.toBool()
				elif type(default) == str:
					try:
						value = unicode(value.toString())
					except:
						value = default
				elif type(default) == int:
					value = value.toInt()[0]
				elif type(default) == QtCore.QPoint:
					value = value.toPoint()
				elif type(default) == QtCore.QSize:
					value = value.toSize()
				elif type(default) == QtCore.QByteArray:
					value = value.toByteArray()
				elif type(default) == QtCore.QString:
					value = value.toString()
				elif type(default) == QtCore.QStringList:
					value = value.toStringList()
				elif type(default) == unicode:
					value = unicode(value.toString())

			# The newer api returns some things as strings, so we still have to
			# do some type conversion
			else:
				if type(default) == bool:
					if value == u'false':
						value = False
					else:
						value = True
				elif type(default) == int:
					value = int(value)

			self.__setattr__(setting, value)

	def save(self, qsettings):

		"""
		Save settings to a QSettings

		Arguments:
		qsettings -- a QSettings instance
		"""

		for setting, value in self.config.items():
			if setting != u"cfg_ver":
				qsettings.setValue(setting, value)

	def version(self):

		"""
		Gets the current version of the config.

		Returns:
		The config version.
		"""

		return self.cfg_ver

# Old style API. See explanation above
def get_config(setting):
	return cfg.__getattr__(setting)

def set_config(setting, value):
	cfg.__setattr__(setting, value)

def restore_config(settings):
	cfg.restore(settings)

def save_config(settings):
	cfg.save(settings)

def parse_cmdline_args(args):
	cfg.parse_cmdline_args(args)

# Create a singleton config instance
global cfg
cfg = config()

########NEW FILE########
__FILENAME__ = dispatch
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.

DISPATCH LOGIC
==============

The following elements can be affected by a change in an item

+ Item tree
	+ Affected by name changes
	+ Affected by sequence and loop changes

- Loop items
	+ Affected by name changes (only if parent)
	
- Sequence items
	+ Affected by name changes (only if parent)
		
To handle this, we have the following events

+ name_change
	Refresh item tree
	Refresh loops
	Refresh sequences

+ script_change

"""

from PyQt4 import QtCore
from libqtopensesame.misc import _
from libqtopensesame.items import experiment
import libopensesame.exceptions
import sip
import traceback

class dispatch(QtCore.QObject):

	"""
	The dispatch is informed of changes and passes these on to the various
	parts of the GUI.
	"""
	
	event_name_change = QtCore.pyqtSignal([str, str], name=u'nameChange')
	event_regenerate = QtCore.pyqtSignal([str], name=u'regenerate')
	event_script_change = QtCore.pyqtSignal([str], [sip.voidptr], \
		name=u'scriptChange')
	event_simple_change = QtCore.pyqtSignal([str], [sip.voidptr], \
		name=u'simpleChange')
	event_structure_change = QtCore.pyqtSignal([str], [sip.voidptr], \
		name=u'structureChange')
		
	def __init__(self, main_window):
	
		"""
		Constructor.
		
		Arguments:
		main_window 	--	The main window.
		"""
	
		QtCore.QObject.__init__(self)
		self.main_window = main_window	
		self.event_name_change.connect(self.name_change)
		self.event_regenerate.connect(self.regenerate)		
		self.event_script_change[str].connect(self.script_change)
		self.event_script_change[sip.voidptr].connect(self.script_change)
		self.event_simple_change[str].connect(self.simple_change)
		self.event_simple_change[sip.voidptr].connect(self.simple_change)
		self.event_structure_change[str].connect(self.structure_change)
		self.event_structure_change[sip.voidptr].connect(self.structure_change)
		
	def regenerate(self, script):
	
		"""
		Handles a full regeneration of the experiment.
		
		Arguments:
		script 			--	A definition Unicode string / QString.
		"""
				
		self.main_window.set_busy(True)		
		script = self.main_window.experiment.unistr(script)
		try:
			# Generate the new experiment
			tmp = experiment.experiment(self.main_window, \
				self.main_window.experiment.title, script, \
				self.main_window.experiment.pool_folder)
		except Exception as error:		
			# If something is wrong with the script, notify the user and print
			# a traceback to the debug window
			self.main_window.experiment.notify( \
				_(u'Failed to parse script (see traceback in debug window): %s') \
				% error)
			self.main_window.print_debug_window(error)
			return
		# Apply the new experiment
		self.main_window.experiment = tmp
		self.main_window.experiment.build_item_tree()			
		self.main_window.ui.tabwidget.close_all()
		self.main_window.ui.tabwidget.open_general_script()
		self.main_window.set_busy(False)
		self.main_window.set_unsaved()	
		
	def script_change(self, name=None):
	
		"""
		Handles a change to an items script.
		
		Arguments:
		name 		--	The name of an item. (default=None)
		"""
	
		self.main_window.experiment.build_item_tree()		
		self.simple_change(name)
				
	def simple_change(self, name=None):
	
		"""
		Handles simple changes to an item.
		
		Arguments:
		name		-- The name of an item.
		"""
	
		self.main_window.refresh_variable_inspector()
		self.main_window.set_unsaved()
			
	def structure_change(self, name=None):
		
		"""
		Handles changes to the structure of the experiment.
		
		Arguments:
		name 		--	The name of the item that caused the change.
						(default=None)
		"""
		
		self.main_window.experiment.build_item_tree()
		self.simple_change(name)
		
	def name_change(self, from_name, to_name):
	
		"""
		Handles the name change of an item.
		
		Arguments:
		from_name 	-- The previous name.
		to_name 	-- The new name.
		"""
	
		from_name = unicode(from_name)
		to_name = unicode(to_name)
		self.main_window.set_busy(True)
		# Rename the item in the experiment item list
		item = self.main_window.experiment.items[from_name]
		del self.main_window.experiment.items[from_name]
		self.main_window.experiment.items[to_name] = item		
		# Give all items the chance to process the name change
		for item in self.main_window.experiment.items:
			self.main_window.experiment.items[item].rename(from_name, to_name)
		# Rebuild the item tree
		self.main_window.experiment.build_item_tree()		
		# Rename the item tab
		i = self.main_window.ui.tabwidget.get_item(to_name)
		if i != None:		
			self.main_window.ui.tabwidget.setTabText(i, to_name)
		# Also process simple changes
		self.simple_change(to_name)
		self.main_window.set_busy(False)		

########NEW FILE########
__FILENAME__ = dummy
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
""" 

class qtplugin(object):	
	pass

class qtautoplugin(object):	
	pass
########NEW FILE########
__FILENAME__ = includes
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.

***

This file includes all kinds of things so that py2exe incorporates
them into the distribution. This is necessary, because items are
loaded at runtime, and therefore escape the detection of py2exe.
"""

import sys
from libopensesame import debug

# Below is a quick hack to deal with pylinks quirky behavior.
# Pylink needs to be imported prior to pygame, otherwise it
# gives a DLL not found error. However, if we use a regular
# import statement, py2exe will include pylink with OpenSesame
# which is not allowed. This hack loads pylink if available,
# prior to pygame, without giving an error if pylink is not
# installed.

if "--pylink" in sys.argv:
	try:
		exec("import pylink") # This makes sure that py2exe doesn't try to include pylink
	except Exception as e:
		debug.msg( \
			"failed to import pylink module. You will not be able to use eyelink connectivity")

# Explicitly importing these modules ensures that Py2exe will
# bundle them. This is therefore only required for Windows.

if "--preload" in sys.argv:

	import warnings

	debug.msg("preloading modules ...")
	debug.msg("preloading 'legacy' back-end")
	try:
		import openexp,\
			openexp._canvas.legacy,\
			openexp._keyboard.legacy,\
			openexp._mouse.legacy,\
			openexp._sampler.legacy,\
			openexp._synth.legacy
	except Exception as e:
		debug.msg("failed to import 'legacy' back-end. Error: %s" % e)

	debug.msg("preloading 'opengl' back-end")
	try:
		import openexp,\
			openexp._canvas.xpyriment,\
			openexp._mouse.xpyriment
	except Exception as e:
		debug.msg("failed to import 'xpyriment' back-end. Error: %s" % e)

	debug.msg("preloading 'opengl' back-end")
	try:
		import openexp,\
			openexp._canvas.opengl
	except Exception as e:
		debug.msg("failed to import 'opengl' back-end. Error: %s" % e)

	debug.msg("preloading 'psycho' back-end")
	try:
		with warnings.catch_warnings():
			warnings.simplefilter("ignore")
			import openexp,\
				openexp._canvas.psycho,\
				openexp._keyboard.psycho,\
				openexp._mouse.psycho
	except Exception as e:
		debug.msg("failed to import 'psycho' back-end. Error: %s" % e)

	debug.msg("preloading 'psychopy'")
	try:
		with warnings.catch_warnings():
			warnings.simplefilter("ignore")
			from psychopy import core, visual, data, event, filters, gui, hardware, log, misc, monitors, sound, platform_specific # info, serial and parallel produce errors
	except Exception as e:
		debug.msg("failed to import 'psychopy' <http://www.psychopy.org/>. You will not be able to use PsychoPy or the psycho back-end. Error: %s" % e)

	debug.msg("preloading 'pyffmpeg'")
	try:
		import pyffmpeg
		import pyffmpeg_numpybindings
		from audioqueue import AudioQueue, Queue_Empty, Queue_Full
	except Exception as e:
		debug.msg("failed to import 'pyffmpeg' <http://code.google.com/p/pyffmpeg/>. You will not be able to use the media_player plug-in. Error: %s" % e)

	debug.msg("preloading 'PIL'")
	try:
		# The correct way to import PIL appears to depend on the version. So
		# try both methods.
		try:
			import PIL
			import PIL.Image
		except:
			import Image
	except Exception as e:
		debug.msg("failed to import 'PIL' <http://www.pythonware.com/products/pil/>. You will not be able the Python Imaging library. Error: %s" % e)

	debug.msg("preloading 'pyaudio'")
	try:
		import pyaudio
	except Exception as e:
		debug.msg("failed to import 'pyaudio' <http://people.csail.mit.edu/hubert/pyaudio/>. You will not be able to use portaudio and the media_player plug-in. Error: %s" % e)

	debug.msg("preloading 'wave'")
	try:
		import wave
	except Exception as e:
		debug.msg("failed to import 'wave'. Error: %s" % e)

	# OpenGL requires hacks to work with Py2Exe. The approach here is based on
	# information from <http://www.py2exe.org/index.cgi/PyOpenGL>
	debug.msg("preloading 'OpenGL'")
	try:
		from OpenGL.GL import *
		from OpenGL.platform import win32
	except AttributeError:
		pass
	try:
		from ctypes import util
		import OpenGL
	except Exception as e:
		debug.msg("failed to import 'OpenGL' <http://pyopengl.sourceforge.net/>. You will not be able to use OpenGL. Error: %s" % e)

	debug.msg("preloading 'cv'")
	try:
		import cv
	except Exception as e:
		debug.msg("failed to import 'cv' <http://opencv.willowgarage.com/wiki/>. You will not be able to use the Open Computer Vision libraries. Error: %s" % e)

	debug.msg("preloading 'serial'")
	try:
		import serial
	except Exception as e:
		debug.msg("failed to import 'serial' module <http://pyserial.sourceforge.net/>. You will not be able to use serial port connectivity. Error: %s" % e)

	debug.msg("preloading 'parallel'")
	try:
		import parallel
		import parallel.parallelutil
	except Exception as e:
		debug.msg("failed to import 'parallel' module <http://pyserial.sourceforge.net/pyparallel.html>. You will not be able to use parallel port connectivity. Error: %s" % e)

	debug.msg("preloading 'pyglet'")
	try:
		import pyglet
	except Exception as e:
		debug.msg("failed to import 'pyglet' module <http://www.pyglet.org/>. You will not be able to use PsychoPy. Error: %s" % e)

	debug.msg("preloading modules required by questionnaire plug-ins")
	try:
		import htmllib
		import htmlentitydefs
		import HTMLParser
		import sgmllib
		import markupbase
	except Exception as e:
		debug.msg("failed to import modules required by questionnaire plug-ins")

	debug.msg("preloading IPython")
	try:
		from IPython.frontend.qt.console.ipython_widget import IPythonWidget
		from IPython.frontend.qt.kernelmanager import QtKernelManager
		from IPython.utils.localinterfaces import LOCALHOST
	except Exception as e:
		debug.msg("failed to import IPython <http://www.ipython.org/>. You will not be able to use the IPython console. Error: %s" % e)

	debug.msg("preloading OSX dependencies")
	try:
		from libqtopensesame.widgets import pool_widget, statusbar, tree_overview, toolbar_items, variable_inspector, good_looking_table
		from libqtopensesame.items import exceptions, experiment, feedback, generic_response, inline_script, item, keyboard_response, logger, loop, misc, mouse_response, plugins, sampler, sequence, sketchpad, synth
	except Exception as e:
		debug.msg('Failed to load libqtopensesame.items modules')
	try:
		import pygame._view
	except Exception as e:
		debug.msg('Failed to load pygame._view')

########NEW FILE########
__FILENAME__ = process
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""



import platform
# In OS X the multiprocessing module is horribly broken, but a fixed
# version has been released as the 'billiard' module
if platform.system() == 'Darwin':
	import billiard as multiprocessing
	multiprocessing.forking_enable(0)
else:
	import multiprocessing

class OutputChannel:

	"""Passes messages from child process back to main process."""

	def __init__(self, channel, orig=None):

		"""
		Constructor.

		Arguments:
		channel	--	A multiprocessing.JoinableQueue object that is referenced
					from the main process.

		Keyword arguments:
		orig	--	The original stdout or stderr to also print the messages to.
		"""

		self.channel = channel
		self.orig = orig

	def write(self, m):

		"""
		Writes a message to the queue.

		Arguments
		m		--	The message to write. Should be a string or an (Exception,
					traceback) tuple.
		"""

		self.channel.put(m)

	def flush(self):

		"""Dummy function to mimic the stderr.flush() function."""

		if self.orig:
			self.orig.flush()
		else:
			pass

class ExperimentProcess(multiprocessing.Process):

	"""Creates a new process to run an experiment in."""

	def __init__(self, exp, output):

		"""
		Constructor.

		Arguments
		exp		--	An instance of libopensesame.experiment.experiment
		output	--	A reference to the queue object created in and used to
					communicate with the main process.
		"""

		multiprocessing.Process.__init__(self)
		self.output = output
		# The experiment object is troublesome to serialize,
		# therefore pull out all relevant data to pass on to the new process
		# and rebuild the exp object in there.
		self.script = exp.to_string()
		self.pool_folder = exp.pool_folder
		self.subject_nr = exp.subject_nr
		self.experiment_path = exp.experiment_path
		self.fullscreen = exp.fullscreen
		self.logfile = exp.logfile
		self.auto_response = exp.auto_response

	def run(self):

		"""
		Everything in this function is run in a new process, therefore all
		import statements are put in here. The function reroutes all output to
		stdin and stderr to the pipe to the main process so OpenSesame can
		handle all prints and errors.
		"""

		import os
		import sys
		from libopensesame import misc
		from libopensesame.experiment import experiment
		from libopensesame.exceptions import osexception
		# Under Windows, change the working directory to the OpenSesame folder,
		# so that the new process can find the main script.
		if os.name == u'nt':
			os.chdir(misc.opensesame_folder())
		# Reroute output to OpenSesame main process, so everything will be
		# printed in the Debug window there.
		pipeToMainProcess = OutputChannel(self.output)
		sys.stdout = pipeToMainProcess
		sys.stderr = pipeToMainProcess
		# First initialize the experiment and catch any resulting Exceptions
		try:
			exp = experiment(string=self.script, pool_folder= \
				self.pool_folder, experiment_path=self.experiment_path, \
				fullscreen=self.fullscreen, auto_response=self.auto_response, \
				subject_nr=self.subject_nr, logfile=self.logfile)
		except Exception as e:
			if not isinstance(e, osexception):
				e = osexception(u'Unexpected error', exception=e)
			# Communicate the exception and exit with error
			self.output.put(e)
			sys.exit(1)
		print(u'Starting experiment as %s' % self.name)
		# Run the experiment and catch any Exceptions.
		e_run = None
		try:
			exp.run()
		except Exception as e_run:
			if not isinstance(e_run, osexception):
				e_run = osexception(u'Unexpected error', exception=e_run)
		# End the experiment and catch any Exceptions. These exceptions are just
		# printed out and not explicitly passed on to the user, because they are
		# less important than the run-related exceptions.
		try:
			exp.end()
		except Exception as e_exp:
			print(u'An Exception occurred during exp.end(): %s' % e_exp)
		# Communicate the exception and exit with error
		if e_run != None:
			self.output.put(e_run)
			sys.exit(1)
		# Exit with success
		sys.exit(0)

########NEW FILE########
__FILENAME__ = template_info
 #-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

templates = [
	('templates/default.opensesame', 'Default template'),
	('templates/extended_template.opensesame', 'Extended template'),
	('templates/android_template.opensesame', 'Runtime for Android template'),
	('templates/eco_alt_template.opensesame.tar.gz',
			'Stimulus set: an ecological alternative to Snodgrass & Vanderwart'),
	('templates/gaped_template.opensesame.tar.gz', 
			'Stimulus set: the Geneva affective picture database (GAPED)'),
	('templates/boss_template.opensesame.tar,gz',
			'Stimulus set: the bank of standardized stimuli (BOSS)')
	]

########NEW FILE########
__FILENAME__ = theme
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import os.path
import imp
from libopensesame import debug, misc
from libqtopensesame.misc import config
from PyQt4 import QtGui, QtCore

available_themes = [u'default', u'gnome']

class theme:

	"""Handles the GUI theme"""

	default_icon_size = 32

	def __init__(self, main_window, theme=None):
	
		"""
		Constructor
		
		Arguments:
		main_window -- the main_window object
		
		Keyword arguments:
		theme -- the theme to be used or None to use config (default=None)
		"""

		self.main_window = main_window
		if theme == None:
			self.theme = config.get_config(u"theme")
		else:
			self.theme = theme
		self.theme_folder = misc.resource(os.path.join(u"theme", \
			self.theme))
		debug.msg(u"theme = '%s' (%s)" % (self.theme, self.theme_folder))			
		if self.theme_folder == None or not os.path.exists(self.theme_folder):			
			debug.msg(u"theme '%s' does not exist, using 'default'" % theme, \
				reason=u"warning")
			self.theme = u"default"
			self.theme_folder = misc.resource(os.path.join(u"theme", \
				self.theme))						
		self.theme_info = os.path.join(self.theme_folder, u"__theme__.py")
		if os.path.exists(self.theme_info):						
			info = imp.load_source(self.theme, self.theme_info)
			self._qss = path = \
				open(os.path.join(self.theme_folder, info.qss)).read()
			self._icon_map = info.icon_map
			self._icon_theme = info.icon_theme									
		self.load_icon_map()
		self.apply_theme(self.main_window)			
		
	def apply_theme(self, widget):
	
		"""
		Apply the theme to a QWidget, i.e. load the stylesheet and the icons
		
		Arguments:
		widget -- a QWidget
		"""
		
		widget.setStyleSheet(self._qss)
		if hasattr(widget, u"ui"):
			self.load_icons(widget.ui)
				
	def qicon(self, icon):
	
		"""
		Get an icon from the theme
		
		Arguments:
		icon -- the icon name
		
		Returns:
		A QIcon
		"""	
	
		if icon in self.icon_map:
			name, size = self.icon_map[icon]
		else:
			name = icon
		return QtGui.QIcon.fromTheme(name, QtGui.QIcon(os.path.join( \
			misc.resource(u"theme"), u"fallback.png")))
			
	def qpixmap(self, icon, size=None):
	
		"""
		Get an icon from the theme
		
		Arguments:
		icon -- the icon name
		
		Keyword arguments:
		size -- the size of the icon or None for default (default=None)
		
		Returns:
		A QPixmap		
		"""	
		
		if size == None:
			if icon in self.icon_map:
				name, size = self.icon_map[icon]
			else:
				name = icon
				size = self.default_icon_size			
		else:
			if icon in self.icon_map:
				name = self.icon_map[icon][0]
			else:
				name = icon					
		return QtGui.QIcon.fromTheme(name, QtGui.QIcon(os.path.join( \
			misc.resource(u"theme"), u"fallback.png"))).pixmap(size)
			
	def qlabel(self, icon):
	
		"""
		Get an icon from the theme
		
		Arguments:
		icon -- the icon name
		
		Returns:
		A QLabel		
		"""
	
		l = QtGui.QLabel()
		l.setPixmap(self.qpixmap(icon))
		return l
		
	def load_icon_map(self):
	
		"""Load the icon map"""
	
		if os.path.exists(os.path.join(self.theme_folder, self._icon_theme)):
			debug.msg(u"using custom icon theme")
			QtGui.QIcon.setThemeSearchPaths(QtGui.QIcon.themeSearchPaths() \
				+ [self.theme_folder])
			QtGui.QIcon.setThemeName(self._icon_theme)
		else:
			debug.msg(u"using default icon theme, icons may be missing", \
				reason=u"warning")
		self.icon_map = {}
		path = os.path.join(self.theme_folder, self._icon_map)		
		debug.msg(path)
		for l in open(path):
			l = l.split(",")			
			if len(l) == 3:
				try:
					size = int(l[2])
				except:
					size = 32
				alias = l[0].strip()
				name = l[1].strip()
				if alias in self.icon_map:
					debug.msg(u"alias '%s' already in icon map, overwriting" % \
						alias, reason=u"warning")
				self.icon_map[alias] = name, size
		
	def load_icons(self, ui):
	
		"""
		Add icons to all icon supporting widgets in a ui object
				
		Arguments:
		ui -- the ui object to load icons into
		"""
		
		debug.msg()
		for i in dir(ui):
			if i in self.icon_map:			
				a = getattr(ui, i)
				if hasattr(a, u"setIcon"):
					a.setIcon(self.qicon(i))
				elif hasattr(a, u"setPixmap"):
					a.setPixmap(self.qpixmap(i))
		
	def set_toolbar_size(self, size):
	
		"""
		Control the size of the icons in the toolbar
		
		Arguments:
		size -- a size in pixels		
		"""
	
		self.main_window.ui.toolbar_main.setIconSize(QtCore.QSize(size, size))
		self.main_window.ui.toolbar_items.setIconSize(QtCore.QSize(size, size))
		self.main_window.ui.toolbar_items.build()

	def resource(self, fname):
		
		"""
		Retrieves the path to a resource within the theme folder.
		
		Arguments:
		fname	--	The resource filename.
		
		Returns:
		The full path to the resource file in the theme folder.
		"""
		
		return os.path.join(self.theme_folder, fname)
	

########NEW FILE########
__FILENAME__ = qtopensesame
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt4 import QtCore, QtGui
from libqtopensesame.misc import includes, config, _
from libqtopensesame.misc.config import cfg
from libqtopensesame.items import experiment
from libopensesame import debug, misc
from libopensesame.exceptions import osexception
import libopensesame.experiment
import libopensesame.plugins
import libopensesame.misc
import os.path
import os
import sys
import time
import traceback
import subprocess

class qtopensesame(QtGui.QMainWindow):

	"""The main class of the OpenSesame GUI"""

	# Set to False for release!
	devmode = False

	def __init__(self, app, parent=None):

		"""
		Constructor. This does very little, except prepare the app to be shown
		as rapidly as possible. The actual GUI initialization is handled by
		resume_init().

		Arguments:
		app -- the QApplication

		Keyword arguments:
		parent -- a link to the parent window
		"""

		if sys.platform == 'darwin':
			# Workaround for Qt issue on OS X that causes QMainWindow to
			# hide when adding QToolBar, see
			# https://bugreports.qt-project.org/browse/QTBUG-4300
			QtGui.QMainWindow.__init__(self, parent, \
				QtCore.Qt.MacWindowToolBarButtonHint)
		else:
			QtGui.QMainWindow.__init__(self, parent)
		self.app = app
		self.first_show = True

	def resume_init(self):

		"""Resume GUI initialization"""

		from libopensesame import misc
		from libqtopensesame.widgets import pool_widget
		from libqtopensesame.ui import opensesame_ui
		from libqtopensesame.misc import theme, dispatch
		import platform
		import random

		# Make sure that QProgEdit doesn't complain about some standard names
		from QProgEdit import validate
		validate.addPythonBuiltins([u'exp', u'win', u'self'])

		# Initialize random number generator
		random.seed()

		# Check the filesystem encoding for debugging purposes
		debug.msg(u'filesystem encoding: %s' % misc.filesystem_encoding())

		# Restore the configuration
		self.restore_config()

		# Setup dispatch
		self.dispatch = dispatch.dispatch(self)

		# Setup the UI
		self.ui = opensesame_ui.Ui_opensesame_mainwindow()
		self.ui.setupUi(self)
		self.ui.toolbar_items.main_window = self
		self.ui.itemtree.main_window = self
		self.ui.table_variables.main_window = self
		self.ui.tabwidget.main_window = self

		# Set some initial variables
		self.current_path = None
		self.version = misc.version
		self.codename = misc.codename
		self.lock_refresh = False
		self.unsaved_changes = False

		# Parse the command line
		self.parse_command_line()

		# Load a theme
		self.theme = theme.theme(self, self.options._theme)

		# Determine the home folder
		self.home_folder = libopensesame.misc.home_folder()

		# Determine autosave_folder
		if not os.path.exists(os.path.join(self.home_folder, u".opensesame")):
			os.mkdir(os.path.join(self.home_folder, u".opensesame"))
		if not os.path.exists(os.path.join(self.home_folder, u".opensesame", \
			u"backup")):
			os.mkdir(os.path.join(self.home_folder, u".opensesame", u"backup"))
		self.autosave_folder = os.path.join(self.home_folder, u".opensesame", \
			u"backup")

		# Set the filter-string for opening and saving files
		self.file_type_filter = \
			u"OpenSesame files (*.opensesame.tar.gz *.opensesame);;OpenSesame script and file pool (*.opensesame.tar.gz);;OpenSesame script (*.opensesame)"

		# Set the window message
		self.window_message(_(u"Welcome to OpenSesame %s") % self.version)

		# Set the window icon
		self.setWindowIcon(self.theme.qicon(u"opensesame"))

		# Make the connections
		self.ui.itemtree.itemClicked.connect(self.open_item)
		self.ui.action_quit.triggered.connect(self.closeEvent)
		self.ui.action_new.triggered.connect(self.new_file)
		self.ui.action_open.triggered.connect(self.open_file)
		self.ui.action_save.triggered.connect(self.save_file)
		self.ui.action_save_as.triggered.connect(self.save_file_as)
		self.ui.action_run.triggered.connect(self.run_experiment)
		self.ui.action_run_in_window.triggered.connect( \
			self.run_experiment_in_window)
		self.ui.action_run_quick.triggered.connect(self.run_quick)
		self.ui.action_enable_auto_response.triggered.connect( \
			self.set_auto_response)
		self.ui.action_close_all_tabs.triggered.connect( \
			self.ui.tabwidget.close_all)
		self.ui.action_close_other_tabs.triggered.connect( \
			self.ui.tabwidget.close_other)
		self.ui.action_onetabmode.triggered.connect( \
			self.ui.tabwidget.toggle_onetabmode)
		self.ui.action_show_overview.triggered.connect(self.toggle_overview)
		self.ui.action_show_variable_inspector.triggered.connect( \
			self.refresh_variable_inspector)
		self.ui.action_show_pool.triggered.connect(self.refresh_pool)
		self.ui.action_show_stdout.triggered.connect(self.refresh_stdout)
		self.ui.action_help.triggered.connect( \
			self.ui.tabwidget.open_general_help)
		self.ui.action_about.triggered.connect(self.ui.tabwidget.open_about)
		self.ui.action_online_documentation.triggered.connect( \
			self.ui.tabwidget.open_osdoc)
		self.ui.action_check_for_update.triggered.connect(self.check_update)
		self.ui.action_open_autosave_folder.triggered.connect( \
			self.open_autosave_folder)
		self.ui.action_preferences.triggered.connect( \
			self.ui.tabwidget.open_preferences)
		self.ui.action_add_loop.triggered.connect(self.drag_loop)
		self.ui.action_add_sequence.triggered.connect(self.drag_sequence)
		self.ui.action_add_sketchpad.triggered.connect(self.drag_sketchpad)
		self.ui.action_add_feedback.triggered.connect(self.drag_feedback)
		self.ui.action_add_sampler.triggered.connect(self.drag_sampler)
		self.ui.action_add_synth.triggered.connect(self.drag_synth)
		self.ui.action_add_keyboard_response.triggered.connect( \
			self.drag_keyboard_response)
		self.ui.action_add_mouse_response.triggered.connect( \
			self.drag_mouse_response)
		self.ui.action_add_logger.triggered.connect(self.drag_logger)
		self.ui.action_add_inline_script.triggered.connect( \
			self.drag_inline_script)
		self.ui.button_help_stdout.clicked.connect( \
			self.ui.tabwidget.open_stdout_help)

		# Setup the overview area
		self.ui.dock_overview.show()
		self.ui.dock_overview.visibilityChanged.connect( \
			self.ui.action_show_overview.setChecked)

		# Setup the variable inspector
		self.ui.dock_variable_inspector.hide()
		self.ui.button_help_variables.clicked.connect( \
			self.ui.tabwidget.open_variables_help)
		self.ui.dock_variable_inspector.visibilityChanged.connect( \
			self.ui.action_show_variable_inspector.setChecked)
		self.ui.edit_variable_filter.textChanged.connect( \
			self.refresh_variable_inspector)

		# Setup the file pool
		self.ui.dock_pool.hide()
		self.ui.dock_pool.visibilityChanged.connect( \
			self.ui.action_show_pool.setChecked)
		self.ui.pool_widget = pool_widget.pool_widget(self)
		self.ui.dock_pool.setWidget(self.ui.pool_widget)

		# Uncheck the debug window button on debug window close
		self.ui.dock_stdout.visibilityChanged.connect( \
			self.ui.action_show_stdout.setChecked)

		# Initialize keyboard shortcuts
		self.ui.shortcut_itemtree = QtGui.QShortcut( \
			QtGui.QKeySequence(), self, self.ui.itemtree.setFocus)
		self.ui.shortcut_tabwidget = QtGui.QShortcut( \
			QtGui.QKeySequence(), self, self.ui.tabwidget.setFocus)
		self.ui.shortcut_stdout = QtGui.QShortcut( \
			QtGui.QKeySequence(), self, self.ui.edit_stdout.setFocus)
		self.ui.shortcut_variables = QtGui.QShortcut( \
			QtGui.QKeySequence(), self, \
			self.ui.edit_variable_filter.setFocus)
		self.ui.shortcut_pool = QtGui.QShortcut( \
			QtGui.QKeySequence(), self, \
			self.ui.pool_widget.ui.edit_pool_filter.setFocus)

		# Create the initial experiment, which is the default template.
		self.experiment = experiment.experiment(self, u"New experiment", \
			open(misc.resource(os.path.join(u"templates", \
				u"default.opensesame")), u"r").read())

		# Miscellaneous initialization
		self.set_status(_(u"Welcome to OpenSesame %s") % self.version)
		self.restore_state()
		self.refresh_plugins()
		self.start_autosave_timer()
		self.update_recent_files()
		self.clean_autosave()
		self.set_unsaved(False)

	def parse_command_line(self):

		"""Parse command line options"""

		import optparse

		parser = optparse.OptionParser( \
			u"usage: opensesame [experiment] [options]", \
			version = u"%s '%s'" % (self.version, self.codename))
		parser.set_defaults(debug=False)
		parser.set_defaults(run=False)
		parser.set_defaults(run_in_window=False)
		group = optparse.OptionGroup(parser, u"Immediately run an experiment")
		group.add_option(u"-r", u"--run", action=u"store_true", dest=u"run", \
			help=u"Run fullscreen")
		group.add_option(u"-w", u"--run-in-window", action=u"store_true", \
			dest=u"run_in_window", help=u"Run in window")
		parser.add_option_group(group)
		group = optparse.OptionGroup(parser, u"Miscellaneous options")
		group.add_option(u"-c", u"--config", action=u"store", dest=u"_config", \
			help=u"Set a configuration option, e.g, '--config auto_update_check=False;scintilla_font_size=10'. For a complete list of configuration options, please refer to the source of config.py.")
		group.add_option(u"-t", u"--theme", action=u"store", dest=u"_theme", \
			help=u"Specify a GUI theme")
		group.add_option(u"-d", u"--debug", action=u"store_true", dest= \
			u"debug", help= \
			u"Print lots of debugging messages to the standard output")
		group.add_option(u"--start-clean", action=u"store_true", dest= \
			u"start_clean", help= \
			u"Do not load configuration and do not restore window geometry")
		group.add_option(u"-s", u"--stack", action=u"store_true", dest= \
			u"_stack", help=u"Print stack trace (only in debug mode)")
		group.add_option(u"-p", u"--preload", action=u"store_true", dest= \
			u"preload", help=u"Preload Python modules")
		group.add_option(u"--pylink", action=u"store_true", dest=u"pylink", \
			help=u"Load PyLink before PyGame (necessary for using the Eyelink plug-ins in non-dummy mode)")
		group.add_option(u"--ipython", action=u"store_true", dest=u"ipython", \
			help=u"Enable the IPython interpreter")
		group.add_option(u"--locale", action=u"store_true", dest=u"locale", \
			help=u"Specify localization")
		group.add_option(u"--catch-translatables", action=u"store_true", \
			dest=u"catch_translatables", help=u"Log all translatable text")
		group.add_option(u"--no-global-resources", action=u"store_true", dest= \
			u"no_global_resources", help= \
			u"Do not use global resources on *nix")
		parser.add_option_group(group)
		self.options, args = parser.parse_args(sys.argv)
		if self.options.run and self.options.run_in_window:
			parser.error( \
				u"Options -r / --run and -w / --run-in-window are mutually exclusive.")

	def restore_config(self):

		"""Restores the configuration settings, but doesn't apply anything"""

		debug.msg()
		settings = QtCore.QSettings(u"cogscinl", u"opensesame")
		settings.beginGroup(u"MainWindow")
		config.restore_config(settings)
		settings.endGroup()

	def restore_state(self):

		"""Restore the current window to the saved state"""

		debug.msg()

		# Force configuration options that were set via the command line
		config.parse_cmdline_args(self.options._config)
		self.recent_files = []
		if self.options.start_clean:
			debug.msg(u'Not restoring state')
			return
		self.resize(cfg.size)
		self.move(cfg.pos)
		self.experiment.auto_response = cfg.auto_response
		# Set the keyboard shortcuts
		self.ui.shortcut_itemtree.setKey(QtGui.QKeySequence( \
			cfg.shortcut_itemtree))
		self.ui.shortcut_tabwidget.setKey(QtGui.QKeySequence( \
			cfg.shortcut_tabwidget))
		self.ui.shortcut_stdout.setKey(QtGui.QKeySequence(cfg.shortcut_stdout))
		self.ui.shortcut_pool.setKey(QtGui.QKeySequence(cfg.shortcut_pool))
		self.ui.shortcut_variables.setKey(QtGui.QKeySequence( \
			cfg.shortcut_variables))
		# Unpack the string with recent files and only remember those that exist
		for path in cfg.recent_files.split(u";;"):
			if os.path.exists(path):
				debug.msg(u"adding recent file '%s'" % path)
				self.recent_files.append(path)
			else:
				debug.msg(u"missing recent file '%s'" % path)
		self.ui.action_enable_auto_response.setChecked( \
			self.experiment.auto_response)
		self.ui.action_onetabmode.setChecked(cfg.onetabmode)
		self.ui.action_compact_toolbar.setChecked( \
			cfg.toolbar_size == 16)
		self.ui.tabwidget.toggle_onetabmode()
		if cfg.toolbar_text:
			self.ui.toolbar_main.setToolButtonStyle( \
				QtCore.Qt.ToolButtonTextUnderIcon)
		else:
			self.ui.toolbar_main.setToolButtonStyle( \
				QtCore.Qt.ToolButtonIconOnly)
		self.set_style()
		self.theme.set_toolbar_size(cfg.toolbar_size)

	def restore_window_state(self):

		"""
		This is done separately from the rest of the restoration, because if we
		don't wait until the end, the window gets distorted again.
		"""

		if self.options.start_clean:
			debug.msg(u'Not restoring window state')
			return
		self.restoreState(cfg._initial_window_state)
		self.restoreGeometry(cfg._initial_window_geometry)

	def save_state(self):

		"""Restores the state of the current window"""

		debug.msg()
		settings = QtCore.QSettings(u"cogscinl", u"opensesame")
		settings.beginGroup(u"MainWindow")
		config.save_config(settings)
		settings.setValue(u"size", self.size())
		settings.setValue(u"pos", self.pos())
		settings.setValue(u"_initial_window_geometry", self.saveGeometry())
		settings.setValue(u"_initial_window_state", self.saveState())
		settings.setValue(u"auto_response", self.experiment.auto_response)
		settings.setValue(u"toolbar_text", \
			self.ui.toolbar_main.toolButtonStyle() == \
			QtCore.Qt.ToolButtonTextUnderIcon)
		settings.setValue(u"recent_files", u";;".join(self.recent_files))
		settings.endGroup()

	def set_busy(self, state=True):

		"""
		Show/ hide the busy notification

		Keywords arguments:
		state -- indicates the busy status (default=True)
		"""

		if state:
			self.set_status(_(u"Busy ..."), status=u"busy")
		else:
			self.set_status(_(u"Done!"))
		QtGui.QApplication.processEvents()

	def set_style(self):

		"""Appply the application style"""

		if cfg.style in QtGui.QStyleFactory.keys():
			self.setStyle(QtGui.QStyleFactory.create(cfg.style))
			debug.msg(u"using style '%s'" % cfg.style)
		else:
			debug.msg(u"ignoring unknown style '%s'" % cfg.style)
			cfg.style = u''

	def set_auto_response(self):

		"""Set the auto response based on the menu action"""

		self.experiment.auto_response = \
			self.ui.action_enable_auto_response.isChecked()
		self.update_preferences_tab()

	def open_autosave_folder(self):

		"""Browse the autosave folder in a platform specific way"""

		if os.name == u"nt":
			os.startfile(self.autosave_folder)
		elif os.name == u"posix":
			misc.open_url(self.autosave_folder)

	def start_autosave_timer(self):

		"""If autosave is enabled, construct and start the autosave timer"""

		if cfg.autosave_interval > 0:
			debug.msg(u"autosave interval = %d ms" % cfg.autosave_interval)
			self.autosave_timer = QtCore.QTimer()
			self.autosave_timer.setInterval(cfg.autosave_interval)
			self.autosave_timer.setSingleShot(True)
			self.autosave_timer.timeout.connect(self.autosave)
			self.autosave_timer.start()
		else:
			debug.msg(u"autosave disabled")
			self.autosave_timer = None

	def autosave(self):

		"""Autosave the experiment if there are unsaved changes"""

		if not self.unsaved_changes:
			self.set_status(u'No unsaved changes, skipping backup')
			autosave_path = u''
		else:
			_current_path = self.current_path
			_experiment_path = self.experiment.experiment_path
			_unsaved_changes = self.unsaved_changes
			_window_msg = self.window_msg
			self.current_path = os.path.join(self.autosave_folder, \
				u'%s.opensesame.tar.gz'% unicode(time.ctime()).replace(u':', \
				u'_'))
			debug.msg(u"saving backup as %s" % self.current_path)
			try:
				self.save_file(False, remember=False, catch=False)
				self.set_status(_(u'Backup saved as %s') % self.current_path)
			except:
				self.set_status(_(u'Failed to save backup ...'))
			autosave_path = self.current_path
			self.current_path = _current_path
			self.experiment.experiment_path = _experiment_path
			self.set_unsaved(_unsaved_changes)
			self.window_message(_window_msg)
		self.start_autosave_timer()
		return autosave_path

	def clean_autosave(self):

		"""Remove old files from the back-up folder"""

		for path in os.listdir(self.autosave_folder):
			_path = os.path.join(self.autosave_folder, path)
			t = os.path.getctime(_path)
			age = (time.time() - t)/(60*60*24)
			if age > cfg.autosave_max_age:
				debug.msg(u"removing '%s'" % path)
				try:
					os.remove(_path)
				except:
					debug.msg(u"failed to remove '%s'" % path)

	def save_unsaved_changes(self):

		"""
		If there are unsaved changes, present a dialog and save the changes if
		requested
		"""

		if not self.unsaved_changes:
			return True
		resp = QtGui.QMessageBox.question(self.ui.centralwidget, \
			_(u"Save changes?"), \
			_(u"Your experiment contains unsaved changes. Do you want to save your experiment?"), \
			QtGui.QMessageBox.Yes, QtGui.QMessageBox.No, \
				QtGui.QMessageBox.Cancel)
		if resp == QtGui.QMessageBox.Cancel:
			return False
		if resp == QtGui.QMessageBox.Yes:
			self.save_file()
		return True

	def set_unsaved(self, unsaved_changes=True):

		"""
		Set the unsaved changes status

		Keyword arguments:
		unsaved_changes -- a boolean indicating if there are unsaved changes
						   (default=True)
		"""

		self.unsaved_changes = unsaved_changes
		self.window_message()
		debug.msg(u"unsaved = %s" % unsaved_changes)

	def set_status(self, msg, timeout=5000, status=u'ready'):

		"""
		Prints a text message to the statusbar.

		Arguments:
		msg			--	The message.

		Keyword arguments:
		timeout		--	A value in milliseconds after which the message is
						removed. (default=5000)
		status		--	The status. (default=u'ready')
		"""

		self.ui.statusbar.set_status(msg, timeout=timeout, status=status)

	def window_message(self, msg=None):

		"""
		Display a message in the window border, including an unsaved message
		indicator.

		Keyword arguments:
		msg		--	An optional message, if the message should be changed.
					(default=None)
		"""

		if msg != None:
			self.window_msg = msg
		if self.unsaved_changes:
			self.setWindowTitle(_(u"%s [unsaved]") % self.window_msg)
		else:
			self.setWindowTitle(self.window_msg)

	def set_immediate_rename(self):

		"""Set the immediate rename option based on the menu action"""

		cfg.immediate_rename = self.ui.action_immediate_rename.isChecked()
		debug.msg(u"set to %s" % cfg.immediate_rename)

	def update_dialog(self, message):

		"""
		Presents an update dialog

		Arguments:
		message -- the message to be displayed
		"""

		from libqtopensesame.ui import update_dialog_ui

		a = QtGui.QDialog(self)
		a.ui = update_dialog_ui.Ui_update_dialog()
		a.ui.setupUi(a)
		self.theme.apply_theme(a)
		a.ui.checkbox_auto_check_update.setChecked(cfg.auto_update_check)
		a.ui.textedit_notification.setHtml(message)
		a.adjustSize()
		a.exec_()
		cfg.auto_update_check = a.ui.checkbox_auto_check_update.isChecked()
		self.update_preferences_tab()

	def check_update(self, dummy=None, always=True):

		"""
		Contacts www.cogsci.nl to check for the most recent version

		Keyword arguments:
		dummy -- a dummy argument passed by the signal handler
		always -- a boolean indicating if a dialog should be shown
				  regardless of the auto check update setting and the
				  outcome of the update check
		"""

		import urllib

		if not always and not cfg.auto_update_check:
			debug.msg(u"skipping update check")
			return

		debug.msg(u"opening %s" % cfg.version_check_url)

		try:
			fd = urllib.urlopen(cfg.version_check_url)
			mrv = float(fd.read().strip())
		except Exception as e:
			if always:
				self.update_dialog( \
					_(u"... and is sorry to say that the attempt to check for updates has failed. Please make sure that you are connected to the internet and try again later. If this problem persists, please visit <a href='http://www.cogsci.nl/opensesame'>http://www.cogsci.nl/opensesame</a> for more information."))
			return

		# The most recent version as downloaded is always a float. Therefore, we
		# must convert the various possible version numbers to analogous floats.
		# We do this by dividing each subversion number by 100. The only
		# exception is that prereleases should be counted as older than stable
		# releases, so for pre-release we substract one bugfix version.
		# 0.27			->	0.27.0.0			->	0.27
		# 0.27.1 		-> 	0.27.1.0			->	0.2701
		# 0.27~pre1		->	0.27.0.1 - .0001	-> 	0.269901
		# 0.27.1~pre1	->	0.27.1.1 - .0001	-> 	0.270001
		v = self.version
		l = v.split(u"~pre")
		if len(l) == 2:
			lastSubVer = l[1]
			v = l[0]
			ver = -.0001
		else:
			lastSubVer = 0
			ver = .0
		lvl = 0
		fct = .01
		for subVer in v.split(u'.') + [lastSubVer]:
			try:
				_subVer = int(subVer)
			except:
				debug.msg(u'Failed to process version segment %s' % subVer, \
					reason=u'warning')
				return
			ver += fct**lvl * _subVer
			lvl += 1
		debug.msg(u'identifying as version %s' % ver)
		debug.msg(u'latest stable version is %s' % mrv)
		if mrv > ver:
			self.update_dialog( \
				_(u"... and is happy to report that a new version of OpenSesame (%s) is available at <a href='http://www.cogsci.nl/opensesame'>http://www.cogsci.nl/opensesame</a>!") % mrv)
		else:
			if always:
				self.update_dialog( \
					_(u" ... and is happy to report that you are running the most recent version of OpenSesame."))

	def update_preferences_tab(self):

		"""
		If the preferences tab is open, make sure that its controls are updated
		to match potential changes to the preferences
		"""

		w = self.ui.tabwidget.get_widget(u'__preferences__')
		if w != None:
			w.set_controls()

	def show_text_in_toolbar(self):

		"""
		Set the toolbar style (text/ icons only) based on the menu action status
		"""

		if self.ui.action_show_text_in_toolbar.isChecked():
			style = QtCore.Qt.ToolButtonTextUnderIcon
		else:
			style = QtCore.Qt.ToolButtonIconOnly
		self.ui.toolbar_main.setToolButtonStyle(style)

	def toggle_overview(self, dummy=None):

		"""
		Set the visibility of the overview area based on the state of the
		toolbar action

		Keyword arguments:
		dummy -- a dummy argument passed by the signal handler (default=None)
		"""

		if not self.ui.action_show_overview.isChecked():
			self.ui.dock_overview.setVisible(False)
			return
		self.ui.dock_overview.setVisible(True)

	def refresh_plugins(self, dummy=None):

		"""
		Populate the menu with plug-in entries

		Keyword arguments:
		dummy -- a dummy argument passed by the signal handler
		"""

		self.populate_plugin_menu(self.ui.menu_items)

	def refresh_stdout(self, dummy=None):

		"""
		Set the visibility of the debug window (stdout) based on
		the menu action status

		Keyword arguments:
		dummy -- a dummy argument passed by the signal handler (default=None)
		"""

		if not self.ui.action_show_stdout.isChecked():
			self.ui.dock_stdout.setVisible(False)
			return
		self.ui.dock_stdout.setVisible(True)

	def refresh_pool(self, make_visible=None):

		"""
		Refresh the file pool

		Keyword arguments:
		make_visible -- an optional boolean that sets the visibility of the file
						pool (default = None)
		"""

		if make_visible != None:
			self.ui.action_show_pool.setChecked(make_visible)
		if not self.ui.action_show_pool.isChecked():
			self.ui.dock_pool.setVisible(False)
			return
		self.ui.dock_pool.setVisible(True)
		self.ui.pool_widget.refresh()

	def refresh_variable_inspector(self, dummy=None):

		"""
		Refresh the variable inspector and sets the visibility based on the menu
		action status

		Keyword arguments:
		dummy -- a dummy argument passed by the signal handler
		"""

		if self.ui.action_show_variable_inspector.isChecked():
			self.ui.dock_variable_inspector.setVisible(True)
			self.ui.table_variables.refresh()
		else:
			self.ui.dock_variable_inspector.setVisible(False)

	def closeEvent(self, e):

		"""
		Process a closeEvent, which occurs when the window managers close button
		is clicked

		Arguments:
		e -- the closeEvent or a bool
		"""

		if debug.enabled or self.devmode:
			libopensesame.experiment.clean_up(debug.enabled)
			self.save_state()
			if isinstance(e, bool):
				QtCore.QCoreApplication.quit()
			else:
				e.accept()
			return
		resp = QtGui.QMessageBox.question(self.ui.centralwidget, _(u"Quit?"), \
			_(u"Are you sure you want to quit OpenSesame?"), \
			QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)
		if resp == QtGui.QMessageBox.No:
			if not isinstance(e, bool):
				e.ignore()
				return
		if not self.save_unsaved_changes():
			e.ignore()
			return
		self.save_state()
		libopensesame.experiment.clean_up(debug.enabled)
		if isinstance(e, bool):
			QtCore.QCoreApplication.quit()
		else:
			e.accept()

	def update_recent_files(self):

		"""Recreate the list with recent documents"""

		from libqtopensesame.actions import recent_action

		# Add the current path to the front of the list
		if self.current_path != None and os.path.exists(self.current_path):
			if self.current_path in self.recent_files:
				self.recent_files.remove(self.current_path)
			self.recent_files.insert(0, self.current_path)

		# Trim the list
		self.recent_files = self.recent_files[:5]

		# Build the menu
		self.ui.menu_recent_files.clear()
		if len(self.recent_files) == 0:
			a = QtGui.QAction(_(u"(No recent files)"), \
				self.ui.menu_recent_files)
			a.setDisabled(True)
			self.ui.menu_recent_files.addAction(a)
		else:
			for path in self.recent_files:
				self.ui.menu_recent_files.addAction( \
					recent_action.recent_action(path, self, \
					self.ui.menu_recent_files))

	def new_file(self):

		"""Discard the current experiment and start with a new file"""

		self.ui.tabwidget.open_start_new()

	def open_file(self, dummy=None, path=None, add_to_recent=True):

		"""
		Open a .opensesame or .opensesame.tar.gz file

		Keyword arguments:
		dummy -- An unused argument which is passed by the signal (default=None)
		path -- The path to the file. If None, a file dialog is presented
				(default=None)
		"""

		if not self.save_unsaved_changes():
			self.ui.tabwidget.open_general()
			return
		if path == None:
			path = unicode(QtGui.QFileDialog.getOpenFileName(
				self.ui.centralwidget, _(u"Open file"),
				filter=self.file_type_filter, directory=cfg.file_dialog_path))
		if path == None or path == u'' or (not path.lower().endswith(
			u'.opensesame') and not path.lower().endswith(
			u'.opensesame.tar.gz')):
			return
		self.set_status(u"Opening ...")
		self.ui.tabwidget.close_all()
		cfg.file_dialog_path = os.path.dirname(path)
		try:
			exp = experiment.experiment(self, u"Experiment", path)
		except Exception as e:

			if not isinstance(e, osexception):
				e = osexception(msg=u'Failed to open file', exception=e)
			self.print_debug_window(e)
			self.experiment.notify(e.html(), title=u'Exception')
			return

		self.experiment = exp
		self.refresh()
		self.ui.tabwidget.open_general()
		self.set_status(u"Opened %s" % path)

		if add_to_recent:
			self.current_path = path
			self.window_message(self.current_path)
			self.update_recent_files()
			cfg.default_logfile_folder = os.path.dirname(self.current_path)
		else:
			self.window_message(u"New experiment")
			self.current_path = None

		self.set_auto_response()
		self.set_unsaved(False)

	def save_file(self, dummy=None, remember=True, catch=True):

		"""
		Save the current experiment

		Keyword arguments:
		dummy -- a dummy argument passed by the signal handler (default=None)
		remember -- a boolean indicating whether the file should be included in
					the list of recent files (default=True)
		catch -- a boolean indicating whether exceptions should be caught and
				 displayed in a notification (default=True)
		"""

		if self.current_path == None:
			self.save_file_as()
			return

		# Indicate that we're busy
		self.set_busy(True)
		QtGui.QApplication.processEvents()

		# Get ready, generate the script and see if the script can be
		# re-parsed. In debug mode any errors are not caught. Otherwise. a
		# neat exception is thrown.
		if debug.enabled:
			self.get_ready()
			script = self.experiment.to_string()
			experiment.experiment(self, u"Experiment", script)
		else:
			try:
				self.get_ready()
				script = self.experiment.to_string()
				experiment.experiment(self, u"Experiment", script)
			except osexception as e:
				if not catch:
					raise e
				self.experiment.notify( \
					_(u"Could not save file, because the script could not be generated. The following error occured:<br/>%s") \
					% e)
				self.set_busy(False)
				return

		# Try to save the experiment if it doesn't exist already
		if debug.enabled:
			resp = self.experiment.save(self.current_path, overwrite=True)
			self.set_status(_(u"Saved as %s") % self.current_path)
		else:
			try:
				resp = self.experiment.save(self.current_path, overwrite=True)
				self.set_status(_(u"Saved as %s") % self.current_path)
			except Exception as e:
				if not catch:
					raise e
				self.experiment.notify(_(u"Failed to save file. Error: %s") % e)
				self.set_busy(False)
				return

		if remember:
			self.update_recent_files()
		self.set_unsaved(False)
		self.window_message(self.current_path)
		self.set_busy(False)

	def save_file_as(self):

		"""Save the current experiment after asking for a file name"""

		if self.current_path == None:
			cfg.file_dialog_path = os.path.join(self.home_folder, \
				self.experiment.sanitize(self.experiment.title, strict=True, \
				allow_vars=False))
		else:
			cfg.file_dialog_path = self.current_path
		path, file_type = QtGui.QFileDialog.getSaveFileNameAndFilter( \
			self.ui.centralwidget, _(u'Save file as ...'), directory= \
			cfg.file_dialog_path, filter=self.file_type_filter)

		if path != None and path != u"":
			path = unicode(path)
			cfg.file_dialog_path = os.path.dirname(path)

			# If the extension has not been explicitly typed in, set it based
			# on the selected filter and, if no filter has been set, based on
			# whether there is content in the file pool
			if path[-18:].lower() != u".opensesame.tar.gz" and \
				path[-11:].lower() != u".opensesame":
				debug.msg(u"automagically determing file type")
				if u"(*.opensesame)" in file_type:
					path += u".opensesame"
				elif u"(*.opensesame.tar.gz)" in file_type:
					path += u".opensesame.tar.gz"
				elif len(os.listdir(self.experiment.pool_folder)) == 0:
					path += u".opensesame"
				else:
					path += u".opensesame.tar.gz"
				debug.msg(path)

			self.current_path = path
			self.save_file()

	def close_item_tab(self, item, close_edit=True, close_script=True):

		"""
		Closes all tabs that edit and/ or script tabs of a specific item.

		Arguments:
		item			--	The name of the item.

		Keyword arguments:
		close_edit		--	A boolean indicating whether the edit tab should be
							closed. (default=True)
		close_script	--	A boolean indicating whether the script tab should
							be closed. (default=True)
		"""

		debug.msg(u"closing tabs for '%s'" % item)

		# There's a kind of double loop, because the indices change
		# after a deletion
		redo = True
		while redo:
			redo = False
			for i in range(self.ui.tabwidget.count()):
				w = self.ui.tabwidget.widget(i)
				if close_edit and hasattr(w, u"edit_item") and \
					w.edit_item == item:
					self.ui.tabWidget.removeTab(i)
					redo = True
					break
				if close_script and hasattr(w, u"script_item") and \
					w.script_item == item:
					self.ui.tabWidget.removeTab(i)
					redo = True
					break

	def update_resolution(self, width, height):

		"""
		Updates the resolution in a way that preserves display centering. This
		is kind of a quick hack. First generate the script, change the
		resolution in the script and then re-parse the script.

		Arguments:
		width -- the display width in pixels
		height -- the display height in pixels
		"""

		debug.msg(u"changing resolution to %d x %d" % (width, height))

		try:
			script = self.experiment.to_string()
		except Exception as e:
			if not isinstance(e, osexception):
				e = osexception(u'Failed to change the display resolution', \
					exception=e)
			self.experiment.notify(e.html())
			return

		script = script.replace(u"\nset height \"%s\"\n" % \
			self.experiment.get(u"height"), u"\nset height \"%s\"\n" % height)
		script = script.replace(u"\nset width \"%s\"\n" % \
			self.experiment.get(u"width"), u"\nset width \"%s\"\n" % width)

		try:
			tmp = experiment.experiment(self, self.experiment.title, script, \
				self.experiment.pool_folder)
		except osexception as error:
			self.experiment.notify(_(u"Could not parse script: %s") % error)
			self.edit_script.edit.setText(self.experiment.to_string())
			return

		self.experiment = tmp
		self.refresh()

	def build_item_list(self, name=None):

		"""
		Refreshes the item list

		Keyword arguments:
		name -- a name of the item that has called the build (default=None)
		"""

		debug.msg(name)
		self.experiment.build_item_tree()

	def select_item(self, name):

		"""
		Selects an item from the itemlist and opens the corresponding edit tab

		Arguments:
		name -- the name of the item
		"""

		debug.msg(name)
		if name in self.experiment.unused_items:
			self.experiment.unused_widget.setExpanded(True)
		for item in self.ui.itemtree.findItems(name, \
			QtCore.Qt.MatchFlags(QtCore.Qt.MatchRecursive)):
			self.ui.itemtree.setCurrentItem(item)
		if name in self.experiment.items:
			self.experiment.items[name].open_tab()

	def open_item(self, widget, dummy=None):

		"""
		Open a tab belonging to a widget in the item tree

		Arguments:
		widget -- a QTreeWidgetItem

		Keyword arguments:
		dummy -- an unused parameter which is passed on automatically by the
				 signaller
		"""

		if widget.name == u"__general__":
			self.ui.tabwidget.open_general()
		elif widget.name == u"__unused__":
			self.ui.tabwidget.open_unused()
		else:
			self.experiment.items[widget.name].open_tab()

	def copy_to_pool(self, fname):

		"""
		Copy a file to the file pool

		Arguments:
		fname -- full path to file
		"""

		import shutil

		renamed = False
		_fname = os.path.basename(fname)
		while os.path.exists(os.path.join(self.experiment.pool_folder, _fname)):
			_fname = u"_" + _fname
			renamed = True

		if renamed:
			QtGui.QMessageBox.information(self.ui.centralwidget, \
				_(u"File renamed"), \
				_(u"The file has been renamed to '%s', because the file pool already contains a file named '%s'.") \
				% (_fname, os.path.basename(fname)))

		shutil.copyfile(fname, os.path.join(self.experiment.pool_folder, _fname))
		self.refresh_pool(True)

	def get_ready(self):

		"""Give all items the opportunity to get ready for running or saving"""

		# Redo the get_ready loop until no items report having done
		# anything
		debug.msg()
		redo = True
		done = []
		while redo:
			redo = False
			for item in self.experiment.items:
				if item not in done:
					done.append(item)
					if self.experiment.items[item].get_ready():
						debug.msg(u"'%s' did something" % item)
						redo = True
						break

	def print_debug_window(self, msg):

		"""
		Prints a message to the debug window.

		Arguments:
		msg		--	An object to print to the debug window.
		"""

		from libqtopensesame.widgets import pyterm
		out = pyterm.output_buffer(self.ui.edit_stdout)
		out.write(self.experiment.unistr(msg))

	def run_experiment(self, dummy=None, fullscreen=True, quick=False):

		"""
		Runs the current experiment.

		Keyword arguments:
		dummy 		--	A dummy argument that is passed by signaler.
						(default=None)
		fullscreen	--	A boolean to indicate whether the window should be
						fullscreen. (default=True)
		quick		--	A boolean to indicate whether default should be used for
						the log-file and subject number. Mostly useful while
						testing the experiment. (default=False)
		"""

		from libqtopensesame.widgets import pyterm

		# Disable the entire Window, so that we can't interact with OpenSesame.
		# TODO: This should be more elegant, so that we selectively disable
		# parts of the GUI.
		if sys.platform != 'darwin':
			self.setDisabled(True)
		# Suspend autosave
		if self.autosave_timer != None:
			debug.msg(u"stopping autosave timer")
			self.autosave_timer.stop()
		# Reroute the standard output to the debug window
		buf = pyterm.output_buffer(self.ui.edit_stdout)
		sys.stdout = buf
		# Launch the runner!
		if cfg.runner == u'multiprocess':
			from libqtopensesame.runners import multiprocess_runner as runner
		elif cfg.runner == u'inprocess':
			from libqtopensesame.runners import inprocess_runner as runner
		elif cfg.runner == u'external':
			from libqtopensesame.runners import external_runner as runner
		debug.msg(u'using %s runner' % runner)
		runner(self).run(quick=quick, fullscreen=fullscreen, auto_response= \
			self.experiment.auto_response)
		# Undo the standard output rerouting
		sys.stdout = sys.__stdout__
		self.ui.edit_stdout.show_prompt()
		# Resume autosave
		if self.autosave_timer != None:
			debug.msg(u"resuming autosave timer")
			self.autosave_timer.start()
		# Re-enable the GUI.
		if sys.platform != 'darwin':
			self.setDisabled(False)

	def run_experiment_in_window(self):

		"""Runs the experiment in a window"""

		self.run_experiment(fullscreen=False)

	def run_quick(self):

		"""Run the experiment without asking for subject nr and logfile"""

		self.run_experiment(fullscreen=False, quick=True)

	def refresh(self, changed_item=None, refresh_edit=True, \
		refresh_script=True):

		"""
		Refreshes all parts of the interface that may have changed because of a
		changed item

		Keyword arguments:
		changed_item -- the name of a specific item that should be refreshed
						(default = None)
		refresh_edit -- a boolean to indicate if the edit tabs should be
						refreshed (default = True)
		refresh_script -- a boolean to indicate if the script tabs should be
						  refreshed (default = True)
		"""

		# Make sure the refresh does not get caught in
		# a recursive loop
		if self.lock_refresh:
			return
		self.lock_refresh = True

		self.set_busy(True)
		debug.msg(changed_item)

		index = self.ui.tabwidget.currentIndex()
		for i in range(self.ui.tabwidget.count()):
			w = self.ui.tabwidget.widget(i)
			if hasattr(w, u"__general_tab__"):
				w.refresh()
			# For now the unused tab doesn't need to be refreshed
			if hasattr(w, u"__unused_tab__"):
				pass
			if refresh_edit and hasattr(w, u"__edit_item__") and (changed_item \
				== None or w.__edit_item__ == changed_item):
				if w.__edit_item__ in self.experiment.items:
					self.experiment.items[w.__edit_item__].edit_widget()
			if refresh_script and hasattr(w, u"__script_item__") and ( \
				changed_item == None or w.__script_item__ == changed_item):
				if w.__script_item__ in self.experiment.items:
					self.experiment.items[w.__script_item__].script_widget()

		self.ui.tabwidget.setCurrentIndex(index)
		self.build_item_list()
		self.refresh_variable_inspector()
		self.refresh_pool()
		self.lock_refresh = False
		self.set_busy(False)

	def hard_refresh(self, changed_item):

		"""
		Closes and reopens the tabs for a changed item. This is different from
		the normal refresh in the sense that here the tabs are reinitialized
		from scratch which is necessary if a new instance of the item has been
		created.

		Arguments:
		changed_item -- the name of the changed item
		"""

		# Make sure the refresh does not get caught in
		# a recursive loop
		if self.lock_refresh:
			return
		self.lock_refresh = True

		self.set_busy(True)
		debug.msg(changed_item)
		index = self.ui.tabwidget.currentIndex()

		for i in range(self.ui.tabwidget.count()):
				w = self.ui.tabwidget.widget(i)
				if hasattr(w, u"edit_item") and (changed_item == None or \
					w.edit_item == changed_item) and w.edit_item in \
					self.experiment.items:
					debug.msg(u"reopening edit tab %s" % changed_item)
					self.ui.tabwidget.removeTab(i)
					self.experiment.items[w.edit_item].open_edit_tab(i, False)
					w = self.ui.tabwidget.widget(i)
					w.edit_item = changed_item
				if hasattr(w, u"script_item") and (changed_item == None or \
					w.script_item == changed_item) and w.script_item in \
					self.experiment.items:
					debug.msg(u"reopening script tab %s" % changed_item)
					self.ui.tabwidget.removeTab(i)
					self.experiment.items[w.script_item].open_script_tab(i, \
						False)
					w = self.ui.tabwidget.widget(i)
					w.script_item = changed_item

		self.ui.tabwidget.setCurrentIndex(index)
		self.lock_refresh = False
		self.set_busy(False)

	def populate_plugin_menu(self, menu):

		"""
		Adds a list of plugins to a menu

		Arguments:
		menu -- a QMenu instance
		"""

		from libqtopensesame.actions import plugin_action

		cat_menu = {}
		for plugin in libopensesame.plugins.list_plugins():
			debug.msg(u"found plugin '%s'" % plugin)
			cat = libopensesame.plugins.plugin_category(plugin)
			if cat not in cat_menu:
				cat_menu[cat] = QtGui.QMenu(cat)
				cat_menu[cat] = menu.addMenu(self.experiment.icon(u"plugin"), \
					cat)
			cat_menu[cat].addAction(plugin_action.plugin_action(self, \
				cat_menu[cat], plugin))

	def add_item(self, item_type, refresh=True, name=None, interactive=True):

		"""
		Adds a new item to the item list

		Arguments:
		item_type -- the type of the item to add

		Keyword arguments:
		refresh -- a bool to indicate if the interface should be refreshed
				   (default=True)
		name -- a custom name to give the item (default=None)
		interactive -- indicates whether the GUI is allowed to be interactive.
					   More specifically, this means that the GUI can ask for
					   a new name, if the immediate rename option is enabled.
					   (default=True)

		Returns:
		The name of the new item
		"""

		# Get a unique name if none has been specified
		name = self.experiment.unique_name(u"%s" % item_type)
		debug.msg(u"adding %s (%s)" % (name, item_type))
		# If the item type is a plugin, we need to use the plugin mechanism
		if libopensesame.plugins.is_plugin(item_type):
			try:
				item = libopensesame.plugins.load_plugin(item_type, name, \
					self.experiment, None, self.experiment.item_prefix())
			except Exception as e:
				if not isinstance(e, osexception):
					e = osexception(msg=u"Failed to load plug-in '%s'" \
						% item_type, exception=e)
				self.print_debug_window(e)
				self.experiment.notify(e.html(), title=u'Exception')
				return
		else:
			# Load a core item
			debug.msg(u"loading core item '%s' from '%s'" % (item_type, \
				self.experiment.module_container()))
			item_module = __import__(u'%s.%s' % ( \
				self.experiment.module_container(), item_type), fromlist= \
				[u'dummy'])
			item_class = getattr(item_module, item_type)
			item = item_class(name, self.experiment)
		# Optionally, ask for a new name right away
		if interactive and cfg.immediate_rename:
			while True:
				name, ok = QtGui.QInputDialog.getText(self, _(u"New name"), \
					_(u"Please enter a name for the new %s") % item_type, \
					text=name)
				name = self.experiment.sanitize(unicode(name), strict=True, \
					allow_vars=False)
				if name not in self.experiment.items:
					break
			if not ok:
				return None
			name = unicode(name)
			item.name = name
		# Add the item to the item list
		self.experiment.items[name] = item
		self.set_unsaved()
		# Optionally, refresh the interface
		if refresh:
			debug.msg(u"refresh")
			self.refresh()
			self.select_item(name)
		return name

	def add_loop(self, refresh=True, parent=None):

		"""
		Add a loop item and ask for an item to fill the loop with

		Keyword arguments:
		refresh -- a bool to indicate if the interface should be refreshed
				   (default=True)
		parent -- the parent item for the new loop (default=None)

		Returns:
		The name of the new loop
		"""

		from libqtopensesame.dialogs import new_loop_sequence_dialog

		d = new_loop_sequence_dialog.new_loop_sequence_dialog(self, \
			self.experiment, u"loop", parent)
		d.exec_()
		if d.action == u"cancel":
			return None
		loop = self.add_item(u"loop", False)
		if d.action == u"new":
			item_name = self.add_item(d.item_type, False)
			self.experiment.items[loop].set(u"item", item_name)
		else:
			self.experiment.items[loop].set(u"item", d.item_name)
		if refresh:
			self.refresh()
			self.select_item(loop)
		return loop

	def add_sequence(self, refresh=True, parent=None):

		"""
		Add a sequence item and ask for an item to fill the loop with

		Keyword arguments:
		refresh -- a bool to indicate if the interface should be refreshed
				   (default=True)
		parent -- the parent item for the new sequence (default=None)

		Returns:
		The name of the new sequence
		"""

		from libqtopensesame.dialogs import new_loop_sequence_dialog

		d = new_loop_sequence_dialog.new_loop_sequence_dialog(self, \
			self.experiment, u"sequence", parent)
		d.exec_()
		if d.action == u"cancel":
			return None
		seq = self.add_item(u"sequence", False)
		if d.action == u"new":
			item_name = self.add_item(d.item_type, False)
			self.experiment.items[seq].items.append((item_name, u"always"))
		else:
			self.experiment.items[seq].items.append((d.item_name, u"always"))
		if refresh:
			self.refresh()
			self.select_item(seq)

		return seq

	def add_sketchpad(self, refresh=True, parent=None):

		"""
		Add a sketchpad item and ask for an item to fill the loop with

		Keyword arguments:
		refresh -- a bool to indicate if the interface should be refreshed
				   (default=True)
		parent -- the parent item for the new item (default = None)

		Returns:

		The name of the new item
		"""

		return self.add_item(u"sketchpad", refresh)

	def add_feedback(self, refresh=True, parent=None):

		"""
		Add a feedback item and ask for an item to fill the loop with

		Keyword arguments:
		refresh -- a bool to indicate if the interface should be refreshed
				   (default=True)
		parent -- the parent item for the new item (default=None)

		Returns:
		The name of the new item
		"""
		return self.add_item(u"feedback", refresh)

	def add_sampler(self, refresh=True, parent=None):

		"""
		Add a sampler item and ask for an item to fill the loop with

		Keyword arguments:
		refresh -- a bool to indicate if the interface should be refreshed
				   (default=True)
		parent -- the parent item for the new item (default=None)

		Returns:
		The name of the new item
		"""

		return self.add_item(u"sampler", refresh)

	def add_synth(self, refresh=True, parent=None):

		"""
		Add a synth item and ask for an item to fill the loop with

		Keyword arguments:
		refresh -- a bool to indicate if the interface should be refreshed
				   (default=True)
		parent -- the parent item for the new item
				  (default=None)

		Returns:
		The name of the new item
		"""

		return self.add_item(u"synth", refresh)

	def add_keyboard_response(self, refresh=True, parent=None):

		"""
		Add a keyboard_response item and ask for an item to fill the loop with

		Keyword arguments:
		refresh -- a bool to indicate if the interface should be refreshed
				   (default=True)
		parent -- the parent item for the new item (default=None)

		Returns:
		The name of the new item
		"""

		return self.add_item(u"keyboard_response", refresh)

	def add_mouse_response(self, refresh=True, parent=None):

		"""
		Add a mouse_response item and ask for an item to fill the loop with

		Keyword arguments:
		refresh -- a bool to indicate if the interface should be refreshed
				   (default=True)
		parent -- the parent item for the new item (default=None)

		Returns:
		The name of the new item
		"""

		return self.add_item(u"mouse_response", refresh)

	def add_logger(self, refresh=True, parent=None):

		"""
		Add a logger item and ask for an item to fill the loop with

		Keyword arguments:
		refresh -- a bool to indicate if the interface should be refreshed
				   (default=True)
		parent -- the parent item for the new item (default=None)

		Returns:
		The name of the new item
		"""

		return self.add_item(u"logger", refresh)

	def add_inline_script(self, refresh=True, parent=None):

		"""
		Add an inline_script item and ask for an item to fill the loop with

		Keyword arguments:
		refresh -- a bool to indicate if the interface should be refreshed
				   (default=True)
		parent -- the parent item for the new item (default=None)

		Returns:
		The name of the new item
		"""

		return self.add_item(u"inline_script", refresh)

	def drop_item(self, add_func):

		"""
		Create a new item after an item has been dragged and dropped from the
		toolbar. The necessary information is stored in the itemtree.

		Arguments:
		add_func -- a function to call to create the new item
		"""

		from libqtopensesame.widgets import draggables

		debug.msg(u'dropping from toolbar')

		# Determine the drop target
		if draggables.drop_target == None:
			return
		target, index, select = draggables.drop_target

		# Create a new item and return if it fails
		if not isinstance(add_func, basestring):
			new_item = add_func(False, parent=target)
		else:
			new_item = self.add_item(add_func, False)
		if new_item == None:
			self.refresh(target)
			return

		if target == u'__start__':
			self.experiment.set(u'start', new_item)
		else:
			self.experiment.items[target].items.insert(index, (new_item, \
				u'always'))

		self.refresh(target)
		if select:
			self.select_item(new_item)

	def drag_item(self, add_func):

		"""
		Drag an item from the item toolbar

		Arguments:
		add_func -- a function to create a new item, if the item is dropped
		"""

		from libqtopensesame.widgets import draggables

		debug.msg(u"dragging")

		# Reset the drop target
		draggables.drop_target = None

		# Start the drop action
		d = QtGui.QDrag(self.ui.centralwidget)
		m = QtCore.QMimeData()
		m.setText(u"__osnew__ %s" % add_func)
		d.setMimeData(m)

		# Check if the drop was successful
		if d.start(QtCore.Qt.CopyAction) == QtCore.Qt.CopyAction:
			self.drop_item(add_func)
		else:
			# Create a new item
			if type(add_func) != str:
				new_item = add_func(False)
			else:
				new_item = self.add_item(add_func, False)

			if new_item != None:
				debug.msg(u"adding to unused")
				self.refresh()
				self.select_item(new_item)

	def drag_loop(self):

		"""Drag a new loop"""

		self.drag_item(self.add_loop)

	def drag_sequence(self):

		"""Drag a new sequence"""

		self.drag_item(self.add_sequence)

	def drag_sketchpad(self):

		"""Drag a new sketchpad"""

		self.drag_item(self.add_sketchpad)

	def drag_feedback(self):

		"""Drag a new feedback"""

		self.drag_item(self.add_feedback)

	def drag_sampler(self):

		"""Drag a new sampler"""

		self.drag_item(self.add_sampler)

	def drag_synth(self):

		"""Drag a new synth"""

		self.drag_item(self.add_synth)

	def drag_keyboard_response(self):

		"""Drag a new keyboard_response"""

		self.drag_item(self.add_keyboard_response)

	def drag_mouse_response(self):

		"""Drag a new mouse_response"""

		self.drag_item(self.add_mouse_response)

	def drag_logger(self):

		"""Drag a new logger"""

		self.drag_item(self.add_logger)

	def drag_inline_script(self):

		"""Drag a new inline_script"""

		self.drag_item(self.add_inline_script)


########NEW FILE########
__FILENAME__ = qtopensesamerun
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt4 import QtCore, QtGui
from libqtopensesame.ui import opensesamerun_ui
from libqtopensesame.misc import theme

class qtopensesamerun(QtGui.QMainWindow):

	"""Implements the GUI for opensesamerun."""
	
	def __init__(self, options, parent=None):
		
		"""
		Constructor.
		
		Arguments:
		options		--	Command-line arguments passed to opensesamerun, as
						parsed by `libopensesame.misc.opensesamerun_options()`.
		
		Keyword arguments:
		parent		--	A parent QWidget. (default=None)
		"""
			
		# Construct the parent
		QtGui.QMainWindow.__init__(self, parent)
		# Setup the UI
		self.ui = opensesamerun_ui.Ui_opensesamerun_mainwindow()
		self.ui.setupUi(self)		
		self.ui.button_run.clicked.connect(self.run)
		self.theme = theme.theme(self)
		self.ui.button_browse_experiment.clicked.connect(self.browse_experiment)
		self.ui.button_browse_logfile.clicked.connect(self.browse_logfile)
		self.options = options
		# Fill the GUI controls based on the options
		self.ui.edit_experiment.setText(self.options.experiment)
		self.ui.checkbox_fullscreen.setChecked(self.options.fullscreen)
		self.ui.checkbox_pylink.setChecked(self.options.pylink)
		self.ui.spinbox_subject_nr.setValue(int(self.options.subject))
		self.ui.edit_logfile.setText(self.options.logfile)
		
	def browse_experiment(self):
	
		"""Locates the experiment file."""
		
		file_type_filter = \
			u"OpenSesame files (*.opensesame.tar.gz *.opensesame);;OpenSesame script and file pool (*.opensesame.tar.gz);;OpenSesame script (*.opensesame)"
		path = QtGui.QFileDialog.getOpenFileName(self, \
			u"Open experiment file", filter = file_type_filter)
		if path == u"":
			return
		self.ui.edit_experiment.setText(path)
		
	def browse_logfile(self):
	
		"""Locates the logfile.	"""
			
		path = QtGui.QFileDialog.getSaveFileName(self, \
			u"Choose a location for the logfile")
		if path == u"":
			return
		self.ui.edit_logfile.setText(path)
		
	def show(self):
	
		"""Sets the run flag to false."""
	
		self.run = False
		QtGui.QMainWindow.show(self)
			
	def run(self):
	
		"""
		Does not actual run the experiment, but marks the application for
		running later.
		"""
	
		self.run = True		
		self.options.experiment = unicode(self.ui.edit_experiment.text())
		self.options.subject = self.ui.spinbox_subject_nr.value()
		self.options.logfile = unicode(self.ui.edit_logfile.text())		
		self.options.fullscreen = self.ui.checkbox_fullscreen.isChecked()
		self.options.custom_resolution = \
			self.ui.checkbox_custom_resolution.isChecked()
		self.options.width = self.ui.spinbox_width.value()
		self.options.height = self.ui.spinbox_height.value()
		self.options.pylink = self.ui.checkbox_pylink.isChecked()
		self.close()

########NEW FILE########
__FILENAME__ = base_runner
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
from PyQt4 import QtGui
from libqtopensesame.misc import config, _
from libopensesame import debug
from libopensesame.exceptions import osexception
from libopensesame.experiment import experiment

class base_runner(object):
	
	"""
	A runner implements a specific way to execute an OpenSesame experiment from
	within the GUI. The base_runner is an abstract runner that is inherited by
	actual runners.
	"""
	
	valid_logfile_extensions = u'.csv', u'.txt', u'.dat', u'.log'
	default_logfile_extension = u'.csv'
	
	def __init__(self, main_window):
		
		"""
		Constructor.
		
		Arguments:
		main_window		--	An QtGui.QMainWindow object. Typically this will be
							the qtopensesame object.
		"""		
		
		self.main_window = main_window

	def execute(self):
		
		"""
		Executes the experiments. This function should be transparent and leave
		no mess to clean up for the GUI.
		
		Returns:
		None if the experiment finished cleanly, or an Exception (any kind) if
		an exception occurred.
		"""
		
		pass
	
	def get_logfile(self, quick=False, subject_nr=0):
		
		"""
		Gets the logfile for the current session, either by falling back to a 
		default value ('quickrun.csv') or through a pop-up dialogue.
		
		Keyword arguments:
		quick		--	Indicates whether we are quickrunning the experiment.
						(default=False)
		subject_nr	--	Indicates the subject number, which is used to
						suggest a logfile. (default=0)
					
		Returns:
		A pathname for the logfile or None if no logfile was chosen (i.e. the
		dialogue was cancelled).
		"""
		
		if quick:
			logfile = os.path.join(config.get_config( \
				u'default_logfile_folder'), config.get_config( \
				u'quick_run_logfile'))
		else:
			# Suggested filename
			suggested_path = os.path.join(config.get_config( \
				u'default_logfile_folder'), u'subject-%d.csv' % subject_nr)
			# Get the data file
			csv_filter = u'Comma-separated values (*.csv)'
			logfile = unicode(QtGui.QFileDialog.getSaveFileName( \
				self.main_window.ui.centralwidget, \
				_(u"Choose location for logfile (press 'escape' for default location)"), \
				suggested_path, filter=csv_filter))
			# An empty string indicates that the dialogue was cancelled, in
			# which case we fall back to a default location.
			if logfile == u'':
				logfile = os.path.join(config.get_config( \
						'default_logfile_folder'), u'defaultlog.csv')
			# If a logfile was provided, but it did not have a proper extension,
			# we add a `.csv` extension.
			else:
				if os.path.splitext(logfile)[1].lower() not in \
					self.valid_logfile_extensions:
					logfile += self.default_logfile_extension		
		# If the logfile is not writable, inform the user and cancel.
		try:
			open(logfile, u'w').close()
		except:
			self.main_window.experiment.notify( \
				_(u"The logfile '%s' is not writable. Please choose another location for the logfile.") \
				% logfile)
			return None
		# Remember the logfile folder for the next run
		# Remember the location of the logfile
		config.set_config('default_logfile_folder', os.path.dirname(logfile))
		return logfile
	
	def get_subject_nr(self, quick=False):
				
		"""
		Gets the subject number for the current session, either by falling back 
		to a default value of 999 (in quickmode) or through a pop-up dialogue.
		
		Keyword arguments:
		quick	--	Indicates whether we are quickrunning the experiment.
					(default=False)
					
		Returns:
		A subject number or None if no subject number was chosen (i.e. the
		dialogue was cancelled).
		"""
		
		if quick:
			return 999
		subject_nr, ok = QtGui.QInputDialog.getInt( \
			self.main_window.ui.centralwidget, _(u'Subject number'), \
			_(u'Please enter the subject number'), min=0)
		if not ok:
			return None
		return subject_nr
	
	def init_experiment(self, quick=False, fullscreen=False, auto_response= \
		False):
		
		"""
		Initializes a new experiment, which is a newly generated instance of the
		experiment currently active in the user interface.
		
		Keyword arguments:
		quick		--	Indicates whether we are quickrunning the experiment.
						(default=False)
		
		Returns:
		True if the experiment was successfully initiated, False it was not.
		"""
		
		# First tell the experiment to get ready, to apply any pending changes,
		# and then initialize the script. This can trigger errors.
		try:
			self.main_window.get_ready()
			script = self.main_window.experiment.to_string()
		except Exception as e:
			if not isinstance(e, osexception):
				e = osexception(u'Unexpected error', exception=e)
			self.main_window.print_debug_window(e)
			self.main_window.experiment.notify(e.html())
			return False
		# Get and set the subject number
		subject_nr = self.get_subject_nr(quick=quick)
		if subject_nr == None:
			return False
		# Get and set the logfile
		logfile = self.get_logfile(quick=quick, subject_nr=subject_nr)
		if logfile == None:
			return False		
		# Build a new experiment. This can trigger a script error.
		try:
			self.experiment = experiment(string=script, pool_folder= \
				self.main_window.experiment.pool_folder, experiment_path= \
				self.main_window.experiment.experiment_path, fullscreen= \
				fullscreen, auto_response=auto_response, subject_nr= \
				subject_nr, logfile=logfile)
		except Exception as e:
			if not isinstance(e, osexception):
				e = osexception(u'Unexpected error', exception=e)
			self.main_window.print_debug_window(e)
			self.main_window.experiment.notify(e.html())
		return True
	
	def on_exception(self, e):
		
		"""
		Is called when an exception has occurred during the experiment.
		
		Arguments:
		e		--	An exception, or an (exception, traceback) tuple.
		"""

		if not isinstance(e, osexception):
			e = osexception(msg=u'Unexpected error', exception=e)
		self.main_window.print_debug_window(e)
		self.main_window.experiment.notify(e.html(), title=u'Exception')
	
	def on_success(self, quick=False):
		
		"""
		Is called when an experiment has successfully ended, and gives the user
		the opportunity to copy the logfile to the file pool.
		
		Keyword arguments:
		quick		--	Indicates whether we are quickrunning the experiment.
						(default=False)
		"""
		
		if quick:
			return
		resp = QtGui.QMessageBox.question(self.main_window.ui.centralwidget, \
			_(u"Finished!"), \
			_(u"The experiment is finished and data has been logged to '%s'. Do you want to copy the logfile to the file pool?") \
			% self.experiment.logfile, QtGui.QMessageBox.Yes, \
			QtGui.QMessageBox.No)
		if resp == QtGui.QMessageBox.Yes:
			self.main_window.copy_to_pool(self.experiment.logfile)

	def run(self, quick=False, fullscreen=False, auto_response=False):
		
		"""
		Runs the experiment.
		
		Keyword arguments:
		quick			--	Indicates whether we are quickrunning the
							experiment. (default=False)
		fullscreen		--	Indicates whether the experiment should be run in
							fullscreen. (default=False)
		auto_response	--	Indicates whether auto-response mode should be
							enabled. (default=False)
		"""		
		
		if not self.init_experiment(quick=quick, fullscreen=fullscreen, \
			auto_response=auto_response):
			return
		ret_val = self.execute()
		if ret_val != None:
			self.on_exception(ret_val)
		elif not quick:
			self.on_success(quick=quick)

########NEW FILE########
__FILENAME__ = external_runner
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import sys
import os
from libopensesame.exceptions import osexception
from libopensesame import debug
from libqtopensesame.misc import config
from libqtopensesame.runners import base_runner

from PyQt4 import QtGui
import time

class external_runner(base_runner):

	"""Runs an experiment using opensesamerun."""

	def execute(self):

		"""See base_runner.execute()."""

		import subprocess
		import tempfile

		try:
			# Temporary file for the standard output and experiment
			self.stdout = tempfile.mktemp(suffix=u".stdout")

			if self.experiment.experiment_path is None:
				raise osexception( \
					u"Please save your experiment first, before running it using opensesamerun")

			self.path = os.path.join(self.experiment.experiment_path, \
				'.opensesamerun-tmp.opensesame.tar.gz')
			self.experiment.save(self.path, True)
			debug.msg(u"experiment saved as '%s'" % self.path)

			# Determine the name of the executable
			if config.get_config(u'opensesamerun_exec') == u'':
				if os.name == u"nt":
					self.cmd = [u"opensesamerun.exe"]
				else:
					self.cmd = [u"opensesamerun"]
			else:
				self.cmd = config.get_config(u'opensesamerun_exec').split()

			self.cmd += [self.path, u"--logfile=%s" % self.experiment.logfile, \
				u"--subject=%s" % self.experiment.subject_nr]

			if debug.enabled:
				self.cmd.append(u"--debug")
			if self.experiment.fullscreen:
				self.cmd.append(u"--fullscreen")
			if u"--pylink" in sys.argv:
				self.cmd.append(u"--pylink")


			debug.msg(u"spawning opensesamerun as a separate process")

			# Call opensesamerun and wait for the process to complete

			try:
				p = subprocess.Popen(self.cmd, stdout = open(self.stdout, u"w"))
			except Exception as e:
				try:
					os.remove(self.path)
					os.remove(self.stdout)
				except:
					pass
				return e

			# Wait for OpenSesame run to complete, process events in the meantime,
			# to make sure that the new process is shown (otherwise it will crash
			# on Windows).
			retcode = None
			while retcode == None:
				retcode = p.poll()
				QtGui.QApplication.processEvents()
				time.sleep(1)

			debug.msg(u"opensesamerun returned %d" % retcode)

			print
			print(open(self.stdout, u"r").read())
			print

			# Clean up the temporary file
			try:
				os.remove(self.path)
				os.remove(self.stdout)
			except:
				pass

			return None
		except Exception as e:
			return e


########NEW FILE########
__FILENAME__ = inprocess_runner
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import debug
from libopensesame.exceptions import osexception
from libqtopensesame.runners import base_runner

class inprocess_runner(base_runner):
	
	"""Runs an experiment in the traditional way, in the same process."""

	def execute(self):
		
		"""See base_runner.execute()."""
		
		# Exceptions during the run phase are important and returned so that the
		# user is notified.
		e = None
		try:
			self.experiment.run()
		except Exception as e:
			if not isinstance(e, osexception):
				e = osexception(u'Unexpected error', e)
		# Exceptions during the end phase are less important and only printed
		# to the debug window.
		try:
			self.experiment.end()
		except Exception as _e:
			debug.msg(u'Exception during experiment.end(): %s' % _e)
		return e

########NEW FILE########
__FILENAME__ = multiprocess_runner
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
import sys
from libqtopensesame.runners import base_runner
from PyQt4 import QtGui
from libopensesame.exceptions import osexception

class multiprocess_runner(base_runner):
	
	"""Runs an experiment in another process using multiprocessing."""
	
	def execute(self):
		
		"""See base_runner.execute()."""
		
		import platform
		# In OS X the multiprocessing module is horribly broken, but a fixed
		# version has been released as the 'billiard' module
		if platform.system() == 'Darwin':
			import billiard as multiprocessing
			multiprocessing.forking_enable(0)
		else:
			import multiprocessing
	
		from libqtopensesame.misc import process, _
		from libopensesame import misc, debug
		from StringIO import StringIO
		if os.name == u'nt':
			# Under Windows, the multiprocess runner assumes that there is a
			# file called `opensesame.py` or `opensesame.pyc`. If this file does
			# not exist, try to copy it from the main script (`opensesame`). If
			# this fails, provide an informative error message.
			os_folder = misc.opensesame_folder()
			if not os.path.exists(os.path.join(os_folder, u'opensesame.pyc')) \
				and not os.path.exists(os.path.join(os_folder, u'opensesame.py')):
				import shutil
				try:
					shutil.copyfile(os.path.join(os_folder, u'opensesame'), \
						os.path.join(os_folder, u'opensesame.py'))
				except Exception as e:			
					return osexception( \
						_(u'Failed to copy `opensesame` to `opensesame.py`, which is required for the multiprocess runner. Please copy the file manually, or select a different runner under Preferences.'), exception=e)
		self.channel = multiprocessing.Queue()
		self.exp_process = process.ExperimentProcess(self.experiment, \
			self.channel)
		# Start process!
		self.exp_process.start()
		# Variables used for ugly hack to suppress 'None' print by Queue.get()
		_stdout = sys.stdout	
		_pit = StringIO()
		# Wait for experiment to finish.
		# Listen for incoming messages in the meantime.
		while self.exp_process.is_alive() or not self.channel.empty():
			QtGui.QApplication.processEvents()
			# Make sure None is not printed. Ugly hack for a bug in the Queue
			# class?
			sys.stdout = _pit
			# Wait for messages. Will throw Exception if no message is received
			# before timeout.
			try:
				msg = self.channel.get(True, 0.05)
			except:
				msg = None
			# Restore connection to stdout
			sys.stdout = _stdout
			# For standard print statements
			if isinstance(msg, basestring):
				sys.stdout.write(msg)
			# Errors arrive as a tuple with (Error object, traceback)
			elif isinstance(msg, Exception):
				return msg
			# Anything that is not a string, not an Exception, and not None is
			# unexpected
			elif msg != None:
				return osexception( \
					u"Illegal message type received from child process: %s (%s)" \
					% (msg, type(msg)))
		# Return None if experiment finished without problems
		return None

########NEW FILE########
__FILENAME__ = backend_settings_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/backend_settings.ui'
#
# Created: Sat Jul 14 17:34:56 2012
#      by: PyQt4 UI code generator 4.9.1
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_widget_backend_settings(object):
    def setupUi(self, widget_backend_settings):
        widget_backend_settings.setObjectName(_fromUtf8("widget_backend_settings"))
        widget_backend_settings.resize(828, 852)
        self.verticalLayout = QtGui.QVBoxLayout(widget_backend_settings)
        self.verticalLayout.setMargin(4)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.scrollarea_backend_settings = QtGui.QScrollArea(widget_backend_settings)
        self.scrollarea_backend_settings.setWidgetResizable(True)
        self.scrollarea_backend_settings.setObjectName(_fromUtf8("scrollarea_backend_settings"))
        self.scrollAreaWidgetContents = QtGui.QWidget()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 818, 842))
        self.scrollAreaWidgetContents.setObjectName(_fromUtf8("scrollAreaWidgetContents"))
        self.verticalLayout_7 = QtGui.QVBoxLayout(self.scrollAreaWidgetContents)
        self.verticalLayout_7.setObjectName(_fromUtf8("verticalLayout_7"))
        self.widget_2 = QtGui.QWidget(self.scrollAreaWidgetContents)
        self.widget_2.setObjectName(_fromUtf8("widget_2"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget_2)
        self.horizontalLayout.setSpacing(16)
        self.horizontalLayout.setMargin(4)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.label_backend_icon = QtGui.QLabel(self.widget_2)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_backend_icon.sizePolicy().hasHeightForWidth())
        self.label_backend_icon.setSizePolicy(sizePolicy)
        self.label_backend_icon.setObjectName(_fromUtf8("label_backend_icon"))
        self.horizontalLayout.addWidget(self.label_backend_icon)
        self.label_2 = QtGui.QLabel(self.widget_2)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.horizontalLayout.addWidget(self.label_2)
        self.verticalLayout_7.addWidget(self.widget_2)
        self.group_canvas = QtGui.QGroupBox(self.scrollAreaWidgetContents)
        self.group_canvas.setObjectName(_fromUtf8("group_canvas"))
        self.layout_canvas = QtGui.QVBoxLayout(self.group_canvas)
        self.layout_canvas.setContentsMargins(0, -1, 0, 0)
        self.layout_canvas.setObjectName(_fromUtf8("layout_canvas"))
        self.label_canvas = QtGui.QLabel(self.group_canvas)
        self.label_canvas.setObjectName(_fromUtf8("label_canvas"))
        self.layout_canvas.addWidget(self.label_canvas)
        self.verticalLayout_7.addWidget(self.group_canvas)
        self.group_keyboard = QtGui.QGroupBox(self.scrollAreaWidgetContents)
        self.group_keyboard.setObjectName(_fromUtf8("group_keyboard"))
        self.layout_keyboard = QtGui.QVBoxLayout(self.group_keyboard)
        self.layout_keyboard.setContentsMargins(0, -1, 0, 0)
        self.layout_keyboard.setObjectName(_fromUtf8("layout_keyboard"))
        self.label_keyboard = QtGui.QLabel(self.group_keyboard)
        self.label_keyboard.setObjectName(_fromUtf8("label_keyboard"))
        self.layout_keyboard.addWidget(self.label_keyboard)
        self.verticalLayout_7.addWidget(self.group_keyboard)
        self.group_mouse = QtGui.QGroupBox(self.scrollAreaWidgetContents)
        self.group_mouse.setObjectName(_fromUtf8("group_mouse"))
        self.layout_mouse = QtGui.QVBoxLayout(self.group_mouse)
        self.layout_mouse.setContentsMargins(0, -1, 0, 0)
        self.layout_mouse.setObjectName(_fromUtf8("layout_mouse"))
        self.label_mouse = QtGui.QLabel(self.group_mouse)
        self.label_mouse.setObjectName(_fromUtf8("label_mouse"))
        self.layout_mouse.addWidget(self.label_mouse)
        self.verticalLayout_7.addWidget(self.group_mouse)
        self.group_sampler = QtGui.QGroupBox(self.scrollAreaWidgetContents)
        self.group_sampler.setObjectName(_fromUtf8("group_sampler"))
        self.layout_sampler = QtGui.QVBoxLayout(self.group_sampler)
        self.layout_sampler.setContentsMargins(0, -1, 0, 0)
        self.layout_sampler.setObjectName(_fromUtf8("layout_sampler"))
        self.label_sampler = QtGui.QLabel(self.group_sampler)
        self.label_sampler.setObjectName(_fromUtf8("label_sampler"))
        self.layout_sampler.addWidget(self.label_sampler)
        self.verticalLayout_7.addWidget(self.group_sampler)
        self.group_synth = QtGui.QGroupBox(self.scrollAreaWidgetContents)
        self.group_synth.setObjectName(_fromUtf8("group_synth"))
        self.layout_synth = QtGui.QVBoxLayout(self.group_synth)
        self.layout_synth.setContentsMargins(0, -1, 0, 0)
        self.layout_synth.setObjectName(_fromUtf8("layout_synth"))
        self.label_synth = QtGui.QLabel(self.group_synth)
        self.label_synth.setObjectName(_fromUtf8("label_synth"))
        self.layout_synth.addWidget(self.label_synth)
        self.verticalLayout_7.addWidget(self.group_synth)
        self.widget = QtGui.QWidget(self.scrollAreaWidgetContents)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget.sizePolicy().hasHeightForWidth())
        self.widget.setSizePolicy(sizePolicy)
        self.widget.setObjectName(_fromUtf8("widget"))
        self.verticalLayout_7.addWidget(self.widget)
        self.scrollarea_backend_settings.setWidget(self.scrollAreaWidgetContents)
        self.verticalLayout.addWidget(self.scrollarea_backend_settings)

        self.retranslateUi(widget_backend_settings)
        QtCore.QMetaObject.connectSlotsByName(widget_backend_settings)

    def retranslateUi(self, widget_backend_settings):
        widget_backend_settings.setWindowTitle(QtGui.QApplication.translate("widget_backend_settings", "Form", None, QtGui.QApplication.UnicodeUTF8))
        self.label_backend_icon.setText(QtGui.QApplication.translate("widget_backend_settings", "ICON", None, QtGui.QApplication.UnicodeUTF8))
        self.label_2.setText(QtGui.QApplication.translate("widget_backend_settings", "<b>Back-end settings</b><br />\n"
"Various settings related to the control of the display, sound, and input devices", None, QtGui.QApplication.UnicodeUTF8))
        self.group_canvas.setTitle(QtGui.QApplication.translate("widget_backend_settings", "Canvas", None, QtGui.QApplication.UnicodeUTF8))
        self.label_canvas.setText(QtGui.QApplication.translate("widget_backend_settings", "TextLabel", None, QtGui.QApplication.UnicodeUTF8))
        self.group_keyboard.setTitle(QtGui.QApplication.translate("widget_backend_settings", "Keyboard", None, QtGui.QApplication.UnicodeUTF8))
        self.label_keyboard.setText(QtGui.QApplication.translate("widget_backend_settings", "TextLabel", None, QtGui.QApplication.UnicodeUTF8))
        self.group_mouse.setTitle(QtGui.QApplication.translate("widget_backend_settings", "Mouse", None, QtGui.QApplication.UnicodeUTF8))
        self.label_mouse.setText(QtGui.QApplication.translate("widget_backend_settings", "TextLabel", None, QtGui.QApplication.UnicodeUTF8))
        self.group_sampler.setTitle(QtGui.QApplication.translate("widget_backend_settings", "Sampler", None, QtGui.QApplication.UnicodeUTF8))
        self.label_sampler.setText(QtGui.QApplication.translate("widget_backend_settings", "TextLabel", None, QtGui.QApplication.UnicodeUTF8))
        self.group_synth.setTitle(QtGui.QApplication.translate("widget_backend_settings", "Synth", None, QtGui.QApplication.UnicodeUTF8))
        self.label_synth.setText(QtGui.QApplication.translate("widget_backend_settings", "TextLabel", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = credits_widget_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/credits_widget.ui'
#
# Created: Fri Jan  3 14:35:01 2014
#      by: PyQt4 UI code generator 4.10.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_widget_credits(object):
    def setupUi(self, widget_credits):
        widget_credits.setObjectName(_fromUtf8("widget_credits"))
        widget_credits.resize(868, 55)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.MinimumExpanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(widget_credits.sizePolicy().hasHeightForWidth())
        widget_credits.setSizePolicy(sizePolicy)
        self.verticalLayout = QtGui.QVBoxLayout(widget_credits)
        self.verticalLayout.setMargin(0)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        spacerItem = QtGui.QSpacerItem(20, 2, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)
        self.verticalLayout.addItem(spacerItem)
        self.widget_container = QtGui.QWidget(widget_credits)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_container.sizePolicy().hasHeightForWidth())
        self.widget_container.setSizePolicy(sizePolicy)
        self.widget_container.setObjectName(_fromUtf8("widget_container"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget_container)
        self.horizontalLayout.setSpacing(0)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.widget_credits_2 = QtGui.QWidget(self.widget_container)
        self.widget_credits_2.setObjectName(_fromUtf8("widget_credits_2"))
        self.verticalLayout_3 = QtGui.QVBoxLayout(self.widget_credits_2)
        self.verticalLayout_3.setSpacing(0)
        self.verticalLayout_3.setMargin(0)
        self.verticalLayout_3.setObjectName(_fromUtf8("verticalLayout_3"))
        self.widget_social = QtGui.QWidget(self.widget_credits_2)
        self.widget_social.setObjectName(_fromUtf8("widget_social"))
        self.horizontalLayout_2 = QtGui.QHBoxLayout(self.widget_social)
        self.horizontalLayout_2.setSpacing(4)
        self.horizontalLayout_2.setMargin(0)
        self.horizontalLayout_2.setObjectName(_fromUtf8("horizontalLayout_2"))
        self.label_facebook = QtGui.QLabel(self.widget_social)
        self.label_facebook.setObjectName(_fromUtf8("label_facebook"))
        self.horizontalLayout_2.addWidget(self.label_facebook)
        self.label_twitter = QtGui.QLabel(self.widget_social)
        self.label_twitter.setObjectName(_fromUtf8("label_twitter"))
        self.horizontalLayout_2.addWidget(self.label_twitter)
        self.label_website = QtGui.QLabel(self.widget_social)
        self.label_website.setObjectName(_fromUtf8("label_website"))
        self.horizontalLayout_2.addWidget(self.label_website)
        self.label_cogscinl = QtGui.QLabel(self.widget_social)
        self.label_cogscinl.setObjectName(_fromUtf8("label_cogscinl"))
        self.horizontalLayout_2.addWidget(self.label_cogscinl)
        self.label_contribute = QtGui.QLabel(self.widget_social)
        self.label_contribute.setOpenExternalLinks(True)
        self.label_contribute.setObjectName(_fromUtf8("label_contribute"))
        self.horizontalLayout_2.addWidget(self.label_contribute)
        self.label_donate = QtGui.QLabel(self.widget_social)
        self.label_donate.setOpenExternalLinks(True)
        self.label_donate.setObjectName(_fromUtf8("label_donate"))
        self.horizontalLayout_2.addWidget(self.label_donate)
        spacerItem1 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem1)
        self.verticalLayout_3.addWidget(self.widget_social)
        self.horizontalLayout.addWidget(self.widget_credits_2)
        spacerItem2 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem2)
        self.label_opensesame = QtGui.QLabel(self.widget_container)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_opensesame.sizePolicy().hasHeightForWidth())
        self.label_opensesame.setSizePolicy(sizePolicy)
        self.label_opensesame.setAlignment(QtCore.Qt.AlignBottom|QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing)
        self.label_opensesame.setObjectName(_fromUtf8("label_opensesame"))
        self.horizontalLayout.addWidget(self.label_opensesame)
        self.verticalLayout.addWidget(self.widget_container)

        self.retranslateUi(widget_credits)
        QtCore.QMetaObject.connectSlotsByName(widget_credits)

    def retranslateUi(self, widget_credits):
        widget_credits.setWindowTitle(_translate("widget_credits", "Form", None))
        self.label_facebook.setToolTip(_translate("widget_credits", "Visit Facebook page", None))
        self.label_facebook.setText(_translate("widget_credits", "F", None))
        self.label_twitter.setToolTip(_translate("widget_credits", "Visit Twitter page", None))
        self.label_twitter.setText(_translate("widget_credits", "T", None))
        self.label_website.setToolTip(_translate("widget_credits", "Visit cogsci.nl", None))
        self.label_website.setText(_translate("widget_credits", "H", None))
        self.label_cogscinl.setText(_translate("widget_credits", "<html><head/><body><p>COGSCIdotNL // cognitive science and more</p></body></html>", None))
        self.label_contribute.setText(_translate("widget_credits", "<a href=\"http://osdoc.cogsci.nl/contribute/\">Contribute</a>", None))
        self.label_donate.setText(_translate("widget_credits", "<a href=\"http://osdoc.cogsci.nl/donate/\">Donate</a>", None))
        self.label_opensesame.setText(_translate("widget_credits", "OpenSesame [version] [codename]\n"
"Copyright Sebastiaan Matht (2010-2014)", None))


########NEW FILE########
__FILENAME__ = font_widget_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/font_widget.ui'
#
# Created: Mon Feb 24 16:14:52 2014
#      by: PyQt4 UI code generator 4.10.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_font_widget(object):
    def setupUi(self, font_widget):
        font_widget.setObjectName(_fromUtf8("font_widget"))
        font_widget.resize(267, 171)
        self.gridLayout = QtGui.QGridLayout(font_widget)
        self.gridLayout.setMargin(0)
        self.gridLayout.setSpacing(4)
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        self.label = QtGui.QLabel(font_widget)
        self.label.setObjectName(_fromUtf8("label"))
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
        self.combobox_family = QtGui.QComboBox(font_widget)
        self.combobox_family.setObjectName(_fromUtf8("combobox_family"))
        self.combobox_family.addItem(_fromUtf8(""))
        self.combobox_family.setItemText(0, _fromUtf8("mono"))
        self.combobox_family.addItem(_fromUtf8(""))
        self.combobox_family.setItemText(1, _fromUtf8("sans"))
        self.combobox_family.addItem(_fromUtf8(""))
        self.combobox_family.setItemText(2, _fromUtf8("serif"))
        self.combobox_family.addItem(_fromUtf8(""))
        self.combobox_family.setItemText(3, _fromUtf8("arabic"))
        self.combobox_family.addItem(_fromUtf8(""))
        self.combobox_family.setItemText(4, _fromUtf8("chinese-japanese-korean"))
        self.combobox_family.addItem(_fromUtf8(""))
        self.combobox_family.setItemText(5, _fromUtf8("hebrew"))
        self.combobox_family.addItem(_fromUtf8(""))
        self.combobox_family.setItemText(6, _fromUtf8("hindi"))
        self.combobox_family.addItem(_fromUtf8(""))
        self.gridLayout.addWidget(self.combobox_family, 0, 1, 1, 1)
        self.label_2 = QtGui.QLabel(font_widget)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.gridLayout.addWidget(self.label_2, 1, 0, 1, 1)
        self.spinbox_size = QtGui.QSpinBox(font_widget)
        self.spinbox_size.setMinimum(1)
        self.spinbox_size.setMaximum(1024)
        self.spinbox_size.setObjectName(_fromUtf8("spinbox_size"))
        self.gridLayout.addWidget(self.spinbox_size, 1, 1, 1, 1)
        self.checkbox_italic = QtGui.QCheckBox(font_widget)
        font = QtGui.QFont()
        font.setItalic(True)
        self.checkbox_italic.setFont(font)
        self.checkbox_italic.setObjectName(_fromUtf8("checkbox_italic"))
        self.gridLayout.addWidget(self.checkbox_italic, 2, 0, 1, 1)
        self.checkbox_bold = QtGui.QCheckBox(font_widget)
        font = QtGui.QFont()
        font.setBold(True)
        font.setWeight(75)
        self.checkbox_bold.setFont(font)
        self.checkbox_bold.setObjectName(_fromUtf8("checkbox_bold"))
        self.gridLayout.addWidget(self.checkbox_bold, 3, 0, 1, 1)
        self.frame = QtGui.QFrame(font_widget)
        self.frame.setFrameShape(QtGui.QFrame.StyledPanel)
        self.frame.setFrameShadow(QtGui.QFrame.Raised)
        self.frame.setObjectName(_fromUtf8("frame"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.frame)
        self.horizontalLayout.setMargin(4)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.label_example = QtGui.QLabel(self.frame)
        self.label_example.setAlignment(QtCore.Qt.AlignCenter)
        self.label_example.setObjectName(_fromUtf8("label_example"))
        self.horizontalLayout.addWidget(self.label_example)
        self.gridLayout.addWidget(self.frame, 2, 1, 2, 1)

        self.retranslateUi(font_widget)
        QtCore.QMetaObject.connectSlotsByName(font_widget)

    def retranslateUi(self, font_widget):
        font_widget.setWindowTitle(_translate("font_widget", "Form", None))
        self.label.setText(_translate("font_widget", "Font family", None))
        self.combobox_family.setItemText(7, _translate("font_widget", "other ...", None))
        self.label_2.setText(_translate("font_widget", "Font size", None))
        self.spinbox_size.setSuffix(_translate("font_widget", " pt", None))
        self.checkbox_italic.setText(_translate("font_widget", "Italic", None))
        self.checkbox_bold.setText(_translate("font_widget", "Bold", None))
        self.label_example.setText(_translate("font_widget", "Example", None))


########NEW FILE########
__FILENAME__ = gabor_dialog_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/gabor_dialog.ui'
#
# Created: Tue Apr  9 17:37:52 2013
#      by: PyQt4 UI code generator 4.9.1
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_gabor_dialog(object):
    def setupUi(self, gabor_dialog):
        gabor_dialog.setObjectName(_fromUtf8("gabor_dialog"))
        gabor_dialog.resize(476, 510)
        self.verticalLayout = QtGui.QVBoxLayout(gabor_dialog)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.widget_header_box = QtGui.QWidget(gabor_dialog)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_header_box.sizePolicy().hasHeightForWidth())
        self.widget_header_box.setSizePolicy(sizePolicy)
        self.widget_header_box.setObjectName(_fromUtf8("widget_header_box"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget_header_box)
        self.horizontalLayout.setSpacing(0)
        self.horizontalLayout.setMargin(5)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.label_gabor = QtGui.QLabel(self.widget_header_box)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_gabor.sizePolicy().hasHeightForWidth())
        self.label_gabor.setSizePolicy(sizePolicy)
        self.label_gabor.setText(_fromUtf8(""))
        self.label_gabor.setPixmap(QtGui.QPixmap(_fromUtf8(":/icons/gabor.png")))
        self.label_gabor.setObjectName(_fromUtf8("label_gabor"))
        self.horizontalLayout.addWidget(self.label_gabor)
        self.label_2 = QtGui.QLabel(self.widget_header_box)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_2.setFont(font)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.horizontalLayout.addWidget(self.label_2)
        self.verticalLayout.addWidget(self.widget_header_box)
        self.widget = QtGui.QWidget(gabor_dialog)
        font = QtGui.QFont()
        font.setPointSize(8)
        self.widget.setFont(font)
        self.widget.setObjectName(_fromUtf8("widget"))
        self.formLayout = QtGui.QFormLayout(self.widget)
        self.formLayout.setFieldGrowthPolicy(QtGui.QFormLayout.AllNonFixedFieldsGrow)
        self.formLayout.setMargin(0)
        self.formLayout.setVerticalSpacing(12)
        self.formLayout.setObjectName(_fromUtf8("formLayout"))
        self.label_3 = QtGui.QLabel(self.widget)
        self.label_3.setObjectName(_fromUtf8("label_3"))
        self.formLayout.setWidget(0, QtGui.QFormLayout.LabelRole, self.label_3)
        self.spin_orient = QtGui.QDoubleSpinBox(self.widget)
        self.spin_orient.setMaximum(360.0)
        self.spin_orient.setObjectName(_fromUtf8("spin_orient"))
        self.formLayout.setWidget(0, QtGui.QFormLayout.FieldRole, self.spin_orient)
        self.label_4 = QtGui.QLabel(self.widget)
        self.label_4.setObjectName(_fromUtf8("label_4"))
        self.formLayout.setWidget(1, QtGui.QFormLayout.LabelRole, self.label_4)
        self.spin_size = QtGui.QSpinBox(self.widget)
        self.spin_size.setMinimum(1)
        self.spin_size.setMaximum(1000)
        self.spin_size.setProperty("value", 96)
        self.spin_size.setObjectName(_fromUtf8("spin_size"))
        self.formLayout.setWidget(1, QtGui.QFormLayout.FieldRole, self.spin_size)
        self.label_5 = QtGui.QLabel(self.widget)
        self.label_5.setObjectName(_fromUtf8("label_5"))
        self.formLayout.setWidget(2, QtGui.QFormLayout.LabelRole, self.label_5)
        self.combobox_env = QtGui.QComboBox(self.widget)
        self.combobox_env.setObjectName(_fromUtf8("combobox_env"))
        self.combobox_env.addItem(_fromUtf8(""))
        self.combobox_env.addItem(_fromUtf8(""))
        self.combobox_env.addItem(_fromUtf8(""))
        self.combobox_env.addItem(_fromUtf8(""))
        self.formLayout.setWidget(2, QtGui.QFormLayout.FieldRole, self.combobox_env)
        self.label_6 = QtGui.QLabel(self.widget)
        self.label_6.setObjectName(_fromUtf8("label_6"))
        self.formLayout.setWidget(3, QtGui.QFormLayout.LabelRole, self.label_6)
        self.spin_stdev = QtGui.QDoubleSpinBox(self.widget)
        self.spin_stdev.setMaximum(1000.0)
        self.spin_stdev.setProperty("value", 12.0)
        self.spin_stdev.setObjectName(_fromUtf8("spin_stdev"))
        self.formLayout.setWidget(3, QtGui.QFormLayout.FieldRole, self.spin_stdev)
        self.label_7 = QtGui.QLabel(self.widget)
        self.label_7.setObjectName(_fromUtf8("label_7"))
        self.formLayout.setWidget(4, QtGui.QFormLayout.LabelRole, self.label_7)
        self.spin_freq = QtGui.QDoubleSpinBox(self.widget)
        self.spin_freq.setSuffix(_fromUtf8(""))
        self.spin_freq.setMaximum(1000.0)
        self.spin_freq.setProperty("value", 0.1)
        self.spin_freq.setObjectName(_fromUtf8("spin_freq"))
        self.formLayout.setWidget(4, QtGui.QFormLayout.FieldRole, self.spin_freq)
        self.label_8 = QtGui.QLabel(self.widget)
        self.label_8.setObjectName(_fromUtf8("label_8"))
        self.formLayout.setWidget(5, QtGui.QFormLayout.LabelRole, self.label_8)
        self.spin_phase = QtGui.QDoubleSpinBox(self.widget)
        self.spin_phase.setMaximum(1.0)
        self.spin_phase.setSingleStep(0.1)
        self.spin_phase.setObjectName(_fromUtf8("spin_phase"))
        self.formLayout.setWidget(5, QtGui.QFormLayout.FieldRole, self.spin_phase)
        self.label_10 = QtGui.QLabel(self.widget)
        self.label_10.setObjectName(_fromUtf8("label_10"))
        self.formLayout.setWidget(6, QtGui.QFormLayout.LabelRole, self.label_10)
        self.edit_color1 = QtGui.QLineEdit(self.widget)
        self.edit_color1.setText(_fromUtf8("white"))
        self.edit_color1.setObjectName(_fromUtf8("edit_color1"))
        self.formLayout.setWidget(6, QtGui.QFormLayout.FieldRole, self.edit_color1)
        self.label_9 = QtGui.QLabel(self.widget)
        self.label_9.setObjectName(_fromUtf8("label_9"))
        self.formLayout.setWidget(7, QtGui.QFormLayout.LabelRole, self.label_9)
        self.edit_color2 = QtGui.QLineEdit(self.widget)
        self.edit_color2.setText(_fromUtf8("black"))
        self.edit_color2.setObjectName(_fromUtf8("edit_color2"))
        self.formLayout.setWidget(7, QtGui.QFormLayout.FieldRole, self.edit_color2)
        self.label_11 = QtGui.QLabel(self.widget)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_11.setFont(font)
        self.label_11.setObjectName(_fromUtf8("label_11"))
        self.formLayout.setWidget(8, QtGui.QFormLayout.LabelRole, self.label_11)
        self.combobox_bgmode = QtGui.QComboBox(self.widget)
        self.combobox_bgmode.setObjectName(_fromUtf8("combobox_bgmode"))
        self.combobox_bgmode.addItem(_fromUtf8(""))
        self.combobox_bgmode.addItem(_fromUtf8(""))
        self.formLayout.setWidget(8, QtGui.QFormLayout.FieldRole, self.combobox_bgmode)
        self.verticalLayout.addWidget(self.widget)
        self.widget_3 = QtGui.QWidget(gabor_dialog)
        self.widget_3.setObjectName(_fromUtf8("widget_3"))
        self.verticalLayout_2 = QtGui.QVBoxLayout(self.widget_3)
        self.verticalLayout_2.setMargin(0)
        self.verticalLayout_2.setObjectName(_fromUtf8("verticalLayout_2"))
        self.label_12 = QtGui.QLabel(self.widget_3)
        font = QtGui.QFont()
        font.setPointSize(9)
        font.setItalic(True)
        self.label_12.setFont(font)
        self.label_12.setWordWrap(True)
        self.label_12.setObjectName(_fromUtf8("label_12"))
        self.verticalLayout_2.addWidget(self.label_12)
        self.verticalLayout.addWidget(self.widget_3)
        self.buttonBox = QtGui.QDialogButtonBox(gabor_dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.buttonBox.setCenterButtons(False)
        self.buttonBox.setObjectName(_fromUtf8("buttonBox"))
        self.verticalLayout.addWidget(self.buttonBox)

        self.retranslateUi(gabor_dialog)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("accepted()")), gabor_dialog.accept)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), gabor_dialog.reject)
        QtCore.QMetaObject.connectSlotsByName(gabor_dialog)

    def retranslateUi(self, gabor_dialog):
        gabor_dialog.setWindowTitle(QtGui.QApplication.translate("gabor_dialog", "Insert Gabor patch", None, QtGui.QApplication.UnicodeUTF8))
        self.label_2.setText(QtGui.QApplication.translate("gabor_dialog", "Insert Gabor patch", None, QtGui.QApplication.UnicodeUTF8))
        self.label_3.setText(QtGui.QApplication.translate("gabor_dialog", "Orientation<br /><i>in degrees (0 .. 360)</i>", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_orient.setSuffix(QtGui.QApplication.translate("gabor_dialog", "deg", None, QtGui.QApplication.UnicodeUTF8))
        self.label_4.setText(QtGui.QApplication.translate("gabor_dialog", "Size<br /><i>in pixels</i>", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_size.setSuffix(QtGui.QApplication.translate("gabor_dialog", "px", None, QtGui.QApplication.UnicodeUTF8))
        self.label_5.setText(QtGui.QApplication.translate("gabor_dialog", "Envelope", None, QtGui.QApplication.UnicodeUTF8))
        self.combobox_env.setItemText(0, QtGui.QApplication.translate("gabor_dialog", "gaussian", None, QtGui.QApplication.UnicodeUTF8))
        self.combobox_env.setItemText(1, QtGui.QApplication.translate("gabor_dialog", "linear", None, QtGui.QApplication.UnicodeUTF8))
        self.combobox_env.setItemText(2, QtGui.QApplication.translate("gabor_dialog", "circular (sharp edge)", None, QtGui.QApplication.UnicodeUTF8))
        self.combobox_env.setItemText(3, QtGui.QApplication.translate("gabor_dialog", "rectangle (no envelope)", None, QtGui.QApplication.UnicodeUTF8))
        self.label_6.setText(QtGui.QApplication.translate("gabor_dialog", "Standard deviation<br /><i>in pixels, only applies to Gaussian envelope</i>", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_stdev.setSuffix(QtGui.QApplication.translate("gabor_dialog", "px", None, QtGui.QApplication.UnicodeUTF8))
        self.label_7.setText(QtGui.QApplication.translate("gabor_dialog", "Frequency<br /><i>in cycles/ px</i>", None, QtGui.QApplication.UnicodeUTF8))
        self.label_8.setText(QtGui.QApplication.translate("gabor_dialog", "Phase<br /><i>in cycles (0 .. 1)</i>", None, QtGui.QApplication.UnicodeUTF8))
        self.label_10.setText(QtGui.QApplication.translate("gabor_dialog", "Color 1<br /><i>e.g., \'white\' or \'#FFFFFF\'</i>", None, QtGui.QApplication.UnicodeUTF8))
        self.label_9.setText(QtGui.QApplication.translate("gabor_dialog", "Color 1<br /><i>e.g., \'black\' or \'#000000\'</i>", None, QtGui.QApplication.UnicodeUTF8))
        self.label_11.setText(QtGui.QApplication.translate("gabor_dialog", "Background color *", None, QtGui.QApplication.UnicodeUTF8))
        self.combobox_bgmode.setItemText(0, QtGui.QApplication.translate("gabor_dialog", "Color average", None, QtGui.QApplication.UnicodeUTF8))
        self.combobox_bgmode.setItemText(1, QtGui.QApplication.translate("gabor_dialog", "Color 2", None, QtGui.QApplication.UnicodeUTF8))
        self.label_12.setText(QtGui.QApplication.translate("gabor_dialog", "* Has no effect in psycho back-end", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = general_script_editor_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/general_script_editor.ui'
#
# Created: Sat Jul 14 17:34:50 2012
#      by: PyQt4 UI code generator 4.9.1
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_widget_general_script_editor(object):
    def setupUi(self, widget_general_script_editor):
        widget_general_script_editor.setObjectName(_fromUtf8("widget_general_script_editor"))
        widget_general_script_editor.resize(400, 300)
        self.layout_vbox = QtGui.QVBoxLayout(widget_general_script_editor)
        self.layout_vbox.setMargin(4)
        self.layout_vbox.setObjectName(_fromUtf8("layout_vbox"))
        self.widget = QtGui.QWidget(widget_general_script_editor)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget.sizePolicy().hasHeightForWidth())
        self.widget.setSizePolicy(sizePolicy)
        self.widget.setObjectName(_fromUtf8("widget"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget)
        self.horizontalLayout.setSpacing(16)
        self.horizontalLayout.setMargin(4)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.label_warning_icon = QtGui.QLabel(self.widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_warning_icon.sizePolicy().hasHeightForWidth())
        self.label_warning_icon.setSizePolicy(sizePolicy)
        self.label_warning_icon.setObjectName(_fromUtf8("label_warning_icon"))
        self.horizontalLayout.addWidget(self.label_warning_icon)
        self.label = QtGui.QLabel(self.widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label.sizePolicy().hasHeightForWidth())
        self.label.setSizePolicy(sizePolicy)
        self.label.setWordWrap(True)
        self.label.setObjectName(_fromUtf8("label"))
        self.horizontalLayout.addWidget(self.label)
        self.layout_vbox.addWidget(self.widget)

        self.retranslateUi(widget_general_script_editor)
        QtCore.QMetaObject.connectSlotsByName(widget_general_script_editor)

    def retranslateUi(self, widget_general_script_editor):
        widget_general_script_editor.setWindowTitle(QtGui.QApplication.translate("widget_general_script_editor", "Form", None, QtGui.QApplication.UnicodeUTF8))
        self.label_warning_icon.setText(QtGui.QApplication.translate("widget_general_script_editor", "ICON", None, QtGui.QApplication.UnicodeUTF8))
        self.label.setText(QtGui.QApplication.translate("widget_general_script_editor", "<b>General script editor</b><br />\n"
"Edit your experiment in script form", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = general_widget_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/general_widget.ui'
#
# Created: Sat Feb 15 15:53:31 2014
#      by: PyQt4 UI code generator 4.10.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_general_widget(object):
    def setupUi(self, general_widget):
        general_widget.setObjectName(_fromUtf8("general_widget"))
        general_widget.resize(829, 852)
        self.gridLayout_5 = QtGui.QGridLayout(general_widget)
        self.gridLayout_5.setMargin(0)
        self.gridLayout_5.setObjectName(_fromUtf8("gridLayout_5"))
        self.widget_container = QtGui.QWidget(general_widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_container.sizePolicy().hasHeightForWidth())
        self.widget_container.setSizePolicy(sizePolicy)
        self.widget_container.setObjectName(_fromUtf8("widget_container"))
        self.horizontalLayout_5 = QtGui.QHBoxLayout(self.widget_container)
        self.horizontalLayout_5.setMargin(0)
        self.horizontalLayout_5.setObjectName(_fromUtf8("horizontalLayout_5"))
        self.widget = QtGui.QWidget(self.widget_container)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget.sizePolicy().hasHeightForWidth())
        self.widget.setSizePolicy(sizePolicy)
        self.widget.setMinimumSize(QtCore.QSize(20, 20))
        self.widget.setObjectName(_fromUtf8("widget"))
        self.formLayout = QtGui.QFormLayout(self.widget)
        self.formLayout.setFieldGrowthPolicy(QtGui.QFormLayout.AllNonFixedFieldsGrow)
        self.formLayout.setLabelAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.formLayout.setMargin(0)
        self.formLayout.setObjectName(_fromUtf8("formLayout"))
        self.label_backend = QtGui.QLabel(self.widget)
        self.label_backend.setObjectName(_fromUtf8("label_backend"))
        self.formLayout.setWidget(0, QtGui.QFormLayout.LabelRole, self.label_backend)
        self.label_resolution = QtGui.QLabel(self.widget)
        self.label_resolution.setObjectName(_fromUtf8("label_resolution"))
        self.formLayout.setWidget(2, QtGui.QFormLayout.LabelRole, self.label_resolution)
        self.frame_resolution = QtGui.QFrame(self.widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frame_resolution.sizePolicy().hasHeightForWidth())
        self.frame_resolution.setSizePolicy(sizePolicy)
        self.frame_resolution.setFrameShape(QtGui.QFrame.NoFrame)
        self.frame_resolution.setObjectName(_fromUtf8("frame_resolution"))
        self.horizontalLayout_3 = QtGui.QHBoxLayout(self.frame_resolution)
        self.horizontalLayout_3.setMargin(0)
        self.horizontalLayout_3.setObjectName(_fromUtf8("horizontalLayout_3"))
        self.spinbox_width = QtGui.QSpinBox(self.frame_resolution)
        self.spinbox_width.setMinimum(1)
        self.spinbox_width.setMaximum(10000)
        self.spinbox_width.setObjectName(_fromUtf8("spinbox_width"))
        self.horizontalLayout_3.addWidget(self.spinbox_width)
        self.label_6 = QtGui.QLabel(self.frame_resolution)
        self.label_6.setObjectName(_fromUtf8("label_6"))
        self.horizontalLayout_3.addWidget(self.label_6)
        self.spinbox_height = QtGui.QSpinBox(self.frame_resolution)
        self.spinbox_height.setMinimum(1)
        self.spinbox_height.setMaximum(10000)
        self.spinbox_height.setObjectName(_fromUtf8("spinbox_height"))
        self.horizontalLayout_3.addWidget(self.spinbox_height)
        self.formLayout.setWidget(2, QtGui.QFormLayout.FieldRole, self.frame_resolution)
        self.label_colors = QtGui.QLabel(self.widget)
        self.label_colors.setObjectName(_fromUtf8("label_colors"))
        self.formLayout.setWidget(3, QtGui.QFormLayout.LabelRole, self.label_colors)
        self.frame_colors = QtGui.QFrame(self.widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frame_colors.sizePolicy().hasHeightForWidth())
        self.frame_colors.setSizePolicy(sizePolicy)
        self.frame_colors.setFrameShape(QtGui.QFrame.NoFrame)
        self.frame_colors.setObjectName(_fromUtf8("frame_colors"))
        self.gridLayout_6 = QtGui.QGridLayout(self.frame_colors)
        self.gridLayout_6.setMargin(0)
        self.gridLayout_6.setObjectName(_fromUtf8("gridLayout_6"))
        self.edit_foreground = color_edit(self.frame_colors)
        self.edit_foreground.setObjectName(_fromUtf8("edit_foreground"))
        self.gridLayout_6.addWidget(self.edit_foreground, 0, 1, 1, 1)
        self.label_foreground = QtGui.QLabel(self.frame_colors)
        self.label_foreground.setObjectName(_fromUtf8("label_foreground"))
        self.gridLayout_6.addWidget(self.label_foreground, 0, 0, 1, 1)
        self.label_background = QtGui.QLabel(self.frame_colors)
        self.label_background.setObjectName(_fromUtf8("label_background"))
        self.gridLayout_6.addWidget(self.label_background, 1, 0, 1, 1)
        self.edit_background = color_edit(self.frame_colors)
        self.edit_background.setObjectName(_fromUtf8("edit_background"))
        self.gridLayout_6.addWidget(self.edit_background, 1, 1, 1, 1)
        self.label_colors_examples = QtGui.QLabel(self.frame_colors)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_colors_examples.sizePolicy().hasHeightForWidth())
        self.label_colors_examples.setSizePolicy(sizePolicy)
        self.label_colors_examples.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.label_colors_examples.setWordWrap(True)
        self.label_colors_examples.setObjectName(_fromUtf8("label_colors_examples"))
        self.gridLayout_6.addWidget(self.label_colors_examples, 2, 0, 1, 2)
        self.formLayout.setWidget(3, QtGui.QFormLayout.FieldRole, self.frame_colors)
        self.label_font = QtGui.QLabel(self.widget)
        self.label_font.setObjectName(_fromUtf8("label_font"))
        self.formLayout.setWidget(4, QtGui.QFormLayout.LabelRole, self.label_font)
        self.frame_font = QtGui.QFrame(self.widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frame_font.sizePolicy().hasHeightForWidth())
        self.frame_font.setSizePolicy(sizePolicy)
        self.frame_font.setFrameShape(QtGui.QFrame.NoFrame)
        self.frame_font.setFrameShadow(QtGui.QFrame.Raised)
        self.frame_font.setObjectName(_fromUtf8("frame_font"))
        self.horizontalLayout_4 = QtGui.QHBoxLayout(self.frame_font)
        self.horizontalLayout_4.setMargin(0)
        self.horizontalLayout_4.setObjectName(_fromUtf8("horizontalLayout_4"))
        self.widget_font = font_widget(self.frame_font)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_font.sizePolicy().hasHeightForWidth())
        self.widget_font.setSizePolicy(sizePolicy)
        self.widget_font.setMinimumSize(QtCore.QSize(10, 10))
        self.widget_font.setObjectName(_fromUtf8("widget_font"))
        self.horizontalLayout_4.addWidget(self.widget_font)
        self.formLayout.setWidget(4, QtGui.QFormLayout.FieldRole, self.frame_font)
        self.label_advanced = QtGui.QLabel(self.widget)
        self.label_advanced.setObjectName(_fromUtf8("label_advanced"))
        self.formLayout.setWidget(7, QtGui.QFormLayout.LabelRole, self.label_advanced)
        self.frame_advanced = QtGui.QFrame(self.widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frame_advanced.sizePolicy().hasHeightForWidth())
        self.frame_advanced.setSizePolicy(sizePolicy)
        self.frame_advanced.setFrameShape(QtGui.QFrame.NoFrame)
        self.frame_advanced.setFrameShadow(QtGui.QFrame.Raised)
        self.frame_advanced.setObjectName(_fromUtf8("frame_advanced"))
        self.horizontalLayout_6 = QtGui.QHBoxLayout(self.frame_advanced)
        self.horizontalLayout_6.setSpacing(0)
        self.horizontalLayout_6.setMargin(0)
        self.horizontalLayout_6.setObjectName(_fromUtf8("horizontalLayout_6"))
        self.button_backend_settings = QtGui.QCommandLinkButton(self.frame_advanced)
        self.button_backend_settings.setObjectName(_fromUtf8("button_backend_settings"))
        self.horizontalLayout_6.addWidget(self.button_backend_settings)
        self.button_script_editor = QtGui.QCommandLinkButton(self.frame_advanced)
        self.button_script_editor.setObjectName(_fromUtf8("button_script_editor"))
        self.horizontalLayout_6.addWidget(self.button_script_editor)
        self.formLayout.setWidget(7, QtGui.QFormLayout.FieldRole, self.frame_advanced)
        self.checkbox_transparent_variables = QtGui.QCheckBox(self.widget)
        self.checkbox_transparent_variables.setObjectName(_fromUtf8("checkbox_transparent_variables"))
        self.formLayout.setWidget(5, QtGui.QFormLayout.FieldRole, self.checkbox_transparent_variables)
        self.label_miscellaneous = QtGui.QLabel(self.widget)
        self.label_miscellaneous.setTextFormat(QtCore.Qt.AutoText)
        self.label_miscellaneous.setObjectName(_fromUtf8("label_miscellaneous"))
        self.formLayout.setWidget(5, QtGui.QFormLayout.LabelRole, self.label_miscellaneous)
        self.checkbox_bidi = QtGui.QCheckBox(self.widget)
        self.checkbox_bidi.setObjectName(_fromUtf8("checkbox_bidi"))
        self.formLayout.setWidget(6, QtGui.QFormLayout.FieldRole, self.checkbox_bidi)
        self.widget_backend = QtGui.QWidget(self.widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_backend.sizePolicy().hasHeightForWidth())
        self.widget_backend.setSizePolicy(sizePolicy)
        self.widget_backend.setObjectName(_fromUtf8("widget_backend"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget_backend)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.combobox_backend = QtGui.QComboBox(self.widget_backend)
        self.combobox_backend.setObjectName(_fromUtf8("combobox_backend"))
        self.horizontalLayout.addWidget(self.combobox_backend)
        self.label_backend_2 = QtGui.QLabel(self.widget_backend)
        self.label_backend_2.setOpenExternalLinks(True)
        self.label_backend_2.setObjectName(_fromUtf8("label_backend_2"))
        self.horizontalLayout.addWidget(self.label_backend_2)
        self.formLayout.setWidget(0, QtGui.QFormLayout.FieldRole, self.widget_backend)
        self.horizontalLayout_5.addWidget(self.widget)
        self.gridLayout_5.addWidget(self.widget_container, 0, 0, 1, 1)

        self.retranslateUi(general_widget)
        QtCore.QMetaObject.connectSlotsByName(general_widget)

    def retranslateUi(self, general_widget):
        general_widget.setWindowTitle(_translate("general_widget", "Form", None))
        self.label_backend.setText(_translate("general_widget", "<h3>Back-end</h3>", None))
        self.label_resolution.setText(_translate("general_widget", "<h3>Resolution</h3>", None))
        self.spinbox_width.setToolTip(_translate("general_widget", "The display resolution (width) in pixels", None))
        self.spinbox_width.setSuffix(_translate("general_widget", "px", None))
        self.label_6.setText(_translate("general_widget", "x", None))
        self.spinbox_height.setToolTip(_translate("general_widget", "The display resolution (height) in pixels", None))
        self.spinbox_height.setSuffix(_translate("general_widget", "px", None))
        self.label_colors.setText(_translate("general_widget", "<h3>Colors</h3>", None))
        self.label_foreground.setText(_translate("general_widget", "Foreground", None))
        self.label_background.setText(_translate("general_widget", "Background", None))
        self.label_colors_examples.setText(_translate("general_widget", "<small><i>Examples: \'white\', \'#FFFFFF\'</i></small>", None))
        self.label_font.setText(_translate("general_widget", "<h3>Font</h3>", None))
        self.label_advanced.setText(_translate("general_widget", "<h3>Advanced</h3>", None))
        self.button_backend_settings.setToolTip(_translate("general_widget", "Advanced settings for the selected back-end", None))
        self.button_backend_settings.setText(_translate("general_widget", "Back-end settings", None))
        self.button_script_editor.setToolTip(_translate("general_widget", "Edit the script for the entire experiment", None))
        self.button_script_editor.setText(_translate("general_widget", "Script editor", None))
        self.checkbox_transparent_variables.setToolTip(_translate("general_widget", "Allows you to access experimental variables directly by name", None))
        self.checkbox_transparent_variables.setText(_translate("general_widget", "Transparent variable management", None))
        self.label_miscellaneous.setText(_translate("general_widget", "<html><head/><body><p><span style=\" font-size:large; font-weight:600;\">Miscellaneous</span></p></body></html>", None))
        self.checkbox_bidi.setToolTip(_translate("general_widget", "Enables support for bi-directional languages, such as Arabic and Hebrew", None))
        self.checkbox_bidi.setText(_translate("general_widget", "Bi-directional-text support", None))
        self.label_backend_2.setText(_translate("general_widget", "<html><head/><body><p><a href=\"http://osdoc.cogsci.nl/back-ends/about\"><span style=\"font-size:small;font-style:italic; text-decoration: underline; color:#0057ae;\">Why is this important?</span></a></p></body></html>", None))

from libqtopensesame.widgets.font_widget import font_widget
from libqtopensesame.widgets.color_edit import color_edit

########NEW FILE########
__FILENAME__ = loop_widget_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/loop_widget.ui'
#
# Created: Thu Nov 15 18:03:35 2012
#      by: PyQt4 UI code generator 4.9.1
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_loop_widget(object):
    def setupUi(self, loop_widget):
        loop_widget.setObjectName(_fromUtf8("loop_widget"))
        loop_widget.resize(811, 318)
        self.gridLayout = QtGui.QGridLayout(loop_widget)
        self.gridLayout.setMargin(0)
        self.gridLayout.setVerticalSpacing(8)
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        self.widget_buttons = QtGui.QWidget(loop_widget)
        self.widget_buttons.setObjectName(_fromUtf8("widget_buttons"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget_buttons)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.button_add_cyclevar = QtGui.QPushButton(self.widget_buttons)
        self.button_add_cyclevar.setIconSize(QtCore.QSize(16, 16))
        self.button_add_cyclevar.setObjectName(_fromUtf8("button_add_cyclevar"))
        self.horizontalLayout.addWidget(self.button_add_cyclevar)
        self.button_rename_cyclevar = QtGui.QPushButton(self.widget_buttons)
        self.button_rename_cyclevar.setIconSize(QtCore.QSize(16, 16))
        self.button_rename_cyclevar.setObjectName(_fromUtf8("button_rename_cyclevar"))
        self.horizontalLayout.addWidget(self.button_rename_cyclevar)
        self.button_remove_cyclevar = QtGui.QPushButton(self.widget_buttons)
        self.button_remove_cyclevar.setIconSize(QtCore.QSize(16, 16))
        self.button_remove_cyclevar.setObjectName(_fromUtf8("button_remove_cyclevar"))
        self.horizontalLayout.addWidget(self.button_remove_cyclevar)
        self.button_apply_weights = QtGui.QPushButton(self.widget_buttons)
        self.button_apply_weights.setObjectName(_fromUtf8("button_apply_weights"))
        self.horizontalLayout.addWidget(self.button_apply_weights)
        spacerItem = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.button_wizard = QtGui.QPushButton(self.widget_buttons)
        self.button_wizard.setIconSize(QtCore.QSize(16, 16))
        self.button_wizard.setObjectName(_fromUtf8("button_wizard"))
        self.horizontalLayout.addWidget(self.button_wizard)
        self.gridLayout.addWidget(self.widget_buttons, 6, 0, 1, 1)
        self.frame = QtGui.QFrame(loop_widget)
        self.frame.setFrameShape(QtGui.QFrame.StyledPanel)
        self.frame.setFrameShadow(QtGui.QFrame.Raised)
        self.frame.setObjectName(_fromUtf8("frame"))
        self.verticalLayout = QtGui.QVBoxLayout(self.frame)
        self.verticalLayout.setMargin(4)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.checkbox_advanced = QtGui.QCheckBox(self.frame)
        self.checkbox_advanced.setObjectName(_fromUtf8("checkbox_advanced"))
        self.verticalLayout.addWidget(self.checkbox_advanced)
        self.widget_advanced = QtGui.QWidget(self.frame)
        self.widget_advanced.setObjectName(_fromUtf8("widget_advanced"))
        self.gridLayout_3 = QtGui.QGridLayout(self.widget_advanced)
        self.gridLayout_3.setMargin(0)
        self.gridLayout_3.setMargin(0)
        self.gridLayout_3.setObjectName(_fromUtf8("gridLayout_3"))
        self.spin_skip = QtGui.QSpinBox(self.widget_advanced)
        self.spin_skip.setMaximum(10000)
        self.spin_skip.setObjectName(_fromUtf8("spin_skip"))
        self.gridLayout_3.addWidget(self.spin_skip, 1, 1, 1, 1)
        self.label_skip = QtGui.QLabel(self.widget_advanced)
        self.label_skip.setObjectName(_fromUtf8("label_skip"))
        self.gridLayout_3.addWidget(self.label_skip, 1, 0, 1, 1)
        self.label = QtGui.QLabel(self.widget_advanced)
        self.label.setObjectName(_fromUtf8("label"))
        self.gridLayout_3.addWidget(self.label, 0, 0, 1, 1)
        self.edit_break_if = QtGui.QLineEdit(self.widget_advanced)
        self.edit_break_if.setObjectName(_fromUtf8("edit_break_if"))
        self.gridLayout_3.addWidget(self.edit_break_if, 0, 1, 1, 1)
        self.checkbox_offset = QtGui.QCheckBox(self.widget_advanced)
        self.checkbox_offset.setObjectName(_fromUtf8("checkbox_offset"))
        self.gridLayout_3.addWidget(self.checkbox_offset, 2, 0, 1, 2)
        self.verticalLayout.addWidget(self.widget_advanced)
        self.gridLayout.addWidget(self.frame, 2, 0, 1, 1)
        self.widget_options = QtGui.QWidget(loop_widget)
        self.widget_options.setObjectName(_fromUtf8("widget_options"))
        self.gridLayout_2 = QtGui.QGridLayout(self.widget_options)
        self.gridLayout_2.setMargin(0)
        self.gridLayout_2.setMargin(0)
        self.gridLayout_2.setObjectName(_fromUtf8("gridLayout_2"))
        self.label_item = QtGui.QLabel(self.widget_options)
        self.label_item.setObjectName(_fromUtf8("label_item"))
        self.gridLayout_2.addWidget(self.label_item, 0, 0, 1, 1)
        self.combobox_item = QtGui.QComboBox(self.widget_options)
        self.combobox_item.setObjectName(_fromUtf8("combobox_item"))
        self.gridLayout_2.addWidget(self.combobox_item, 0, 1, 1, 1)
        self.label_cycles = QtGui.QLabel(self.widget_options)
        self.label_cycles.setObjectName(_fromUtf8("label_cycles"))
        self.gridLayout_2.addWidget(self.label_cycles, 3, 0, 1, 1)
        self.combobox_order = QtGui.QComboBox(self.widget_options)
        self.combobox_order.setObjectName(_fromUtf8("combobox_order"))
        self.combobox_order.addItem(_fromUtf8(""))
        self.combobox_order.setItemText(0, _fromUtf8("random"))
        self.combobox_order.addItem(_fromUtf8(""))
        self.combobox_order.setItemText(1, _fromUtf8("sequential"))
        self.gridLayout_2.addWidget(self.combobox_order, 0, 3, 1, 1)
        self.label_order = QtGui.QLabel(self.widget_options)
        self.label_order.setObjectName(_fromUtf8("label_order"))
        self.gridLayout_2.addWidget(self.label_order, 0, 2, 1, 1)
        self.spin_cycles = QtGui.QSpinBox(self.widget_options)
        self.spin_cycles.setMaximum(10000000)
        self.spin_cycles.setObjectName(_fromUtf8("spin_cycles"))
        self.gridLayout_2.addWidget(self.spin_cycles, 3, 1, 1, 1)
        self.label_repeat = QtGui.QLabel(self.widget_options)
        self.label_repeat.setObjectName(_fromUtf8("label_repeat"))
        self.gridLayout_2.addWidget(self.label_repeat, 3, 2, 1, 1)
        self.spin_repeat = QtGui.QDoubleSpinBox(self.widget_options)
        self.spin_repeat.setMaximum(100000.0)
        self.spin_repeat.setObjectName(_fromUtf8("spin_repeat"))
        self.gridLayout_2.addWidget(self.spin_repeat, 3, 3, 1, 1)
        self.gridLayout.addWidget(self.widget_options, 0, 0, 1, 1)
        self.frame_summary = QtGui.QFrame(loop_widget)
        self.frame_summary.setFrameShape(QtGui.QFrame.StyledPanel)
        self.frame_summary.setFrameShadow(QtGui.QFrame.Raised)
        self.frame_summary.setObjectName(_fromUtf8("frame_summary"))
        self.horizontalLayout_2 = QtGui.QHBoxLayout(self.frame_summary)
        self.horizontalLayout_2.setMargin(4)
        self.horizontalLayout_2.setObjectName(_fromUtf8("horizontalLayout_2"))
        self.label_info = QtGui.QLabel(self.frame_summary)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_info.sizePolicy().hasHeightForWidth())
        self.label_info.setSizePolicy(sizePolicy)
        self.label_info.setObjectName(_fromUtf8("label_info"))
        self.horizontalLayout_2.addWidget(self.label_info)
        self.label_summary = QtGui.QLabel(self.frame_summary)
        self.label_summary.setObjectName(_fromUtf8("label_summary"))
        self.horizontalLayout_2.addWidget(self.label_summary)
        self.gridLayout.addWidget(self.frame_summary, 1, 0, 1, 1)

        self.retranslateUi(loop_widget)
        QtCore.QObject.connect(self.checkbox_advanced, QtCore.SIGNAL(_fromUtf8("toggled(bool)")), self.widget_advanced.setVisible)
        QtCore.QMetaObject.connectSlotsByName(loop_widget)

    def retranslateUi(self, loop_widget):
        loop_widget.setWindowTitle(QtGui.QApplication.translate("loop_widget", "Form", None, QtGui.QApplication.UnicodeUTF8))
        self.button_add_cyclevar.setText(QtGui.QApplication.translate("loop_widget", "Add variable", None, QtGui.QApplication.UnicodeUTF8))
        self.button_rename_cyclevar.setText(QtGui.QApplication.translate("loop_widget", "Rename variable", None, QtGui.QApplication.UnicodeUTF8))
        self.button_remove_cyclevar.setText(QtGui.QApplication.translate("loop_widget", "Remove variable", None, QtGui.QApplication.UnicodeUTF8))
        self.button_apply_weights.setText(QtGui.QApplication.translate("loop_widget", "Apply weights", None, QtGui.QApplication.UnicodeUTF8))
        self.button_wizard.setText(QtGui.QApplication.translate("loop_widget", "Variable wizard", None, QtGui.QApplication.UnicodeUTF8))
        self.checkbox_advanced.setText(QtGui.QApplication.translate("loop_widget", "Show advanced options", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_skip.setSuffix(QtGui.QApplication.translate("loop_widget", " cycle(s)", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_skip.setPrefix(QtGui.QApplication.translate("loop_widget", "first ", None, QtGui.QApplication.UnicodeUTF8))
        self.label_skip.setText(QtGui.QApplication.translate("loop_widget", "At loop start, skip the", None, QtGui.QApplication.UnicodeUTF8))
        self.label.setText(QtGui.QApplication.translate("loop_widget", "Break if", None, QtGui.QApplication.UnicodeUTF8))
        self.checkbox_offset.setText(QtGui.QApplication.translate("loop_widget", "Run skipped cycles at end of loop (offset mode)", None, QtGui.QApplication.UnicodeUTF8))
        self.label_item.setText(QtGui.QApplication.translate("loop_widget", "Item to run", None, QtGui.QApplication.UnicodeUTF8))
        self.label_cycles.setText(QtGui.QApplication.translate("loop_widget", "Cycles", None, QtGui.QApplication.UnicodeUTF8))
        self.label_order.setText(QtGui.QApplication.translate("loop_widget", "Order", None, QtGui.QApplication.UnicodeUTF8))
        self.label_repeat.setText(QtGui.QApplication.translate("loop_widget", "Repeat", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_repeat.setPrefix(QtGui.QApplication.translate("loop_widget", "each cycle ", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_repeat.setSuffix(QtGui.QApplication.translate("loop_widget", " time(s)", None, QtGui.QApplication.UnicodeUTF8))
        self.label_info.setText(QtGui.QApplication.translate("loop_widget", "TextLabel", None, QtGui.QApplication.UnicodeUTF8))
        self.label_summary.setText(QtGui.QApplication.translate("loop_widget", "Automatic summary", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = loop_wizard_dialog_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/loop_wizard_dialog.ui'
#
# Created: Thu Aug  2 12:43:06 2012
#      by: PyQt4 UI code generator 4.9.1
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_loop_wizard_dialog(object):
    def setupUi(self, loop_wizard_dialog):
        loop_wizard_dialog.setObjectName(_fromUtf8("loop_wizard_dialog"))
        loop_wizard_dialog.resize(478, 471)
        self.verticalLayout = QtGui.QVBoxLayout(loop_wizard_dialog)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.widget = QtGui.QWidget(loop_wizard_dialog)
        self.widget.setObjectName(_fromUtf8("widget"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.label_wizard = QtGui.QLabel(self.widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_wizard.sizePolicy().hasHeightForWidth())
        self.label_wizard.setSizePolicy(sizePolicy)
        self.label_wizard.setText(_fromUtf8(""))
        self.label_wizard.setPixmap(QtGui.QPixmap(_fromUtf8(":/icons/wizard_large.png")))
        self.label_wizard.setObjectName(_fromUtf8("label_wizard"))
        self.horizontalLayout.addWidget(self.label_wizard)
        self.label_2 = QtGui.QLabel(self.widget)
        self.label_2.setWordWrap(True)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.horizontalLayout.addWidget(self.label_2)
        self.verticalLayout.addWidget(self.widget)
        self.widget_2 = QtGui.QWidget(loop_wizard_dialog)
        self.widget_2.setObjectName(_fromUtf8("widget_2"))
        self.horizontalLayout_2 = QtGui.QHBoxLayout(self.widget_2)
        self.horizontalLayout_2.setMargin(0)
        self.horizontalLayout_2.setMargin(0)
        self.horizontalLayout_2.setObjectName(_fromUtf8("horizontalLayout_2"))
        self.checkBox = QtGui.QCheckBox(self.widget_2)
        self.checkBox.setObjectName(_fromUtf8("checkBox"))
        self.horizontalLayout_2.addWidget(self.checkBox)
        spacerItem = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem)
        self.verticalLayout.addWidget(self.widget_2)
        self.table_example = good_looking_table(loop_wizard_dialog)
        self.table_example.setEditTriggers(QtGui.QAbstractItemView.NoEditTriggers)
        self.table_example.setGridStyle(QtCore.Qt.DotLine)
        self.table_example.setObjectName(_fromUtf8("table_example"))
        self.table_example.setColumnCount(10)
        self.table_example.setRowCount(12)
        item = QtGui.QTableWidgetItem()
        self.table_example.setVerticalHeaderItem(0, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setVerticalHeaderItem(1, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setVerticalHeaderItem(2, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setVerticalHeaderItem(3, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setVerticalHeaderItem(4, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setVerticalHeaderItem(5, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setVerticalHeaderItem(6, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setVerticalHeaderItem(7, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setVerticalHeaderItem(8, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setVerticalHeaderItem(9, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setVerticalHeaderItem(10, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setVerticalHeaderItem(11, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setHorizontalHeaderItem(0, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setHorizontalHeaderItem(1, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setHorizontalHeaderItem(2, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setHorizontalHeaderItem(3, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setHorizontalHeaderItem(4, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setHorizontalHeaderItem(5, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setHorizontalHeaderItem(6, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setHorizontalHeaderItem(7, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setHorizontalHeaderItem(8, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setHorizontalHeaderItem(9, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setItem(0, 0, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setItem(0, 1, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setItem(0, 2, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setItem(1, 0, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setItem(1, 1, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setItem(1, 2, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setItem(2, 0, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setItem(2, 1, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setItem(2, 2, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setItem(3, 0, item)
        item = QtGui.QTableWidgetItem()
        self.table_example.setItem(4, 0, item)
        self.table_example.horizontalHeader().setVisible(False)
        self.table_example.verticalHeader().setVisible(False)
        self.verticalLayout.addWidget(self.table_example)
        self.table_wizard = good_looking_table(loop_wizard_dialog)
        self.table_wizard.setGridStyle(QtCore.Qt.DotLine)
        self.table_wizard.setObjectName(_fromUtf8("table_wizard"))
        self.table_wizard.setColumnCount(0)
        self.table_wizard.setRowCount(0)
        self.table_wizard.horizontalHeader().setVisible(False)
        self.table_wizard.verticalHeader().setVisible(False)
        self.verticalLayout.addWidget(self.table_wizard)
        self.buttonBox = QtGui.QDialogButtonBox(loop_wizard_dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName(_fromUtf8("buttonBox"))
        self.verticalLayout.addWidget(self.buttonBox)

        self.retranslateUi(loop_wizard_dialog)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("accepted()")), loop_wizard_dialog.accept)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), loop_wizard_dialog.reject)
        QtCore.QObject.connect(self.checkBox, QtCore.SIGNAL(_fromUtf8("toggled(bool)")), self.table_example.setVisible)
        QtCore.QMetaObject.connectSlotsByName(loop_wizard_dialog)

    def retranslateUi(self, loop_wizard_dialog):
        loop_wizard_dialog.setWindowTitle(QtGui.QApplication.translate("loop_wizard_dialog", "Loop Variable Wizard", None, QtGui.QApplication.UnicodeUTF8))
        self.label_2.setText(QtGui.QApplication.translate("loop_wizard_dialog", "<b>Loop variable wizard</b><br /><small>Enter the names of the variables (factors) in the first row in the table below. Under the variable names, enter the levels of the variables.<br /><i>Note: This will overwrite the current loop table</i></small>", None, QtGui.QApplication.UnicodeUTF8))
        self.checkBox.setText(QtGui.QApplication.translate("loop_wizard_dialog", "Show example", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.verticalHeaderItem(0)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Row", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.verticalHeaderItem(1)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Row", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.verticalHeaderItem(2)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Row", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.verticalHeaderItem(3)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Row", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.verticalHeaderItem(4)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Row", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.verticalHeaderItem(5)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Row", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.verticalHeaderItem(6)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Row", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.verticalHeaderItem(7)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Row", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.verticalHeaderItem(8)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Row", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.verticalHeaderItem(9)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Row", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.verticalHeaderItem(10)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Row", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.verticalHeaderItem(11)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Row", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.horizontalHeaderItem(0)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Column", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.horizontalHeaderItem(1)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Column", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.horizontalHeaderItem(2)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Column", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.horizontalHeaderItem(3)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Column", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.horizontalHeaderItem(4)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Column", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.horizontalHeaderItem(5)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Column", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.horizontalHeaderItem(6)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Column", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.horizontalHeaderItem(7)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Column", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.horizontalHeaderItem(8)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Column", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.horizontalHeaderItem(9)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "New Column", None, QtGui.QApplication.UnicodeUTF8))
        __sortingEnabled = self.table_example.isSortingEnabled()
        self.table_example.setSortingEnabled(False)
        item = self.table_example.item(0, 0)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "soa", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.item(0, 1)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "target", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.item(0, 2)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "cue", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.item(1, 0)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "0", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.item(1, 1)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "left", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.item(1, 2)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "left", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.item(2, 0)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "100", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.item(2, 1)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "right", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.item(2, 2)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "right", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.item(3, 0)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "500", None, QtGui.QApplication.UnicodeUTF8))
        item = self.table_example.item(4, 0)
        item.setText(QtGui.QApplication.translate("loop_wizard_dialog", "1000", None, QtGui.QApplication.UnicodeUTF8))
        self.table_example.setSortingEnabled(__sortingEnabled)

from good_looking_table import good_looking_table

########NEW FILE########
__FILENAME__ = new_loop_sequence_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/new_loop_sequence.ui'
#
# Created: Thu Aug  2 12:43:06 2012
#      by: PyQt4 UI code generator 4.9.1
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_new_loop_sequence_dialog(object):
    def setupUi(self, new_loop_sequence_dialog):
        new_loop_sequence_dialog.setObjectName(_fromUtf8("new_loop_sequence_dialog"))
        new_loop_sequence_dialog.resize(411, 197)
        self.verticalLayout = QtGui.QVBoxLayout(new_loop_sequence_dialog)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.widget_3 = QtGui.QWidget(new_loop_sequence_dialog)
        self.widget_3.setObjectName(_fromUtf8("widget_3"))
        self.horizontalLayout_3 = QtGui.QHBoxLayout(self.widget_3)
        self.horizontalLayout_3.setMargin(0)
        self.horizontalLayout_3.setMargin(0)
        self.horizontalLayout_3.setObjectName(_fromUtf8("horizontalLayout_3"))
        self.label_icon = QtGui.QLabel(self.widget_3)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_icon.sizePolicy().hasHeightForWidth())
        self.label_icon.setSizePolicy(sizePolicy)
        self.label_icon.setText(_fromUtf8(""))
        self.label_icon.setPixmap(QtGui.QPixmap(_fromUtf8(":/icons/loop_large.png")))
        self.label_icon.setObjectName(_fromUtf8("label_icon"))
        self.horizontalLayout_3.addWidget(self.label_icon)
        self.label_explanation = QtGui.QLabel(self.widget_3)
        self.label_explanation.setWordWrap(True)
        self.label_explanation.setObjectName(_fromUtf8("label_explanation"))
        self.horizontalLayout_3.addWidget(self.label_explanation)
        self.verticalLayout.addWidget(self.widget_3)
        spacerItem = QtGui.QSpacerItem(20, 40, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)
        self.verticalLayout.addItem(spacerItem)
        self.widget_2 = QtGui.QWidget(new_loop_sequence_dialog)
        self.widget_2.setObjectName(_fromUtf8("widget_2"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget_2)
        self.horizontalLayout.setSpacing(12)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.groupBox = QtGui.QGroupBox(self.widget_2)
        self.groupBox.setObjectName(_fromUtf8("groupBox"))
        self.verticalLayout_2 = QtGui.QVBoxLayout(self.groupBox)
        self.verticalLayout_2.setContentsMargins(0, 8, 0, 0)
        self.verticalLayout_2.setObjectName(_fromUtf8("verticalLayout_2"))
        self.combobox_new = QtGui.QComboBox(self.groupBox)
        self.combobox_new.setObjectName(_fromUtf8("combobox_new"))
        self.verticalLayout_2.addWidget(self.combobox_new)
        self.button_new = QtGui.QPushButton(self.groupBox)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/add.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_new.setIcon(icon)
        self.button_new.setIconSize(QtCore.QSize(16, 16))
        self.button_new.setObjectName(_fromUtf8("button_new"))
        self.verticalLayout_2.addWidget(self.button_new)
        self.horizontalLayout.addWidget(self.groupBox)
        self.groupBox_2 = QtGui.QGroupBox(self.widget_2)
        self.groupBox_2.setObjectName(_fromUtf8("groupBox_2"))
        self.verticalLayout_3 = QtGui.QVBoxLayout(self.groupBox_2)
        self.verticalLayout_3.setContentsMargins(0, 8, 0, 0)
        self.verticalLayout_3.setObjectName(_fromUtf8("verticalLayout_3"))
        self.combobox_select = QtGui.QComboBox(self.groupBox_2)
        self.combobox_select.setObjectName(_fromUtf8("combobox_select"))
        self.verticalLayout_3.addWidget(self.combobox_select)
        self.button_select = QtGui.QPushButton(self.groupBox_2)
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/apply.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_select.setIcon(icon1)
        self.button_select.setIconSize(QtCore.QSize(16, 16))
        self.button_select.setObjectName(_fromUtf8("button_select"))
        self.verticalLayout_3.addWidget(self.button_select)
        self.horizontalLayout.addWidget(self.groupBox_2)
        self.verticalLayout.addWidget(self.widget_2)
        self.widget = QtGui.QWidget(new_loop_sequence_dialog)
        self.widget.setObjectName(_fromUtf8("widget"))
        self.horizontalLayout_2 = QtGui.QHBoxLayout(self.widget)
        self.horizontalLayout_2.setMargin(0)
        self.horizontalLayout_2.setMargin(0)
        self.horizontalLayout_2.setObjectName(_fromUtf8("horizontalLayout_2"))
        spacerItem1 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem1)
        self.button_cancel = QtGui.QPushButton(self.widget)
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/delete.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_cancel.setIcon(icon2)
        self.button_cancel.setIconSize(QtCore.QSize(16, 16))
        self.button_cancel.setObjectName(_fromUtf8("button_cancel"))
        self.horizontalLayout_2.addWidget(self.button_cancel)
        self.verticalLayout.addWidget(self.widget)

        self.retranslateUi(new_loop_sequence_dialog)
        QtCore.QObject.connect(self.button_cancel, QtCore.SIGNAL(_fromUtf8("clicked()")), new_loop_sequence_dialog.accept)
        QtCore.QMetaObject.connectSlotsByName(new_loop_sequence_dialog)

    def retranslateUi(self, new_loop_sequence_dialog):
        new_loop_sequence_dialog.setWindowTitle(QtGui.QApplication.translate("new_loop_sequence_dialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
        self.label_explanation.setText(QtGui.QApplication.translate("new_loop_sequence_dialog", "Explanation\n"
"", None, QtGui.QApplication.UnicodeUTF8))
        self.groupBox.setTitle(QtGui.QApplication.translate("new_loop_sequence_dialog", "Create new item to use", None, QtGui.QApplication.UnicodeUTF8))
        self.button_new.setText(QtGui.QApplication.translate("new_loop_sequence_dialog", "Create", None, QtGui.QApplication.UnicodeUTF8))
        self.groupBox_2.setTitle(QtGui.QApplication.translate("new_loop_sequence_dialog", "Select existing item to use", None, QtGui.QApplication.UnicodeUTF8))
        self.button_select.setText(QtGui.QApplication.translate("new_loop_sequence_dialog", "Select", None, QtGui.QApplication.UnicodeUTF8))
        self.button_cancel.setText(QtGui.QApplication.translate("new_loop_sequence_dialog", "Cancel", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = noise_patch_dialog_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/noise_patch_dialog.ui'
#
# Created: Tue Apr  9 17:37:57 2013
#      by: PyQt4 UI code generator 4.9.1
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_noise_patch_dialog(object):
    def setupUi(self, noise_patch_dialog):
        noise_patch_dialog.setObjectName(_fromUtf8("noise_patch_dialog"))
        noise_patch_dialog.resize(476, 384)
        self.verticalLayout = QtGui.QVBoxLayout(noise_patch_dialog)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.widget_header_box = QtGui.QWidget(noise_patch_dialog)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_header_box.sizePolicy().hasHeightForWidth())
        self.widget_header_box.setSizePolicy(sizePolicy)
        self.widget_header_box.setObjectName(_fromUtf8("widget_header_box"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget_header_box)
        self.horizontalLayout.setSpacing(0)
        self.horizontalLayout.setMargin(5)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.label_noise_patch = QtGui.QLabel(self.widget_header_box)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_noise_patch.sizePolicy().hasHeightForWidth())
        self.label_noise_patch.setSizePolicy(sizePolicy)
        self.label_noise_patch.setText(_fromUtf8(""))
        self.label_noise_patch.setPixmap(QtGui.QPixmap(_fromUtf8(":/icons/noise_patch.png")))
        self.label_noise_patch.setObjectName(_fromUtf8("label_noise_patch"))
        self.horizontalLayout.addWidget(self.label_noise_patch)
        self.label_2 = QtGui.QLabel(self.widget_header_box)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_2.setFont(font)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.horizontalLayout.addWidget(self.label_2)
        self.verticalLayout.addWidget(self.widget_header_box)
        self.widget = QtGui.QWidget(noise_patch_dialog)
        font = QtGui.QFont()
        font.setPointSize(8)
        self.widget.setFont(font)
        self.widget.setObjectName(_fromUtf8("widget"))
        self.formLayout = QtGui.QFormLayout(self.widget)
        self.formLayout.setFieldGrowthPolicy(QtGui.QFormLayout.AllNonFixedFieldsGrow)
        self.formLayout.setMargin(0)
        self.formLayout.setVerticalSpacing(12)
        self.formLayout.setObjectName(_fromUtf8("formLayout"))
        self.spin_size = QtGui.QSpinBox(self.widget)
        self.spin_size.setMinimum(1)
        self.spin_size.setMaximum(1000)
        self.spin_size.setProperty("value", 96)
        self.spin_size.setObjectName(_fromUtf8("spin_size"))
        self.formLayout.setWidget(0, QtGui.QFormLayout.FieldRole, self.spin_size)
        self.label_5 = QtGui.QLabel(self.widget)
        self.label_5.setObjectName(_fromUtf8("label_5"))
        self.formLayout.setWidget(1, QtGui.QFormLayout.LabelRole, self.label_5)
        self.combobox_env = QtGui.QComboBox(self.widget)
        self.combobox_env.setObjectName(_fromUtf8("combobox_env"))
        self.combobox_env.addItem(_fromUtf8(""))
        self.combobox_env.addItem(_fromUtf8(""))
        self.combobox_env.addItem(_fromUtf8(""))
        self.combobox_env.addItem(_fromUtf8(""))
        self.formLayout.setWidget(1, QtGui.QFormLayout.FieldRole, self.combobox_env)
        self.label_6 = QtGui.QLabel(self.widget)
        self.label_6.setObjectName(_fromUtf8("label_6"))
        self.formLayout.setWidget(2, QtGui.QFormLayout.LabelRole, self.label_6)
        self.spin_stdev = QtGui.QDoubleSpinBox(self.widget)
        self.spin_stdev.setMaximum(1000.0)
        self.spin_stdev.setProperty("value", 12.0)
        self.spin_stdev.setObjectName(_fromUtf8("spin_stdev"))
        self.formLayout.setWidget(2, QtGui.QFormLayout.FieldRole, self.spin_stdev)
        self.label_10 = QtGui.QLabel(self.widget)
        self.label_10.setObjectName(_fromUtf8("label_10"))
        self.formLayout.setWidget(3, QtGui.QFormLayout.LabelRole, self.label_10)
        self.edit_color1 = QtGui.QLineEdit(self.widget)
        self.edit_color1.setText(_fromUtf8("white"))
        self.edit_color1.setObjectName(_fromUtf8("edit_color1"))
        self.formLayout.setWidget(3, QtGui.QFormLayout.FieldRole, self.edit_color1)
        self.label_9 = QtGui.QLabel(self.widget)
        self.label_9.setObjectName(_fromUtf8("label_9"))
        self.formLayout.setWidget(4, QtGui.QFormLayout.LabelRole, self.label_9)
        self.edit_color2 = QtGui.QLineEdit(self.widget)
        self.edit_color2.setText(_fromUtf8("black"))
        self.edit_color2.setObjectName(_fromUtf8("edit_color2"))
        self.formLayout.setWidget(4, QtGui.QFormLayout.FieldRole, self.edit_color2)
        self.label_11 = QtGui.QLabel(self.widget)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.label_11.setFont(font)
        self.label_11.setObjectName(_fromUtf8("label_11"))
        self.formLayout.setWidget(5, QtGui.QFormLayout.LabelRole, self.label_11)
        self.combobox_bgmode = QtGui.QComboBox(self.widget)
        self.combobox_bgmode.setObjectName(_fromUtf8("combobox_bgmode"))
        self.combobox_bgmode.addItem(_fromUtf8(""))
        self.combobox_bgmode.addItem(_fromUtf8(""))
        self.formLayout.setWidget(5, QtGui.QFormLayout.FieldRole, self.combobox_bgmode)
        self.label_4 = QtGui.QLabel(self.widget)
        self.label_4.setObjectName(_fromUtf8("label_4"))
        self.formLayout.setWidget(0, QtGui.QFormLayout.LabelRole, self.label_4)
        self.verticalLayout.addWidget(self.widget)
        self.widget_3 = QtGui.QWidget(noise_patch_dialog)
        self.widget_3.setObjectName(_fromUtf8("widget_3"))
        self.verticalLayout_2 = QtGui.QVBoxLayout(self.widget_3)
        self.verticalLayout_2.setMargin(0)
        self.verticalLayout_2.setObjectName(_fromUtf8("verticalLayout_2"))
        self.label_12 = QtGui.QLabel(self.widget_3)
        font = QtGui.QFont()
        font.setPointSize(9)
        font.setItalic(True)
        self.label_12.setFont(font)
        self.label_12.setWordWrap(True)
        self.label_12.setObjectName(_fromUtf8("label_12"))
        self.verticalLayout_2.addWidget(self.label_12)
        self.verticalLayout.addWidget(self.widget_3)
        self.buttonBox = QtGui.QDialogButtonBox(noise_patch_dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.buttonBox.setCenterButtons(False)
        self.buttonBox.setObjectName(_fromUtf8("buttonBox"))
        self.verticalLayout.addWidget(self.buttonBox)

        self.retranslateUi(noise_patch_dialog)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("accepted()")), noise_patch_dialog.accept)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), noise_patch_dialog.reject)
        QtCore.QMetaObject.connectSlotsByName(noise_patch_dialog)

    def retranslateUi(self, noise_patch_dialog):
        noise_patch_dialog.setWindowTitle(QtGui.QApplication.translate("noise_patch_dialog", "Insert noise patch", None, QtGui.QApplication.UnicodeUTF8))
        self.label_2.setText(QtGui.QApplication.translate("noise_patch_dialog", "Insert noise patch", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_size.setSuffix(QtGui.QApplication.translate("noise_patch_dialog", "px", None, QtGui.QApplication.UnicodeUTF8))
        self.label_5.setText(QtGui.QApplication.translate("noise_patch_dialog", "Envelope", None, QtGui.QApplication.UnicodeUTF8))
        self.combobox_env.setItemText(0, QtGui.QApplication.translate("noise_patch_dialog", "gaussian", None, QtGui.QApplication.UnicodeUTF8))
        self.combobox_env.setItemText(1, QtGui.QApplication.translate("noise_patch_dialog", "linear", None, QtGui.QApplication.UnicodeUTF8))
        self.combobox_env.setItemText(2, QtGui.QApplication.translate("noise_patch_dialog", "circular (sharp edge)", None, QtGui.QApplication.UnicodeUTF8))
        self.combobox_env.setItemText(3, QtGui.QApplication.translate("noise_patch_dialog", "rectangle (no envelope)", None, QtGui.QApplication.UnicodeUTF8))
        self.label_6.setText(QtGui.QApplication.translate("noise_patch_dialog", "Standard deviation<br /><i>in pixels, only applies to Gaussian envelope</i>", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_stdev.setSuffix(QtGui.QApplication.translate("noise_patch_dialog", "px", None, QtGui.QApplication.UnicodeUTF8))
        self.label_10.setText(QtGui.QApplication.translate("noise_patch_dialog", "Color 1<br /><i>e.g., \'white\' or \'#FFFFFF\'</i>", None, QtGui.QApplication.UnicodeUTF8))
        self.label_9.setText(QtGui.QApplication.translate("noise_patch_dialog", "Color 2<br /><i>e.g., \'black\' or \'#000000\'</i>", None, QtGui.QApplication.UnicodeUTF8))
        self.label_11.setText(QtGui.QApplication.translate("noise_patch_dialog", "Background color *", None, QtGui.QApplication.UnicodeUTF8))
        self.combobox_bgmode.setItemText(0, QtGui.QApplication.translate("noise_patch_dialog", "Color average", None, QtGui.QApplication.UnicodeUTF8))
        self.combobox_bgmode.setItemText(1, QtGui.QApplication.translate("noise_patch_dialog", "Color 2", None, QtGui.QApplication.UnicodeUTF8))
        self.label_4.setText(QtGui.QApplication.translate("noise_patch_dialog", "Size<br /><i>in pixels</i>", None, QtGui.QApplication.UnicodeUTF8))
        self.label_12.setText(QtGui.QApplication.translate("noise_patch_dialog", "* Has no effect in psycho back-end", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = notification_dialog_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/notification_dialog.ui'
#
# Created: Wed Oct  9 14:51:38 2013
#      by: PyQt4 UI code generator 4.10
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_notification_dialog(object):
    def setupUi(self, notification_dialog):
        notification_dialog.setObjectName(_fromUtf8("notification_dialog"))
        notification_dialog.resize(400, 300)
        self.verticalLayout = QtGui.QVBoxLayout(notification_dialog)
        self.verticalLayout.setMargin(8)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.widget = QtGui.QWidget(notification_dialog)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget.sizePolicy().hasHeightForWidth())
        self.widget.setSizePolicy(sizePolicy)
        self.widget.setStyleSheet(_fromUtf8("color: rgb(255, 255, 255);\n"
"background-color: #729fcf;"))
        self.widget.setObjectName(_fromUtf8("widget"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget)
        self.horizontalLayout.setMargin(5)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.label_notification = QtGui.QLabel(self.widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_notification.sizePolicy().hasHeightForWidth())
        self.label_notification.setSizePolicy(sizePolicy)
        self.label_notification.setText(_fromUtf8(""))
        self.label_notification.setPixmap(QtGui.QPixmap(_fromUtf8(":/icons/about_large.png")))
        self.label_notification.setObjectName(_fromUtf8("label_notification"))
        self.horizontalLayout.addWidget(self.label_notification)
        self.label_title = QtGui.QLabel(self.widget)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_title.setFont(font)
        self.label_title.setObjectName(_fromUtf8("label_title"))
        self.horizontalLayout.addWidget(self.label_title)
        self.verticalLayout.addWidget(self.widget)
        self.textedit_notification = QtGui.QTextBrowser(notification_dialog)
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Monospace"))
        self.textedit_notification.setFont(font)
        self.textedit_notification.setObjectName(_fromUtf8("textedit_notification"))
        self.verticalLayout.addWidget(self.textedit_notification)
        self.buttonBox = QtGui.QDialogButtonBox(notification_dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Close)
        self.buttonBox.setObjectName(_fromUtf8("buttonBox"))
        self.verticalLayout.addWidget(self.buttonBox)

        self.retranslateUi(notification_dialog)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("accepted()")), notification_dialog.accept)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), notification_dialog.reject)
        QtCore.QMetaObject.connectSlotsByName(notification_dialog)

    def retranslateUi(self, notification_dialog):
        notification_dialog.setWindowTitle(_translate("notification_dialog", "OpenSesame says ...", None))
        self.label_title.setText(_translate("notification_dialog", "OpenSesame says ...", None))


########NEW FILE########
__FILENAME__ = opensesamerun_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/opensesamerun.ui'
#
# Created: Thu Aug  2 12:43:05 2012
#      by: PyQt4 UI code generator 4.9.1
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_opensesamerun_mainwindow(object):
    def setupUi(self, opensesamerun_mainwindow):
        opensesamerun_mainwindow.setObjectName(_fromUtf8("opensesamerun_mainwindow"))
        opensesamerun_mainwindow.resize(429, 381)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/experiment.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        opensesamerun_mainwindow.setWindowIcon(icon)
        self.centralwidget = QtGui.QWidget(opensesamerun_mainwindow)
        self.centralwidget.setObjectName(_fromUtf8("centralwidget"))
        self.verticalLayout = QtGui.QVBoxLayout(self.centralwidget)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.widget_5 = QtGui.QWidget(self.centralwidget)
        self.widget_5.setStyleSheet(_fromUtf8("background-color: #555753;\n"
"color: rgb(255, 255, 255);"))
        self.widget_5.setObjectName(_fromUtf8("widget_5"))
        self.horizontalLayout_5 = QtGui.QHBoxLayout(self.widget_5)
        self.horizontalLayout_5.setMargin(5)
        self.horizontalLayout_5.setMargin(0)
        self.horizontalLayout_5.setObjectName(_fromUtf8("horizontalLayout_5"))
        self.label_opensesamerun = QtGui.QLabel(self.widget_5)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_opensesamerun.sizePolicy().hasHeightForWidth())
        self.label_opensesamerun.setSizePolicy(sizePolicy)
        self.label_opensesamerun.setText(_fromUtf8(""))
        self.label_opensesamerun.setPixmap(QtGui.QPixmap(_fromUtf8(":/icons/experiment_large.png")))
        self.label_opensesamerun.setObjectName(_fromUtf8("label_opensesamerun"))
        self.horizontalLayout_5.addWidget(self.label_opensesamerun)
        self.label_6 = QtGui.QLabel(self.widget_5)
        self.label_6.setObjectName(_fromUtf8("label_6"))
        self.horizontalLayout_5.addWidget(self.label_6)
        self.verticalLayout.addWidget(self.widget_5)
        self.groupBox_3 = QtGui.QGroupBox(self.centralwidget)
        self.groupBox_3.setObjectName(_fromUtf8("groupBox_3"))
        self.formLayout_2 = QtGui.QFormLayout(self.groupBox_3)
        self.formLayout_2.setFieldGrowthPolicy(QtGui.QFormLayout.AllNonFixedFieldsGrow)
        self.formLayout_2.setContentsMargins(0, 6, 0, 0)
        self.formLayout_2.setObjectName(_fromUtf8("formLayout_2"))
        self.widget_3 = QtGui.QWidget(self.groupBox_3)
        self.widget_3.setObjectName(_fromUtf8("widget_3"))
        self.horizontalLayout_3 = QtGui.QHBoxLayout(self.widget_3)
        self.horizontalLayout_3.setMargin(0)
        self.horizontalLayout_3.setMargin(0)
        self.horizontalLayout_3.setObjectName(_fromUtf8("horizontalLayout_3"))
        self.edit_experiment = QtGui.QLineEdit(self.widget_3)
        self.edit_experiment.setObjectName(_fromUtf8("edit_experiment"))
        self.horizontalLayout_3.addWidget(self.edit_experiment)
        self.button_browse_experiment = QtGui.QPushButton(self.widget_3)
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/browse.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_browse_experiment.setIcon(icon1)
        self.button_browse_experiment.setObjectName(_fromUtf8("button_browse_experiment"))
        self.horizontalLayout_3.addWidget(self.button_browse_experiment)
        self.formLayout_2.setWidget(0, QtGui.QFormLayout.FieldRole, self.widget_3)
        self.label_7 = QtGui.QLabel(self.groupBox_3)
        self.label_7.setObjectName(_fromUtf8("label_7"))
        self.formLayout_2.setWidget(0, QtGui.QFormLayout.LabelRole, self.label_7)
        self.widget_2 = QtGui.QWidget(self.groupBox_3)
        self.widget_2.setObjectName(_fromUtf8("widget_2"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget_2)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.edit_logfile = QtGui.QLineEdit(self.widget_2)
        self.edit_logfile.setObjectName(_fromUtf8("edit_logfile"))
        self.horizontalLayout.addWidget(self.edit_logfile)
        self.button_browse_logfile = QtGui.QPushButton(self.widget_2)
        self.button_browse_logfile.setIcon(icon1)
        self.button_browse_logfile.setObjectName(_fromUtf8("button_browse_logfile"))
        self.horizontalLayout.addWidget(self.button_browse_logfile)
        self.formLayout_2.setWidget(1, QtGui.QFormLayout.FieldRole, self.widget_2)
        self.label_2 = QtGui.QLabel(self.groupBox_3)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.formLayout_2.setWidget(1, QtGui.QFormLayout.LabelRole, self.label_2)
        self.spinbox_subject_nr = QtGui.QSpinBox(self.groupBox_3)
        self.spinbox_subject_nr.setMaximum(100000)
        self.spinbox_subject_nr.setObjectName(_fromUtf8("spinbox_subject_nr"))
        self.formLayout_2.setWidget(2, QtGui.QFormLayout.FieldRole, self.spinbox_subject_nr)
        self.label = QtGui.QLabel(self.groupBox_3)
        self.label.setObjectName(_fromUtf8("label"))
        self.formLayout_2.setWidget(2, QtGui.QFormLayout.LabelRole, self.label)
        self.verticalLayout.addWidget(self.groupBox_3)
        self.groupBox_2 = QtGui.QGroupBox(self.centralwidget)
        self.groupBox_2.setObjectName(_fromUtf8("groupBox_2"))
        self.formLayout_3 = QtGui.QFormLayout(self.groupBox_2)
        self.formLayout_3.setFieldGrowthPolicy(QtGui.QFormLayout.AllNonFixedFieldsGrow)
        self.formLayout_3.setContentsMargins(0, 6, 0, 0)
        self.formLayout_3.setObjectName(_fromUtf8("formLayout_3"))
        self.checkbox_fullscreen = QtGui.QCheckBox(self.groupBox_2)
        self.checkbox_fullscreen.setObjectName(_fromUtf8("checkbox_fullscreen"))
        self.formLayout_3.setWidget(0, QtGui.QFormLayout.LabelRole, self.checkbox_fullscreen)
        self.checkbox_custom_resolution = QtGui.QCheckBox(self.groupBox_2)
        self.checkbox_custom_resolution.setObjectName(_fromUtf8("checkbox_custom_resolution"))
        self.formLayout_3.setWidget(1, QtGui.QFormLayout.SpanningRole, self.checkbox_custom_resolution)
        self.widget = QtGui.QWidget(self.groupBox_2)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget.sizePolicy().hasHeightForWidth())
        self.widget.setSizePolicy(sizePolicy)
        self.widget.setObjectName(_fromUtf8("widget"))
        self.horizontalLayout_2 = QtGui.QHBoxLayout(self.widget)
        self.horizontalLayout_2.setMargin(0)
        self.horizontalLayout_2.setMargin(0)
        self.horizontalLayout_2.setObjectName(_fromUtf8("horizontalLayout_2"))
        self.label_width = QtGui.QLabel(self.widget)
        self.label_width.setEnabled(False)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_width.sizePolicy().hasHeightForWidth())
        self.label_width.setSizePolicy(sizePolicy)
        self.label_width.setObjectName(_fromUtf8("label_width"))
        self.horizontalLayout_2.addWidget(self.label_width)
        self.spinbox_width = QtGui.QSpinBox(self.widget)
        self.spinbox_width.setEnabled(False)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.spinbox_width.sizePolicy().hasHeightForWidth())
        self.spinbox_width.setSizePolicy(sizePolicy)
        self.spinbox_width.setMinimum(1)
        self.spinbox_width.setMaximum(100000)
        self.spinbox_width.setProperty("value", 1024)
        self.spinbox_width.setObjectName(_fromUtf8("spinbox_width"))
        self.horizontalLayout_2.addWidget(self.spinbox_width)
        self.label_height = QtGui.QLabel(self.widget)
        self.label_height.setEnabled(False)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_height.sizePolicy().hasHeightForWidth())
        self.label_height.setSizePolicy(sizePolicy)
        self.label_height.setObjectName(_fromUtf8("label_height"))
        self.horizontalLayout_2.addWidget(self.label_height)
        self.spinbox_height = QtGui.QSpinBox(self.widget)
        self.spinbox_height.setEnabled(False)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.spinbox_height.sizePolicy().hasHeightForWidth())
        self.spinbox_height.setSizePolicy(sizePolicy)
        self.spinbox_height.setMinimum(1)
        self.spinbox_height.setMaximum(100000)
        self.spinbox_height.setProperty("value", 768)
        self.spinbox_height.setObjectName(_fromUtf8("spinbox_height"))
        self.horizontalLayout_2.addWidget(self.spinbox_height)
        self.formLayout_3.setWidget(2, QtGui.QFormLayout.LabelRole, self.widget)
        spacerItem = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.formLayout_3.setItem(2, QtGui.QFormLayout.FieldRole, spacerItem)
        self.verticalLayout.addWidget(self.groupBox_2)
        self.groupBox = QtGui.QGroupBox(self.centralwidget)
        self.groupBox.setObjectName(_fromUtf8("groupBox"))
        self.formLayout = QtGui.QFormLayout(self.groupBox)
        self.formLayout.setFieldGrowthPolicy(QtGui.QFormLayout.AllNonFixedFieldsGrow)
        self.formLayout.setContentsMargins(0, 6, 0, 0)
        self.formLayout.setObjectName(_fromUtf8("formLayout"))
        self.checkbox_pylink = QtGui.QCheckBox(self.groupBox)
        self.checkbox_pylink.setObjectName(_fromUtf8("checkbox_pylink"))
        self.formLayout.setWidget(0, QtGui.QFormLayout.SpanningRole, self.checkbox_pylink)
        self.verticalLayout.addWidget(self.groupBox)
        self.widget_4 = QtGui.QWidget(self.centralwidget)
        self.widget_4.setObjectName(_fromUtf8("widget_4"))
        self.horizontalLayout_4 = QtGui.QHBoxLayout(self.widget_4)
        self.horizontalLayout_4.setMargin(0)
        self.horizontalLayout_4.setMargin(0)
        self.horizontalLayout_4.setObjectName(_fromUtf8("horizontalLayout_4"))
        spacerItem1 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem1)
        self.button_cancel = QtGui.QPushButton(self.widget_4)
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/close.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_cancel.setIcon(icon2)
        self.button_cancel.setObjectName(_fromUtf8("button_cancel"))
        self.horizontalLayout_4.addWidget(self.button_cancel)
        self.button_run = QtGui.QPushButton(self.widget_4)
        icon3 = QtGui.QIcon()
        icon3.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/execute.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_run.setIcon(icon3)
        self.button_run.setObjectName(_fromUtf8("button_run"))
        self.horizontalLayout_4.addWidget(self.button_run)
        self.verticalLayout.addWidget(self.widget_4)
        opensesamerun_mainwindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(opensesamerun_mainwindow)
        QtCore.QObject.connect(self.button_cancel, QtCore.SIGNAL(_fromUtf8("clicked()")), opensesamerun_mainwindow.close)
        QtCore.QObject.connect(self.checkbox_custom_resolution, QtCore.SIGNAL(_fromUtf8("toggled(bool)")), self.spinbox_width.setEnabled)
        QtCore.QObject.connect(self.checkbox_custom_resolution, QtCore.SIGNAL(_fromUtf8("toggled(bool)")), self.spinbox_height.setEnabled)
        QtCore.QObject.connect(self.checkbox_custom_resolution, QtCore.SIGNAL(_fromUtf8("toggled(bool)")), self.label_width.setEnabled)
        QtCore.QObject.connect(self.checkbox_custom_resolution, QtCore.SIGNAL(_fromUtf8("toggled(bool)")), self.label_height.setEnabled)
        QtCore.QMetaObject.connectSlotsByName(opensesamerun_mainwindow)

    def retranslateUi(self, opensesamerun_mainwindow):
        opensesamerun_mainwindow.setWindowTitle(QtGui.QApplication.translate("opensesamerun_mainwindow", "OpenSesame Run", None, QtGui.QApplication.UnicodeUTF8))
        self.label_6.setText(QtGui.QApplication.translate("opensesamerun_mainwindow", "<b>OpenSesame Run</b><br /><small><i>Run your OpenSesame experiment</i></small>", None, QtGui.QApplication.UnicodeUTF8))
        self.groupBox_3.setTitle(QtGui.QApplication.translate("opensesamerun_mainwindow", "Experiment, subject and log file", None, QtGui.QApplication.UnicodeUTF8))
        self.button_browse_experiment.setText(QtGui.QApplication.translate("opensesamerun_mainwindow", "Browse", None, QtGui.QApplication.UnicodeUTF8))
        self.label_7.setText(QtGui.QApplication.translate("opensesamerun_mainwindow", "Experiment", None, QtGui.QApplication.UnicodeUTF8))
        self.button_browse_logfile.setText(QtGui.QApplication.translate("opensesamerun_mainwindow", "Browse", None, QtGui.QApplication.UnicodeUTF8))
        self.label_2.setText(QtGui.QApplication.translate("opensesamerun_mainwindow", "Log file", None, QtGui.QApplication.UnicodeUTF8))
        self.label.setText(QtGui.QApplication.translate("opensesamerun_mainwindow", "Subject number", None, QtGui.QApplication.UnicodeUTF8))
        self.groupBox_2.setTitle(QtGui.QApplication.translate("opensesamerun_mainwindow", "Display", None, QtGui.QApplication.UnicodeUTF8))
        self.checkbox_fullscreen.setText(QtGui.QApplication.translate("opensesamerun_mainwindow", "Run fullscreen", None, QtGui.QApplication.UnicodeUTF8))
        self.checkbox_custom_resolution.setText(QtGui.QApplication.translate("opensesamerun_mainwindow", "Use custom display resolution", None, QtGui.QApplication.UnicodeUTF8))
        self.label_width.setText(QtGui.QApplication.translate("opensesamerun_mainwindow", "Width", None, QtGui.QApplication.UnicodeUTF8))
        self.spinbox_width.setSuffix(QtGui.QApplication.translate("opensesamerun_mainwindow", "px", None, QtGui.QApplication.UnicodeUTF8))
        self.label_height.setText(QtGui.QApplication.translate("opensesamerun_mainwindow", "Height", None, QtGui.QApplication.UnicodeUTF8))
        self.spinbox_height.setSuffix(QtGui.QApplication.translate("opensesamerun_mainwindow", "px", None, QtGui.QApplication.UnicodeUTF8))
        self.groupBox.setTitle(QtGui.QApplication.translate("opensesamerun_mainwindow", "Miscellaneous", None, QtGui.QApplication.UnicodeUTF8))
        self.checkbox_pylink.setText(QtGui.QApplication.translate("opensesamerun_mainwindow", "Enable PyLink module (required for the Eyelink plug-ins)", None, QtGui.QApplication.UnicodeUTF8))
        self.button_cancel.setText(QtGui.QApplication.translate("opensesamerun_mainwindow", "Cancel", None, QtGui.QApplication.UnicodeUTF8))
        self.button_run.setText(QtGui.QApplication.translate("opensesamerun_mainwindow", "Run", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = opensesame_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/opensesame.ui'
#
# Created: Thu Jun  6 16:59:41 2013
#      by: PyQt4 UI code generator 4.10
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_opensesame_mainwindow(object):
    def setupUi(self, opensesame_mainwindow):
        opensesame_mainwindow.setObjectName(_fromUtf8("opensesame_mainwindow"))
        opensesame_mainwindow.resize(1000, 773)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/experiment.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        opensesame_mainwindow.setWindowIcon(icon)
        self.centralwidget = QtGui.QWidget(opensesame_mainwindow)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.centralwidget.sizePolicy().hasHeightForWidth())
        self.centralwidget.setSizePolicy(sizePolicy)
        self.centralwidget.setObjectName(_fromUtf8("centralwidget"))
        self.verticalLayout_6 = QtGui.QVBoxLayout(self.centralwidget)
        self.verticalLayout_6.setObjectName(_fromUtf8("verticalLayout_6"))
        self.tabwidget = tab_widget(self.centralwidget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.MinimumExpanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tabwidget.sizePolicy().hasHeightForWidth())
        self.tabwidget.setSizePolicy(sizePolicy)
        self.tabwidget.setTabsClosable(True)
        self.tabwidget.setMovable(True)
        self.tabwidget.setObjectName(_fromUtf8("tabwidget"))
        self.verticalLayout_6.addWidget(self.tabwidget)
        opensesame_mainwindow.setCentralWidget(self.centralwidget)
        self.menubar = QtGui.QMenuBar(opensesame_mainwindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1000, 22))
        self.menubar.setObjectName(_fromUtf8("menubar"))
        self.menu_file = QtGui.QMenu(self.menubar)
        self.menu_file.setObjectName(_fromUtf8("menu_file"))
        self.menu_recent_files = QtGui.QMenu(self.menu_file)
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/recent_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.menu_recent_files.setIcon(icon1)
        self.menu_recent_files.setObjectName(_fromUtf8("menu_recent_files"))
        self.menu_run = QtGui.QMenu(self.menubar)
        self.menu_run.setObjectName(_fromUtf8("menu_run"))
        self.menu_items = QtGui.QMenu(self.menubar)
        self.menu_items.setObjectName(_fromUtf8("menu_items"))
        self.menu_view = QtGui.QMenu(self.menubar)
        self.menu_view.setObjectName(_fromUtf8("menu_view"))
        self.menu_help = QtGui.QMenu(self.menubar)
        self.menu_help.setObjectName(_fromUtf8("menu_help"))
        self.menu_tools = QtGui.QMenu(self.menubar)
        self.menu_tools.setObjectName(_fromUtf8("menu_tools"))
        opensesame_mainwindow.setMenuBar(self.menubar)
        self.statusbar = statusbar(opensesame_mainwindow)
        self.statusbar.setObjectName(_fromUtf8("statusbar"))
        opensesame_mainwindow.setStatusBar(self.statusbar)
        self.dock_overview = QtGui.QDockWidget(opensesame_mainwindow)
        self.dock_overview.setMinimumSize(QtCore.QSize(200, 118))
        self.dock_overview.setFeatures(QtGui.QDockWidget.AllDockWidgetFeatures)
        self.dock_overview.setObjectName(_fromUtf8("dock_overview"))
        self.dock_widget_overview = QtGui.QWidget()
        self.dock_widget_overview.setObjectName(_fromUtf8("dock_widget_overview"))
        self.verticalLayout = QtGui.QVBoxLayout(self.dock_widget_overview)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.itemtree = tree_overview(self.dock_widget_overview)
        self.itemtree.setAcceptDrops(True)
        self.itemtree.setAlternatingRowColors(True)
        self.itemtree.setAutoExpandDelay(4)
        self.itemtree.setAnimated(True)
        self.itemtree.setHeaderHidden(True)
        self.itemtree.setObjectName(_fromUtf8("itemtree"))
        self.verticalLayout.addWidget(self.itemtree)
        self.dock_overview.setWidget(self.dock_widget_overview)
        opensesame_mainwindow.addDockWidget(QtCore.Qt.DockWidgetArea(1), self.dock_overview)
        self.dock_variable_inspector = QtGui.QDockWidget(opensesame_mainwindow)
        self.dock_variable_inspector.setAllowedAreas(QtCore.Qt.AllDockWidgetAreas)
        self.dock_variable_inspector.setObjectName(_fromUtf8("dock_variable_inspector"))
        self.dock_widget_variable_inspector = QtGui.QWidget()
        self.dock_widget_variable_inspector.setObjectName(_fromUtf8("dock_widget_variable_inspector"))
        self.verticalLayout_2 = QtGui.QVBoxLayout(self.dock_widget_variable_inspector)
        self.verticalLayout_2.setObjectName(_fromUtf8("verticalLayout_2"))
        self.widget_variable_inspector_header_box = QtGui.QWidget(self.dock_widget_variable_inspector)
        self.widget_variable_inspector_header_box.setObjectName(_fromUtf8("widget_variable_inspector_header_box"))
        self.horizontalLayout_3 = QtGui.QHBoxLayout(self.widget_variable_inspector_header_box)
        self.horizontalLayout_3.setSpacing(0)
        self.horizontalLayout_3.setMargin(4)
        self.horizontalLayout_3.setObjectName(_fromUtf8("horizontalLayout_3"))
        self.label_variables = QtGui.QLabel(self.widget_variable_inspector_header_box)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_variables.sizePolicy().hasHeightForWidth())
        self.label_variables.setSizePolicy(sizePolicy)
        self.label_variables.setText(_fromUtf8(""))
        self.label_variables.setPixmap(QtGui.QPixmap(_fromUtf8(":/icons/variable_inspector_large.png")))
        self.label_variables.setObjectName(_fromUtf8("label_variables"))
        self.horizontalLayout_3.addWidget(self.label_variables)
        self.label_3 = QtGui.QLabel(self.widget_variable_inspector_header_box)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_3.setFont(font)
        self.label_3.setObjectName(_fromUtf8("label_3"))
        self.horizontalLayout_3.addWidget(self.label_3)
        self.verticalLayout_2.addWidget(self.widget_variable_inspector_header_box)
        self.widget = QtGui.QWidget(self.dock_widget_variable_inspector)
        self.widget.setObjectName(_fromUtf8("widget"))
        self.horizontalLayout_2 = QtGui.QHBoxLayout(self.widget)
        self.horizontalLayout_2.setSpacing(2)
        self.horizontalLayout_2.setMargin(0)
        self.horizontalLayout_2.setObjectName(_fromUtf8("horizontalLayout_2"))
        self.label_variables_search = QtGui.QLabel(self.widget)
        self.label_variables_search.setText(_fromUtf8(""))
        self.label_variables_search.setObjectName(_fromUtf8("label_variables_search"))
        self.horizontalLayout_2.addWidget(self.label_variables_search)
        self.edit_variable_filter = QtGui.QLineEdit(self.widget)
        self.edit_variable_filter.setObjectName(_fromUtf8("edit_variable_filter"))
        self.horizontalLayout_2.addWidget(self.edit_variable_filter)
        self.button_variables_clear = QtGui.QPushButton(self.widget)
        self.button_variables_clear.setText(_fromUtf8(""))
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/clear.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_variables_clear.setIcon(icon2)
        self.button_variables_clear.setIconSize(QtCore.QSize(16, 16))
        self.button_variables_clear.setObjectName(_fromUtf8("button_variables_clear"))
        self.horizontalLayout_2.addWidget(self.button_variables_clear)
        self.button_help_variables = QtGui.QPushButton(self.widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.button_help_variables.sizePolicy().hasHeightForWidth())
        self.button_help_variables.setSizePolicy(sizePolicy)
        self.button_help_variables.setText(_fromUtf8(""))
        icon3 = QtGui.QIcon()
        icon3.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/help.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_help_variables.setIcon(icon3)
        self.button_help_variables.setIconSize(QtCore.QSize(16, 16))
        self.button_help_variables.setFlat(False)
        self.button_help_variables.setObjectName(_fromUtf8("button_help_variables"))
        self.horizontalLayout_2.addWidget(self.button_help_variables)
        self.verticalLayout_2.addWidget(self.widget)
        self.table_variables = variable_inspector(self.dock_widget_variable_inspector)
        self.table_variables.setEditTriggers(QtGui.QAbstractItemView.NoEditTriggers)
        self.table_variables.setAlternatingRowColors(True)
        self.table_variables.setShowGrid(True)
        self.table_variables.setGridStyle(QtCore.Qt.DotLine)
        self.table_variables.setObjectName(_fromUtf8("table_variables"))
        self.table_variables.setColumnCount(3)
        self.table_variables.setRowCount(0)
        item = QtGui.QTableWidgetItem()
        self.table_variables.setHorizontalHeaderItem(0, item)
        item = QtGui.QTableWidgetItem()
        self.table_variables.setHorizontalHeaderItem(1, item)
        item = QtGui.QTableWidgetItem()
        self.table_variables.setHorizontalHeaderItem(2, item)
        self.table_variables.horizontalHeader().setSortIndicatorShown(True)
        self.table_variables.horizontalHeader().setStretchLastSection(True)
        self.table_variables.verticalHeader().setVisible(False)
        self.table_variables.verticalHeader().setCascadingSectionResizes(True)
        self.verticalLayout_2.addWidget(self.table_variables)
        self.dock_variable_inspector.setWidget(self.dock_widget_variable_inspector)
        opensesame_mainwindow.addDockWidget(QtCore.Qt.DockWidgetArea(2), self.dock_variable_inspector)
        self.dock_pool = QtGui.QDockWidget(opensesame_mainwindow)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Maximum, QtGui.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.dock_pool.sizePolicy().hasHeightForWidth())
        self.dock_pool.setSizePolicy(sizePolicy)
        self.dock_pool.setObjectName(_fromUtf8("dock_pool"))
        self.dock_pool_widget = QtGui.QWidget()
        self.dock_pool_widget.setObjectName(_fromUtf8("dock_pool_widget"))
        self.verticalLayout_3 = QtGui.QVBoxLayout(self.dock_pool_widget)
        self.verticalLayout_3.setObjectName(_fromUtf8("verticalLayout_3"))
        self.dock_pool.setWidget(self.dock_pool_widget)
        opensesame_mainwindow.addDockWidget(QtCore.Qt.DockWidgetArea(2), self.dock_pool)
        self.dock_stdout = QtGui.QDockWidget(opensesame_mainwindow)
        self.dock_stdout.setFeatures(QtGui.QDockWidget.AllDockWidgetFeatures)
        self.dock_stdout.setObjectName(_fromUtf8("dock_stdout"))
        self.dockWidgetContents_3 = QtGui.QWidget()
        self.dockWidgetContents_3.setObjectName(_fromUtf8("dockWidgetContents_3"))
        self.verticalLayout_4 = QtGui.QVBoxLayout(self.dockWidgetContents_3)
        self.verticalLayout_4.setObjectName(_fromUtf8("verticalLayout_4"))
        self.widget_debug_window_header_box = QtGui.QWidget(self.dockWidgetContents_3)
        self.widget_debug_window_header_box.setObjectName(_fromUtf8("widget_debug_window_header_box"))
        self.horizontalLayout_5 = QtGui.QHBoxLayout(self.widget_debug_window_header_box)
        self.horizontalLayout_5.setSpacing(0)
        self.horizontalLayout_5.setMargin(4)
        self.horizontalLayout_5.setObjectName(_fromUtf8("horizontalLayout_5"))
        self.label_stdout = QtGui.QLabel(self.widget_debug_window_header_box)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_stdout.sizePolicy().hasHeightForWidth())
        self.label_stdout.setSizePolicy(sizePolicy)
        self.label_stdout.setText(_fromUtf8(""))
        self.label_stdout.setPixmap(QtGui.QPixmap(_fromUtf8(":/icons/stdout_large.png")))
        self.label_stdout.setObjectName(_fromUtf8("label_stdout"))
        self.horizontalLayout_5.addWidget(self.label_stdout)
        self.label_4 = QtGui.QLabel(self.widget_debug_window_header_box)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_4.setFont(font)
        self.label_4.setObjectName(_fromUtf8("label_4"))
        self.horizontalLayout_5.addWidget(self.label_4)
        self.verticalLayout_4.addWidget(self.widget_debug_window_header_box)
        self.widget_5 = QtGui.QWidget(self.dockWidgetContents_3)
        self.widget_5.setObjectName(_fromUtf8("widget_5"))
        self.horizontalLayout_6 = QtGui.QHBoxLayout(self.widget_5)
        self.horizontalLayout_6.setMargin(0)
        self.horizontalLayout_6.setObjectName(_fromUtf8("horizontalLayout_6"))
        self.edit_stdout = console(self.widget_5)
        self.edit_stdout.setReadOnly(False)
        self.edit_stdout.setObjectName(_fromUtf8("edit_stdout"))
        self.horizontalLayout_6.addWidget(self.edit_stdout)
        self.widget_3 = QtGui.QWidget(self.widget_5)
        self.widget_3.setObjectName(_fromUtf8("widget_3"))
        self.verticalLayout_5 = QtGui.QVBoxLayout(self.widget_3)
        self.verticalLayout_5.setSpacing(2)
        self.verticalLayout_5.setMargin(0)
        self.verticalLayout_5.setObjectName(_fromUtf8("verticalLayout_5"))
        self.button_help_stdout = QtGui.QPushButton(self.widget_3)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.button_help_stdout.sizePolicy().hasHeightForWidth())
        self.button_help_stdout.setSizePolicy(sizePolicy)
        self.button_help_stdout.setText(_fromUtf8(""))
        self.button_help_stdout.setIcon(icon3)
        self.button_help_stdout.setIconSize(QtCore.QSize(16, 16))
        self.button_help_stdout.setFlat(False)
        self.button_help_stdout.setObjectName(_fromUtf8("button_help_stdout"))
        self.verticalLayout_5.addWidget(self.button_help_stdout)
        self.button_clear_stdout = QtGui.QPushButton(self.widget_3)
        self.button_clear_stdout.setText(_fromUtf8(""))
        self.button_clear_stdout.setIcon(icon2)
        self.button_clear_stdout.setIconSize(QtCore.QSize(16, 16))
        self.button_clear_stdout.setObjectName(_fromUtf8("button_clear_stdout"))
        self.verticalLayout_5.addWidget(self.button_clear_stdout)
        spacerItem = QtGui.QSpacerItem(20, 40, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)
        self.verticalLayout_5.addItem(spacerItem)
        self.horizontalLayout_6.addWidget(self.widget_3)
        self.verticalLayout_4.addWidget(self.widget_5)
        self.dock_stdout.setWidget(self.dockWidgetContents_3)
        opensesame_mainwindow.addDockWidget(QtCore.Qt.DockWidgetArea(8), self.dock_stdout)
        self.toolbar_main = QtGui.QToolBar(opensesame_mainwindow)
        self.toolbar_main.setIconSize(QtCore.QSize(32, 32))
        self.toolbar_main.setToolButtonStyle(QtCore.Qt.ToolButtonIconOnly)
        self.toolbar_main.setFloatable(True)
        self.toolbar_main.setObjectName(_fromUtf8("toolbar_main"))
        opensesame_mainwindow.addToolBar(QtCore.Qt.TopToolBarArea, self.toolbar_main)
        self.toolbar_items = toolbar_items(opensesame_mainwindow)
        self.toolbar_items.setObjectName(_fromUtf8("toolbar_items"))
        opensesame_mainwindow.addToolBar(QtCore.Qt.LeftToolBarArea, self.toolbar_items)
        self.action_open = QtGui.QAction(opensesame_mainwindow)
        icon4 = QtGui.QIcon()
        icon4.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/open_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_open.setIcon(icon4)
        self.action_open.setObjectName(_fromUtf8("action_open"))
        self.action_save = QtGui.QAction(opensesame_mainwindow)
        icon5 = QtGui.QIcon()
        icon5.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/save_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_save.setIcon(icon5)
        self.action_save.setObjectName(_fromUtf8("action_save"))
        self.action_save_as = QtGui.QAction(opensesame_mainwindow)
        icon6 = QtGui.QIcon()
        icon6.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/saveas_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_save_as.setIcon(icon6)
        self.action_save_as.setObjectName(_fromUtf8("action_save_as"))
        self.action_quit = QtGui.QAction(opensesame_mainwindow)
        icon7 = QtGui.QIcon()
        icon7.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/quit_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_quit.setIcon(icon7)
        self.action_quit.setObjectName(_fromUtf8("action_quit"))
        self.action_run = QtGui.QAction(opensesame_mainwindow)
        self.action_run.setObjectName(_fromUtf8("action_run"))
        self.action_new = QtGui.QAction(opensesame_mainwindow)
        icon8 = QtGui.QIcon()
        icon8.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/new_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_new.setIcon(icon8)
        self.action_new.setObjectName(_fromUtf8("action_new"))
        self.action_add_sequence = QtGui.QAction(opensesame_mainwindow)
        icon9 = QtGui.QIcon()
        icon9.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/sequence_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_add_sequence.setIcon(icon9)
        self.action_add_sequence.setObjectName(_fromUtf8("action_add_sequence"))
        self.action_add_sketchpad = QtGui.QAction(opensesame_mainwindow)
        icon10 = QtGui.QIcon()
        icon10.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/sketchpad_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_add_sketchpad.setIcon(icon10)
        self.action_add_sketchpad.setObjectName(_fromUtf8("action_add_sketchpad"))
        self.action_add_keyboard_response = QtGui.QAction(opensesame_mainwindow)
        icon11 = QtGui.QIcon()
        icon11.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/keyboard_response_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_add_keyboard_response.setIcon(icon11)
        self.action_add_keyboard_response.setObjectName(_fromUtf8("action_add_keyboard_response"))
        self.action_add_logger = QtGui.QAction(opensesame_mainwindow)
        icon12 = QtGui.QIcon()
        icon12.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/logger_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_add_logger.setIcon(icon12)
        self.action_add_logger.setObjectName(_fromUtf8("action_add_logger"))
        self.action_add_loop = QtGui.QAction(opensesame_mainwindow)
        icon13 = QtGui.QIcon()
        icon13.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/loop_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_add_loop.setIcon(icon13)
        self.action_add_loop.setObjectName(_fromUtf8("action_add_loop"))
        self.action_add_feedback = QtGui.QAction(opensesame_mainwindow)
        icon14 = QtGui.QIcon()
        icon14.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/feedback_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_add_feedback.setIcon(icon14)
        self.action_add_feedback.setObjectName(_fromUtf8("action_add_feedback"))
        self.action_add_inline_script = QtGui.QAction(opensesame_mainwindow)
        icon15 = QtGui.QIcon()
        icon15.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/inline_script_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_add_inline_script.setIcon(icon15)
        self.action_add_inline_script.setObjectName(_fromUtf8("action_add_inline_script"))
        self.action_close_all_tabs = QtGui.QAction(opensesame_mainwindow)
        icon16 = QtGui.QIcon()
        icon16.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/closeothertabs_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_close_all_tabs.setIcon(icon16)
        self.action_close_all_tabs.setObjectName(_fromUtf8("action_close_all_tabs"))
        self.action_close_other_tabs = QtGui.QAction(opensesame_mainwindow)
        icon17 = QtGui.QIcon()
        icon17.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/close_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_close_other_tabs.setIcon(icon17)
        self.action_close_other_tabs.setObjectName(_fromUtf8("action_close_other_tabs"))
        self.action_help = QtGui.QAction(opensesame_mainwindow)
        icon18 = QtGui.QIcon()
        icon18.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/help_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_help.setIcon(icon18)
        self.action_help.setObjectName(_fromUtf8("action_help"))
        self.action_about = QtGui.QAction(opensesame_mainwindow)
        icon19 = QtGui.QIcon()
        icon19.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/about_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_about.setIcon(icon19)
        self.action_about.setObjectName(_fromUtf8("action_about"))
        self.action_add_mouse_response = QtGui.QAction(opensesame_mainwindow)
        icon20 = QtGui.QIcon()
        icon20.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/mouse_response_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_add_mouse_response.setIcon(icon20)
        self.action_add_mouse_response.setObjectName(_fromUtf8("action_add_mouse_response"))
        self.action_run_in_window = QtGui.QAction(opensesame_mainwindow)
        self.action_run_in_window.setObjectName(_fromUtf8("action_run_in_window"))
        self.action_check_for_update = QtGui.QAction(opensesame_mainwindow)
        icon21 = QtGui.QIcon()
        icon21.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/update_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_check_for_update.setIcon(icon21)
        self.action_check_for_update.setObjectName(_fromUtf8("action_check_for_update"))
        self.action_show_variable_inspector = QtGui.QAction(opensesame_mainwindow)
        self.action_show_variable_inspector.setCheckable(True)
        icon22 = QtGui.QIcon()
        icon22.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/variable_inspector_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_show_variable_inspector.setIcon(icon22)
        self.action_show_variable_inspector.setObjectName(_fromUtf8("action_show_variable_inspector"))
        self.action_add_sampler = QtGui.QAction(opensesame_mainwindow)
        icon23 = QtGui.QIcon()
        icon23.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/sampler_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_add_sampler.setIcon(icon23)
        self.action_add_sampler.setObjectName(_fromUtf8("action_add_sampler"))
        self.action_add_synth = QtGui.QAction(opensesame_mainwindow)
        icon24 = QtGui.QIcon()
        icon24.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/synth_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_add_synth.setIcon(icon24)
        self.action_add_synth.setObjectName(_fromUtf8("action_add_synth"))
        self.action_show_pool = QtGui.QAction(opensesame_mainwindow)
        self.action_show_pool.setCheckable(True)
        icon25 = QtGui.QIcon()
        icon25.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/pool_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_show_pool.setIcon(icon25)
        self.action_show_pool.setObjectName(_fromUtf8("action_show_pool"))
        self.action_show_stdout = QtGui.QAction(opensesame_mainwindow)
        self.action_show_stdout.setCheckable(True)
        icon26 = QtGui.QIcon()
        icon26.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/stdout_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_show_stdout.setIcon(icon26)
        self.action_show_stdout.setObjectName(_fromUtf8("action_show_stdout"))
        self.action_enable_auto_response = QtGui.QAction(opensesame_mainwindow)
        self.action_enable_auto_response.setCheckable(True)
        self.action_enable_auto_response.setObjectName(_fromUtf8("action_enable_auto_response"))
        self.actionPlugins = QtGui.QAction(opensesame_mainwindow)
        self.actionPlugins.setEnabled(False)
        self.actionPlugins.setObjectName(_fromUtf8("actionPlugins"))
        self.action_show_random_tip = QtGui.QAction(opensesame_mainwindow)
        self.action_show_random_tip.setIcon(icon19)
        self.action_show_random_tip.setObjectName(_fromUtf8("action_show_random_tip"))
        self.action_open_autosave_folder = QtGui.QAction(opensesame_mainwindow)
        self.action_open_autosave_folder.setIcon(icon25)
        self.action_open_autosave_folder.setObjectName(_fromUtf8("action_open_autosave_folder"))
        self.action_submit_a_bug = QtGui.QAction(opensesame_mainwindow)
        icon27 = QtGui.QIcon()
        icon27.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/submit_bug.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_submit_a_bug.setIcon(icon27)
        self.action_submit_a_bug.setObjectName(_fromUtf8("action_submit_a_bug"))
        self.action_contribute = QtGui.QAction(opensesame_mainwindow)
        icon28 = QtGui.QIcon()
        icon28.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/contribute.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_contribute.setIcon(icon28)
        self.action_contribute.setObjectName(_fromUtf8("action_contribute"))
        self.action_preferences = QtGui.QAction(opensesame_mainwindow)
        icon29 = QtGui.QIcon()
        icon29.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/options_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_preferences.setIcon(icon29)
        self.action_preferences.setObjectName(_fromUtf8("action_preferences"))
        self.actionDummy = QtGui.QAction(opensesame_mainwindow)
        self.actionDummy.setObjectName(_fromUtf8("actionDummy"))
        self.action_show_overview = QtGui.QAction(opensesame_mainwindow)
        self.action_show_overview.setCheckable(True)
        self.action_show_overview.setObjectName(_fromUtf8("action_show_overview"))
        self.action_onetabmode = QtGui.QAction(opensesame_mainwindow)
        self.action_onetabmode.setCheckable(True)
        icon30 = QtGui.QIcon()
        icon30.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/onetabmode_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.action_onetabmode.setIcon(icon30)
        self.action_onetabmode.setObjectName(_fromUtf8("action_onetabmode"))
        self.action_compact_toolbar = QtGui.QAction(opensesame_mainwindow)
        self.action_compact_toolbar.setCheckable(True)
        self.action_compact_toolbar.setObjectName(_fromUtf8("action_compact_toolbar"))
        self.action_online_documentation = QtGui.QAction(opensesame_mainwindow)
        self.action_online_documentation.setObjectName(_fromUtf8("action_online_documentation"))
        self.action_online_forum = QtGui.QAction(opensesame_mainwindow)
        self.action_online_forum.setObjectName(_fromUtf8("action_online_forum"))
        self.action_run_quick = QtGui.QAction(opensesame_mainwindow)
        self.action_run_quick.setObjectName(_fromUtf8("action_run_quick"))
        self.menu_recent_files.addAction(self.actionDummy)
        self.menu_file.addAction(self.action_new)
        self.menu_file.addAction(self.action_open)
        self.menu_file.addAction(self.action_save)
        self.menu_file.addAction(self.action_save_as)
        self.menu_file.addSeparator()
        self.menu_file.addAction(self.menu_recent_files.menuAction())
        self.menu_file.addSeparator()
        self.menu_file.addAction(self.action_quit)
        self.menu_run.addAction(self.action_run)
        self.menu_run.addAction(self.action_run_in_window)
        self.menu_run.addAction(self.action_run_quick)
        self.menu_run.addSeparator()
        self.menu_run.addAction(self.action_enable_auto_response)
        self.menu_items.addAction(self.action_add_loop)
        self.menu_items.addAction(self.action_add_sequence)
        self.menu_items.addAction(self.action_add_sketchpad)
        self.menu_items.addAction(self.action_add_feedback)
        self.menu_items.addAction(self.action_add_sampler)
        self.menu_items.addAction(self.action_add_synth)
        self.menu_items.addAction(self.action_add_keyboard_response)
        self.menu_items.addAction(self.action_add_mouse_response)
        self.menu_items.addAction(self.action_add_logger)
        self.menu_items.addAction(self.action_add_inline_script)
        self.menu_items.addSeparator()
        self.menu_items.addAction(self.actionPlugins)
        self.menu_view.addAction(self.action_close_all_tabs)
        self.menu_view.addAction(self.action_close_other_tabs)
        self.menu_view.addAction(self.action_onetabmode)
        self.menu_view.addSeparator()
        self.menu_view.addAction(self.action_show_overview)
        self.menu_view.addAction(self.action_show_variable_inspector)
        self.menu_view.addAction(self.action_show_pool)
        self.menu_view.addAction(self.action_show_stdout)
        self.menu_help.addAction(self.action_online_documentation)
        self.menu_help.addAction(self.action_help)
        self.menu_help.addSeparator()
        self.menu_help.addAction(self.action_about)
        self.menu_tools.addAction(self.action_check_for_update)
        self.menu_tools.addAction(self.action_open_autosave_folder)
        self.menu_tools.addSeparator()
        self.menu_tools.addAction(self.action_preferences)
        self.menubar.addAction(self.menu_file.menuAction())
        self.menubar.addAction(self.menu_run.menuAction())
        self.menubar.addAction(self.menu_items.menuAction())
        self.menubar.addAction(self.menu_view.menuAction())
        self.menubar.addAction(self.menu_tools.menuAction())
        self.menubar.addAction(self.menu_help.menuAction())
        self.toolbar_main.addAction(self.action_new)
        self.toolbar_main.addAction(self.action_open)
        self.toolbar_main.addAction(self.action_save)
        self.toolbar_main.addSeparator()
        self.toolbar_main.addAction(self.action_run)
        self.toolbar_main.addAction(self.action_run_in_window)
        self.toolbar_main.addAction(self.action_run_quick)
        self.toolbar_main.addSeparator()
        self.toolbar_main.addAction(self.action_close_other_tabs)
        self.toolbar_main.addAction(self.action_onetabmode)
        self.toolbar_main.addSeparator()
        self.toolbar_main.addAction(self.action_show_pool)
        self.toolbar_main.addAction(self.action_show_variable_inspector)
        self.toolbar_main.addAction(self.action_show_stdout)
        self.toolbar_main.addSeparator()
        self.toolbar_main.addAction(self.action_help)
        self.toolbar_main.addAction(self.action_online_documentation)

        self.retranslateUi(opensesame_mainwindow)
        self.tabwidget.setCurrentIndex(-1)
        QtCore.QObject.connect(self.button_variables_clear, QtCore.SIGNAL(_fromUtf8("clicked()")), self.edit_variable_filter.clear)
        QtCore.QObject.connect(self.button_clear_stdout, QtCore.SIGNAL(_fromUtf8("clicked()")), self.edit_stdout.clear)
        QtCore.QMetaObject.connectSlotsByName(opensesame_mainwindow)

    def retranslateUi(self, opensesame_mainwindow):
        opensesame_mainwindow.setWindowTitle(_translate("opensesame_mainwindow", "OpenSesame", None))
        self.menu_file.setTitle(_translate("opensesame_mainwindow", "File", None))
        self.menu_recent_files.setTitle(_translate("opensesame_mainwindow", "Recent files", None))
        self.menu_run.setTitle(_translate("opensesame_mainwindow", "Run", None))
        self.menu_items.setTitle(_translate("opensesame_mainwindow", "Items", None))
        self.menu_view.setTitle(_translate("opensesame_mainwindow", "View", None))
        self.menu_help.setTitle(_translate("opensesame_mainwindow", "Help", None))
        self.menu_tools.setTitle(_translate("opensesame_mainwindow", "Tools", None))
        self.dock_overview.setWindowTitle(_translate("opensesame_mainwindow", "Overview", None))
        self.itemtree.headerItem().setText(0, _translate("opensesame_mainwindow", "Name", None))
        self.dock_variable_inspector.setWindowTitle(_translate("opensesame_mainwindow", "Variable inspector", None))
        self.label_3.setText(_translate("opensesame_mainwindow", "Variable inspector", None))
        self.edit_variable_filter.setToolTip(_translate("opensesame_mainwindow", "Enter a filter", None))
        self.button_variables_clear.setToolTip(_translate("opensesame_mainwindow", "Clear filter", None))
        self.button_help_variables.setToolTip(_translate("opensesame_mainwindow", "Help", None))
        self.table_variables.setSortingEnabled(True)
        item = self.table_variables.horizontalHeaderItem(0)
        item.setText(_translate("opensesame_mainwindow", "Variable", None))
        item = self.table_variables.horizontalHeaderItem(1)
        item.setText(_translate("opensesame_mainwindow", "Value", None))
        item = self.table_variables.horizontalHeaderItem(2)
        item.setText(_translate("opensesame_mainwindow", "In item", None))
        self.dock_pool.setWindowTitle(_translate("opensesame_mainwindow", "File pool", None))
        self.dock_stdout.setWindowTitle(_translate("opensesame_mainwindow", "Debug window", None))
        self.label_4.setText(_translate("opensesame_mainwindow", "Debug window", None))
        self.button_help_stdout.setToolTip(_translate("opensesame_mainwindow", "Help", None))
        self.button_clear_stdout.setToolTip(_translate("opensesame_mainwindow", "Clear debug window", None))
        self.toolbar_main.setWindowTitle(_translate("opensesame_mainwindow", "Main toolbar", None))
        self.toolbar_items.setWindowTitle(_translate("opensesame_mainwindow", "Toolbar items", None))
        self.action_open.setText(_translate("opensesame_mainwindow", "Open", None))
        self.action_open.setToolTip(_translate("opensesame_mainwindow", "Open (Ctrl+0)", None))
        self.action_open.setShortcut(_translate("opensesame_mainwindow", "Ctrl+O", None))
        self.action_save.setText(_translate("opensesame_mainwindow", "Save", None))
        self.action_save.setToolTip(_translate("opensesame_mainwindow", "Save (Control+S)", None))
        self.action_save.setShortcut(_translate("opensesame_mainwindow", "Ctrl+S", None))
        self.action_save_as.setText(_translate("opensesame_mainwindow", "Save as", None))
        self.action_save_as.setToolTip(_translate("opensesame_mainwindow", "Save as (Control+Shift+S)", None))
        self.action_save_as.setShortcut(_translate("opensesame_mainwindow", "Ctrl+Shift+S", None))
        self.action_quit.setText(_translate("opensesame_mainwindow", "Quit", None))
        self.action_quit.setToolTip(_translate("opensesame_mainwindow", "Quit (Alt+F4)", None))
        self.action_run.setText(_translate("opensesame_mainwindow", "Run fullscreen", None))
        self.action_run.setToolTip(_translate("opensesame_mainwindow", "Run fullscreen (Control+R)", None))
        self.action_run.setShortcut(_translate("opensesame_mainwindow", "Ctrl+R", None))
        self.action_new.setText(_translate("opensesame_mainwindow", "New", None))
        self.action_new.setToolTip(_translate("opensesame_mainwindow", "New (Control+N)", None))
        self.action_new.setShortcut(_translate("opensesame_mainwindow", "Ctrl+N", None))
        self.action_add_sequence.setText(_translate("opensesame_mainwindow", "Add sequence", None))
        self.action_add_sketchpad.setText(_translate("opensesame_mainwindow", "Add sketchpad", None))
        self.action_add_keyboard_response.setText(_translate("opensesame_mainwindow", "Add keyboard response", None))
        self.action_add_logger.setText(_translate("opensesame_mainwindow", "Add logger", None))
        self.action_add_loop.setText(_translate("opensesame_mainwindow", "Add loop", None))
        self.action_add_feedback.setText(_translate("opensesame_mainwindow", "Add feedback", None))
        self.action_add_inline_script.setText(_translate("opensesame_mainwindow", "Add inline script", None))
        self.action_close_all_tabs.setText(_translate("opensesame_mainwindow", "Close all tabs", None))
        self.action_close_other_tabs.setText(_translate("opensesame_mainwindow", "Close other tabs", None))
        self.action_close_other_tabs.setToolTip(_translate("opensesame_mainwindow", "Close other tabs (Control+T)", None))
        self.action_close_other_tabs.setShortcut(_translate("opensesame_mainwindow", "Ctrl+T", None))
        self.action_help.setText(_translate("opensesame_mainwindow", "Offline help", None))
        self.action_about.setText(_translate("opensesame_mainwindow", "About", None))
        self.action_add_mouse_response.setText(_translate("opensesame_mainwindow", "Add mouse response", None))
        self.action_run_in_window.setText(_translate("opensesame_mainwindow", "Run in window", None))
        self.action_run_in_window.setToolTip(_translate("opensesame_mainwindow", "Run in window (Control+W)", None))
        self.action_run_in_window.setShortcut(_translate("opensesame_mainwindow", "Ctrl+W", None))
        self.action_check_for_update.setText(_translate("opensesame_mainwindow", "Check for updates", None))
        self.action_show_variable_inspector.setText(_translate("opensesame_mainwindow", "Show variable inspector", None))
        self.action_show_variable_inspector.setToolTip(_translate("opensesame_mainwindow", "Show variable inspector (Control+I)", None))
        self.action_show_variable_inspector.setShortcut(_translate("opensesame_mainwindow", "Ctrl+I", None))
        self.action_add_sampler.setText(_translate("opensesame_mainwindow", "Add sampler", None))
        self.action_add_sampler.setToolTip(_translate("opensesame_mainwindow", "Add sound sampler", None))
        self.action_add_synth.setText(_translate("opensesame_mainwindow", "Add synth", None))
        self.action_add_synth.setToolTip(_translate("opensesame_mainwindow", "Add sound synthesizer", None))
        self.action_show_pool.setText(_translate("opensesame_mainwindow", "Show file pool", None))
        self.action_show_pool.setShortcut(_translate("opensesame_mainwindow", "Ctrl+P", None))
        self.action_show_stdout.setText(_translate("opensesame_mainwindow", "Show debug window", None))
        self.action_show_stdout.setToolTip(_translate("opensesame_mainwindow", "Show debug window (standard output) and a Python interpreter (Control+D)", None))
        self.action_show_stdout.setShortcut(_translate("opensesame_mainwindow", "Ctrl+D", None))
        self.action_enable_auto_response.setText(_translate("opensesame_mainwindow", "Enable auto response", None))
        self.actionPlugins.setText(_translate("opensesame_mainwindow", "Plugins", None))
        self.action_show_random_tip.setText(_translate("opensesame_mainwindow", "Random tip", None))
        self.action_show_random_tip.setToolTip(_translate("opensesame_mainwindow", "Show a random tip", None))
        self.action_open_autosave_folder.setText(_translate("opensesame_mainwindow", "Open backup folder", None))
        self.action_submit_a_bug.setText(_translate("opensesame_mainwindow", "Submit a bug", None))
        self.action_contribute.setText(_translate("opensesame_mainwindow", "Contribute", None))
        self.action_preferences.setText(_translate("opensesame_mainwindow", "Preferences", None))
        self.actionDummy.setText(_translate("opensesame_mainwindow", "Dummy", None))
        self.action_show_overview.setText(_translate("opensesame_mainwindow", "Show overview area", None))
        self.action_show_overview.setShortcut(_translate("opensesame_mainwindow", "Ctrl+Shift+O", None))
        self.action_onetabmode.setText(_translate("opensesame_mainwindow", "One tab mode", None))
        self.action_onetabmode.setToolTip(_translate("opensesame_mainwindow", "Enable one tab mode", None))
        self.action_compact_toolbar.setText(_translate("opensesame_mainwindow", "Compact toolbar", None))
        self.action_online_documentation.setText(_translate("opensesame_mainwindow", "Online help", None))
        self.action_online_forum.setText(_translate("opensesame_mainwindow", "Online forum", None))
        self.action_run_quick.setText(_translate("opensesame_mainwindow", "Quick run", None))
        self.action_run_quick.setToolTip(_translate("opensesame_mainwindow", "Give your experiment a quick test run", None))
        self.action_run_quick.setShortcut(_translate("opensesame_mainwindow", "Ctrl+Shift+W", None))

from libqtopensesame.widgets.statusbar import statusbar
from libqtopensesame.widgets.tree_overview import tree_overview
from libqtopensesame.widgets.tab_widget import tab_widget
from libqtopensesame.widgets.variable_inspector import variable_inspector
from libqtopensesame.widgets.toolbar_items import toolbar_items
from libqtopensesame.widgets.pyterm import console

########NEW FILE########
__FILENAME__ = pool_widget_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/pool_widget.ui'
#
# Created: Thu Aug  2 12:43:05 2012
#      by: PyQt4 UI code generator 4.9.1
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_pool_widget(object):
    def setupUi(self, pool_widget):
        pool_widget.setObjectName(_fromUtf8("pool_widget"))
        pool_widget.resize(355, 291)
        pool_widget.setAcceptDrops(True)
        self.verticalLayout = QtGui.QVBoxLayout(pool_widget)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.widget_header_box = QtGui.QWidget(pool_widget)
        self.widget_header_box.setObjectName(_fromUtf8("widget_header_box"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget_header_box)
        self.horizontalLayout.setSpacing(0)
        self.horizontalLayout.setMargin(4)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.label_pool = QtGui.QLabel(self.widget_header_box)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_pool.sizePolicy().hasHeightForWidth())
        self.label_pool.setSizePolicy(sizePolicy)
        self.label_pool.setPixmap(QtGui.QPixmap(_fromUtf8(":/icons/pool_large.png")))
        self.label_pool.setObjectName(_fromUtf8("label_pool"))
        self.horizontalLayout.addWidget(self.label_pool)
        self.label_3 = QtGui.QLabel(self.widget_header_box)
        self.label_3.setObjectName(_fromUtf8("label_3"))
        self.horizontalLayout.addWidget(self.label_3)
        self.verticalLayout.addWidget(self.widget_header_box)
        self.widget_pool = QtGui.QWidget(pool_widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_pool.sizePolicy().hasHeightForWidth())
        self.widget_pool.setSizePolicy(sizePolicy)
        self.widget_pool.setObjectName(_fromUtf8("widget_pool"))
        self.horizontalLayout_3 = QtGui.QHBoxLayout(self.widget_pool)
        self.horizontalLayout_3.setSpacing(2)
        self.horizontalLayout_3.setMargin(0)
        self.horizontalLayout_3.setMargin(0)
        self.horizontalLayout_3.setObjectName(_fromUtf8("horizontalLayout_3"))
        self.label_pool_search = QtGui.QLabel(self.widget_pool)
        self.label_pool_search.setText(_fromUtf8(""))
        self.label_pool_search.setPixmap(QtGui.QPixmap(_fromUtf8(":/icons/variable_inspector.png")))
        self.label_pool_search.setObjectName(_fromUtf8("label_pool_search"))
        self.horizontalLayout_3.addWidget(self.label_pool_search)
        self.edit_pool_filter = QtGui.QLineEdit(self.widget_pool)
        self.edit_pool_filter.setObjectName(_fromUtf8("edit_pool_filter"))
        self.horizontalLayout_3.addWidget(self.edit_pool_filter)
        self.button_pool_filter_clear = QtGui.QPushButton(self.widget_pool)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.button_pool_filter_clear.sizePolicy().hasHeightForWidth())
        self.button_pool_filter_clear.setSizePolicy(sizePolicy)
        self.button_pool_filter_clear.setText(_fromUtf8(""))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/clear.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_pool_filter_clear.setIcon(icon)
        self.button_pool_filter_clear.setIconSize(QtCore.QSize(16, 16))
        self.button_pool_filter_clear.setObjectName(_fromUtf8("button_pool_filter_clear"))
        self.horizontalLayout_3.addWidget(self.button_pool_filter_clear)
        self.button_help_pool = QtGui.QPushButton(self.widget_pool)
        self.button_help_pool.setText(_fromUtf8(""))
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/help.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_help_pool.setIcon(icon1)
        self.button_help_pool.setIconSize(QtCore.QSize(16, 16))
        self.button_help_pool.setObjectName(_fromUtf8("button_help_pool"))
        self.horizontalLayout_3.addWidget(self.button_help_pool)
        self.verticalLayout.addWidget(self.widget_pool)
        self.widget_2 = QtGui.QWidget(pool_widget)
        self.widget_2.setObjectName(_fromUtf8("widget_2"))
        self.horizontalLayout_2 = QtGui.QHBoxLayout(self.widget_2)
        self.horizontalLayout_2.setMargin(0)
        self.horizontalLayout_2.setMargin(0)
        self.horizontalLayout_2.setObjectName(_fromUtf8("horizontalLayout_2"))
        self.button_pool_add = QtGui.QPushButton(self.widget_2)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.button_pool_add.sizePolicy().hasHeightForWidth())
        self.button_pool_add.setSizePolicy(sizePolicy)
        self.button_pool_add.setText(_fromUtf8(""))
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/add.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_pool_add.setIcon(icon2)
        self.button_pool_add.setIconSize(QtCore.QSize(16, 16))
        self.button_pool_add.setObjectName(_fromUtf8("button_pool_add"))
        self.horizontalLayout_2.addWidget(self.button_pool_add)
        self.button_refresh = QtGui.QPushButton(self.widget_2)
        self.button_refresh.setText(_fromUtf8(""))
        icon3 = QtGui.QIcon()
        icon3.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/refresh.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_refresh.setIcon(icon3)
        self.button_refresh.setIconSize(QtCore.QSize(16, 16))
        self.button_refresh.setObjectName(_fromUtf8("button_refresh"))
        self.horizontalLayout_2.addWidget(self.button_refresh)
        self.button_browse_pool = QtGui.QPushButton(self.widget_2)
        self.button_browse_pool.setText(_fromUtf8(""))
        icon4 = QtGui.QIcon()
        icon4.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/browse.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_browse_pool.setIcon(icon4)
        self.button_browse_pool.setIconSize(QtCore.QSize(16, 16))
        self.button_browse_pool.setObjectName(_fromUtf8("button_browse_pool"))
        self.horizontalLayout_2.addWidget(self.button_browse_pool)
        self.combobox_view = QtGui.QComboBox(self.widget_2)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.combobox_view.sizePolicy().hasHeightForWidth())
        self.combobox_view.setSizePolicy(sizePolicy)
        self.combobox_view.setObjectName(_fromUtf8("combobox_view"))
        icon5 = QtGui.QIcon()
        icon5.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/variable_inspector.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.combobox_view.addItem(icon5, _fromUtf8(""))
        self.combobox_view.addItem(icon5, _fromUtf8(""))
        self.horizontalLayout_2.addWidget(self.combobox_view)
        self.verticalLayout.addWidget(self.widget_2)
        self.list_pool = QtGui.QListWidget(pool_widget)
        self.list_pool.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)
        self.list_pool.setAcceptDrops(True)
        self.list_pool.setAlternatingRowColors(True)
        self.list_pool.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)
        self.list_pool.setViewMode(QtGui.QListView.ListMode)
        self.list_pool.setUniformItemSizes(True)
        self.list_pool.setWordWrap(True)
        self.list_pool.setSelectionRectVisible(True)
        self.list_pool.setObjectName(_fromUtf8("list_pool"))
        self.verticalLayout.addWidget(self.list_pool)

        self.retranslateUi(pool_widget)
        QtCore.QObject.connect(self.button_pool_filter_clear, QtCore.SIGNAL(_fromUtf8("clicked()")), self.edit_pool_filter.clear)
        QtCore.QMetaObject.connectSlotsByName(pool_widget)

    def retranslateUi(self, pool_widget):
        pool_widget.setWindowTitle(QtGui.QApplication.translate("pool_widget", "Form", None, QtGui.QApplication.UnicodeUTF8))
        self.label_pool.setText(QtGui.QApplication.translate("pool_widget", "ICON", None, QtGui.QApplication.UnicodeUTF8))
        self.label_3.setText(QtGui.QApplication.translate("pool_widget", "<b>File pool</b><br /><small><i>You can drag and drop files into the pool</i></small>", None, QtGui.QApplication.UnicodeUTF8))
        self.edit_pool_filter.setToolTip(QtGui.QApplication.translate("pool_widget", "Enter a filter", None, QtGui.QApplication.UnicodeUTF8))
        self.button_pool_filter_clear.setToolTip(QtGui.QApplication.translate("pool_widget", "Clear filter", None, QtGui.QApplication.UnicodeUTF8))
        self.button_help_pool.setToolTip(QtGui.QApplication.translate("pool_widget", "Help", None, QtGui.QApplication.UnicodeUTF8))
        self.button_pool_add.setToolTip(QtGui.QApplication.translate("pool_widget", "Add file", None, QtGui.QApplication.UnicodeUTF8))
        self.button_browse_pool.setToolTip(QtGui.QApplication.translate("pool_widget", "Open file pool in file manager", None, QtGui.QApplication.UnicodeUTF8))
        self.combobox_view.setItemText(0, QtGui.QApplication.translate("pool_widget", "View as list", None, QtGui.QApplication.UnicodeUTF8))
        self.combobox_view.setItemText(1, QtGui.QApplication.translate("pool_widget", "View as icons", None, QtGui.QApplication.UnicodeUTF8))
        self.list_pool.setSortingEnabled(True)


########NEW FILE########
__FILENAME__ = preferences_widget_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/preferences_widget.ui'
#
# Created: Tue Nov 26 13:40:32 2013
#      by: PyQt4 UI code generator 4.10.3
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_preferences_widget(object):
    def setupUi(self, preferences_widget):
        preferences_widget.setObjectName(_fromUtf8("preferences_widget"))
        preferences_widget.resize(834, 842)
        self.verticalLayout = QtGui.QVBoxLayout(preferences_widget)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.scrollArea = QtGui.QScrollArea(preferences_widget)
        self.scrollArea.setWidgetResizable(True)
        self.scrollArea.setObjectName(_fromUtf8("scrollArea"))
        self.scrollAreaWidgetContents = QtGui.QWidget()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 820, 828))
        self.scrollAreaWidgetContents.setObjectName(_fromUtf8("scrollAreaWidgetContents"))
        self.verticalLayout_2 = QtGui.QVBoxLayout(self.scrollAreaWidgetContents)
        self.verticalLayout_2.setObjectName(_fromUtf8("verticalLayout_2"))
        self.groupBox_2 = QtGui.QGroupBox(self.scrollAreaWidgetContents)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.groupBox_2.sizePolicy().hasHeightForWidth())
        self.groupBox_2.setSizePolicy(sizePolicy)
        self.groupBox_2.setObjectName(_fromUtf8("groupBox_2"))
        self.gridLayout_5 = QtGui.QGridLayout(self.groupBox_2)
        self.gridLayout_5.setContentsMargins(0, -1, 0, 0)
        self.gridLayout_5.setObjectName(_fromUtf8("gridLayout_5"))
        self.checkbox_immediately_rename = QtGui.QCheckBox(self.groupBox_2)
        self.checkbox_immediately_rename.setObjectName(_fromUtf8("checkbox_immediately_rename"))
        self.gridLayout_5.addWidget(self.checkbox_immediately_rename, 0, 0, 1, 1)
        self.checkbox_autoresponse = QtGui.QCheckBox(self.groupBox_2)
        self.checkbox_autoresponse.setObjectName(_fromUtf8("checkbox_autoresponse"))
        self.gridLayout_5.addWidget(self.checkbox_autoresponse, 1, 0, 1, 1)
        self.verticalLayout_2.addWidget(self.groupBox_2)
        self.groupBox_5 = QtGui.QGroupBox(self.scrollAreaWidgetContents)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.groupBox_5.sizePolicy().hasHeightForWidth())
        self.groupBox_5.setSizePolicy(sizePolicy)
        self.groupBox_5.setObjectName(_fromUtf8("groupBox_5"))
        self.gridLayout_4 = QtGui.QGridLayout(self.groupBox_5)
        self.gridLayout_4.setContentsMargins(0, 9, 0, 0)
        self.gridLayout_4.setObjectName(_fromUtf8("gridLayout_4"))
        self.label_8 = QtGui.QLabel(self.groupBox_5)
        self.label_8.setWordWrap(True)
        self.label_8.setObjectName(_fromUtf8("label_8"))
        self.gridLayout_4.addWidget(self.label_8, 0, 0, 1, 2)
        self.label_2 = QtGui.QLabel(self.groupBox_5)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.gridLayout_4.addWidget(self.label_2, 1, 0, 1, 1)
        self.combobox_style = QtGui.QComboBox(self.groupBox_5)
        self.combobox_style.setObjectName(_fromUtf8("combobox_style"))
        self.gridLayout_4.addWidget(self.combobox_style, 1, 1, 1, 1)
        self.label_7 = QtGui.QLabel(self.groupBox_5)
        self.label_7.setObjectName(_fromUtf8("label_7"))
        self.gridLayout_4.addWidget(self.label_7, 2, 0, 1, 1)
        self.combobox_theme = QtGui.QComboBox(self.groupBox_5)
        self.combobox_theme.setObjectName(_fromUtf8("combobox_theme"))
        self.gridLayout_4.addWidget(self.combobox_theme, 2, 1, 1, 1)
        self.checkbox_small_toolbar = QtGui.QCheckBox(self.groupBox_5)
        self.checkbox_small_toolbar.setObjectName(_fromUtf8("checkbox_small_toolbar"))
        self.gridLayout_4.addWidget(self.checkbox_small_toolbar, 3, 0, 1, 2)
        self.checkbox_toolbar_text = QtGui.QCheckBox(self.groupBox_5)
        self.checkbox_toolbar_text.setObjectName(_fromUtf8("checkbox_toolbar_text"))
        self.gridLayout_4.addWidget(self.checkbox_toolbar_text, 4, 0, 1, 2)
        self.verticalLayout_2.addWidget(self.groupBox_5)
        self.groupBox = QtGui.QGroupBox(self.scrollAreaWidgetContents)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.groupBox.sizePolicy().hasHeightForWidth())
        self.groupBox.setSizePolicy(sizePolicy)
        self.groupBox.setFlat(False)
        self.groupBox.setObjectName(_fromUtf8("groupBox"))
        self.gridLayout_3 = QtGui.QGridLayout(self.groupBox)
        self.gridLayout_3.setContentsMargins(0, 9, 0, 0)
        self.gridLayout_3.setHorizontalSpacing(6)
        self.gridLayout_3.setObjectName(_fromUtf8("gridLayout_3"))
        self.checkbox_enable_autosave = QtGui.QCheckBox(self.groupBox)
        self.checkbox_enable_autosave.setObjectName(_fromUtf8("checkbox_enable_autosave"))
        self.gridLayout_3.addWidget(self.checkbox_enable_autosave, 0, 0, 1, 1)
        self.label_autosave_interval = QtGui.QLabel(self.groupBox)
        self.label_autosave_interval.setObjectName(_fromUtf8("label_autosave_interval"))
        self.gridLayout_3.addWidget(self.label_autosave_interval, 1, 0, 1, 1)
        self.spinbox_autosave_interval = QtGui.QSpinBox(self.groupBox)
        self.spinbox_autosave_interval.setMinimum(1)
        self.spinbox_autosave_interval.setMaximum(1000)
        self.spinbox_autosave_interval.setSingleStep(10)
        self.spinbox_autosave_interval.setObjectName(_fromUtf8("spinbox_autosave_interval"))
        self.gridLayout_3.addWidget(self.spinbox_autosave_interval, 1, 1, 1, 1)
        self.label_3 = QtGui.QLabel(self.groupBox)
        self.label_3.setObjectName(_fromUtf8("label_3"))
        self.gridLayout_3.addWidget(self.label_3, 2, 0, 1, 1)
        self.spinbox_autosave_max_age = QtGui.QSpinBox(self.groupBox)
        self.spinbox_autosave_max_age.setMinimum(1)
        self.spinbox_autosave_max_age.setMaximum(365)
        self.spinbox_autosave_max_age.setObjectName(_fromUtf8("spinbox_autosave_max_age"))
        self.gridLayout_3.addWidget(self.spinbox_autosave_max_age, 2, 1, 1, 1)
        self.button_browse_autosave = QtGui.QPushButton(self.groupBox)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/browse.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_browse_autosave.setIcon(icon)
        self.button_browse_autosave.setObjectName(_fromUtf8("button_browse_autosave"))
        self.gridLayout_3.addWidget(self.button_browse_autosave, 3, 0, 1, 1)
        self.verticalLayout_2.addWidget(self.groupBox)
        self.groupBox_3 = QtGui.QGroupBox(self.scrollAreaWidgetContents)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.groupBox_3.sizePolicy().hasHeightForWidth())
        self.groupBox_3.setSizePolicy(sizePolicy)
        self.groupBox_3.setObjectName(_fromUtf8("groupBox_3"))
        self.gridLayout_6 = QtGui.QGridLayout(self.groupBox_3)
        self.gridLayout_6.setContentsMargins(0, -1, 0, 0)
        self.gridLayout_6.setObjectName(_fromUtf8("gridLayout_6"))
        self.checkbox_auto_update_check = QtGui.QCheckBox(self.groupBox_3)
        self.checkbox_auto_update_check.setObjectName(_fromUtf8("checkbox_auto_update_check"))
        self.gridLayout_6.addWidget(self.checkbox_auto_update_check, 0, 0, 1, 1)
        self.button_update_check = QtGui.QPushButton(self.groupBox_3)
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/update.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_update_check.setIcon(icon1)
        self.button_update_check.setObjectName(_fromUtf8("button_update_check"))
        self.gridLayout_6.addWidget(self.button_update_check, 1, 0, 1, 1)
        self.verticalLayout_2.addWidget(self.groupBox_3)
        self.groupBox_4 = QtGui.QGroupBox(self.scrollAreaWidgetContents)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.groupBox_4.sizePolicy().hasHeightForWidth())
        self.groupBox_4.setSizePolicy(sizePolicy)
        self.groupBox_4.setObjectName(_fromUtf8("groupBox_4"))
        self.gridLayout = QtGui.QGridLayout(self.groupBox_4)
        self.gridLayout.setContentsMargins(0, 9, 0, 0)
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        self.label = QtGui.QLabel(self.groupBox_4)
        self.label.setWordWrap(True)
        self.label.setObjectName(_fromUtf8("label"))
        self.gridLayout.addWidget(self.label, 0, 0, 1, 2)
        self.combobox_runner = QtGui.QComboBox(self.groupBox_4)
        self.combobox_runner.setObjectName(_fromUtf8("combobox_runner"))
        self.combobox_runner.addItem(_fromUtf8(""))
        self.combobox_runner.addItem(_fromUtf8(""))
        self.combobox_runner.addItem(_fromUtf8(""))
        self.gridLayout.addWidget(self.combobox_runner, 1, 0, 1, 2)
        self.verticalLayout_2.addWidget(self.groupBox_4)
        self.groupBox_6 = QtGui.QGroupBox(self.scrollAreaWidgetContents)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.groupBox_6.sizePolicy().hasHeightForWidth())
        self.groupBox_6.setSizePolicy(sizePolicy)
        self.groupBox_6.setObjectName(_fromUtf8("groupBox_6"))
        self.gridLayout_7 = QtGui.QGridLayout(self.groupBox_6)
        self.gridLayout_7.setContentsMargins(0, 9, 0, 0)
        self.gridLayout_7.setObjectName(_fromUtf8("gridLayout_7"))
        self.label_6 = QtGui.QLabel(self.groupBox_6)
        self.label_6.setObjectName(_fromUtf8("label_6"))
        self.gridLayout_7.addWidget(self.label_6, 0, 0, 1, 1)
        self.edit_plugin_folders = QtGui.QLineEdit(self.groupBox_6)
        self.edit_plugin_folders.setReadOnly(True)
        self.edit_plugin_folders.setObjectName(_fromUtf8("edit_plugin_folders"))
        self.gridLayout_7.addWidget(self.edit_plugin_folders, 0, 1, 1, 1)
        self.widget_plugin_list = QtGui.QWidget(self.groupBox_6)
        self.widget_plugin_list.setObjectName(_fromUtf8("widget_plugin_list"))
        self.layout_plugin_list = QtGui.QVBoxLayout(self.widget_plugin_list)
        self.layout_plugin_list.setMargin(0)
        self.layout_plugin_list.setObjectName(_fromUtf8("layout_plugin_list"))
        self.label_plugin_dummy = QtGui.QLabel(self.widget_plugin_list)
        self.label_plugin_dummy.setObjectName(_fromUtf8("label_plugin_dummy"))
        self.layout_plugin_list.addWidget(self.label_plugin_dummy)
        self.gridLayout_7.addWidget(self.widget_plugin_list, 1, 0, 1, 2)
        self.verticalLayout_2.addWidget(self.groupBox_6)
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.verticalLayout.addWidget(self.scrollArea)

        self.retranslateUi(preferences_widget)
        QtCore.QObject.connect(self.checkbox_enable_autosave, QtCore.SIGNAL(_fromUtf8("toggled(bool)")), self.spinbox_autosave_interval.setEnabled)
        QtCore.QObject.connect(self.checkbox_enable_autosave, QtCore.SIGNAL(_fromUtf8("toggled(bool)")), self.label_autosave_interval.setEnabled)
        QtCore.QMetaObject.connectSlotsByName(preferences_widget)

    def retranslateUi(self, preferences_widget):
        preferences_widget.setWindowTitle(_translate("preferences_widget", "Form", None))
        self.groupBox_2.setTitle(_translate("preferences_widget", "Miscellaneous", None))
        self.checkbox_immediately_rename.setText(_translate("preferences_widget", "Offer to rename new items immediately", None))
        self.checkbox_autoresponse.setText(_translate("preferences_widget", "Enable auto-response", None))
        self.groupBox_5.setTitle(_translate("preferences_widget", "Appearance", None))
        self.label_8.setText(_translate("preferences_widget", "<small><i>Changes take effect the next time you start OpenSesame</i></small>\n"
"", None))
        self.label_2.setText(_translate("preferences_widget", "Interface style", None))
        self.label_7.setText(_translate("preferences_widget", "icon theme", None))
        self.checkbox_small_toolbar.setText(_translate("preferences_widget", "Small icons in toolbar", None))
        self.checkbox_toolbar_text.setText(_translate("preferences_widget", "Show text in toolbar", None))
        self.groupBox.setTitle(_translate("preferences_widget", "Backups", None))
        self.checkbox_enable_autosave.setText(_translate("preferences_widget", "Automatically create backups", None))
        self.label_autosave_interval.setText(_translate("preferences_widget", "Auto-save interval:", None))
        self.spinbox_autosave_interval.setSuffix(_translate("preferences_widget", " minute(s)", None))
        self.spinbox_autosave_interval.setPrefix(_translate("preferences_widget", "every ", None))
        self.label_3.setText(_translate("preferences_widget", "Clean backups after:", None))
        self.spinbox_autosave_max_age.setSuffix(_translate("preferences_widget", " day(s)", None))
        self.button_browse_autosave.setText(_translate("preferences_widget", "Open backup folder", None))
        self.groupBox_3.setTitle(_translate("preferences_widget", "Updates", None))
        self.checkbox_auto_update_check.setText(_translate("preferences_widget", "Check for updates on start-up", None))
        self.button_update_check.setText(_translate("preferences_widget", "Check for updates now", None))
        self.groupBox_4.setTitle(_translate("preferences_widget", "Runner", None))
        self.label.setText(_translate("preferences_widget", "<html><head/><body><p><span style=\" font-size:8pt; font-style:italic;\">The \'runner\' determines how your OpenSesame experiment is executed. For more information, please visit </span><a href=\"http://osdoc.cogsci.nl/miscellaneous/runners\"><span style=\" font-size:8pt; font-style:italic; text-decoration: underline; color:#0057ae;\">http://osdoc.cogsci.nl/miscellaneous/runners</span></a><span style=\" font-size:8pt; font-style:italic;\">.</span></p></body></html>", None))
        self.combobox_runner.setItemText(0, _translate("preferences_widget", "Run experiment in the same process (inprocess)", None))
        self.combobox_runner.setItemText(1, _translate("preferences_widget", "Run experiment in a separate process (multiprocess)", None))
        self.combobox_runner.setItemText(2, _translate("preferences_widget", "Run experiment with opensesamerun (external)", None))
        self.groupBox_6.setTitle(_translate("preferences_widget", "Plug-ins", None))
        self.label_6.setText(_translate("preferences_widget", "Plug-in folders:", None))
        self.label_plugin_dummy.setText(_translate("preferences_widget", "Installed plug-ins (requires restart):", None))


########NEW FILE########
__FILENAME__ = replace_dialog_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/replace_dialog.ui'
#
# Created: Thu Aug  2 12:43:06 2012
#      by: PyQt4 UI code generator 4.9.1
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_replace_dialog(object):
    def setupUi(self, replace_dialog):
        replace_dialog.setObjectName(_fromUtf8("replace_dialog"))
        replace_dialog.resize(409, 111)
        self.verticalLayout = QtGui.QVBoxLayout(replace_dialog)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.widget = QtGui.QWidget(replace_dialog)
        self.widget.setObjectName(_fromUtf8("widget"))
        self.formLayout = QtGui.QFormLayout(self.widget)
        self.formLayout.setMargin(0)
        self.formLayout.setMargin(0)
        self.formLayout.setObjectName(_fromUtf8("formLayout"))
        self.label = QtGui.QLabel(self.widget)
        self.label.setObjectName(_fromUtf8("label"))
        self.formLayout.setWidget(0, QtGui.QFormLayout.LabelRole, self.label)
        self.label_2 = QtGui.QLabel(self.widget)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.formLayout.setWidget(1, QtGui.QFormLayout.LabelRole, self.label_2)
        self.edit_search = QtGui.QLineEdit(self.widget)
        self.edit_search.setObjectName(_fromUtf8("edit_search"))
        self.formLayout.setWidget(0, QtGui.QFormLayout.FieldRole, self.edit_search)
        self.edit_replace = QtGui.QLineEdit(self.widget)
        self.edit_replace.setObjectName(_fromUtf8("edit_replace"))
        self.formLayout.setWidget(1, QtGui.QFormLayout.FieldRole, self.edit_replace)
        self.verticalLayout.addWidget(self.widget)
        self.widget_2 = QtGui.QWidget(replace_dialog)
        self.widget_2.setObjectName(_fromUtf8("widget_2"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget_2)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.button_search = QtGui.QPushButton(self.widget_2)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/search.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_search.setIcon(icon)
        self.button_search.setObjectName(_fromUtf8("button_search"))
        self.horizontalLayout.addWidget(self.button_search)
        self.button_replace = QtGui.QPushButton(self.widget_2)
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/replace.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_replace.setIcon(icon1)
        self.button_replace.setObjectName(_fromUtf8("button_replace"))
        self.horizontalLayout.addWidget(self.button_replace)
        self.button_replace_all = QtGui.QPushButton(self.widget_2)
        self.button_replace_all.setIcon(icon1)
        self.button_replace_all.setObjectName(_fromUtf8("button_replace_all"))
        self.horizontalLayout.addWidget(self.button_replace_all)
        self.button_close = QtGui.QPushButton(self.widget_2)
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/close.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_close.setIcon(icon2)
        self.button_close.setObjectName(_fromUtf8("button_close"))
        self.horizontalLayout.addWidget(self.button_close)
        self.verticalLayout.addWidget(self.widget_2)

        self.retranslateUi(replace_dialog)
        QtCore.QObject.connect(self.button_close, QtCore.SIGNAL(_fromUtf8("clicked()")), replace_dialog.accept)
        QtCore.QMetaObject.connectSlotsByName(replace_dialog)

    def retranslateUi(self, replace_dialog):
        replace_dialog.setWindowTitle(QtGui.QApplication.translate("replace_dialog", "Search/ Replace", None, QtGui.QApplication.UnicodeUTF8))
        self.label.setText(QtGui.QApplication.translate("replace_dialog", "Search for", None, QtGui.QApplication.UnicodeUTF8))
        self.label_2.setText(QtGui.QApplication.translate("replace_dialog", "Replace with", None, QtGui.QApplication.UnicodeUTF8))
        self.edit_search.setToolTip(QtGui.QApplication.translate("replace_dialog", "Search term", None, QtGui.QApplication.UnicodeUTF8))
        self.edit_replace.setToolTip(QtGui.QApplication.translate("replace_dialog", "Replacement term", None, QtGui.QApplication.UnicodeUTF8))
        self.button_search.setToolTip(QtGui.QApplication.translate("replace_dialog", "Search and select a single occurence", None, QtGui.QApplication.UnicodeUTF8))
        self.button_search.setText(QtGui.QApplication.translate("replace_dialog", "Search", None, QtGui.QApplication.UnicodeUTF8))
        self.button_replace.setToolTip(QtGui.QApplication.translate("replace_dialog", "Replace the current selection", None, QtGui.QApplication.UnicodeUTF8))
        self.button_replace.setText(QtGui.QApplication.translate("replace_dialog", "Replace", None, QtGui.QApplication.UnicodeUTF8))
        self.button_replace_all.setToolTip(QtGui.QApplication.translate("replace_dialog", "Replace all occurences", None, QtGui.QApplication.UnicodeUTF8))
        self.button_replace_all.setText(QtGui.QApplication.translate("replace_dialog", "Replace all", None, QtGui.QApplication.UnicodeUTF8))
        self.button_close.setToolTip(QtGui.QApplication.translate("replace_dialog", "Close this dialog", None, QtGui.QApplication.UnicodeUTF8))
        self.button_close.setText(QtGui.QApplication.translate("replace_dialog", "Close", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = sampler_widget_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/sampler_widget.ui'
#
# Created: Thu Mar 14 21:12:06 2013
#      by: PyQt4 UI code generator 4.9.1
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_sampler_widget(object):
    def setupUi(self, sampler_widget):
        sampler_widget.setObjectName(_fromUtf8("sampler_widget"))
        sampler_widget.resize(550, 436)
        self.gridLayout = QtGui.QGridLayout(sampler_widget)
        self.gridLayout.setMargin(0)
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        self.frame_controls = QtGui.QFrame(sampler_widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frame_controls.sizePolicy().hasHeightForWidth())
        self.frame_controls.setSizePolicy(sizePolicy)
        self.frame_controls.setFrameShape(QtGui.QFrame.StyledPanel)
        self.frame_controls.setFrameShadow(QtGui.QFrame.Raised)
        self.frame_controls.setObjectName(_fromUtf8("frame_controls"))
        self.gridLayout_3 = QtGui.QGridLayout(self.frame_controls)
        self.gridLayout_3.setObjectName(_fromUtf8("gridLayout_3"))
        self.label = QtGui.QLabel(self.frame_controls)
        self.label.setObjectName(_fromUtf8("label"))
        self.gridLayout_3.addWidget(self.label, 1, 0, 1, 1)
        self.edit_sample = QtGui.QLineEdit(self.frame_controls)
        self.edit_sample.setObjectName(_fromUtf8("edit_sample"))
        self.gridLayout_3.addWidget(self.edit_sample, 1, 1, 1, 1)
        self.button_browse_sample = QtGui.QPushButton(self.frame_controls)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.button_browse_sample.sizePolicy().hasHeightForWidth())
        self.button_browse_sample.setSizePolicy(sizePolicy)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/browse.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_browse_sample.setIcon(icon)
        self.button_browse_sample.setObjectName(_fromUtf8("button_browse_sample"))
        self.gridLayout_3.addWidget(self.button_browse_sample, 1, 2, 1, 1)
        self.frame = QtGui.QFrame(self.frame_controls)
        self.frame.setMaximumSize(QtCore.QSize(16777215, 140))
        self.frame.setFrameShape(QtGui.QFrame.StyledPanel)
        self.frame.setFrameShadow(QtGui.QFrame.Raised)
        self.frame.setObjectName(_fromUtf8("frame"))
        self.gridLayout_2 = QtGui.QGridLayout(self.frame)
        self.gridLayout_2.setMargin(4)
        self.gridLayout_2.setObjectName(_fromUtf8("gridLayout_2"))
        self.label_7 = QtGui.QLabel(self.frame)
        self.label_7.setAlignment(QtCore.Qt.AlignCenter)
        self.label_7.setObjectName(_fromUtf8("label_7"))
        self.gridLayout_2.addWidget(self.label_7, 0, 0, 1, 1)
        self.dial_volume = QtGui.QDial(self.frame)
        self.dial_volume.setMaximum(100)
        self.dial_volume.setProperty("value", 99)
        self.dial_volume.setNotchTarget(10.0)
        self.dial_volume.setNotchesVisible(True)
        self.dial_volume.setObjectName(_fromUtf8("dial_volume"))
        self.gridLayout_2.addWidget(self.dial_volume, 1, 0, 1, 1)
        self.spin_volume = QtGui.QDoubleSpinBox(self.frame)
        self.spin_volume.setMaximum(100.0)
        self.spin_volume.setSingleStep(100.0)
        self.spin_volume.setObjectName(_fromUtf8("spin_volume"))
        self.gridLayout_2.addWidget(self.spin_volume, 2, 0, 1, 1)
        self.label_8 = QtGui.QLabel(self.frame)
        self.label_8.setAlignment(QtCore.Qt.AlignCenter)
        self.label_8.setObjectName(_fromUtf8("label_8"))
        self.gridLayout_2.addWidget(self.label_8, 0, 1, 1, 1)
        self.label_2 = QtGui.QLabel(self.frame)
        self.label_2.setAlignment(QtCore.Qt.AlignCenter)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.gridLayout_2.addWidget(self.label_2, 0, 2, 1, 1)
        self.dial_pan = QtGui.QDial(self.frame)
        self.dial_pan.setMinimum(-20)
        self.dial_pan.setMaximum(20)
        self.dial_pan.setNotchTarget(10.0)
        self.dial_pan.setNotchesVisible(True)
        self.dial_pan.setObjectName(_fromUtf8("dial_pan"))
        self.gridLayout_2.addWidget(self.dial_pan, 1, 1, 1, 1)
        self.dial_pitch = QtGui.QDial(self.frame)
        self.dial_pitch.setMaximum(400)
        self.dial_pitch.setProperty("value", 100)
        self.dial_pitch.setNotchTarget(20.0)
        self.dial_pitch.setNotchesVisible(True)
        self.dial_pitch.setObjectName(_fromUtf8("dial_pitch"))
        self.gridLayout_2.addWidget(self.dial_pitch, 1, 2, 1, 1)
        self.spin_pan = QtGui.QDoubleSpinBox(self.frame)
        self.spin_pan.setMinimum(-1000.0)
        self.spin_pan.setMaximum(1000.0)
        self.spin_pan.setProperty("value", 0.0)
        self.spin_pan.setObjectName(_fromUtf8("spin_pan"))
        self.gridLayout_2.addWidget(self.spin_pan, 2, 1, 1, 1)
        self.spin_pitch = QtGui.QDoubleSpinBox(self.frame)
        self.spin_pitch.setMaximum(10000.0)
        self.spin_pitch.setProperty("value", 99.99)
        self.spin_pitch.setObjectName(_fromUtf8("spin_pitch"))
        self.gridLayout_2.addWidget(self.spin_pitch, 2, 2, 1, 1)
        self.gridLayout_3.addWidget(self.frame, 2, 0, 1, 3)
        self.label_4 = QtGui.QLabel(self.frame_controls)
        self.label_4.setObjectName(_fromUtf8("label_4"))
        self.gridLayout_3.addWidget(self.label_4, 3, 0, 1, 1)
        self.spin_stop_after = QtGui.QSpinBox(self.frame_controls)
        self.spin_stop_after.setMaximum(100000000)
        self.spin_stop_after.setObjectName(_fromUtf8("spin_stop_after"))
        self.gridLayout_3.addWidget(self.spin_stop_after, 3, 1, 1, 2)
        self.spin_fade_in = QtGui.QSpinBox(self.frame_controls)
        self.spin_fade_in.setMaximum(10000000)
        self.spin_fade_in.setObjectName(_fromUtf8("spin_fade_in"))
        self.gridLayout_3.addWidget(self.spin_fade_in, 4, 1, 1, 2)
        self.edit_duration = QtGui.QLineEdit(self.frame_controls)
        self.edit_duration.setObjectName(_fromUtf8("edit_duration"))
        self.gridLayout_3.addWidget(self.edit_duration, 5, 1, 1, 2)
        self.label_5 = QtGui.QLabel(self.frame_controls)
        self.label_5.setObjectName(_fromUtf8("label_5"))
        self.gridLayout_3.addWidget(self.label_5, 4, 0, 1, 1)
        self.label_6 = QtGui.QLabel(self.frame_controls)
        self.label_6.setObjectName(_fromUtf8("label_6"))
        self.gridLayout_3.addWidget(self.label_6, 5, 0, 1, 1)
        self.widget = QtGui.QWidget(self.frame_controls)
        self.widget.setStyleSheet(_fromUtf8("background-color: #fcaf3e;\n"
"color: rgb(255, 255, 255);"))
        self.widget.setObjectName(_fromUtf8("widget"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget)
        self.horizontalLayout.setMargin(5)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.label_sampler = QtGui.QLabel(self.widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_sampler.sizePolicy().hasHeightForWidth())
        self.label_sampler.setSizePolicy(sizePolicy)
        self.label_sampler.setText(_fromUtf8(""))
        self.label_sampler.setPixmap(QtGui.QPixmap(_fromUtf8(":/icons/sampler.png")))
        self.label_sampler.setObjectName(_fromUtf8("label_sampler"))
        self.horizontalLayout.addWidget(self.label_sampler)
        self.label_9 = QtGui.QLabel(self.widget)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_9.setFont(font)
        self.label_9.setObjectName(_fromUtf8("label_9"))
        self.horizontalLayout.addWidget(self.label_9)
        self.gridLayout_3.addWidget(self.widget, 0, 0, 1, 3)
        self.gridLayout.addWidget(self.frame_controls, 0, 1, 1, 1)
        spacerItem = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem, 0, 2, 1, 1)
        spacerItem1 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem1, 0, 0, 1, 1)

        self.retranslateUi(sampler_widget)
        QtCore.QMetaObject.connectSlotsByName(sampler_widget)

    def retranslateUi(self, sampler_widget):
        sampler_widget.setWindowTitle(QtGui.QApplication.translate("sampler_widget", "Form", None, QtGui.QApplication.UnicodeUTF8))
        self.label.setText(QtGui.QApplication.translate("sampler_widget", "Sound file", None, QtGui.QApplication.UnicodeUTF8))
        self.edit_sample.setToolTip(QtGui.QApplication.translate("sampler_widget", "The sound file. Expecting a .ogg or .wav file.", None, QtGui.QApplication.UnicodeUTF8))
        self.button_browse_sample.setToolTip(QtGui.QApplication.translate("sampler_widget", "Select a sound file from the file pool", None, QtGui.QApplication.UnicodeUTF8))
        self.button_browse_sample.setText(QtGui.QApplication.translate("sampler_widget", "Browse", None, QtGui.QApplication.UnicodeUTF8))
        self.label_7.setText(QtGui.QApplication.translate("sampler_widget", "Volume", None, QtGui.QApplication.UnicodeUTF8))
        self.dial_volume.setToolTip(QtGui.QApplication.translate("sampler_widget", "Set the volume of the sound", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_volume.setToolTip(QtGui.QApplication.translate("sampler_widget", "Set the volume of the sound", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_volume.setSuffix(QtGui.QApplication.translate("sampler_widget", "%", None, QtGui.QApplication.UnicodeUTF8))
        self.label_8.setText(QtGui.QApplication.translate("sampler_widget", "Pan", None, QtGui.QApplication.UnicodeUTF8))
        self.label_2.setText(QtGui.QApplication.translate("sampler_widget", "Pitch", None, QtGui.QApplication.UnicodeUTF8))
        self.dial_pan.setToolTip(QtGui.QApplication.translate("sampler_widget", "Set the panning (left-right) of the sound", None, QtGui.QApplication.UnicodeUTF8))
        self.dial_pitch.setToolTip(QtGui.QApplication.translate("sampler_widget", "Set the relative pitch of the sound (100% = original)", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_pan.setToolTip(QtGui.QApplication.translate("sampler_widget", "Set the panning (left-right) of the sound", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_pitch.setToolTip(QtGui.QApplication.translate("sampler_widget", "Set the relative pitch of the sound (100% = original)", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_pitch.setSuffix(QtGui.QApplication.translate("sampler_widget", "%", None, QtGui.QApplication.UnicodeUTF8))
        self.label_4.setText(QtGui.QApplication.translate("sampler_widget", "Stop after", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_stop_after.setToolTip(QtGui.QApplication.translate("sampler_widget", "Force playback to stop after a specified duration. 0ms corresponds to a full playback.", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_stop_after.setSuffix(QtGui.QApplication.translate("sampler_widget", "ms", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_fade_in.setToolTip(QtGui.QApplication.translate("sampler_widget", "The fade-in time of the sound.", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_fade_in.setSuffix(QtGui.QApplication.translate("sampler_widget", "ms", None, QtGui.QApplication.UnicodeUTF8))
        self.edit_duration.setToolTip(QtGui.QApplication.translate("sampler_widget", "Set the duration of the sampler item. Expecting a duration in ms, \'sound\' (to wait until the sound is finished playing), \'keypress\', \'mouseclick\', or a variable (e.g., \'[sampler_dur]\').", None, QtGui.QApplication.UnicodeUTF8))
        self.edit_duration.setText(QtGui.QApplication.translate("sampler_widget", "sound", None, QtGui.QApplication.UnicodeUTF8))
        self.label_5.setText(QtGui.QApplication.translate("sampler_widget", "Fade in", None, QtGui.QApplication.UnicodeUTF8))
        self.label_6.setText(QtGui.QApplication.translate("sampler_widget", "Duration", None, QtGui.QApplication.UnicodeUTF8))
        self.label_9.setText(QtGui.QApplication.translate("sampler_widget", "Sampler controls", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = sketchpad_widget_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/sketchpad_widget.ui'
#
# Created: Sun Aug 25 12:47:26 2013
#      by: PyQt4 UI code generator 4.10
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)

class Ui_sketchpad_widget(object):
    def setupUi(self, sketchpad_widget):
        sketchpad_widget.setObjectName(_fromUtf8("sketchpad_widget"))
        sketchpad_widget.resize(1053, 708)
        self.verticalLayout = QtGui.QVBoxLayout(sketchpad_widget)
        self.verticalLayout.setMargin(0)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.frame = QtGui.QFrame(sketchpad_widget)
        self.frame.setFrameShape(QtGui.QFrame.NoFrame)
        self.frame.setFrameShadow(QtGui.QFrame.Raised)
        self.frame.setObjectName(_fromUtf8("frame"))
        self.verticalLayout_2 = QtGui.QVBoxLayout(self.frame)
        self.verticalLayout_2.setMargin(0)
        self.verticalLayout_2.setObjectName(_fromUtf8("verticalLayout_2"))
        self.widget = QtGui.QWidget(self.frame)
        self.widget.setObjectName(_fromUtf8("widget"))
        self.horizontalLayout_2 = QtGui.QHBoxLayout(self.widget)
        self.horizontalLayout_2.setMargin(0)
        self.horizontalLayout_2.setObjectName(_fromUtf8("horizontalLayout_2"))
        self.widget_3 = QtGui.QWidget(self.widget)
        self.widget_3.setObjectName(_fromUtf8("widget_3"))
        self.verticalLayout_3 = QtGui.QVBoxLayout(self.widget_3)
        self.verticalLayout_3.setMargin(0)
        self.verticalLayout_3.setObjectName(_fromUtf8("verticalLayout_3"))
        self.widget_2 = QtGui.QWidget(self.widget_3)
        self.widget_2.setObjectName(_fromUtf8("widget_2"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget_2)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.verticalLayout_3.addWidget(self.widget_2)
        self.widget_7 = QtGui.QWidget(self.widget_3)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_7.sizePolicy().hasHeightForWidth())
        self.widget_7.setSizePolicy(sizePolicy)
        self.widget_7.setObjectName(_fromUtf8("widget_7"))
        self.horizontalLayout_5 = QtGui.QHBoxLayout(self.widget_7)
        self.horizontalLayout_5.setMargin(0)
        self.horizontalLayout_5.setObjectName(_fromUtf8("horizontalLayout_5"))
        self.frame_4 = QtGui.QFrame(self.widget_7)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frame_4.sizePolicy().hasHeightForWidth())
        self.frame_4.setSizePolicy(sizePolicy)
        self.frame_4.setFrameShape(QtGui.QFrame.StyledPanel)
        self.frame_4.setObjectName(_fromUtf8("frame_4"))
        self.gridLayout = QtGui.QGridLayout(self.frame_4)
        self.gridLayout.setSpacing(0)
        self.gridLayout.setContentsMargins(4, 4, 4, 0)
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        self.button_line = QtGui.QPushButton(self.frame_4)
        self.button_line.setText(_fromUtf8(""))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/line_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_line.setIcon(icon)
        self.button_line.setIconSize(QtCore.QSize(32, 32))
        self.button_line.setCheckable(True)
        self.button_line.setChecked(True)
        self.button_line.setFlat(True)
        self.button_line.setObjectName(_fromUtf8("button_line"))
        self.gridLayout.addWidget(self.button_line, 0, 0, 1, 1)
        self.button_arrow = QtGui.QPushButton(self.frame_4)
        self.button_arrow.setText(_fromUtf8(""))
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/arrow_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_arrow.setIcon(icon1)
        self.button_arrow.setIconSize(QtCore.QSize(32, 32))
        self.button_arrow.setCheckable(True)
        self.button_arrow.setFlat(True)
        self.button_arrow.setObjectName(_fromUtf8("button_arrow"))
        self.gridLayout.addWidget(self.button_arrow, 0, 1, 1, 1)
        self.button_textline = QtGui.QPushButton(self.frame_4)
        self.button_textline.setText(_fromUtf8(""))
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/textline_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_textline.setIcon(icon2)
        self.button_textline.setIconSize(QtCore.QSize(32, 32))
        self.button_textline.setCheckable(True)
        self.button_textline.setFlat(True)
        self.button_textline.setObjectName(_fromUtf8("button_textline"))
        self.gridLayout.addWidget(self.button_textline, 0, 2, 1, 1)
        self.button_image = QtGui.QPushButton(self.frame_4)
        self.button_image.setText(_fromUtf8(""))
        icon3 = QtGui.QIcon()
        icon3.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/image_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_image.setIcon(icon3)
        self.button_image.setIconSize(QtCore.QSize(32, 32))
        self.button_image.setCheckable(True)
        self.button_image.setFlat(True)
        self.button_image.setObjectName(_fromUtf8("button_image"))
        self.gridLayout.addWidget(self.button_image, 0, 3, 1, 1)
        self.button_gabor = QtGui.QPushButton(self.frame_4)
        self.button_gabor.setText(_fromUtf8(""))
        icon4 = QtGui.QIcon()
        icon4.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/gabor.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_gabor.setIcon(icon4)
        self.button_gabor.setIconSize(QtCore.QSize(32, 32))
        self.button_gabor.setCheckable(True)
        self.button_gabor.setFlat(True)
        self.button_gabor.setObjectName(_fromUtf8("button_gabor"))
        self.gridLayout.addWidget(self.button_gabor, 0, 4, 1, 1)
        self.button_rect = QtGui.QPushButton(self.frame_4)
        self.button_rect.setText(_fromUtf8(""))
        icon5 = QtGui.QIcon()
        icon5.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/rectangle_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_rect.setIcon(icon5)
        self.button_rect.setIconSize(QtCore.QSize(32, 32))
        self.button_rect.setCheckable(True)
        self.button_rect.setFlat(True)
        self.button_rect.setObjectName(_fromUtf8("button_rect"))
        self.gridLayout.addWidget(self.button_rect, 1, 0, 1, 1)
        self.button_ellipse = QtGui.QPushButton(self.frame_4)
        self.button_ellipse.setText(_fromUtf8(""))
        icon6 = QtGui.QIcon()
        icon6.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/ellipse_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_ellipse.setIcon(icon6)
        self.button_ellipse.setIconSize(QtCore.QSize(32, 32))
        self.button_ellipse.setCheckable(True)
        self.button_ellipse.setFlat(True)
        self.button_ellipse.setObjectName(_fromUtf8("button_ellipse"))
        self.gridLayout.addWidget(self.button_ellipse, 1, 1, 1, 1)
        self.button_circle = QtGui.QPushButton(self.frame_4)
        self.button_circle.setText(_fromUtf8(""))
        icon7 = QtGui.QIcon()
        icon7.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/circle_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_circle.setIcon(icon7)
        self.button_circle.setIconSize(QtCore.QSize(32, 32))
        self.button_circle.setCheckable(True)
        self.button_circle.setFlat(True)
        self.button_circle.setObjectName(_fromUtf8("button_circle"))
        self.gridLayout.addWidget(self.button_circle, 1, 2, 1, 1)
        self.button_fixdot = QtGui.QPushButton(self.frame_4)
        self.button_fixdot.setText(_fromUtf8(""))
        icon8 = QtGui.QIcon()
        icon8.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/fixdot_large.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_fixdot.setIcon(icon8)
        self.button_fixdot.setIconSize(QtCore.QSize(32, 32))
        self.button_fixdot.setCheckable(True)
        self.button_fixdot.setFlat(True)
        self.button_fixdot.setObjectName(_fromUtf8("button_fixdot"))
        self.gridLayout.addWidget(self.button_fixdot, 1, 3, 1, 1)
        self.widget_5 = QtGui.QWidget(self.frame_4)
        self.widget_5.setObjectName(_fromUtf8("widget_5"))
        self.gridLayout.addWidget(self.widget_5, 2, 1, 1, 1)
        self.button_noise_patch = QtGui.QPushButton(self.frame_4)
        self.button_noise_patch.setText(_fromUtf8(""))
        icon9 = QtGui.QIcon()
        icon9.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/noise_patch.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_noise_patch.setIcon(icon9)
        self.button_noise_patch.setIconSize(QtCore.QSize(32, 32))
        self.button_noise_patch.setCheckable(True)
        self.button_noise_patch.setFlat(True)
        self.button_noise_patch.setObjectName(_fromUtf8("button_noise_patch"))
        self.gridLayout.addWidget(self.button_noise_patch, 1, 4, 1, 1)
        self.horizontalLayout_5.addWidget(self.frame_4)
        self.frame_5 = QtGui.QFrame(self.widget_7)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frame_5.sizePolicy().hasHeightForWidth())
        self.frame_5.setSizePolicy(sizePolicy)
        self.frame_5.setMinimumSize(QtCore.QSize(250, 0))
        self.frame_5.setFrameShape(QtGui.QFrame.StyledPanel)
        self.frame_5.setObjectName(_fromUtf8("frame_5"))
        self.gridLayout_2 = QtGui.QGridLayout(self.frame_5)
        self.gridLayout_2.setMargin(4)
        self.gridLayout_2.setSpacing(4)
        self.gridLayout_2.setObjectName(_fromUtf8("gridLayout_2"))
        self.label_options = QtGui.QLabel(self.frame_5)
        font = QtGui.QFont()
        font.setItalic(True)
        self.label_options.setFont(font)
        self.label_options.setObjectName(_fromUtf8("label_options"))
        self.gridLayout_2.addWidget(self.label_options, 0, 0, 1, 3)
        self.label_arrow_size = QtGui.QLabel(self.frame_5)
        self.label_arrow_size.setObjectName(_fromUtf8("label_arrow_size"))
        self.gridLayout_2.addWidget(self.label_arrow_size, 4, 0, 1, 1)
        self.edit_color = color_edit(self.frame_5)
        self.edit_color.setObjectName(_fromUtf8("edit_color"))
        self.gridLayout_2.addWidget(self.edit_color, 2, 1, 1, 2)
        self.edit_show_if = QtGui.QLineEdit(self.frame_5)
        self.edit_show_if.setText(_fromUtf8("always"))
        self.edit_show_if.setObjectName(_fromUtf8("edit_show_if"))
        self.gridLayout_2.addWidget(self.edit_show_if, 1, 1, 1, 2)
        self.label_show_if = QtGui.QLabel(self.frame_5)
        self.label_show_if.setObjectName(_fromUtf8("label_show_if"))
        self.gridLayout_2.addWidget(self.label_show_if, 1, 0, 1, 1)
        self.label_color = QtGui.QLabel(self.frame_5)
        self.label_color.setObjectName(_fromUtf8("label_color"))
        self.gridLayout_2.addWidget(self.label_color, 2, 0, 1, 1)
        self.checkbox_center = QtGui.QCheckBox(self.frame_5)
        self.checkbox_center.setChecked(True)
        self.checkbox_center.setObjectName(_fromUtf8("checkbox_center"))
        self.gridLayout_2.addWidget(self.checkbox_center, 7, 0, 1, 3)
        self.spin_arrow_size = QtGui.QSpinBox(self.frame_5)
        self.spin_arrow_size.setProperty("value", 10)
        self.spin_arrow_size.setObjectName(_fromUtf8("spin_arrow_size"))
        self.gridLayout_2.addWidget(self.spin_arrow_size, 4, 1, 1, 2)
        self.label_penwidth = QtGui.QLabel(self.frame_5)
        self.label_penwidth.setObjectName(_fromUtf8("label_penwidth"))
        self.gridLayout_2.addWidget(self.label_penwidth, 3, 0, 1, 1)
        self.checkbox_fill = QtGui.QCheckBox(self.frame_5)
        self.checkbox_fill.setObjectName(_fromUtf8("checkbox_fill"))
        self.gridLayout_2.addWidget(self.checkbox_fill, 6, 0, 1, 3)
        self.widget_font = font_widget(self.frame_5)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_font.sizePolicy().hasHeightForWidth())
        self.widget_font.setSizePolicy(sizePolicy)
        self.widget_font.setObjectName(_fromUtf8("widget_font"))
        self.gridLayout_2.addWidget(self.widget_font, 9, 0, 1, 3)
        self.spin_penwidth = QtGui.QSpinBox(self.frame_5)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.spin_penwidth.sizePolicy().hasHeightForWidth())
        self.spin_penwidth.setSizePolicy(sizePolicy)
        self.spin_penwidth.setMinimum(1)
        self.spin_penwidth.setMaximum(99)
        self.spin_penwidth.setObjectName(_fromUtf8("spin_penwidth"))
        self.gridLayout_2.addWidget(self.spin_penwidth, 3, 1, 1, 2)
        self.label_scale = QtGui.QLabel(self.frame_5)
        self.label_scale.setObjectName(_fromUtf8("label_scale"))
        self.gridLayout_2.addWidget(self.label_scale, 5, 0, 1, 1)
        self.spin_scale = QtGui.QDoubleSpinBox(self.frame_5)
        self.spin_scale.setDecimals(0)
        self.spin_scale.setMinimum(1.0)
        self.spin_scale.setMaximum(1000.0)
        self.spin_scale.setProperty("value", 100.0)
        self.spin_scale.setObjectName(_fromUtf8("spin_scale"))
        self.gridLayout_2.addWidget(self.spin_scale, 5, 1, 1, 2)
        self.checkbox_html = QtGui.QCheckBox(self.frame_5)
        self.checkbox_html.setChecked(True)
        self.checkbox_html.setObjectName(_fromUtf8("checkbox_html"))
        self.gridLayout_2.addWidget(self.checkbox_html, 8, 0, 1, 2)
        self.horizontalLayout_5.addWidget(self.frame_5)
        spacerItem = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout_5.addItem(spacerItem)
        self.frame_9 = QtGui.QFrame(self.widget_7)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frame_9.sizePolicy().hasHeightForWidth())
        self.frame_9.setSizePolicy(sizePolicy)
        self.frame_9.setFrameShape(QtGui.QFrame.StyledPanel)
        self.frame_9.setObjectName(_fromUtf8("frame_9"))
        self.gridLayout_3 = QtGui.QGridLayout(self.frame_9)
        self.gridLayout_3.setMargin(4)
        self.gridLayout_3.setSpacing(4)
        self.gridLayout_3.setObjectName(_fromUtf8("gridLayout_3"))
        self.label_6 = QtGui.QLabel(self.frame_9)
        self.label_6.setObjectName(_fromUtf8("label_6"))
        self.gridLayout_3.addWidget(self.label_6, 0, 0, 1, 1)
        self.spin_zoom = QtGui.QSpinBox(self.frame_9)
        self.spin_zoom.setMinimum(10)
        self.spin_zoom.setMaximum(500)
        self.spin_zoom.setProperty("value", 100)
        self.spin_zoom.setObjectName(_fromUtf8("spin_zoom"))
        self.gridLayout_3.addWidget(self.spin_zoom, 0, 1, 1, 1)
        self.label_5 = QtGui.QLabel(self.frame_9)
        self.label_5.setObjectName(_fromUtf8("label_5"))
        self.gridLayout_3.addWidget(self.label_5, 1, 0, 1, 1)
        self.spin_grid = QtGui.QSpinBox(self.frame_9)
        self.spin_grid.setMinimum(1)
        self.spin_grid.setProperty("value", 32)
        self.spin_grid.setObjectName(_fromUtf8("spin_grid"))
        self.gridLayout_3.addWidget(self.spin_grid, 1, 1, 1, 1)
        self.checkbox_show_grid = QtGui.QCheckBox(self.frame_9)
        self.checkbox_show_grid.setChecked(True)
        self.checkbox_show_grid.setObjectName(_fromUtf8("checkbox_show_grid"))
        self.gridLayout_3.addWidget(self.checkbox_show_grid, 2, 0, 1, 1)
        self.label_mouse_pos = QtGui.QLabel(self.frame_9)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_mouse_pos.sizePolicy().hasHeightForWidth())
        self.label_mouse_pos.setSizePolicy(sizePolicy)
        self.label_mouse_pos.setMinimumSize(QtCore.QSize(100, 0))
        self.label_mouse_pos.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.label_mouse_pos.setObjectName(_fromUtf8("label_mouse_pos"))
        self.gridLayout_3.addWidget(self.label_mouse_pos, 2, 1, 1, 1)
        self.widget_6 = QtGui.QWidget(self.frame_9)
        self.widget_6.setObjectName(_fromUtf8("widget_6"))
        self.gridLayout_3.addWidget(self.widget_6, 3, 0, 1, 1)
        self.horizontalLayout_5.addWidget(self.frame_9)
        self.verticalLayout_3.addWidget(self.widget_7)
        self.frame_notification = QtGui.QFrame(self.widget_3)
        self.frame_notification.setFrameShape(QtGui.QFrame.StyledPanel)
        self.frame_notification.setFrameShadow(QtGui.QFrame.Raised)
        self.frame_notification.setObjectName(_fromUtf8("frame_notification"))
        self.horizontalLayout_3 = QtGui.QHBoxLayout(self.frame_notification)
        self.horizontalLayout_3.setSpacing(8)
        self.horizontalLayout_3.setMargin(5)
        self.horizontalLayout_3.setObjectName(_fromUtf8("horizontalLayout_3"))
        self.pixmap_notification = QtGui.QLabel(self.frame_notification)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pixmap_notification.sizePolicy().hasHeightForWidth())
        self.pixmap_notification.setSizePolicy(sizePolicy)
        self.pixmap_notification.setText(_fromUtf8(""))
        self.pixmap_notification.setPixmap(QtGui.QPixmap(_fromUtf8(":/icons/about_large.png")))
        self.pixmap_notification.setObjectName(_fromUtf8("pixmap_notification"))
        self.horizontalLayout_3.addWidget(self.pixmap_notification)
        self.label_notification = QtGui.QLabel(self.frame_notification)
        self.label_notification.setWordWrap(True)
        self.label_notification.setOpenExternalLinks(True)
        self.label_notification.setObjectName(_fromUtf8("label_notification"))
        self.horizontalLayout_3.addWidget(self.label_notification)
        self.button_edit_script = QtGui.QPushButton(self.frame_notification)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.button_edit_script.sizePolicy().hasHeightForWidth())
        self.button_edit_script.setSizePolicy(sizePolicy)
        icon10 = QtGui.QIcon()
        icon10.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/script.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_edit_script.setIcon(icon10)
        self.button_edit_script.setIconSize(QtCore.QSize(16, 16))
        self.button_edit_script.setObjectName(_fromUtf8("button_edit_script"))
        self.horizontalLayout_3.addWidget(self.button_edit_script)
        self.verticalLayout_3.addWidget(self.frame_notification)
        self.scrollArea = QtGui.QScrollArea(self.widget_3)
        self.scrollArea.setWidgetResizable(True)
        self.scrollArea.setObjectName(_fromUtf8("scrollArea"))
        self.scrollAreaWidgetContents = QtGui.QWidget()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 1047, 398))
        self.scrollAreaWidgetContents.setObjectName(_fromUtf8("scrollAreaWidgetContents"))
        self.verticalLayout_5 = QtGui.QVBoxLayout(self.scrollAreaWidgetContents)
        self.verticalLayout_5.setObjectName(_fromUtf8("verticalLayout_5"))
        self.view = QtGui.QGraphicsView(self.scrollAreaWidgetContents)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.view.sizePolicy().hasHeightForWidth())
        self.view.setSizePolicy(sizePolicy)
        self.view.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.view.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.view.setObjectName(_fromUtf8("view"))
        self.verticalLayout_5.addWidget(self.view)
        self.widget_items = QtGui.QWidget(self.scrollAreaWidgetContents)
        self.widget_items.setObjectName(_fromUtf8("widget_items"))
        self.verticalLayout_5.addWidget(self.widget_items)
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.verticalLayout_3.addWidget(self.scrollArea)
        self.horizontalLayout_2.addWidget(self.widget_3)
        self.verticalLayout_2.addWidget(self.widget)
        self.verticalLayout.addWidget(self.frame)

        self.retranslateUi(sketchpad_widget)
        QtCore.QMetaObject.connectSlotsByName(sketchpad_widget)

    def retranslateUi(self, sketchpad_widget):
        sketchpad_widget.setWindowTitle(_translate("sketchpad_widget", "Form", None))
        self.button_line.setToolTip(_translate("sketchpad_widget", "Line tool", None))
        self.button_arrow.setToolTip(_translate("sketchpad_widget", "Arrow tool", None))
        self.button_textline.setToolTip(_translate("sketchpad_widget", "Text tool", None))
        self.button_image.setToolTip(_translate("sketchpad_widget", "Image tool", None))
        self.button_gabor.setToolTip(_translate("sketchpad_widget", "Gabor patch tool", None))
        self.button_rect.setToolTip(_translate("sketchpad_widget", "Rectangle tool", None))
        self.button_ellipse.setToolTip(_translate("sketchpad_widget", "Ellipse tool", None))
        self.button_circle.setToolTip(_translate("sketchpad_widget", "Circle tool", None))
        self.button_fixdot.setToolTip(_translate("sketchpad_widget", "Fixation dot tool", None))
        self.button_noise_patch.setToolTip(_translate("sketchpad_widget", "Noise patch tool", None))
        self.label_options.setText(_translate("sketchpad_widget", "Click on the sketchpad for options", None))
        self.label_arrow_size.setText(_translate("sketchpad_widget", "Arrowhead size", None))
        self.label_show_if.setText(_translate("sketchpad_widget", "Show if", None))
        self.label_color.setText(_translate("sketchpad_widget", "Color", None))
        self.checkbox_center.setToolTip(_translate("sketchpad_widget", "Center the object", None))
        self.checkbox_center.setText(_translate("sketchpad_widget", "Center object", None))
        self.spin_arrow_size.setToolTip(_translate("sketchpad_widget", "Size of the arrowhead", None))
        self.spin_arrow_size.setSuffix(_translate("sketchpad_widget", "px", None))
        self.label_penwidth.setText(_translate("sketchpad_widget", "Pen width", None))
        self.checkbox_fill.setToolTip(_translate("sketchpad_widget", "Check to draw filled objects", None))
        self.checkbox_fill.setText(_translate("sketchpad_widget", "Fill object", None))
        self.spin_penwidth.setToolTip(_translate("sketchpad_widget", "Pen width", None))
        self.spin_penwidth.setSuffix(_translate("sketchpad_widget", "px", None))
        self.label_scale.setText(_translate("sketchpad_widget", "Image scale", None))
        self.spin_scale.setToolTip(_translate("sketchpad_widget", "Image scaling in %", None))
        self.spin_scale.setSuffix(_translate("sketchpad_widget", "%", None))
        self.checkbox_html.setToolTip(_translate("sketchpad_widget", "Parse a subset of HTML tags", None))
        self.checkbox_html.setText(_translate("sketchpad_widget", "Parse HTML subset", None))
        self.label_6.setText(_translate("sketchpad_widget", "Zoom", None))
        self.spin_zoom.setToolTip(_translate("sketchpad_widget", "Zoom level in %", None))
        self.spin_zoom.setSuffix(_translate("sketchpad_widget", "%", None))
        self.label_5.setText(_translate("sketchpad_widget", "Grid", None))
        self.spin_grid.setToolTip(_translate("sketchpad_widget", "Grid size", None))
        self.spin_grid.setSuffix(_translate("sketchpad_widget", "px", None))
        self.checkbox_show_grid.setToolTip(_translate("sketchpad_widget", "Check to display the grid and enable snap-to-grid", None))
        self.checkbox_show_grid.setText(_translate("sketchpad_widget", "Show grid", None))
        self.label_mouse_pos.setText(_translate("sketchpad_widget", "(0, 0)", None))
        self.label_notification.setText(_translate("sketchpad_widget", "[nr] objects are not shown, because their definition contains variables.", None))
        self.button_edit_script.setToolTip(_translate("sketchpad_widget", "Edit the script to see objects defined using variables", None))
        self.button_edit_script.setText(_translate("sketchpad_widget", "Edit script", None))

from libqtopensesame.widgets.font_widget import font_widget
from libqtopensesame.widgets.color_edit import color_edit

########NEW FILE########
__FILENAME__ = start_new_widget_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/start_new_widget.ui'
#
# Created: Thu Oct 11 11:14:29 2012
#      by: PyQt4 UI code generator 4.9.1
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_widget_start_new(object):
    def setupUi(self, widget_start_new):
        widget_start_new.setObjectName(_fromUtf8("widget_start_new"))
        widget_start_new.resize(1098, 366)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(widget_start_new.sizePolicy().hasHeightForWidth())
        widget_start_new.setSizePolicy(sizePolicy)
        self.verticalLayout_2 = QtGui.QVBoxLayout(widget_start_new)
        self.verticalLayout_2.setMargin(0)
        self.verticalLayout_2.setObjectName(_fromUtf8("verticalLayout_2"))
        self.widget_main_container = QtGui.QWidget(widget_start_new)
        self.widget_main_container.setObjectName(_fromUtf8("widget_main_container"))
        self.layout_main = QtGui.QVBoxLayout(self.widget_main_container)
        self.layout_main.setMargin(0)
        self.layout_main.setObjectName(_fromUtf8("layout_main"))
        spacerItem = QtGui.QSpacerItem(20, 8, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)
        self.layout_main.addItem(spacerItem)
        self.widget_central_container = QtGui.QWidget(self.widget_main_container)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_central_container.sizePolicy().hasHeightForWidth())
        self.widget_central_container.setSizePolicy(sizePolicy)
        self.widget_central_container.setObjectName(_fromUtf8("widget_central_container"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget_central_container)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        spacerItem1 = QtGui.QSpacerItem(0, 0, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem1)
        self.widget_central_form = QtGui.QWidget(self.widget_central_container)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget_central_form.sizePolicy().hasHeightForWidth())
        self.widget_central_form.setSizePolicy(sizePolicy)
        self.widget_central_form.setMinimumSize(QtCore.QSize(400, 0))
        self.widget_central_form.setObjectName(_fromUtf8("widget_central_form"))
        self.formLayout = QtGui.QFormLayout(self.widget_central_form)
        self.formLayout.setFieldGrowthPolicy(QtGui.QFormLayout.AllNonFixedFieldsGrow)
        self.formLayout.setLabelAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.formLayout.setMargin(0)
        self.formLayout.setMargin(0)
        self.formLayout.setObjectName(_fromUtf8("formLayout"))
        self.widget_header_start = QtGui.QWidget(self.widget_central_form)
        self.widget_header_start.setObjectName(_fromUtf8("widget_header_start"))
        self.horizontalLayout_2 = QtGui.QHBoxLayout(self.widget_header_start)
        self.horizontalLayout_2.setSpacing(4)
        self.horizontalLayout_2.setMargin(4)
        self.horizontalLayout_2.setMargin(0)
        self.horizontalLayout_2.setObjectName(_fromUtf8("horizontalLayout_2"))
        self.label_get_started = QtGui.QLabel(self.widget_header_start)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_get_started.sizePolicy().hasHeightForWidth())
        self.label_get_started.setSizePolicy(sizePolicy)
        self.label_get_started.setObjectName(_fromUtf8("label_get_started"))
        self.horizontalLayout_2.addWidget(self.label_get_started)
        self.label_2 = QtGui.QLabel(self.widget_header_start)
        self.label_2.setWordWrap(True)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.horizontalLayout_2.addWidget(self.label_2)
        self.formLayout.setWidget(0, QtGui.QFormLayout.SpanningRole, self.widget_header_start)
        spacerItem2 = QtGui.QSpacerItem(20, 8, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)
        self.formLayout.setItem(2, QtGui.QFormLayout.SpanningRole, spacerItem2)
        self.label_templates = QtGui.QLabel(self.widget_central_form)
        self.label_templates.setObjectName(_fromUtf8("label_templates"))
        self.formLayout.setWidget(3, QtGui.QFormLayout.LabelRole, self.label_templates)
        self.list_templates = QtGui.QListWidget(self.widget_central_form)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.list_templates.sizePolicy().hasHeightForWidth())
        self.list_templates.setSizePolicy(sizePolicy)
        self.list_templates.setMaximumSize(QtCore.QSize(16777215, 100))
        self.list_templates.setObjectName(_fromUtf8("list_templates"))
        self.formLayout.setWidget(3, QtGui.QFormLayout.FieldRole, self.list_templates)
        self._label_recent = QtGui.QLabel(self.widget_central_form)
        self._label_recent.setObjectName(_fromUtf8("_label_recent"))
        self.formLayout.setWidget(5, QtGui.QFormLayout.LabelRole, self._label_recent)
        self.list_recent = QtGui.QListWidget(self.widget_central_form)
        self.list_recent.setMaximumSize(QtCore.QSize(16777215, 100))
        self.list_recent.setObjectName(_fromUtf8("list_recent"))
        self.formLayout.setWidget(5, QtGui.QFormLayout.FieldRole, self.list_recent)
        self.label_browse = QtGui.QLabel(self.widget_central_form)
        self.label_browse.setObjectName(_fromUtf8("label_browse"))
        self.formLayout.setWidget(6, QtGui.QFormLayout.LabelRole, self.label_browse)
        self.button_browse = QtGui.QCommandLinkButton(self.widget_central_form)
        self.button_browse.setObjectName(_fromUtf8("button_browse"))
        self.formLayout.setWidget(6, QtGui.QFormLayout.FieldRole, self.button_browse)
        self.label_help = QtGui.QLabel(self.widget_central_form)
        self.label_help.setObjectName(_fromUtf8("label_help"))
        self.formLayout.setWidget(7, QtGui.QFormLayout.LabelRole, self.label_help)
        self.widget_3 = QtGui.QWidget(self.widget_central_form)
        self.widget_3.setObjectName(_fromUtf8("widget_3"))
        self.horizontalLayout_3 = QtGui.QHBoxLayout(self.widget_3)
        self.horizontalLayout_3.setMargin(0)
        self.horizontalLayout_3.setMargin(0)
        self.horizontalLayout_3.setObjectName(_fromUtf8("horizontalLayout_3"))
        self.button_osdoc = QtGui.QCommandLinkButton(self.widget_3)
        self.button_osdoc.setObjectName(_fromUtf8("button_osdoc"))
        self.horizontalLayout_3.addWidget(self.button_osdoc)
        self.button_forum = QtGui.QCommandLinkButton(self.widget_3)
        self.button_forum.setObjectName(_fromUtf8("button_forum"))
        self.horizontalLayout_3.addWidget(self.button_forum)
        self.formLayout.setWidget(7, QtGui.QFormLayout.FieldRole, self.widget_3)
        self.widget_header_new = QtGui.QWidget(self.widget_central_form)
        self.widget_header_new.setObjectName(_fromUtf8("widget_header_new"))
        self.horizontalLayout_4 = QtGui.QHBoxLayout(self.widget_header_new)
        self.horizontalLayout_4.setSpacing(4)
        self.horizontalLayout_4.setMargin(4)
        self.horizontalLayout_4.setMargin(0)
        self.horizontalLayout_4.setObjectName(_fromUtf8("horizontalLayout_4"))
        self.label_start_new = QtGui.QLabel(self.widget_header_new)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_start_new.sizePolicy().hasHeightForWidth())
        self.label_start_new.setSizePolicy(sizePolicy)
        self.label_start_new.setObjectName(_fromUtf8("label_start_new"))
        self.horizontalLayout_4.addWidget(self.label_start_new)
        self.label = QtGui.QLabel(self.widget_header_new)
        self.label.setWordWrap(True)
        self.label.setObjectName(_fromUtf8("label"))
        self.horizontalLayout_4.addWidget(self.label)
        self.button_cancel = QtGui.QPushButton(self.widget_header_new)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.button_cancel.sizePolicy().hasHeightForWidth())
        self.button_cancel.setSizePolicy(sizePolicy)
        self.button_cancel.setObjectName(_fromUtf8("button_cancel"))
        self.horizontalLayout_4.addWidget(self.button_cancel)
        self.formLayout.setWidget(1, QtGui.QFormLayout.SpanningRole, self.widget_header_new)
        self.horizontalLayout.addWidget(self.widget_central_form)
        spacerItem3 = QtGui.QSpacerItem(0, 0, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem3)
        self.layout_main.addWidget(self.widget_central_container)
        spacerItem4 = QtGui.QSpacerItem(20, 8, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)
        self.layout_main.addItem(spacerItem4)
        self.widget_credits = credits_widget(self.widget_main_container)
        self.widget_credits.setObjectName(_fromUtf8("widget_credits"))
        self.layout_main.addWidget(self.widget_credits)
        self.verticalLayout_2.addWidget(self.widget_main_container)

        self.retranslateUi(widget_start_new)
        QtCore.QMetaObject.connectSlotsByName(widget_start_new)

    def retranslateUi(self, widget_start_new):
        widget_start_new.setWindowTitle(QtGui.QApplication.translate("widget_start_new", "Form", None, QtGui.QApplication.UnicodeUTF8))
        self.label_get_started.setText(QtGui.QApplication.translate("widget_start_new", "ICON", None, QtGui.QApplication.UnicodeUTF8))
        self.label_2.setText(QtGui.QApplication.translate("widget_start_new", "<b>Get started!</b><br />\n"
"<small><i>Select an item in the overview area to start right away</i></small>", None, QtGui.QApplication.UnicodeUTF8))
        self.label_templates.setText(QtGui.QApplication.translate("widget_start_new", "<h3>New</h3>", None, QtGui.QApplication.UnicodeUTF8))
        self._label_recent.setText(QtGui.QApplication.translate("widget_start_new", "<h3>Recent</h3>", None, QtGui.QApplication.UnicodeUTF8))
        self.label_browse.setText(QtGui.QApplication.translate("widget_start_new", "<h3>Open</h3>", None, QtGui.QApplication.UnicodeUTF8))
        self.button_browse.setText(QtGui.QApplication.translate("widget_start_new", "Open an existing experiment", None, QtGui.QApplication.UnicodeUTF8))
        self.label_help.setText(QtGui.QApplication.translate("widget_start_new", "<h3>Help</h3>", None, QtGui.QApplication.UnicodeUTF8))
        self.button_osdoc.setText(QtGui.QApplication.translate("widget_start_new", "Visit the documentation site", None, QtGui.QApplication.UnicodeUTF8))
        self.button_forum.setText(QtGui.QApplication.translate("widget_start_new", "Ask a question on the forum", None, QtGui.QApplication.UnicodeUTF8))
        self.label_start_new.setText(QtGui.QApplication.translate("widget_start_new", "ICON", None, QtGui.QApplication.UnicodeUTF8))
        self.label.setText(QtGui.QApplication.translate("widget_start_new", "<b>New expriment</b><br />\n"
"<small><i>Click \'cancel\' or close this tab to resume your current experiment</i></small>", None, QtGui.QApplication.UnicodeUTF8))
        self.button_cancel.setText(QtGui.QApplication.translate("widget_start_new", "Cancel", None, QtGui.QApplication.UnicodeUTF8))

from libqtopensesame.widgets.credits_widget import credits_widget

########NEW FILE########
__FILENAME__ = synth_widget_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/synth_widget.ui'
#
# Created: Thu Mar 14 21:12:09 2013
#      by: PyQt4 UI code generator 4.9.1
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_synth_widget(object):
    def setupUi(self, synth_widget):
        synth_widget.setObjectName(_fromUtf8("synth_widget"))
        synth_widget.resize(715, 505)
        self.gridLayout = QtGui.QGridLayout(synth_widget)
        self.gridLayout.setMargin(0)
        self.gridLayout.setObjectName(_fromUtf8("gridLayout"))
        spacerItem = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem, 0, 0, 1, 1)
        self.frame_controls = QtGui.QFrame(synth_widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frame_controls.sizePolicy().hasHeightForWidth())
        self.frame_controls.setSizePolicy(sizePolicy)
        self.frame_controls.setFrameShape(QtGui.QFrame.StyledPanel)
        self.frame_controls.setFrameShadow(QtGui.QFrame.Raised)
        self.frame_controls.setObjectName(_fromUtf8("frame_controls"))
        self.gridLayout_3 = QtGui.QGridLayout(self.frame_controls)
        self.gridLayout_3.setObjectName(_fromUtf8("gridLayout_3"))
        self.frame = QtGui.QFrame(self.frame_controls)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frame.sizePolicy().hasHeightForWidth())
        self.frame.setSizePolicy(sizePolicy)
        self.frame.setMaximumSize(QtCore.QSize(16777215, 140))
        self.frame.setFrameShape(QtGui.QFrame.StyledPanel)
        self.frame.setFrameShadow(QtGui.QFrame.Raised)
        self.frame.setObjectName(_fromUtf8("frame"))
        self.gridLayout_2 = QtGui.QGridLayout(self.frame)
        self.gridLayout_2.setMargin(4)
        self.gridLayout_2.setObjectName(_fromUtf8("gridLayout_2"))
        self.label_7 = QtGui.QLabel(self.frame)
        self.label_7.setAlignment(QtCore.Qt.AlignCenter)
        self.label_7.setObjectName(_fromUtf8("label_7"))
        self.gridLayout_2.addWidget(self.label_7, 0, 2, 1, 1)
        self.dial_volume = QtGui.QDial(self.frame)
        self.dial_volume.setMaximum(100)
        self.dial_volume.setProperty("value", 99)
        self.dial_volume.setNotchTarget(10.0)
        self.dial_volume.setNotchesVisible(True)
        self.dial_volume.setObjectName(_fromUtf8("dial_volume"))
        self.gridLayout_2.addWidget(self.dial_volume, 1, 2, 1, 1)
        self.spin_volume = QtGui.QDoubleSpinBox(self.frame)
        self.spin_volume.setMaximum(100.0)
        self.spin_volume.setSingleStep(100.0)
        self.spin_volume.setProperty("value", 100.0)
        self.spin_volume.setObjectName(_fromUtf8("spin_volume"))
        self.gridLayout_2.addWidget(self.spin_volume, 2, 2, 1, 1)
        self.label_8 = QtGui.QLabel(self.frame)
        self.label_8.setAlignment(QtCore.Qt.AlignCenter)
        self.label_8.setObjectName(_fromUtf8("label_8"))
        self.gridLayout_2.addWidget(self.label_8, 0, 3, 1, 1)
        self.dial_pan = QtGui.QDial(self.frame)
        self.dial_pan.setMinimum(-20)
        self.dial_pan.setMaximum(20)
        self.dial_pan.setNotchTarget(10.0)
        self.dial_pan.setNotchesVisible(True)
        self.dial_pan.setObjectName(_fromUtf8("dial_pan"))
        self.gridLayout_2.addWidget(self.dial_pan, 1, 3, 1, 1)
        self.spin_pan = QtGui.QDoubleSpinBox(self.frame)
        self.spin_pan.setMinimum(-1000.0)
        self.spin_pan.setMaximum(1000.0)
        self.spin_pan.setProperty("value", 0.0)
        self.spin_pan.setObjectName(_fromUtf8("spin_pan"))
        self.gridLayout_2.addWidget(self.spin_pan, 2, 3, 1, 1)
        self.dial_decay = QtGui.QDial(self.frame)
        self.dial_decay.setMaximum(500)
        self.dial_decay.setProperty("value", 5)
        self.dial_decay.setNotchTarget(50.0)
        self.dial_decay.setNotchesVisible(True)
        self.dial_decay.setObjectName(_fromUtf8("dial_decay"))
        self.gridLayout_2.addWidget(self.dial_decay, 1, 1, 1, 1)
        self.dial_attack = QtGui.QDial(self.frame)
        self.dial_attack.setMaximum(500)
        self.dial_attack.setNotchTarget(50.0)
        self.dial_attack.setNotchesVisible(True)
        self.dial_attack.setObjectName(_fromUtf8("dial_attack"))
        self.gridLayout_2.addWidget(self.dial_attack, 1, 0, 1, 1)
        self.label_10 = QtGui.QLabel(self.frame)
        self.label_10.setAlignment(QtCore.Qt.AlignCenter)
        self.label_10.setObjectName(_fromUtf8("label_10"))
        self.gridLayout_2.addWidget(self.label_10, 0, 0, 1, 1)
        self.label_11 = QtGui.QLabel(self.frame)
        self.label_11.setAlignment(QtCore.Qt.AlignCenter)
        self.label_11.setObjectName(_fromUtf8("label_11"))
        self.gridLayout_2.addWidget(self.label_11, 0, 1, 1, 1)
        self.spin_attack = QtGui.QSpinBox(self.frame)
        self.spin_attack.setMaximum(100000)
        self.spin_attack.setObjectName(_fromUtf8("spin_attack"))
        self.gridLayout_2.addWidget(self.spin_attack, 2, 0, 1, 1)
        self.spin_decay = QtGui.QSpinBox(self.frame)
        self.spin_decay.setMaximum(100000)
        self.spin_decay.setProperty("value", 5)
        self.spin_decay.setObjectName(_fromUtf8("spin_decay"))
        self.gridLayout_2.addWidget(self.spin_decay, 2, 1, 1, 1)
        self.gridLayout_3.addWidget(self.frame, 3, 0, 1, 3)
        self.label_4 = QtGui.QLabel(self.frame_controls)
        self.label_4.setObjectName(_fromUtf8("label_4"))
        self.gridLayout_3.addWidget(self.label_4, 5, 0, 1, 1)
        self.edit_duration = QtGui.QLineEdit(self.frame_controls)
        self.edit_duration.setObjectName(_fromUtf8("edit_duration"))
        self.gridLayout_3.addWidget(self.edit_duration, 6, 1, 1, 2)
        self.label_6 = QtGui.QLabel(self.frame_controls)
        self.label_6.setObjectName(_fromUtf8("label_6"))
        self.gridLayout_3.addWidget(self.label_6, 6, 0, 1, 1)
        self.spin_length = QtGui.QSpinBox(self.frame_controls)
        self.spin_length.setMaximum(100000000)
        self.spin_length.setProperty("value", 100)
        self.spin_length.setObjectName(_fromUtf8("spin_length"))
        self.gridLayout_3.addWidget(self.spin_length, 5, 1, 1, 2)
        self.label_2 = QtGui.QLabel(self.frame_controls)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.gridLayout_3.addWidget(self.label_2, 1, 0, 1, 1)
        self.edit_freq = QtGui.QLineEdit(self.frame_controls)
        self.edit_freq.setObjectName(_fromUtf8("edit_freq"))
        self.gridLayout_3.addWidget(self.edit_freq, 1, 1, 1, 1)
        self.widget = QtGui.QWidget(self.frame_controls)
        self.widget.setStyleSheet(_fromUtf8("background-color: #729fcf;\n"
"color: rgb(255, 255, 255);"))
        self.widget.setObjectName(_fromUtf8("widget"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget)
        self.horizontalLayout.setMargin(5)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.label_synth = QtGui.QLabel(self.widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_synth.sizePolicy().hasHeightForWidth())
        self.label_synth.setSizePolicy(sizePolicy)
        self.label_synth.setText(_fromUtf8(""))
        self.label_synth.setPixmap(QtGui.QPixmap(_fromUtf8(":/icons/synth.png")))
        self.label_synth.setObjectName(_fromUtf8("label_synth"))
        self.horizontalLayout.addWidget(self.label_synth)
        self.label_9 = QtGui.QLabel(self.widget)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_9.setFont(font)
        self.label_9.setObjectName(_fromUtf8("label_9"))
        self.horizontalLayout.addWidget(self.label_9)
        self.gridLayout_3.addWidget(self.widget, 0, 0, 1, 3)
        self.frame_3 = QtGui.QFrame(self.frame_controls)
        self.frame_3.setFrameShape(QtGui.QFrame.StyledPanel)
        self.frame_3.setFrameShadow(QtGui.QFrame.Raised)
        self.frame_3.setObjectName(_fromUtf8("frame_3"))
        self.gridLayout_4 = QtGui.QGridLayout(self.frame_3)
        self.gridLayout_4.setMargin(4)
        self.gridLayout_4.setObjectName(_fromUtf8("gridLayout_4"))
        self.label = QtGui.QLabel(self.frame_3)
        self.label.setAlignment(QtCore.Qt.AlignCenter)
        self.label.setObjectName(_fromUtf8("label"))
        self.gridLayout_4.addWidget(self.label, 0, 0, 1, 1)
        self.label_12 = QtGui.QLabel(self.frame_3)
        self.label_12.setAlignment(QtCore.Qt.AlignCenter)
        self.label_12.setObjectName(_fromUtf8("label_12"))
        self.gridLayout_4.addWidget(self.label_12, 0, 1, 1, 1)
        self.label_13 = QtGui.QLabel(self.frame_3)
        self.label_13.setAlignment(QtCore.Qt.AlignCenter)
        self.label_13.setObjectName(_fromUtf8("label_13"))
        self.gridLayout_4.addWidget(self.label_13, 0, 2, 1, 1)
        self.label_14 = QtGui.QLabel(self.frame_3)
        self.label_14.setAlignment(QtCore.Qt.AlignCenter)
        self.label_14.setObjectName(_fromUtf8("label_14"))
        self.gridLayout_4.addWidget(self.label_14, 0, 3, 1, 1)
        self.button_sine = QtGui.QPushButton(self.frame_3)
        self.button_sine.setText(_fromUtf8(""))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/sine.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_sine.setIcon(icon)
        self.button_sine.setIconSize(QtCore.QSize(64, 64))
        self.button_sine.setCheckable(True)
        self.button_sine.setChecked(True)
        self.button_sine.setFlat(True)
        self.button_sine.setObjectName(_fromUtf8("button_sine"))
        self.gridLayout_4.addWidget(self.button_sine, 1, 0, 1, 1)
        self.button_saw = QtGui.QPushButton(self.frame_3)
        self.button_saw.setText(_fromUtf8(""))
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/saw.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_saw.setIcon(icon1)
        self.button_saw.setIconSize(QtCore.QSize(64, 64))
        self.button_saw.setCheckable(True)
        self.button_saw.setFlat(True)
        self.button_saw.setObjectName(_fromUtf8("button_saw"))
        self.gridLayout_4.addWidget(self.button_saw, 1, 1, 1, 1)
        self.button_square = QtGui.QPushButton(self.frame_3)
        self.button_square.setText(_fromUtf8(""))
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/square.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_square.setIcon(icon2)
        self.button_square.setIconSize(QtCore.QSize(64, 64))
        self.button_square.setCheckable(True)
        self.button_square.setFlat(True)
        self.button_square.setObjectName(_fromUtf8("button_square"))
        self.gridLayout_4.addWidget(self.button_square, 1, 2, 1, 1)
        self.button_white_noise = QtGui.QPushButton(self.frame_3)
        self.button_white_noise.setText(_fromUtf8(""))
        icon3 = QtGui.QIcon()
        icon3.addPixmap(QtGui.QPixmap(_fromUtf8(":/icons/white_noise.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.button_white_noise.setIcon(icon3)
        self.button_white_noise.setIconSize(QtCore.QSize(64, 64))
        self.button_white_noise.setCheckable(True)
        self.button_white_noise.setFlat(True)
        self.button_white_noise.setObjectName(_fromUtf8("button_white_noise"))
        self.gridLayout_4.addWidget(self.button_white_noise, 1, 3, 1, 1)
        self.gridLayout_3.addWidget(self.frame_3, 2, 0, 1, 3)
        self.gridLayout.addWidget(self.frame_controls, 0, 2, 1, 1)
        spacerItem1 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem1, 0, 3, 1, 1)

        self.retranslateUi(synth_widget)
        QtCore.QMetaObject.connectSlotsByName(synth_widget)

    def retranslateUi(self, synth_widget):
        synth_widget.setWindowTitle(QtGui.QApplication.translate("synth_widget", "Form", None, QtGui.QApplication.UnicodeUTF8))
        self.label_7.setText(QtGui.QApplication.translate("synth_widget", "Volume", None, QtGui.QApplication.UnicodeUTF8))
        self.dial_volume.setToolTip(QtGui.QApplication.translate("synth_widget", "Set the volume of the sound", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_volume.setToolTip(QtGui.QApplication.translate("synth_widget", "Set the volume of the sound", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_volume.setSuffix(QtGui.QApplication.translate("synth_widget", "%", None, QtGui.QApplication.UnicodeUTF8))
        self.label_8.setText(QtGui.QApplication.translate("synth_widget", "Pan", None, QtGui.QApplication.UnicodeUTF8))
        self.dial_pan.setToolTip(QtGui.QApplication.translate("synth_widget", "Set the panning (left-right) of the sound", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_pan.setToolTip(QtGui.QApplication.translate("synth_widget", "Set the panning (left-right) of the sound", None, QtGui.QApplication.UnicodeUTF8))
        self.dial_decay.setToolTip(QtGui.QApplication.translate("synth_widget", "Set the decay (\"fade out\") of the sound", None, QtGui.QApplication.UnicodeUTF8))
        self.dial_attack.setToolTip(QtGui.QApplication.translate("synth_widget", "Set the attack (\"fade in\") of the sound", None, QtGui.QApplication.UnicodeUTF8))
        self.label_10.setText(QtGui.QApplication.translate("synth_widget", "Attack", None, QtGui.QApplication.UnicodeUTF8))
        self.label_11.setText(QtGui.QApplication.translate("synth_widget", "Decay", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_attack.setToolTip(QtGui.QApplication.translate("synth_widget", "Set the attack (\"fade in\") of the sound", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_attack.setSuffix(QtGui.QApplication.translate("synth_widget", "ms", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_decay.setToolTip(QtGui.QApplication.translate("synth_widget", "Set the decay (\"fade out\") of the sound", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_decay.setSuffix(QtGui.QApplication.translate("synth_widget", "ms", None, QtGui.QApplication.UnicodeUTF8))
        self.label_4.setText(QtGui.QApplication.translate("synth_widget", "Length", None, QtGui.QApplication.UnicodeUTF8))
        self.edit_duration.setToolTip(QtGui.QApplication.translate("synth_widget", "Set the duration of the synth item. Expecting a duration in ms, \'sound\' (to wait until the sound is finished playing), \'keypress\', \'mouseclick\', or a variable (e.g., \'[synth_dur]\').", None, QtGui.QApplication.UnicodeUTF8))
        self.edit_duration.setText(QtGui.QApplication.translate("synth_widget", "sound", None, QtGui.QApplication.UnicodeUTF8))
        self.label_6.setText(QtGui.QApplication.translate("synth_widget", "Duration", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_length.setToolTip(QtGui.QApplication.translate("synth_widget", "Set the length of the sound", None, QtGui.QApplication.UnicodeUTF8))
        self.spin_length.setSuffix(QtGui.QApplication.translate("synth_widget", "ms", None, QtGui.QApplication.UnicodeUTF8))
        self.label_2.setText(QtGui.QApplication.translate("synth_widget", "Frequency<br /><small><i>in Hertz (Hz) or by note, like \'A1\'</i></small>", None, QtGui.QApplication.UnicodeUTF8))
        self.edit_freq.setToolTip(QtGui.QApplication.translate("synth_widget", "The frequence of the sound. Expecting a numeric value (frequency in Hertz) a note (like \'C#2\' and \'A1\') or a variable (like \'[freq]\')", None, QtGui.QApplication.UnicodeUTF8))
        self.edit_freq.setText(QtGui.QApplication.translate("synth_widget", "A1", None, QtGui.QApplication.UnicodeUTF8))
        self.label_9.setText(QtGui.QApplication.translate("synth_widget", "Synth controls", None, QtGui.QApplication.UnicodeUTF8))
        self.label.setText(QtGui.QApplication.translate("synth_widget", "Sine wave", None, QtGui.QApplication.UnicodeUTF8))
        self.label_12.setText(QtGui.QApplication.translate("synth_widget", "Sawtooth wave", None, QtGui.QApplication.UnicodeUTF8))
        self.label_13.setText(QtGui.QApplication.translate("synth_widget", "Square wave", None, QtGui.QApplication.UnicodeUTF8))
        self.label_14.setText(QtGui.QApplication.translate("synth_widget", "White noise", None, QtGui.QApplication.UnicodeUTF8))
        self.button_sine.setToolTip(QtGui.QApplication.translate("synth_widget", "Generate a sine wav", None, QtGui.QApplication.UnicodeUTF8))
        self.button_saw.setToolTip(QtGui.QApplication.translate("synth_widget", "Generate a sawtooth wave", None, QtGui.QApplication.UnicodeUTF8))
        self.button_square.setToolTip(QtGui.QApplication.translate("synth_widget", "Generate a square wave", None, QtGui.QApplication.UnicodeUTF8))
        self.button_white_noise.setToolTip(QtGui.QApplication.translate("synth_widget", "Generate white noise", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = text_input_dialog_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/text_input_dialog.ui'
#
# Created: Sun Nov 18 18:16:40 2012
#      by: PyQt4 UI code generator 4.9.1
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_text_input_dialog(object):
    def setupUi(self, text_input_dialog):
        text_input_dialog.setObjectName(_fromUtf8("text_input_dialog"))
        text_input_dialog.resize(608, 233)
        self.verticalLayout = QtGui.QVBoxLayout(text_input_dialog)
        self.verticalLayout.setMargin(8)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.widget = QtGui.QWidget(text_input_dialog)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget.sizePolicy().hasHeightForWidth())
        self.widget.setSizePolicy(sizePolicy)
        self.widget.setStyleSheet(_fromUtf8("color: rgb(255, 255, 255);\n"
"background-color: #729fcf;"))
        self.widget.setObjectName(_fromUtf8("widget"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget)
        self.horizontalLayout.setMargin(5)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.label_text_input = QtGui.QLabel(self.widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_text_input.sizePolicy().hasHeightForWidth())
        self.label_text_input.setSizePolicy(sizePolicy)
        self.label_text_input.setText(_fromUtf8(""))
        self.label_text_input.setPixmap(QtGui.QPixmap(_fromUtf8(":/icons/about_large.png")))
        self.label_text_input.setObjectName(_fromUtf8("label_text_input"))
        self.horizontalLayout.addWidget(self.label_text_input)
        self.label_message = QtGui.QLabel(self.widget)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_message.setFont(font)
        self.label_message.setObjectName(_fromUtf8("label_message"))
        self.horizontalLayout.addWidget(self.label_message)
        self.verticalLayout.addWidget(self.widget)
        self.textedit_input = QtGui.QTextEdit(text_input_dialog)
        self.textedit_input.setAcceptRichText(False)
        self.textedit_input.setObjectName(_fromUtf8("textedit_input"))
        self.verticalLayout.addWidget(self.textedit_input)
        self.buttonBox = QtGui.QDialogButtonBox(text_input_dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName(_fromUtf8("buttonBox"))
        self.verticalLayout.addWidget(self.buttonBox)

        self.retranslateUi(text_input_dialog)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("accepted()")), text_input_dialog.accept)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), text_input_dialog.reject)
        QtCore.QMetaObject.connectSlotsByName(text_input_dialog)

    def retranslateUi(self, text_input_dialog):
        text_input_dialog.setWindowTitle(QtGui.QApplication.translate("text_input_dialog", "OpenSesame says ...", None, QtGui.QApplication.UnicodeUTF8))
        self.label_message.setText(QtGui.QApplication.translate("text_input_dialog", "Message", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = update_dialog_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/update_dialog.ui'
#
# Created: Thu Aug  2 12:43:06 2012
#      by: PyQt4 UI code generator 4.9.1
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_update_dialog(object):
    def setupUi(self, update_dialog):
        update_dialog.setObjectName(_fromUtf8("update_dialog"))
        update_dialog.resize(400, 299)
        self.verticalLayout = QtGui.QVBoxLayout(update_dialog)
        self.verticalLayout.setMargin(8)
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.widget = QtGui.QWidget(update_dialog)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget.sizePolicy().hasHeightForWidth())
        self.widget.setSizePolicy(sizePolicy)
        self.widget.setStyleSheet(_fromUtf8("color: rgb(255, 255, 255);\n"
"background-color: #729fcf;"))
        self.widget.setObjectName(_fromUtf8("widget"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget)
        self.horizontalLayout.setMargin(5)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.label_update_dialog = QtGui.QLabel(self.widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_update_dialog.sizePolicy().hasHeightForWidth())
        self.label_update_dialog.setSizePolicy(sizePolicy)
        self.label_update_dialog.setText(_fromUtf8(""))
        self.label_update_dialog.setPixmap(QtGui.QPixmap(_fromUtf8(":/icons/update_large.png")))
        self.label_update_dialog.setObjectName(_fromUtf8("label_update_dialog"))
        self.horizontalLayout.addWidget(self.label_update_dialog)
        self.label_2 = QtGui.QLabel(self.widget)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_2.setFont(font)
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.horizontalLayout.addWidget(self.label_2)
        self.verticalLayout.addWidget(self.widget)
        self.textedit_notification = QtGui.QTextBrowser(update_dialog)
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Monospace"))
        self.textedit_notification.setFont(font)
        self.textedit_notification.setObjectName(_fromUtf8("textedit_notification"))
        self.verticalLayout.addWidget(self.textedit_notification)
        self.checkbox_auto_check_update = QtGui.QCheckBox(update_dialog)
        self.checkbox_auto_check_update.setObjectName(_fromUtf8("checkbox_auto_check_update"))
        self.verticalLayout.addWidget(self.checkbox_auto_check_update)
        self.buttonBox = QtGui.QDialogButtonBox(update_dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Close)
        self.buttonBox.setObjectName(_fromUtf8("buttonBox"))
        self.verticalLayout.addWidget(self.buttonBox)

        self.retranslateUi(update_dialog)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("accepted()")), update_dialog.accept)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL(_fromUtf8("rejected()")), update_dialog.reject)
        QtCore.QMetaObject.connectSlotsByName(update_dialog)

    def retranslateUi(self, update_dialog):
        update_dialog.setWindowTitle(QtGui.QApplication.translate("update_dialog", "OpenSesame has checked for updates ...", None, QtGui.QApplication.UnicodeUTF8))
        self.label_2.setText(QtGui.QApplication.translate("update_dialog", "OpenSesame has checked for updates ...", None, QtGui.QApplication.UnicodeUTF8))
        self.checkbox_auto_check_update.setText(QtGui.QApplication.translate("update_dialog", "Check for updates on start-up", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = user_hint_widget_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/user_hint_widget.ui'
#
# Created: Thu Mar 14 21:01:43 2013
#      by: PyQt4 UI code generator 4.9.1
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_user_hint_widget(object):
    def setupUi(self, user_hint_widget):
        user_hint_widget.setObjectName(_fromUtf8("user_hint_widget"))
        user_hint_widget.resize(406, 37)
        self.horizontalLayout = QtGui.QHBoxLayout(user_hint_widget)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.label_user_hint = QtGui.QLabel(user_hint_widget)
        self.label_user_hint.setObjectName(_fromUtf8("label_user_hint"))
        self.horizontalLayout.addWidget(self.label_user_hint)
        self.button_edit_script = QtGui.QPushButton(user_hint_widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.button_edit_script.sizePolicy().hasHeightForWidth())
        self.button_edit_script.setSizePolicy(sizePolicy)
        self.button_edit_script.setObjectName(_fromUtf8("button_edit_script"))
        self.horizontalLayout.addWidget(self.button_edit_script)

        self.retranslateUi(user_hint_widget)
        QtCore.QMetaObject.connectSlotsByName(user_hint_widget)

    def retranslateUi(self, user_hint_widget):
        user_hint_widget.setWindowTitle(QtGui.QApplication.translate("user_hint_widget", "Form", None, QtGui.QApplication.UnicodeUTF8))
        self.label_user_hint.setToolTip(QtGui.QApplication.translate("user_hint_widget", "A list of user hints", None, QtGui.QApplication.UnicodeUTF8))
        self.label_user_hint.setText(QtGui.QApplication.translate("user_hint_widget", "User hints", None, QtGui.QApplication.UnicodeUTF8))
        self.button_edit_script.setToolTip(QtGui.QApplication.translate("user_hint_widget", "Click to open script editor", None, QtGui.QApplication.UnicodeUTF8))
        self.button_edit_script.setText(QtGui.QApplication.translate("user_hint_widget", "Edit script", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = webbrowser_widget_ui
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'resources/ui/webbrowser_widget.ui'
#
# Created: Fri Nov 23 12:45:18 2012
#      by: PyQt4 UI code generator 4.9.1
#
# WARNING! All changes made in this file will be lost!

from PyQt4 import QtCore, QtGui

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    _fromUtf8 = lambda s: s

class Ui_webbrowser_widget(object):
    def setupUi(self, webbrowser_widget):
        webbrowser_widget.setObjectName(_fromUtf8("webbrowser_widget"))
        webbrowser_widget.resize(402, 326)
        self.layout_main = QtGui.QVBoxLayout(webbrowser_widget)
        self.layout_main.setMargin(4)
        self.layout_main.setObjectName(_fromUtf8("layout_main"))
        self.widget = QtGui.QWidget(webbrowser_widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widget.sizePolicy().hasHeightForWidth())
        self.widget.setSizePolicy(sizePolicy)
        self.widget.setObjectName(_fromUtf8("widget"))
        self.horizontalLayout = QtGui.QHBoxLayout(self.widget)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setMargin(0)
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        self.button_back = QtGui.QPushButton(self.widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.button_back.sizePolicy().hasHeightForWidth())
        self.button_back.setSizePolicy(sizePolicy)
        self.button_back.setText(_fromUtf8(""))
        self.button_back.setFlat(True)
        self.button_back.setObjectName(_fromUtf8("button_back"))
        self.horizontalLayout.addWidget(self.button_back)
        self.button_osdoc = QtGui.QPushButton(self.widget)
        self.button_osdoc.setText(_fromUtf8(""))
        self.button_osdoc.setFlat(True)
        self.button_osdoc.setObjectName(_fromUtf8("button_osdoc"))
        self.horizontalLayout.addWidget(self.button_osdoc)
        self.button_forum = QtGui.QPushButton(self.widget)
        self.button_forum.setText(_fromUtf8(""))
        self.button_forum.setFlat(True)
        self.button_forum.setObjectName(_fromUtf8("button_forum"))
        self.horizontalLayout.addWidget(self.button_forum)
        self.edit_url = QtGui.QLineEdit(self.widget)
        self.edit_url.setReadOnly(True)
        self.edit_url.setObjectName(_fromUtf8("edit_url"))
        self.horizontalLayout.addWidget(self.edit_url)
        self.label_load_progress = QtGui.QLabel(self.widget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_load_progress.sizePolicy().hasHeightForWidth())
        self.label_load_progress.setSizePolicy(sizePolicy)
        font = QtGui.QFont()
        font.setItalic(True)
        self.label_load_progress.setFont(font)
        self.label_load_progress.setObjectName(_fromUtf8("label_load_progress"))
        self.horizontalLayout.addWidget(self.label_load_progress)
        self.layout_main.addWidget(self.widget)

        self.retranslateUi(webbrowser_widget)
        QtCore.QMetaObject.connectSlotsByName(webbrowser_widget)

    def retranslateUi(self, webbrowser_widget):
        webbrowser_widget.setWindowTitle(QtGui.QApplication.translate("webbrowser_widget", "Form", None, QtGui.QApplication.UnicodeUTF8))
        self.button_back.setToolTip(QtGui.QApplication.translate("webbrowser_widget", "Go back", None, QtGui.QApplication.UnicodeUTF8))
        self.button_osdoc.setToolTip(QtGui.QApplication.translate("webbrowser_widget", "Open OpenSesame documentation area", None, QtGui.QApplication.UnicodeUTF8))
        self.button_forum.setToolTip(QtGui.QApplication.translate("webbrowser_widget", "Open cogsci.nl forum", None, QtGui.QApplication.UnicodeUTF8))
        self.edit_url.setToolTip(QtGui.QApplication.translate("webbrowser_widget", "Address", None, QtGui.QApplication.UnicodeUTF8))
        self.label_load_progress.setToolTip(QtGui.QApplication.translate("webbrowser_widget", "Progress", None, QtGui.QApplication.UnicodeUTF8))
        self.label_load_progress.setText(QtGui.QApplication.translate("webbrowser_widget", "50%", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = backend_settings
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt4 import QtCore, QtGui
import sip
from libqtopensesame.misc import _
from libqtopensesame.ui.backend_settings_ui import \
	Ui_widget_backend_settings

class backend_settings(QtGui.QWidget):

	def __init__(self, main_window):
	
		self.main_window = main_window
		QtGui.QWidget.__init__(self, main_window)
		self.ui = Ui_widget_backend_settings()
		self.ui.setupUi(self)
		self.main_window.theme.apply_theme(self)
		self.tab_name = '__backend_settings__'
		
		for backend_type in ["canvas", "keyboard", "mouse", "synth", \
			"sampler"]:
			backend = self.main_window.experiment.get("%s_backend" \
				% backend_type)
			backend_module = __import__(u'openexp._%s.%s' % (backend_type, \
				backend), fromlist=[u'dummy'])
			_backend = getattr(backend_module, backend)
			group = getattr(self.ui, u'group_%s' % backend_type)
			layout = getattr(self.ui, u'layout_%s' % backend_type)
			label = getattr(self.ui, u'label_%s' % backend_type)
			# Horribly ugly way to clear the previous settings
			while layout.count() > 1:
				w = layout.itemAt(1)
				layout.removeItem(w)
				w.widget().hide()
				sip.delete(w)

			if not hasattr(_backend, "settings") or _backend.settings == \
				None:
				label.setText(_("No settings for %s") % backend)
			else:
				label.setText(_("Settings for %s:") % backend)
				layout.addWidget(settings_widget( \
					self.main_window.experiment, _backend.settings, self))
					
class settings_edit(QtGui.QLineEdit):

	"""An edit widget for a single variable"""

	def __init__(self, experiment, var, val, parent=None):

		"""
		Constructor

		Arguments:
		experiment -- the experiment
		var -- the variable name
		val -- the variable value

		Keywords arguments:
		parent -- parent QWidget (default=None)
		"""

		QtGui.QLineEdit.__init__(self, experiment.unistr(val))
		self._parent = parent
		self.var = var
		self.experiment = experiment
		self.editingFinished.connect(self.apply_setting)

	def apply_setting(self):

		"""Apply changes"""

		self.experiment.set(self.var, self.experiment.sanitize(self.text()))
		self._parent._parent.main_window.refresh()

class settings_widget(QtGui.QWidget):

	"""A widget containing a number of settings"""

	def __init__(self, experiment, settings, parent=None):

		"""
		Constructor

		Arguments:
		experiment -- the experiment
		settings -- the settings dictionary

		Keywords arguments:
		parent -- parent QWidget (default=None)
		"""

		QtGui.QWidget.__init__(self, parent)
		self._parent = parent
		self.experiment = experiment
		self.settings = settings
		self.layout = QtGui.QFormLayout(self)
		self.layout.setFieldGrowthPolicy(QtGui.QFormLayout.FieldsStayAtSizeHint)
		self.setLayout(self.layout)
		for var, desc in settings.items():
			if self.experiment.has(var):
				val = self.experiment.get(var)
			else:
				val = desc["default"]
			label = QtGui.QLabel()
			label.setText("%(name)s<br /><small><i>%(description)s</i></small>" % desc)
			label.setTextFormat(QtCore.Qt.RichText)
			edit = settings_edit(self.experiment, var, val, self)
			self.layout.addRow(label, edit)

########NEW FILE########
__FILENAME__ = color_edit
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt4 import QtCore, QtGui
from libopensesame import debug

class color_edit(QtGui.QWidget):

	"""A colorpicker QWidget with a QLineEdit and a QPushButton."""

	def __init__(self, parent=None):
	
		"""
		Constructor.
		
		Arguments:
		experiment	--	The experiment object.
		
		Keywords arguments:
		parent		--	The parent QWidget. (default=None)
		"""
	
		QtGui.QWidget.__init__(self, parent)		
		self.edit = QtGui.QLineEdit()
		self.edit.editingFinished.connect(self.apply)
		self.editingFinished = self.edit.editingFinished
		self.button = QtGui.QPushButton()
		self.button.setIconSize(QtCore.QSize(16,16))		
		self.button.clicked.connect(self.colorpicker)
		layout = QtGui.QHBoxLayout()				
		layout.setContentsMargins(0,0,0,0)
		layout.addWidget(self.edit)
		layout.addWidget(self.button)
		self.setLayout(layout)						

	def colorpicker(self):
	
		"""Picks a color with the colorpicker dialog."""
	
		color = self.experiment.colorpicker(self.experiment.sanitize( \
			self.text()))
		if color == None:
			return
		self.setText(color)
		self.apply()		

	def text(self):
	
		"""
		Returns the text (emulate QLineEdit behavior).
		
		Returns:
		A QString.
		"""
	
		return self.edit.text()
		
	def setText(self, s):
	
		"""
		Sets the text (emulate QLineEdit behavior).
		
		Arguments:
		s	--	The text.
		"""
	
		self.edit.setText(s)
		
	def apply(self):
	
		"""Emit a 'set_color' signal to indicate that a color has been picker"""		
		
		self.emit(QtCore.SIGNAL(u'set_color'))
		
	def initialize(self, experiment, color=None):
	
		"""
		Initializes the widget.
		
		Arguments:
		experiment	--	The experiment object.
		
		Keyword arguments:
		color		--	A color to start with or None for experiment foreground
						default. (default=None)
		"""
		
		debug.msg(u'color = %s' % color)
		self.experiment = experiment
		if color == None:
			color = self.experiment.get(u'foreground', _eval=False)
		self.setText(color)
		self.button.setIcon(self.experiment.icon(u'colorpicker'))
		

########NEW FILE########
__FILENAME__ = credits_widget
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import misc
from libqtopensesame.misc import config
from libqtopensesame.ui.credits_widget_ui import Ui_widget_credits
from PyQt4 import QtGui, QtCore

class credits_widget(QtGui.QWidget):

	"""A widget with the opensesame credits"""

	def __init__(self, parent=None):
	
		"""
		Constructor

		Keywords arguments:
		parent -- the parent QWidget
		"""	
	
		QtGui.QTabWidget.__init__(self, parent)		
		self.ui = Ui_widget_credits()
		self.ui.setupUi(self)
		
	def initialize(self, main_window):
	
		self.main_window = main_window
		self.main_window.theme.apply_theme(self)
		self.ui.label_opensesame.setText(unicode( \
			self.ui.label_opensesame.text()).replace("[version]", \
			misc.version).replace("[codename]", misc.codename))			
		self.ui.label_website.mousePressEvent = self.open_website
		self.ui.label_facebook.mousePressEvent = self.open_facebook
		self.ui.label_twitter.mousePressEvent = self.open_twitter
			
	def open_website(self, dummy=None):
	
		"""Open the main website"""
		
		misc.open_url(config.get_config("url_website"))
		
	def open_facebook(self, dummy=None):
	
		"""Open Facebook page"""	

		misc.open_url(config.get_config("url_facebook"))

	def open_twitter(self, dummy=None):
	
		"""Open Twitter page"""	
	
		misc.open_url(config.get_config("url_twitter"))					
		

########NEW FILE########
__FILENAME__ = draggables
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import sip
from PyQt4 import QtGui, QtCore
from libqtopensesame.widgets import item_context_menu
from libqtopensesame.misc import _

drop_target = None

class draggable_handle(QtGui.QLabel):

	"""The draggable handles for re-ordering the list"""

	def __init__(self, parent=None):

		"""
		Constructor

		Keywords arguments:
		parent -- the parent widget
		"""

		QtGui.QLabel.__init__(self)
		self.setPixmap( \
			parent._list.sequence.experiment.main_window.theme.qpixmap( \
			"handle"))
		self.setAcceptDrops(True)
		self.setCursor(QtCore.Qt.OpenHandCursor)
		self.container = parent
		self.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
		self.setToolTip(_("Drag this item to re-order"))

	def valid_drag(self, mime_data):

		"""
		Checks if mime data corresponds to a valid drag operation

		Arguments:
		mime_data -- the mime data

		Returns:
		True or False
		"""

		if mime_data.hasText():
			l = mime_data.text().split(" ")
			if len(l) == 2 and l[0] in ["__osdrag__", "__osnew__"]:
				return True
		return False


	def index_from_mime_data(self, mime_data):

		"""
		Extract the item index from a mime data

		Returns:
		An item index or -1 if the mime data was invalid
		"""

		if mime_data.hasText():
			l = mime_data.text().split(" ")
			if len(l) == 2 and l[0] == "__osdrag__":
				try:
					return int(l[1])
				except:
					pass
		return -1

	def dragEnterEvent(self, e):

		"""
		Handle incoming drags

		Arguments:
		e -- a QDragEvent
		"""

		if self.valid_drag(e.mimeData()):
			e.accept()
		else:
			e.ignore()

	def dropEvent(self, e):

		"""
		Handle incoming drops

		Arguments:
		e -- a QDragEvent
		"""

		global drop_target

		if self.valid_drag(e.mimeData()):
			from_index = self.index_from_mime_data(e.mimeData())
			if from_index >= 0:
				e.accept()
				self.container._list.sequence.move(from_index, \
					self.container.index)
			else:
				drop_target = self.container._list.sequence.name, \
					self.container.index, False
				e.setDropAction(QtCore.Qt.CopyAction)
				e.accept()
		else:
			e.ignore()

	def mouseMoveEvent(self, e):

		"""
		Start drags

		Arguments:
		e -- a QMouseEvent
		"""

		mime_data = QtCore.QMimeData()
		mime_data.setText("__osdrag__ %d" % self.container.index)
		drag = QtGui.QDrag(self)
		drag.setMimeData(mime_data)
		drag.setHotSpot(e.pos() - self.rect().topLeft())
		dropAction = drag.start(QtCore.Qt.MoveAction)

class run_if_edit(QtGui.QLineEdit):

	"""Item 'run if' edit"""

	def __init__(self, parent):

		"""
		Constructor

		Arguments:
		parent -- the parent container
		"""

		QtGui.QLineEdit.__init__(self, parent.item[1])
		self.container = parent
		self.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
		self.editingFinished.connect(self.change)
		self.setToolTip(_("Run this item only under the following conditions"))

	def change(self):

		"""Apply changes"""

		self.container._list.sequence.set_run_if(self.container.index, \
			self.text())

class open_button(QtGui.QPushButton):

	"""A button containing the item icon and name"""

	def __init__(self, item, parent):

		"""
		Constructor

		Arguments:
		item -- the item tuple (name, run_if)
		parent -- the parent container
		"""

		item_type = parent._list.sequence.experiment.items[item[0]].item_type
		icon = parent._list.sequence.experiment.icon(item_type)
		QtGui.QPushButton.__init__(self, icon, item[0], parent)
		self.setObjectName("sequence_open_button")
		self.container = parent
		self.item = item
		self.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
		self.setFlat(True)
		self.setIconSize(QtCore.QSize(32,16))
		self.clicked.connect(self.open_item_tab)
		self.setToolTip(_("Click to edit this item"))

	def open_item_tab(self):

		"""Open the item's tab"""

		self.container._list.sequence.experiment.items[self.item[0]].open_tab()

	def mousePressEvent(self, e):

		"""
		Open the tab on a left click and show the context menu on a right click

		Arguments:
		e -- a QMouseEvent
		"""

		if e.button() == QtCore.Qt.LeftButton:
			QtGui.QPushButton.mousePressEvent(self, e)
		elif e.button() == QtCore.Qt.RightButton:
			item = self.container._list.sequence.experiment.items[self.item[0]]
			m = item_context_menu.item_context_menu("Item", self, item,
				self.container._list.sequence.name, self.container.index)
			m.popup(e.globalPos())

class draggable_widget_container(QtGui.QFrame):

	"""A container for a single item"""

	def __init__(self, parent, item, index):

		"""
		Constructor

		Arguments:
		parent -- the parent draggable_list
		item -- the item tuple (name, run_if)
		index -- the index of the item in the sequence
		"""

		QtGui.QFrame.__init__(self, parent)
		self.setObjectName("sequence_container")
		self.item = item
		self.setFrameStyle(QtGui.QFrame.Panel)
		self._list = parent
		self.handle = draggable_handle(self)
		self.run_if_edit = run_if_edit(self)
		self.index = index
		self._layout = QtGui.QHBoxLayout()
		self._layout.addWidget(self.handle)
		self._layout.addWidget(open_button(item, self))
		self._layout.addStretch()
		self._layout.addWidget(QtGui.QLabel(_("<small><i>Run if</i></small>")))
		self._layout.addWidget(self.run_if_edit)
		self.setLayout(self._layout)
		self._layout.setContentsMargins(4, 4, 4, 4)
		self.setMinimumSize(100,32)
		self.setSizePolicy(QtGui.QSizePolicy.MinimumExpanding, \
			QtGui.QSizePolicy.Fixed)

class draggable_list(QtGui.QWidget):

	"""The main draggable list"""

	def __init__(self, sequence):

		"""
		Constructor

		Arguments:
		sequence -- the parent sequence item
		"""

		QtGui.QWidget.__init__(self)
		self.items = []
		self.sequence = sequence
		self._layout = QtGui.QVBoxLayout()
		self._layout.setContentsMargins(4, 4, 4, 16)
		self._layout.setSpacing(0)
		self.setLayout(self._layout)
		self.widgets = []
		self.setSizePolicy(QtGui.QSizePolicy.MinimumExpanding, \
			QtGui.QSizePolicy.MinimumExpanding)

	def refresh(self):

		"""Refresh the view"""

		for widget in self.widgets:
			self._layout.removeWidget(widget)
			widget.hide()
			del widget
		self.widgets = []

		for i in range(len(self.sequence.items)):
			item_name = self.sequence.items[i][0]
			if  item_name not in self.sequence.experiment.items:
				self.sequence.experiment.notify( \
					_("Unkown item '%s' in sequence '%s'. You can fix this using the script editor.") \
					% (item_name, self.sequence.name))
			else:
				widget = draggable_widget_container(self, \
					self.sequence.items[i], i)
				self.widgets.append(widget)
				self._layout.addWidget(widget)

		spacer = QtGui.QWidget()
		self.widgets.append(spacer)
		self._layout.addWidget(spacer)



########NEW FILE########
__FILENAME__ = font_widget
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt4 import QtCore, QtGui
from libqtopensesame.ui import font_widget_ui
from libqtopensesame.misc import _

class font_widget(QtGui.QWidget):

	"""A font selection widget"""

	max_size = 64
	font_list = [u'mono', u'sans', u'serif', u'arabic', \
		u'chinese-japanese-korean', u'hebrew', u'hindi', _(u'other ...', \
		context=u'font_widget')]

	def __init__(self, parent=None):

		"""
		Constructor.

		Arguments:
		experiment	--	The experiment.

		Keywords arguments:
		parent		--	The parent QWidget. (default=None)
		"""

		QtGui.QWidget.__init__(self, parent)
		self.ui = font_widget_ui.Ui_font_widget()
		self.ui.setupUi(self)

	def _apply(self):

		"""Applies the controls."""

		self.family = self.ui.combobox_family.currentText()
		self.size = self.ui.spinbox_size.value()
		self.italic = self.ui.checkbox_italic.isChecked()
		self.bold = self.ui.checkbox_bold.isChecked()
		self.ui.label_example.setFont(self.get_font())
		self.emit(QtCore.SIGNAL(u"font_changed"))

	def apply_family(self):

		"""
		Applies the controls and optionally presents a full font selection
		dialog if the user has selected 'other ...'
		"""

		if self.ui.combobox_family.currentText() == _(u'other ...', context= \
			u'font_widget'):
			font, ok = QtGui.QFontDialog.getFont(self.get_font())
			if ok:
				self.family = unicode(font.family())
			else:
				self.family = self.experiment.get(u'font_family')
			self.update_family_combobox()
		self._apply()

	def get_font(self):

		"""
		Make a QFont based on the settings

		Returns:
		A QFont
		"""

		if self.bold:
			weight = QtGui.QFont.Bold
		else:
			weight = QtGui.QFont.Normal
		return QtGui.QFont(self.family, min(self.max_size, self.size), weight, \
			self.italic)

	def initialize(self, experiment, family=None, italic=None, bold=None, \
		size=None):

		"""
		Initializes the widget.

		Arguments:
		experiment	--	The experiment.

		Keyword arguments:
		family		--	The font family or None to use experiment default.
						(default=None)
		italic		--	The font italic state or None to use experiment default.
						(default=None)
		bold		--	The font bold state or None to use experiment default.
						(default=None)
		size		--	The font size or None to use experiment default.
						(default=None)
		"""

		self.experiment = experiment
		if family == None:
			self.family = self.experiment.get(u'font_family')
		else:
			self.family = family
		if italic == None:
			self.italic = self.experiment.get(u'font_italic') == u'yes'
		else:
			self.italic = italic
		if bold == None:
			self.bold = self.experiment.get(u'font_bold') == u'yes'
		else:
			self.bold = bold
		if size == None:
			self.size = self.experiment.get(u'font_size')
		else:
			self.size = size
		if self.ui.combobox_family.findText(self.family) < 0:
			self.ui.combobox_family.addItem(self.family)
		self.ui.combobox_family.setCurrentIndex( \
			self.ui.combobox_family.findText(self.family))
		self.ui.checkbox_italic.setChecked(self.italic)
		self.ui.checkbox_bold.setChecked(self.bold)
		self.ui.spinbox_size.setValue(self.size)
		self._apply()
		self.ui.combobox_family.currentIndexChanged.connect( \
			self.apply_family)
		self.ui.checkbox_italic.toggled.connect(self._apply)
		self.ui.checkbox_bold.toggled.connect(self._apply)
		self.ui.spinbox_size.valueChanged.connect(self._apply)

	def update_family_combobox(self):

		"""Updates the family combobox to include a custom font."""

		self.ui.combobox_family.currentIndexChanged.disconnect()
		self.ui.combobox_family.clear()
		l = self.font_list[:]
		if self.family not in l:
			l += [self.family]
		self.ui.combobox_family.insertItems(0, l)
		self.ui.combobox_family.setCurrentIndex( \
			self.ui.combobox_family.findText(self.family))
		self.ui.combobox_family.currentIndexChanged.connect( \
			self.apply_family)

########NEW FILE########
__FILENAME__ = general_properties
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import debug
from PyQt4 import QtCore, QtGui
from libopensesame import misc
from libqtopensesame.misc import _
import libopensesame.exceptions
from libqtopensesame.ui import general_widget_ui
from libqtopensesame.widgets import color_edit, header_widget
from libqtopensesame.items import experiment
from libqtopensesame.misc import config
import openexp.backend_info
import sip

class general_properties(QtGui.QWidget):

	"""The QWidget for the general properties tab."""

	backend_format = u'%s [%s]'

	def __init__(self, parent=None):

		"""
		Constructor.

		Keywords arguments:
		parent 	--	The parent QWidget. (default=None)
		"""

		self.main_window = parent
		QtGui.QWidget.__init__(self)
		# Set the header, with the icon, label and script button
		self.header_widget = general_header_widget(self, \
			self.main_window.experiment)
		button_help = QtGui.QPushButton(self.main_window.experiment.icon( \
			u"help"), u"")
		button_help.setIconSize(QtCore.QSize(16, 16))
		button_help.clicked.connect( \
			self.main_window.ui.tabwidget.open_general_help)
		button_help.setToolTip(_(u"Tell me more about OpenSesame!"))
		header_hbox = QtGui.QHBoxLayout()
		header_hbox.addWidget(self.main_window.experiment.label_image( \
			u"experiment"))
		header_hbox.addWidget(self.header_widget)
		header_hbox.addStretch()
		header_hbox.addWidget(button_help)
		header_hbox.setContentsMargins(0, 0, 0, 0)
		header_widget = QtGui.QWidget()
		header_widget.setLayout(header_hbox)

		# The rest of the controls from the UI file
		w = QtGui.QWidget()
		self.ui = general_widget_ui.Ui_general_widget()
		self.ui.setupUi(w)
		self.main_window.theme.apply_theme(self)

		# Initialize the color and font widgets
		self.ui.edit_foreground.initialize(self.main_window.experiment)
		self.ui.edit_background.initialize(self.main_window.experiment)
		QtCore.QObject.connect(self.ui.edit_foreground, QtCore.SIGNAL( \
			u"set_color"), self.apply_changes)
		QtCore.QObject.connect(self.ui.edit_background, QtCore.SIGNAL( \
			u"set_color"), self.apply_changes)
		self.ui.widget_font.initialize(self.main_window.experiment)
		QtCore.QObject.connect(self.ui.widget_font, QtCore.SIGNAL( \
			u"font_changed"), self.apply_changes)

		# Connect the rest
		self.ui.spinbox_width.editingFinished.connect(self.apply_changes)
		self.ui.spinbox_height.editingFinished.connect(self.apply_changes)
		self.ui.button_script_editor.clicked.connect( \
			self.main_window.ui.tabwidget.open_general_script)
		self.ui.button_backend_settings.clicked.connect( \
			self.main_window.ui.tabwidget.open_backend_settings)

		# Set the backend combobox
		for backend in openexp.backend_info.backend_list:
			desc = openexp.backend_info.backend_list[backend][u"description"]
			icon = openexp.backend_info.backend_list[backend][u"icon"]
			self.ui.combobox_backend.addItem(self.main_window.theme.qicon( \
				icon), self.backend_format % (backend, desc))
		self.ui.combobox_backend.currentIndexChanged.connect(self.apply_changes)

		# Variable transparency
		self.ui.checkbox_transparent_variables.stateChanged.connect( \
			self.apply_changes)
		# Bi-directional-text support
		self.ui.checkbox_bidi.stateChanged.connect(self.apply_changes)

		vbox = QtGui.QVBoxLayout()
		vbox.addWidget(header_widget)
		vbox.addWidget(w)

		self.setLayout(vbox)
		self.tab_name = u'__general_properties__'
		self.on_activate = self.refresh

	def set_header_label(self):

		"""
		Sets the general header based on the experiment title and description.
		"""

		self.header_widget.edit_name.setText(self.main_window.experiment.title)
		self.header_widget.label_name.setText( \
			u"<font size='5'><b>%s</b> - Experiment</font>&nbsp;&nbsp;&nbsp;<font color='gray'><i>Click to edit</i></font>" \
			% self.main_window.experiment.title)
		self.header_widget.edit_desc.setText( \
			self.main_window.experiment.description)
		self.header_widget.label_desc.setText(\
			self.main_window.experiment.description)

	def apply_changes(self):

		"""Applies changes to the general tab."""

		# Skip if the general tab is locked and lock it otherwise
		if self.lock:
			return
		self.lock = True

		debug.msg()
		rebuild_item_tree = False
		self.main_window.set_busy(True)
		# Set the title and the description
		title = self.main_window.experiment.sanitize( \
			self.header_widget.edit_name.text())
		self.main_window.experiment.set(u"title", title)
		desc = self.main_window.experiment.sanitize( \
			self.header_widget.edit_desc.text())
		self.main_window.experiment.set(u"description", desc)

		# Set the backend
		if self.ui.combobox_backend.isEnabled():
			i = self.ui.combobox_backend.currentIndex()
			backend = openexp.backend_info.backend_list.values()[i]
			self.main_window.experiment.set(u"canvas_backend", \
				backend[u"canvas"])
			self.main_window.experiment.set(u"keyboard_backend", \
				backend[u"keyboard"])
			self.main_window.experiment.set(u"mouse_backend", \
				backend[u"mouse"])
			self.main_window.experiment.set(u"sampler_backend", \
				backend[u"sampler"])
			self.main_window.experiment.set(u"synth_backend", \
				backend[u"synth"])
		else:
			debug.msg( \
				u'not setting back-end, because a custom backend is selected')

		# Set the display width
		width = self.ui.spinbox_width.value()
		if self.main_window.experiment.get(u"width") != width:
			self.main_window.update_resolution(width, \
				self.main_window.experiment.get(u"height"))

		# Set the display height
		height = self.ui.spinbox_height.value()
		if self.main_window.experiment.get(u"height") != height:
			self.main_window.update_resolution( \
				self.main_window.experiment.get(u"width"), height)

		# Set the foreground color
		foreground = self.main_window.experiment.sanitize( \
			self.ui.edit_foreground.text())
		refs = []
		try:
			refs = self.main_window.experiment.get_refs(foreground)
			self.main_window.experiment.color_check(foreground)
		except Exception as e:
			if refs == []:
				self.main_window.experiment.notify(e)
				foreground = self.main_window.experiment.get(u"foreground")
				self.ui.edit_foreground.setText(foreground)
		self.main_window.experiment.set(u"foreground", foreground)

		# Set the background color
		background = self.main_window.experiment.sanitize( \
			self.ui.edit_background.text())
		refs = []
		try:
			refs = self.main_window.experiment.get_refs(background)
			self.main_window.experiment.color_check(background)
		except Exception as e:
			if refs == []:
				self.main_window.experiment.notify(e)
				background = self.main_window.experiment.get(u"background")
				self.ui.edit_background.setText(background)
		self.main_window.experiment.set(u"background", foreground)
		self.main_window.experiment.set(u"background", background)

		# Set the font
		self.main_window.experiment.set(u'font_family', \
			self.ui.widget_font.family)
		self.main_window.experiment.set(u'font_size', \
			self.ui.widget_font.size)
		self.main_window.experiment.set(u'font_italic', \
			self.ui.widget_font.italic)
		self.main_window.experiment.set(u'font_bold', \
			self.ui.widget_font.bold)
		# Set variable transparency
		self.main_window.experiment.set(u'transparent_variables', \
			self.ui.checkbox_transparent_variables.isChecked())
		# Set bi-directional text
		self.main_window.experiment.set(u'bidi', \
			self.ui.checkbox_bidi.isChecked())

		# Refresh the interface and unlock the general tab
		self.main_window.refresh()
		self.lock = False
		self.main_window.set_busy(False)

	def refresh(self):

		"""Update the controls of the general tab"""

		debug.msg()

		# Lock the general tab to prevent a recursive loop
		self.lock = True

		# Set the header containing the titel etc
		self.set_header_label()

		# Select the backend
		backend = openexp.backend_info.match(self.main_window.experiment)
		if backend == u"custom":
			self.ui.combobox_backend.setDisabled(True)
		else:
			self.ui.combobox_backend.setDisabled(False)
			desc = openexp.backend_info.backend_list[backend][u"description"]
			i = self.ui.combobox_backend.findText(self.backend_format \
				% (backend, desc))
			self.ui.combobox_backend.setCurrentIndex(i)

		# Set the resolution
		try:
			self.ui.spinbox_width.setValue(int( \
				self.main_window.experiment.width))
			self.ui.spinbox_height.setValue(int( \
				self.main_window.experiment.height))
		except:
			self.main_window.experiment.notify( \
				_(u"Failed to parse the resolution. Expecting positive numeric values."))

		# Set the colors
		self.ui.edit_foreground.setText(self.main_window.experiment.unistr( \
			self.main_window.experiment.foreground))
		self.ui.edit_background.setText(self.main_window.experiment.unistr( \
			self.main_window.experiment.background))

		# Set the font
		self.ui.widget_font.initialize(self.main_window.experiment)
		# Set variable transparency
		self.ui.checkbox_transparent_variables.setChecked( \
			self.main_window.experiment.get(u'transparent_variables') == u'yes')
		# Set bidirectional text
		self.ui.checkbox_bidi.setChecked(self.main_window.experiment.get( \
			u'bidi') == u'yes')
		# Release the general tab
		self.lock = False

class general_header_widget(header_widget.header_widget):

	"""
	The widget containing the clickable title and description of the experiment
	"""

	def __init__(self, general_tab, item):

		"""
		Constructor

		Arguments:
		item -- the experiment
		"""

		header_widget.header_widget.__init__(self, item)
		self.general_tab = general_tab
		self.label_name.setText( \
			u"<font size='5'><b>%s</b> - Experiment</font>&nbsp;&nbsp;&nbsp;<font color='gray'><i>Click to edit</i></font>" \
			% self.item.get(u"title", _eval=False))

	def restore_name(self):

		"""Apply the name change, hide the editable title and show the label"""

		self.general_tab.apply_changes()
		self.label_name.setText( \
			u"<font size='5'><b>%s</b> - Experiment</font>&nbsp;&nbsp;&nbsp;<font color='gray'><i>Click to edit</i></font>" \
			% self.item.get(u"title", _eval=False))
		self.label_name.show()
		self.edit_name.setText(self.item.get(u"title", _eval=False))
		self.edit_name.hide()

	def restore_desc(self):

		"""
		Apply the description change, hide the editable description and show the label
		"""

		self.general_tab.apply_changes()
		self.label_desc.setText(self.item.get(u"description", _eval=False))
		self.label_desc.show()
		self.edit_desc.setText(self.item.get(u"description", _eval=False))
		self.edit_desc.hide()

########NEW FILE########
__FILENAME__ = general_script_editor
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt4 import QtCore, QtGui
from libqtopensesame.misc import _
from libqtopensesame.ui.general_script_editor_ui import \
	Ui_widget_general_script_editor
from libqtopensesame.misc.config import cfg

class general_script_editor(QtGui.QWidget):

	"""The general script editor"""

	def __init__(self, main_window):
	
		"""
		Constructor
		
		Arguments:
		main_window -- the main window
		"""	
	
		from QProgEdit import QTabManager
		
		self.main_window = main_window
		QtGui.QWidget.__init__(self, main_window)
		self.ui = Ui_widget_general_script_editor()
		self.ui.setupUi(self)
		self.ui.qprogedit = QTabManager(handler=self._apply, defaultLang= \
			u'OpenSesame', handlerButtonText=u'Apply', cfg=cfg)
		self.ui.qprogedit.addTab(u'General script')
		self.ui.layout_vbox.addWidget(self.ui.qprogedit)
		self.main_window.theme.apply_theme(self)
		self.tab_name = '__general_script__'
		
	def _apply(self):
	
		"""Confirm and apply the script changes"""
		
		resp = QtGui.QMessageBox.question(self.main_window, _('Apply?'), \
			_('Are you sure you want to apply the changes to the general script?'), \
			QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)
		if resp == QtGui.QMessageBox.No:
			return	
		self.main_window.dispatch.event_regenerate.emit( \
			self.ui.qprogedit.text())
				
	def on_activate(self):
		
		"""Refresh the tab when it is activated"""
	
		self.refresh()
		
	def refresh(self):
	
		"""Refresh the contents of the general script"""
		
		self.ui.qprogedit.setText(self.main_window.experiment.to_string())

########NEW FILE########
__FILENAME__ = good_looking_table
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt4 import QtCore, QtGui

class good_looking_table(QtGui.QTableWidget):

	"""Extended the QTableWidget for copy-pasting, etc."""

	def __init__(self, rows, columns=None, icons={}, parent=None):

		"""
		Constructor.

		Arguments:
		rows	--	The number of rows.

		Keywords arguments:
		columns	--	The number of columns or None for no columns. (default=None)
		icons	--	A dictionary with QIcons for the various actions.
					(default={})
		parent	--	The parent QWidget. (default=None)
		"""

		self.clipboard = QtGui.QApplication.clipboard
		self.build_context_menu(icons)
		# If there is only one parameter, this is the parent
		if columns == None:
			QtGui.QTableWidget.__init__(self, rows)
		else:
			QtGui.QTableWidget.__init__(self, rows, columns, parent)
		self.setGridStyle(QtCore.Qt.DotLine)
		self.setAlternatingRowColors(True)

	def build_context_menu(self, icons={}):

		"""
		Builds the context menu.

		Keyword arguments:
		icons	--	A dictionary with icon names. (default={})
		"""

		self.menu = QtGui.QMenu()
		if "cut" in icons:
			self.menu.addAction(icons["cut"], "Cut", self.cut)
		else:
			self.menu.addAction("Cut", self.cut)
		if "copy" in icons:
			self.menu.addAction(icons["copy"], "Copy", self.copy)
		else:
			self.menu.addAction("Copy", self.copy)
		if "paste" in icons:
			self.menu.addAction(icons["paste"], "Paste", self.paste)
		else:
			self.menu.addAction("Paste", self.paste)
		if "clear" in icons:
			self.menu.addAction(icons["clear"], "Clear", self._clear)
		else:
			self.menu.addAction("Clear", self._clear)

	def contextMenuEvent(self, e):

		"""
		Presents the context menu.

		Arguments:
		e	--	a QContextMenuEvent.
		"""

		self.pos = e.globalPos()
		self.menu.exec_(self.pos)

	def keyPressEvent(self, e):

		"""
		Captures keypresses to handle copy, cut, and paste.

		Arguments:
		e	--	a QKeyEvent.
		"""

		if e.key() == QtCore.Qt.Key_Delete:
			self._clear()
			e.ignore()
		elif e.modifiers() == QtCore.Qt.ControlModifier and e.key() == \
			QtCore.Qt.Key_X:
			self.cut()
			e.ignore()
		elif e.modifiers() == QtCore.Qt.ControlModifier and e.key() == \
			QtCore.Qt.Key_C:
			self.copy()
			e.ignore()
		elif e.modifiers() == QtCore.Qt.ControlModifier and e.key() == \
			QtCore.Qt.Key_V:
			self.paste()
			e.ignore()
		else:
			QtGui.QTableWidget.keyPressEvent(self, e)

	def cut(self):

		"""Cuts text from the table into the clipboard (copy + clear = cut)"""

		self.copy()
		self._clear()

	def copy(self):

		"""Copies data from the table into the clipboard."""

		_range = self.selectedRanges()[0]
		rows = []
		for row in range(_range.topRow(), _range.bottomRow()+1):
			columns = []
			for column in range(_range.leftColumn(), _range.rightColumn()+1):
				item = self.item(row, column)
				if item != None:
					value = unicode(item.text())
				else:
					value = u''
				columns.append(value)
			rows.append(u'\t'.join(columns))
		selection = u'\n'.join(rows)
		self.clipboard().setText(selection)

	def paste(self):

		"""Pastes text from the clipboard into the table."""

		selection = unicode(self.clipboard().mimeData().text())
		rows = selection.split(u'\n')
		current_row = self.currentRow()
		for row in rows:
			cells = row.split(u'\t')
			current_column = self.currentColumn()
			for cell in cells:
				if current_column >= self.columnCount():
					break
				item = QtGui.QTableWidgetItem()
				item.setText(cell)
				self.setItem(current_row, current_column, item)
				current_column += 1
			current_row += 1

	def _clear(self):

		"""Clears the selected cells."""

		selected_range = self.selectedRanges()[0]
		for row in range(selected_range.topRow(), selected_range.bottomRow() + \
			1):
			for column in range(selected_range.leftColumn(), \
				selected_range.rightColumn() + 1):
				item = self.item(row, column)
				if item != None:
					item.setText(u'')

	def get_contents(self):

		"""
		Gets the contents of the table.

		Returns:
		A QStringList for the table contents.
		"""

		contents = QtCore.QStringList()
		for row in range(self.rowCount()):
			for column in range(self.columnCount()):
				i = self.item(row, column)
				if i != None:
					contents.append(i.text())
				else:
					contents.append(QtCore.QString())
		return contents

	def set_contents(self, contents):

		"""
		Sets the table contents.

		Arguments:
		contents	--	a QStringList.
		"""

		column = 0
		row = 0
		for i in contents:
			# Set the item
			item = QtGui.QTableWidgetItem()
			item.setText(i)
			self.setItem(row, column, item)
			# Advance to next cell with wraparound
			column += 1
			if column == self.columnCount():
				row += 1
				column = 0

if __name__ == "__main__":

	"""If called standalone, this class shows a demo table"""

	import sys
	app = QtGui.QApplication(sys.argv)
	widget = good_looking_table(10, 10)
	widget.setWindowTitle("Good looking table")
	widget.show()
	app.exec_()
	print(widget.get_contents())


########NEW FILE########
__FILENAME__ = header_widget
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

__author__ = "Sebastiaan Mathot"
__license__ = "GPLv3"

from PyQt4 import QtCore, QtGui
from libopensesame import debug
from libqtopensesame.misc import _

class header_widget(QtGui.QWidget):

	"""Editable labels for the item's name and description"""

	def __init__(self, item):

		"""
		Constructor

		Arguments:
		item -- the item to provide a header for
		"""

		QtGui.QWidget.__init__(self)
		self.setCursor(QtCore.Qt.IBeamCursor)
		self.setToolTip(_(u"Click to edit"))
		self.item = item
		self.label_name = QtGui.QLabel()
		self.label_name.id = u"name"
		self.edit_name = QtGui.QLineEdit()
		self.edit_name.editingFinished.connect(self.restore_name)
		self.edit_name.hide()
		self.label_desc = QtGui.QLabel()
		self.label_desc.id = u"desc"
		self.edit_desc = QtGui.QLineEdit()
		self.edit_desc.editingFinished.connect(self.restore_desc)
		self.edit_desc.hide()
			
		vbox = QtGui.QVBoxLayout()
		vbox.setContentsMargins(8, 0, 0, 0)
		vbox.setSpacing(0)
		vbox.addWidget(self.label_name)
		vbox.addWidget(self.edit_name)
		vbox.addWidget(self.label_desc)
		vbox.addWidget(self.edit_desc)		
		self.refresh()
		self.setLayout(vbox)

	def refresh(self):

		"""Update the header"""

		self.edit_name.setText(self.item.name)
		self.label_name.setText( \
			u"<font size='5'><b>%s</b> - %s</font>&nbsp;&nbsp;&nbsp;<font color='gray'><i>Click to edit</i></font>" \
			% (self.item.name, self.item.item_type.replace(u"_", u" ").title()))
		self.edit_desc.setText(self.item.description)
		self.label_desc.setText(self.item.description)

	def restore_name(self, apply_name_change=True):

		"""
		Apply the name change and revert the edit control back to the static
		label

		Keywords arguments:
		apply_name_change -- indicates of the name change should be applied
							 (default=True)
		"""
		
		debug.msg(u"apply_name_change = %s" % apply_name_change)
		if apply_name_change:
			self.item.apply_name_change()			
		self.refresh()					
		self.label_name.show()
		self.edit_name.hide()

	def restore_desc(self):

		"""Apply the description change and revert the edit	back to the label"""
		
		self.item.apply_edit_changes()			
		self.refresh()
		self.label_desc.show()
		self.edit_desc.hide()

	def mousePressEvent(self, event):

		"""
		Change the label into an edit for the name or
		the description, depending on where has been
		clicked

		Arguments:
		event -- the mouseClickEvent
		"""

		target = self.childAt(event.pos())

		if target != None and hasattr(target, u"id"):
			if target.id == u"name":
				self.restore_desc()
				self.label_name.hide()
				self.edit_name.show()
				self.edit_name.selectAll()
				self.edit_name.setFocus()
			else:
				self.restore_name()
				self.label_desc.hide()
				self.edit_desc.show()
				self.edit_desc.selectAll()
				self.edit_desc.setFocus()

########NEW FILE########
__FILENAME__ = item_context_menu
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt4 import QtCore, QtGui
from libqtopensesame.misc import _

class item_context_menu(QtGui.QMenu):

	"""Provides a basic context menu for an item"""

	def __init__(self, title, parent, item, parent_item=None, index=None):

		"""
		Constructor

		Arguments:
		title -- menu title
		parent -- parent widget
		item -- the item to which this context menu belongs

		Keyword arguments:
		parent_item -- the parent of the item (default=None)
		index -- the index of the item in the parent item (if applicable)
				 (default=None)
		"""

		QtGui.QMenu.__init__(self, title, parent)
		self.item = item
		self.parent_item = parent_item
		self.index = index

		# The menu text
		self.open_text = _("Open %s") % item.name
		self.edit_text = _("Edit script")
		self.rename_text = _("Rename")
		self.delete_text = _("Delete")
		self.help_text = _("%s help") % item.item_type.capitalize()

		self.addAction(item.experiment.icon(item.item_type), self.open_text)
		self.addAction(item.experiment.icon("script"), self.edit_text)
		self.addSeparator()
		self.addAction(item.experiment.icon("rename"), self.rename_text)
		if parent_item != None:
			self.addAction(item.experiment.icon("delete"), self.delete_text)
		self.addSeparator()
		self.addAction(item.experiment.icon("help"), self.help_text)

	def popup(self, pos):

		"""
		Show the menu and execute the chosen action

		Arguments:
		pos -- the position to popup
		"""

		action = self.exec_(pos)
		if action == None:
			return
		action = unicode(action.text())
		if action == self.open_text:
			self.item.open_edit_tab()
		elif action == self.edit_text:
			self.item.open_script_tab()
		elif action == self.rename_text:
			self.rename()
		elif action == self.help_text:
			self.item.open_help_tab()
		elif action == self.delete_text:
			self.item.experiment.delete(self.item.name, self.parent_item, \
				self.index)

	def rename(self):

		"""Rename an item"""

		new_name, ok = QtGui.QInputDialog.getText(self, _(u'Rename'), \
			_(u'Please enter a new name'), text=self.item.name)
		new_name = self.item.experiment.sanitize(new_name, strict=True, \
			allow_vars=False)
		if ok:
			# Do not allow names that are already in use, but do allow
			# capitalization changes.
			if new_name.lower() != self.item.name.lower():
				valid = self.item.experiment.check_name(new_name)
				if valid != True:
					self.item.experiment.notify(valid)
					return
			# Accept
			self.item.experiment.main_window.set_unsaved()
			self.item.experiment.rename(self.item.name, new_name)


########NEW FILE########
__FILENAME__ = loop_table
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

__author__ = "Sebastiaan Mathot"
__license__ = "GPLv3"

from libqtopensesame.widgets import good_looking_table
from PyQt4 import QtCore, QtGui

class loop_table(good_looking_table.good_looking_table):

	"""The looptable extends the QtTableWidget to allow copying and pasting"""

	def __init__(self, loop, rows, columns, parent=None):

		"""
		Constructor

		Arguments:
		loop -- the loop item
		rows -- the nr of rows
		columns -- the nr of columns

		Keyword arguments:
		parent -- parent QWidget (default=None)
		"""

		self.pos = None
		self.loop = loop
		self.lock = False

		icons = {}
		icons["cut"] = self.loop.experiment.icon("cut")
		icons["copy"] = self.loop.experiment.icon("copy")
		icons["paste"] = self.loop.experiment.icon("paste")
		icons["clear"] = self.loop.experiment.icon("clear")

		good_looking_table.good_looking_table.__init__(self, \
			rows, columns, icons, parent)
		self.cellChanged.connect(self.apply_changes)

	def paste(self):

		"""Paste data from the clipboard into the table"""

		self.lock = True
		good_looking_table.good_looking_table.paste(self)
		self.lock = False
		self.apply_changes()

	def _clear(self):

		"""Clear the table"""

		self.lock = True
		good_looking_table.good_looking_table._clear(self)
		self.lock = False
		self.apply_changes()

	def apply_changes(self):

		"""
		Apply changes to the table and make sure that the cursor is restored to
		its previous position
		"""

		if self.lock:
			return
		self.loop.apply_edit_changes()

########NEW FILE########
__FILENAME__ = pool_widget
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import debug, misc
from libqtopensesame.ui import pool_widget_ui
from libqtopensesame.misc import _
from libqtopensesame.misc.config import cfg
from PyQt4 import QtCore, QtGui
import os
import platform
import os.path
import shutil
import subprocess

class pool_widget(QtGui.QWidget):

	"""The file pool widget"""

	def __init__(self, main_window, parent=None):

		"""
		Constructur

		Arguments:
		main_window		--	The GUI main window.

		Keyword arguments:
		parent			--	A parent widget. (default=None)
		"""

		# Known image and sound extensions
		self.exts = {u"image" : (u".png", u".jpg", u".bmp", u".gif", \
			u".jpeg"), \
			u"sound" : (u".ogg", u".wav"), \
			u"text" : (u".txt", u".csv", u".tsv"), \
			u"python" : (u".py", u".pyc"), \
			u"video" : (u".avi", u".mpg", u".wmv", u".mpeg", u".mov", u".ogv", \
				u".mp4", u".flv"), \
			u"pdf" : (u".pdf"), \
			}

		self.main_window = main_window
		self.max_len = 5

		QtGui.QWidget.__init__(self, parent)
		self.ui = pool_widget_ui.Ui_pool_widget()
		self.ui.setupUi(self)
		self.ui.button_pool_add.clicked.connect(self.select_and_add)
		self.ui.button_refresh.clicked.connect(self.refresh)
		self.ui.button_help_pool.clicked.connect(self.help)
		self.ui.button_browse_pool.clicked.connect(self.browse)
		self.ui.edit_pool_filter.textChanged.connect(self.refresh)
		self.ui.combobox_view.currentIndexChanged.connect(self.set_view)
		self.ui.list_pool.itemActivated.connect(self.activate_file)
		self.main_window.theme.apply_theme(self)

		self.ui.combobox_view.setItemIcon(0, self.main_window.theme.qicon( \
			u"view-list-details-symbolic"))
		self.ui.combobox_view.setItemIcon(1, self.main_window.theme.qicon( \
			u"view-list-icons-symbolic"))

	def help(self):

		"""Open the help tab"""

		self.main_window.ui.tabwidget.open_help(u"pool")

	def set_view(self):

		"""Set the viewmode (list/ icons) based on the gui control"""

		if self.ui.combobox_view.currentIndex() == 0:
			self.ui.list_pool.setViewMode(QtGui.QListView.ListMode)
		else:
			self.ui.list_pool.setViewMode(QtGui.QListView.IconMode)

	def browse(self):

		"""Open the pool folder in the file manager in an OS specific way"""

		misc.open_url(self.main_window.experiment.pool_folder)

	def add(self, files):

		"""
		Add a list of files to the pool.

		Arguments:
		files - A list of paths
		"""

		basename = ""
		for path in files:
			path = unicode(path)
			debug.msg(path)
			basename = os.path.basename(path)
			if not os.path.isfile(path):
				self.main_window.experiment.notify( \
					_(u"'%s' is not a regular file and could not be added to the file pool.") \
					% path)
			else:
				# If a similar file already exists in the pool, ask before overwriting
				if os.path.exists(os.path.join( \
					self.main_window.experiment.pool_folder, basename)):
					resp = QtGui.QMessageBox.question(self, _("Overwrite"), \
						_(u"A file named '%s' already exists in the pool. Do you want to overwrite this file?") \
						% basename, QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)
					if resp == QtGui.QMessageBox.Yes:
						shutil.copyfile(path, os.path.join( \
							self.main_window.experiment.pool_folder, basename))
				else:
					shutil.copyfile(path, os.path.join( \
						self.main_window.experiment.pool_folder, basename))

		self.refresh()
		self.select(basename)

	def select_and_add(self, dummy = None):

		"""
		Add one or more files to the pool

		Keyword arguments:
		dummy -- a dummy argument passed py the signal handler (default=None)
		"""

		path_list = QtGui.QFileDialog.getOpenFileNames( \
			self.main_window.ui.centralwidget, _(u"Add files to pool"), \
			directory=cfg.default_pool_folder)
		if len(path_list) == 0:
			return
		cfg.default_pool_folder = os.path.dirname(unicode(path_list[0]))
		self.add(path_list)

	def select(self, fname):

		"""
		Select a specific file in the file pool

		Arguments:
		fname -- the file to be selected
		"""

		for i in range(self.ui.list_pool.count()):
			item = self.ui.list_pool.item(i)
			if unicode(item.text()) == fname:
				self.ui.list_pool.setCurrentItem(item)

	def file_type(self, fname):

		"""
		Determine the type of a file based on the extension

		Arguments:
		fname -- the file under investigation

		Returns:
		A string with the filetype or "unknown"
		"""

		ext = os.path.splitext(fname)[1].lower()
		for file_type in self.exts:
			if ext in self.exts[file_type]:
				return file_type
		return u"unknown"

	def refresh(self):

		"""Refresh the contents of the pool widget"""

		filt = unicode(self.ui.edit_pool_filter.text()).lower()
		self.ui.list_pool.clear()

		# This function can be called after the pool has been cleaned
		# up. This should not lead to a warning.
		if not os.path.exists(self.main_window.experiment.pool_folder):
			return

		for fname in os.listdir(unicode( \
			self.main_window.experiment.pool_folder)):
			debug.msg(fname)
			if filt in fname.lower():
				icon = self.main_window.experiment.icon(self.file_type(fname))
				item = QtGui.QListWidgetItem(icon, fname)
				item.icon = icon
				item.path = os.path.join( \
					self.main_window.experiment.pool_folder, fname)
				self.ui.list_pool.addItem(item)

	def open_file(self, path):

		"""
		Open a file in a platform specific way

		Arguments:
		path -- the full path to the file to be opened
		"""

		misc.open_url(path)

	def activate_file(self, item):

		"""
		Is called when a file is double-clicked or
		otherwise activated and opens the file.

		Arguments:
		item -- a listWidgetItem
		"""

		self.open_file(item.path)

	def contextMenuEvent(self, event):

		"""
		Presents a context menu

		Arguments:
		event -- a mouseClickEvent
		"""

		item = self.ui.list_pool.itemAt(self.ui.list_pool.mapFromGlobal( \
			event.globalPos()))
		if item == None:
			return
		menu = QtGui.QMenu()
		menu.addAction(item.icon, _(u"Open"))
		menu.addSeparator()
		menu.addAction(self.main_window.experiment.icon(u"delete"), \
			_(u"Remove from pool"))
		menu.addAction(self.main_window.experiment.icon(u"rename"), _(u"Rename"))
		menu.triggered.connect(self.context_action)
		self.context_target = unicode(item.text())
		menu.exec_(event.globalPos())

	def context_action(self, action):

		"""
		Perform a conext menu action

		Arguments:
		action -- the action to be performed
		"""

		a = unicode(action.text())
		f = os.path.join(self.main_window.experiment.pool_folder, \
			self.context_target)

		if a == _(u"Open"):
			self.open_file(f)

		elif a == _(u"Remove from pool"):

			# Prepare the confirmation dialog, which contains a limited nr of
			# filenames
			l = []
			suffix = ''
			for item in self.ui.list_pool.selectedItems()[:self.max_len]:
				l.append(unicode(item.text()))
			if len(self.ui.list_pool.selectedItems()) > self.max_len:
				suffix = _('And %d more file(s)') % \
					(len(self.ui.list_pool.selectedItems())-self.max_len)

			# Ask for confirmation
			resp = QtGui.QMessageBox.question(self, _(u"Remove"), \
				_(u"<p>Are you sure you want to remove the following files from the file pool? This operation will only affect the OpenSesame file pool, not the original files on your disk.</p><p><b> - %s</b></p><p>%s</p>") \
				% (u"<br /> - ".join(l), suffix), QtGui.QMessageBox.Yes, \
				QtGui.QMessageBox.No)
			if resp == QtGui.QMessageBox.No:
				return

			# Create a list of files to be removed
			dL = []
			for item in self.ui.list_pool.selectedItems():
				dL.append(unicode(item.text()))

			# Remove the files
			try:
				for f in dL:
					os.remove(os.path.join( \
						self.main_window.experiment.pool_folder, f))
				debug.msg(u"removed '%s'" % self.context_target)
			except:
				debug.msg(u"failed to remove '%s'" % self.context_target)
		else:

			# Rename the file
			new_name, ok = QtGui.QInputDialog.getText(self, _(u"Rename"), \
				_(u"Please enter a new name for '%s'") \
				% self.context_target, text = self.context_target)
			if ok:
				new_name = unicode(new_name)

				if os.path.exists(os.path.join( \
					self.main_window.experiment.pool_folder, new_name)):
					self.main_window.experiment.notify( \
						_(u"There already is a file named '%s' in the file pool") \
						% new_name)
					return

				try:
					os.rename(f, os.path.join( \
						self.main_window.experiment.pool_folder, new_name))
					debug.msg(u"renamed '%s' to '%s'" % (self.context_target, \
						new_name))
				except:
					debug.msg(u"failed to rename '%s' to '%s'" % \
						(self.context_target, new_name))

		self.main_window.set_unsaved()
		self.refresh()

	def dragEnterEvent(self, event):

		"""
		Accept an incoming drag that precedes a drop

		Arguments:
		event -- a drag event
		"""

		event.acceptProposedAction()

	def dropEvent(self, event):

		"""
		Accept an incoming drop

		Arguments:
		event -- a drop event
		"""

		files = []
		for url in event.mimeData().urls():
			files.append(url.toLocalFile())
		self.add(files)
		event.acceptProposedAction()

def select_from_pool(main_window):

	"""
	A static function that presents the select from pool dialog

	Arguments:
	main_window -- the GUI main window
	"""

	d = QtGui.QDialog(main_window.ui.centralwidget)
	widget = pool_widget(main_window)
	widget.refresh()
	bbox = QtGui.QDialogButtonBox(d)
	bbox.addButton(_(u"Cancel"), QtGui.QDialogButtonBox.RejectRole)
	bbox.addButton(_(u"Select"), QtGui.QDialogButtonBox.AcceptRole)
	bbox.accepted.connect(d.accept)
	bbox.rejected.connect(d.reject)
	vbox = QtGui.QVBoxLayout()
	vbox.addWidget(widget)
	vbox.addWidget(bbox)
	d.setLayout(vbox)
	d.setWindowTitle(_(u"Select file from pool"))
	res = d.exec_()
	main_window.refresh_pool()

	if res == QtGui.QDialog.Rejected:
		return ""

	selected = widget.ui.list_pool.currentItem()
	if selected == None:
		return ""
	return unicode(selected.text())

########NEW FILE########
__FILENAME__ = preferences_widget
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import debug
from libqtopensesame.ui import preferences_widget_ui
from libqtopensesame.misc import config, theme
from libopensesame import plugins
from PyQt4 import QtCore, QtGui
import os

class preferences_widget(QtGui.QWidget):

	"""The widget displayed in the preferences tab."""

	def __init__(self, parent):

		"""
		Constructor.

		Arguments:
		parent	--	The parent widget.
		"""

		QtGui.QWidget.__init__(self, parent)
		self.tab_name = u'__preferences__'
		self.main_window = parent
		# Setup the GUI
		self.ui = preferences_widget_ui.Ui_preferences_widget()
		self.ui.setupUi(self)
		self.main_window.theme.apply_theme(self)
		self.lock = False
		# Connect the controls
		self.ui.checkbox_immediately_rename.toggled.connect(self.apply)
		self.ui.checkbox_autoresponse.toggled.connect(self.apply)
		self.ui.checkbox_toolbar_text.toggled.connect(self.apply)
		self.ui.checkbox_small_toolbar.toggled.connect(self.apply)
		self.ui.checkbox_enable_autosave.toggled.connect(self.apply)
		self.ui.spinbox_autosave_interval.valueChanged.connect(self.apply)
		self.ui.spinbox_autosave_max_age.valueChanged.connect(self.apply)
		self.ui.checkbox_auto_update_check.toggled.connect(self.apply)
		self.ui.combobox_runner.currentIndexChanged.connect(self.apply)
		self.ui.button_browse_autosave.clicked.connect( \
			self.main_window.open_autosave_folder)
		self.ui.button_update_check.clicked.connect( \
			self.main_window.check_update)
		self.ui.combobox_style.currentIndexChanged.connect(self.apply)
		self.ui.combobox_theme.currentIndexChanged.connect(self.apply)
		# Construct the plugin section
		self.checkbox_plugins = {}
		self.ui.edit_plugin_folders.setText(u'; '.join(plugins.plugin_folders( \
			only_existing=False)))
		for plugin in sorted(plugins.list_plugins(filter_disabled=False)):
			self.checkbox_plugins[plugin] = QtGui.QCheckBox(plugin)
			self.checkbox_plugins[plugin].toggled.connect(self.apply)
			self.ui.layout_plugin_list.addWidget(self.checkbox_plugins[plugin])
		self.set_controls()

	def set_controls(self):

		"""Updates the controls."""

		if self.lock:
			return
		self.lock = True
		debug.msg()

		self.ui.checkbox_immediately_rename.setChecked( \
			config.get_config(u'immediate_rename'))
		self.ui.checkbox_autoresponse.setChecked( \
			self.main_window.experiment.auto_response)
		self.ui.checkbox_toolbar_text.setChecked( \
			self.main_window.ui.toolbar_main.toolButtonStyle() == \
			QtCore.Qt.ToolButtonTextUnderIcon)
		self.ui.checkbox_small_toolbar.setChecked( \
			config.get_config(u"toolbar_size") == 16)		
		self.ui.checkbox_enable_autosave.setChecked( \
			config.get_config(u'autosave_interval') > 0)
		self.ui.spinbox_autosave_interval.setValue( \
			config.get_config(u'autosave_interval') / 60000) # Show in minutes
		self.ui.spinbox_autosave_max_age.setValue( \
			config.get_config(u'autosave_max_age'))
		self.ui.checkbox_auto_update_check.setChecked(config.get_config( \
			u'auto_update_check'))		
		self.ui.combobox_runner.setCurrentIndex( \
			self.ui.combobox_runner.findText(config.get_config(u'runner'), \
			flags=QtCore.Qt.MatchContains))		
		# Disable some of the controls, if they depend on other controls
		if config.get_config(u'autosave_interval') <= 0:
			self.ui.spinbox_autosave_interval.setDisabled(True)
		# Set the style combobox
		i = 0
		if config.get_config(u'style') == u'':
			self.ui.combobox_style.addItem(u"[Default]")
			self.ui.combobox_style.setCurrentIndex(i)
			i += 1
		for style in QtGui.QStyleFactory.keys():
			self.ui.combobox_style.addItem(style)
			if config.get_config(u'style') == unicode(style):
				self.ui.combobox_style.setCurrentIndex(i)
			i += 1
		# Set the theme combobox
		i = 0
		for _theme in theme.available_themes:
			self.ui.combobox_theme.addItem(_theme)
			if config.get_config(u'theme') == _theme:
				self.ui.combobox_theme.setCurrentIndex(i)
			i += 1
		# Set the plugin status
		for plugin in plugins.list_plugins(filter_disabled=False):
			self.checkbox_plugins[plugin].setChecked(not \
				plugins.plugin_disabled(plugin))
		self.lock = False

	def apply(self):

		"""Apply the controls"""

		if self.lock:
			return
		self.lock = True
		debug.msg()

		config.set_config(u'immediate_rename', \
			self.ui.checkbox_immediately_rename.isChecked())
		self.main_window.experiment.auto_response = \
			self.ui.checkbox_autoresponse.isChecked()
		self.main_window.ui.action_enable_auto_response.setChecked( \
			self.ui.checkbox_autoresponse.isChecked())

		if self.ui.checkbox_toolbar_text.isChecked():
			self.main_window.ui.toolbar_main.setToolButtonStyle( \
				QtCore.Qt.ToolButtonTextUnderIcon)
		else:
			self.main_window.ui.toolbar_main.setToolButtonStyle( \
				QtCore.Qt.ToolButtonIconOnly)
		
		old_size = config.get_config(u'toolbar_size')
		if self.ui.checkbox_small_toolbar.isChecked():
			new_size = 16
		else:
			new_size = 32
		if old_size != new_size:
			config.set_config(u"toolbar_size", new_size)
			self.main_window.theme.set_toolbar_size(config.get_config( \
				"toolbar_size"))		

		if self.ui.checkbox_enable_autosave.isChecked():
			config.set_config(u'autosave_interval', 60000 * \
				self.ui.spinbox_autosave_interval.value())
		else:
			config.set_config(u'autosave_interval', 0)	
		config.set_config(u'autosave_max_age', \
			self.ui.spinbox_autosave_max_age.value())
		self.main_window.start_autosave_timer()

		config.set_config(u'auto_update_check', \
			self.ui.checkbox_auto_update_check.isChecked())
		
		from libqtopensesame import runners
		for runner in runners.runner_list:
			if runner in self.ui.combobox_runner.currentText():
				config.set_config(u'runner', runner)

		config.set_config(u'theme', unicode( \
			self.ui.combobox_theme.currentText()))

		# Create a semicolon-separated list of disabled plugins
		l = []
		for plugin in plugins.list_plugins(filter_disabled=False):
			if not self.checkbox_plugins[plugin].isChecked():
				l.append(plugin)
		config.set_config(u"disabled_plugins", ";".join(l))

		config.set_config(u'style', unicode( \
			self.ui.combobox_style.currentText()))
		self.main_window.save_state()

		self.lock = False

########NEW FILE########
__FILENAME__ = pyterm
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import sys

if "--ipython" in sys.argv:
	from pyterm_ipython import console, output_buffer
else:
	from pyterm_original import console, output_buffer

########NEW FILE########
__FILENAME__ = pyterm_ipython
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import sys
from IPython.frontend.qt.console.ipython_widget import IPythonWidget
from IPython.frontend.qt.kernelmanager import QtKernelManager
from IPython.utils.localinterfaces import LOCALHOST
from PyQt4.QtCore import *
from PyQt4.QtGui import *
from PyQt4 import QtGui

class output_buffer:

	"""Used to capture the standard output and reroute it to the debug window"""

	def __init__(self, console):

		"""
		Constructor

		Keyword arguments:
		console -- a console widget
		"""

		self.console = console

	def write(self, s):

		"""
		Write a string

		Arguments:
		s -- a string
		"""

		self.console.console._append_plain_text(s)
		
	def flush(self):
		
		"""Dummy flush function for compatibility."""
		
		pass
		

class console(QWidget):

	"""A QWidget that serves as a debug window"""

	def __init__(self, parent=None):

		QDialog.__init__(self, parent)

		self.main_window = parent
		self.kernel_manager = QtKernelManager()
		self.kernel_manager.start_kernel()
		self.kernel_manager.start_channels()
		self.console = IPythonWidget(local_kernel=LOCALHOST)
		self.console.kernel_manager = self.kernel_manager
		self.verticalLayout = QVBoxLayout(self)
		self.verticalLayout.setContentsMargins(0,0,0,0)
		self.setLayout(self.verticalLayout)
		self.verticalLayout.addWidget(self.console)

	def setReadOnly(self, state):

		"""
		Dummy function

		Arguments:
		state -- dummy argument
		"""

		pass

	def clear(self):

		"""Clears the console"""

		self.console.reset()

	def show_prompt(self):

		"""Shows a new prompt"""

		self.console._show_interpreter_prompt()


########NEW FILE########
__FILENAME__ = pyterm_original
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import code
import sys
import os
import time
from PyQt4 import QtGui, QtCore
from libopensesame import debug
from libqtopensesame.misc import _
from libqtopensesame.misc.config import cfg

def modules():

	"""Print version info"""

	from libopensesame.misc import module_versions
	print(module_versions())

class output_buffer:

	"""Used to capture the standard output and reroute it to the debug window"""

	def __init__(self, plaintext):

		"""
		Constructor

		Keyword arguments:
		plaintext -- a QPlainTextEdit widget
		"""

		self.plaintext = plaintext

	def readline(self):

		"""Input is crudely supported through an input dialog"""

		self.plaintext._input = ""
		self.plaintext.collect_input = True
		while len(self.plaintext._input) == 0 or self.plaintext._input[-1] != \
			"\n":
			time.sleep(0.01)
			QtGui.QApplication.processEvents()
		self.plaintext.collect_input = False
		return self.plaintext._input

	def write(self, s):

		"""
		Write a string

		Arguments:
		s -- a string
		"""

		if isinstance(s, str):
			s = s.decode(u'utf-8', u'replace')
		if s.strip() != u'':
			self.plaintext.appendPlainText(s)
			QtGui.QApplication.processEvents()

	def flush(self):

		"""Dummy flush function for compatibility."""

		pass

class pyterm(code.InteractiveConsole):

	"""Custom Python interpreter"""

	def __init__(self, parent, textedit=None):

		"""Constructor"""

		global modules

		self._locals = {u'modules' : modules, u'parent' : parent}
		code.InteractiveConsole.__init__(self, self._locals)
		self.textedit = textedit

	def write(self, s):

		"""
		Simply redirect everything to the standard output.

		Arguments:
		s -- the output string
		"""

		if isinstance(s, str):
			s = s.decode(u'utf-8', u'replace')
		print(s.replace(u'\n', u''))

class console(QtGui.QPlainTextEdit):

	"""A nice console widget"""

	def __init__(self, parent=None):

		"""
		Constructor

		Keywords arguments:
		parent -- parent QWidget
		"""

		QtGui.QPlainTextEdit.__init__(self, parent)
		self.main_window = parent
		self.collect_input = False
		self._input = u""
		self.history = []
		self.prompt = u">>> "
		self.pyterm = pyterm(self.main_window)
		self.pyterm.textedit = self
		self.setCursorWidth(8)
		self.setTheme()
		self.welcome()
		self.show_prompt()

	def setTheme(self):

		"""Sets the theme, based on the QProgEdit settings."""

		self.setFont(QtGui.QFont(cfg.qProgEditFontFamily, \
			cfg.qProgEditFontSize))
		from QProgEdit import QColorScheme
		if not hasattr(QColorScheme, cfg.qProgEditColorScheme):
			debug.msg(u'Failed to set debug-output colorscheme')
			return
		cs = getattr(QColorScheme, cfg.qProgEditColorScheme)
		if u'Background' not in cs:
			background = u'white'
		else:
			background = cs[u'Background']
		if u'Default' not in cs:
			foreground = u'black'
		else:
			foreground = cs[u'Default']
		self.setStyleSheet(u'background-color: "%s"; color: "%s";' \
			% (background, foreground))

	def focusInEvent(self, e):

		"""
		Process focus-in events to set the style of the debug window.

		Arguments:
		e		--	A focus-in event.
		"""

		self.setTheme()
		super(console, self).focusInEvent(e)

	def clear(self):

		"""Clear and draw prompt"""

		QtGui.QPlainTextEdit.clear(self)
		self.show_prompt()

	def welcome(self):

		"""Print welcome information"""

		s = u"Python %d.%d.%d" % (sys.version_info[0], sys.version_info[1], \
			sys.version_info[2]) \
			+ u"\nType \"help()\", \"copyright()\", \"credits()\" or \"license()\" for more information." \
			+ u"\nType \"modules()\" for details about installed modules and version information." \
			+ u"\nUse the \"print([msg])\" statement in inline_script items to print to this debug window."
		self.insertPlainText(s)

	def show_prompt(self, suffix=""):

		"""Show a prompt"""

		self.appendPlainText(self.prompt+suffix)

	def keyPressEvent(self, e):

		"""
		Handle key presses

		Arguments:
		e -- a QKeyEvent
		"""

		# Emulate the standard input
		if self.collect_input:
			if e.key() in [QtCore.Qt.Key_Enter, QtCore.Qt.Key_Return]:
				self._input += u"\n"
			else:
				self._input += unicode(e.text())
				QtGui.QPlainTextEdit.keyPressEvent(self, e)

		# Emulate the console
		else:
			self.jump_to_end()
			if e.key() == QtCore.Qt.Key_Up:
				if len(self.history) > 0:
					cmd = self.history.pop()
					self.show_prompt(cmd)
					self.history.insert(0, cmd)
			elif e.key() == QtCore.Qt.Key_Home:
				cursor = self.textCursor()
				cursor.setPosition(self.textCursor().block().position() \
					+len(self.prompt))
				self.setTextCursor(cursor)
			elif e.key() in [QtCore.Qt.Key_Enter, QtCore.Qt.Key_Return]:
				self.execute()
			elif e.key() not in [QtCore.Qt.Key_Backspace, QtCore.Qt.Key_Home, \
				QtCore.Qt.Key_Up, QtCore.Qt.Key_Down] and e.key() != \
				QtCore.Qt.Key_Left or self.textCursor().positionInBlock() > \
				len(self.prompt):
				QtGui.QPlainTextEdit.keyPressEvent(self, e)

	def execute(self):

		"""Execute a command"""

		try:
			s = unicode(self.document().lastBlock().text())[len(self.prompt):]
		except:
			self.appendPlainText( \
				_(u"Error: Command contains invalid characters"))
			self.show_prompt()
			return
		if len(s) > 0:
			self.history.append(s)
		buf = output_buffer(self)
		sys.stdout = buf
		sys.stdin = buf
		self.pyterm.push(s)
		sys.stdout = sys.__stdout__
		sys.stdin = sys.__stdin__
		self.show_prompt()

	def jump_to_end(self):

		"""Restore the cursor to the end of the textedit"""

		c = self.textCursor()
		if not c.atEnd() and c.blockNumber()+1 < self.document().blockCount():
			c.movePosition(QtGui.QTextCursor.End)
			self.setTextCursor(c)


########NEW FILE########
__FILENAME__ = sketchpad_widget
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

__author__ = "Sebastiaan Mathot"
__license__ = "GPLv3"

import math
import os
import numbers
from libopensesame.exceptions import osexception
from libopensesame import debug
from libqtopensesame.ui import sketchpad_widget_ui, gabor_dialog_ui, \
	noise_patch_dialog_ui
from libqtopensesame.widgets import pool_widget
from libqtopensesame.misc import _
import openexp.canvas
from PyQt4 import QtCore, QtGui

class remove_item_button(QtGui.QPushButton):

	"""A button to remove items from the sketchpad"""

	def __init__(self, sketchpad_widget, item):

		"""
		Constructor

		Arguments:
		sketchpad_widget -- the sketchpad widget
		item -- the item of the sketchpad widget
		"""

		self.sketchpad_widget = sketchpad_widget
		self.item = item
		QtGui.QPushButton.__init__(self, \
			self.sketchpad_widget.sketchpad.experiment.icon("delete"), "")
		self.clicked.connect(self.remove_item)
		self.setIconSize(QtCore.QSize(16,16))

	def remove_item(self):

		"""Is called when the remove button is clicked"""

		self.sketchpad_widget.sketchpad.items.remove(self.item)
		self.sketchpad_widget.refresh()

class edit_item_button(QtGui.QPushButton):

	"""A button to edit items in the sketchpad"""

	def __init__(self, sketchpad_widget, item):

		"""
		Constructor

		Arguments:
		sketchpad_widget -- the sketchpad widget
		item -- the item of the sketchpad widget
		"""

		self.sketchpad_widget = sketchpad_widget
		self.item = item
		QtGui.QPushButton.__init__(self, \
			self.sketchpad_widget.sketchpad.experiment.icon("edit"), "")
		self.clicked.connect(self.edit_item)
		self.setIconSize(QtCore.QSize(16,16))

	def edit_item(self):

		"""Is called when the edit button is clicked"""

		self.sketchpad_widget.scene.edit_item( \
			self.sketchpad_widget.sketchpad.fix_coordinates(self.item))
		self.sketchpad_widget.sketchpad.apply_edit_changes()
		self.sketchpad_widget.refresh()

class canvas(QtGui.QGraphicsScene):

	"""The QGraphicsScene on which the sketchpad is drawn"""

	def __init__(self, sketchpad_widget, parent=None):

		"""
		Constructor

		Arguments:
		sketchpad_widget -- the sketchpad_widget of which the canvas is part

		Keyword arguments:
		parent -- the parent QWidget (default=None)
		"""

		self.sketchpad_widget = sketchpad_widget
		self.grid = 10
		self.r = 4
		self.pen = pen = QtGui.QPen()
		self.grid_color = "green"
		self.pen.setColor(QtGui.QColor(self.grid_color))
		self.oneshot = False
		self.from_pos = None
		self.grid_list = []
		QtGui.QGraphicsScene.__init__(self, parent)

	def cursor_pos(self, e):

		"""
		Gets the position of the mouse cursor. This position
		takes into account the reference frame (relative/ absolute)
		and the grid

		Arguments:
		e -- a QMouseEvent

		Returns:
		An (x, y) tuple with the the coordinates of the mouse cursor
		"""

		pos = e.scenePos().toPoint()
		x = pos.x() + 0.5 * self.grid
		y = pos.y() + 0.5 * self.grid

		if self.sketchpad_widget.sketchpad.get("coordinates") == "relative":
			x -= 0.5 * self.sketchpad_widget.sketchpad.get("width")
			y -= 0.5 * self.sketchpad_widget.sketchpad.get("height")

		x = x - x % self.grid
		y = y - y % self.grid

		return x, y

	def mouseMoveEvent(self, e):

		"""
		Update the text widget with the cursor position

		Arguments:
		e -- a QMouseEvent
		"""

		x, y = self.cursor_pos(e)
		if x == None:
			text = "(0, 0)"
		else:
			text = "(%d, %d)" % (x, y)
		self.sketchpad_widget.ui.label_mouse_pos.setText(text)

	def mousePressEvent(self, e):

		"""
		Handle mouse presses to start/ finish drawing
		or present a context menu

		Arguments:
		e -- a QMouseEvent
		"""

		if e.button() == QtCore.Qt.RightButton:
			self.context_menu(e)
		else:
			self.draw(e)

	def draw(self, e):

		"""
		Handle drawing operations

		Arguments:
		e -- a QMouseEvent
		"""

		x, y = self.cursor_pos(e)
		if x == None:
			return

		if self.sketchpad_widget.sketchpad.get("coordinates") == "relative":
			x += 0.5 * self.sketchpad_widget.sketchpad.get("width")
			y += 0.5 * self.sketchpad_widget.sketchpad.get("height")

		if x < 0 or y < 0 or x >= self.sketchpad_widget.sketchpad.get("width") \
			or y >= self.sketchpad_widget.sketchpad.get("height"):
			self.sketchpad_widget.ui.label_mouse_pos.setText( \
				_("(Out of sketchpad)"))
			return

		if self.from_pos == None and not self.oneshot:
			self.addEllipse(x - self.r, y - self.r, 2 * self.r, 2 * self.r, \
				self.pen)
			self.from_pos = x, y
		else:
			pos = self.from_pos
			self.from_pos = None
			self.sketchpad_widget.add(pos, (x, y))

	def context_menu(self, e):

		"""
		Show the context menu

		Arguments:
		e -- a QMouseEvent
		"""

		# First clear the grid, so we don't select the grid items
		for l in self.grid_list:
			self.removeItem(l)
		self.grid_list = []


		# Get the item under the cursor
		item = self.itemAt(e.scenePos())
		if item != None:

			# Get the corresponding item from the sketchpad_widget
			for g, _item in self.sketchpad_widget.item_list:
				if g == item:

					# Draw a highlight box
					brush = QtGui.QBrush()
					brush.setColor(QtGui.QColor(self.grid_color))
					brush.setStyle(QtCore.Qt.Dense2Pattern)

					# For some items the boundingrect does not appear to work
					# correctly, so we have to use the pos() function
					x = max(item.pos().x(), item.boundingRect().x()) - 4
					y = max(item.pos().y(), item.boundingRect().y()) - 4
					w = item.boundingRect().width() + 8
					h = item.boundingRect().height() + 8
					l = self.addRect(x, y, w, h, brush = brush)
					l.setOpacity(0.25)

					# Show the context menu
					menu = QtGui.QMenu()
					menu.addAction( \
						self.sketchpad_widget.sketchpad.experiment.icon( \
						"delete"), _("Delete"))
					menu.addAction( \
						self.sketchpad_widget.sketchpad.experiment.icon( \
						"edit"), _("Edit"))
					action = menu.exec_(e.screenPos())

					# Execute the chosen action
					if action != None:
						if unicode(action.text()) == _("Delete"):
							self.delete_item(_item)
						elif unicode(action.text()) == _("Edit"):
							self.edit_item(_item)

		self.sketchpad_widget.sketchpad.apply_edit_changes()
		self.sketchpad_widget.refresh()

	def delete_item(self, item):

		"""
		Delete an item from the sketchpad

		Arguments:
		item -- the item to be deleted
		"""

		s = self.sketchpad_widget.sketchpad.item_to_string(item)

		# Walk through all items and find the matching one
		for i in self.sketchpad_widget.sketchpad.items:

			# We have to fix the coordinates, because the items in the widget
			# are not relative, whereas the items in the sketchpats are
			j = self.sketchpad_widget.sketchpad.fix_coordinates(i)

			# If the strings match, delete it!
			if self.sketchpad_widget.sketchpad.item_to_string(j) == s:
				self.sketchpad_widget.sketchpad.items.remove(i)
				break

	def edit_item(self, item):

		"""
		Present an input dialog to edit an item

		Arguments:
		item -- the item to edit
		"""

		s = self.sketchpad_widget.sketchpad.item_to_string( \
			self.sketchpad_widget.sketchpad.unfix_coordinates(item))
		s = self.sketchpad_widget.sketchpad.experiment.text_input( \
			_("Edit sketchpad element"), message=_("Element script"), \
			content=s)
		if s == None:
			return
		tmp = self.sketchpad_widget.sketchpad.items[:] # Keep a backup
		self.delete_item(item)
		try:
			self.sketchpad_widget.sketchpad.from_string(s)
		except osexception as e:
			self.sketchpad_widget.sketchpad.items = tmp
			self.sketchpad_widget.sketchpad.experiment.notify(e)

	def draw_grid(self):

		"""Draw the grid"""

		self.grid_list = []

		w = self.sketchpad_widget.sketchpad.experiment.get("width")
		h = self.sketchpad_widget.sketchpad.experiment.get("height")

		pen = QtGui.QPen()
		pen.setWidth(1)
		pen.setColor(QtGui.QColor(self.grid_color))

		x1 = 0
		x2 = w
		y1 = 0
		y2 = h

		if self.sketchpad_widget.sketchpad.get("coordinates") == "relative":
			x1 -= w / 2
			y1 -= h / 2
			x1 = x1 - x1 % self.grid
			y1 = y1 - y1 % self.grid
			x1 += w / 2
			y1 += h / 2

			if x1 < w / 2:
				x1 += self.grid

			if y1 < h / 2:
				y1 += self.grid

		for x in range(x1, x2, self.grid):
			if x == w / 2:
				pen.setWidth(3)
			l = self.addLine(x, y1, x, y2, pen)
			l.setOpacity(0.25)
			self.grid_list.append(l)
			if x == w / 2:
				pen.setWidth(1)

		for y in range(y1, y2, self.grid):
			if y == h / 2:
				pen.setWidth(3)
			l = self.addLine(x1, y, x2, y, pen)
			l.setOpacity(0.25)
			self.grid_list.append(l)
			if y == h / 2:
				pen.setWidth(1)


class sketchpad_widget(QtGui.QWidget):

	"""A custom widget contain the sketchpad canvas controls, etc."""

	def __init__(self, sketchpad, parent=None, embed=True):

		"""
		Constructor

		Arguments:
		sketchpad -- a libopensesame.sketchpad instance

		Keyword arguments:
		parent -- a parent widget (default=None)
		"""

		QtGui.QWidget.__init__(self, parent)

		# Setup the UI
		self.ui = sketchpad_widget_ui.Ui_sketchpad_widget()
		self.ui.setupUi(self)
		self.ui.view.setViewportMargins(0, 0, 0, 0)

		self.sketchpad = sketchpad
		self.embed = embed

		self.zoom = 1.0
		self.scene = canvas(self)
		self.ui.view.setScene(self.scene)
		self.item_list = []

		self.vbox_items = QtGui.QVBoxLayout()
		self.ui.widget_items.setLayout(self.vbox_items)

		# Initialize custom color and font widgets
		self.ui.edit_color.initialize(self.sketchpad.experiment, color= \
			self.sketchpad.get('foreground', _eval=False))
		QtCore.QObject.connect(self.ui.edit_color, QtCore.SIGNAL( \
			"set_color"), self.set_tool)
		self.ui.widget_font.initialize(self.sketchpad.experiment)
		QtCore.QObject.connect(self.ui.widget_font, QtCore.SIGNAL( \
			"font_changed"), self.set_tool)

		self.ui.button_line.clicked.connect(self.set_line)
		self.ui.button_rect.clicked.connect(self.set_rect)
		self.ui.button_ellipse.clicked.connect(self.set_ellipse)
		self.ui.button_circle.clicked.connect(self.set_circle)
		self.ui.button_arrow.clicked.connect(self.set_arrow)
		self.ui.button_textline.clicked.connect(self.set_textline)
		self.ui.button_fixdot.clicked.connect(self.set_fixdot)
		self.ui.button_image.clicked.connect(self.set_image)
		self.ui.button_gabor.clicked.connect(self.set_gabor)
		self.ui.button_noise_patch.clicked.connect(self.set_noise)
		self.ui.button_edit_script.clicked.connect(self.edit_script)
		self.ui.spin_penwidth.valueChanged.connect(self.set_tool)
		self.ui.spin_zoom.valueChanged.connect(self.set_tool)
		self.ui.spin_scale.valueChanged.connect(self.set_tool)
		self.ui.spin_grid.valueChanged.connect(self.set_tool)
		self.ui.spin_arrow_size.valueChanged.connect(self.set_tool)
		self.ui.checkbox_fill.stateChanged.connect(self.set_tool)
		self.ui.checkbox_center.stateChanged.connect(self.set_tool)
		self.ui.checkbox_html.stateChanged.connect(self.set_tool)
		self.ui.checkbox_show_grid.stateChanged.connect(self.set_tool)
		self.ui.edit_show_if.editingFinished.connect(self.set_tool)

		self.set_line()
		self.refresh()
		self.sketchpad.experiment.main_window.theme.apply_theme(self)

	def edit_script(self):

		"""
		Show the edit script tab and, if not embedded, close the current window
		"""

		if not self.embed:
			self.parent().accept()
		self.sketchpad.open_script_tab()

	def unset_all(self):

		"""Untoggle all buttons"""

		self.ui.button_line.setChecked(False)
		self.ui.button_rect.setChecked(False)
		self.ui.button_ellipse.setChecked(False)
		self.ui.button_circle.setChecked(False)
		self.ui.button_arrow.setChecked(False)
		self.ui.button_textline.setChecked(False)
		self.ui.button_fixdot.setChecked(False)
		self.ui.button_image.setChecked(False)
		self.ui.button_gabor.setChecked(False)
		self.ui.button_noise_patch.setChecked(False)

		self.ui.edit_color.hide()
		self.ui.spin_penwidth.hide()
		self.ui.spin_scale.hide()
		self.ui.spin_arrow_size.hide()
		self.ui.checkbox_fill.hide()
		self.ui.checkbox_center.hide()
		self.ui.checkbox_html.hide()
		self.ui.widget_font.hide()

		self.ui.label_options.hide()
		self.ui.label_color.hide()
		self.ui.label_penwidth.hide()
		self.ui.label_scale.hide()
		self.ui.label_arrow_size.hide()

	def set_rect(self):

		"""Activate the rect button"""

		self.unset_all()
		self.ui.button_rect.setChecked(True)
		self.ui.edit_color.show()
		self.ui.spin_penwidth.show()
		self.ui.checkbox_fill.show()
		self.ui.label_color.show()
		self.ui.label_penwidth.show()
		self.set_tool()

	def set_ellipse(self):

		"""Activate the ellipse button"""

		self.unset_all()
		self.ui.button_ellipse.setChecked(True)
		self.ui.edit_color.show()
		self.ui.spin_penwidth.show()
		self.ui.checkbox_fill.show()
		self.ui.label_color.show()
		self.ui.label_penwidth.show()
		self.set_tool()

	def set_line(self):

		"""Activate the line button"""

		self.unset_all()
		self.ui.button_line.setChecked(True)
		self.ui.edit_color.show()
		self.ui.spin_penwidth.show()
		self.ui.label_color.show()
		self.ui.label_penwidth.show()
		self.set_tool()

	def set_arrow(self):

		"""Activate the line button"""

		self.unset_all()
		self.ui.button_arrow.setChecked(True)
		self.ui.edit_color.show()
		self.ui.spin_penwidth.show()
		self.ui.spin_arrow_size.show()
		self.ui.label_color.show()
		self.ui.label_penwidth.show()
		self.ui.label_arrow_size.show()
		self.set_tool()

	def set_circle(self):

		"""Activate the circle button"""

		self.unset_all()
		self.ui.button_circle.setChecked(True)
		self.ui.edit_color.show()
		self.ui.spin_penwidth.show()
		self.ui.checkbox_fill.show()
		self.ui.label_color.show()
		self.ui.label_penwidth.show()
		self.set_tool()

	def set_fixdot(self):

		"""Activate the fixdot button"""

		self.unset_all()
		self.ui.button_fixdot.setChecked(True)
		self.ui.edit_color.show()
		self.ui.label_color.show()
		self.set_tool()

	def set_image(self):

		"""Activate the image button"""

		self.unset_all()
		self.ui.button_image.setChecked(True)
		self.ui.spin_scale.show()
		self.ui.checkbox_center.show()
		self.ui.label_scale.show()
		self.set_tool()

	def set_textline(self):

		"""Activate the textline button"""

		self.unset_all()
		self.ui.button_textline.setChecked(True)
		self.ui.edit_color.show()
		self.ui.checkbox_center.show()
		self.ui.checkbox_html.show()
		self.ui.label_color.show()
		self.ui.widget_font.show()
		self.set_tool()

	def set_gabor(self):

		"""Activate the textline button"""

		self.unset_all()
		self.ui.button_gabor.setChecked(True)
		self.ui.label_options.show()
		self.set_tool()

	def set_noise(self):

		"""Activate the textline button"""

		self.unset_all()
		self.ui.button_noise_patch.setChecked(True)
		self.ui.label_options.show()
		self.set_tool()

	def add(self, from_pos, to_pos):

		"""
		Add an item to the sketchpad item list

		Arguments:
		from_pos -- an (x, y) tuple containing the top-left corner
		to_pos -- an (x, y) tuple containing the bottom-right corner
		"""

		item = {}
		item["type"] = self.tool
		item["fill"] = self.fill
		item["color"] = self.color
		item["penwidth"] = self.penwidth
		item["show_if"] = self.show_if

		if self.tool in ("ellipse", "rect"):
			if to_pos[0] > from_pos[0]:
				item["x"] = from_pos[0]
				item["w"] = to_pos[0] - from_pos[0]
			else:
				item["x"] = to_pos[0]
				item["w"] = from_pos[0] - to_pos[0]

			if to_pos[1] > from_pos[1]:
				item["y"] = from_pos[1]
				item["h"] = to_pos[1] - from_pos[1]
			else:
				item["y"] = to_pos[1]
				item["h"] = from_pos[1] - to_pos[1]

		elif self.tool in ("arrow", "line"):
			item["x1"] = from_pos[0]
			item["y1"] = from_pos[1]
			item["x2"] = to_pos[0]
			item["y2"] = to_pos[1]
			item["arrow_size"] = self.arrow_size

		elif self.tool == "fixdot":
			item["x"] = to_pos[0]
			item["y"] = to_pos[1]

		elif self.tool == "circle":
			item["x"] = from_pos[0]
			item["y"] = from_pos[1]
			item["r"] = 2 * math.sqrt( (from_pos[0] - to_pos[0]) ** 2 + (from_pos[1] - to_pos[1]) ** 2 )

		elif self.tool == "textline":
			text, ok = QtGui.QInputDialog.getText(self.ui.view, \
				_("New textline"), _("Please enter a text for the textline"))
			if not ok:
				return
			item["x"] = to_pos[0]
			item["y"] = to_pos[1]
			item["text"] = self.sketchpad.experiment.sanitize(text)
			item["center"] = self.center
			item["html"] = self.html
			item["font_family"] = self.font_family
			item["font_size"] = self.font_size
			item["font_italic"] = self.sketchpad.experiment.auto_type( \
				self.font_italic)
			item["font_bold"] = self.sketchpad.experiment.auto_type( \
				self.font_bold)

		elif self.tool == "image":
			path = pool_widget.select_from_pool(self.sketchpad.experiment.main_window)
			if path == None or unicode(path) == "":
				return
			item["x"] = to_pos[0]
			item["y"] = to_pos[1]
			item["file"] = unicode(path)
			item["scale"] = self.scale
			item["center"] = self.center

		elif self.tool == "gabor":
			item["x"] = to_pos[0]
			item["y"] = to_pos[1]
			item = self.gabor_dialog(item)
			if item == None:
				return

		elif self.tool == "noise":
			item["x"] = to_pos[0]
			item["y"] = to_pos[1]
			item = self.noise_dialog(item)
			if item == None:
				return

		item = self.sketchpad.unfix_coordinates(item)
		self.sketchpad.items.append(item)
		self.sketchpad.apply_edit_changes()
		self.refresh()

	def gabor_dialog(self, item):

		"""
		Presents the Gabor dialog and adds the relevant
		parameters to an item

		Arguments:
		item -- the item to be filled in

		Returns:
		The passed item, but filled in with all the relevant parameters
		"""

		d = QtGui.QDialog(self)
		d.ui = gabor_dialog_ui.Ui_gabor_dialog()
		d.ui.setupUi(d)
		self.sketchpad.experiment.main_window.theme.apply_theme(d)
		resp = d.exec_()
		if resp == QtGui.QDialog.Accepted:
			env = ["gaussian", "linear", "circular", "rectangle"]
			bgmode = ["avg", "col2"]
			item["orient"] = d.ui.spin_orient.value()
			item["size"] = d.ui.spin_size.value()
			item["env"] = env[d.ui.combobox_env.currentIndex()]
			item["stdev"] = d.ui.spin_stdev.value()
			item["freq"] = d.ui.spin_freq.value()
			item["phase"] = d.ui.spin_phase.value()
			item["color1"] = unicode(d.ui.edit_color1.text())
			item["color2"] = unicode(d.ui.edit_color2.text())
			item["bgmode"] = bgmode[d.ui.combobox_bgmode.currentIndex()]
			return item
		return None

	def noise_dialog(self, item):

		"""
		Presents the noise dialog and adds the relevant
		parameters to an item

		Arguments:
		item -- the item to be filled in

		Returns:
		The passed item, but filled in with all the relevant parameters
		"""

		d = QtGui.QDialog(self)
		d.ui = noise_patch_dialog_ui.Ui_noise_patch_dialog()
		d.ui.setupUi(d)
		self.sketchpad.experiment.main_window.theme.apply_theme(d)
		resp = d.exec_()
		if resp == QtGui.QDialog.Accepted:
			env = ["gaussian", "linear", "circular", "rectangle"]
			bgmode = ["avg", "col2"]
			item["size"] = d.ui.spin_size.value()
			item["env"] = env[d.ui.combobox_env.currentIndex()]
			item["stdev"] = d.ui.spin_stdev.value()
			item["color1"] = unicode(d.ui.edit_color1.text())
			item["color2"] = unicode(d.ui.edit_color2.text())
			item["bgmode"] = bgmode[d.ui.combobox_bgmode.currentIndex()]
			return item
		return None

	def rect(self, x, y, w, h, pen, brush):

		"""Draw rectangle"""

		return self.scene.addRect(x, y, w, h, pen, brush)

	def ellipse(self, x, y, w, h, pen, brush):

		"""Draw ellipse"""

		return self.scene.addEllipse(x, y, w, h, pen, brush)

	def fixdot(self, x, y, color):

		"""Draw fixation dot"""

		color = QtGui.QColor(color)
		pen = QtGui.QPen()
		pen.setColor(color)
		brush = QtGui.QBrush()
		brush.setColor(color)
		brush.setStyle(QtCore.Qt.SolidPattern)
		r1 = 8
		r2 = 2
		i = self.scene.addEllipse(x - r1, y - r1, 2*r1, 2*r1, pen, brush)
		brush.setColor(QtGui.QColor(self.sketchpad.get("background", \
			_eval=False)))
		self.scene.addEllipse(x - r2, y - r2, 2*r2, 2*r2, pen, brush)
		return i

	def arrow(self, sx, sy, ex, ey, arrow_size, pen):

		"""Draw arrow"""

		i = self.scene.addLine(sx, sy, ex, ey, pen)
		a = math.atan2(ey - sy, ex - sx)
		_sx = ex + arrow_size * math.cos(a + math.radians(135))
		_sy = ey + arrow_size * math.sin(a + math.radians(135))
		self.scene.addLine(_sx, _sy, ex, ey, pen)
		_sx = ex + arrow_size * math.cos(a + math.radians(225))
		_sy = ey + arrow_size * math.sin(a + math.radians(225))
		self.scene.addLine(_sx, _sy, ex, ey, pen)
		return i

	def line(self, x1, y1, x2, y2, pen):

		"""Draw line"""

		return self.scene.addLine(x1, y1, x2, y2, pen)

	def textline(self, text, center, x, y, color, font_family, font_size, \
		font_bold, font_italic):

		"""Draw textline"""

		if font_family == "serif" and os.name == "nt":
			font_family = "times" # WINDOWS HACK: Windows doesn't recognize serif
		if font_bold:
			weight = QtGui.QFont.Bold
		else:
			weight = QtGui.QFont.Normal
		font = QtGui.QFont(font_family, font_size, weight, font_italic)
		text_item = self.scene.addText(text, font)
		text_item.setDefaultTextColor(QtGui.QColor(color))
		if center:
			r = text_item.boundingRect()
			text_item.setPos(x - 0.5 * r.width(), y - 0.5 * r.height())
		else:
			text_item.setPos(x, y)
		return text_item

	def image(self, path, center, x, y, scale):

		"""Draw image"""

		pixmap = QtGui.QPixmap(path)

		if pixmap.isNull():
			# Qt4 cannot handle certain funky bitmaps that PyGame can. So if
			# loading the image directly fails, we fall back to loading the
			# image with PyGame and converting it to a QPixmap. In addition, we
			# notify the user that he/ she is using a funky bitmap.
			import pygame
			im = pygame.image.load(path)
			data = pygame.image.tostring(im, "RGBA")
			size = im.get_size()
			image = QtGui.QImage(data, size[0], size[1], \
				QtGui.QImage.Format_ARGB32)
			pixmap = QtGui.QPixmap.fromImage(image)
			self.notifications.append( \
				_("Funky image alert: '%s' has a non-standard format. It is recommended to convert this image to .png format, for example with Gimp <http://www.gimp.org/>.") \
				% os.path.basename(path))

		w = pixmap.width()*scale
		pixmap = pixmap.scaledToWidth(w)
		_item = self.scene.addPixmap(pixmap)
		if center:
			_item.setPos(x - 0.5 * pixmap.width(), y - 0.5 * pixmap.height())
		else:
			_item.setPos(x, y)
		return _item

	def gabor(self, item):

		"""Draw gabor patch"""

		path = openexp.canvas.gabor_file(item["orient"], item["freq"], \
			item["env"], item["size"], item["stdev"], item["phase"], \
			item["color1"], item["color2"], item["bgmode"])
		pixmap = QtGui.QPixmap(path)
		_item = self.scene.addPixmap(pixmap)
		_item.setPos(item["x"]-0.5*pixmap.width(), \
			item["y"]-0.5*pixmap.height())
		return _item

	def noise(self, item):

		"""Draw noise patch"""

		path = openexp.canvas.noise_file(item["env"], item["size"], \
			item["stdev"], item["color1"], item["color2"], item["bgmode"])
		pixmap = QtGui.QPixmap(path)
		_item = self.scene.addPixmap(pixmap)
		_item.setPos(item["x"]-0.5*pixmap.width(), \
			item["y"]-0.5*pixmap.height())
		return _item

	def refresh(self):

		"""(Re)draws the canvas and fill the item list."""

		self.scene.clear()
		self.ui.view.setMouseTracking(True)
		w = self.sketchpad.get(u'width')
		h = self.sketchpad.get(u'height')
		# Apply the zoom level
		self.ui.view.setFixedSize(self.zoom*w+60, self.zoom*h+60)
		self.ui.view.resetTransform()
		self.ui.view.scale(self.zoom, self.zoom)
		# Set the foreground
		self.ui.edit_color.initialize(self.sketchpad.experiment, color= \
			self.color)
		# Set the background
		brush = QtGui.QBrush()
		brush.setColor(QtGui.QColor(self.sketchpad.get(u'background', \
			_eval=False)))
		brush.setStyle(QtCore.Qt.SolidPattern)
		self.ui.view.setBackgroundBrush(brush)
		# Optionally draw a grid
		if self.show_grid and self.zoom * self.scene.grid >= 5:
			self.scene.draw_grid()
		# Initialize the notifications
		self.notifications = []
		static_items = self.sketchpad.static_items()
		not_shown = len(self.sketchpad.items) - len(static_items)
		if not_shown > 1:
			self.notifications.append( \
				_(u"%d objects are not shown, because they are defined using variables.") \
				% not_shown)
		elif not_shown == 1:
			self.notifications.append( \
				_(u"One object is not shown, because it is defined using variables."))
		if self.sketchpad.items_out_of_bounds() > 0:
			self.notifications.append( \
				_(u"Some objects will not be visible (or partly) because they fall outside of the screen boundaries."))
		# Walk through all items and show them
		self.item_list = []
		for item in static_items:
			g = None
			try:
				s = self.sketchpad.item_to_string(item)
				item = self.sketchpad.fix_coordinates(item)

				# Set the pen and the brush
				pen = QtGui.QPen()
				pen.setWidth(item["penwidth"])
				pen.setColor(QtGui.QColor(item["color"]))
				brush = QtGui.QBrush()
				if item["fill"] == 1:
					brush.setColor(QtGui.QColor(item["color"]))
					brush.setStyle(QtCore.Qt.SolidPattern)

				if item["type"] == "rect":
					g = self.rect(item["x"], item["y"], item["w"], item["h"], \
						pen, brush)
				elif item["type"] == "circle":
					g = self.ellipse(item["x"]-0.5*item["r"], \
						item["y"]-0.5*item["r"], item["r"], item["r"], pen, \
						brush)
				elif item["type"] == "ellipse":
					g = self.ellipse(item["x"], item["y"], item["w"], \
						item["h"], pen, brush)
				elif item["type"] == "fixdot":
					g = self.fixdot(item["x"], item["y"], item["color"])
				elif item["type"] == "arrow":
					g = self.arrow(item["x1"], item["y1"], item["x2"], \
						item["y2"], item["arrow_size"], pen)
				elif item["type"] == "line":
					g = self.line(item["x1"], item["y1"], item["x2"], \
						item["y2"], pen)
				elif item["type"] == "textline":
					g = self.textline(item["text"], item["center"]==1, \
						item["x"], item["y"], item["color"], \
						item["font_family"], item["font_size"], \
						item['font_bold'] == 'yes', item['font_italic'] == 'yes')
				elif item["type"] == "image":
					g = self.image(self.sketchpad.experiment.get_file( \
						item["file"]), item["center"]==1, item["x"], \
						item["y"], item["scale"])
				elif item["type"] == "gabor":
					g = self.gabor(item)
				elif item["type"] == "noise":
					g = self.noise(item)
				else:
					print("Could not find", item["type"])

			except Exception as e:
				debug.msg("exception caught: %s" % e)
				self.notifications.append( \
					_("Failed to parse the following item (use 'Edit script' to fix/ remove this line):\n'%s'") \
					% s)

			# Add a tooltip to the scene element
			if g != None:
				g.setToolTip(s)
				self.item_list.append( (g, item) )

		# Show the notifications (if any)
		if len(self.notifications) > 0:
			self.ui.frame_notification.setVisible(True)
			self.ui.label_notification.setText("\n- ".join(["Notifications:"] + \
				self.notifications))
		else:
			self.ui.frame_notification.setVisible(False)

		# Add the items to the list below the sketchpad
		self.sketchpad.experiment.clear_widget(self.ui.widget_items)
		row = 0
		for item in self.sketchpad.items:
			edit = QtGui.QLineEdit(self.sketchpad.item_to_string(item))
			edit.setReadOnly(True)
			hbox = QtGui.QHBoxLayout()
			hbox.setContentsMargins(0, 0, 0, 0)
			hbox.addWidget(edit_item_button(self, item))
			hbox.addWidget(edit)
			hbox.addWidget(remove_item_button(self, item))
			widget = QtGui.QWidget()
			widget.setLayout(hbox)
			self.vbox_items.addWidget(widget)
		self.vbox_items.addStretch()

		return True

	def set_tool(self, dummy=None):

		"""
		Sets the current tool according to the options in the widget.

		Keyword argument:
		dummy	--	DEPRECATED.
		"""

		self.penwidth = self.ui.spin_penwidth.value()
		self.color = self.sketchpad.experiment.sanitize( \
			self.ui.edit_color.text())
		refs = []
		try:
			refs = self.sketchpad.experiment.get_refs(self.color)
			self.sketchpad.experiment.color_check(self.color)
		except Exception as e:
			if len(refs) == 0:
				self.sketchpad.experiment.notify(e)
				self.ui.edit_color.setText(u'white')
				self.color = u'white'

		self.show_grid = self.ui.checkbox_show_grid.isChecked()

		if self.ui.checkbox_fill.isChecked():
			self.fill = 1
		else:
			self.fill = 0
		if self.ui.checkbox_center.isChecked():
			self.center = 1
		else:
			self.center = 0
		self.arrow_size = self.ui.spin_arrow_size.value()
		self.scale = self.ui.spin_scale.value() * 0.01
		self.scene.grid = self.ui.spin_grid.value()
		self.zoom = self.ui.spin_zoom.value() * 0.01
		self.font_family = self.ui.widget_font.family
		self.font_size = self.ui.widget_font.size
		self.font_italic = self.ui.widget_font.italic
		self.font_bold = self.ui.widget_font.bold
		self.show_if = self.sketchpad.clean_cond(self.ui.edit_show_if.text())
		self.ui.edit_show_if.setText(self.show_if)
		if self.ui.checkbox_html.isChecked():
			self.html = u'yes'
		else:
			self.html = u'no'

		if self.ui.button_line.isChecked():
			self.tool = u'line'
			self.scene.oneshot = False
		elif self.ui.button_arrow.isChecked():
			self.tool = u'arrow'
			self.scene.oneshot = False
		elif self.ui.button_rect.isChecked():
			self.tool = u'rect'
			self.scene.oneshot = False
		elif self.ui.button_ellipse.isChecked():
			self.tool = u'ellipse'
			self.scene.oneshot = False
		elif self.ui.button_circle.isChecked():
			self.tool = u'circle'
			self.scene.oneshot = False
		elif self.ui.button_fixdot.isChecked():
			self.tool = u'fixdot'
			self.scene.oneshot = True
		elif self.ui.button_image.isChecked():
			self.tool = u'image'
			self.scene.oneshot = True
		elif self.ui.button_textline.isChecked():
			self.tool = u'textline'
			self.scene.oneshot = True
		elif self.ui.button_gabor.isChecked():
			self.tool = u'gabor'
			self.scene.oneshot = True
		elif self.ui.button_noise_patch.isChecked():
			self.tool = u'noise'
			self.scene.oneshot = True
		self.refresh()





########NEW FILE########
__FILENAME__ = start_new_widget
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt4 import QtCore, QtGui
from libqtopensesame.ui.start_new_widget_ui import Ui_widget_start_new
from libqtopensesame.misc import template_info
import random
import os

class start_new_widget(QtGui.QWidget):

	"""Start new dialog presented when starting with a clean experiment"""
	
	def __init__(self, main_window, start=False):

		"""
		Constructor

		Arguments:
		main_window -- a the main ui
		
		Keyword arguments:
		start -- indicates whether the widget is opened because OpenSesame has
				 started (True) or because the new button has been clicked
				 (False) (default=True)
		"""

		QtGui.QDialog.__init__(self, main_window)

		self.main_window = main_window
		self.ui = Ui_widget_start_new()
		self.ui.setupUi(self)
		self.ui.widget_credits.initialize(self.main_window)
		self.main_window.theme.apply_theme(self)
		if start:
			self.tab_name = '__start_wizard__'
		else:
			self.tab_name = '__new_wizard__'

		# Initialize templates						
		for path, desc in template_info.templates:
			try:
				path = self.main_window.experiment.resource(path)
			except:
				continue
			item = QtGui.QListWidgetItem(self.ui.list_templates)
			item.setText(desc)
			item.file = path
			item.setIcon(self.main_window.experiment.icon("wizard"))
			self.ui.list_templates.addItem(item)
		self.ui.list_templates.setCurrentRow(0)
		self.ui.list_templates.itemDoubleClicked.connect(self.open_template)		

		# Initialize recent
		if len(self.main_window.recent_files) == 0:
			self.ui.list_recent.hide()
			self.ui._label_recent.hide()
		else:		
			for f in self.main_window.recent_files:
				item = QtGui.QListWidgetItem(self.ui.list_recent)
				item.setText(os.path.basename(f))
				item.file = f
				item.setIcon(self.main_window.experiment.icon("experiment"))
			self.ui.list_recent.setCurrentRow(0)	
			self.ui.list_recent.itemDoubleClicked.connect(self.open_recent)
		
		# Connect buttons
		self.ui.button_browse.clicked.connect(self.main_window.open_file)
		self.ui.button_osdoc.clicked.connect( \
			self.main_window.ui.tabwidget.open_osdoc)
		self.ui.button_forum.clicked.connect( \
			self.main_window.ui.tabwidget.open_forum)
		self.ui.button_cancel.clicked.connect(self.cancel)			
			
		# Show the correct header
		if start:
			self.ui.widget_header_new.hide()
		else:
			self.ui.widget_header_start.hide()
			
	def cancel(self):
		
		"""Cancel the start_new_wizard"""
		
		self.main_window.ui.tabwidget.close_current()
		self.main_window.ui.tabwidget.open_general()

	def open_template(self):

		"""Open the selected template"""

		self.main_window.open_file(path= \
			self.ui.list_templates.currentItem().file, add_to_recent=False)
		self.close()

	def open_recent(self):

		"""Open the selected file"""

		item = self.ui.list_recent.currentItem()
		if item != None:
			self.main_window.open_file(path= \
				self.ui.list_recent.currentItem().file)
			self.close()


########NEW FILE########
__FILENAME__ = statusbar
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

__author__ = "Sebastiaan Mathot"
__license__ = "GPLv3"

from PyQt4 import QtCore, QtGui
from libqtopensesame.misc import _

class statusbar(QtGui.QStatusBar):

	"""A fancy statusbar with icons"""

	def __init__(self, parent=None):
	
		"""
		Constructor
		
		Keywords arguments:
		parent -- the parent QWidget
		"""
	
		QtGui.QStatusBar.__init__(self, parent)		
		self.initialized = False
		
	def init(self):
	
		"""Initialize the statusbar"""
	
		self.ready_icon = self.parent().experiment.label_image("status_ready")
		self.busy_icon = self.parent().experiment.label_image("status_busy")
		self.message = QtGui.QLabel()				
		self.addWidget(self.ready_icon)
		self.addWidget(self.busy_icon)
		self.addWidget(self.message)		
		self.initialized = True
		
	def set_status(self, msg, timeout=5000, status="ready"):
	
		"""
		Set a statusbar message
		
		Arguments:
		msg -- the message
		
		Keywords arguments:
		timeout -- the timeout of the message (default=5000)
		status -- the message status (ready/busy) (default='ready')
		"""
	
		if not self.initialized:
			self.init()	
		if status == "ready":
			self.ready_icon.show()
			self.busy_icon.hide()
		else:
			self.ready_icon.hide()
			self.busy_icon.show()	
		self.message.setText("<small>%s</small>" % msg)	
		
		if timeout != None:
			QtCore.QTimer.singleShot(timeout, self.clear_status)	
		
	def clear_status(self):
	
		"""Clear the statusbar to a default ready message"""
	
		self.set_status(_("Ready"), timeout=None)
		

########NEW FILE########
__FILENAME__ = tab_widget
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import debug
from libqtopensesame.misc import config, _
from PyQt4 import QtGui, QtCore

class tab_widget(QtGui.QTabWidget):

	"""A custom tab widget with some extra functionality"""

	def __init__(self, parent=None):

		"""
		Constructor

		Keywords arguments:
		parent -- the parent QWidget
		"""

		QtGui.QTabWidget.__init__(self, parent)
		try:
			self.tabCloseRequested.connect(self.removeTab)
		except:
			# Catch what appears to be a bug in earlier versions of PyQt4.
			self.tabCloseRequested.connect(self._removeTab)
		self.currentChanged.connect(self.index_changed)
		self.setSizePolicy(QtGui.QSizePolicy.MinimumExpanding, \
			QtGui.QSizePolicy.MinimumExpanding)

	def _removeTab(self, i):

		"""
		This is simply a wrapper around QTabWidget.removeTab(). For some reason,
		connecting this function to tabCloseRequested causes an exception on
		older versions of PyQt4. This functions is a workaround.

		Arguments:
		i		--	The index of the tab to close.
		"""

		self.removeTab(i)

	def add(self, widget, icon, name):

		"""
		Open a tab and switch to it

		Arguments:
		widget -- a QWidget for the tab
		icon -- the name of an icon or a QIcon
		name -- a name for the tab
		"""

		self.setCurrentIndex(self.addTab(widget, \
			self.main_window.experiment.icon(icon), _(name)))

	def close_all(self):

		"""Close all tabs"""

		while self.count() > 0:
			self.removeTab(0)

	def close_current(self):

		"""Close the current tab"""

		self.removeTab(self.currentIndex())

	def close_other(self):

		"""Close all tabs except for the currently opened one"""

		while self.count() > 0 and \
			self.currentIndex() != 0:
			self.removeTab(0)
		while self.count() > 1:
			self.removeTab(1)

	def get_index(self, tab_name):

		"""
		Return the index of a specific tab

		Arguments:
		tab_name -- the tab_name of the widget

		Returns:
		The index of the tab or None if the tab wasn't found
		"""

		for i in range(self.count()):
			w = self.widget(i)
			if (hasattr(w, u"tab_name") and w.tab_name == tab_name) or \
				(hasattr(w, tab_name)):
				return i
		return None

	def get_item(self, item):

		"""
		Return the index of a specific item tab

		Arguments:
		item -- the name of the item

		Returns:
		The index of the tab or None if the tab wasn't found
		"""

		for i in range(self.count()):
			w = self.widget(i)
			if (hasattr(w, u"__edit_item__") and w.__edit_item__ == item):
				return i
		return None


	def get_widget(self, tab_name):

		"""
		Return a specific tab

		Arguments:
		tab_name -- the tab_name of the widget

		Returns:
		A QWidget or None if the tab wasn't found
		"""

		i = self.get_index(tab_name)
		if i == None:
			return None
		return self.widget(i)

	def open_about(self):

		"""Open the about help tab"""

		self.open_browser(u'http://osdoc.cogsci.nl/about/')

	def open_browser(self, url):

		"""
		Open a browser tab to browse local or remote HTML files

		Argument:
		url -- a url
		"""

		from libqtopensesame.widgets import webbrowser
		browser = webbrowser.webbrowser(self.main_window)
		browser.load(url)
		self.add(browser, u"web-browser", u'Help')

	def open_help(self, item):

		"""
		Open a help tab for the specified item. Looks for a file called
		[item].html or [item.md] in the resources folder.

		Arguments:
		item -- the item for which help should be displayed
		"""

		import os
		md_path = self.main_window.experiment.help(item + u'.md')
		html_path = self.main_window.experiment.help(item + u'.html')
		if os.path.exists(md_path):
			path = md_path
		elif os.path.exists(html_path):
			path = html_path
		else:
			path = self.main_window.experiment.help(u'missing.md')
		self.open_browser(path)

	def open_backend_settings(self):

		"""Opens the backend settings"""

		if self.switch(u'__backend_settings__'):
			return
		from libqtopensesame.widgets.backend_settings import backend_settings
		self.add(backend_settings(self.main_window), u'backend', \
			u'Back-end settings')

	def open_forum(self):

		"""Open osdoc.cogsci.nl"""

		self.open_browser(u'http://forum.cogsci.nl')

	def open_general(self):

		"""Opens the general tab"""

		if self.switch(u'__general_properties__'):
			return
		from libqtopensesame.widgets.general_properties import general_properties
		w = general_properties(self.main_window)
		self.add(w, u'experiment', u'General properties')

	def open_general_help(self):

		"""Open the general help tab"""

		self.open_help(u'general')

	def open_general_script(self):

		"""Opens the general script editor"""

		if self.switch(u'__general_script__'):
			return
		from libqtopensesame.widgets.general_script_editor import \
			general_script_editor
		self.add(general_script_editor(self.main_window), u'terminal', \
			u'General script editor')

	def open_osdoc(self):

		"""Open osdoc.cogsci.nl"""

		self.open_browser(u'http://osdoc.cogsci.nl')

	def open_stdout_help(self):

		"""Open the debug window help tab"""

		self.open_help(u'stdout')

	def open_unused(self):

		"""Opens the unused tab"""

		if self.switch(u'__general__'):
			return
		from libqtopensesame.widgets.unused_widget import unused_widget
		w = unused_widget(self.main_window)
		self.add(w, u'unused', u'Unused items')

	def open_variables_help(self):

		"""Open the variable inspector help tab"""

		self.open_help(u'variables')

	def open_preferences(self):

		"""Open the preferences tab"""

		from libqtopensesame.widgets import preferences_widget
		if not self.switch(u"__preferences__"):
			self.add(preferences_widget.preferences_widget(self.main_window), \
				u"options", u"Preferences")

	def open_start_new(self, start=False):

		"""
		Opens the start new tab

		Keyword arguments:
		start -- indicates whether the widget is opened because OpenSesame has
				 started (True) or because the new button has been clicked
				 (False) (default=True)
		"""

		if start:
			if self.switch(u'__start_wizard__'):
				return
		else:
			if self.switch(u'__new_wizard__'):
				return
		from libqtopensesame.widgets.start_new_widget import start_new_widget
		w = start_new_widget(self.main_window, start=start)
		self.add(w, u'os-experiment', u'Get started')

	def switch(self, tab_name):

		"""
		Switch to a specific tab

		Returns:
		True if the tab exists, False otherwise
		"""

		i = self.get_index(tab_name)
		if i == None:
			return False
		self.setCurrentIndex(i)
		return True

	def toggle_onetabmode(self):

		"""Toggles onetabmode"""

		config.set_config(u"onetabmode", \
			self.main_window.ui.action_onetabmode.isChecked())
		if config.get_config(u"onetabmode"):
			self.close_other()
		self.setTabsClosable(not config.get_config(u"onetabmode"))
		self.main_window.ui.action_close_other_tabs.setEnabled(not \
			config.get_config(u"onetabmode"))

	def index_changed(self, index):

		"""
		Monitors tab index changes, closing other tabs if onetabmode is enabled

		Arguments:
		index -- the index of the new tab
		"""

		if config.get_config(u"onetabmode"):
			self.close_other()
		w = self.currentWidget()
		if hasattr(w, u'on_activate'):
			w.on_activate()


########NEW FILE########
__FILENAME__ = toolbar_items
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt4 import QtCore, QtGui
import libopensesame.plugins
from libopensesame import debug
from libqtopensesame.misc import config, _

class widget_item(QtGui.QLabel):

	"""A draggable toolbar icon"""

	def __init__(self, pixmap, item, main_window):

		"""
		Constructor

		Arguments:
		icon -- a QIcon
		item -- the item name
		main_window -- the main window
		"""

		self.main_window = main_window
		self.item = item
		self.pixmap = pixmap

		QtGui.QLabel.__init__(self)
		self.setMargin(6)
		self.setToolTip( \
			_("Drag this <b>%s</b> item to the intended location in the overview area or into the item list of a sequence tab") \
			% self.item)
		self.setCursor(QtGui.QCursor(QtCore.Qt.OpenHandCursor))
		self.setPixmap(self.pixmap)

	def mouseMoveEvent(self, e):

		"""
		Start a drag operation and drop it if it was accepted by item overview

		Arguments:
		e -- a mouse event
		"""

		if e.buttons() != QtCore.Qt.LeftButton:
			return

		mimedata = QtCore.QMimeData()
		mimedata.setText("__osnew__ %s" % self.item)

		drag = QtGui.QDrag(self)
		drag.setMimeData(mimedata)
		drag.setHotSpot(e.pos() - self.rect().topLeft())
		drag.setPixmap(self.pixmap)

		if drag.start(QtCore.Qt.CopyAction) == QtCore.Qt.CopyAction:
			if self.item == "loop":
				self.main_window.drop_item(self.main_window.add_loop)
			elif self.item == "sequence":
				self.main_window.drop_item(self.main_window.add_sequence)
			else:
				self.main_window.drop_item(self.item)
		else:
			debug.msg("drop cancelled")

class toolbar_label(QtGui.QFrame):

	"""A toolbar label"""

	def __init__(self, label):

		"""
		Constructor

		Arguments:
		label -- the text for the label
		"""

		QtGui.QWidget.__init__(self)

		l = QtGui.QLabel(label)
		l.setMaximumWidth(90)
		l.setIndent(5)
		l.setWordWrap(True)

		hbox = QtGui.QHBoxLayout()
		hbox.addWidget(l)
		hbox.setMargin(0)

		self.setLayout(hbox)

class toolbar_items(QtGui.QToolBar):

	"""This class implements the drag-and-droppable item toolbar"""

	def __init__(self, parent=None):

		"""
		Constructor

		Keywords arguments:
		parent -- parent widget
		"""

		QtGui.QToolBar.__init__(self, parent)
		self.main_window = None
		self.orientationChanged.connect(self.build)

	def add_content(self, content):

		"""
		Add double rows of content to the toolbar

		Arguments:
		content -- a list of content widgets
		"""

		if self.orientation() == QtCore.Qt.Horizontal:
			for c in content:
				self.addWidget(c)
		else:
			i = 0
			for c in content:
				if i % 2 == 0:
					if i > 0:
						self.addWidget(w)
					l = QtGui.QHBoxLayout()
					l.setSpacing(16)
					w = QtGui.QWidget()
					w.setLayout(l)
				c.setMargin(0)
				l.addWidget(c)
				i += 1
			if i % 2 == 1:
				l.addStretch()
			self.addWidget(w)

	def build(self, dummy=None):

		"""
		Populate the toolbar with items (core and plugins)

		Keywords arguments:
		dummy -- a dummy argument (default=None)
		"""

		# Only do something if the main_window has been attached
		if self.main_window == None:
			return

		# Remove old items
		self.clear()

		if self.orientation() == QtCore.Qt.Vertical:
			self.addWidget(toolbar_label(_("<small>Commonly used</small>")))

		# Add the core items
		content = []
		for item in self.main_window.experiment.core_items:
			content.append(widget_item(self.main_window.theme.qpixmap(item, \
				size=config.get_config("toolbar_size")), item, \
				self.main_window))
		self.add_content(content)

		# Create a dictionary of plugins by category. We also maintain a list
		# to preserve the order of the categories.
		cat_list = []
		cat_dict = {}
		for plugin in libopensesame.plugins.list_plugins():
			cat = libopensesame.plugins.plugin_category(plugin)
			if cat not in cat_dict:
				cat_dict[cat] = []
				cat_list.append(cat)
			cat_dict[cat].append(plugin)

		# Add the plugins
		for cat in cat_list:
			self.addSeparator()
			if self.orientation() == QtCore.Qt.Vertical:
				self.addWidget(toolbar_label("<small>%s</small>" % cat))
			content = []
			for plugin in cat_dict[cat]:
				debug.msg("adding plugin '%s'" % plugin)
				if config.get_config("toolbar_size") == 16:
					pixmap = QtGui.QPixmap( \
						libopensesame.plugins.plugin_icon_small(plugin))
				else:
					pixmap = QtGui.QPixmap( \
						libopensesame.plugins.plugin_icon_large(plugin))					
				content.append(widget_item(pixmap, plugin, self.main_window))
			self.add_content(content)



########NEW FILE########
__FILENAME__ = tree_overview
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt4 import QtCore, QtGui
from libqtopensesame.widgets import draggables, item_context_menu
from libopensesame import debug


class tree_overview(QtGui.QTreeWidget):

	"""The drag-and-droppable overview tree"""

	def __init__(self, parent):

		"""
		Constructor

		Arguments:
		parent 	--	The parent item.
		"""

		QtGui.QTreeWidget.__init__(self, parent)

	def dragEnterEvent(self, e):

		"""
		Accept an incoming drag event

		Arguments:
		e -- a QDragEvent
		"""

		if e.mimeData().hasText():
			e.setDropAction(QtCore.Qt.CopyAction)
			e.accept()
		else:
			e.ignore()

	def dragMoveEvent(self, e):

		"""
		Highlight the appropriate item while a drop is being moved

		Arguments:
		e -- a QDragEvent
		"""

		if e.mimeData().hasText():
			e.setDropAction(QtCore.Qt.CopyAction)
			for item in self.selectedItems():
				item.setSelected(False)
			item = self.itemAt(e.pos())
			if item != None:
				item.setSelected(True)
			e.accept()
		else:
			e.ignore()

	def dropEvent(self, e):

		"""
		Accepts a drop event.

		Arguments:
		e 	--	A QDropEvent.
		"""

		# Open files by drag-and-drop
		if e.mimeData().hasUrls():
			urls = e.mimeData().urls()
			if len(urls) == 0:
				debug.msg(u'An empty URL list was dropped')
				return
			url = urls[0]
			if not url.isLocalFile():
				debug.msg(u'URL is not a local file')
				return
			path = unicode(url.toLocalFile())
			self.main_window.open_file(path=path)
		elif e.mimeData().hasText():
			s = e.mimeData().text()
			e.setDropAction(QtCore.Qt.CopyAction)
			item = self.itemAt(e.pos())
			if item == None:
				e.ignore()
				return
			# Accept a drop on the toplevel item
			if item.parent() == None:
				self.main_window.experiment.notify( \
					u'You cannot change the entry point of the experiment!')
				return
			index = 0
			while True:
				item_name = unicode(item.text(0))
				if item_name not in self.main_window.experiment.items:
					e.ignore()
					return
				item_type = \
					self.main_window.experiment.items[item_name].item_type
				if item_type == u'sequence':
					break
				index = item.parent().indexOfChild(item)
				item = item.parent()
			if item != None:
				item.setSelected(True)
				draggables.drop_target = item_name, index, True
				e.accept()
			else:
				e.ignore()
		else:
			e.ignore()

	def context_menu(self, item, pos=None):

		"""
		Present a context menu for an item.

		Arguments:
		item -- a QTreeWidgetItem

		Keyword arguments:
		A position for the top-left of the menu (default=None)
		"""

		target_item = item
		item_name = unicode(target_item.text(0))
		parent_item = target_item.parent()
		if parent_item != None:
			parent_name = unicode(parent_item.text(0))
		else:
			parent_name = None
		index = None
		if parent_name in self.main_window.experiment.items:
			parent_type = \
				self.main_window.experiment.items[parent_name].item_type

			# If the parent is a sequence, get the position of the item in the
			# sequence, because the name by itself is ambiguous since the name
			# may occur multiple times in one sequence
			if parent_type == u'sequence':
				index = 0
				for index in range(parent_item.childCount()):
					child = parent_item.child(index)
					if child == target_item:
						break
					index += 1

		if item_name not in self.main_window.experiment.items:
			return
		item = self.main_window.experiment.items[item_name]
		m = item_context_menu.item_context_menu("Item", self, item, \
			parent_name, index)

		if pos == None:
			m.popup(self.mapToGlobal(self.pos()))
		else:
			m.popup(pos)

	def contextMenuEvent(self, e):

		"""
		Show a context menu at the cursor position

		Arguments:
		e -- the content menu event
		"""

		item = self.itemAt(e.pos())
		self.context_menu(item, e.globalPos())


	def keyPressEvent(self, e):

		"""
		Capture key presses to auto-activate selected items

		Arguments:
		e -- a QKeyEvent
		"""

		QtGui.QTreeWidget.keyPressEvent(self, e)
		if e.key() in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Down, \
			QtCore.Qt.Key_PageUp, QtCore.Qt.Key_PageDown, QtCore.Qt.Key_Home, \
			QtCore.Qt.Key_End, QtCore.Qt.Key_Return]:
			self.main_window.open_item(self.currentItem())
		elif e.key() == QtCore.Qt.Key_Space:
			self.context_menu(self.currentItem())

	def recursive_children(self, item):

		"""
		Get a list of unused items from the itemtree

		Returns:
		A list of items (strings) that are children of the parent item
		"""

		children = []
		for i in range(item.childCount()):
			child = item.child(i)
			children.append(unicode(child.text(0)))
			children += self.recursive_children(child)
		return children

	def unused_items(self):

		"""
		Get a list of unused items

		Returns:
		A list of unused items (names as strings)
		"""

		return self.main_window.ui.itemtree.recursive_children( \
			self.main_window.ui.itemtree.topLevelItem( \
				self.main_window.ui.itemtree.topLevelItemCount()-1))


########NEW FILE########
__FILENAME__ = unused_widget
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import debug
from libqtopensesame.misc import config, _
from PyQt4 import QtGui, QtCore

class unused_widget(QtGui.QWidget):

	"""The unused items widget"""

	def __init__(self, parent=None):

		"""
		Constructor.

		Keywords arguments:
		parent	--	The parent QWidget. (default=None)
		"""
				
		self.main_window = parent
		self.experiment = self.main_window.experiment
		QtGui.QWidget.__init__(self, parent)

		# Set the header, with the icon, label and script button
		header_hbox = QtGui.QHBoxLayout()
		header_hbox.addWidget(self.experiment.label_image(u"unused"))
		header_label = QtGui.QLabel()
		header_label.setText(_(u"<b><font size='5'>Unused</font></b>"))
		header_hbox.addWidget(header_label)
		header_hbox.addStretch()
		header_widget = QtGui.QWidget()
		header_widget.setLayout(header_hbox)

		purge_button = QtGui.QPushButton(self.experiment.icon(u"purge"), \
			_(u"Permanently delete unused items"))
		purge_button.setIconSize(QtCore.QSize(16, 16))
		QtCore.QObject.connect(purge_button, QtCore.SIGNAL(u"clicked()"), \
			self.purge_unused)

		purge_hbox = QtGui.QHBoxLayout()
		purge_hbox.addWidget(purge_button)
		purge_hbox.addStretch()
		purge_widget = QtGui.QWidget()
		purge_widget.setLayout(purge_hbox)

		vbox = QtGui.QVBoxLayout()
		vbox.addWidget(header_widget)
		vbox.addWidget(purge_widget)
		vbox.addStretch()
		
		self.setLayout(vbox)
		self.__unused_tab__ = True

	def purge_unused(self):

		"""Remove all unused items from the items list"""

		# Ask confirmation
		resp = QtGui.QMessageBox.question(self.main_window.ui.centralwidget, \
			_(u"Permanently delete items?"), \
			_(u"Are you sure you want to permanently delete all unused items? This action cannot be undone."), \
			QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)
		if resp == QtGui.QMessageBox.No:
			return
		
		# We need a loop, because items may become unused
		# by deletion of their unused parent items
		while len(self.main_window.experiment.unused_items) > 0:
			for item in self.main_window.experiment.unused_items:
				if item in self.main_window.experiment.items:
					del self.main_window.experiment.items[item]
			self.main_window.experiment.build_item_tree()
						
		# Notify dispatch
		self.main_window.dispatch.event_structure_change.emit(u'')		
		self.main_window.ui.tabwidget.close_all()
		self.main_window.ui.tabwidget.open_general()
########NEW FILE########
__FILENAME__ = user_hint_widget
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

__author__ = "Sebastiaan Mathot"
__license__ = "GPLv3"

from libqtopensesame.ui import user_hint_widget_ui
from PyQt4 import QtGui

class user_hint_widget(QtGui.QFrame):

	"""Provides various informative hints to the user"""

	def __init__(self, parent, item):

		"""
		Constructor.

		Arguments:
		parent		--	The parent QWidget.
		item		--	The item to provide a header for.
		"""

		QtGui.QWidget.__init__(self)	
		self.main_window = parent
		self.item = item
		self.ui = user_hint_widget_ui.Ui_user_hint_widget()
		self.ui.setupUi(self)
		self.ui.button_edit_script.clicked.connect(self.item.open_script_tab)
		self.main_window.theme.apply_theme(self)
		self.hide()
		
	def add_user_hint(self, hint):
		
		"""
		Adds a user hint.
		
		Arguments:
		hint		--	A text with the user hint.
		"""
		
		self.hints.append(hint)

	def clear(self):
		
		"""Clears all user hints."""
		
		self.hints = []
		self.hide()
		
	def refresh(self):
		
		"""Updates the widget with the current user hints."""
		
		if len(self.hints) == 0:
			self.hide()
			return		
		s = '\n'.join(self.hints)
		self.ui.label_user_hint.setText(s)
		self.show()
########NEW FILE########
__FILENAME__ = variable_inspector
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

__author__ = "Sebastiaan Mathot"
__license__ = "GPLv3"

from libopensesame import debug
from PyQt4 import QtCore, QtGui

class sortable(QtGui.QTableWidgetItem):

	"""A sortable tablewidget"""

	def __init__(self, text, sort_key):

		"""
		Constructor

		Arguments:
		text -- the cell text
		sort_key -- the key to use for sorting
		"""

		QtGui.QTableWidgetItem.__init__(self, text, \
			QtGui.QTableWidgetItem.UserType)
		self.sort_key = sort_key

	def __lt__(self, other):

		"""
		Sort operator (less than)

		Arguments:
		other -- the other sortable
		"""

		return self.sort_key < other.sort_key

class variable_inspector(QtGui.QTableWidget):

	"""The table for the variable inspector"""

	def __init__(self, parent=None):

		"""
		Constructor

		Keywords arguments:
		parent -- the parent QWidget
		"""

		QtGui.QTableWidget.__init__(self, parent)
		self.unsorted = True

	def refresh(self):

		"""Updates and restores the variable inspector"""

		debug.msg()
		if self.unsorted:
			self.sortItems(0, QtCore.Qt.AscendingOrder)
			self.unsorted = False
		scrollpos = self.verticalScrollBar().sliderPosition()
		col = self.currentColumn()
		row = self.currentRow()
		filt = unicode(self.main_window.ui.edit_variable_filter.text())
		self.setSortingEnabled(False)
		i = 0
		for var, val, item in self.main_window.experiment.var_list(filt):
			self.insertRow(i)
			val = self.main_window.experiment.unistr(val)
			self.setItem(i, 0, sortable(var, u'%s_%s_%s' % (var,val,item)))
			self.setItem(i, 1, sortable(val, u'%s_%s_%s' % (val,var,item)))
			self.setItem(i, 2, sortable(item, u'%s_%s_%s' % (item,var,val)))
			i += 1
		self.setRowCount(i)
		self.setSortingEnabled(True)
		self.setCurrentCell(row, col)
		self.verticalScrollBar().setSliderPosition(scrollpos)


########NEW FILE########
__FILENAME__ = webbrowser
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt4 import QtCore, QtGui, QtWebKit
from libopensesame import debug
from libqtopensesame.ui import webbrowser_widget_ui
import os.path
import sys

class small_webview(QtWebKit.QWebView):

	"""
	A wrapper around QWebView too override the sizeHint, which prevents the
	browser from resizing to small sizes
	"""

	def sizeHint(self):

		"""
		Give size hint

		Returns:
		A QSize
		"""

		return QtCore.QSize(100,100)

class webbrowser(QtGui.QWidget):

	"""A simple browser tab"""

	def __init__(self, parent):

		"""
		Constructor

		Keyword arguments:
		parent -- the parent QWidget (default=None)
		"""

		QtGui.QWidget.__init__(self, parent)
		self.main_window = parent
		self.ui = webbrowser_widget_ui.Ui_webbrowser_widget()
		self.ui.setupUi(self)

		self.ui.webview = small_webview(self)
		self.ui.webview.loadProgress.connect(self.update_progressbar)
		self.ui.webview.loadStarted.connect(self.load_started)
		self.ui.webview.loadFinished.connect(self.load_finished)
		self.ui.webview.urlChanged.connect(self.url_changed)
		self.ui.layout_main.addWidget(self.ui.webview)
		self.ui.button_back.clicked.connect(self.ui.webview.back)
		self.ui.button_osdoc.clicked.connect(self.open_osdoc)
		self.ui.button_forum.clicked.connect(self.open_forum)
		self.main_window.theme.apply_theme(self)

	def load(self, url):

		"""
		Load a webpage

		Arguments:
		url -- the webpage to load
		"""

		if url.endswith(u'.md'):
			try:
				import markdown
				html = markdown.markdown(open(url).read().decode(u'utf-8', \
					'ignore'))
				html += u'<style type="text/css">%s</style>' % \
					open(self.main_window.theme.resource( \
					u'markdown.css')).read()
			except Exception as e:
				debug.msg(self.main_window.experiment.unistr(e))
				html = \
					u'<p>Python markdown must be installed to view this page. Sorry!</p>'
			self.ui.webview.setHtml(html, QtCore.QUrl(url))
		else:
			self.ui.webview.load(QtCore.QUrl(url))

	def load_finished(self):

		"""Hide the statusbar to indicate that loading is finished"""

		self.ui.label_load_progress.setText(u'Done')

	def update_progressbar(self, progress):

		"""
		Update the progressbar to indicate the load progress

		Arguments:
		progress -- the load progress
		"""

		self.ui.label_load_progress.setText(u'%d%%' % progress)

	def load_started(self):

		"""Show the statusbar to indicate that loading has started"""

		self.ui.label_load_progress.setText(u'Starting ...')

	def open_osdoc(self):

		"""Open osdoc.cogsci.nl"""

		self.load(u'http://osdoc.cogsci.nl/')

	def open_forum(self):

		"""Open forum.cogsci.nl"""

		self.load(u'http://forum.cogsci.nl/')

	def url_changed(self, url):

		"""Update the url bat"""

		self.ui.edit_url.setText(url.toString())

########NEW FILE########
__FILENAME__ = backend_info
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

legacy = {
	"description" : "uses PyGame, maximum stability", \
	"canvas" : "legacy", \
	"keyboard" : "legacy", \
	"mouse" : "legacy", \
	"sampler" : "legacy", \
	"synth" : "legacy", \
	"icon" : "os-pygame"
	}
	
opengl = {
	"description" : "uses PyGame and OpenGL", \
	"canvas" : "opengl", \
	"keyboard" : "legacy", \
	"mouse" : "legacy", \
	"sampler" : "legacy", \
	"synth" : "legacy", \
	"icon" : "os-pygame"	
	}	

psycho = {
	"description" : "uses PsychoPy, powerful stimulus generation", \
	"canvas" : "psycho", \
	"keyboard" : "psycho", \
	"mouse" : "psycho", \
	"sampler" : "legacy", \
	"synth" : "legacy", \
	"icon" : "os-psychopy"	
	}
	
xpyriment = {
	"description" : "uses Expyriment", \
	"canvas" : "xpyriment", \
	"keyboard" : "legacy", \
	"mouse" : "xpyriment", \
	"sampler" : "legacy", \
	"synth" : "legacy", \
	"icon" : "os-expyriment"
	}	
	
droid = {
	"description" : "for Android devices", \
	"canvas" : "droid", \
	"keyboard" : "droid", \
	"mouse" : "droid", \
	"sampler" : "legacy", \
	"synth" : "droid", \
	"icon" : "os-android"
	}	
	
backend_list = {}
backend_list["legacy"] = legacy
backend_list["xpyriment"] = xpyriment
backend_list["droid"] = droid
backend_list["psycho"] = psycho

def match(experiment):

	"""
	Returns the name of the backend that is currently used by
	the experiment or "custom" if no matching backend is found.
	
	Arguments:
	experiment -- an instance of libopensesame.experiment.experiment
	
	Returns:
	The name of the backend or "custom" if no matching backend is found
	"""
	
	for name in backend_list:	
		backend = backend_list[name]	
		if experiment.canvas_backend == backend["canvas"] and \
			experiment.keyboard_backend == backend["keyboard"] and \
			experiment.mouse_backend == backend["mouse"] and \
			experiment.sampler_backend == backend["sampler"] and \
			experiment.synth_backend == backend["synth"]:			
			return name
	return "custom"

########NEW FILE########
__FILENAME__ = canvas
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import debug
import tempfile
import pygame
import os

temp_files = [] # Contains a list of temporary files that should be cleaned up

class canvas:

	"""A 'magic' class that morphs into the approriate backend from openexp._canvas"""

	def __init__(self, experiment, bgcolor=None, fgcolor=None, auto_prepare=True):

		backend = experiment.canvas_backend
		debug.msg('morphing into %s' % backend)
		mod = __import__('openexp._canvas.%s' % backend, fromlist=['dummy'])
		cls = getattr(mod, backend)
		self.__class__ = cls
		cls.__init__(self, experiment, bgcolor, fgcolor, auto_prepare)

def init_display(experiment):

	"""Call the back-end specific init_display function"""

	backend = experiment.canvas_backend
	debug.msg('morphing into %s' % backend)
	mod = __import__('openexp._canvas.%s' % backend, fromlist=['dummy'])
	mod.init_display(experiment)

def close_display(experiment):

	"""Call the back-end specific close_display function"""

	backend = experiment.canvas_backend
	debug.msg('morphing into %s' % backend)
	mod = __import__('openexp._canvas.%s' % backend, fromlist=['dummy'])
	mod.close_display(experiment)

def clean_up(verbose = False):

	"""
	Cleans up the temporary pool folders

	Keyword arguments:
	verbose		--	a boolean indicating if debugging output should be provided
					(default = False)
	"""

	global temp_files

	if verbose:
		print("canvas.clean_up()")

	for path in temp_files:
		if verbose:
			print("canvas.clean_up(): removing '%s'" % path)
		try:
			os.remove(path)
		except Exception as e:
			if verbose:
				print("canvas.clean_up(): failed to remove '%s': %s" \
					% (path, e))

def gabor_file(orient, freq, env = "gaussian", size = 96, stdev = 12, phase = 0, col1 = "white", col2 = "black", bgmode = "avg"):

	"""
	Creates a temporary file containing a Gabor patch.

	Keyword arguments:
	See canvas.noise_patch()

	Returns:
	A path to the image file
	"""

	global temp_files
	import openexp._canvas.legacy
	surface = openexp._canvas.legacy._gabor(orient, freq, env, size, stdev, phase, col1, col2, bgmode)

	tmp = tempfile.mkstemp(suffix = ".png")	[1]
	pygame.image.save(surface, tmp)
	temp_files.append(tmp)

	return tmp

def noise_file(env = "gaussian", size = 96, stdev = 12, col1 = "white", col2 = "black", bgmode = "avg"):

	"""
	Creates a temporary file containing a noise patch.

	Keyword arguments:
	See canvas.noise_patch()

	Returns:
	A path to the image file
	"""

	global temp_files
	import openexp._canvas.legacy
	surface = openexp._canvas.legacy._noise_patch(env, size, stdev, col1, col2, bgmode)

	tmp = tempfile.mkstemp(suffix = ".png")	[1]
	pygame.image.save(surface, tmp)
	temp_files.append(tmp)

	return tmp


########NEW FILE########
__FILENAME__ = exceptions
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

# For backwards compatibility, we should also define the old openexp exceptions
from libopensesame.exceptions import osexception
openexp_error = osexception
canvas_error = osexception
response_error = osexception
sample_error = osexception
synth_error = osexception
########NEW FILE########
__FILENAME__ = keyboard
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import debug

class keyboard:

	"""
	Based on the keyboard_backend variable in the experiment, this class
	morphs into the appropriate keyboard backend class.
	"""

	def __init__(self, experiment, keylist=None, timeout=None):		
	
		backend = experiment.keyboard_backend		
		debug.msg('morphing into %s' % backend)
		mod = __import__('openexp._keyboard.%s' % backend, fromlist=['dummy'])			
		cls = getattr(mod, backend)
		self.__class__ = cls
		cls.__init__(self, experiment, keylist, timeout)
			


########NEW FILE########
__FILENAME__ = mouse
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import debug

class mouse:

	"""
	Based on the mouse_backend variable in the experiment, this class
	morphs into the appropriate keyboard backend class.
	"""

	def __init__(self, experiment, buttonlist=None, timeout=None, visible=False):
	
		backend = experiment.mouse_backend		
		debug.msg('morphing into %s' % backend)
		mod = __import__('openexp._mouse.%s' % backend, fromlist=['dummy'])			
		cls = getattr(mod, backend)
		self.__class__ = cls
		cls.__init__(self, experiment, buttonlist, timeout, visible)
		

########NEW FILE########
__FILENAME__ = sampler
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import debug

class sampler:

	"""
	This is a dummy class, which morphes into the appropriate backend. For a list of
	functions, see openexp._sampler.legacy
	"""

	def __init__(self, experiment, src):

		backend = experiment.sampler_backend		
		debug.msg('morphing into %s' % backend)
		mod = __import__('openexp._sampler.%s' % backend, fromlist=['dummy'])			
		cls = getattr(mod, backend)
		self.__class__ = cls
		cls.__init__(self, experiment, src)
		

def init_sound(experiment):

	"""Call the back-end specific init_sound function"""

	backend = experiment.sampler_backend		
	debug.msg('morphing into %s' % backend)
	mod = __import__('openexp._sampler.%s' % backend, fromlist=['dummy'])			
	mod.init_sound(experiment)
		
def close_sound(experiment):

	"""Call the back-end specific close_sound function"""

	backend = experiment.sampler_backend		
	debug.msg('morphing into %s' % backend)
	mod = __import__('openexp._sampler.%s' % backend, fromlist=['dummy'])			
	mod.close_sound(experiment)

########NEW FILE########
__FILENAME__ = synth
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import debug

class synth:

	"""
	This is a dummy class, which morphes into the appropriate backend. For a list of
	functions, see openexp._synth.legacy
	"""

	def __init__(self, experiment, osc="sine", freq=440, length=100, attack=0, decay=5):
	
		backend = experiment.synth_backend		
		debug.msg('morphing into %s' % backend)
		mod = __import__('openexp._synth.%s' % backend, fromlist=['dummy'])			
		cls = getattr(mod, backend)
		self.__class__ = cls
		cls.__init__(self, experiment, osc, freq, length, attack, decay)
		


########NEW FILE########
__FILENAME__ = droid
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from math import hypot
import pygame
from openexp._canvas.legacy import legacy
from libopensesame.exceptions import osexception

try:
	import android
except ImportError:
	android = None
	
initialized = False
resolution = 1280, 800 # resolution is hardcoded for now

class droid(legacy):

	"""
	This is a canvas backend for Android devices. It is identical to the legacy
	backend, except for the display initialization.
	"""

	pass

def init_display(experiment):

	"""See openexp._canvas.legacy"""
	
	if experiment.resolution() != resolution:
		raise osexception( \
		'The droid back-end requires a resolution of %d x %d. Your display will be scaled automatically to fit devices with different resolutions.' \
		% resolution)

	# Intialize PyGame
	if not pygame.display.get_init():
		pygame.init()
	experiment.window = pygame.display.set_mode(resolution)	
	experiment.surface = pygame.display.get_surface()	
	# Set the time functions to use pygame
	experiment._time_func = pygame.time.get_ticks
	experiment._sleep_func = pygame.time.delay
	experiment.time = experiment._time_func
	experiment.sleep = experiment._sleep_func
	# Initialze the Android device if necessary
	if android != None:
		android.init()
		android.map_key(android.KEYCODE_BACK, pygame.K_ESCAPE)
		dpi = android.get_dpi()
	else:
		# A dummy dpi if we are not on Android
		dpi = 96
	# Log the device characteristics
	info = pygame.display.Info()
	diag = hypot(info.current_w, info.current_h) / dpi
	if diag < 6: # 6" is the minimum size to be considered a tablet
		is_tablet = 'yes'
	else:
		is_tablet = 'no'
	experiment.set('device_resolution_width', info.current_w)
	experiment.set('device_resolution_height', info.current_h)
	experiment.set('device_dpi', dpi)
	experiment.set('device_screen_diag', diag)
	experiment.set('device_is_tablet', is_tablet)
		
	# Start with a splash screen		
	splash = pygame.image.load(experiment.resource('android-splash.jpg'))
	x = resolution[0]/2 - splash.get_width()/2
	y = resolution[1]/2 - splash.get_height()/2
	experiment.surface.blit(splash, (x,y))	
	for i in range(10):
		pygame.display.flip()
		pygame.time.delay(100)
	if android != None and android.check_pause():
		android.wait_for_resume()

def close_display(experiment):

	"""See openexp._canvas.legacy"""

	# On Android, we don't quit the display, as this appears to exit the
	# application altogether.
	if android == None:
		pygame.display.quit()

########NEW FILE########
__FILENAME__ = legacy
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

import pygame
from pygame.locals import *
import random
import openexp.canvas
import math
import subprocess
import os
import os.path
import tempfile
from libopensesame.exceptions import osexception
from libopensesame import debug, html, misc

# Translation mapping from envelope names
env_synonyms = {}
env_synonyms[u"c"] = u"c"
env_synonyms[u"circular"] = u"c"
env_synonyms[u"round"] = u"c"

env_synonyms[u"g"] = u"g"
env_synonyms[u"gaussian"] = u"g"
env_synonyms[u"gauss"] = u"g"
env_synonyms[u"normal"] = u"g"

env_synonyms[u"r"] = u"r"
env_synonyms[u"rectangular"] = u"r"
env_synonyms[u"rectangle"] = u"r"

env_synonyms[u"g"] = u"g"
env_synonyms[u"rect"] = u"g"
env_synonyms[u"square"] = u"g"
env_synonyms[None] = u"g"

env_synonyms[u"l"] = u"l"
env_synonyms[u"linear"] = u"l"
env_synonyms[u"lin"] = u"l"
env_synonyms[u"ln"] = u"l"
env_synonyms[u"l"] = u"l"

class legacy:

	"""
	The legacy backend is the default backend which uses PyGame to handle all
	display operations.

	This class serves as a template for creating OpenSesame video backends.
	Let's say you want to create a dummy backend. First, create dummy.py in the
	openexp.video folder. In dummy.py, create a dummy class, which is derived
	from openexp.canvas.canvas and which implements all the functions specified
	below.

	After you have done this, the new backend can be activated by adding
	"set video_backend dummy" to the general script. This will make OpenSesame
	use the dummy class instead of the default legacy backend.

	A few guidelines:
	-- Catch exceptions wherever possible and raise an
	   osexception with a clear and descriptive error
	   message.
	-- If you create a temporary file, add its path to the
	   openexp.canvas.temp_files list.
	-- Do not deviate from the guidelines. All back-ends should be
	   interchangeable and transparent to OpenSesame. You are free to add
	   functionality to this class, to be used in inline scripts, but this
	   should not break the basic functionality.
	-- Print debugging output using the debug.msg() function
	"""

	# The settings variable is used by the GUI to provide a list of back-end
	# settings
	settings = {
		u"pygame_hwsurface" : {
			u"name" : u"Hardware surface",
			u"description" : u"Create a hardware surface",
			u"default" : u"yes"
			},
		u"pygame_doublebuf" : {
			u"name" : u"Double buffering",
			u"description" : u"Use double buffering",
			u"default" : u"yes"
			},
		u"pygame_window_frame" : {
			u"name" : u"Draw window frame",
			u"description" : u"Draw a frame in window mode",
			u"default" : u"yes",
			},
		u"pygame_window_pos" : {
			u"name" : u"Window position",
			u"description" : u"Window position in window mode (format: 'x,y' or 'auto')",
			u"default" : u"auto",
			}
		}

	def __init__(self, experiment, bgcolor=None, fgcolor=None, auto_prepare=True):

		"""<DOC>
		Initializes the canvas.

		Arguments:
		experiment -- An instance of libopensesame.experiment.experiment.

		Keyword arguments:
		bgcolor -- A human-readable background color or None to use #
				   experiment default (default=None).
		fgcolor -- A human-readable foreground color or None to use #
				   experiment default (default=None).
		auto_prepare -- Indicates whether the canvas should be automatically #
					    prepared after each drawing operation, so that #
					    canvas.show() will be maximally efficient. If #
					    auto_prepare is turned off, drawing operations may #
					    be faster, but canvas.show() will take longer, #
					    unless canvas.prepare() is explicitly called in #
					    advance. Generally, it only makes sense to disable #
					    auto_prepare when you want to draw a large number #
						of stimuli, as in the second example below. #
						Currently, the auto_prepare parameter only applies #
						to the xpyriment backend, and is ignored by the other #
						backends (default=True).

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> my_canvas.fixdot()
		>>> my_canvas.show()

		Example:
		>>> from openexp.canvas import canvas
		>>> from random import randint
		>>> my_canvas = canvas(exp, auto_prepare=False)
		>>> for i in range(1000):
		>>>		x = randint(0, self.get('width'))
		>>>		y = randint(0, self.get('height'))
		>>> 	my_canvas.fixdot(x, y)
		>>> my_canvas.prepare()
		>>> my_canvas.show()

		</DOC>"""

		self.experiment = experiment
		self.html = html.html()
		if fgcolor == None:
			fgcolor = self.experiment.get(u"foreground")
		if bgcolor == None:
			bgcolor = self.experiment.get(u"background")
		self.set_fgcolor(fgcolor)
		self.set_bgcolor(bgcolor)
		self.penwidth = 1
		self.antialias = True
		self.surface = self.experiment.surface.copy()
		self._current_font = None
		self.bidi = self.experiment.get(u'bidi')==u'yes'
		self.set_font(style=self.experiment.font_family, size= \
			self.experiment.font_size, bold=self.experiment.font_bold==u'yes', \
			italic=self.experiment.font_italic==u'yes', underline= \
			self.experiment.font_underline==u'yes')
		self.clear()

	def color(self, color):

		"""
		Transforms a "human-readable" color into the format that is used by the#
		back-end (e.g., a PyGame color).

		Arguments:
		color -- A color in one the following formats (by example):
			255, 255, 255 (rgb)
			255, 255, 255, 255 (rgba)
			#f57900 (case-insensitive html)
			100 (integer intensity value 0 .. 255, for gray-scale)
			0.1 (float intensity value 0 .. 1.0, for gray-scale)

		Returns:
		A color in the back-end format
		"""

		return _color(color)

	def _font(self):

		"""
		Creates a PyGame font instance.

		Returns:
		A PyGame font.
		"""

		if self._current_font == None:
			# First see if the font refers to a file in the resources/ filepool
			try:
				font_path = self.experiment.resource(u'%s.ttf' % \
					self.font_style)
				self._current_font = pygame.font.Font(font_path, self.font_size)
			# If not, try to match a system font
			except:
				self._current_font = pygame.font.SysFont(self.font_style, \
					self.font_size)
			self._current_font.set_bold(self.font_bold)
			self._current_font.set_italic(self.font_italic)
			self._current_font.set_underline(self.font_underline)
		return self._current_font

	def flip(self, x=True, y=False):

		"""
		Flips the canvas along the x- and/ or y-axis. Note: This does not #
		refresh the display, like e.g., pygame.display.flip(), which is handled #
		by show().

		Keyword arguments:
		x -- A Boolean indicating whether the canvas should be flipped #
			 horizontally (default=True).
		y -- A Boolean indicating whether the canvas should be flipped #
			 vertically (default=False).

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> my_canvas.fixdot(x=100, color='green')
		>>> my_canvas.flip(x=True)
		"""

		self.surface = pygame.transform.flip(self.surface, x, y)

	def copy(self, canvas):

		"""<DOC>
		Turns the current canvas into a copy of the passed canvas. Note: If you #
		want to create a copy of a sketchpad canvas, it is more convenient to #
		use the inline_script.copy_sketchpad() function.

		Arguments:
		canvas -- The canvas to copy.

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> my_canvas.fixdot(x=100, color='green')
		>>> my_copied_canvas = canvas(exp)
		>>> my_copied_canvas.copy(my_canvas)
		>>> my_copied_canvas.fixdot(x=200, color="blue")
		>>> my_copied_canvas.show()
		</DOC>"""

		self.surface = canvas.surface.copy()
		self.font_style = canvas.font_style
		self.font_style = canvas.font_style
		self.penwidth = canvas.penwidth
		self.fgcolor = canvas.fgcolor
		self.bgcolor = canvas.bgcolor

	def xcenter(self):

		"""<DOC>
		Returns:
		The center X coordinate in pixels.

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> x1 = my_canvas.xcenter() - 100
		>>> y1 = my_canvas.ycenter() - 100
		>>> x2 = my_canvas.xcenter() + 100
		>>> y2 = my_canvas.ycenter() + 100
		>>> my_canvas.line(x1, y1, x2, y2)
		</DOC>"""

		return self.experiment.get(u'width') / 2

	def ycenter(self):

		"""<DOC>
		Returns:
		The center Y coordinate in pixels.

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> x1 = my_canvas.xcenter() - 100
		>>> y1 = my_canvas.ycenter() - 100
		>>> x2 = my_canvas.xcenter() + 100
		>>> y2 = my_canvas.ycenter() + 100
		>>> my_canvas.line(x1, y1, x2, y2)
		</DOC>"""

		return self.experiment.get(u'height') / 2

	def prepare(self):

		"""<DOC>
		Finishes up pending canvas operations (if any), so that a subsequent #
		call to show() is extra fast. It's generally not necessary to call this #
		function, unless you use a specific back-end that requires this. Also, #
		see the note on auto_prepare under __init__().
		</DOC>"""

		pass

	def show(self):

		"""<DOC>
		Puts ('flips') the canvas onto the screen.

		Returns:
		A timestamp containing the time at which the canvas actually appeared on #
		the screen (or a best guess).

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> my_canvas.fixdot()
		>>> t = my_canvas.show()
		>>> exp.set('time_fixdot', t)
		</DOC>"""

		self.experiment.surface.blit(self.surface, (0, 0))
		self.experiment.last_shown_canvas = self.surface
		pygame.display.flip()
		return pygame.time.get_ticks()


	def clear(self, color=None):

		"""<DOC>
		Clears the canvas with the current background color. Note that it is #
		generally better to use a different canvas for each experimental display, #
		than to use a single canvas and repeatedly clear and redraw it.

		Keyword arguments:
		color -- A custom human-readable background color to be used. This does #
				not affect the default background color as set by set_bgcolor(). #
				(Default=None)

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> my_canvas.fixdot(color='green')
		>>> my_canvas.show()
		>>> self.sleep(1000)
		>>> my_canvas.clear()
		>>> my_canvas.fixdot(color='red')
		>>> my_canvas.show()
		</DOC>"""

		if color != None:
			color = self.color(color)
		else:
			color = self.bgcolor
		self.surface.fill(color)

	def set_bidi(self, bidi):

		"""<DOC>
		Enables or disables bi-directional text support.

		Arguments:
		bidi	--	True to enable bi-directional text support, False to
					disable.
		</DOC>"""

		self.bidi = bidi

	def set_penwidth(self, penwidth):

		"""<DOC>
		Sets the pen width for subsequent drawing operations.

		Arguments:
		penwidth -- A pen width in pixels.

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> my_canvas.set_penwidth(10)
		>>> my_canvas.line(100, 100, 200, 200)
		</DOC>"""

		self.penwidth = penwidth

	def set_fgcolor(self, color):

		"""<DOC>
		Sets the foreground color for subsequent drawing operations.

		Arguments:
		color -- A color. Acceptable formats are human-readable colors, such as #
				 'red'; and HTML colors, such as '#FF0000'.

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> my_canvas.set_fgcolor('green')
		>>> my_canvas.text('Green text', y=200)
		>>> my_canvas.set_fgcolor('red')
		>>> my_canvas.text('Red text', y=400)
		</DOC>"""

		self.fgcolor = self.color(color)

	def set_bgcolor(self, color):

		"""<DOC>
		Sets the background color for the canvas.

		Arguments:
		color -- A color. Acceptable formats are human-readable colors, such as #
				 'red'; and HTML colors, such as '#FF0000'.

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> my_canvas.set_bgcolor('gray')
		>>> my_canvas.clear()
		</DOC>"""

		self.bgcolor = self.color(color)

	def set_font(self, style=None, size=None, italic=None, bold=None, underline=None):

		"""<DOC>
		Sets the font for subsequent drawing operations.

		Keyword arguments:
		style -- A font style. This can be one of the default fonts #
				 (e.g., 'mono'), a system font (e.g., 'arial'). #
				 or the name of a `.ttf` font file in the file pool (without #
				 the `.ttf` extension).
		size -- A font size in pixels (default=None).
		italic -- Indicates if the font should be italic (default=None).
		bold -- Indicates if the font should be bold (default=None).
		underline -- Indicates if the font should be underlined (default=None).

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> my_canvas.set_font(style='serif', italic=True)
		>>> my_canvas.text('Text in italic serif')
		</DOC>"""

		self._current_font = None
		if style != None: self.font_style = style
		if size != None: self.font_size = size
		if italic != None: self.font_italic = italic
		if bold != None: self.font_bold = bold
		if underline != None: self.font_underline = underline

	def fixdot(self, x=None, y=None, color=None, style=u'default'):

		"""<DOC>
		Draws a fixation dot. Various styles are available ('default' equals #
		'medium-open'):

		- 'large-filled' is a filled circle with a 16px radius.
		- 'medium-filled' is a filled circle with an 8px radius.
		- 'small-filled' is a filled circle with a 4px radius.
		- 'large-open' is a filled circle with a 16px radius and a 2px hole.
		- 'medium-open' is a filled circle with an 8px radius and a 2px hole.
		- 'small-open' is a filled circle with a 4px radius and a 2px hole.
		- 'large-cross' is 16px cross.
		- 'medium-cross' is an 8px cross.
		- 'small-cross' is a 4px cross.

		Keyword arguments:
		x		--	The center X coordinate. None = center (default=None).
		y 		--	The center Y coordinate. None = center (default=None).
		color	--	A custom human-readable foreground color. This does not #
					affect the default foreground color as set by #
					set_fgcolor(). (default=None)
		style	--	One of: default, large-filled, medium-filled, small-filled, #
					large-open, medium-open, small-open, large-cross, #
					medium-cross, small-cross. default equals medium-open. #
					(default=u'default')

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> my_canvas.fixdot()
		"""

		if color != None:
			color = self.color(color)
		else:
			color = self.fgcolor
		if x == None:
			x = self.xcenter()
		if y == None:
			y = self.ycenter()

		h = 2
		if u'large' in style:
			s = 16
		elif u'medium' in style or style == u'default':
			s = 8
		elif u'small' in style:
			s = 4
		else:
			raise osexception(u'Unknown style: %s' % self.style)

		if u'open' in style or style == u'default':
			self.ellipse(x-s, y-s, 2*s, 2*s, True, color=color)
			self.ellipse(x-h, y-h, 2*h, 2*h, True, color=self.bgcolor)
		elif u'filled' in style:
			self.ellipse(x-s, y-s, 2*s, 2*s, True, color=color)
		elif u'cross' in style:
			self.line(x, y-s, x, y+s, color=color)
			self.line(x-s, y, x+s, y, color=color)
		else:
			raise osexception(u'Unknown style: %s' % self.style)

	def circle(self, x, y, r, fill=False, color=None):

		"""<DOC>
		Draws a circle.

		Arguments:
		x -- The center X coordinate.
		y -- The center Y coordinate.
		r -- The radius.

		Keyword arguments:
		fill -- A Boolean indicating whether the circle is outlined (False) #
				or filled (True). (Default=False)
		color -- A custom human-readable foreground color. This does not #
				 affect the default foreground color as set by #
				 set_fgcolor(). (Default=None)

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> my_canvas.circle(100, 100, 50, fill=True, color='red')
		</DOC>"""

		self.ellipse(x-r, y-r, 2*r, 2*r, fill=fill, color=color)

	def line(self, sx, sy, ex, ey, color=None):

		"""<DOC>
		Draws a line.

		Arguments:
		sx -- The left coordinate.
		sy -- The top coordinate.
		ex -- The right coordinate.
		ey -- The bottom coordinate.

		Keyword arguments:
		color -- A custom human-readable foreground color. This does not #
				 affect the default foreground color as set by #
				 set_fgcolor(). (Default=None)

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> w = self.get('width')
		>>> h = self.get('height')
		>>> my_canvas.line(0, 0, w, h)
		</DOC>"""

		if color != None:
			color = self.color(color)
		else:
			color = self.fgcolor
		pygame.draw.line(self.surface, color, (sx, sy), (ex, ey), self.penwidth)

	def arrow(self, sx, sy, ex, ey, arrow_size=5, color=None):

		"""<DOC>
		Draws an arrow. An arrow is a line, with an arrowhead at (ex, ey). The #
		angle between the arrowhead lines and the arrow line is 45 degrees.

		Arguments:
		sx -- The left coordinate.
		sy -- The top coordinate.
		ex -- The right coordinate.
		ey -- The bottom coordinate.

		Keyword arguments:
		arrow_size -- The length of the arrowhead lines (default=5).
		color -- A custom human-readable foreground color. This does not affect #
				the default foreground color as set by set_fgcolor(). #
				(Default=None)

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> w = self.get('width')/2
		>>> h = self.get('height')/2
		>>> my_canvas.line(0, 0, w, h, arrow_size=10)
		</DOC>"""

		self.line(sx, sy, ex, ey, color=color)
		a = math.atan2(ey - sy, ex - sx)
		_sx = ex + arrow_size * math.cos(a + math.radians(135))
		_sy = ey + arrow_size * math.sin(a + math.radians(135))
		self.line(_sx, _sy, ex, ey, color=color)
		_sx = ex + arrow_size * math.cos(a + math.radians(225))
		_sy = ey + arrow_size * math.sin(a + math.radians(225))
		self.line(_sx, _sy, ex, ey, color=color)

	def rect(self, x, y, w, h, fill=False, color=None):

		"""<DOC>
		Draws a rectangle.

		Arguments:
		x -- The left X coordinate.
		y -- The top Y coordinate.
		w -- The width.
		h -- The height.

		Keyword arguments:
		fill -- A Boolean indicating whether the rectangle is outlined (False) #
				or filled (True). (Default=False)
		color -- A custom human-readable foreground color. This does not affect #
				the default foreground color as set by set_fgcolor(). #
				(Default=None)

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> w = self.get('width')-10
		>>> h = self.get('height')-10
		>>> my_canvas.rect(10, 10, w, h, fill=True)
		</DOC>"""

		if color != None:
			color = self.color(color)
		else:
			color = self.fgcolor
		if fill:
			pygame.draw.rect(self.surface, color, (x, y, w, h), 0)
		else:
			pygame.draw.rect(self.surface, color, (x, y, w, h), self.penwidth)

	def ellipse(self, x, y, w, h, fill=False, color=None):

		"""<DOC>
		Draws an ellipse.

		Arguments:
		x -- The left X coordinate.
		y -- The top Y coordinate.
		w -- The width.
		h -- The height.

		Keyword arguments:
		fill -- A Boolean indicating whether the ellipse is outlined (False) or #
				filled (True). (Default=False)
		color -- A custom foreground color. This does not affect the default #
				 foreground color as set by set_fgcolor(). (Default=None)

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> w = self.get('width')-10
		>>> h = self.get('height')-10
		>>> my_canvas.ellipse(10, 10, w, h, fill=True)
		</DOC>"""

		if color != None:
			color = self.color(color)
		else:
			color = self.fgcolor
		x = int(x)
		y = int(y)
		w = int(w)
		h = int(h)
		if fill:
			pygame.draw.ellipse(self.surface, color, (x, y, w, h), 0)
		else:
			# Because the default way of drawing thick lines gives ugly results
			# for ellipses, we draw thick ellipses manually, by drawing an
			# ellipse with the background color inside of it
			i = self.penwidth / 2
			j = self.penwidth - i
			pygame.draw.ellipse(self.surface, color, (x-i, y-i, w+2*i, h+2*i), \
				0)
			pygame.draw.ellipse(self.surface, self.bgcolor, (x+j, y+j, w-2*j, \
				h-2*j), 0)

	def polygon(self, vertices, fill=False, color=None):

		"""<DOC>
		Draws a polygon that consists of multiple vertices (i.e. a shape of #
		points connected by lines).

		Arguments:
		vertices -- A list of tuples, where each tuple corresponds to a vertex. #
					For example, [(100,100), (200,100), (100,200)] will draw a #
					triangle.

		Keyword arguments:
		fill -- A Boolean indicating whether the rectangle is outlined (False) #
				or filled (True). (Default=False)
		color -- A custom human-readable foreground color. This does not affect #
				the default foreground color as set by set_fgcolor(). #
				(Default=None)

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> n1 = 0,0
		>>> n2 = 100, 100
		>>> n3 = 0, 100
		>>> my_canvas.polygon([n1, n2, n3])
		</DOC>"""

		if color != None:
			color = self.color(color)
		else:
			color = self.fgcolor
		if fill:
			width = 0
		else:
			width = self.penwidth
		pygame.draw.polygon(self.surface, color, vertices, width)

	def text_size(self, text):

		"""<DOC>
		Determines the size of a text string in pixels.

		Arguments:
		text -- The text string.

		Returns:
		A (width, height) tuple containing the dimensions of the text string.

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> w, h = my_canvas.text_size('Some text')
		</DOC>"""

		return self._font().size(text)

	def text(self, text, center=True, x=None, y=None, max_width=None, color=None, bidi=None, html=True):

		"""<DOC>
		Draws text.

		Arguments:
		text		--	The text string.

		Keyword arguments:
		center		--	A Boolean indicating whether the coordinates reflect the
						center (True) or top-left (default=True).
		x			--	The X coordinate. None = center. (Default=None)
		y			--	The Y coordinate. None = center. (Default=None)
		max_width	--	The maximum width of the text, before wrapping to a new
						line, or None to wrap at screen edge (default=None)
		color		--	A custom human-readable foreground color. This does not
						affect the default foreground color as set by
						set_fgcolor(). (Default=None)
		bidi		--	True or False for bi-directional text support, or None
						to use experiment default. This does not affect the
						default bidi setting as set by set_bidi().
						(Default=None)
		html		--	Indicates whether HTML tags should be parsed
						(default=True).

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> my_canvas.text('Some text with <b>boldface</b> and <i>italics</i>')
		</DOC>"""

		if color != None: color = self.color(color)
		else: color = self.fgcolor
		if bidi == None: bidi = self.bidi
		if x == None: x = self.xcenter()
		if y == None: y = self.ycenter()
		self.html.reset()
		self.html.render(text, x, y, self, max_width=max_width, center=center, \
			color=color, html=html, bidi=bidi)

	def _text(self, text, x, y):

		"""
		A simple function that renders a string of text with the canvas default
		settings. This is the only function that needs to be re-implemented in
		other back-ends, as it is the only function that should handle actual
		text rendering.

		Arguments:
		text -- The text.
		x -- The x-coordinate.
		y -- The y-coordinate.
		"""

		font = self._font()
		surface = font.render(text, self.antialias, self.fgcolor)
		self.surface.blit(surface, (x, y))

	def textline(self, text, line, color=None):

		"""<DOC>
		A convenience function that draws a line of text based on a line number. #
		The text strings are centered on the X-axis and vertically spaced with #
		1.5 times the line height as determined by text_size().

		Arguments:
		text -- The text string.
		line -- A line number, where 0 is the center and > 0 is below the #
				center.

		Keyword arguments:
		color -- A human-readable custom foreground color. This does not affect #
				the default 	foreground color as set by set_fgcolor(). #
				(Default=None)

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> my_canvas.textline('A line', 0)
		>>> my_canvas.textline('Another line', 1)
		</DOC>"""

		font = self._font()
		size = self.text_size(text)
		self.text(text, True, self.xcenter(), self.ycenter()+1.5*line*size[1], \
			color=color)

	def image(self, fname, center=True, x=None, y=None, scale=None):

		"""<DOC>
		Draws an image from file. This function does not look in the file #
		pool, but takes an absolute path.

		Arguments:
		fname		--	The path of the file. If this is a Unicode string, it #
						is intepreted as utf-8 encoding.

		Keyword arguments:
		center		--	A Boolean indicating whether the given coordinates #
						reflect the center (True) or the top-left (False) of #
						the image default=True).
		x			--	The X coordinate. None = center. (Default=None)
		y			--	The Y coordinate. None = center. (Default=None)
		scale		--	The scaling factor of the image. 1.0 or None = #
						no scaling, 2.0 = twice as large, etc. (default=None).

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> # Determine the absolute path:
		>>> path = exp.get_file(u'image_in_pool.png')
		>>> my_canvas.image(path)
		</DOC>"""

		if isinstance(fname, unicode):
			fname = fname.encode(self.experiment.encoding)
		try:
			surface = pygame.image.load(fname)
		except pygame.error as e:
			raise osexception( \
				u"'%s' is not a supported image format" % fname)

		if scale != None:
			try:
				surface = pygame.transform.smoothscale(surface, \
					(int(surface.get_width()*scale), \
					int(surface.get_height()*scale)))
			except:
				debug.msg(u"smooth scaling failed for '%s'" % fname, reason=\
					u"warning")
				surface = pygame.transform.scale(surface, \
					(int(surface.get_width()*scale), \
					int(surface.get_height()*scale)))

		size = surface.get_size()
		if x == None:
			x = self.xcenter()
		if y == None:
			y = self.ycenter()
		if center:
			x -= size[0] / 2
			y -= size[1] / 2
		self.surface.blit(surface, (x, y))

	def gabor(self, x, y, orient, freq, env=u"gaussian", size=96, stdev=12, phase=0, col1=u"white", col2=u"black", bgmode=u"avg"):

		"""<DOC>
		Draws a Gabor patch. The exact rendering of the Gabor patch depends on the #
		back-end.

		Arguments:
		x -- The center X coordinate.
		y -- The center Y coordinate.
		orient -- Orientation in degrees [0 .. 360].
		freq -- Frequency in cycles/px of the sinusoid.

		Keyword arguments:
		env -- Any of the following: "gaussian", "linear", "circular", #
			   "rectangle" (default="gaussian").
		size -- Size in pixels (default=96).
		stdev -- Standard deviation in pixels of the gaussian. Only applicable #
				 if env = "gaussian". (Default=12)
		phase -- Phase of the sinusoid [0.0 .. 1.0] (default=0).
		col1 -- Human-readable color for the tops (default="white").
		col2 -- Human-readable color for the troughs. Note: This parameter is #
				ignored by the psycho backend. (Default="black").
		bgmode -- Specifies whether the background is the average of col1 and #
				  col2 (bgmode = "avg", a typical Gabor patch) or equal to col2 #
				  ("col2"), useful for blending into the background. Note: this #
				  parameter is ignored by the psycho backend. (Default="avg")

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> my_canvas.gabor(100, 100, 45, .05)
		</DOC>"""

		surface = _gabor(orient, freq, env, size, stdev, phase, col1, col2, \
			bgmode)
		self.surface.blit(surface, (x - 0.5 * size, y - 0.5 * size))

	def noise_patch(self, x, y, env=u"gaussian", size=96, stdev=12, col1=u"white", col2=u"black", bgmode=u"avg"):

		"""<DOC>
		Draws a patch of noise, with an envelope. The exact rendering of the noise #
		patch depends on the back-end.

		Arguments:
		x -- The center X coordinate.
		y -- The center Y coordinate.

		Keyword arguments:
		env -- Any of the following: "gaussian", "linear", "circular", #
			   "rectangle" (default="gaussian").
		size -- Size in pixels (default=96).
		stdev -- Standard deviation in pixels of the gaussian. Only applicable #
				 if env = "gaussian". (Default=12)
		phase -- Phase of the sinusoid [0.0 .. 1.0] (default=0).
		col1 -- Human-readable color for the tops (default="white").
		col2 -- Human-readable color for the troughs (default="black").
		bgmode -- Specifies whether the background is the average of col1 and #
				  col2 (bgmode="avg", a typical noise patch) or equal to col2 #
				  ("col2"), useful for blending into the background #
				  (default="avg").

		Example:
		>>> from openexp.canvas import canvas
		>>> my_canvas = canvas(exp)
		>>> my_canvas.noise_patch(100, 100, env='circular')
		</DOC>"""

		surface = _noise_patch(env, size, stdev, col1, col2, bgmode)
		self.surface.blit(surface, (x - 0.5 * size, y - 0.5 * size))

"""
Static methods
"""

def init_display(experiment):

	"""
	Initialize the display before the experiment begins.

	Arguments:
	experiment -- An instance of libopensesame.experiment.experiment. The
				  following properties are of particular importance:
				  experiment.fullscreen (bool), experiment.width (int) and
				  experiment.height (int). The experiment also contains default
				  font settings as experiment.font_family (str) and
				  experiment.font_size (int).
	"""

	# Intialize PyGame
	pygame.init()

	# Set the window icon
	surf = pygame.Surface( (32, 32) )
	surf.fill( (255, 255, 255) )
	pygame.draw.circle(surf, (0, 0, 255), (16, 16), 10, 4)
	pygame.display.set_icon(surf)

	# Determine the video mode
	mode = 0
	if experiment.get_check(u"pygame_hwsurface", u"yes", [u"yes", u"no"]) == \
		u"yes":
		mode = mode | pygame.HWSURFACE
		print( \
			u"openexp._canvas.legacy.init_display(): enabling hardware surface")
	else:
		print( \
			u"openexp._canvas.legacy.init_display(): not enabling hardware surface")

	if experiment.get_check(u"pygame_doublebuf", u"yes", [u"yes", u"no"]) == \
		u"yes":
		mode = mode | pygame.DOUBLEBUF
		print( \
			u"openexp._canvas.legacy.init_display(): enabling double buffering")
	else:
		print( \
			u"openexp._canvas.legacy.init_display(): not enabling double buffering")

	if pygame.display.mode_ok(experiment.resolution(), mode):
		print(u"openexp._canvas.legacy.init_display(): video mode ok")
	else:
		print( \
			u"openexp._canvas.legacy.init_display(): warning: video mode not ok")

	if experiment.fullscreen:
		mode = mode | pygame.FULLSCREEN

	if experiment.get_check(u'pygame_window_frame', u'yes', [u'yes', u'no']) \
		== u'no':
		mode = mode | pygame.NOFRAME

	if experiment.get_check(u'pygame_window_pos', u'auto') != u'auto':
		os.environ[u'SDL_VIDEO_WINDOW_POS'] = experiment.get( \
			u'pygame_window_pos')

	# Create the window and the surface
	experiment.window = pygame.display.set_mode(experiment.resolution(), mode)
	pygame.display.set_caption(u'OpenSesame (legacy backend)')
	pygame.mouse.set_visible(False)
	experiment.surface = pygame.display.get_surface()

	# Create a font, falling back to the default font
	experiment.font = pygame.font.Font(experiment.resource(u"%s.ttf" \
		% experiment.font_family), experiment.font_size)
	if experiment.font == None:
		debug.msg(u"'%s.ttf' not found, falling back to default font" \
			% experiment.font_family)
		experiment.font = pygame.font.Font(None, experiment.font_size)

	# Set the time functions to use pygame
	experiment._time_func = pygame.time.get_ticks
	experiment._sleep_func = pygame.time.delay
	experiment.time = experiment._time_func
	experiment.sleep = experiment._sleep_func

def close_display(experiment):

	"""
	Close the display after the experiment is finished.

	Arguments:
	experiment -- An instance of libopensesame.experiment.experiment
	"""

	pygame.display.quit()

"""
The functions below are specific to the legacy backend and do not have to be
implemented in other backends.
"""

canvas_cache = {}

def _color(color):

	"""
	See canvas.color()
	"""

	if isinstance(color, unicode):
		return pygame.Color(str(color))
	if isinstance(color, str):
		return pygame.Color(color)
	if isinstance(color, int):
		return pygame.Color(color, color, color, 255)
	if isinstance(color, float):
		i = int(255 * color)
		return pygame.Color(i, i, i, 255)
	if isinstance(color, tuple):
		if len(color) == 3:
			return pygame.Color(color[0], color[1], color[2], 255)
		if len(color) > 3:
			return pygame.Color(color[0], color[1], color[2], color[3])
		raise osexception(u'Unknown color: %s' % color)
	if isinstance(color, pygame.Color):
		return color
	raise osexception(u'Unknown color: %s' % color)

def _gabor(orient, freq, env=u"gaussian", size=96, stdev=12, phase=0, col1= \
	u"white", col2=u"black", bgmode=u"avg"):

	"""
	Returns a pygame surface containing a Gabor patch.
	See canvas.gabor()
	"""

	env = _match_env(env)
	# Generating a Gabor patch takes quite some time, so keep
	# a cache of previously generated Gabor patches to speed up
	# the process.
	global canvas_cache
	key = u"gabor_%s_%s_%s_%s_%s_%s_%s_%s_%s" % (orient, freq, env, size, \
		stdev, phase, col1, col2, bgmode)
	if key in canvas_cache:
		return canvas_cache[key]
	# Create a surface
	surface = pygame.Surface( (size, size) )
	px = pygame.PixelArray(surface)
	# Conver the orientation to radians
	orient = math.radians(orient)
	col1 = _color(col1)
	col2 = _color(col2)
	# rx and ry reflect the real coordinates in the
	# target image
	for rx in range(size):
		for ry in range(size):
			# Distance from the center
			dx = rx - 0.5 * size
			dy = ry - 0.5 * size
			# Get the coordinates (x, y) in the unrotated
			# Gabor patch
			t = math.atan2(dy, dx) + orient
			r = math.sqrt(dx ** 2 + dy ** 2)
			ux = r * math.cos(t)
			uy = r * math.sin(t)
			# Get the amplitude without the envelope (0 .. 1)
			amp = 0.5 + 0.5 * math.cos(2.0 * math.pi * (ux * freq + phase))
			# The envelope adjustment
			if env == "g":
				f = math.exp(-0.5 * (ux / stdev) ** 2 - 0.5 * (uy / stdev) ** 2)
			elif env == "l":
				f = max(0, (0.5 * size - r) / (0.5 * size))
			elif env == "c":
				if (r > 0.5 * size):
					f = 0.0
				else:
					f = 1.0
			else:
				f = 1.0
			# Apply the envelope
			if bgmode == u"avg":
				amp = amp * f + 0.5 * (1.0 - f)
			else:
				amp = amp * f
			r = col1.r * amp + col2.r * (1.0 - amp)
			g = col1.g * amp + col2.g * (1.0 - amp)
			b = col1.b * amp + col2.b * (1.0 - amp)
			px[rx][ry] = r, g, b
	canvas_cache[key] = surface
	del px
	return surface

def _noise_patch(env=u"gaussian", size=96, stdev=12, col1=u"white", col2= \
	u"black", bgmode=u"avg"):

	"""
	Returns a pygame surface containing a noise patch.
	See canvas.noise_patch()
	"""

	env = _match_env(env)
	# Generating a noise patch takes quite some time, so keep
	# a cache of previously generated noise patches to speed up
	# the process.
	global canvas_cache
	key = u"noise_%s_%s_%s_%s_%s_%s" % (env, size, stdev, col1, col2, bgmode)
	if key in canvas_cache:
		return canvas_cache[key]
	# Create a surface
	surface = pygame.Surface( (size, size) )
	px = pygame.PixelArray(surface)
	col1 = _color(col1)
	col2 = _color(col2)
	# rx and ry reflect the real coordinates in the
	# target image
	for rx in range(size):
		for ry in range(size):
			# Distance from the center
			ux = rx - 0.5 * size
			uy = ry - 0.5 * size
			r = math.sqrt(ux ** 2 + uy ** 2)
			# Get the amplitude without the envelope (0 .. 1)
			amp = random.random()
			# The envelope adjustment
			if env == u"g":
				f = math.exp(-0.5 * (ux / stdev) ** 2 - 0.5 * (uy / stdev) ** 2)
			elif env == u"l":
				f = max(0, (0.5 * size - r) / (0.5 * size))
			elif env == u"c":
				if (r > 0.5 * size):
					f = 0.0
				else:
					f = 1.0
			else:
				f = 1.0
			# Apply the envelope
			if bgmode == u"avg":
				amp = amp * f + 0.5 * (1.0 - f)
			else:
				amp = amp * f
			r = col1.r * amp + col2.r * (1.0 - amp)
			g = col1.g * amp + col2.g * (1.0 - amp)
			b = col1.b * amp + col2.b * (1.0 - amp)
			px[rx][ry] = r, g, b
	canvas_cache[key] = surface
	del px
	return surface

def _match_env(env):

	"""
	Allows for easy translation between various envelope names

	Arguments:
	env -- an envelope name

	Exception:
	Throws an osexception if an unknown envelope was specified

	Returns:
	A standard envelope name ("c", "g", "r" or "l")
	"""

	global env_synonyms
	if env not in env_synonyms:
		raise osexception(u"'%s' is not a valid envelope" % env)
	return env_synonyms[env]

########NEW FILE########
__FILENAME__ = libopengl
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

import pygame
from pygame.locals import *
from OpenGL.GL import *
try:
    from OpenGL.GLU import *
    GLU = 1
except:
    print("Warning: OpenGL.GLU did not import correctly.")
    GLU = None

lastclearcolor = None
lastclearimage = None
def clearScreen(color):
    """
    Set the whole window to RGB 3-tuple color.
    """
    global lastclearcolor
    global lastclearimage
    try:
        alpha = color[3]
    except IndexError:
        alpha = 255
    if alpha == 255:
        glClearColor(color[0] / 255.0, color[1] / 255.0, color[2] / 255.0, alpha / 255.0)
        glClear(GL_COLOR_BUFFER_BIT)
    else:
        if lastclearcolor != color:
            x, y = pygame.display.get_surface().get_size()
            lastclearimage = LowImage(x + 1, y + 1)
            lastclearimage.fill(color[0], color[1], color[2], alpha)
            lastclearcolor = color
        lastclearimage.show(0, 0)

gl_version = None
def getGLVersion():
    # !!! You must have an active GL context to call this method !!!
    global gl_version
    if gl_version is None:
        # Determine the version. This kind of an ugly hack to make sure
        # that versions like 1.1.1 can be represented as a float (i.e., strip
        # the final digit
        v = glGetString(GL_VERSION)
        v = ".".join(v.split()[0].split(".")[:2])
        gl_version = float(v)
    return gl_version

def doBlockingFlip():
    """
    Perform a flip and then write a pixel to the back buffer to pause
    the pipeline.  Inspired by PsychToolbox code.
    """

    # do the flip
    pygame.display.flip()

    # The following is taken from the PsychToolbox
    # Draw a single pixel in left-top area of back-buffer. This will wait/stall the rendering pipeline
    # until the buffer flip has happened, aka immediately after the VBL has started.
    # We need the pixel as "synchronization token", so the following glFinish() really
    # waits for VBL instead of just "falling through" due to the asynchronous nature of
    # OpenGL:
    glDrawBuffer(GL_BACK)
    # We draw our single pixel with an alpha-value of zero - so effectively it doesn't
    # change the color buffer - just the z-buffer if z-writes are enabled...
    glColor4f(0,0,0,0)
    glBegin(GL_POINTS)
    glVertex2i(10,10)
    glEnd()
    # This glFinish() will wait until point drawing is finished, ergo backbuffer was ready
    # for drawing, ergo buffer swap in sync with start of VBL has happened.
    glFinish()


class OGLSprite:
    """Implement the ugly details of "blitting" to OpenGL"""
    def __init__(self, surf, mipmap=None, interpolate=True):
        """OGLSprite(self, surf, mipmap=None) -> OGLSprite

        Create a drawable texture out of a given surface."""

        w, h = surf.get_width(), surf.get_height()
        if getGLVersion() >= 2.1:
            w2 = w
            h2 = h
            img = surf
        else:
            # must use power of 2
            w2, h2 = 1, 1
            while w2 < w: w2 <<= 1
            while h2 < h: h2 <<= 1
            img = pygame.Surface((w2, h2), SRCALPHA, 32)
            img.blit(surf, (0,0))

        rgba = pygame.image.tostring(img, "RGBA", 0)

        #assign a texture
        texid = glGenTextures(1)
        glBindTexture(GL_TEXTURE_2D, texid)

        if mipmap:
            if not GLU:
                raise NotImplementedError("OGLSprite mipmaps require OpenGL.GLU")
            #build MIPMAP levels. Ths is another slow bit
            gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA, w2, h2, GL_RGBA, GL_UNSIGNED_BYTE, rgba)
            glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
            glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
        else:
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w2, h2, 0, GL_RGBA, GL_UNSIGNED_BYTE, rgba)

        if interpolate:
            smoothing = GL_LINEAR
            glEnable(GL_LINE_SMOOTH)
            glEnable(GL_POLYGON_SMOOTH)
        else:
            smoothing = GL_NEAREST
            glDisable(GL_LINE_SMOOTH)
            glDisable(GL_POLYGON_SMOOTH)
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, smoothing)
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, smoothing)
        #glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
        #glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)

        self.mipmap = mipmap
        self.srcsize = w, h
        self.texsize = w2, h2
        self.coords = float(w)/w2, float(h)/h2
        self.texid = texid
    def __del__(self):
        """
        """
        try:
            glDeleteTextures([self.texid])
        except NameError:
            pyepl.exceptions.eplWarn("glDeleteTextures function not present.")
    def update(self, surf):
        """update(self, surf) -> None
        """
        if self.mipmap:
            raise TypeError("Cannot update a mipmap enabled OGLSprite")

        w, h = surf.get_width(), surf.get_height()
        if getGLVersion() >= 2.1:
            w2 = w
            h2 = h
            img = surf
        else:
            # must use power of 2
            w2, h2 = 1, 1
            while w2 < w: w2 <<= 1
            while h2 < h: h2 <<= 1
            img = pygame.Surface((w2, h2), SRCALPHA, 32)
            img.blit(surf, (0,0))

        rgba = pygame.image.tostring(img, "RGBA", 0)

        glBindTexture(GL_TEXTURE_2D, self.texid)
        if 'glTexSubImage2D' in dir() and w2 <= self.texsize[0] and h2 <= self.texsize[1]:

            # untested; i suspect it doesn't work
            w2, h2 = self.texsize
            glTexSubImage2D(GL_TEXTURE_RECTANGLE_EXT, 0,
                0, 0, w2, h2, GL_RGBA, GL_UNSIGNED_BYTE, rgba);
            if (w, h) != self.srcsize:
                self.coords = float(w)/w2, float(h)/h2
        else:
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
                w2, h2, 0, GL_RGBA, GL_UNSIGNED_BYTE, rgba)
            self.coords = float(w)/w2, float(h)/h2
            self.texsize = w2, h2

        self.srcsize = w, h

        #print "TEX", self.srcsize, self.texsize, self.coords
    def blit_at(self, *rects):
        """blit_at(self, *rects) -> self

        Draw the texture at the supplied position(s).  If a tuple and width and
        height are not specified, the original size is used (just like you'd
        expect).  Returns self so ogs.enter().blit().exit() works"""

        for rect in rects:
            x0, y0 = rect[0:2]
            try:
                x1, y1 = x0 + rect[2], y0 + rect[3]
            except IndexError:
                x1, y1 = x0 + self.srcsize[0] - 1, y0 + self.srcsize[1] - 1

            glBindTexture(GL_TEXTURE_2D, self.texid)
            glBegin(GL_TRIANGLE_STRIP)
            glTexCoord2f(0, 0); glVertex2f(x0, y0)
            glTexCoord2f(self.coords[0], 0); glVertex2f(x1, y0)
            glTexCoord2f(0, self.coords[1]); glVertex2f(x0, y1)
            glTexCoord2f(self.coords[0], self.coords[1]); glVertex2f(x1, y1)
            glEnd()

        return self
    def enter(self, xres, yres):
        """enter(self) -> self

        Set up OpenGL for drawing textures; do this once per batch of
        textures.  Returns self so ogs.enter().blit().exit() works"""

        glViewport(0, 0, xres, yres)
        glPushAttrib(GL_ENABLE_BIT)     # save old enables
        glDisable(GL_DEPTH_TEST)
        glDisable(GL_CULL_FACE)
        glColor4f(1,1,1,1)
        glEnable(GL_TEXTURE_2D)

        # XXX: in pre pygame1.5, there is no proper alpha, so this makes
        # the entire texture transparent.  in 1.5 and forward, it works.
        if pygame.version.ver >= '1.4.9':
            glEnable(GL_BLEND)
            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)

        #glEnable(GL_ALPHA_TEST)
        #glAlphaFunc(GL_GREATER, 0.5)

        glMatrixMode(GL_PROJECTION)
        glPushMatrix()
        glLoadIdentity()
        glOrtho(0.0, xres, yres, 0.0, 0.0, 1.0)

        glMatrixMode(GL_MODELVIEW)
        glPushMatrix()
        glLoadIdentity()

        #glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL)

        return self
    def exit(self):
        """exit(self) -> None

        Return OpenGL to previous settings; do this once per batch."""
        glMatrixMode(GL_PROJECTION)
        glPopMatrix()
        glMatrixMode(GL_MODELVIEW)
        glPopMatrix()
        glPopAttrib()
    def get_width(self):
        """get_width(self) -> int"""
        return self.srcsize[0]
    def get_height(self):
        """get_height(self) -> int"""
        return self.srcsize[1]

class LowImage:
    """
    Low level representation of an image.
    """
    def __init__(self, *args, **kwargs):
        """
        Create LowImage.
        """
        if len(args) == 2:
            self.surf = pygame.Surface(args)
        elif len(args) == 1:
            param = args[0]
            if isinstance(param, pygame.Surface):
                self.surf = param
            elif isinstance(param, str):
                self.surf = pygame.image.load(param)
            else:
                raise ValueError, "Invalid type for LowImage constructor argument."
        else:
            raise ValueError, "Invalid number of arguments for LowImage constructor."
        if kwargs.has_key('interpolate'):
            interpolate = kwargs['interpolate']
        else:
            interpolate = True
        self.gl_texture = OGLSprite(self.surf, interpolate=interpolate)
        self.gl_texture_dirty = False

	# this next line supposedly breaks on OSX, set to none if this is the case
        self.surfarray = pygame.surfarray.pixels3d(self.surf)
        # fix for the mac (breaks other stuff)
        #self.surfarray = None
    def dataString(self):
        """
        Return an RGBA string of the image data.
        """
        return pygame.image.tostring(self.surf, "RGBA")
    def cleanGLTexture(self):
        """
        """
        if self.gl_texture_dirty:
            self.gl_texture.update(self.surf)
            self.gl_texture_dirty = False
    def show(self, x, y):
        """
        """
        self.cleanGLTexture()
        self.gl_texture.enter(*pygame.display.get_surface().get_size())
        self.gl_texture.blit_at((x, y))
        self.gl_texture.exit()
    def fill(self, r, g, b, a):
        """
        """
        self.surf = self.surf.convert_alpha()
        self.surf.fill((int(r), int(g), int(b), int(a)))
        self.gl_texture_dirty = True
    def __getitem__(self, index):
        """
        Two dimensional indexing and slicing.
        """
        return pygame.surfarray.make_surface(self.surfarray[index])
    def __setitem__(self, index, value):
        """
        Index and slice assignment.
        """
        if isinstance(value, LowImage):
            self.surfarray[index] = value.surfarray
        else:
            self.surfarray[index] = value
        self.gl_texture_dirty = True
    def __mul__(self, x):
        """
        Color multiplication.
        """
        if isinstance(x, LowImage):
            return pygame.surfarray.make_surface(self.surfarray * x.surfarray)
        else:
            return pygame.surfarray.make_surface(self.surfarray * x)
    def __div__(self, x):
        """
        Color division.
        """
        if isinstance(x, LowImage):
            return pygame.surfarray.make_surface(self.surfarray / x.surfarray)
        else:
            return pygame.surfarray.make_surface(self.surfarray / x)
    def __add__(self, x):
        """
        Color addition.
        """
        if isinstance(x, LowImage):
            return pygame.surfarray.make_surface(self.surfarray + x.surfarray)
        else:
            return pygame.surfarray.make_surface(self.surfarray + x)
    def __sub__(self, x):
        """
        Color subtraction.
        """
        if isinstance(x, LowImage):
            return pygame.surfarray.make_surface(self.surfarray - x.surfarray)
        else:
            return pygame.surfarray.make_surface(self.surfarray - x)
    def __neg__(self):
        """
        Color inversion.
        """
        return pygame.surfarray.make_surface(-self.surfarray)
    def scale(self, x, y):
        """
        Get scaled image.
        """
        return LowImage(pygame.transform.scale(self.surf, (x, y)))
    def getSize(self):
        """
        Return an x, y tuple for image dimensions.
        """
        return self.surf.get_size()

########NEW FILE########
__FILENAME__ = opengl
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

import pygame
from pygame.locals import *
import random
import openexp._canvas.legacy
from libopensesame.exceptions import osexception
from libopensesame import debug, html
import math
import subprocess
import os
import os.path
import tempfile
import copy
import libopengl

class opengl(openexp._canvas.legacy.legacy):

	"""
	Implements an OpenGL canvas. See openexp._canvas.legacy for a full
	explanation of all parameters
	"""

	settings = None

	def __init__(self, experiment, bgcolor=None, fgcolor=None, auto_prepare=True):

		self.experiment = experiment
		self.html = html.html()
		if fgcolor == None:
			fgcolor = self.experiment.get("foreground")
		if bgcolor == None:
			bgcolor = self.experiment.get("background")

		self.fgcolor = self.color(fgcolor)
		self.bgcolor = self.color(bgcolor)
		self.penwidth = 1
		self.antialias = True
		self.font = self.experiment.font
		self.bidi = self.experiment.get(u'bidi')==u'yes'
		# set to have no objects
		self.showables = []
		self.clear()

	def color(self, color):

		"""see openexp._canvas.legacy"""

		return openexp._canvas.legacy._color(color)

	def flip(self, x = True, y = False):

		"""see openexp._canvas.legacy"""

		#self.surface = pygame.transform.flip(self.surface, x, y)
		# will have to flip each object and adjust it's location accordingly
		pass

	def copy(self, canvas):

		"""see openexp._canvas.legacy"""

		# PBS: do we need a deep copy here
		#self.showables = [s.copy() for s in canvas.showables]
		self.showables = copy.deepcopy(canvas.showables)

	def xcenter(self):

		"""see openexp._canvas.legacy"""

		return self.experiment.get('width') / 2

	def ycenter(self):

		"""see openexp._canvas.legacy"""

		return self.experiment.get('height') / 2

	def show(self):

		"""see openexp._canvas.legacy"""

		for s,loc in self.showables:
			s.show(loc[0],loc[1])
		libopengl.doBlockingFlip()
		return pygame.time.get_ticks()

	def clear(self, color = None):

		"""see openexp._canvas.legacy"""

		if color is None:
			color = self.bgcolor
		else:
			color = self.color(color)

		# clear the showable list
		self.showables = []
		surface = pygame.Surface(self.experiment.resolution())
		surface.fill(color)
		self.showables.append((libopengl.LowImage(surface), (0,0)))

	def set_penwidth(self, penwidth):

		"""see openexp._canvas.legacy"""

		self.penwidth = penwidth

	def set_fgcolor(self, color):

		"""see openexp._canvas.legacy"""

		self.fgcolor = self.color(color)

	def set_bgcolor(self, color):

		"""see openexp._canvas.legacy"""

		self.bgcolor = self.color(color)

	def set_font(self, style, size):

		"""see openexp._canvas.legacy"""

		self.font = pygame.font.Font(self.experiment.resource("%s.ttf" % style), size)

	def line(self, sx, sy, ex, ey, color = None):

		"""see openexp._canvas.legacy"""

		if color == None:
			color = self.fgcolor
		color = self.color(color)

		dy = abs(ey - sy) + 2*self.penwidth + 1
		dx = abs(ex - sx) + 2*self.penwidth + 1
		surface = pygame.Surface((dx,dy), SRCALPHA)

		if sx < ex:
			s_sx = self.penwidth
			s_ex = dx - self.penwidth - 1
		else:
			s_sx = dx - self.penwidth - 1
			s_ex = self.penwidth
		if sy < ey:
			s_sy = self.penwidth
			s_ey = dy - self.penwidth - 1
		else:
			s_sy = dy - self.penwidth - 1
			s_ey = self.penwidth

		pygame.draw.line(surface, color,
				 (s_sx, s_sy), (s_ex, s_ey),
				 self.penwidth)

		self.showables.append((libopengl.LowImage(surface,interpolate=False),
			(min(sx,ex)-self.penwidth,
			min(sy,ey)-self.penwidth)))

	def arrow(self, sx, sy, ex, ey, arrow_size = 5, color = None):

		"""see openexp._canvas.legacy"""

		if color == None:
			color = self.fgcolor
		color = self.color(color)

		dy = abs(ey - sy) + 2*arrow_size
		dx = abs(ex - sx) + 2*arrow_size
		surface = pygame.Surface((dx,dy), SRCALPHA)

		if sx < ex:
			s_sx = arrow_size
			s_ex = dx - arrow_size
		else:
			s_sx = dx - arrow_size
			s_ex = arrow_size
		if sy < ey:
			s_sy = arrow_size
			s_ey = dy - arrow_size
		else:
			s_sy = dy - arrow_size
			s_ey = arrow_size

		pygame.draw.line(surface, color,
				 (s_sx, s_sy), (s_ex, s_ey),
				 self.penwidth)

		a = math.atan2(s_ey - s_sy, s_ex - s_sx)

		_sx = s_ex + arrow_size * math.cos(a + math.radians(135))
		_sy = s_ey + arrow_size * math.sin(a + math.radians(135))
		pygame.draw.line(surface, color,
				 (_sx, _sy), (s_ex, s_ey), self.penwidth)

		_sx = s_ex + arrow_size * math.cos(a + math.radians(225))
		_sy = s_ey + arrow_size * math.sin(a + math.radians(225))
		pygame.draw.line(surface, color,
				 (_sx, _sy), (s_ex, s_ey), self.penwidth)

		self.showables.append((libopengl.LowImage(surface),
				       (min(sx,ex)+arrow_size,
					min(sy,ey)+arrow_size)))

	def rect(self, x, y, w, h, fill = False, color = None):

		"""see openexp._canvas.legacy"""

		if color == None:
			color = self.fgcolor
		color = self.color(color)

		if fill:
			surface = pygame.Surface((w,h), SRCALPHA)
			pygame.draw.rect(surface, color, (0, 0, w, h), 0)
			loc = (x,y)
		else:
			surface = pygame.Surface((w+2*self.penwidth,h+2*self.penwidth),
						 SRCALPHA)
			pygame.draw.rect(surface, color,
					 (self.penwidth, self.penwidth, w, h), self.penwidth)
			loc = (x-self.penwidth,y-self.penwidth)

		self.showables.append((libopengl.LowImage(surface),
				       loc))

	def ellipse(self, x, y, w, h, fill = False, color = None):

		"""see openexp._canvas.legacy"""

		if color == None:
			color = self.fgcolor
		color = self.color(color)

		x = int(x)
		y = int(y)
		w = int(w)
		h = int(h)

		if fill:
			surface = pygame.Surface((w,h), SRCALPHA)
			pygame.draw.ellipse(surface, color, (0, 0, w, h), 0)
			loc = (x,y)
		else:
			# Because the default way of drawing thick lines gives ugly results
			# for ellipses, we draw thick circles manually
			i = self.penwidth / 2.
			j = self.penwidth - i

			fgrect = (self.penwidth-i, self.penwidth-i,
				  self.penwidth+w+2*i, self.penwidth+h+2*i)
			bgrect = (self.penwidth+j, self.penwidth+j,
				  self.penwidth+w-2*j, self.penwidth+h-2*j)
			loc = (x-self.penwidth-i,y-self.penwidth-j)
			surface = pygame.Surface((w+2*self.penwidth+2,
						  h+2*self.penwidth+2),
						 SRCALPHA)
			pygame.draw.ellipse(surface, color,
					    fgrect, 0)
			pygame.draw.ellipse(surface, self.bgcolor,
					    bgrect, 0)

		self.showables.append((libopengl.LowImage(surface),
				       loc))

	def polygon(self, vertices, fill=False, color=None):

		"""see openexp._canvas.legacy"""

		# TODO
		raise osexception( \
			"openexp._canvas.opengl.polygon() not implemented")

	def text_size(self, text):

		"""see openexp._canvas.legacy"""

		return self.font.size(text)

	def text(self, text, center = True, x = None, y = None, color = None):

		"""see openexp._canvas.legacy"""

		if color == None:
			color = self.fgcolor
		color = self.color(color)

		surface = self.font.render(text, self.antialias, color)
		size = self.font.size(text)

		if x == None:
			x = self.xcenter()

		if y == None:
			y = self.ycenter()

		if center:
			x -= size[0] / 2
			y -= size[1] / 2

		self.showables.append((libopengl.LowImage(surface), (x,y)))

	def textline(self, text, line, color = None):

		"""see openexp._canvas.legacy"""

		size = self.font.size(text)
		self.text(text, True, self.xcenter(), self.ycenter() + 1.5 * line * size[1], color=color)

	def image(self, fname, center = True, x = None, y = None, scale = None):

		"""see openexp._canvas.legacy"""

		try:
			surface = pygame.image.load(fname)
		except pygame.error as e:
			raise osexception("'%s' is not a supported image format" % fname)

		if scale != None:
			surface = pygame.transform.smoothscale(surface, (int(surface.get_width() * scale), int(surface.get_height() * scale)))

		size = surface.get_size()

		if x == None:
			x = self.xcenter()

		if y == None:
			y = self.ycenter()

		if center:
			x -= size[0] / 2
			y -= size[1] / 2

		self.showables.append((libopengl.LowImage(surface),
				       (x,y)))

	def gabor(self, x, y, orient, freq, env = "gaussian", size = 96, stdev = 12, phase = 0, col1 = "white", col2 = "black", bgmode = "avg"):

		"""
		Draws a Gabor patch. This function is derived from the online Gabor patch generator
		<http://www.cogsci.nl/software/online-gabor-patch-generator>

		orient: orientation in degrees [0 .. 360]
		freq: frequency in cycles/px
		env: envelope (gaussian/ linear/ circular/ rectangle)
		size: size in px
		stdev: standard deviation of the gaussian (only applicable if env == gaussian)
		phase: phase [0 .. 1]
		col1: color of tops
		col2: color of troughs
		bgmode: color of the background (avg/ col2)
		"""

		surface = openexp._canvas.legacy._gabor(orient, freq, env, size, stdev, phase, col1, col2, bgmode)
		self.showables.append((libopengl.LowImage(surface),
				       (x - 0.5 * size, y - 0.5 * size)))

	def noise_patch(self, x, y, env = "gaussian", size = 96, stdev = 12, col1 = "white", col2 = "black", bgmode = "avg"):

		"""
		Draws a patch of noise, with an envelope applied over it.
		"""

		surface = openexp._canvas.legacy._noise_patch(env, size, stdev, col1, col2, bgmode)
		self.showables.append((libopengl.LowImage(surface),
				       (x - 0.5 * size, y - 0.5 * size)))

"""
Static methods
"""

canvas_cache = {}

def init_display(experiment):

	"""
	Initializes the display
	"""

	# Intialize PyGame
	pygame.init()

	# Set the window icon
	surf = pygame.Surface( (32, 32) )
	surf.fill( (255, 255, 255) )
	pygame.draw.circle(surf, (0, 0, 255), (16, 16), 10, 4)
	pygame.display.set_icon(surf)

	# Determine the video mode
	mode = pygame.HWSURFACE | pygame.DOUBLEBUF | pygame.OPENGL
	if experiment.fullscreen:
		mode = mode | pygame.FULLSCREEN
	if pygame.display.mode_ok(experiment.resolution(), mode):
		print("video.opengl.init_display(): video mode ok")
	else:
		print("video.opengl.init_display(): warning: video mode not ok")

	# Set the sync to VBL

	# PBS: Currently only for linux, must add in for OSX, but that
	# takes Objective C code.

	# Set for nVidia linux
	val = "1"
	os.environ["__GL_SYNC_TO_VBLANK"] = val
	# Set for recent linux Mesa DRI Radeon
	os.environ["LIBGL_SYNC_REFRESH"] = val

	# Create the window and the surface
	experiment.window = pygame.display.set_mode(experiment.resolution(), mode)
	pygame.display.set_caption(experiment.title)
	pygame.mouse.set_visible(False)
	experiment.surface = pygame.display.get_surface()

	# Set the time function to use pygame
	experiment._time_func = pygame.time.get_ticks
	experiment._sleep_func = pygame.time.delay
	experiment.time = experiment._time_func
	experiment.sleep = experiment._sleep_func

	# Create a font, falling back to the default font
	experiment.font = pygame.font.Font(experiment.resource("%s.ttf" % experiment.font_family), experiment.font_size)
	if experiment.font == None:
		experiment.font = pygame.font.Font(None, experiment.font_size)

def close_display(experiment):

	"""
	Close the display
	"""

	pygame.display.quit()


########NEW FILE########
__FILENAME__ = psycho
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

import pygame
import pyglet
import math
import openexp._canvas.legacy
from libopensesame.exceptions import osexception
from libopensesame import debug, html
try: # Try both import statements
	from PIL import Image
except:
	import Image
import numpy as np
import os.path

try:
	from psychopy import core, visual, logging
except:
	raise osexception(
		u'Failed to import PsychoPy, probably because it is not (correctly) installed. For installation instructions, please visit http://www.psychopy.org/.')
if not hasattr(visual, u'ImageStim'):
	raise osexception( \
		u'PsychoPy is missing the ImageStim() class. Please update your version of PsychoPy! For installation instructions, please visit http://www.psychopy.org/.')
if not hasattr(visual, u'GratingStim'):
	raise osexception( \
		u'PsychoPy is missing the GratingStim() class. Please update your version of PsychoPy! For installation instructions, please visit http://www.psychopy.org/.')

class psycho(openexp._canvas.legacy.legacy):

	"""This is a canvas backend built on top of PsychoPy (with Pyglet)"""

	# The settings variable is used by the GUI to provide a list of back-end
	# settings
	settings = {
		u'psychopy_waitblanking' : {
			u'name' : u'Wait for blanking',
			u'description' : u'Block until the display has been shown',
			u'default' : u'yes'
			},
		u'psychopy_monitor' : {
			u'name' : u'Monitor',
			u'description' : u'Virtual monitor',
			u'default' : u'testMonitor'
			},
		u"psychopy_screen" : {
			u"name" : u"Screen",
			u"description" : u"The physical screen that is used",
			u"default" : 0,
			},
		u"psychopy_gamma" : {
			u"name" : u"Gamma",
			u"description" : u"Display gamma value display",
			u"default" : u"unchanged",
			},
		u'psychopy_suppress_warnings' : {
			u'name' : u'Suppress warnings',
			u'description' : u'Set PsychoPy logging level to "critical"',
			u'default' : u'yes',
			}
		}

	def __init__(self, experiment, bgcolor=None, fgcolor=None, auto_prepare= \
		True):

		"""See openexp._canvas.legacy"""

		self.experiment = experiment
		self.html = html.html()
		self.min_penwidth = 1
		if fgcolor == None:
			fgcolor = self.experiment.get(u"foreground")
		if bgcolor == None:
			bgcolor = self.experiment.get(u"background")
		self.set_fgcolor(fgcolor)
		self.set_bgcolor(bgcolor)
		self.set_penwidth(1)
		self.bidi = self.experiment.get(u'bidi')==u'yes'
		self.set_font(style=self.experiment.font_family, size= \
			self.experiment.font_size, bold=self.experiment.font_bold==u'yes', \
			italic=self.experiment.font_italic==u'yes', underline= \
			self.experiment.font_underline==u'yes')
		# We need to map the simple font names used by OpenSesame onto the
		# actual names of the fonts.
		self.font_map = {
			u"sans" : u"Droid Sans",
			u"serif" : u"Droid Serif",
			u"mono" : u"Droid Sans Mono",
			u'hebrew' : u'Alef',
			u'hindi' : u'Lohit Hindi',
			u'arabic' : u'Droid Arabic Naskh',
			u'chinese-japanese-korean' : u'WenQuanYi Micro Hei',
			}
		self.clear()

	def color(self, color):

		"""See openexp._canvas.legacy"""

		if type(color) in (tuple, list):
			# PsycoPy want tuples to be between 0 and 1, so we normalize the
			# tuple if the format is incorrect (i.e. 0-255).
			r = color[0]
			g = color[1]
			b = color[2]
			if r>1 or g>1 or b>1:
				r = 1.*r/255
				g = 1.*g/255
				b = 1.*b/255
				color = r,g,b
		return color

	def flip(self, x=True, y=False):

		"""See openexp._canvas.legacy"""

		# TODO
		raise osexception( \
			u"openexp._canvas.psycho.flip(): the flip() function has not been implemented for the psycho back-end!")

	def copy(self, canvas):

		"""See openexp._canvas.legacy"""

		self.stim_list = canvas.stim_list + []
		self.bgcolor = canvas.bgcolor
		self.fgcolor = canvas.fgcolor
		self.penwidth = canvas.penwidth

	def show(self):

		"""See openexp._canvas.legacy"""

		for stim in self.stim_list:
			stim.draw()
		self.experiment.window.flip(clearBuffer = True)
		return 1000.0 * self.experiment.clock.getTime()

	def clear(self, color=None):

		"""See openexp._canvas.legacy"""

		self.stim_list = []
		if color != None:
			color = self.color(color)
		else:
			color = self.bgcolor
		if self.experiment.background != color:
			# The background is simply a rectangle, because of the double flip
			# required by set_color()
			self.rect(0, 0, self.experiment.width, self.experiment.height, \
				color=color, fill=True)

	def circle(self, x, y, r, fill=False, color=None):

		"""See openexp._canvas.legacy"""

		self.ellipse(x-r, y-r, 2*r, 2*r, fill = fill, color = color)

	def line(self, sx, sy, ex, ey, color=None):

		"""See openexp._canvas.legacy"""


		if color == None:
			color = self.fgcolor
		self.shapestim( [[sx, sy], [ex, ey]], color = color)

	def rect(self, x, y, w, h, fill=False, color=None):

		"""See openexp._canvas.legacy"""

		if color == None:
			color = self.fgcolor
		else:
			color = self.color(color)

		if not fill:
			self.shapestim( [[x, y], [x+w, y], [x+w, y+h], [x, y+h]], color, \
				close=True)
		else:
			pos = x + w/2 - self.xcenter(), self.ycenter() - y - h/2
			stim = visual.GratingStim(win=self.experiment.window, pos=pos, \
				size=[w, h], color=color, tex=None, interpolate=False)
			self.stim_list.append(stim)

	def ellipse(self, x, y, w, h, fill=False, color=None):

		"""See openexp._canvas.legacy"""

		if color != None:
			color = self.color(color)
		else:
			color = self.fgcolor

		pos = x - self.xcenter() + w/2, self.ycenter() - y - h/2

		stim = visual.GratingStim(win=self.experiment.window, mask=u'circle', \
			pos=pos, size=[w, h], color=color, tex=None, interpolate=True)
		self.stim_list.append(stim)

		if not fill:
			stim = visual.GratingStim(win = self.experiment.window, \
				mask=u'circle', pos=pos, size=[w-2*self.penwidth, \
				h-2*self.penwidth], color=self.bgcolor, tex=None, \
				interpolate=True)
			self.stim_list.append(stim)

	def polygon(self, vertices, fill=False, color=None):

		"""See openexp._canvas.legacy"""

		self.shapestim(vertices, fill=fill, color=color, fix_coor=True, \
			close=True)

	def set_font(self, style=None, size=None, italic=None, bold=None, \
		underline=None):

		"""See openexp._canvas.legacy"""

		if style != None:
			# If a font is taken from the file pool, it is not registered with
			# PyGlet, and we therefore need to register it now.
			if self.experiment.file_in_pool(u'%s.ttf' % style):
				font_path = self.experiment.get_file(u'%s.ttf' % style)
				register_font(font_path)
		openexp._canvas.legacy.legacy.set_font(self, style=style, size=size, \
			italic=italic, bold=bold, underline=underline)

	def text_size(self, text):

		"""See openexp._canvas.legacy"""

		self._text(text, 0, 0)
		s = self.stim_list.pop()
		t = pyglet.font.Text(s._font, text)
		return t.width, t.height

	def _text(self, text, x, y):

		"""See openexp._canvas.legacy"""

		if self.font_style in self.font_map:
			font = self.font_map[self.font_style]
		else:
			font = self.font_style
		pos = x - self.xcenter(), self.ycenter() - y
		stim = visual.TextStim(win=self.experiment.window, text=text, \
			alignHoriz=u'left', alignVert=u'top', pos=pos, color=self.fgcolor, \
			font=font, height= self.font_size, wrapWidth= \
			self.experiment.width, bold=self.font_bold, italic=self.font_italic)
		self.stim_list.append(stim)

	def textline(self, text, line, color=None):

		"""See openexp._canvas.legacy"""

		self.text(text, True, self.xcenter(), self.ycenter() + 1.5 * line * \
			self.font_size, color = color)

	def image(self, fname, center=True, x=None, y=None, scale=None):

		"""See openexp._canvas.legacy"""

		im = Image.open(fname)

		if scale != None:
			w = im.size[0] * scale
			h = im.size[1] * scale
		else:
			w, h = im.size

		# Calculate the position
		if x == None:
			x = self.xcenter()
		if y == None:
			y = self.ycenter()
		if not center:
			x += w/2
			y += h/2
		pos = x - self.xcenter(), self.ycenter() - y

		stim = visual.ImageStim(win=self.experiment.window, image=fname, \
			pos=pos, size=(w,h))
		self.stim_list.append(stim)

	def gabor(self, x, y, orient, freq, env=u"gaussian", size=96, stdev=12, \
		phase=0, col1=u"white", col2=None, bgmode=None):

		"""See openexp._canvas.legacy"""

		pos = x - self.xcenter(), self.ycenter() - y
		_env, _size, s = self.env_to_mask(env, size, stdev)
		p = visual.GratingStim(win=self.experiment.window, pos=pos, ori=-orient,
			mask=_env, size=_size, sf=freq, phase=phase, color=col1)
		self.stim_list.append(p)

	def noise_patch(self, x, y, env=u"gaussian", size=96, stdev=12, \
		col1=u"white", col2=u"black", bgmode=u"avg"):

		"""See openexp._canvas.legacy"""

		pos = x - self.xcenter(), self.ycenter() - y
		_env, _size, s = self.env_to_mask(env, size, stdev)
		tex = 2*(np.random.random([s,s])-0.5)
		p = visual.GratingStim(win=self.experiment.window, tex=tex, pos=pos,
			mask=_env, size=_size, color=col1)
		self.stim_list.append(p)

	def env_to_mask(self, env, size, stdev):

		"""
		* Note: Specific to the PsychoPy backend, primarily intended for
				internal use. Using this function directly will break your
				experiment when switching backends.

		Converts an envelope name to a PsychoPy mask. Also returns the
		appropriate patch size and the smallest power-of-two size

		Arguments:
		env -- an envelope name
		size -- a size value

		Returns:
		A (psychopy_mask, mask_size, power_of_two_size) tuple
		"""

		env = openexp._canvas.legacy._match_env(env)

		# Get the smallest power-of-two size
		i = 2
		while size / (i) > 0:
			i = 2*i
		s = i

		# Create a PsychoPy mask
		if env == u"c":
			_env = u"circle"
			_size = size
		elif env == u"g":
			_env = u"gauss"
			_size = 6*stdev
		elif env == u"r":
			_env = u"None"
			_size = size
		elif env == u"l":
			_env = np.zeros([s,s])
			for x in range(s):
				for y in range(s):
					r = np.sqrt((x-s/2)**2+(y-s/2)**2)
					_env[x,y] = (max(0, (0.5*s-r) / (0.5*s))-0.5)*2
			_size = size
		return	(_env, _size, s)

	def shapestim(self, vertices, color=None, fill=False, fix_coor=True, \
		close=False):

		"""
		* Note: Specific to the PsychoPy backend, primarily intended for
				internal use. Using this function directly will break your
				experiment when switching backends.

		Draws a stimulus definied by a list of vertices

		Arguments:
		vertices -- A list of lists, like [[0,0],[10,10]] containing the
					vertices of the shape

		Keyword arguments:
		color -- the color of the shape
		fill -- a boolean indicating wether the shape should be filles
		fix_coor -- a boolean indicating whether the vertices are in OpenSesame
					or PsychoPy format
		"""

		if fix_coor:
			# Convert the coordinates into the PsychoPy format, in which 0,0 is
			# the center of the screen and negative y-coordinates are down.
			_vertices = []
			for x, y in vertices:
				_vertices.append( [x - self.xcenter(), self.ycenter() - y] )
		else:
			_vertices = vertices

		if color == None:
			color = self.fgcolor
		if fill:
			fill = color
		else:
			fill = None

		stim = visual.ShapeStim(self.experiment.window, units="pix", \
			lineWidth=self.penwidth, vertices=_vertices, lineColor=color, \
			closeShape=close, fillColor=fill, interpolate=False)
		self.stim_list.append(stim)

"""
Static methods
"""

# Store the experiment as a singleton, to be used in the _time() function
_experiment = None
# Store the old display gamma value
_old_gamma = None
# Contains a list of fonts that have been explicitly registered with PyGlet
_registered_fonts = []

def init_display(experiment):

	"""See openexp._canvas.legacy"""

	global _experiment, _old_gamma
	_experiment = experiment
	# Set the PsychoPy monitor, default to testMonitor
	monitor = experiment.get_check(u'psychopy_monitor', u'testMonitor')
	waitblanking = experiment.get_check(u'psychopy_waitblanking', u'yes', \
		[u'yes', u'no']) == u'yes'
	screen = experiment.get_check(u'psychopy_screen', 0)
	# Print some information to the debug window
	print(u'openexp._canvas.psycho.init_display(): waitblanking = %s' % \
		waitblanking)
	print(u'openexp._canvas.psycho.init_display(): monitor = %s' % monitor)
	print(u'openexp._canvas.psycho.init_display(): screen = %s' % screen)
	# Initialize the PsychoPy window and set various functions
	experiment.window = visual.Window( experiment.resolution(), screen=screen, \
		waitBlanking=waitblanking, fullscr=experiment.fullscreen, \
		monitor=monitor, units=u'pix', rgb=experiment.background)
	experiment.window.setMouseVisible(False)
	experiment.clock = core.Clock()
	experiment._time_func = _time
	experiment._sleep_func = _sleep
	experiment.time = experiment._time_func
	experiment.sleep = experiment._sleep_func
	experiment.window.winHandle.set_caption(u'OpenSesame (PsychoPy backend)')
	# Set Gamma value if specified
	gamma = experiment.get_check(u'psychopy_gamma', u'unchanged')
	if type(gamma) in (int, float) and gamma > 0:
		_old_gamma = experiment.window.gamma
		experiment.window.setGamma(gamma)
	elif gamma != u'unchanged':
		raise osexception( \
			u'Gamma should be a positive numeric value or "unchanged"')
	# Register the built-in OpenSesame fonts.
	for font in [u'sans', u'serif', u'mono', u'arabic', u'hebrew', u'hindi', \
		u'chinese-japanese-korean']:
		font_path = experiment.resource(u'%s.ttf' % font)
		register_font(font_path)
	# Override the default quit function, so that the application is not exited
	core.quit = _psychopy_clean_quit
	# Optionally change the logging level to avoid a lot of warnings in the
	# debug window
	if experiment.get_check(u'psychopy_suppress_warnings', u'yes'):
		logging.console.setLevel(logging.CRITICAL)
	# We need to initialize the pygame mixer, because PsychoPy uses that as well
	pygame.mixer.init()

def close_display(experiment):

	"""See openexp._canvas.legacy"""

	global _old_gamma
	# Restore display gamma if necessary
	if _old_gamma != None:
		experiment.window.setGamma(_old_gamma)
	# This causes a (harmless) exception in some cases, so we catch it to
	# prevent confusion
	try:
		experiment.window.close()
	except:
		debug.msg(u'An error occurred while closing the PsychoPy window.', \
			reason=u'warning')

def register_font(font_path):

	"""
	Register a font with PyGlet. If the font has already been registered, this
	function does nothing.

	Arguments:
	font_path	--	The full path to the font file.
	"""

	global _registered_fonts
	if font_path in _registered_fonts:
		return
	debug.msg(u'registering %s' % font_path)
	pyglet.font.add_file(font_path)
	_registered_fonts.append(font_path)

def _time():

	"""See openexp._canvas.legacy"""

	global _experiment
	return 1000.0*_experiment.clock.getTime()

def _sleep(ms):

	"""See openexp._canvas.legacy"""

	core.wait(.001*ms)

def _psychopy_clean_quit():

	"""
	When PsychoPy encounters an error, it does a sys.exit() which is not what
	we want, because it closes OpenSesame altogether. Instead, we nicely inform

	the user that PsychoPy has signalled an error.
	"""

	raise osexception( \
		u'PsychoPy encountered an error and aborted the program. See the debug window for PsychoPy error messages.')

########NEW FILE########
__FILENAME__ = xpyriment
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

import numpy as np
import copy
import openexp._canvas.legacy
from libopensesame.exceptions import osexception
from libopensesame import debug, html
import pygame
try:
	from expyriment import control, stimuli, misc, io
	from expyriment.misc.geometry import coordinates2position, \
		points_to_vertices as p2v
except:
	raise osexception(
		u'Failed to import expyriment, probably because it is not (correctly) installed. For installation instructions, please visit http://www.expyriment.org/.')

def c2p(pos):

	"""
	Converts coordinates (where 0,0 is the display center) to position (where
	0,0 is the top-left). This function is used instead of coordinates2position,
	because we want the virtual screen to be centered in fullscreen mode.

	Arguments:
	pos -- an (x,y) tuple

	Returns:
	An (x,y) tuple
	"""

	return pos[0] - control.defaults.window_size[0]/2, \
		control.defaults.window_size[1]/2 - pos[1]

class xpyriment(openexp._canvas.legacy.legacy):

	"""This is a canvas backend built on top of Expyriment"""

	settings = {
		u"expyriment_opengl" : {
			u"name" : u"Use OpenGL",
			u"description" : u"Use OpenGL mode for better temporal precision",
			u"default" : u"yes"
			},
		}

	def __init__(self, experiment, bgcolor=None, fgcolor=None, auto_prepare=True):

		"""See openexp._canvas.legacy"""

		self.experiment = experiment
		self.html = html.html()
		self.auto_prepare = auto_prepare
		self.prepared = False
		if fgcolor == None:
			fgcolor = self.experiment.get(u'foreground')
		if bgcolor == None:
			bgcolor = self.experiment.get(u'background')
		self.set_fgcolor(fgcolor)
		self.set_bgcolor(bgcolor)
		self.bidi = self.experiment.get(u'bidi')==u'yes'
		self.set_font(style=self.experiment.font_family, size= \
			self.experiment.font_size, bold=self.experiment.font_bold==u'yes', \
			italic=self.experiment.font_italic==u'yes', underline= \
			self.experiment.font_underline==u'yes')
		self.penwidth = 1
		self.aa = 10
		self.clear()

	def flip(self, x=True, y=False):

		"""See openexp._canvas.legacy"""

		# TODO
		raise osexception( \
			u"openexp._canvas.xpyriment.flip(): the flip() function has not been implemented for the xpyriment back-end!")

	def copy(self, canvas):

		"""See openexp._canvas.legacy"""

		self.fgcolor = canvas.fgcolor
		self.bgcolor = canvas.bgcolor
		self.font_style = canvas.font_style
		self.font_size = canvas.font_size
		self.font_italic = canvas.font_italic
		self.font_bold = canvas.font_bold
		self.font_underline = canvas.font_underline
		self.penwidth = canvas.penwidth
		self.auto_prepare = canvas.auto_prepare
		self.aa = canvas.aa
		self.prepared = False
		self.clear()
		self.stim_list = [stim.copy() for stim in canvas.stim_list]
		if self.auto_prepare:
			self.prepare()
		canvas.prepared = False

	def add_stim(self, stim, prepare=True):

		"""
		Adds a stimulus to the stimulus list

		Arguments:
		stim -- the stimulus

		Keyword arguments:
		prepare -- indicates whether we should prepare (default=True)
		"""

		self.stim_list.append(stim)
		self.prepared = False
		if prepare and self.auto_prepare:
			self.prepare()

	def prepare(self):

		"""See openexp._canvas.legacy"""

		if not self.prepared:
			self._canvas = stimuli.Canvas( \
				self.experiment.expyriment.screen.size, colour= \
				self._canvas_color)
			for stim in self.stim_list:
				stim.plot(self._canvas)
			self._canvas.preload()
			self.prepared = True
		return self.experiment.time()

	def show(self):

		"""See openexp._canvas.legacy"""

		if not self.prepared: self.prepare()
		self._canvas.present()
		self.experiment.last_shown_canvas = self._canvas
		return self.experiment.time()

	def clear(self, color=None):

		"""See openexp._canvas.legacy"""

		if color != None: self._canvas_color = self.color(color)
		else: self._canvas_color = self.bgcolor
		self.stim_list = []
		self.prepare()

	def line(self, sx, sy, ex, ey, color=None):

		"""See openexp._canvas.legacy"""

		if color != None: color = self.color(color)
		else: color = self.fgcolor
		stim = stimuli.Line(c2p((sx,sy)), c2p((ex,ey)), line_width= \
			self.penwidth, colour=color, anti_aliasing=self.aa)
		self.add_stim(stim)

	def rect(self, x, y, w, h, fill=False, color=None):

		"""See openexp._canvas.legacy"""

		if fill:
			if color != None: color = self.color(color)
			else: color = self.fgcolor
			# The position of the stimulus is the center, not the top-left
			pos = c2p((x+w/2,y+h/2))
			#stim = stimuli.Rectangle(size=(w,h), position=pos, colour= \
			#	color, anti_aliasing=self.aa)
			# Anti-aliasing gone as of 0.6.1
			stim = stimuli.Rectangle(size=(w,h), position=pos, colour= \
				color)
			self.add_stim(stim)

		# Unfilled shapes are drawn using a polygon
		else:
			# For now, do not use a polygon, because it's really slow when
			# rendering, which is particularly problematic for forms.
			# self.polygon( [(x,y), (x+w,y), (x+w,y+w), (x,y+w), (x,y)], \
			# color=color)
			self.line(x, y, x+w, y, color=color)
			self.line(x+w, y, x+w, y+h, color=color)
			self.line(x, y+h, x+w, y+h, color=color)
			self.line(x, y, x, y+h, color=color)

	def ellipse(self, x, y, w, h, fill=False, color=None):

		"""See openexp._canvas.legacy"""

		if color != None: color = self.color(color)
		else: color = self.fgcolor
		if fill: line_width = 0
		else: line_width = self.penwidth
		pos = c2p((x+w/2,y+h/2))
		stim = stimuli.Ellipse((w, h), colour=color, line_width=line_width, \
			position=pos)
		self.add_stim(stim)

	def polygon(self, vertices, fill=False, color=None):

		"""See openexp._canvas.legacy"""

		if color != None: color = self.color(color)
		else: color = self.fgcolor
		if fill: line_width = 0
		else: line_width = self.penwidth
		# The coordinate transformations are a bit awkard. Shape expects
		# a list of vertices that start form (0,0), but the position of the
		# shape is the center of the shape. So we first need to determine
		# the center of the polygon=(min+max)/2 and then convert the list
		# of vertices to a format that's acceptable to Shape
		center = (min(p[0] for p in vertices) + \
			max(p[0] for p in vertices)) / 2, \
			(min(p[1] for p in vertices) + \
			max(p[1] for p in vertices)) / 2
		stim = stimuli.Shape(colour=color, position=c2p(center), \
			anti_aliasing=self.aa, line_width=line_width)
		l = p2v([c2p(p) for p in vertices])
		for v in l: stim.add_vertex(v)
		self.add_stim(stim)

	def set_bgcolor(self, color):

		"""See openexp._canvas.set_bgcolor"""

		self.bgcolor = self.color(color)
		self._canvas_color = self.bgcolor

	def text_size(self, text):

		"""See openexp._canvas.legacy"""

		try:
			_font = self.experiment.resource(u"%s.ttf" % self.font_style)
		except:
			_font = self.font_style
		stim = stimuli.TextLine(text, text_font=_font, \
			text_size=self.font_size, text_bold=self.font_bold, \
			text_italic=self.font_italic)
		surf = stim._create_surface()
		return surf.get_width(), surf.get_height()

	def _text(self, text, x, y):

		"""See openexp._canvas.legacy"""

		try:
			_font = self.experiment.resource(u"%s.ttf" % self.font_style)
		except:
			_font = self.font_style

		w, h = self.text_size(text)
		x += w/2
		y += h/2

		stim = stimuli.TextLine(text, position=c2p((x,y)), \
			text_colour=self.fgcolor, text_font=_font, \
			text_size=self.font_size, text_bold=self.font_bold, \
			text_italic=self.font_italic, text_underline=self.font_underline)
		self.add_stim(stim)

	def textline(self, text, line, color=None):

		"""See openexp._canvas.legacy"""

		size = self.text_size(text)
		self.text(text, True, self.xcenter(), self.ycenter()+1.5*line*size[1], \
			color=color)

	def image(self, fname, center=True, x=None, y=None, scale=None):

		"""See openexp._canvas.legacy"""

		if x == None: x = self.xcenter()
		if y == None: y = self.ycenter()
		if center == False:
			if isinstance(fname, unicode):
				_fname = fname.encode(self.experiment.encoding)
			else:
				_fname = fname
			surf = pygame.image.load(_fname)
			if scale == None:
				x += surf.get_width()/2
				y += surf.get_height()/2
			else:
				x += scale*surf.get_width()/2
				y += scale*surf.get_height()/2
		stim = stimuli.Picture(fname, position=c2p((x,y)))
		if scale != None: stim.scale( (scale, scale) )
		self.add_stim(stim)

	def gabor(self, x, y, orient, freq, env=u"gaussian", size=96, stdev=12, \
		phase=0, col1=u"white", col2=u"black", bgmode=u"avg"):

		"""See openexp._canvas.legacy"""

		surface = openexp._canvas.legacy._gabor(orient, freq, env, size, \
			stdev, phase, col1, col2, bgmode)
		stim = stimuli._visual.Visual(position=c2p((x,y)))
		stim._surface = surface
		self.add_stim(stim)

	def noise_patch(self, x, y, env=u"gaussian", size=96, stdev=12, \
		col1=u"white", col2=u"black", bgmode=u"avg"):

		"""See openexp._canvas.legacy"""

		surface = openexp._canvas.legacy._noise_patch(env, size, stdev, col1, \
			col2, bgmode)
		stim = stimuli._visual.Visual(position=c2p((x,y)))
		stim._surface = surface
		self.add_stim(stim)

"""
Static methods
"""

def init_display(experiment):

	"""See openexp._canvas.legacy"""

	import pygame

	# Configure Expyriment
	io.defaults.mouse_track_button_events = False
	control.defaults.initialize_delay = 0
	control.defaults.event_logging = 0
	control.defaults.window_mode = experiment.get(u'fullscreen') == u'no'
	control.defaults.fast_quit = True
	control.defaults.window_size = experiment.resolution()
	control.defaults.auto_create_subject_id = True
	control.defaults.open_gl = experiment.get_check(u'expyriment_opengl', \
		xpyriment.settings[u'expyriment_opengl'][u'default']) == u'yes'
	control.defaults.audiosystem_sample_rate = experiment.get(u'sound_freq')
	control.defaults.audiosystem_bit_depth = experiment.get(u'sound_sample_size')
	control.defaults.audiosystem_channels = experiment.get(u'sound_channels')
	control.defaults.audiosystem_buffer_size = experiment.get(u'sound_buf_size')

	# Initialize
	exp = control.initialize()
	experiment._time_func = pygame.time.get_ticks
	experiment._sleep_func = pygame.time.delay
	experiment.time = experiment._time_func
	experiment.sleep = experiment._sleep_func
	experiment.window = exp.screen._surface
	experiment.expyriment = exp

	# TODO: In order to set the window title and to allow mouse responses we
	# need to bypass expyriment for now
	pygame.display.set_caption(u'OpenSesame (Expyriment backend)')
	pygame.event.set_allowed(pygame.MOUSEBUTTONDOWN)
	pygame.event.set_allowed(pygame.MOUSEBUTTONUP)

def close_display(experiment):

	"""See openexp._canvas.legacy"""

	control.end()

########NEW FILE########
__FILENAME__ = droid
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

import pygame
import sys
import openexp
from openexp._keyboard.legacy import *

try:
	import android
except ImportError:
	android = None

class droid(legacy):

	"""
	Keyboard back-end for Android devices. Only changes the legacy back-end by
	allowing Android-specific interrupts.
	"""			

	def get_key(self, keylist=None, timeout=None):

		"""See openexp._keyboard.legacy"""
		
		if android != None:
			android.show_keyboard()		
		start_time = pygame.time.get_ticks()
		time = start_time		
		if keylist == None:
			keylist = self._keylist
		if timeout == None:
			timeout = self.timeout
		while True:
			time = pygame.time.get_ticks()
			for event in pygame.event.get():
				if event.type != pygame.KEYDOWN:
					continue
				if event.key == pygame.K_ESCAPE:
					raise osexception( \
						"The escape key was pressed.")
				# TODO The unicode mechanism that ensures compatibility between
				# keyboard layouts doesn't work for Android, so we use key
				# names. I'm not sure what effect this will have on non-QWERTY
				# virtual keyboards.
				key = pygame.key.name(event.key)
				if keylist == None or key in keylist:
					if android != None:
						android.hide_keyboard()
					return key, time				
			if timeout != None and time-start_time >= timeout:
				break
			# Allow Android interrupt
			if android != None and android.check_pause():
				android.wait_for_resume()
		if android != None:
			android.hide_keyboard()				
		return None, time
########NEW FILE########
__FILENAME__ = legacy
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

import pygame
from pygame.locals import *
from string import whitespace, printable
from libopensesame.exceptions import osexception

# Whitespace and empty strings are not acceptable names for keys. These should
# be converted to descriptions, e.g. '\t' to 'tab'
invalid_unicode = [u''] + list(whitespace)

class legacy:

	"""
	The legacy backend is the default backend which uses PyGame to handle all
	keyboard input. This is essentially a class based on the openexp.response
	module, which is now deprecated.

	This class can serve as a template for creating new OpenSesame keyboard
	input backends. The new backend can be activated by adding
	"set keyboard_backend [name]" to the OpenSesame script

	A few guidelines:
	-- Acceptable key-formats are characters and integers, interpreted as ASCII
	   key codes
	-- Moderators are represented by the following strings: "shift", "alt",
	   "control" and "meta"
	-- Catch exceptions wherever possible and raise an
	   osexception with a clear and descriptive error
	   message
	-- Do not deviate from the guidelines. All back-ends should be
	   interchangeable and transparent to OpenSesame. You are free to add
	   functionality to this class, to be used in inline scripts, but this
	   should not break the basic functionality.
	"""

	def __init__(self, experiment, keylist=None, timeout=None):

		"""<DOC>
		Intializes the keyboard object.

		Keys can be identified either by character or name. This is case #
		insensitive. Naming keys using ASCII (integer) key codes is deprecated.

		For example:
		- The key 'a' is represented by 'a' and 'A'.
		- The up arrow is represented by 'up' and 'UP'.
		- The '/' key is represented by '/', 'slash', and 'SLASH'.
		- The spacebar is represented by 'space' and 'SPACE'.

		For a complete list of available key names, click on the 'list available #
		keys' button in the keyboard_response tab within OpenSesame.

		Arguments:
		experiment -- An instance of libopensesame.experiment.experiment.

		Keyword arguments:
		keylist -- A list of human-readable keys that are accepted or None to #
				   accept all keys (default=None).
		timeout -- An integer value specifying a timeout in milliseconds or None #
				   for no timeout (default=None).

		Example:
		>>> from openexp.keyboard import keyboard
		>>> my_keyboard = keyboard(exp, keylist=['z', 'm'], timeout=2000)
		</DOC>"""

		pygame.init()
		self.key_code_to_name = {}
		self.key_name_to_code = {}
		for i in dir(pygame):
			if i[:2] == u"K_":
				code = getattr(pygame, i)
				name1 = self.key_name(code).lower()
				name2 = name1.upper()
				name3 = i[2:].lower()
				name4 = name3.upper()
				self.key_code_to_name[code] = [name1, name2, name3, name4]
				try:
					i = int(name5)
					self.key_code_to_name[code].append(name5)
				except:
					pass
				self.key_name_to_code[name1] = code
				self.key_name_to_code[name2] = code
				self.key_name_to_code[name3] = code
				self.key_name_to_code[name4] = code
		self.experiment = experiment
		self.set_keylist(keylist)
		self.set_timeout(timeout)

	def set_keylist(self, keylist=None):

		"""<DOC>
		Sets a list of accepted keys.

		Keyword arguments:
		keylist -- A list of keys that are accepted or None to accept all keys #
				   (default=None).

		Example:
		>>> from openexp.keyboard import keyboard
		>>> my_keyboard = keyboard(exp)
		>>> my_keyboard.set_keylist( ['z', 'm'] )
		</DOC>"""

		if keylist == None:
			self._keylist = None
		else:
			self._keylist = []
			for key in keylist:
				self._keylist += self.synonyms(key)

	def set_timeout(self, timeout=None):

		"""<DOC>
		Sets a timeout.

		Keyword arguments:
		timeout -- An integer value specifying a timeout in milliseconds or None #
				   for no timeout (default=None).

		Example:
		>>> from openexp.keyboard import keyboard
		>>> my_keyboard = keyboard(exp)
		>>> my_keyboard.set_timeout(2000)
		</DOC>"""

		self.timeout = timeout

	def get_key(self, keylist=None, timeout=None):

		"""<DOC>
		Waits for keyboard input.

		Keyword arguments:
		keylist -- A list of human-readable keys that are accepted or None to #
				   use the default. This parameter does not change the default #
				   keylist (default=None).
		timeout -- An integer value specifying a timeout in milliseconds or None #
				   to use the default. This parameter does not change the #
				   default timeout (default=None).

		Exceptions:
		An osexception if 'escape' was pressed.

		Returns:
		A (key, timestamp) tuple. The key is None if a timeout occurs.

		Example:
		>>> from openexp.keyboard import keyboard
		>>> my_keyboard = keyboard(exp, timeout=2000)
		>>> response, timestamp = my_keyboard.get_key()
		>>> if response == None:
		>>> 	print('A timeout occurred!')
		</DOC>"""

		start_time = pygame.time.get_ticks()
		time = start_time

		if keylist == None:
			keylist = self._keylist
		if timeout == None:
			timeout = self.timeout

		while True:
			time = pygame.time.get_ticks()
			for event in pygame.event.get():
				if event.type != pygame.KEYDOWN:
					continue
				if event.key == pygame.K_ESCAPE:
					raise osexception(u'The escape key was pressed.')
				if event.unicode in invalid_unicode or event.unicode not in \
					printable:
					key = self.key_name(event.key)
				else:
					key = event.unicode
				if keylist == None or key in keylist:
					return key, time
			if timeout != None and time-start_time >= timeout:
				break
		return None, time

	def get_mods(self):

		"""<DOC>
		Returns a list of keyboard moderators (e.g., shift, alt, etc.) that are #
		currently pressed.

		Returns:
		A list of keyboard moderators. An empty list is returned if no #
		moderators are pressed.

		Example:
		>>> from openexp.keyboard import keyboard
		>>> my_keyboard = keyboard(exp)
		>>> moderators = my_keyboard.get_mods()
		>>> if 'shift' in moderators:
		>>> 	print('The shift-key is down!')
		</DOC>"""

		l = []
		mods = pygame.key.get_mods()
		if mods & KMOD_LSHIFT or mods & KMOD_RSHIFT or mods & KMOD_SHIFT:
			l.append(u"shift")
		if mods & KMOD_LCTRL or mods & KMOD_RCTRL or mods & KMOD_CTRL:
			l.append(u"ctrl")
		if mods & KMOD_LALT or mods & KMOD_RALT or mods & KMOD_ALT:
			l.append(u"alt")
		if mods & KMOD_LMETA or mods & KMOD_RMETA or mods & KMOD_META:
			l.append(u"meta")
		return l

	def shift(self, key, mods=[u"shift"]):

		"""
		DEPRECATED

		This function has been deprecated as of 0.27.4. Shift is handled
		transparently by keyboard.get_key()

		Arguments:
		key 	--	A key.

		Keyword arguments:
		mods	--	A list of keyboard modifiers.

		Exception:
		This function always raises an exception
		"""

		raise osexception( \
			u"keyboard.shift() is deprecated")

	def to_int(self, key):

		"""
		DEPRECATED

		This function has been removed as of 0.26. Keys are now only referred to
		by their name and/ or character

		Arguments:
		key -- a key

		Exception:
		This function always raises an exception
		"""

		raise osexception( \
			u"keyboard.to_int() is deprecated")

	def to_chr(self, key):

		"""
		DEPRECATED

		This function is deprecated as of 0.26. Keys are now only referred to
		by their name and/ or character and this conversion function is no
		longer necessary. For backwards compatibility, the input argument is
		silently returned.

		Arguments:
		key -- a key

		Returns:
		The key
		"""

		return key

	def valid_keys(self):

		"""
		Generates a list of valid key names. Mostly for use by the GUI.

		Returns:
		A list of valid key names
		"""

		return sorted(self.key_name_to_code.keys())

	def synonyms(self, key):

		"""
		Gives a list of synonyms for a key, either codes or names. Synonyms
		include all variables as types and as Unicode strings (if applicable).

		Returns:
		A list of synonyms
		"""

		# If the key is not familiar, simply return it plus its string
		# representation.
		if key not in self.key_name_to_code:
			return [key, self.experiment.unistr(key)]
		return self.key_code_to_name[self.key_name_to_code[key]]

	def flush(self):

		"""<DOC>
		Clears all pending input, not limited to the keyboard.

		Exceptions:
		An osexception if 'escape' was pressed

		Returns:
		True if a key had been pressed (i.e., if there was something #
		to flush) and False otherwise.

		Example:
		>>> from openexp.keyboard import keyboard
		>>> my_keyboard = keyboard(exp)
		>>> my_keyboard.flush()
		>>> response, timestamp = my_keyboard.get_key()
		</DOC>"""

		keypressed = False
		for event in pygame.event.get():
			if event.type == KEYDOWN:
				keypressed = True
				if event.key == pygame.K_ESCAPE:
					raise osexception( \
						u"The escape key was pressed.")
		return keypressed

	def key_name(self, key):

		"""
		Returns the name that corresponds to a key code. This intercepts the
		pygame.key.name() function, to prevent invalid names like '[1]'.

		Arguments:
		key		--	A key code.

		Returns:
		A unicode string corresponding to the key code.
		"""

		return unicode(pygame.key.name(key)).replace(u'[', u'') \
			.replace(u']', u'')

########NEW FILE########
__FILENAME__ = psycho
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
import openexp._keyboard.legacy
from psychopy import event
import pyglet.window.key

class psycho(openexp._keyboard.legacy.legacy):

	"""
	This is a canvas backend that uses PsychoPy
	"""
	
	# The keymap is an incomplete attempt at translating keys from the PyGame 
	# names to the names used by PsychoPy
	keymap = {
		'!' : 'exclamation',
		'"' : 'doublequote',
		'#' : 'hash',
		'$' : 'dollar',
		'&' : 'ampersand',
		'\'' : 'quoteleft',
		'(' : None,
		')' : None,
		'*' : 'asterisk',
		'+' : 'plus',
		',' : 'comma',
		'-' : 'minus',
		'.' : None,
		'/' : 'slash',
		':' : 'colin',
		';' : 'semicolon',
		'=' : 'equal',
		'>' : 'greater',
		'?' : 'question',
		'@' : 'at',
		'[' : 'bracketleft',
		'\\' : 'backslash',
		']' : 'bracketright',
		'^' : None,
		'_' : 'underscore'
		}	

	def __init__(self, experiment, keylist=None, timeout=None):

		"""See openexp._keyboard.legacy"""

		if experiment.canvas_backend != "psycho":
			raise osexception( \
				"The psycho keyboard backend must be used in combination with the psycho canvas backend!")

		self.experiment = experiment
		self.set_keylist(keylist)
		self.set_timeout(timeout)				

	def valid_keys(self):

		"""See openexp._keyboard.legacy"""

		l = []
		for i in dir(pyglet.window.key):
			if isinstance(getattr(pyglet.window.key, i), int):
				l.append(i)
		return l

	def set_keylist(self, keylist=None):

		"""See openexp._keyboard.legacy"""

		if keylist == None:
			self._keylist = None
		else:
			_keylist = []
			for key in keylist:
				if key in self.keymap:
					_keylist.append(self.keymap[key])
				else:				
					if not hasattr(pyglet.window.key, key.upper()) and not \
						hasattr(pyglet.window.key, "NUM_%s" % key):
						raise osexception( \
							"The key '%s' is not recognized by the psycho keyboard backend. Please refer to <a href='http://pyglet.org/doc/api/pyglet.window.key-module.html'>http://pyglet.org/doc/api/pyglet.window.key-module.html</a> for a list of valid keys." \
							% key)
					_keylist.append(key)
			self._keylist = _keylist

	def set_timeout(self, timeout=None):

		"""See openexp._keyboard.legacy"""

		self.timeout = timeout

	def get_key(self, keylist=None, timeout=None):

		"""See openexp._keyboard.legacy"""

		if keylist == None:
			keylist = self._keylist
		if timeout == None:
			timeout = self.timeout

		if keylist == None:
			_keylist = None
		else:
			_keylist = keylist + ["escape"]
			
		start_time = 1000.0 * self.experiment.clock.getTime()
		time = start_time
		
		while True:
			time = 1000.0 * self.experiment.clock.getTime()
			keys = event.getKeys(_keylist, timeStamped=self.experiment.clock)
			for key, time in keys:
				time *= 1000.0
				if key == "escape":
					raise osexception( \
						"The escape key was pressed.")
				elif keylist == None or key in keylist:				
					return key, time
			if timeout != None and time-start_time >= timeout:
				break

		return None, time

	def get_mods(self):

		"""See openexp._keyboard.legacy"""

		# TODO: Accept moderator keys
		return []

	def shift(self, key):

		"""See openexp._keyboard.legacy"""

		# TODO: Accept moderator keys
		return key

	def synonyms(self, key):

		"""See openexp._keyboard.legacy"""
		
		# Respond correctly if a keycode is passed, rather than a Unicode string
		# key description.
		if type(key) == int:
			l = [key, pyglet.window.key.symbol_string(key).lower()]
			if l[-1].upper() != l[-1].lower():
				l.append(l[-1].upper())
			return l
		
		# Sanity check
		if not isinstance(key, basestring):
			raise osexception( \
				'Key names should be string or numeric, not %s' % type(key))
		
		# Make a list of all conceivable ways that a key might be referred to.
		l = [key, key.upper()]
		if key.upper() != key.lower():
			l.append(key.lower())
		for char, name in self.keymap.items():
			if key == char:
				l.append(name)
			if key.lower() == name:
				l.append(char)	
		# Make sure that we can deal with None/ timeout responses
		if key.lower() == 'none':
			l.append(None)
		# Make sure that we convert numeric strings to ints as well
		try:
			i = int(key)
			l.append(i)
		except:
			pass
		return l

	def flush(self):

		"""See openexp._keyboard.legacy"""

		keypressed = False
		for key in event.getKeys():
			if key == "escape":
				raise osexception( \
					"The escape key was pressed.")
			keypressed = True
		return keypressed


########NEW FILE########
__FILENAME__ = droid
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

import sys
import pygame
from pygame.locals import *
import openexp._mouse.legacy
from libopensesame.exceptions import osexception
try:
	import android
except ImportError:
	android = None

class droid(openexp._mouse.legacy.legacy):

	"""
	Mouse back-end for Android devices. Only changes the legacy back-end by
	allowing Android-specific interrupts and not providing a custom mouse
	cursor.
	"""	
	
	def __init__(self, experiment, buttonlist=None, timeout=None, visible=False):
	
		"""See openexp._mouse.legacy"""		
	
		self.experiment = experiment
		self.set_buttonlist(buttonlist)
		self.set_timeout(timeout)
		self.set_visible(visible)		
		
	def get_click(self, buttonlist=None, timeout=None, visible=None):
	
		"""See openexp._mouse.legacy"""
	
		if android == None:
			pygame.mouse.set_visible(True)
		if buttonlist == None:
			buttonlist = self.buttonlist
		if timeout == None:
			timeout = self.timeout
		if visible == None:
			visible = self.visible
		enable_escape = self.experiment.get_check(u'enable_escape', u'no', \
			[u'yes', u'no']) == u'yes'
		start_time = pygame.time.get_ticks()
		time = start_time		
		while timeout == None or time - start_time < timeout:
			time = pygame.time.get_ticks()
			# Process the input
			for event in pygame.event.get():
				if event.type == KEYDOWN and event.key == pygame.K_ESCAPE:
					raise osexception(u"The escape key was pressed.")
				if event.type == MOUSEBUTTONDOWN:
					# Check escape sequence. If the top-left and top-right
					# corner are clicked successively within 2000ms, the
					# experiment is aborted
					if enable_escape and event.pos[0] < 64 and event.pos[1] \
						< 64:
						_time = pygame.time.get_ticks()
						while pygame.time.get_ticks() - _time < 2000:
							for event in pygame.event.get():
								if event.type == MOUSEBUTTONDOWN:
									if event.pos[0] > self.experiment.get( \
										u'width')-64 and event.pos[1] < 64:
										raise osexception( \
											u"The escape sequence was clicked/ tapped")
					if buttonlist == None or event.button in buttonlist:
						return event.button, event.pos, time
			# Allow Android interrupt
			if android != None and android.check_pause():
				android.wait_for_resume()
		return None, None, time
		

########NEW FILE########
__FILENAME__ = legacy
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

import openexp.mouse
from libopensesame.exceptions import osexception
import pygame
from pygame.locals import *

class legacy:

	"""
	The legacy backend is the default backend which uses PyGame to handle all
	mouse input.

	This class serves as a template for creating OpenSesame mouse input
	backends. The new backend can be activated by adding
	"set mouse_backend dummy"

	A few guidelines:
	-- Buttons are numbered as follows:
		1 = left
		2 = middle
		3 = right
		4 = scroll up
		5 = scroll down
	-- Catch exceptions wherever possible and raise an
	   osexception with a clear and descriptive error
	   message.
	-- Do not deviate from the guidelines. All back-ends should be
	   interchangeable and transparent to OpenSesame. You are free to add
	   functionality to this class, to be used in inline scripts, but this
	   should not break the basic functionality.
	"""

	settings = {
		"custom_cursor" : {
			"name" : "Custom cursor",
			"description" : "Bypass the system mouse cursor",
			"default" : "no"
			},
		"enable_escape" : {
			"name" : "Enable escape",
			"description" : "Abort the experiment when the upper left and right corners are clicked",
			"default" : "no",
			}
		}

	def __init__(self, experiment, buttonlist=None, timeout=None, visible=False):

		"""<DOC>
		Intializes the mouse object.

		Arguments:
		experiment -- An instance of libopensesame.experiment.experiment.

		Keyword arguments:
		buttonlist -- A list of buttons that are accepted or None to accept all #
					  input (default = None).
		timeout -- An integer value specifying a timeout in milliseconds or None #
				   for no timeout (default = None).
		visible -- A Boolean indicating the visibility of the cursor #
				   (default=False).

		Example:
		>>> from openexp.mouse import mouse
		>>> my_mouse = mouse(exp)
		</DOC>"""

		self.experiment = experiment
		self.set_buttonlist(buttonlist)
		self.set_timeout(timeout)
		self.set_visible(visible)
		if self.experiment.get_check('custom_cursor', 'no') == 'yes':
			self.cursor = pygame.image.load(self.experiment.resource( \
				'cursor.png'))
		else:
			self.cursor = None

	def set_buttonlist(self, buttonlist = None):

		"""<DOC>
		Sets a list of accepted buttons.

		Keyword arguments:
		buttonlist -- A list of buttons that are accepted or None to accept all #
					  input (default=None).

		Example:
		>>> from openexp.mouse import mouse
		>>> my_mouse = mouse(exp)
		>>> my_mouse.set_buttonlist( [1,2] )
		</DOC>"""

		if buttonlist == None:
			self.buttonlist = None
		else:
			self.buttonlist = []
			try:
				for b in buttonlist:
					self.buttonlist.append(int(b))
			except:
				raise osexception( \
					"The list of mousebuttons must be a list of numeric values")

	def set_timeout(self, timeout=None):

		"""<DOC>
		Sets a timeout.

		Keyword arguments:
		timeout -- An integer value specifying a timeout in milliseconds or None #
				   for no timeout (default=None).

		Example:
		>>> from openexp.mouse import mouse
		>>> my_mouse = mouse(exp)
		>>> my_mouse.set_timeout(2000)
		</DOC>"""

		self.timeout = timeout

	def set_visible(self, visible=True):

		"""<DOC>
		Sets the visibility of the cursor.

		Keyword arguments:
		visible -- A Boolean indicating the visibility of the cursor #
				   (default=True).

		Example:
		>>> from openexp.mouse import mouse
		>>> my_mouse = mouse(exp)
		>>> my_mouse.set_visible()
		</DOC>"""

		self.visible = visible
		pygame.mouse.set_visible(visible)

	def set_pos(self, pos=(0,0)):

		"""<DOC>
		Sets the mouse position.

		Keyword arguments:
		pos -- A (x,y) tuple for the new mouse coordinates (default = (0,0))

		Example:
		>>> from openexp.mouse import mouse
		>>> my_mouse = mouse(exp)
		>>> my_mouse.set_pos(pos=(0,0))
		</DOC>"""

		pygame.mouse.set_pos(pos)

	def get_click(self, buttonlist=None, timeout=None, visible=None):

		"""<DOC>
		Waits for mouse input.

		Keyword arguments:
		buttonlist -- A list of buttons that are accepted or None to use the #
					  default. This parameter does not change the default keylist #
					  (default=None).
		timeout -- An integer value specifying a timeout in milliseconds or None #
				   to use the default. This parameter does not change the #
				   default timeout (default=None).
		visible -- A Boolean indicating the visibility of the target or None to #
				   use the default. This parameter does not change the default #
				   visibility (default=False).

		Returns:
		A (button, position, timestamp) tuple. The button and position are None #
		if a timeout occurs. Position is an (x, y) tuple in screen coordinates.

		Example:
		>>> from openexp.mouse import mouse
		>>> my_mouse = mouse(exp)
		>>> button, position, timestamp = my_mouse.get_click()
		>>> if button == None:
		>>> 	print('A timeout occurred!')
		</DOC>"""

		if buttonlist == None:
			buttonlist = self.buttonlist
		if timeout == None:
			timeout = self.timeout
		if visible == None:
			visible = self.visible
		enable_escape = self.experiment.get_check('enable_escape', 'no', \
			['yes', 'no']) == 'yes'
		if self.cursor == None:
			pygame.mouse.set_visible(visible)
		elif visible:
			pygame.mouse.set_visible(False)

		start_time = pygame.time.get_ticks()
		time = start_time

		while True:
			time = pygame.time.get_ticks()

			# Draw a cusom cursor if necessary
			if self.cursor != None and visible:
				surface = self.experiment.last_shown_canvas.copy()
				surface.blit(self.cursor, pygame.mouse.get_pos())
				self.experiment.surface.blit(surface, (0,0))
				pygame.display.flip()

			# Process the input
			for event in pygame.event.get():
				if event.type == KEYDOWN and event.key == pygame.K_ESCAPE:
					raise osexception( \
						"The escape key was pressed.")
				if event.type == MOUSEBUTTONDOWN:

					# Check escape sequence. If the top-left and top-right
					# corner are clicked successively within 2000ms, the
					# experiment is aborted
					if enable_escape and event.pos[0] < 64 and event.pos[1] \
						< 64:
						_time = pygame.time.get_ticks()
						while pygame.time.get_ticks() - _time < 2000:
							for event in pygame.event.get():
								if event.type == MOUSEBUTTONDOWN:
									if event.pos[0] > self.experiment.get( \
										'width')-64 and event.pos[1] < 64:
										raise osexception( \
											"The escape sequence was clicked/ tapped")

					if (buttonlist == None or event.button in buttonlist):
						if self.cursor is None:
							pygame.mouse.set_visible(self.visible)
						return event.button, event.pos, time
			if timeout != None and time-start_time >= timeout:
				break

		if self.cursor == None:
			pygame.mouse.set_visible(self.visible)
		return None, None, time

	def get_pos(self):

		"""<DOC>
		Returns the current location of the cursor.

		Returns:
		A (position, timestamp) tuple.

		Example:
		>>> from openexp.mouse import mouse
		>>> my_mouse = mouse(exp)
		>>> position, timestamp = my_mouse.get_pos()
		>>> x, y = position
		>>> print('The cursor was at (%d, %d)' % (x, y))
		</DOC>"""

		pygame.event.get()
		return pygame.mouse.get_pos(), self.experiment.time()

	def get_pressed(self):

		"""<DOC>
		Returns the current state of the mouse buttons. A True value means #
		the button is currently being pressed.

		Returns:
		A (button1, button2, button3) tuple.

		Example:
		>>> from openexp.mouse import mouse
		>>> my_mouse = mouse(exp)
		>>> buttons = my_mouse.get_pressed()
		>>> b1, b2, b3 = buttons
		>>> print('Currently pressed mouse buttons: (%d, %d, %d)' % (b1, b2, b3))
		</DOC>"""

		return pygame.mouse.get_pressed()

	def flush(self):

		"""<DOC>
		Clears all pending input, not limited to the mouse.

		Returns:
		True if a button had been clicked (i.e., if there was something #
		to flush) and False otherwise.

		Example:
		>>> from openexp.mouse import mouse
		>>> my_mouse = mouse(exp)
		>>> my_mouse.flush()
		>>> button, position, timestamp = my_mouse.get_click()
		</DOC>"""

		buttonclicked = False
		for event in pygame.event.get():
			if event.type == KEYDOWN and event.key == pygame.K_ESCAPE:
				raise osexception( \
					"The escape key was pressed.")
			if event.type == MOUSEBUTTONDOWN:
				buttonclicked = True
		return buttonclicked

	def synonyms(self, button):

		"""
		Gives a list of synonyms for a mouse button. For example, 1 and #
		'left_click' are synonyms.

		Arguments:
		button -- A button value.

		Returns:
		A list of synonyms.
		"""

		button_map = [ (1, "left_button"), (2, "middle_button"), (3, \
			"right_button"), (4, "scroll_up"), (5, "scroll_down") ]
		for bm in button_map:
			if button in bm:
				return bm
		return []


########NEW FILE########
__FILENAME__ = psycho
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

import openexp.mouse
from libopensesame.exceptions import osexception
import openexp._mouse.legacy
from psychopy import event
import psychopy.visual

class psycho(openexp._mouse.legacy.legacy):

	"""This is a mouse backend built on top of PsychoPy"""

	def __init__(self, experiment, buttonlist=None, timeout=None, \
		visible=False):
	
		"""See openexp._mouse.legacy"""
		
		if experiment.canvas_backend != "psycho":
			raise osexception( \
				"The psycho mouse backend must be used in combination with the psycho canvas backend!")
	
		self.experiment = experiment						
		self.set_buttonlist(buttonlist)
		self.set_timeout(timeout)
		self.mouse = event.Mouse(visible=False, win=self.experiment.window)
		self.set_visible(visible)
		event.mouseButtons = [0, 0, 0]	
				
	def set_buttonlist(self, buttonlist=None):
	
		"""See openexp._mouse.legacy"""
	
		if buttonlist == None:
			self.buttonlist = None
		else:
			self.buttonlist = []
			try:
				for b in buttonlist:
					self.buttonlist.append(int(b))
			except:
				raise osexception( \
					"The list of mousebuttons must be a list of numeric values")
		
	def set_timeout(self, timeout=None):	
	
		"""See openexp._mouse.legacy"""
			
		self.timeout = timeout
				
	def set_visible(self, visible=True):
	
		"""See openexp._mouse.legacy"""
	
		self.visible = visible
		self.mouse.setVisible(visible)

	def set_pos(self, pos=(0,0)):

		"""See openexp._mouse.legacy"""	

		if psychopy.visual.openWindows[0].winType == 'pyglet':
			raise osexception( \
				"Method set_pos not supported in pyglet environment (default for psycho back-end)")

		self.mouse.setPos(newPos=pos)
		
	def get_click(self, buttonlist=None, timeout=None, visible=None):
	
		"""See openexp._mouse.legacy"""
		
		if buttonlist == None:
			buttonlist = self.buttonlist
		if timeout == None:
			timeout = self.timeout	
		if visible == None:
			visible = self.visible			
		self.mouse.setVisible(visible)	
		
		start_time = 1000.0 * self.experiment.clock.getTime()
		time = start_time			
		button = None
		pos = None
		self.mouse.clickReset()
		while True:
			time = 1000.0 * self.experiment.clock.getTime()			
			buttons, times = self.mouse.getPressed(getTime=True)
			if buttons[0] and (buttonlist == None or 1 in buttonlist):
				button = 1
				pos = self.mouse.getPos()
				break
			if buttons[1] and (buttonlist == None or 2 in buttonlist):
				button = 2
				pos = self.mouse.getPos()
				break
			if buttons[2] and (buttonlist == None or 3 in buttonlist):
				button = 3
				pos = self.mouse.getPos()
				break
			if timeout != None and time-start_time >= timeout:
				break
		if pos != None:
			pos = pos[0]+self.experiment.width/2, \
				self.experiment.height/2-pos[1]
		self.mouse.setVisible(self.visible)					
		return button, pos, time					
		
	def get_pos(self):
	
		"""See openexp._mouse.legacy"""
	
		x, y = self.mouse.getPos()
		t = self.experiment.time()
		x = x + self.experiment.width/2
		y = self.experiment.height/2 - y
		return (x, y), t

	def get_pressed(self):
	
		"""See openexp._mouse.legacy"""

		return tuple(self.mouse.getPressed(getTime=False))
		
	def flush(self):
	
		"""See openexp._mouse.legacy"""
	
		event.mouseButtons = [0,0,0]
		event.clearEvents()
		return False
		
	def synonyms(self, button):
	
		"""See openexp._mouse.legacy"""
				
		button_map = [ (1, "left_button"), (2, "middle_button"), (3, \
			"right_button"), (4, "scroll_up"), (5, "scroll_down") ]
		for bm in button_map:
			if button in bm:
				return bm
		return []		

########NEW FILE########
__FILENAME__ = xpyriment
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

import openexp._mouse.legacy
from libopensesame.exceptions import osexception
import pygame
from pygame.locals import *
from expyriment import stimuli
from expyriment.misc.geometry import coordinates2position as c2p

class xpyriment(openexp._mouse.legacy.legacy):

	"""
	Mouse backend built on top of Expyriment. Contains only minor differences
	from the legacy backend to re-implement the custom mouse cursor.
	"""
	
	settings = {
		"custom_cursor" : {
			"name" : "Custom cursor",
			"description" : "Bypass the system mouse cursor",
			"default" : "no"
			}
		}	

	def __init__(self, experiment, buttonlist=None, timeout=None, \
		visible=False):
	
		"""See openexp._mouse.legacy"""		
	
		self.experiment = experiment
		self.set_buttonlist(buttonlist)
		self.set_timeout(timeout)
		self.set_visible(visible)		
		if self.experiment.get_check('custom_cursor', 'no') == 'yes':
			if self.experiment.expyriment.screen._fullscreen:
				raise osexception( \
					'The xpyriment mouse back-end does not support custom cursors in fullscreen mode (you can change this in the back-end settings)')
			self.cursor = stimuli.Picture(self.experiment.resource( \
				'cursor.png'))
		else:
			self.cursor = None				
		
	def get_click(self, buttonlist=None, timeout=None, visible=None):
	
		"""See openexp._mouse.legacy"""		
	
		if buttonlist == None:
			buttonlist = self.buttonlist
		if timeout == None:
			timeout = self.timeout	
		if visible == None:
			visible = self.visible			
		
		if self.cursor == None:
			pygame.mouse.set_visible(visible)
		elif visible:
			pygame.mouse.set_visible(False)
			bg_surface = self.experiment.last_shown_canvas._get_surface().copy()
			dx, dy = self.cursor.surface_size
			dx /= 2
			dy /= 2
		
		start_time = pygame.time.get_ticks()
		time = start_time		
		
		while True:
			time = pygame.time.get_ticks()						
			
			# Draw a cusom cursor if necessary
			if self.cursor != None and visible:
				x, y = pygame.mouse.get_pos()
				self.experiment.window.blit(bg_surface, (0,0))										
				self.cursor.position = c2p((x+dx, y+dy))
				self.cursor.present(clear=False)					
			
			# Process the input
			for event in pygame.event.get([MOUSEBUTTONDOWN, KEYDOWN]):												
				if event.type == KEYDOWN and event.key == pygame.K_ESCAPE:
					raise osexception( \
						"The escape key was pressed.")										
				if event.type == MOUSEBUTTONDOWN:
					if buttonlist == None or event.button in buttonlist:
						pygame.mouse.set_visible(self.visible)
						
						# Compensate for the fact that the screen is padded
						x, y = event.pos
						x -= (self.experiment.expyriment.screen.window_size[0] \
							-self.experiment.width)/2
						y -= (self.experiment.expyriment.screen.window_size[1] \
							-self.experiment.height)/2
												
						return event.button, (x,y), time					
			if timeout != None and time-start_time >= timeout:
				break
											
		if self.cursor == None:
			pygame.mouse.set_visible(self.visible)					
		return None, None, time		
		

########NEW FILE########
__FILENAME__ = legacy
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

import pygame
from pygame.locals import *
from libopensesame.exceptions import osexception
from openexp.keyboard import keyboard
import os.path
try:
	import numpy
except:
	numpy = None
try:
	import pygame.mixer as mixer
except ImportError:
	import android.mixer as mixer

class legacy:

	"""
	The sampler loads a sound file in .ogg or .wav format from disk and plays
	it back. The sampler offers a number of basic operations, such as pitch,
	panning, and fade in.
	"""


	# The settings variable is used by the GUI to provide a list of back-end
	# settings
	settings = {
		u"sound_buf_size" : {
			u"name" : u"Sound buffer size",
			u"description" : u"Size of the sound buffer (increase if playback is choppy)",
			u"default" : 1024
			},
		u"sound_freq" : {
			u"name" : u"Sampling frequency",
			u"description" : u"Determines the sampling rate",
			u"default" : 48000
			},
		u"sound_sample_size" : {
			u"name" : u"Sample size",
			u"description" : u"Determines the bith depth (negative = signed)",
			u"default" : -16
			},
		"sound_channels" : {
			u"name" : u"The number of sound channels",
			u"description" : u"1 = mono, 2 = stereo",
			u"default" : 2
			},
		}

	def __init__(self, experiment, src):

		"""<DOC>
		Initializes the sampler with a specified file.

		Arguments:
		experiment -- An instance of libopensesame.experiment.experiment.
		src -- A path to a .wav or .ogg file.

		Example:
		>>> from openexp.sampler import sampler
		>>> src = exp.get_file('my_sound.ogg')
		>>> my_sampler = sampler(exp, src)
		</DOC>"""

		if src != None:
			if not os.path.exists(src):
				raise osexception( \
					u"openexp._sampler.legacy.__init__() the file '%s' does not exist" \
					% src)
			if os.path.splitext(src)[1].lower() not in (".ogg", ".wav"):
				raise osexception( \
					u"openexp._sampler.legacy.__init__() the file '%s' is not an .ogg or .wav file" \
					% src)
			# The mixer chokes on unicode pathnames that contain special
			# characters. To avoid this we convert to str with the filesystem
			# encoding.
			if isinstance(src, unicode):
				import sys
				src = src.encode(sys.getfilesystemencoding())
			self.sound = mixer.Sound(src)

		self.experiment = experiment
		self.keyboard = keyboard(experiment)
		self._stop_after = 0
		self._fade_in = 0
		self._volume = 1.0

	def stop_after(self, ms):

		"""<DOC>
		Specifies a duration after which the sampler stops playing.

		Arguments:
		ms -- An integer value specifying the duration in milliseconds.

		Example:
		>>> from openexp.sampler import sampler
		>>> src = exp.get_file('my_sound.ogg')
		>>> my_sampler = sampler(exp, src)
		>>> my_sampler.stop_after(100)
		</DOC>"""

		if type(ms) != int or ms < 0:
			raise osexception( \
				u"openexp._sampler.legacy.stop_after() requires a positive integer")

		self._stop_after = ms

	def fade_in(self, ms):

		"""<DOC>
		Sets the fade-in time in milliseconds.

		Arguments:
		ms -- An integer value specifying the duration in milliseconds.

		Example:
		>>> from openexp.sampler import sampler
		>>> src = exp.get_file('my_sound.ogg')
		>>> my_sampler = sampler(exp, src)
		>>> my_sampler.fade_in(100)
		</DOC>"""

		if type(ms) != int or ms < 0:
			raise osexception( \
				u"openexp._sampler.legacy.fade_in() requires a positive integer")

		self._fade_in = ms

	def volume(self, vol):

		"""<DOC>
		Sets the volume.

		Arguments:
		vol -- A volume between 0.0 and 1.0

		Example:
		>>> from openexp.sampler import sampler
		>>> src = exp.get_file('my_sound.ogg')
		>>> my_sampler = sampler(exp, src)
		>>> my_sampler.volume(0.5)
		</DOC>"""

		if type(vol) not in (int, float) or vol < 0 or vol > 1:
			raise osexception( \
				u"openexp._sampler.legacy.volume() requires a number between 0.0 and 1.0")

		self._volume = vol
		self.sound.set_volume(vol)

	def pitch(self, p):

		"""<DOC>
		Sets the relative pitch of the sample.

		Arguments:
		p -- The pitch. p > 1.0 slows the sample down, p < 1.0 speeds #
				the sample up.

		Example:
		>>> from openexp.sampler import sampler
		>>> src = exp.get_file('my_sound.ogg')
		>>> my_sampler = sampler(exp, src)
		>>> my_sampler.pitch(2.0)
		</DOC>"""

		# On Android, numpy does not exist and this is not supported
		if numpy == None:
			return

		if type(p) not in (int, float) or p <= 0:
			raise osexception( \
				u"openexp._sampler.legacy.pitch() requires a positive number")

		if p == 1:
			return

		buf = pygame.sndarray.array(self.sound)
		_buf = []

		for i in range(int(float(len(buf)) / p)):
			_buf.append(buf[int(float(i) * p)])

		self.sound = pygame.sndarray.make_sound(numpy.array(_buf, \
			dtype=u"int16"))

	def pan(self, p):

		"""<DOC>
		Sets the panning of the sample. The volume of the "unpanned" channel #
		decreases, the volume of the other channel remains the same. To fully #
		mute one channel specify "left" (mutes right, pans to left) or "right" #
		(mutes left, pans to right").

		Arguments:
		p -- Panning. A float (p < 0 = to left, p > 0 = to right) or string #
			 ("left" or "right").

		Example:
		>>> from openexp.sampler import sampler
		>>> src = exp.get_file('my_sound.ogg')
		>>> my_sampler = sampler(exp, src)
		>>> my_sampler.pan('left')
		</DOC>"""

		# On Android, numpy does not exist and this is not supported
		if numpy == None:
			return

		if type(p) not in (int, float) and p not in (u"left", u"right"):
			raise osexception( \
				u"openexp._sampler.legacy.pan() requires a number or 'left', 'right'")

		if p == 0:
			return

		buf = pygame.sndarray.array(self.sound)

		for i in range(len(buf)):

			l = buf[i][0]
			r = buf[i][1]

			if p == "left":
				r = 0
			elif p == "right":
				l = 0
			elif p < 0:
				r = int(float(r) / abs(p))
			else:
				l = int(float(l) / p)

			buf[i][0] = l
			buf[i][1] = r

		self.sound = pygame.sndarray.make_sound(numpy.array(buf))

	def play(self, block=False):

		"""<DOC>
		Plays the sound.

		Keyword arguments:
		block -- If True, block until the sound is finished (default = False).

		Example:
		>>> from openexp.sampler import sampler
		>>> src = exp.get_file('my_sound.ogg')
		>>> my_sampler = sampler(exp, src)
		>>> my_sampler.play()
		</DOC>"""

		self.sound.play(maxtime=self._stop_after, fade_ms=self._fade_in)
		if block:
			self.wait()

	def stop(self):

		"""<DOC>
		Stops the currently playing sound (if any).

		Example:
		>>> from openexp.sampler import sampler
		>>> src = exp.get_file('my_sound.ogg')
		>>> my_sampler = sampler(exp, src)
		>>> my_sampler.play()
		>>> self.sleep(100)
		>>> my_sampler.stop()
		</DOC>"""

		mixer.stop()

	def pause(self):

		"""<DOC>
		Pauses playback (if any).

		Example:
		>>> from openexp.sampler import sampler
		>>> src = exp.get_file('my_sound.ogg')
		>>> my_sampler = sampler(exp, src)
		>>> my_sampler.play()
		>>> self.sleep(100)
		>>> my_sampler.pause()
		>>> self.sleep(100)
		>>> my_sampler.resume()
		</DOC>"""

		mixer.pause()

	def resume(self):

		"""<DOC>
		Resumes playback (if any).

		Example:
		>>> from openexp.sampler import sampler
		>>> src = exp.get_file('my_sound.ogg')
		>>> my_sampler = sampler(exp, src)
		>>> my_sampler.play()
		>>> self.sleep(100)
		>>> my_sampler.pause()
		>>> self.sleep(100)
		>>> my_sampler.resume()
		</DOC>"""

		mixer.unpause()

	def is_playing(self):

		"""<DOC>
		Checks if a sound is currently playing.

		Returns:
		True if a sound is playing, False if not.

		Example:
		>>> from openexp.sampler import sampler
		>>> src = exp.get_file('my_sound.ogg')
		>>> my_sampler = sampler(exp, src)
		>>> my_sampler.play()
		>>> self.sleep(100)
		>>> if my_sampler.is_playing():
		>>> 	print('The sampler is still playing!')
		</DOC>"""

		return bool(mixer.get_busy())

	def wait(self):

		"""<DOC>
		Blocks until the sound has finished playing or returns right away if no #
		sound is playing.

		Example:
		>>> from openexp.sampler import sampler
		>>> src = exp.get_file('my_sound.ogg')
		>>> my_sampler = sampler(exp, src)
		>>> my_sampler.play()
		>>> my_sampler.wait()
		>>> print('The sampler is finished!')
		</DOC>"""

		while mixer.get_busy():
			self.keyboard.flush()

def init_sound(experiment):

	"""
	Initializes the pygame mixer before the experiment begins.

	Arguments:
	experiment -- An instance of libopensesame.experiment.experiment
	"""

	print( \
		u"openexp.sampler._legacy.init_sound(): sampling freq = %d, buffer size = %d" \
		% (experiment.sound_freq, experiment.sound_buf_size))
	if hasattr(mixer, u'get_init') and mixer.get_init():
		print( \
			u'openexp.sampler._legacy.init_sound(): mixer already initialized, closing')
		pygame.mixer.quit()
	mixer.pre_init(experiment.sound_freq, experiment.sound_sample_size, \
		experiment.sound_channels, experiment.sound_buf_size)
	mixer.init()

def close_sound(experiment):

	"""
	Closes the mixer after the experiment is finished.

	Arguments:
	experiment -- An instance of libopensesame.experiment.experiment
	"""

	mixer.quit()


########NEW FILE########
__FILENAME__ = droid
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception

class droid(object):

	"""The synth generates a sound"""
	
	def __init__(self, experiment, **keywords):
	
		"""See openexp._synth.legacy"""

		raise osexception( \
			'The synth is not supported on the droid back-end, sorry!')
		

		

########NEW FILE########
__FILENAME__ = legacy
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

import openexp._sampler.legacy
from libopensesame.exceptions import osexception
import math
import pygame
import random
import numpy
import pygame.mixer as mixer

class legacy(openexp._sampler.legacy.legacy):

	"""The synth generates a sound"""

	settings = None

	def __init__(self, experiment, osc="sine", freq=440, length=100, attack=0, decay=5):

		"""<DOC>
		Initializes the synthesizer.

		Arguments:
		experiment -- An instance of libopensesame.experiment.experiment.

		Keyword arguments:
		osc -- Oscillator, can be "sine", "saw", "square" or "white_noise" #
			   (default = "sine").
		freq -- Frequency, either an integer value (value in hertz) or a string #
				("A1", "eb2", etc.). (Default = 440)
		length -- The length of the sound in milliseconds (default = 100).
		attack -- The attack (fade-in) time in milliseconds (default = 0).
		decay -- The decay (fade-out) time in milliseconds (default = 5).

		Example:
		>>> from openexp.synth import synth
		>>> my_synth = synth(exp, freq='b2', length=500)
		</DOC>"""

		openexp._sampler.legacy.legacy.__init__(self, experiment, None)

		# If the frequency is not an int, convert it to an int
		try:
			int(freq)
		except:
			freq = self.key_to_freq(freq)

		# Set the oscillator function
		if osc == "sine":
			_func = math.sin
		elif osc == "saw":
			_func = self.saw
		elif osc == "square":
			_func = self.square
		elif osc == "white_noise":
			_func = self.white_noise
		else:
			raise osexception( \
				"synth.__init__(): '%s' is not a valid oscillator, exception 'sine', 'saw', 'square', or 'white_noise'" \
				% osc)

		l = []

		attack = attack * self.experiment.get("sound_freq") / 1000
		decay = decay * self.experiment.get("sound_freq") / 1000
		amp = 32767 / 2
		sps = self.experiment.get("sound_freq") # samples per second
		cps = float(sps / freq) # cycles per sample
		slen = self.experiment.get("sound_freq") * length / 1000 # nr of samples

		for i in range(slen):
			p = float((i % cps)) / cps * 2 * math.pi
			v = int(amp * (_func(p)))
			if i < attack:
				v = int(v * float(i) / attack)
			if i > slen - decay:
				v = int(v * (float(slen) - float(i)) / decay)
			l.append(v)
			l.append(v)

		b = numpy.array(l, dtype="int16").reshape(len(l) / 2, 2)

		self.sound = mixer.Sound(b)

	def key_to_freq(self, key):

		"""<DOC>
		Converts a key (e.g., A1) to a frequency.

		Arguments:
		key -- A string like "A1", "eb2", etc.

		Returns:
		An integer value containing the frequency in hertz.

		Example:
		>>> from openexp.synth import synth
		>>> my_synth = synth(exp)
		>>> print('An a2 is %d Hz' % my_synth.key_to_freq('a2'))
		</DOC>"""

		if type(key) != str or len(key) < 2:
			raise osexception( \
				"synth.key_to_freq(): '%s' is not a valid note, expecting something like 'A1'")

		n = key[:-1].lower()
		try:
			o = int(key[-1])
		except:
			raise osexception( \
				"synth.key_to_freq(): '%s' is not a valid note, expecting something like 'A1'")

		if n == "a":
			f = 440.0
		elif n == "a#" or n == "bb":
			f = 466.16
		elif n == "b":
			f = 493.92
		elif n == "c":
			f = 523.28
		elif n == "c#" or n == "db":
			f = 554.40
		elif n == "d":
			f = 587.36
		elif n == "d#" or n == "eb":
			f = 698.47
		elif n == "e":
			f = 659.48
		elif n == "f":
			f = 698.48
		elif n == "f#" or n == "gb":
			f = 740.00
		elif n == "g":
			f = 784.00
		elif n == "ab" or n == "g#":
			f == 830.64

		if o < 1:
			o = 0.5 ** (abs(o) + 1)
			freq = f * o
		else:
			freq = f ** o

		return freq

	def saw(self, phase):

		"""
		* For internal use

		Generates a saw wave
		"""

		phase = phase % math.pi

		return float(phase) / (0.5 * math.pi) - 1.0


	def square(self, phase):

		"""
		* For internal use

		Generates a square wave
		"""

		if phase < math.pi:
			return 1
		return -1

	def white_noise(self, phase):

		"""
		* For internal use

		Generates random noise
		"""

		return random.random()



########NEW FILE########
__FILENAME__ = opensesameandroid
#!/usr/bin/env python
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
import sys
import pygame
import traceback
from libopensesame.experiment import experiment, clean_up
try:
	import android
except:
	android = None

sdcard_folders = [
	'/sdcard/',
	'/mnt/sdcard/'
	]

class stdout_file(object):

	"""A class that redirects the standard output to a file"""

	def __init__(self, stdout):

		"""
		Constructor

		Arguments:
		stdout		--	the original standard output
		"""

		self.stdout = stdout

		# Try to auto-detect the sdcard location and create a text file there
		for path in sdcard_folders:
			if os.path.isdir(path):
				break
		try:
			self.fd = open(os.path.join(path, 'opensesame-debug.txt'), 'w')
		except:
			self.stdout.write('Failed to create %s' % path)
			self.fd = None

	def write(self, s):

		"""
		Write a message to the standard output

		Arguments:
		s			--	the message to write
		"""

		self.stdout.write(s+'\n')
		if self.fd != None:
			self.fd.write(s)
			self.fd.flush()

def main():

	"""The main routine, which is called automatically by pgs4a"""

	if android != None:
		sys.stdout = stdout_file(sys.stdout)

	# First start the menu experiment
	src = 'resources/android/menu.opensesame'
	print('Launching %s' % src)
	menu = experiment('Experiment', src)
	menu.run()
	menu.end()
	clean_up(menu.debug)

	# Next run the actual experiment!
	exp = experiment('Experiment', menu._experiment)
	print('Launching %s' % menu._experiment)
	exp.set_subject(menu._subject_nr)
	exp.logfile = menu._logfile

	# Capture exceptions and write them to the standard output so they can be
	# inspected
	try:
		exp.run()
	except Exception as e:
		for s in traceback.format_exc(e).split("\n"):
			print(s)
	try:
		exp.end()
	except Exception as e:
		for s in traceback.format_exc(e).split("\n"):
			print(s)

	clean_up(exp.debug)
	pygame.display.quit()

if __name__ == "__main__":

	# This is only necessary for testing on a regular PC. On Android, the main()
	# function is called automatically.
	main()

########NEW FILE########
__FILENAME__ = advanced_delay
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import item, debug
from libqtopensesame.items.qtautoplugin import qtautoplugin
from PyQt4 import QtGui, QtCore
import random

class advanced_delay(item.item):

	description = u'Waits for a specified duration'

	def __init__(self, name, experiment, script=None):

		"""
		Constructor.

		Arguments:
		name		--	The name of the plug-in.
		experiment	--	The experiment object.

		Keyword arguments:
		script		--	A definition script. (default=None)
		"""

		self.duration = 1000
		self.jitter = 0
		self.jitter_mode = u'Uniform'
		item.item.__init__(self, name, experiment, script)

	def prepare(self):

		"""The preparation phase of the plug-in."""

		item.item.prepare(self)
		# Sanity check on the duration value, which should be a positive numeric
		# value.
		if type(self.get('duration')) not in (int, float) or \
			self.get('duration') < 0:
			raise osexception( \
				u'Duration should be a positive numeric value in advanced_delay %s' \
				% self.name)
		if self.get(u'jitter_mode') == u'Uniform':
			self._duration = random.uniform(self.get(u'duration')-self.get( \
				u'jitter')/2, self.get(u'duration')+self.get(u'jitter')/2)
		elif self.get(u'jitter_mode') == u'Std. Dev.':
			self._duration = random.gauss(self.get(u'duration'), self.get( \
				u'jitter'))
		else:
			raise osexception( \
				u'Unknown jitter mode in advanced_delay %s' % self.name)
		# Don't allow negative durations.
		if self._duration < 0:
			self._duration = 0
		self._duration = int(self._duration)
		self.experiment.set(u'delay_%s' % self.name, self._duration)
		debug.msg(u"delay for %s ms" % self._duration)

	def run(self):

		"""The run phase of the plug-in."""

		self.set_item_onset(self.time())
		self.sleep(self._duration)

	def var_info(self):

		"""
		Gives a list of dictionaries with variable descriptions.

		Returns:
		A list of (name, description) tuples.
		"""

		return item.item.var_info(self) + [(u'delay_%s' % self.name, \
			u'[Determined at runtime]')]

class qtadvanced_delay(advanced_delay, qtautoplugin):

	"""Automatic plug-in GUI."""

	def __init__(self, name, experiment, script=None):

		advanced_delay.__init__(self, name, experiment, script)
		qtautoplugin.__init__(self, __file__)


########NEW FILE########
__FILENAME__ = auto_example
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.item import item
from libqtopensesame.items.qtautoplugin import qtautoplugin
from openexp.canvas import canvas

class auto_example(item):

	"""
	This class (the class with the same name as the module) handles the basic
	functionality of the item. It does not deal with GUI stuff.
	"""

	# Provide an informative description for your plug-in.
	description = u'An example new-style plug-in'

	def __init__(self, name, experiment, script=None):

		"""
		Constructor.
		
		Arguments:
		name		--	The name of the plug-in.
		experiment	--	The experiment object.
		
		Keyword arguments:
		script		--	A definition script. (default=None)
		"""

		# Here we provide default values for the variables that are specified
		# in info.json. If you do not provide default values, the plug-in will
		# work, but the variables will be undefined when they are not explicitly
		# set in the GUI.
		self._checkbox = u'yes' # yes = checked, no = unchecked
		self._color = u'white'
		self._option = u'Option 1'
		self._file = u''
		self._text = u'Default text'
		self._spinbox_value = 1
		self._slider_value = 1
		self._script = u'print 10'
		# Then call the parent constructor
		item.__init__(self, name, experiment, script)

	def prepare(self):

		"""The preparation phase of the plug-in goes here."""

		# Call the parent constructor.
		item.prepare(self)
		# Here simply prepare a canvas with a fixatio dot.
		self.c = canvas(self.experiment)
		self.c.fixdot()

	def run(self):

		"""The run phase of the plug-in goes here."""

		# self.set_item_onset() sets the time_[item name] variable. Optionally,
		# you can pass a timestamp, such as returned by canvas.show().
		self.set_item_onset(self.c.show())			

class qtauto_example(auto_example, qtautoplugin):
	
	"""
	This class handles the GUI aspect of the plug-in. By using qtautoplugin, we
	usually need to do hardly anything, because the GUI is defined in info.json.
	"""

	def __init__(self, name, experiment, script=None):

		"""
		Constructor.
		
		Arguments:
		name		--	The name of the plug-in.
		experiment	--	The experiment object.
		
		Keyword arguments:
		script		--	A definition script. (default=None)
		"""

		# We don't need to do anything here, except call the parent
		# constructors.
		auto_example.__init__(self, name, experiment, script)
		qtautoplugin.__init__(self, __file__)

	def init_edit_widget(self):

		"""
		Constructs the GUI controls. Usually, you can omit this function
		altogether, but if you want to implement more advanced functionality,
		such as controls that are grayed out under certain conditions, you need
		to implement this here.
		"""

		# First, call the parent constructor, which constructs the GUI controls
		# based on info.json.
		qtautoplugin.init_edit_widget(self)
		# If you specify a 'name' for a control in info.json, this control will
		# be available self.[name]. The type of the object depends on the
		# control. A checkbox will be a QCheckBox, a line_edit will be a
		# QLineEdit. Here we connect the stateChanged signal of the QCheckBox,
		# to the setEnabled() slot of the QLineEdit. This has the effect of
		# disabling the QLineEdit when the QCheckBox is uncheckhed.
		self.checkbox_widget.stateChanged.connect( \
			self.line_edit_widget.setEnabled)



########NEW FILE########
__FILENAME__ = external_script
"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import item
from libqtopensesame import qtplugin, pool_widget
import openexp.canvas
import os.path
from PyQt4 import QtGui, QtCore
import imp

class external_script(item.item):

	"""
	This class (the class with the same name as the module)
	handles the basic functionality of the item. It does
	not deal with GUI stuff.
	"""

	def __init__(self, name, experiment, string = None):
	
		"""
		Constructor
		"""
		
		# The item_typeshould match the name of the module
		self.item_type = "external_script"
		self.file = ""
		self.module = None
		self.prepare_func = "prepare"
		self.run_func = "run"
		
		# Provide a short accurate description of the items functionality
		self.description = "An alternative way of running Python code, directly from a script file"
				
		# The parent handles the rest of the contruction
		item.item.__init__(self, name, experiment, string)
						
	def prepare(self):
	
		"""
		Prepare the item. In this case this means drawing a fixation
		dot to an offline canvas.
		"""
		
		# Pass the word on to the parent
		item.item.prepare(self)
		
		if self.module == None:
			try:
				self.module = imp.load_source("file", os.path.join( \
					self.experiment.pool_folder, self.file))
			except Exception as e:
				raise osexception( \
					"Failed to import '%s' in the prepare phase of external_script item '%s': %s" \
					% (self.file, self.name, e))
			
		try:
			getattr(self.module, self.prepare_func)(self)
		except Exception as e:
			raise osexception( \
				"Failed to run function '%s(item)' in the prepare phase of external_script item '%s': %s" \
				% (self.prepare_func, self.name, e))				
		
		# Report success
		return True
				
	def run(self):
	
		"""
		Run the item. In this case this means putting the offline canvas
		to the display and waiting for the specified duration.
		"""
		
		# Show the canvas
		self.set_item_onset()
			
		try:
			getattr(self.module, self.run_func)(self)
		except Exception as e:
			raise osexception( \
				"Failed to run function '%s(item)' in the run phase of external_script item '%s': %s" \
				% (self.run_func, self.name, e))
								
		# Report success
		return True
					
class qtexternal_script(external_script, qtplugin.qtplugin):

	"""
	This class (the class named qt[name of module] handles
	the GUI part of the plugin. For more information about
	GUI programming using PyQt4, see:
	<http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/classes.html>
	"""

	def __init__(self, name, experiment, string = None):
	
		"""
		Constructor
		"""
		
		# Pass the word on to the parents		
		external_script.__init__(self, name, experiment, string)		
		qtplugin.qtplugin.__init__(self, __file__)	
		
	def init_edit_widget(self):
	
		"""
		This function creates the controls for the edit
		widget.
		"""
		
		# Lock the widget until we're doing creating it
		self.lock = True
		
		# Pass the word on to the parent		
		qtplugin.qtplugin.init_edit_widget(self, False)
		
		# Create the controls
		# 
		# A number of convenience functions are available which 
		# automatically create controls, which are also automatically
		# updated and applied. If you set the varname to None, the
		# controls will be created, but not automatically updated
		# and applied.
		#
		# qtplugin.add_combobox_control(varname, label, list_of_options)
		# - creates a QComboBox
		# qtplugin.add_line_edit_control(varname, label)
		# - creates a QLineEdit		
		# qtplugin.add_spinbox_control(varname, label, min, max, suffix = suffix, prefix = prefix)
		
		self.add_filepool_control("file", "Script file", self.browse_script, default = "", tooltip = "A Python (.py) script")	
		self.add_line_edit_control("prepare_func", "Prepare function in script", default = "prepare", tooltip = "A function with a single parameter, e.g., 'def run(item)'")		
		self.add_line_edit_control("run_func", "Run function in script", default = "run", tooltip = "A function with a single parameter, e.g., 'def run(item)'")		
		
		# Add a stretch to the edit_vbox, so that the controls do not
		# stretch to the bottom of the window.
		self.edit_vbox.addStretch()		
		
		# Unlock
		self.lock = True		
		
	def browse_script(self):
	
		"""
		Browse the filepool
		"""
		
		s = pool_widget.select_from_pool(self.experiment.main_window)
		if s == "":
			return
			
		self.auto_line_edit["file"].setText(s)			
		self.apply_edit_changes()							
		
	def apply_edit_changes(self):
	
		"""
		Set the variables based on the controls
		"""
		
		# Abort if the parent reports failure of if the controls are locked
		if not qtplugin.qtplugin.apply_edit_changes(self, False) or self.lock:
			return False
				
		# Refresh the main window, so that changes become visible everywhere
		self.experiment.main_window.refresh(self.name)		
		
		# Report success
		return True

	def edit_widget(self):
	
		"""
		Set the controls based on the variables
		"""
		
		# Lock the controls, otherwise a recursive loop might aris
		# in which updating the controls causes the variables to be
		# updated, which causes the controls to be updated, etc...
		self.lock = True
		
		# Let the parent handle everything
		qtplugin.qtplugin.edit_widget(self)				
		
		# Unlock
		self.lock = False
		
		# Return the _edit_widget
		return self._edit_widget

########NEW FILE########
__FILENAME__ = fixation_dot
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
from PyQt4 import QtGui, QtCore
from libopensesame.item import item
from libopensesame.generic_response import generic_response
from libqtopensesame.items.qtautoplugin import qtautoplugin
from openexp.canvas import canvas

class fixation_dot(item, generic_response):

	"""A simple fixation-dot plug-in."""

	description = \
		u'Presents a central fixation dot with a choice of various styles'

	def __init__(self, name, experiment, script=None):

		"""
		Constructor.

		Arguments:
		name		--	The name of the plug-in.
		experiment	--	The experiment object.

		Keyword arguments:
		script		--	A definition script. (default=None)
		"""

		# Set default values.
		self.style = u'default'
		self.duration = 1000
		self.penwidth = 3
		self.x = 0
		self.y = 0
		# Call the parent constructor.
		item.__init__(self, name, experiment, script)

	def prepare(self):

		"""Prepare a canvas with a fixation dot."""

		# Call parent functions.
		item.prepare(self)
		generic_response.prepare(self)
		# Create a canvas.
		self.c = canvas(self.experiment, self.get(u'background'), \
			self.get(u'foreground'))
		# Set the coordinates.
		self._x = self.get(u'x') + self.c.xcenter()
		self._y = self.get(u'y') + self.c.ycenter()
		# Draw the fixation dot.
		self.c.set_penwidth(self.get(u'penwidth'))
		if self.style == u'default':
			self.c.fixdot(self._x, self._y)
		elif self.style == u'filled':
			self.c.ellipse(self._x - 10, self._y - 10, 20, 20, True)
		elif self.style == u'filled-small':
			self.c.ellipse(self._x - 5, self._y - 5, 10, 10, True)
		elif self.style == u'empty':
			self.c.ellipse(self._x - 10, self._y - 10, 20, 20, False)
		elif self.style == u'empty-small':
			self.c.ellipse(self._x - 5, self._y - 5, 10, 10, False)
		elif self.style == u'cross':
			self.c.line(self._x - 10, self._y, self._x + 10, self._y)
			self.c.line(self._x, self._y - 10, self._x, self._y + 10)
		elif self.style == u'cross-small':
			self.c.line(self._x - 5, self._y, self._x + 5, self._y)
			self.c.line(self._x, self._y - 5, self._x, self._y + 5)

	def run(self):

		"""Show the canvas and wait for a specified duration."""

		self.set_item_onset(self.c.show())
		self.set_sri()
		self.process_response()
		
	def var_info(self):
		
		"""
		Gives a list of dictionaries with variable descriptions.

		Returns:
		A list of (name, description) tuples.
		"""		

		return item.var_info(self) + generic_response.var_info(self)

class qtfixation_dot(fixation_dot, qtautoplugin):

	"""The GUI part of the plug-in. Controls are defined in info.json."""

	def __init__(self, name, experiment, script=None):

		"""
		Constructor.

		Arguments:
		name		--	The name of the plug-in.
		experiment	--	The experiment object.

		Keyword arguments:
		script		--	A definition script. (default=None)
		"""

		fixation_dot.__init__(self, name, experiment, script)
		qtautoplugin.__init__(self, __file__)

########NEW FILE########
__FILENAME__ = form_base
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import item, widgets
from libqtopensesame.items.qtautoplugin import qtautoplugin
from libqtopensesame.misc import _
import openexp.canvas
import openexp.keyboard
import os.path
from PyQt4 import QtGui, QtCore

class form_base(item.item):

	"""A generic form plug-in"""
	
	def __init__(self, name, experiment, script=None, item_type=u'form_base', \
		description=u'A generic form plug-in'):

		"""
		Constructor

		Arguments:
		name		--	The item name.
		experiment	--	The experiment object.

		Keyword arguments:
		script		--	A definition script. (default=None)
		"""

		self.item_type = item_type
		self.description = description
		self.cols = u'2;2'
		self.rows = u'2;2'
		self.spacing = 10
		self.focus_widget = None
		self.theme = u'gray'
		self.only_render = u'no'
		self.margins = u'50;50;50;50'
		self._widgets = []

		item.item.__init__(self, name, experiment, script)

	def parse_line(self, line):

		"""
		Allows for arbitrary line parsing, for item-specific requirements.

		Arguments:
		line	--	A single definition line.
		"""

		l = self.split(line.strip())
		if len(l) < 6 or l[0] != u'widget':
			return

		# Verify that the position variables are integers
		try:
			col = int(l[1])
			row = int(l[2])
			colspan = int(l[3])
			rowspan = int(l[4])
		except:
			raise osexception( \
				_(u'Widget column and row should be numeric'))

		# Parse the widget into a dictionary and store it in the list of
		# widgets
		w = self.parse_keywords(line)
		w[u'type'] = l[5]
		w[u'col'] = col
		w[u'row'] = row
		w[u'colspan'] = colspan
		w[u'rowspan'] = rowspan
		self._widgets.append(w)

	def to_string(self):

		"""
		Parse the widgets back into a definition string

		Returns:
		A definition string
		"""

		s = item.item.to_string(self, self.item_type)
		for w in self._widgets:
			w = w.copy()
			_type = w[u'type']
			col = w[u'col']
			row = w[u'row']
			colspan = w[u'colspan']
			rowspan = w[u'rowspan']
			del w[u'type']
			del w[u'col']
			del w[u'row']
			del w[u'colspan']
			del w[u'rowspan']
			s += u'\twidget %s %s %s %s %s' % (col, row, colspan, rowspan, \
				_type)
			for keyword, value in w.items():
				s += ' %s="%s"' % (keyword, value)
			s += u'\n'
		s += u'\n'
		return s

	def run(self):

		"""
		Run the item

		Returns:
		True on success, False on failure
		"""

		self.set_item_onset()
		if self.get(u'only_render') == u'yes':
			self._form.render()
		else:
			self._form._exec(focus_widget=self.focus_widget)
		return True

	def prepare(self):

		"""Prepare for the run phase"""

		item.item.prepare(self)

		# Prepare the form
		try:
			cols = [float(i) for i in unicode(self.cols).split(';')]
			rows = [float(i) for i in unicode(self.rows).split(';')]
			margins = [float(i) for i in unicode(self.margins).split(';')]
		except:
			raise osexception( \
				_(u'cols, rows, and margins should be numeric values separated by a semi-colon'))
		self._form = widgets.form(self.experiment, cols=cols, rows=rows, \
			margins=margins, spacing=self.spacing, theme=self.theme, item=self)

		# Prepare the widgets
		for _w in self._widgets:

			# Evaluate all keyword arguments
			w = {}
			for var, val in _w.iteritems():
				w[var] = self.eval_text(val)

			_type = w[u'type']
			col = w[u'col']
			row = w[u'row']
			colspan = w[u'colspan']
			rowspan = w[u'rowspan']
			del w[u'type']
			del w[u'col']
			del w[u'row']
			del w[u'colspan']
			del w[u'rowspan']

			# Translate paths into full file names
			if u'path' in w:
				w[u'path'] = self.experiment.get_file(w[u'path'])

			# Process focus keyword
			focus = False
			if u'focus' in w:
				if w[u'focus'] == u'yes':
					focus = True
				del w[u'focus']

			# Create the widget and add it to the form
			try:
				_w = getattr(widgets, _type)(self._form, **w)
			except Exception as e:
				raise osexception( \
					u'Failed to create widget "%s": %s' % (_type, e))
			self._form.set_widget(_w, (col, row), colspan=colspan, \
					rowspan=rowspan)

			# Add as focus widget
			if focus:
				self.focus_widget = _w
		return True

class qtform_base(form_base, qtautoplugin):

	def __init__(self, name, experiment, script=None):

		form_base.__init__(self, name, experiment, script)
		qtautoplugin.__init__(self, __file__)

########NEW FILE########
__FILENAME__ = form_consent
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import item, exceptions, generic_response, widgets, plugins
from libqtopensesame.items.qtautoplugin import qtautoplugin
from openexp.canvas import canvas
import openexp.keyboard
import os.path
from PyQt4 import QtGui, QtCore

form_base = plugins.import_plugin(u'form_base')

default_script = u"""
__form_text__
You are about to participate in an experiment.

This experiment poses no known risks to your health and your name will not be associated with the findings.

Upon completion of your participation in this study you will be provided with a brief explanation of the question this study addresses.

If you have any questions not addressed by this consent form, please do not hesitate to ask.

You can stop at any time during experiment if you feel uncomfortable.
__end__
set form_title '<span size=24>Consent form</span>'
set checkbox_text 'I have read and understood the information shown above'
set accept_text 'Participate!'
set decline_text 'Do not participate'
set decline_message 'You need to accept the consent form to participate!'
set rows 1;4;1;1
widget 0 0 2 1 label text=[form_title]
widget 0 1 2 1 label text=[form_text] center=no
widget 0 2 2 1 checkbox text=[checkbox_text] var=checkbox_status
widget 0 3 1 1 button text=[accept_text] var=accept_status
widget 1 3 1 1 button text=[decline_text]
"""

class form_consent(form_base.form_base):

	def __init__(self, name, experiment, string=None):

		"""
		Constructor.

		Arguments:
		name		--	The name of the item.
		experiment	--	The experiment instance.

		Keyword arguments:
		string		--	A definition string. (default=None)
		"""

		if string == None:
			string = default_script
		# Due to dynamic loading, we need to implement this super() hack. See
		# <http://thingspython.wordpress.com/2010/09/27/another-super-wrinkle-raising-typeerror/>			
		self.super_form_consent = super(form_consent, self)
		self.super_form_consent.__init__(name, experiment, string, item_type= \
			u'form_consent', description=u'A simple consent form')

	def from_string(self, script):

		"""
		Re-generates the form from a definition script.

		Arguments:
		script		--	The definition script.
		"""

		self._widgets = []
		self.super_form_consent.from_string(script)

	def run(self):

		"""Executes the consent form."""

		while True:
			# In this case we cannot call super(form_consent, self), because
			# modules may have been reloaded. The exact nature of the bug is
			# unclear, but passing the __class__ property resolves it. See also
			# <http://thingspython.wordpress.com/2010/09/27/another-super-wrinkle-raising-typeerror/>
			self.super_form_consent.run()
			if self.get(u'checkbox_status') == self.get(u'checkbox_text') and \
				self.get(u'accept_status') == u'yes':
				break
			c = canvas(self.experiment)
			c.text(self.get(u'decline_message'))
			c.show()
			self.sleep(5000)
			
class qtform_consent(form_consent, qtautoplugin):
	
	def __init__(self, name, experiment, script=None):

		form_consent.__init__(self, name, experiment, script)
		qtautoplugin.__init__(self, __file__)	


########NEW FILE########
__FILENAME__ = form_multiple_choice
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import item, generic_response, widgets, plugins
from libqtopensesame.items.qtautoplugin import qtautoplugin
from openexp.canvas import canvas
import openexp.keyboard
import os.path
from PyQt4 import QtGui, QtCore

class form_multiple_choice(item.item):
	
	description = u'A simple multiple choice item'

	def __init__(self, name, experiment, string=None):

		"""
		Constructor

		Arguments:
		name		--	The name of the item.
		experiment	--	The experiment instance.

		Keyword arguments:
		string		--	A definition string. (default=None)
		"""
		
		self.options = u'Yes\nNo\nMaybe'
		self.question = u'Your question'
		self.form_title = u'Form title'
		self.form_var = u'response'
		self.advance_immediately = u'yes'
		self.allow_multiple = u'yes'
		self.button_text = u'Ok'
		self.spacing = 10
		self.margins = u'50;50;50;50'
		self.theme = u'gray'
		item.item.__init__(self, name, experiment, string)
		
	def run(self):
		
		"""Run the item"""
		
		# Parse the option list
		option_list = self.get(u'options').split(u'\n') # split by return
		option_list.pop(len(option_list)-1) # remove last (empty) option
		if len(option_list) == 0:
			raise osexception( \
				u'You must specify at least one response option in form_multiple_choice item "%s"' \
				% self.name)
			
		# Determine whether a button is shown and determine the number of rows
		rows = len(option_list) + 2
		if self.get(u'advance_immediately') == u'no' or \
			self.get(u'allow_multiple') == u'yes':
			show_button = True
			click_accepts = False
			rows += 1
		else:
			show_button = False
			click_accepts = True
			
		# Determine the group for the checkboxes
		if self.get(u'allow_multiple') == u'no':
			group = u'response_group'
		else:
			group = None
			
		# The variable in which the response is stored
		var = self.get(u'form_var')
		
		# Build the form
		try:
			margins = [float(i) for i in unicode(self.margins).split(u';')]
		except:
			raise osexception( \
				_(u'margins should be numeric values separated by a semi-colon'))
		form = widgets.form(self.experiment, cols=1, rows=rows,
			spacing=self.get(u'spacing'), margins=margins,
			theme=self.get(u'theme'), item=self)
		form.set_widget(widgets.label(form, self.get(u'form_title')), (0,0))
		form.set_widget(widgets.label(form, self.get(u'question')), (0,1))
		i = 2
		for option in option_list:
			form.set_widget(widgets.checkbox(form, option, group=group, \
				click_accepts=click_accepts, var=var), (0,i))
			i += 1
		if show_button:
			form.set_widget(widgets.button(form, self.get(u'button_text')), \
				(0,i))

		# Go!
		form._exec()
		
	def var_info(self):
		
		"""
		Return a list of dictionaries with variable descriptions

		Returns:
		A list of (name, description) tuples
		"""
		
		return item.item.var_info(self) + \
			[(self.get(u'form_var'), u'[Depends on response]')]

class qtform_multiple_choice(form_multiple_choice, qtautoplugin):

	"""GUI controls"""

	def __init__(self, name, experiment, string=None):

		"""
		Constructor

		Arguments:
		name		--	The name of the item.
		experiment	--	The experiment instance.

		Keyword arguments:
		string		--	A definition string. (default=None)
		"""
		
		form_multiple_choice.__init__(self, name, experiment, string)
		qtautoplugin.__init__(self, __file__)
		self.custom_interactions()
		
	def apply_edit_changes(self):

		"""Apply the controls"""

		if not qtautoplugin.apply_edit_changes(self) or self.lock:
			return False
		self.custom_interactions()
		return True
	
	def custom_interactions(self):
		
		"""
		The advance_immediately option is not applicable if multiple items can
		be selected.
		"""
		
		self.checkbox_advance_immediately.setEnabled(self.get( \
			u'allow_multiple') == u'no')
		self.line_edit_button_text.setEnabled(self.get(u'allow_multiple') == \
			u'yes' or self.get(u'advance_immediately') == u'no')
		


########NEW FILE########
__FILENAME__ = form_text_display
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import item, exceptions, generic_response, widgets, plugins
from libqtopensesame.items.qtautoplugin import qtautoplugin
from openexp.canvas import canvas
import openexp.keyboard
import os.path
from PyQt4 import QtGui, QtCore

form_base = plugins.import_plugin(u'form_base')

default_script = u"""
set form_text 'Your message'
set form_title '<span size=24>Title</span>'
set ok_text 'Ok'
set rows 1;4;1
set cols 1;1;1
widget 0 0 3 1 label text=[form_title]
widget 0 1 3 1 label text=[form_text] center=no
widget 1 2 1 1 button text=[ok_text]
"""

class form_text_display(form_base.form_base):

	def __init__(self, name, experiment, string=None):

		"""
		Constructor.

		Arguments:
		name		--	The name of the item.
		experiment	--	The experiment instance.

		Keyword arguments:
		string		--	A definition string. (default=None)
		"""

		if string == None:
			string = default_script
		# Due to dynamic loading, we need to implement this super() hack. See
		# <http://thingspython.wordpress.com/2010/09/27/another-super-wrinkle-raising-typeerror/>			
		self.super_form_text_display = super(form_text_display, self)
		self.super_form_text_display.__init__(name, experiment, string, \
			item_type=u'form_text_display', description= \
			u'A simple text display form')

	def from_string(self, script):

		"""
		Re-generates the form from a definition script.

		Arguments:
		script		--	The definition script.
		"""

		self._widgets = []
		self.super_form_text_display.from_string(script)
		
class qtform_text_display(form_text_display, qtautoplugin):
	
	def __init__(self, name, experiment, script=None):

		form_text_display.__init__(self, name, experiment, script)
		qtautoplugin.__init__(self, __file__)	


########NEW FILE########
__FILENAME__ = form_text_input
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import item, exceptions, generic_response, widgets, plugins
from libqtopensesame.items.qtautoplugin import qtautoplugin
from openexp.canvas import canvas
import openexp.keyboard
import os.path
from PyQt4 import QtGui, QtCore

form_base = plugins.import_plugin(u'form_base')

default_script = u"""
set form_question 'Your question'
set form_title Title
set form_var response
set rows 1;1;6
set cols 1
widget 0 0 1 1 label text=[form_title]
widget 0 1 1 1 label text=[form_question] center=no
widget 0 2 1 1 text_input return_accepts=yes focus=yes var=[form_var] stub=""
"""

class form_text_input(form_base.form_base):

	def __init__(self, name, experiment, string=None):

		"""
		Constructor.

		Arguments:
		name		--	The name of the item.
		experiment	--	The experiment instance.

		Keyword arguments:
		string		--	A definition string. (default=None)
		"""

		if string == None:
			string = default_script
			
		# Due to dynamic loading, we need to implement this super() hack. See
		# <http://thingspython.wordpress.com/2010/09/27/another-super-wrinkle-raising-typeerror/>
		self.super_form_text_input = super(form_text_input, self)		
		self.super_form_text_input.__init__(name, experiment, string, \
			item_type=u'form_text_input', description= \
			u'A simple text input form')

	def from_string(self, script):

		"""
		Re-generates the form from a definition script.

		Arguments:
		script		--	The definition script.
		"""

		self._widgets = []
		self.super_form_text_input.from_string(script)

	def var_info(self):

		"""
		Returns a list of dictionaries with variable descriptions.

		Returns:
		A list of (name, description) tuples.
		"""

		return self.super_form_text_input.var_info() + \
			[(self.get(u'form_var'), u'[Depends on response]')]
		
class qtform_text_input(form_text_input, qtautoplugin):
	
	def __init__(self, name, experiment, script=None):

		form_text_input.__init__(self, name, experiment, script)
		qtautoplugin.__init__(self, __file__)	

########NEW FILE########
__FILENAME__ = form_text_render
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import item, exceptions, generic_response, widgets, plugins
from libqtopensesame import qtplugin
from openexp.canvas import canvas
import openexp.keyboard
import os.path
from PyQt4 import QtGui, QtCore

form_base = plugins.import_plugin('form_base')

default_script = """
set form_text 'Your message'
set rows 1
set cols 1;1;1
set margins 50;100;50;100
set only_render 'yes'
widget 0 0 3 1 label text=[form_text] center=no
"""

class form_text_render(form_base.form_base):

	def __init__(self, name, experiment, string=None):

		"""
		Constructor

		Arguments:
		name -- the name of the item
		experiment -- the experiment instance

		Keyword arguments:
		string -- a definition string
		"""

		if string == None:
			string = default_script
		super(form_text_render, self).__init__(name, experiment, string, \
			item_type='form_text_render', description= \
			'A simple text display form')

	def from_string(self, script):

		"""
		Re-generate the form from a definition script

		Arguments:
		script -- the definition script
		"""

		self._widgets = []
		super(form_text_render, self).from_string(script)

class qtform_text_render(form_text_render, qtplugin.qtplugin):

	"""GUI controls"""

	def __init__(self, name, experiment, string=None):

		"""
		Constructor

		Arguments:
		name -- the name of the item
		experiment -- the experiment instance

		Keyword arguments:
		string -- a definition string
		"""

		form_text_render.__init__(self, name, experiment, string)
		qtplugin.qtplugin.__init__(self, __file__)

	def init_edit_widget(self):

		"""Initialize the controls"""
		
		self.lock = True
		qtplugin.qtplugin.init_edit_widget(self, False)
		self.add_editor_control('form_text', 'Main form text', \
			tooltip='Main form text')
		self.lock = False

	def apply_edit_changes(self):

		"""Apply the controls"""

		if not qtplugin.qtplugin.apply_edit_changes(self, False) or self.lock:
			return False
		return True

	def edit_widget(self):

		"""Update the controls"""

		self.lock = True
		qtplugin.qtplugin.edit_widget(self)
		self.lock = False
		return self._edit_widget
########NEW FILE########
__FILENAME__ = joystick
"""
30-05-2012
Author: Edwin Dalmaijer

This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame. If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import plugins
from libopensesame.exceptions import osexception
from libopensesame import item, generic_response, debug
from libqtopensesame.items.qtautoplugin import qtautoplugin
import openexp.keyboard
import imp
import os
import os.path
from PyQt4 import QtGui, QtCore

class joystick(item.item, generic_response.generic_response):

	"""A plug-in for using a joystick/gamepad"""

	description = u'Collects input from a joystick or gamepad'

	def __init__(self, name, experiment, string=None):

		"""
		Constructor

		Arguments:
		name		--	The item name.
		experiment	--	The OpenSesame experiment.

		Keyword arguments:
		string		--	A definition string. (default=None)
		"""

		self.timeout = u'infinite'
		self.allowed_responses = u''
		self._dummy = u'no'
		self._device = 0
		item.item.__init__(self, name, experiment, string)
		self.process_feedback = True

	def prepare(self):

		"""Prepares the item."""

		# Pass the word on to the parent
		item.item.prepare(self)

		# Prepare the allowed responses
		if self.has(u"allowed_responses"):
			self._allowed_responses = []
			for r in self.unistr(self.get(u"allowed_responses")).split(u";"):
				if r.strip() != "":
					try:
						r = int(r)
					except:
						raise osexception( \
							u"'%s' is not a valid response on your joystick/gamepad. Expecting a number in the range of 1 to the amount of buttons." \
							% (r,self.name))
					if r < 0 or r > 255:
						raise osexception( \
							u"'%s' is not a valid response on your joystick/gamepad. Expecting a number in the range of 1 to the amount of buttons." \
							% (r, self.name))
					self._allowed_responses.append(r)
			if len(self._allowed_responses) == 0:
				self._allowed_responses = None
		else:
			self._allowed_responses = None
		debug.msg(u"allowed responses has been set to %s" % self._allowed_responses)
		# In case of dummy-mode:
		self._keyboard = openexp.keyboard.keyboard(self.experiment)
		if self.has(u"_dummy") and self.get(u"_dummy") == u"yes":
			self._resp_func = self._keyboard.get_key
		# Not in dummy-mode:
		else:
			timeout = self.get(u"timeout")
			# Dynamically load a joystick instance
			if not hasattr(self.experiment, u"joystick"):
				_joystick = plugins.load_mod(__file__, u'libjoystick')
				self.experiment.joystick = _joystick.libjoystick( \
					self.experiment, device=self._device)
			# Prepare auto response
			if self.experiment.auto_response:
				self._resp_func = self.auto_responder
			else:
				self._resp_func = self.experiment.joystick.get_joybutton
		self.prepare_timeout()

	def run(self):

		"""Runs the item."""

		# Set the onset time
		self.set_item_onset()
		# Flush keyboard, so the escape key can be used
		self._keyboard.flush()
		# If no start response interval has been set, set it to the onset of
		# the current response item
		if self.experiment.start_response_interval == None:
			self.experiment.start_response_interval = self.get(u'time_%s' \
				% self.name)
		if self.has(u'_dummy') and self.get(u'_dummy') == u'yes':
			# In dummy mode, no one can hear you scream! Oh, and we simply
			# take input from the keyboard
			resp, self.experiment.end_response_interval = self._resp_func( \
				None, self._timeout)
		else:
			# Get the response
			resp, self.experiment.end_response_interval = self._resp_func( \
				self._allowed_responses, self._timeout)
		debug.msg(u'received %s' % resp)
		self.experiment.response = resp
		generic_response.generic_response.response_bookkeeping(self)

	def var_info(self):

		"""
		Gives a list of dictionaries with variable descriptions.

		Returns:
		A list of (name, description) tuples
		"""

		return item.item.var_info(self) + \
			generic_response.generic_response.var_info(self)

class qtjoystick(joystick, qtautoplugin):

	def __init__(self, name, experiment, script=None):

		# Call parent constructors.
		joystick.__init__(self, name, experiment, script)
		qtautoplugin.__init__(self, __file__)

########NEW FILE########
__FILENAME__ = libjoystick
#-*- coding:utf-8 -*-

"""
This file is part of openexp.

openexp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

openexp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with openexp.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import plugins

def libjoystick(experiment, **kwargs):

	"""
	A factory that returns a back-end specific joystick module.

	Arguments:
	experiment		--	The experiment object.

	Keyword arguments:
	**kwargs		--	A keyword-argument dictionary.
	"""

	if experiment.get(u'canvas_backend') == u'psycho':
		raise osexception(
			u'The joystick plug-in does not yet support the psycho back-end')
	backend = u'legacy'
	cls = plugins.load_cls(__file__, cls=backend, mod=backend,
		pkg=u'_libjoystick')
	return cls(experiment, **kwargs)

########NEW FILE########
__FILENAME__ = basejoystick
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

class basejoystick(object):

	def __init__(self, experiment, device=0, joybuttonlist=None, timeout=None):

		"""<DOC>
		Intializes the joystick object.

		Arguments:
		experiment		--	An instance of libopensesame.experiment.experiment.

		Keyword arguments:
		device			--	The device number of the joystick. (default=0)
		joybuttonlist	--	A list of buttons that are accepted or None to
							accept all buttons. (default=None)
		timeout			--	An integer value specifying a timeout in
							milliseconds or None for no timeout. (default=None)
		</DOC>"""

		raise NotImplementedError()

	def set_joybuttonlist(self, joybuttonlist=None):

		"""<DOC>
		Sets a list of accepted buttons.

		Keyword arguments:
		joybuttonlist	--	A list of button numbers that are accepted or None
							to accept all buttons. (default=None)
		</DOC>"""

		if joybuttonlist == None or joybuttonlist == []:
			self._joybuttonlist = None
		else:
			self._joybuttonlist = []
			for joybutton in joybuttonlist:
				self._joybuttonlist.append(joybutton)

	def set_timeout(self, timeout=None):

		"""<DOC>
		Sets a timeout.

		Keyword arguments:
		timeout		--	An integer value specifying a timeout in milliseconds or
						None for no timeout. (default=None)
		</DOC>"""

		self.timeout = timeout

	def get_joybutton(self, joybuttonlist=None, timeout=None):

		"""<DOC>
		Waits for joystick button input.

		Keyword arguments:
		joybuttonlist	--	A list of button numbers that are accepted or
							None to use the default. This parameter does not
							change the default joybuttonlist. (default = None)
		timeout			--	An integer value specifying a timeout in
							milliseconds or None to use the default. This
							parameter does not change the default timeout.
							(default=None)

		Returns:
		A (joybutton, timestamp) tuple. The joybutton is None if a timeout
		occurs.
		</DOC>"""

		raise NotImplementedError()

	def get_joyaxes(self, timeout=None):

		"""<DOC>
		Waits for joystick axes movement.

		Keyword arguments:
		timeout		--	An integer value specifying a timeout in milliseconds
						or None to use the default. This parameter does not
						change the default timeout. (default=None)

		Returns:
		A (position, timestamp) tuple. The position is None if a timeout occurs.
		</DOC>"""

		raise NotImplementedError()

	def get_joyballs(self, timeout=None):

		"""<DOC>
		Waits for joystick trackball movement.

		Keyword arguments:
		timeout		--	An integer value specifying a timeout in milliseconds
						or None to use the default. This parameter does not
						change the default timeout. (default=None)

		Returns:
		A (position, timestamp) tuple. The position is None if a timeout occurs.
		</DOC>"""

		raise NotImplementedError()

	def get_joyhats(self, timeout=None):

		"""<DOC>
		Waits for joystick hat movement.

		Keyword arguments:
		timeout		--	An integer value specifying a timeout in milliseconds
						or None to use the default. This parameter does not
						change the default timeout. (default=None)

		Returns:
		A (position, timestamp) tuple. The position is None if a timeout occurs.
		</DOC>"""

		raise NotImplementedError()

	def get_joyinput(self, joybuttonlist=None, timeout=None):

		"""<DOC>
		Waits for any joystick input (buttons, axes, hats or balls).

		Keyword arguments:
		joybuttonlist	--	A list of button numbers that are accepted or
							None to use the default. This parameter does not
							change the default joybuttonlist. (default=None)
		timeout			--	An integer value specifying a timeout in
							milliseconds or None to use the default. This
							parameter does not change the default timeout.
							(default=None)

		Returns:
		A (event, value, timestamp) tuple. The value is None if a timeout
		occurs.
		</DOC>"""

		raise NotImplementedError()

	def input_options(self):

		"""<DOC>
		Generates a list with amount of available buttons, axes, balls and hats.

		Returns:
		List with number of inputs as: [buttons, axes, balls, hats]
		</DOC>"""

		raise NotImplementedError()

	def flush(self):

		"""<DOC>
		Clears all pending input, not limited to the joystick.

		Returns:
		True if a joyinput has been made (i.e., if there was something
		to flush) and False otherwise
		</DOC>"""

		raise NotImplementedError()


########NEW FILE########
__FILENAME__ = legacy
#-*- coding:utf-8 -*-

"""
Created on 25-05-2012

Author: Edwin Dalmaijer

This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.

"""

import pygame
from pygame.locals import *
from pygame.joystick import Joystick
from libopensesame.exceptions import osexception
from libopensesame import plugins

basejoystick = plugins.load_cls(__file__, cls=u'basejoystick',
	mod=u'basejoystick')

class legacy(basejoystick):

	def __init__(self, experiment, device=0, joybuttonlist=None, timeout=None):

		"""See _libjoystick.basejoystick"""

		self.js = pygame.joystick.Joystick(device)
		self.js.init()
		self.experiment = experiment
		self.set_joybuttonlist(joybuttonlist)
		self.set_timeout(timeout)

	def get_joybutton(self, joybuttonlist=None, timeout=None):

		"""See _libjoystick.basejoystick"""

		if joybuttonlist == None or joybuttonlist == []:
			joybuttonlist = self._joybuttonlist
		if timeout == None:
			timeout = self.timeout

		start_time = pygame.time.get_ticks()
		time = start_time

		while timeout == None or time - start_time <= timeout:
			time = pygame.time.get_ticks()
			for event in pygame.event.get():
				if event.type == KEYDOWN:
					if event.key == pygame.K_ESCAPE:
						raise osexception(u"The escape key was pressed.")
				if event.type == JOYBUTTONDOWN:
					if joybuttonlist == None or event.button + 1 in \
						joybuttonlist:
						bpress = event.button + 1
						return bpress, time

		return None, time

	def get_joyaxes(self, timeout=None):

		"""See _libjoystick.basejoystick"""

		if timeout == None:
			timeout = self.timeout

		pos = []
		start_time = pygame.time.get_ticks()
		time = start_time

		while timeout == None or time - start_time < timeout:
			time = pygame.time.get_ticks()
			for event in pygame.event.get():
				if event.type == KEYDOWN:
					if event.key == pygame.K_ESCAPE:
						raise osexception(u"The escape key was pressed.")
				if event.type == JOYAXISMOTION:
					for axis in range(self.js.get_numaxes()):
						pos.append(self.js.get_axis(axis))
					return pos, time

		return None, time

	def get_joyballs(self, timeout=None):

		"""See _libjoystick.basejoystick"""

		if timeout == None:
			timeout = self.timeout

		ballpos = []
		start_time = pygame.time.get_ticks()
		time = start_time

		while timeout == None or time - start_time < timeout:
			time = pygame.time.get_ticks()
			for event in pygame.event.get():
				if event.type == KEYDOWN:
					if event.key == pygame.K_ESCAPE:
						raise osexception(u"The escape key was pressed.")
				if event.type == JOYBALLMOTION:
					for ball in range(self.js.get_numballs()):
						ballpos.append(self.js.get_ball(ball))
					return ballpos, time

		return None, time

	def get_joyhats(self, timeout=None):

		"""See _libjoystick.basejoystick"""

		if timeout == None:
			timeout = self.timeout

		hatpos = []
		start_time = pygame.time.get_ticks()
		time = start_time

		while timeout == None or time - start_time < timeout:
			time = pygame.time.get_ticks()
			for event in pygame.event.get():
				if event.type == KEYDOWN:
					if event.key == pygame.K_ESCAPE:
						raise osexception(u"The escape key was pressed.")
				if event.type == JOYHATMOTION:
					for hat in range(self.js.get_numhats()):
						hatpos.append(self.js.get_hat(hat))
					return hatpos, time

		return None, time

	def get_joyinput(self, joybuttonlist=None, timeout=None):

		"""See _libjoystick.basejoystick"""

		if joybuttonlist == None or joybuttonlist == []:
			joybuttonlist = self._joybuttonlist
		if timeout == None:
			timeout = self.timeout

		pos = []
		ballpos = []
		hatpos = []
		eventtype = None
		start_time = pygame.time.get_ticks()
		time = start_time

		while timeout == None or time - start_time <= timeout:
			time = pygame.time.get_ticks()
			for event in pygame.event.get():
				if event.type == KEYDOWN:
					if event.key == pygame.K_ESCAPE:
						raise osexception(u"The escape key was pressed.")
				if event.type == JOYBUTTONDOWN:
					if joybuttonlist == None or event.button + 1 in \
						joybuttonlist:
						eventtype = u'joybuttonpress'
						bpress = event.button + 1
						return eventtype, bpress, time
				if event.type == JOYAXISMOTION:
					eventtype = u'joyaxismotion'
					for axis in range(self.js.get_numaxes()):
						pos.append(self.js.get_axis(axis))
					return eventtype, pos, time
				if event.type == JOYBALLMOTION:
					eventtype = u'joyballmotion'
					for ball in range(self.js.get_numballs()):
						ballpos.append(self.js.get_ball(ball))
					return eventtype, ballpos, time
				if event.type == JOYHATMOTION:
					eventtype = u'joyhatmotion'
					for hat in range(self.js.get_numhats()):
						hatpos.append(self.js.get_hat(hat))
					return eventtype, hatpos, time

		return eventtype, None, time

	def input_options(self):

		"""See _libjoystick.basejoystick"""

		ninputs = [self.js.get_numbuttons(), self.js.get_numaxes(),
			self.js.get_numballs(), self.js.get_numhats()]
		return ninputs

	def flush(self):

		"""See _libjoystick.basejoystick"""

		joyinput = False
		for event in pygame.event.get():
			if event.type == KEYDOWN and event.key == pygame.K_ESCAPE:
				raise osexception(u"The escape key was pressed.")
			if event.type == JOYBUTTONDOWN or event.type == JOYAXISMOTION or \
				event.type == JOYBALLMOTION or event.type == JOYHATMOTION:
				joyinput = True
		return joyinput

########NEW FILE########
__FILENAME__ = notepad
"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.item import item
from libqtopensesame.items.qtautoplugin import qtautoplugin

class notepad(item):

	"""Notepad plug-in"""

	description = \
			u'A simple notepad to document your experiment. This plug-in does nothing.'
					
class qtnotepad(notepad, qtautoplugin):

	"""Notepad plug-in GUI"""

	def __init__(self, name, experiment, script=None):

		notepad.__init__(self, name, experiment, script)
		qtautoplugin.__init__(self, __file__)

########NEW FILE########
__FILENAME__ = parallel
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import os.path
import threading
from libopensesame import sequence, debug
from libqtopensesame.items import sequence as qtsequence
from libqtopensesame.items import qtplugin

class parallel_process(threading.Thread):

	"""A wrapper for a single process"""
	
	def __init__(self, item):
	
		"""
		Constructor
		
		Arguments:
		item -- the item to run
		"""
	
		threading.Thread.__init__(self)
		self.item = item
		self.exception = None
	
	def run(self):	
	
		"""Runs the item"""

		self.launch_time = self.item.time()
		try:
			self.item.run()
		except Exception as e:
			self.exception = e

class parallel(sequence.sequence):

	"""
	The parallel plug-in behaves much like a sequence, but it runs items in
	parallel. The parallel exits when the last item is finished
	"""
	
	def run(self):
	
		"""
		Run the parallel
		
		Returns:
		True on success, False on failure
		"""
			
		# Optionally flush the responses to catch escape presses
		if self._keyboard != None:
			self._keyboard.flush()
			
		# Do nothing if there are no items
		if len(self._items) == 0:
			return
		
		# The first item is the main item, which is not executed in a thread
		item, cond = self._items[0]
		if eval(cond):
			main_item = self.experiment.items[item]
		else:
			main_item = None
						
		# Create a list of threads for the rest of the items
		tl = []	
		if len(self._items) > 1:
			for item, cond in self._items[1:]:		
				if eval(cond):				
					tl.append(parallel_process(self.experiment.items[item]))
										
		# Run all threads
		for t in tl:
			t.start()
			
		# Run the main item
		if main_item != None:
			self.launch_time = self.time()
			main_item.run()
					
		# Wait for the threads to finish
		while True:
			alive = False		
			for t in tl:
				if t.is_alive():
					alive = True
				if t.exception != None:
					raise t.exception
			if alive:
				self.sleep(100)
			else:
				break

		# Debug output to verify timing
		debug.msg('main item was launched at %s' % self.launch_time)
		for t in tl:
			debug.msg('thread was launched at %s' % t.launch_time)
			
		return True	
	
class qtparallel(qtsequence.sequence, qtplugin.qtplugin):

	"""Parallel GUI"""

	def __init__(self, name, experiment, string=None):

		"""
		Constructor

		Arguments:
		name -- the name of the item
		experiment -- an instance of libopensesame.experiment

		Keyword arguments:
		string -- a string with the item definition (default=None)
		"""

		qtsequence.sequence.__init__(self, name, experiment, string)
		self.item_type = 'parallel'
		self.description = "Runs a number of items in parallel"		
		qtplugin.qtplugin.__init__(self, __file__)
		


########NEW FILE########
__FILENAME__ = port_reader
"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import item, generic_response, debug
from libqtopensesame import qtplugin
from PyQt4 import QtGui, QtCore
try:
	from ctypes import windll
except:
	debug.msg("failed to load ctypes.windll mode (only dummy mode will be available)", \
		reason="warning")

class port_reader(item.item, generic_response.generic_response):

	"""A plug-in to collect responses from a port (Window only)"""

	def __init__(self, name, experiment, string=None):
	
		"""
		Constructor
		
		Arguments:
		name -- item name
		experiment -- experiment instance
		
		Keyword arguments:
		string -- definition string (default=None)
		"""
		
		# The item_typeshould match the name of the module
		self.item_type = "port_reader"
		
		# Provide a short accurate description of the items functionality
		self.description = \
			"Collects input from a port for the purpose of response collection"
		
		self.timeout = "infinite"
		self.port = 889
		self.resting_value = 127
		self.auto_response = 255 # 'a'
		self.duration = "portinput"
		self.dummy = "no"
		self.process_feedback = True				
		
		# The parent handles the rest of the contruction
		item.item.__init__(self, name, experiment, string)

	def get_portinput(self):

		"""Read port input"""

		while True:
			val = self._port.Inp32(self.port)
			time = self.time()
			if val != self.resting_value:
				break
			if self._timeout != None and time - self.sri > self._timeout:
				val = "timeout"
				break
		return val, time

	def prepare_duration_portinput(self):

		"""Prepare a portinput duration"""

		if self.experiment.auto_response:
			self._duration_func = self.sleep_for_duration
			self._duration = 500
		else:
			try:
				self._port = windll.inpout32
			except:
				raise osexception( \
					"Failed to load inpout32.dll in port_reader '%s'" \
					% self.name)
			self._duration_func = self.get_portinput

	def process_response_portinput(self, retval):

		"""Process a portinput response"""

		self.experiment.start_response_interval = self.sri			
		self.experiment.response, self.experiment.end_response_interval = retval		
								
	def prepare(self):

		"""
		Prepare the item

		Returns:
		True on success, False on failure
		"""

		if self.dummy == "yes":
			self.duration = "keypress"

		item.item.prepare(self)
		generic_response.generic_response.prepare(self)
		return True

	def run(self):

		"""
		Runs the item

		Returns:
		True on success, False on failure
		"""

		# Record the onset of the current item
		self.set_item_onset()	
		self.set_sri()
		self.process_response()

		# Report success
		return True

	def var_info(self):
		
		"""
		Give a list of dictionaries with variable descriptions

		Returns:
		A list of (name, description) tuples
		"""		

		return item.item.var_info(self) + \
			generic_response.generic_response.var_info(self)
					
class qtport_reader(port_reader, qtplugin.qtplugin):

	"""GUI controls for port_reader plug-in"""

	def __init__(self, name, experiment, string=None):
	
		"""
		Constructor
		
		Arguments:
		name -- item name
		experiment -- experiment instance
		
		Keyword arguments:
		string -- definition string (default=None)
		"""
		
		# Pass the word on to the parents		
		port_reader.__init__(self, name, experiment, string)		
		qtplugin.qtplugin.__init__(self, __file__)	
		
	def init_edit_widget(self):
	
		"""Initialize GUI controls"""
		
		# Lock the widget until we're doing creating it
		self.lock = True
		
		# Pass the word on to the parent		
		qtplugin.qtplugin.init_edit_widget(self, False)
		
		# Create the controls
		# 
		# A number of convenience functions are available which 
		# automatically create controls, which are also automatically
		# updated and applied. If you set the varname to None, the
		# controls will be created, but not automatically updated
		# and applied.
		#
		# qtplugin.add_combobox_control(varname, label, list_of_options)
		# - creates a QComboBox
		# qtplugin.add_line_edit_control(varname, label)
		# - creates a QLineEdit		
		# qtplugin.add_spinbox_control(varname, label, min, max, suffix = suffix, prefix = prefix)
		
		self.add_combobox_control("dummy", \
			"Dummy mode (use keyboard instead)", ["yes", "no"], \
			tooltip="Enable dummy mode for testing purposes")
		self.add_spinbox_control("port", "Port number", 0, 1024, tooltip= \
			"Expecting a valid port number")
		self.add_spinbox_control("resting_value", "Resting state value", 0, \
			255, tooltip= \
			"A value that is read from the port when there is no input")
		self.add_line_edit_control("correct_response", "Correct response", \
			tooltip="Expecting response values (0 .. 255)")
		self.add_line_edit_control("timeout", "Timeout", tooltip= \
			"Expecting a value in milliseconds or 'infinite'", default= \
			"infinite")

		# Add a stretch to the edit_vbox, so that the controls do not
		# stretch to the bottom of the window.
		self.edit_vbox.addStretch()
		
		# Unlock
		self.lock = True		
		
	def apply_edit_changes(self):
	
		"""Apply GUI controls"""
		
		# Abort if the parent reports failure of if the controls are locked
		if not qtplugin.qtplugin.apply_edit_changes(self, False) or self.lock:
			return False
				
		# Refresh the main window, so that changes become visible everywhere
		self.experiment.main_window.refresh(self.name)		
		
		# Report success
		return True

	def edit_widget(self):
	
		"""Update GUI controls"""
		
		# Lock the controls, otherwise a recursive loop might aris
		# in which updating the controls causes the variables to be
		# updated, which causes the controls to be updated, etc...
		self.lock = True
		
		# Let the parent handle everything
		qtplugin.qtplugin.edit_widget(self)				
		
		# Unlock
		self.lock = False
		
		# Return the _edit_widget
		return self._edit_widget

########NEW FILE########
__FILENAME__ = parallelppdev
#!/usr/bin/env python
# parallel port access using the ppdev driver

import sys
import struct
import fcntl
import os

#----
# Generated by h2py 0.1.1 from <linux/ppdev.h>,
# then cleaned up a bit by Michael P. Ashton and then a gain by chris ;-)
# Changes for Python2.2 support (c) September 2004 Alex.Perry@qm.com


def sizeof(type): return struct.calcsize(type)
def _IOC(dir, type, nr, size):  return int((dir << _IOC_DIRSHIFT ) | (type << _IOC_TYPESHIFT ) |\
                                       (nr << _IOC_NRSHIFT ) | (size << _IOC_SIZESHIFT))
def _IO(type, nr):      return _IOC(_IOC_NONE,  type, nr, 0)
def _IOR(type,nr,size): return _IOC(_IOC_READ,  type, nr, sizeof(size))
def _IOW(type,nr,size): return _IOC(_IOC_WRITE, type, nr, sizeof(size))

_IOC_SIZEBITS   = 14
_IOC_SIZEMASK   = (1 << _IOC_SIZEBITS ) - 1
_IOC_NRSHIFT    = 0
_IOC_NRBITS     = 8
_IOC_TYPESHIFT  = _IOC_NRSHIFT + _IOC_NRBITS
_IOC_TYPEBITS   = 8
_IOC_SIZESHIFT  = _IOC_TYPESHIFT + _IOC_TYPEBITS
IOCSIZE_MASK    = _IOC_SIZEMASK << _IOC_SIZESHIFT
IOCSIZE_SHIFT   = _IOC_SIZESHIFT

# Python 2.2 uses a signed int for the ioctl() call, so ...
if ( sys.version_info[0] < 3 ) or ( sys.version_info[1] < 3 ):
 _IOC_WRITE      =  1
 _IOC_READ       = -2
 _IOC_INOUT      = -1
else:
 _IOC_WRITE      =  1
 _IOC_READ       =  2
 _IOC_INOUT      =  3

_IOC_DIRSHIFT   = _IOC_SIZESHIFT + _IOC_SIZEBITS
IOC_INOUT       = _IOC_INOUT << _IOC_DIRSHIFT
IOC_IN          = _IOC_WRITE << _IOC_DIRSHIFT
IOC_OUT         = _IOC_READ << _IOC_DIRSHIFT

_IOC_NONE       = 0
PP_IOCTL        = ord('p')
PPCLAIM         = _IO(PP_IOCTL,  0x8b)
PPCLRIRQ        = _IOR(PP_IOCTL, 0x93, 'i')

PPDATADIR       = _IOW(PP_IOCTL, 0x90, 'i')
PPEXCL          = _IO(PP_IOCTL,  0x8f)
PPFCONTROL      = _IOW(PP_IOCTL, 0x8e, 'BB')
PPGETFLAGS      = _IOR(PP_IOCTL, 0x9a, 'i')
PPGETMODE       = _IOR(PP_IOCTL, 0x98, 'i')
PPGETMODES      = _IOR(PP_IOCTL, 0x97, 'I')
PPGETPHASE      = _IOR(PP_IOCTL, 0x99, 'i')
PPGETTIME       = _IOR(PP_IOCTL, 0x95, 'll')
PPNEGOT         = _IOW(PP_IOCTL, 0x91, 'i')
PPRCONTROL      = _IOR(PP_IOCTL, 0x83, 'B')
PPRDATA         = _IOR(PP_IOCTL, 0x85, 'B')
#'OBSOLETE__IOR' undefined in 'PPRECONTROL'
PPRELEASE       = _IO(PP_IOCTL,  0x8c)
#'OBSOLETE__IOR' undefined in 'PPRFIFO'
PPRSTATUS       = _IOR(PP_IOCTL, 0x81, 'B')
PPSETFLAGS      = _IOW(PP_IOCTL, 0x9b, 'i')
PPSETMODE       = _IOW(PP_IOCTL, 0x80, 'i')
PPSETPHASE      = _IOW(PP_IOCTL, 0x94, 'i')
PPSETTIME       = _IOW(PP_IOCTL, 0x96, 'll')
PPWCONTROL      = _IOW(PP_IOCTL, 0x84, 'B')
PPWCTLONIRQ     = _IOW(PP_IOCTL, 0x92, 'B')
PPWDATA         = _IOW(PP_IOCTL, 0x86, 'B')
#'OBSOLETE__IOW' undefined in 'PPWECONTROL'
#'OBSOLETE__IOW' undefined in 'PPWFIFO'
#'OBSOLETE__IOW' undefined in 'PPWSTATUS'
PPYIELD         = _IO(PP_IOCTL, 0x8d)
PP_FASTREAD     = 1 << 3
PP_FASTWRITE    = 1 << 2
PP_W91284PIC    = 1 << 4
PP_FLAGMASK     = PP_FASTWRITE | PP_FASTREAD | PP_W91284PIC
PP_MAJOR        = 99
_ASMI386_IOCTL_H= None
_IOC_DIRBITS    = 2
_IOC_DIRMASK    = (1 << _IOC_DIRBITS) - 1
_IOC_NRMASK     = (1 << _IOC_NRBITS) - 1
_IOC_TYPEMASK   = (1 << _IOC_TYPEBITS ) - 1

def _IOC_DIR(nr):       return (nr >> _IOC_DIRSHIFT)  & _IOC_DIRMASK
def _IOC_NR(nr):        return (nr >> _IOC_NRSHIFT)   & _IOC_NRMASK
def _IOC_SIZE(nr):      return (nr >> _IOC_SIZESHIFT) & _IOC_SIZEMASK
def _IOC_TYPE(nr):      return (nr >> _IOC_TYPESHIFT) & _IOC_TYPEMASK
def _IOWR(type, nr, size): return _IOC(_IOC_READ | _IOC_WRITE, type, nr , sizeof(size))

__ELF__         = 1
__i386          = 1
__i386__        = 1
__linux         = 1
__linux__       = 1
__unix          = 1
__unix__        = 1
i386            = 1
linux           = 1
unix            = 1

#-------- Constants from <linux/parport.h>

PARPORT_CONTROL_STROBE  = 0x1
PARPORT_CONTROL_AUTOFD  = 0x2
PARPORT_CONTROL_INIT    = 0x4
PARPORT_CONTROL_SELECT  = 0x8
PARPORT_STATUS_ERROR    = 8
PARPORT_STATUS_SELECT   = 0x10
PARPORT_STATUS_PAPEROUT = 0x20
PARPORT_STATUS_ACK      = 0x40
PARPORT_STATUS_BUSY     = 0x80

IEEE1284_MODE_NIBBLE    = 0
IEEE1284_MODE_BYTE      = 1
IEEE1284_MODE_COMPAT    = 1<<8
IEEE1284_MODE_BECP      = 1<<9
IEEE1284_MODE_ECP       = 1<<4
IEEE1284_MODE_ECPRLE    = IEEE1284_MODE_ECP | (1<<5)
IEEE1284_MODE_ECPSWE    = 1<<10
IEEE1284_MODE_EPP       = 1<<6
IEEE1284_MODE_EPPSL     = 1<<11
IEEE1284_MODE_EPPSWE    = 1<<12
IEEE1284_DEVICEID       = 1<<2
IEEE1284_EXT_LINK       = 1<<14

IEEE1284_ADDR           = 1<<13
IEEE1284_DATA           = 0

PARPORT_EPP_FAST        = 1
PARPORT_W91284PIC       = 2
#----

class Parallel:
    """Class for controlling the pins on a parallel port

    This class provides bit-level access to the pins on a PC parallel
    port.  It is primarily designed for programs which must control
    special circuitry - most often non-IEEE-1284-compliant devices
    other than printers - using 'bit-banging' techniques.

    The current implementation makes ioctl() calls to the Linux ppdev
    driver, using the Python fcntl library.  It might be rewritten in
    C for extra speed.  This particular implementation is written for
    Linux; all of the upper-level calls can be ported to Windows as
    well.

    On Linux, the ppdev device driver, from the Linux 2.4 parallel
    port subsystem, is used to control the parallel port hardware.
    This driver must be made available from a kernel compile.  The
    option is called "Support user-space parallel-port drivers".  When
    using the module, be sure to unload the lp module first: usually
    the lp module claims exclusive access to the parallel port, and if
    it is loaded, this class will fail to open the parallel port file,
    and throw an exception.

    The primary source of information about the Linux 2.4 parallel
    port subsystem is Tim Waugh's documentation, the source for which
    is available in the kernel tree.  This document (called,
    appropriately enough, "The Linux 2.4 Parallel Port Subsystem"),
    thoroughly describes the parallel port drivers and how to use
    them.

    This class provides a method for each of the ioctls supported by
    the ppdev module.  The ioctl methods are named, in uppercase, the
    same as the ioctls they invoke.  The documentation for these
    methods was taken directly from the documentation for their
    corresponding ioctl, and modified only where necessary.

    Unless you have special reason to use the Linux ioctls, you should
    use instead the upper-level functions, which are named in
    lowerCase fashion and should be portable between Linux and
    Windows.  This way, any code you write for this class will (or
    should) also work with the Windows version of this class.
    
    """
    def __init__(self, port = 0, exclusive = False):
        if type(port) == type(""):
            self.device = port
        else:
            self.device = "/dev/parport%d" % port
        self._fd = None
        self._fd = os.open(self.device, os.O_RDWR)
        try:
            if exclusive:
                self.PPEXCL()
            self.PPCLAIM()
            self.setDataDir(1)
            self.setData(0)
        except IOError:
            os.close(self._fd)
            self._fd = None
            raise

    def __del__(self):
        if self._fd is not None:
            self.PPRELEASE()
            os.close(self._fd)

    def timevalToFloat(self, timeval):
        t=struct.unpack('ll', timeval)
        return t[0] + (t[1]/1000000.0)

    def floatToTimeval(self, time):
        sec = int(time)
        usec = int(time*1000000.0)
        return struct.pack('ll', sec, usec)

    def PPCLAIM(self):
        """
        Claims access to the port. As a user-land device driver
        writer, you will need to do this before you are able to
        actually change the state of the parallel port in any
        way. Note that some operations only affect the ppdev driver
        and not the port, such as PPSETMODE; they can be performed
        while access to the port is not claimed.
        """
        fcntl.ioctl(self._fd, PPCLAIM)

    def PPEXCL(self):
        """
        Instructs the kernel driver to forbid any sharing of the port
        with other drivers, i.e. it requests exclusivity. The PPEXCL
        command is only valid when the port is not already claimed for
        use, and it may mean that the next PPCLAIM ioctl will fail:
        some other driver may already have registered itself on that
        port.

        Most device drivers don't need exclusive access to the
        port. It's only provided in case it is really needed, for
        example for devices where access to the port is required for
        extensive periods of time (many seconds).

        Note that the PPEXCL ioctl doesn't actually claim the port
        there and then---action is deferred until the PPCLAIM ioctl is
        performed.
        """
        fcntl.ioctl(self._fd, PPEXCL)

    def PPRELEASE(self):
        """
        Releases the port. Releasing the port undoes the effect of
        claiming the port. It allows other device drivers to talk to
        their devices (assuming that there are any).
        """
        fcntl.ioctl(self._fd, PPRELEASE)

    def PPYIELD(self):
        """
        Yields the port to another driver. This ioctl is a kind of
        short-hand for releasing the port and immediately reclaiming
        it. It gives other drivers a chance to talk to their devices,
        but afterwards claims the port back. An example of using this
        would be in a user-land printer driver: once a few characters
        have been written we could give the port to another device
        driver for a while, but if we still have characters to send to
        the printer we would want the port back as soon as possible.

        It is important not to claim the parallel port for too long,
        as other device drivers will have no time to service their
        devices. If your device does not allow for parallel port
        sharing at all, it is better to claim the parallel port
        exclusively (see PPEXCL).
        """
        fcntl.ioctl(self._fd, PPYIELD)

    def PPNEGOT(self, mode):
        """
        Performs IEEE 1284 negotiation into a particular
        mode. Briefly, negotiation is the method by which the host and
        the peripheral decide on a protocol to use when transferring
        data.

        An IEEE 1284 compliant device will start out in compatibility
        mode, and then the host can negotiate to another mode (such as
        ECP).

        The 'mode' parameter should be one of the following constants
        from PPDEV:

        - IEEE1284_MODE_COMPAT
        - IEEE1284_MODE_NIBBLE
        - IEEE1284_MODE_BYTE
        - IEEE1284_MODE_EPP
        - IEEE1284_MODE_ECP

        The PPNEGOT ioctl actually does two things: it performs the
        on-the-wire negotiation, and it sets the behaviour of
        subsequent read/write calls so that they use that mode (but
        see PPSETMODE).
        """
        fcntl.ioctl(self._fd, PPNEGOT, struct.pack('i', mode))

    def PPSETMODE(self, mode):
        """
        Sets which IEEE 1284 protocol to use for the read and write
        calls.

        The 'mode' parameter should be one of the following constants
        from PPDEV:

        - IEEE1284_MODE_COMPAT
        - IEEE1284_MODE_NIBBLE
        - IEEE1284_MODE_BYTE
        - IEEE1284_MODE_EPP
        - IEEE1284_MODE_ECP
        """
        fcntl.ioctl(self._fd, PPSETMODE, struct.pack('i', mode))

    def PPGETMODE(self):
        """
        Retrieves the IEEE 1284 mode being used for read and
        write.  The return value is one of the following constants
        from PPDEV:

        - IEEE1284_MODE_COMPAT
        - IEEE1284_MODE_NIBBLE
        - IEEE1284_MODE_BYTE
        - IEEE1284_MODE_EPP
        - IEEE1284_MODE_ECP
        """
        ret = struct.pack('i', 0)
        ret = fcntl.ioctl(self._fd, PPGETMODE, ret)
        return struct.unpack('i', ret)[0]

    def PPGETTIME(self):
        """
        Retrieves the time-out value. The read and write calls will
        time out if the peripheral doesn't respond quickly enough. The
        PPGETTIME ioctl retrieves the length of time that the
        peripheral is allowed to have before giving up.

        Returns the timeout value in seconds as a floating-point value.
        """
        ret = struct.pack('ll', 0, 0)
        ret = fcntl.ioctl(self._fd, PPGETTIME, ret)
        return timevalToFloat(ret)

    def PPSETTIME(self, time):
        """
        Sets the time-out (see PPGETTIME for more information).
        'time' is the new time-out in seconds; floating-point values
        are acceptable.
        """
        fcntl.ioctl(self._fd, PPSETTIME, floatToTimeval(time))

    def PPGETMODES(self):
        """
        Retrieves the capabilities of the hardware (i.e. the modes
        field of the parport structure).
        """
        raise NotImplementedError

    def PPSETFLAGS(self):
        """
        Sets flags on the ppdev device which can affect future I/O
        operations. Available flags are:

        - PP_FASTWRITE
        - PP_FASTREAD
        - PP_W91284PIC
        """
        raise NotImplementedError

    def PPWCONTROL(self, lines):
        """
        Sets the control lines.  The 'lines' parameter is a bitwise OR
        of the following constants from PPDEV:

        - PARPORT_CONTROL_STROBE
        - PARPORT_CONTROL_AUTOFD
        - PARPORT_CONTROL_INIT
        - PARPORT_CONTROL_SELECT
        """
        fcntl.ioctl(self._fd, PPWCONTROL, struct.pack('B', lines))

    def PPRCONTROL(self):
        """
        Returns the last value written to the control register, in the
        form of an integer, for which each bit corresponds to a control
        line (although some are unused).

        This doesn't actually touch the hardware; the last value
        written is remembered in software. This is because some
        parallel port hardware does not offer read access to the
        control register.

        The control lines bits are defined by the following constants
        from PPDEV:

        - PARPORT_CONTROL_STROBE
        - PARPORT_CONTROL_AUTOFD
        - PARPORT_CONTROL_SELECT
        - PARPORT_CONTROL_INIT
        """
        ret = struct.pack('B',0)
        ret = fcntl.ioctl(self._fd, PPRCONTROL, ret)
        return struct.unpack('B', ret)[0]

    def PPFCONTROL(self, mask, val):
        """
        Frobs the control lines. Since a common operation is to change
        one of the control signals while leaving the others alone, it
        would be quite inefficient for the user-land driver to have to
        use PPRCONTROL, make the change, and then use PPWCONTROL. Of
        course, each driver could remember what state the control
        lines are supposed to be in (they are never changed by
        anything else), but in order to provide PPRCONTROL, ppdev must
        remember the state of the control lines anyway.

        The PPFCONTROL ioctl is for "frobbing" control lines, and is
        like PPWCONTROL but acts on a restricted set of control
        lines. The ioctl parameter is a pointer to a struct
        ppdev_frob_struct:
        
        struct ppdev_frob_struct {
            unsigned char mask;
            unsigned char val;
        };

        The mask and val fields are bitwise ORs of control line names
        (such as in PPWCONTROL). The operation performed by PPFCONTROL
        is:

        new_ctr = (old_ctr & ~mask) | val

        In other words, the signals named in mask are set to the
        values in val.
        """
        fcntl.ioctl(self._fd, PPFCONTROL, struct.pack('BB', mask, val))

    def PPRSTATUS(self):
        """
        Returns an unsigned char containing bits set for each status
        line that is set (for instance, PARPORT_STATUS_BUSY). The
        ioctl parameter should be a pointer to an unsigned char.
        """
        ret = struct.pack('B',0)
        ret = fcntl.ioctl(self._fd, PPRSTATUS, ret)
        return struct.unpack('B', ret)[0]

    def PPDATADIR(self, out):
        """
        Controls the data line drivers. Normally the computer's
        parallel port will drive the data lines, but for byte-wide
        transfers from the peripheral to the host it is useful to turn
        off those drivers and let the peripheral drive the
        signals. (If the drivers on the computer's parallel port are
        left on when this happens, the port might be damaged.)
        This is only needed in conjunction with PPWDATA or PPRDATA.

        The 'out' parameter indicates the desired port direction.  If
        'out' is true or non-zero, the drivers are turned on (forward
        direction); otherwise, the drivers are turned off (reverse
        direction).
        """
        if out:
            msg=struct.pack('i',0)
        else:
            msg=struct.pack('i',1)
        fcntl.ioctl(self._fd, PPDATADIR, msg)

    def PPWDATA(self, byte):
        """
        Sets the data lines (if in forward mode). The ioctl parameter
        is a pointer to an unsigned char.
        """
        fcntl.ioctl(self._fd, PPWDATA,struct.pack('B',byte))

    def PPRDATA(self):
        """
        Reads the data lines (if in reverse mode). The ioctl parameter
        is a pointer to an unsigned char.
        """
        ret=struct.pack('B',0)
        ret=fcntl.ioctl(self._fd, PPRDATA,ret)
        return struct.unpack('B',ret)[0]

    def PPCLRIRQ(self):
        """
        Returns the current interrupt count, and clears it.  The ppdev
        driver keeps a count of interrupts as they are triggered.
        """
        ret=struct.pack('i',0)
        ret=fcntl.ioctl(self._fd, PPCLRIRQ,ret)
        return struct.unpack('i',ret)[0]

    def PPWCTLONIRQ(self, lines):
        """
        Set a trigger response. Afterwards when an interrupt is
        triggered, the interrupt handler will set the control lines as
        requested. The ioctl parameter is a pointer to an unsigned
        char, which is interpreted in the same way as for PPWCONTROL.

        The reason for this ioctl is simply speed. Without this ioctl,
        responding to an interrupt would start in the interrupt
        handler, switch context to the user-land driver via poll or
        select, and then switch context back to the kernel in order to
        handle PPWCONTROL. Doing the whole lot in the interrupt
        handler is a lot faster.
        """
        fcntl.ioctl(self._fd, PPWCTLONIRQ,struct.pack('B',lines))

    #data lines
##    def data(self):
##        """Returns the states of the data bus line drivers (pins 2-9)"""
##        return self._data

    def setDataDir(self,out):
        """Activates or deactivates the data bus line drivers (pins 2-9)"""
        self._dataDir = out
        self.PPDATADIR(out)

    def dataDir(self):
        """Returns true if the data bus line drivers are on (pins 2-9)"""
        return self._dataDir

    #control lines
##    def strobe(self):
##        """Returns the state of the nStrobe output (pin 1)"""
##        return (self.PPRCONTROL()&PARPORT_CONTROL_STROBE)==0

    def setDataStrobe(self, level):
        """Sets the state of the nStrobe output (pin 1)"""
        if level:
            self.PPFCONTROL(PARPORT_CONTROL_STROBE, 0)
        else:
            self.PPFCONTROL(PARPORT_CONTROL_STROBE, PARPORT_CONTROL_STROBE)

##    def autoFd(self):
##        """Returns the state of the nAutoFd output (pin 14)"""
##        return (self.PPRCONTROL()&PARPORT_CONTROL_AUTOFD)==0

    def setAutoFeed(self, level):
        """Sets the state of the nAutoFd output (pin 14)"""
        if level:
            self.PPFCONTROL(PARPORT_CONTROL_AUTOFD, 0)
        else:
            self.PPFCONTROL(PARPORT_CONTROL_AUTOFD, PARPORT_CONTROL_AUTOFD)

##    def init(self):
##        """Returns the state of the nInit output (pin 16)"""
##        return (self.PPRCONTROL()&PARPORT_CONTROL_INIT)!=0

    def setInitOut(self, level):
        """Sets the state of the nInit output (pin 16)"""
        if level:
            self.PPFCONTROL(PARPORT_CONTROL_INIT, PARPORT_CONTROL_INIT)
        else:
            self.PPFCONTROL(PARPORT_CONTROL_INIT, 0)

##    def selectIn(self):
##        """Returns the state of the nSelectIn output (pin 17)"""
##        return (self.PPRCONTROL()&PARPORT_CONTROL_SELECT)==0

    def setSelect(self,level):
        """Sets the state of the nSelectIn output (pin 17)"""
        if level:
            self.PPFCONTROL(PARPORT_CONTROL_SELECT, 0)
        else:
            self.PPFCONTROL(PARPORT_CONTROL_SELECT, PARPORT_CONTROL_SELECT)

    def setData(self,d):
        """Sets the states of the data bus line drivers (pins 2-9)"""
        self._data=d
        return self.PPWDATA(d)
    
    def getData(self):
        """Gets the states of the data bus line (pin 2-9)"""
        return self.PPRDATA()

    # status lines
    def getInError(self):
        """Returns the level on the nFault pin (15)"""
        return (self.PPRSTATUS() & PARPORT_STATUS_ERROR) != 0

    def getInSelected(self):
        """Returns the level on the Select pin (13)"""
        return (self.PPRSTATUS() & PARPORT_STATUS_SELECT) != 0

    def getInPaperOut(self):
        """Returns the level on the paperOut pin (12)"""
        return (self.PPRSTATUS() & PARPORT_STATUS_PAPEROUT) != 0

    def getInAcknowledge(self):
        """Returns the level on the nAck pin (10)"""
        return (self.PPRSTATUS() & PARPORT_STATUS_ACK) != 0

    def getInBusy(self):
        """Returns the level on the Busy pin (11)"""
        return (self.PPRSTATUS() & PARPORT_STATUS_BUSY) == 0


########NEW FILE########
__FILENAME__ = pp_io
"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame import item
from libqtopensesame import qtplugin

from PyQt4 import QtGui, QtCore

import warnings
import os

import imp

try:
	if os.name == 'posix':
		# import the local modified version of pyparallel
		# that allows for non-exclusive connections to the parport
		path_to_file = os.path.join(os.path.dirname(__file__), "parallelppdev.py")
		parallel = imp.load_source('parallel', path_to_file)
		#import parallelppdev as parallel
	else:
		import parallel
except ImportError:
	warnings.warn("The parallel module could not load, please make sure you have installed pyparallel.")

# we only want one instance of pp, so here's a global var
_pp = None

class pp_io(item.item):

	"""
	This class (the class with the same name as the module)
	handles the basic functionality of the item. It does
	not deal with GUI stuff.
	"""

	def __init__(self, name, experiment, string = None):

		"""
		Constructor
		"""

		# The item_typeshould match the name of the module
		self.item_type = "pp_io"

		# Provide a short accurate description of the item's functionality
		self.description = "Allows setting pins on the parallel port"

		# Set some item-specific variables
		self.value = 1
		self.duration = 1

		# The parent handles the rest of the contruction
		item.item.__init__(self, name, experiment, string)

		# add cleanup code
		self.experiment.cleanup_functions.append(self.clean_up_the_mess)

	def clean_up_the_mess(self):
		global _pp
		if self.experiment.debug:
			print("pp_io.clean_up_this_mess(): deleting _pp")
		if not _pp is None:
			del _pp

	def prepare(self):

		"""
		Prepare the item. In this case this means doing little.
		"""

		# Pass the word on to the parent
		item.item.prepare(self)

		# get the global pp instance and initialize it if
		# necessary
		global _pp
		if _pp is None:
			try:
				_pp = parallel.Parallel()
			except OSError:
				warnings.warn("Could not access /dev/parport0.")
		self.pp = _pp

		# This function prepares a self._duration_func() function based
		# on the compensation and duration variables.
		self.prepare_duration()

		# Report success
		return True

	def run(self):

		"""
		Run the item. In this case this means putting the offline canvas
		to the display and waiting for the specified duration.
		"""

		# Set the pp value
		if not self.pp is None:
			self.set_item_onset(self.pp.setData(self.value))

		# This function has been prepared by self.prepare_duration()
		self._duration_func()

		# unless duration was zero, turn it off
		if not self.pp is None and self.duration !=0:
			self.pp.setData(0)

		# Report success
		return True

class qtpp_io(pp_io, qtplugin.qtplugin):

	"""
	This class (the class named qt[name of module] handles
	the GUI part of the plugin. For more information about
	GUI programming using PyQt4, see:
	<http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/classes.html>
	"""

	def __init__(self, name, experiment, string = None):

		"""
		Constructor
		"""

		# Pass the word on to the parents
		pp_io.__init__(self, name, experiment, string)
		qtplugin.qtplugin.__init__(self, __file__)

	def init_edit_widget(self):

		"""
		This function creates the controls for the edit
		widget.
		"""

		# Lock the widget until we're doing creating it
		self.lock = True

		# Pass the word on to the parent
		qtplugin.qtplugin.init_edit_widget(self, False)

		# Create the controls
		#
		# A number of convenience functions are available which
		# automatically create controls, which are also automatically
		# updated and applied. If you set the varname to None, the
		# controls will be created, but not automatically updated
		# and applied.
		#
		# qtplugin.add_combobox_control(varname, label, list_of_options)
		# - creates a QComboBox
		# qtplugin.add_line_edit_control(varname, label)
		# - creates a QLineEdit
		# qtplugin.add_spinbox_control(varname, label, min, max, suffix = suffix, prefix = prefix)

		self.add_spinbox_control("value", "Value", 0, 255, tooltip = "Value to set port")
		self.add_line_edit_control("duration", "Duration", tooltip = "Expecting a value in milliseconds, 'keypress' or 'mouseclick'")

		# Add a stretch to the edit_vbox, so that the controls do not
		# stretch to the bottom of the window.
		self.edit_vbox.addStretch()

		# Unlock
		self.lock = True

	def apply_edit_changes(self):

		"""
		Set the variables based on the controls
		"""

		# Abort if the parent reports failure of if the controls are locked
		if not qtplugin.qtplugin.apply_edit_changes(self, False) or self.lock:
			return False

		# Refresh the main window, so that changes become visible everywhere
		self.experiment.main_window.refresh(self.name)

		# Report success
		return True

	def edit_widget(self):

		"""
		Set the controls based on the variables
		"""

		# Lock the controls, otherwise a recursive loop might aris
		# in which updating the controls causes the variables to be
		# updated, which causes the controls to be updated, etc...
		self.lock = True

		# Let the parent handle everything
		qtplugin.qtplugin.edit_widget(self)

		# Unlock
		self.lock = False

		# Return the _edit_widget
		return self._edit_widget

########NEW FILE########
__FILENAME__ = repeat_cycle
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

# Optional: Indicate contact and license information
__author__ = 'Sebastiaan Mathot'
__license__ = 'GPLv3'

# Import the base class from which all items are derived
from libopensesame import item

# Import the base class for the plug-in GUI
from libqtopensesame import qtplugin

class repeat_cycle(item.item):

	"""		
	This class (the class with the same name as the module) handles the basic
	runtime functionality of the item. The GUI controls are handled by the
	class qt_[plugin_name], which is defined later on in the same script.		
	"""

	def __init__(self, name, experiment, string=None):
	
		"""
		Constructor. The constructor is automatically called with the proper
		name, a reference to the experiment, etc.
		
		Arguments:
		name -- the name of the item
		experiment -- an experiment instance, as described here:
					  http://osdoc.cogsci.nl/python-inline-code/experiment-functions
		
		Keyword arguments:
		string -- a definition string, which contains the OpenSesame script
				  which is used to construct the plug-in. This is handled
				  automatically (default=None)
		"""
		
		# The item_typeshould match the name of the module
		self.item_type = "repeat_cycle"
		
		# Provide a short accurate description of the items functionality
		self.description = "Optionally repeat a cycle from a loop"		
		
		# Initialize variables
		self.condition = 'never'
		
		# The parent handles the rest of the contruction
		item.item.__init__(self, name, experiment, string)
						
	def prepare(self):
	
		"""Prepare the item"""
		
		item.item.prepare(self)		
		self._condition = self.compile_cond(self.condition)
		return True
				
	def run(self):
	
		"""Run the item"""
		
		if eval(self._condition):
			self.experiment.set('repeat_cycle', 1)
		return True
					
class qtrepeat_cycle(repeat_cycle, qtplugin.qtplugin):

	"""
	This class (the class named qt[name of module] handles the GUI part of the
	plugin. There are a number of convenience functions to construct controls.	
	For more information about GUI programming using PyQt4, see:
	<http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/classes.html>
	"""

	def __init__(self, name, experiment, string=None):
	
		"""
		Constructor. The constructor is automatically called with the proper
		name, a reference to the experiment, etc.
		
		Arguments:
		name -- the name of the item
		experiment -- an experiment instance
		
		Keyword arguments:
		string -- a definition string (default=None)
		"""
		
		# Pass the word on to the parents		
		repeat_cycle.__init__(self, name, experiment, string)		
		qtplugin.qtplugin.__init__(self, __file__)	
		
	def init_edit_widget(self):
	
		"""Set up the GUI controls for the plugin"""
		
		self.lock = True
		qtplugin.qtplugin.init_edit_widget(self, False)		
		self.add_line_edit_control("condition", "Repeat if", tooltip= \
			"Conditional statement to specify when a cycle should be repeated")			
		self.add_stretch()
		self.lock = True
		
	def apply_edit_changes(self):
	
		"""
		Apply the controls (controls -> variables). Unless you have used custom
		controls, you will not need to modify this function.		
		"""
		
		# Abort if the parent reports failure of if the controls are locked
		if not qtplugin.qtplugin.apply_edit_changes(self, False) or self.lock:
			return False
				
		# Refresh the main window, so that changes become visible everywhere
		self.experiment.main_window.refresh(self.name)		
		
		# Report success
		return True

	def edit_widget(self):
	
		"""
		Update the controls (variables -> controls). Unless you have used custom
		controls, you will not need to modify this function.		
		"""
		
		# Lock the controls, otherwise a recursive loop might arise
		# in which updating the controls causes the variables to be
		# updated, which causes the controls to be updated, etc...
		self.lock = True
		
		# Let the parent handle everything
		qtplugin.qtplugin.edit_widget(self)				
		
		# Unlock
		self.lock = False
		
		# Return the _edit_widget
		return self._edit_widget

########NEW FILE########
__FILENAME__ = reset_feedback
"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.item import item
from libqtopensesame.items.qtautoplugin import qtautoplugin
from PyQt4 import QtGui, QtCore

class reset_feedback(item):

	"""A very simple plug-in to reset feedback variables"""

	description = \
		u'Resets the feedback variables, such as \'avg_rt\' and \'acc\''

	def run(self):

		"""Resets the feedback variables."""

		self.experiment.reset_feedback()

class qtreset_feedback(reset_feedback, qtautoplugin):

	def __init__(self, name, experiment, script=None):

		reset_feedback.__init__(self, name, experiment, script)
		qtautoplugin.__init__(self, __file__)

########NEW FILE########
__FILENAME__ = libsrbox
"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import debug
import serial
import os

class libsrbox:

	# The PST sr box only supports five buttons, but some of the VU boxes use
	# higher button numbers
	BUTTON1 = int('11111110', 2)
	BUTTON2 = int('11111101', 2)
	BUTTON3 = int('11111011', 2)
	BUTTON4 = int('11110111', 2)
	BUTTON5 = int('11101111', 2)
	BUTTON6 = int('11011111', 2)
	BUTTON7 = int('10111111', 2)
	BUTTON8 = int('01111111', 2)

	def __init__(self, experiment, dev=None):

		"""<DOC>
		Constructor. Connects to the SR Box.

		Arguments:
		experiment -- Opensesame experiment.

		Keywords arguments:
		dev -- The srbox device port or None for auto-detect (default=None).
		</DOC>"""

		self.experiment = experiment
		self._srbox = None

		# If a device has been specified, use it
		if dev not in (None, "", "autodetect"):
			try:
				self._srbox = serial.Serial(dev, timeout=0, baudrate=19200)
			except Exception as e:
				raise osexception( \
					"Failed to open device port '%s' in libsrbox: '%s'" \
					% (dev, e))

		else:
			# Else determine the common name of the serial devices on the
			# platform and find the first accessible device. On Windows,
			# devices are labeled COM[X], on Linux there are labeled /dev/tty[X]
			if os.name == "nt":
				for i in range(255):
					try:
						dev = "COM%d" % i
						self._srbox = serial.Serial(dev, timeout=0, \
							baudrate=19200)
						break
					except Exception as e:
						self._srbox = None
						pass

			elif os.name == "posix":
				for path in os.listdir("/dev"):
					if path[:3] == "tty":
						try:
							dev = "/dev/%s" % path
							self._srbox = serial.Serial(dev, timeout=0, \
								baudrate=19200)
							break
						except Exception as e:
							self._srbox = None
							pass
			else:
				raise osexception( \
					"libsrbox does not know how to auto-detect the SR Box on your platform. Please specify a device.")

		if self._srbox == None:
			raise osexception( \
				"libsrbox failed to auto-detect an SR Box. Please specify a device.")
		debug.msg("using device %s" % dev)
		# Turn off all lights
		if self._srbox != None:
			self._srbox.write('\x64')

	def send(self, ch):

		"""<DOC>
		Sends a single character.

		Arguments:
		ch -- The character to send.
		</DOC>"""

		self._srbox.write(ch)

	def start(self):

		"""<DOC>
		Turns on sending mode, to start giving output.

		Example:
		>>> exp.srbox.start()
		>>> timestamp, buttonlist = exp.srbox.get_button_press(allowed_buttons=[1,2])
		>>> if 1 in buttonlist:
		>>> 		print('Button 1 was pressed!')
		>>> exp.srbox.stop()
		</DOC>"""

		# Write the start byte
		self._srbox.flushOutput()
		self._srbox.flushInput()
		self._srbox.write('\xA0')

	def stop(self):

		"""<DOC>
		Turns off sending mode, to stop giving output.

		Example:
		>>> exp.srbox.start()
		>>> timestamp, buttonlist = exp.srbox.get_button_press(allowed_buttons=[1,2])
		>>> if 1 in buttonlist:
		>>> 		print('Button 1 was pressed!')
		>>> exp.srbox.stop()
		</DOC>"""

		# Write the stop byte and flush the input
		self._srbox.flushOutput()
		self._srbox.flushInput()
		self._srbox.write('\x20')

	def get_button_press(self, allowed_buttons=None, timeout=None):

		"""<DOC>
		Gets a button press from the SR box.

		Keywords arguments:
		allowed_buttons -- A list of buttons that are accepted or None to accept #
						   all buttons. Valid buttons are integers 1 through 8. #
						   (default=None)
		timeout -- A timeout value or None for no timeout. (default=None)

		Returns:
		A timestamp, buttonlist tuple. The buttonlist consists of a list of #
		button numbers.

		Example:
		>>> exp.srbox.start()
		>>> timestamp, buttonlist = exp.srbox.get_button_press(allowed_buttons=[1,2])
		>>> if 1 in buttonlist:
		>>> 		print('Button 1 was pressed!')
		>>> exp.srbox.stop()
		</DOC>"""

		c = self.experiment.time()
		t = c
		while timeout == None or t - c < timeout:

			j = self._srbox.read(1)
			t = self.experiment.time()
			if j != "" and j != '\x00':
				k = ord(j)

				if k != 0:
					l = []
					if k | self.BUTTON1 == 255 and (allowed_buttons == None or \
						1 in allowed_buttons):
						l.append(1)
					if k | self.BUTTON2 == 255 and (allowed_buttons == None or \
						2 in allowed_buttons):
						l.append(2)
					if k | self.BUTTON3 == 255 and (allowed_buttons == None or \
						3 in allowed_buttons):
						l.append(3)
					if k | self.BUTTON4 == 255 and (allowed_buttons == None or \
						4 in allowed_buttons):
						l.append(4)
					if k | self.BUTTON5 == 255 and (allowed_buttons == None or \
						5 in allowed_buttons):
						l.append(5)
					if k | self.BUTTON6 == 255 and (allowed_buttons == None or \
						6 in allowed_buttons):
						l.append(6)
					if k | self.BUTTON7 == 255 and (allowed_buttons == None or \
						7 in allowed_buttons):
						l.append(7)
					if k | self.BUTTON8 == 255 and (allowed_buttons == None or \
						8 in allowed_buttons):
						l.append(8)
					if l != []:
						return l, t
		return None, t

	def close(self):

		"""<DOC> TODO
		Closes the connection to the srbox. This is (sometimes?) required in #
		order to re-use the SR Box in the same session of OpenSesame.
		</DOC>"""

		self._srbox.close()

########NEW FILE########
__FILENAME__ = srbox
"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import item, generic_response, debug
from libqtopensesame import qtplugin
import openexp.keyboard
import imp
import os
import os.path
from PyQt4 import QtGui, QtCore

class srbox(item.item, generic_response.generic_response):

	"""A plug-in for using the serial response box"""

	def __init__(self, name, experiment, string=None):

		"""
		Constructor

		Arguments:
		name -- item name
		experiment -- opensesame experiment

		Keywords arguments:
		string -- definition string (default=None)
		"""

		# The item_typeshould match the name of the module
		self.item_type = "srbox"

		# Provide a short accurate description of the items functionality
		self.description = \
			"Collects input from a serial response box (Psychology Software Tools) or compatible devices"

		# Set some item-specific variables
		self.timeout = "infinite"
		self.lights = ""
		self.dev = "autodetect"
		self._dummy = "no"
		self.process_feedback = True

		# The parent handles the rest of the contruction
		item.item.__init__(self, name, experiment, string)

	def prepare(self):

		"""
		Prepare the item

		Returns:
		True on success, False on failure
		"""

		# Pass the word on to the parent
		item.item.prepare(self)

		# Prepare the allowed responses
		if self.has("allowed_responses"):
			self._allowed_responses = []
			for r in self.unistr(self.get("allowed_responses")).split(";"):
				if r.strip() != "":
					try:
						r = int(r)
					except:
						raise osexception( \
							"'%s' is not a valid response in srbox '%s'. Expecting a number in the range 0 .. 5." \
							% (r, self.name))
					if r < 0 or r > 255:
						raise osexception( \
							"'%s' is not a valid response in srbox '%s'. Expecting a number in the range 0 .. 5." \
							% (r, self.name))
					self._allowed_responses.append(r)
			if len(self._allowed_responses) == 0:
				self._allowed_responses = None
		else:
			self._allowed_responses = None

		debug.msg("allowed responses set to %s" % self._allowed_responses)

		self._keyboard = openexp.keyboard.keyboard(self.experiment)
		if self.get('_dummy') == 'yes':
			self._resp_func = self._keyboard.get_key

		else:

			# Prepare the device string
			dev = self.get("dev")
			if dev == "autodetect":
				dev = None

			# Dynamically load an srbox instance
			if not hasattr(self.experiment, "srbox"):
				path = os.path.join(os.path.dirname(__file__), "libsrbox.py")
				_srbox = imp.load_source("libsrbox", path)
				self.experiment.srbox = _srbox.libsrbox(self.experiment, dev)
				self.experiment.cleanup_functions.append(self.close)

			# Prepare the light byte
			s = "010" # Control string
			for i in range(5):
				if unicode(5 - i) in unicode(self.get("lights")):
					s += "1"
				else:
					s += "0"
			self._lights = chr(int(s, 2))
			debug.msg("lights string set to %s (%s)" % (s, self.get("lights")))

			# Prepare auto response
			if self.experiment.auto_response:
				self._resp_func = self.auto_responder
			else:
				self._resp_func = self.experiment.srbox.get_button_press

		self.prepare_timeout()

		# Report success
		return True

	def run(self):

		"""
		Run the item

		Returns:
		True on success, False on failure
		"""

		# Set the onset time
		self.set_item_onset()

		# Flush the keyboard so we can use the escape key
		self._keyboard.flush()

		# If no start response interval has been set, set it to the onset of
		# the current response item
		if self.experiment.start_response_interval == None:
			self.experiment.start_response_interval = self.get("time_%s" \
				% self.name)

		if self.get('_dummy') == 'yes':

			# In dummy mode, we simply take the numeric keys from the keyboard
			resp, self.experiment.end_response_interval = self._resp_func( \
				None, self._timeout)
			try:
				resp = self._keyboard.to_chr(resp)
				if resp not in ('timeout', None):
					resp = int(resp)
			except:
				raise osexception( \
					"An error occured in srbox '%s': Only number keys are accepted in dummy mode" \
					% self.name)

		else:
			# Get the response
			try:
				self.experiment.srbox.send(self._lights)
				self.experiment.srbox.start()
				resp, self.experiment.end_response_interval = \
					self._resp_func(self._allowed_responses, self._timeout)
				self.experiment.srbox.stop()
			except Exception as e:
				raise osexception( \
					"An error occured in srbox '%s': %s." % (self.name, e))

		debug.msg("received %s" % resp)
		if type(resp) == list:
			self.experiment.response = resp[0]
		else:
			self.experiment.response = resp

		generic_response.generic_response.response_bookkeeping(self)

		# Report success
		return True

	def close(self):

		"""Neatly close the connection to the srbox"""

		if not hasattr(self.experiment, "srbox") or \
			self.experiment.srbox == None:
				debug.msg("no active srbox")
				return
		try:
			self.experiment.srbox.close()
			debug.msg("srbox closed")
		except:
			debug.msg("failed to close srbox")

	def var_info(self):
		
		"""
		Give a list of dictionaries with variable descriptions

		Returns:
		A list of (name, description) tuples
		"""		

		return item.item.var_info(self) + \
			generic_response.generic_response.var_info(self)

class qtsrbox(srbox, qtplugin.qtplugin):

	"""
	This class (the class named qt[name of module] handles
	the GUI part of the plugin. For more information about
	GUI programming using PyQt4, see:
	<http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/classes.html>
	"""

	def __init__(self, name, experiment, string = None):

		"""
		Constructor
		"""

		# Pass the word on to the parents
		srbox.__init__(self, name, experiment, string)
		qtplugin.qtplugin.__init__(self, __file__)

	def init_edit_widget(self):

		"""
		This function creates the controls for the edit
		widget.
		"""

		global version

		# Lock the widget until we're doing creating it
		self.lock = True

		# Pass the word on to the parent
		qtplugin.qtplugin.init_edit_widget(self, False)

		# Create the controls
		#
		# A number of convenience functions are available which
		# automatically create controls, which are also automatically
		# updated and applied. If you set the varname to None, the
		# controls will be created, but not automatically updated
		# and applied.
		#
		# qtplugin.add_combobox_control(varname, label, list_of_options)
		# - creates a QComboBox
		# qtplugin.add_line_edit_control(varname, label)
		# - creates a QLineEdit
		# qtplugin.add_spinbox_control(varname, label, min, max, suffix = suffix, prefix = prefix)

		self.add_combobox_control("_dummy", \
			"Dummy mode (use keyboard instead)", ["no", "yes"])
		self.add_line_edit_control("dev", "Device name", tooltip= \
			"Expecting a valid device name. Leave empty for autodetect.", \
			default="autodetect")
		self.add_line_edit_control("correct_response", "Correct response", \
			tooltip="Expecting a button number (1 .. 5)")
		self.add_line_edit_control("allowed_responses", "Allowed responses", \
			tooltip="Expecting a semicolon-separated list of button numbers, e.g., 1;3;4")
		self.add_line_edit_control("timeout", "Timeout", \
			tooltip="Expecting a value in milliseconds or 'infinite'", default \
			="infinite")
		self.add_line_edit_control("lights", "Turn on lights", tooltip= \
			"Expecting a semicolon-separated list of light numbers, e.g., 1;3;4")

		# Add a stretch to the edit_vbox, so that the controls do not
		# stretch to the bottom of the window.
		self.edit_vbox.addStretch()

		# Unlock
		self.lock = True

	def apply_edit_changes(self):

		"""
		Set the variables based on the controls
		"""

		# Abort if the parent reports failure of if the controls are locked
		if not qtplugin.qtplugin.apply_edit_changes(self, False) or self.lock:
			return False

		# Refresh the main window, so that changes become visible everywhere
		self.experiment.main_window.refresh(self.name)

		# Report success
		return True

	def edit_widget(self):

		"""
		Set the controls based on the variables
		"""

		# Lock the controls, otherwise a recursive loop might aris
		# in which updating the controls causes the variables to be
		# updated, which causes the controls to be updated, etc...
		self.lock = True

		# Let the parent handle everything
		qtplugin.qtplugin.edit_widget(self)

		# Unlock
		self.lock = False

		# Return the _edit_widget
		return self._edit_widget



########NEW FILE########
__FILENAME__ = text_display
"""
This file is part of opensesame.

opensesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

opensesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with opensesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame.generic_response import generic_response
from libopensesame.item import item
from libqtopensesame.items.qtautoplugin import qtautoplugin
import openexp.canvas
import os.path
from PyQt4 import QtGui, QtCore

class text_display(item, generic_response):

	"""Basic text display plug-in"""

	description = u"Presents a display consisting of text"

	def __init__(self, name, experiment, string=None):

		"""
		Constructor.

		Arguments:
		name		--	The name of the item,
		experiment	--	An experiment object.

		Keyword arguments:
		string		--	A definition string. (default=None)
		"""

		self.duration = u"keypress"
		self.align = u"center"
		self.content = u"Enter your text here."
		self.maxchar = 50
		item.__init__(self, name, experiment, string)

	def prepare(self):

		"""Prepares the text display canvas."""

		# Pass the word on to the parent
		item.prepare(self)
		# Create an offline canvas
		self.c = openexp.canvas.canvas(self.experiment, self.get( \
			u"background"), self.get(u"foreground"))
		self.c.set_font(self.get(u"font_family"), self.get(u"font_size"))
		# Make sure that the content is a unicode string that is evaluated
		# for variables and then split into separated lines, using either the
		# os-specific or the Unix-style line separator.
		content = self.unistr(self.get(u'content'))
		content = content.replace(os.linesep, u'\n')
		content = self.eval_text(content).split(u"\n")
		# Do line wrapping
		_content = []
		for line in content:
			while len(line) > self.get(u"maxchar"):
				i = line.rfind(" ", 0, self.get(u"maxchar"))
				if i < 0:
					raise osexception( \
						u"Failed to do line wrapping in text_display '%s'. Perhaps one of the words is longer than the maximum number of characters per line?" \
						% self.name)
				_content.append(line[:i])
				line = line[i+1:]
			_content.append(line)
		content = _content

		if self.get(u"align") != u"center":
			try:
				max_width = 0
				max_height = 0
				for line in content:
					size = self.c.text_size(line)
					max_width = max(max_width, size[0])
					max_height = max(max_height, size[1])
			except:
				raise osexception( \
					u"Failed to use alignment '%s' in text_display '%s'. Perhaps this alignment is not supported by the back-end. Please use 'center' alignment." \
					% (self.get(u"align"), self.name))

		line_nr = -len(content) / 2
		for line in content:

			if self.get(u"align") == u"center":
				self.c.textline(line, line_nr)
			elif self.get(u"align") == u"left":
				self.c.text(line, False, self.c.xcenter()-0.5*max_width, \
					self.c.ycenter()+1.5*line_nr*max_height)
			else:
				width = self.c.text_size(line)[0]
				self.c.text(line, False, self.c.xcenter()+0.5*max_width-width, \
					self.c.ycenter()+1.5*line_nr*max_height)

			line_nr += 1

		generic_response.prepare(self)

	def run(self):

		"""Shows the text_display canvas."""

		# Show the canvas
		self.set_item_onset(self.c.show())
		self.set_sri()
		self.process_response()

	def var_info(self):

		"""
		Gives a list of dictionaries with variable descriptions.

		Returns:
		A list of (name, description) tuples
		"""

		return item.var_info(self) + generic_response.var_info(self)

class qttext_display(text_display, qtautoplugin):

	"""Automatic GUI class."""

	def __init__(self, name, experiment, script=None):

		text_display.__init__(self, name, experiment, script)
		qtautoplugin.__init__(self, __file__)

########NEW FILE########
__FILENAME__ = text_input
"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

from libopensesame.exceptions import osexception
from libopensesame import item, generic_response
from libqtopensesame import qtplugin
import openexp.canvas
import openexp.keyboard
import os.path
from PyQt4 import QtGui, QtCore

class text_input(item.item, generic_response.generic_response):

	"""A text input display"""

	def __init__(self, name, experiment, string = None):

		"""
		Constructor

		Arguments:
		name -- the name of the item
		experiment -- the experiment instance

		Keyword arguments:
		string -- a definition string
		"""

		# The item_typeshould match the name of the module
		self.item_type = "text_input"
		self._question = "Your question goes here..."
		self.linewidth = 600
		self.frame = "yes"
		self.frame_width = 3
		self.font_family = "sans"
		self.font_size = 24
		self.duration = "dummy"
		self.accept_on = "return press"
		self.timeout = 1000
		self.process_feedback = True

		# Provide a short accurate description of the items functionality
		self.description = "Provides a simple text input"

		# The parent handles the rest of the contruction
		item.item.__init__(self, name, experiment, string)

	def run(self):

		"""
		Run the item

		Returns:
		True on success, False on failure
		"""

		self.set_item_onset(self.time())

		# If no start response interval has been set, set it to the onset of
		# the current response item
		if self.experiment.start_response_interval == None:
			self.experiment.start_response_interval = self.get("time_%s" % \
				self.name)

		self._keyboard = openexp.keyboard.keyboard(self.experiment)

		# Create a canvas
		c = openexp.canvas.canvas(self.experiment, self.get("background"), \
			self.get("foreground"))
		c.set_font(self.get("font_family"), self.get("font_size"))
		c.set_penwidth(self.get("frame_width"))

		# Determine the character size and the maximum number of
		# characters per line (assuming a mono font)
		w, h = c.text_size("0")
		maxchar = self.get("linewidth") / w

		if maxchar < 2:
			raise osexception( \
				"The maximum line width is too small (or the font is too large) in text_input '%s'" \
				% self.name)

		margin = 32

		question = self.eval_text(self.get("_question"))

		resp = ""
		response = ""
		response_time = None
		while True:

			if self._check_return and resp == "return":
				break

			if self._check_timeout and self.time() - \
				self.experiment.start_response_interval > self.timeout:
				break

			# Fill the canvas and put it to the screen
			c.clear()

			_s = question + "\n" + response + "_"
			l = 0
			for s in _s.split("\n"):
				while len(s) > 0:
					c.text(s[:maxchar], False, c.xcenter() - \
						self.get("linewidth") / 2, c.ycenter() + h * l - \
						self.get("linewidth") / 2)
					s = s[maxchar:]
					l += 1
				l += 1

			if self.get("frame") == "yes":
				c.rect(c.xcenter() - self.get("linewidth") / 2 - margin, \
					c.ycenter() - self.get("linewidth") / 2 - margin, \
					self.get("linewidth") + 2 * margin, \
					h * l + 2 * margin, \
					False)

			c.show()

			# Get the response and the moderators (shift etc.)
			resp, time = self._keyboard.get_key()
			if len(resp) == 1:
				o = ord(resp)
			else:
				o = -1

			if response_time == None:
				response_time = time

			# Process the response
			if resp == "backspace" or o == 8:
				if len(response) > 0:
					response = response[:-1]
			elif resp == "space":
				response += " "
			elif len(resp) == 1:
				response += resp

		self.experiment.set("response", self.experiment.sanitize(response))
		self.experiment.end_response_interval = response_time
		self.response_bookkeeping()

		# Report success
		return True

	def prepare(self):

		"""Prepare for the run phase"""

		item.item.prepare(self)
		if self.get("accept_on") != "return press":
			self._check_timeout = True
		else:
			self._check_timeout = False
		if self.get("accept_on") != "timeout":
			self._check_return = True
		else:
			self._check_return = False
		return True

	def var_info(self):
		
		"""
		Give a list of dictionaries with variable descriptions

		Returns:
		A list of (name, description) tuples
		"""		

		return item.item.var_info(self) + \
			generic_response.generic_response.var_info(self)

class qttext_input(text_input, qtplugin.qtplugin):

	"""
	This class (the class named qt[name of module] handles
	the GUI part of the plugin. For more information about
	GUI programming using PyQt4, see:
	<http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/classes.html>
	"""

	def __init__(self, name, experiment, string = None):

		"""
		Constructor
		"""

		# Pass the word on to the parents
		text_input.__init__(self, name, experiment, string)
		qtplugin.qtplugin.__init__(self, __file__)

	def init_edit_widget(self):

		"""
		This function creates the controls for the edit
		widget.
		"""

		self.lock = True

		# Pass the word on to the parent
		qtplugin.qtplugin.init_edit_widget(self, False)
		self.add_text( \
			'<b>Deprecation warning:</b> Forms are faster and more flexible than the text_input plug-in')

		# Create the controls
		#
		# A number of convenience functions are available which
		# automatically create controls, which are also automatically
		# updated and applied. If you set the varname to None, the
		# controls will be created, but not automatically updated
		# and applied.
		#
		# qtplugin.add_combobox_control(varname, label, list_of_options)
		# - creates a QComboBox
		# qtplugin.add_line_edit_control(varname, label)
		# - creates a QLineEdit
		# qtplugin.add_spinbox_control(varname, label, min, max, suffix = suffix, prefix = prefix)

		self.add_spinbox_control("linewidth", "Maximum line width", 100, 2000, suffix = "px", tooltip = "The maximum width of the input field in pixels")
		self.add_combobox_control("frame", "Draw frame", ["yes", "no"], tooltip = "If 'yes', a rectangular frame will be drawn around the input field")
		self.add_spinbox_control("frame_width", "Frame width", 1, 512, suffix = "px", tooltip = "The width of the frame (if enabled)")
		self.add_color_edit_control("foreground", "Foreground", tooltip = "Expecting a colorname (e.g., 'blue') or an HTML color (e.g., '#0000FF')")
		self.add_color_edit_control("background", "Background", tooltip = "Expecting a colorname (e.g., 'blue') or an HTML color (e.g., '#0000FF')")
		self.add_combobox_control("font_family", "Font family", ["mono", "sans", "serif"], tooltip = "The font style")
		self.add_spinbox_control("font_size", "Font size", 1, 512, suffix = "pt", tooltip = "The font size")
		self.add_combobox_control("accept_on", "Accept on", ["return press", "timeout", "return press or timeout"], tooltip = "Indicates when the input text should be accepted")
		self.add_spinbox_control("timeout", "Timeout (if applicable)", 1, 100000, suffix = "ms", tooltip = "Timeout value")
		self.add_editor_control("_question", "Question", default = "Your question?", tooltip = "The question to be displayed above the input field")

		self.lock = False

	def apply_edit_changes(self):

		"""
		Set the variables based on the controls
		"""

		# Abort if the parent reports failure of if the controls are locked
		if not qtplugin.qtplugin.apply_edit_changes(self, False) or self.lock:
			return False

		# Refresh the main window, so that changes become visible everywhere
		self.experiment.main_window.refresh(self.name)

		# Report success
		return True

	def edit_widget(self):

		"""
		Set the controls based on the variables
		"""

		# Lock the controls, otherwise a recursive loop might aris
		# in which updating the controls causes the variables to be
		# updated, which causes the controls to be updated, etc...
		self.lock = True

		# Let the parent handle everything
		qtplugin.qtplugin.edit_widget(self)

		# Unlock
		self.lock = False

		# Return the _edit_widget
		return self._edit_widget


########NEW FILE########
__FILENAME__ = touch_response
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

import openexp.mouse
from libopensesame.mouse_response import mouse_response
from libqtopensesame.items.qtautoplugin import qtautoplugin

class touch_response(mouse_response):

	"""A simple fixation-dot plug-in."""

	description = \
		u'A grid-based response item, convenient for touch screens'

	def __init__(self, name, experiment, script=None):

		"""
		Constructor.

		Arguments:
		name		--	The name of the plug-in.
		experiment	--	The experiment object.

		Keyword arguments:
		script		--	A definition script. (default=None)
		"""

		# Set default values.
		self._ncol = 2
		self._nrow = 1
		mouse_response.__init__(self, name, experiment, script)
		
	def process_response_mouseclick(self, retval):

		"""Processes a mouseclick response."""

		self.experiment.start_response_interval = self.sri
		button, pos, self.experiment.end_response_interval = retval
		if pos != None:
			x, y = pos
			col = x / (self.experiment.width / self._ncol)
			row = y / (self.experiment.height / self._nrow)
			cell = row * self._ncol + col + 1
			self.experiment.set(u'cursor_x', x)
			self.experiment.set(u'cursor_y', y)
			self.experiment.set(u'response', cell)
		else:
			self.experiment.set(u'cursor_x', u'NA')
			self.experiment.set(u'cursor_y', u'NA')
			self.experiment.set(u'response', None)

class qttouch_response(touch_response, qtautoplugin):

	"""The GUI part of the plug-in. Controls are defined in info.json."""

	def __init__(self, name, experiment, script=None):

		"""
		Constructor.

		Arguments:
		name		--	The name of the plug-in.
		experiment	--	The experiment object.

		Keyword arguments:
		script		--	A definition script. (default=None)
		"""

		touch_response.__init__(self, name, experiment, script)
		qtautoplugin.__init__(self, __file__)

########NEW FILE########
__FILENAME__ = video_player
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

# OpenCV is used to read the video file
import cv
# PyGame is used to control the display
import pygame
from pygame.locals import *

from libopensesame import item
from libqtopensesame.items.qtautoplugin import qtautoplugin
from libqtopensesame.widgets import pool_widget
from libopensesame.exceptions import osexception

class video_player(item.item):
	
	description = u'An OpenCV-based image-only video player'

	def __init__(self, name, experiment, script=None):
	
		"""
		Constructor.
		
		Arguments:
		name		--	The item name.
		experiment	--	The experiment object.
		
		Keyword arguments:
		script		--	A definition script. (default=None)
		"""
		
		self.duration = u"keypress"
		self.fullscreen = u"yes"
		self.frame_dur = 50
		self.video_src = u""
		item.item.__init__(self, name, experiment, script)
						
	def prepare(self):
	
		"""Opens the video file for playback."""
			
		if self.experiment.get(u'canvas_backend') != u'legacy':
			raise osexception( \
				u'The video_player plug-in requires the legacy back-end!')
			
		item.item.prepare(self)			
		path = self.experiment.get_file(self.video_src)
		# Open the video file
		self.video = cv.CreateFileCapture(path)
		# Convert the string to a boolean, for slightly faster evaluations in
		# the run phase
		self._fullscreen = self.fullscreen == u"yes"
		# The dimensions of the video
		self._w = int(cv.GetCaptureProperty(self.video, cv.CV_CAP_PROP_FRAME_WIDTH))
		self._h = int(cv.GetCaptureProperty(self.video, cv.CV_CAP_PROP_FRAME_HEIGHT))
		if self._fullscreen:
			# In fullscreen mode, the video is always shown in the top-left and the
			# temporary images need to be fullscreen size
			self._x = 0
			self._y = 0		
			self.src_tmp = cv.CreateMat(self.experiment.height, \
				self.experiment.width, cv.CV_8UC3)
			self.src_rgb = cv.CreateMat(self.experiment.height, \
				self.experiment.width, cv.CV_8UC3)			
		else:
			# Otherwise the location of the video depends on its dimensions and the
			# temporary image is the same size as the video
			self._x = max(0, (self.experiment.width - self._w) / 2)
			self._y = max(0, (self.experiment.height - self._h) / 2)
			self.src_rgb = cv.CreateMat(self._h, self._w, cv.CV_8UC3)
				
	def run(self):
	
		"""Handles the actual video playback."""
		
		# Log the onset time of the item
		self.set_item_onset()
		
		t = pygame.time.get_ticks()
		start_t = t
		# Loop until a key is pressed
		go = True
		while go:
			# Get the frame		
			self.src = cv.QueryFrame(self.video)
			# Check for the end of the video
			if self.src == None:
				break		
			# Resize if requested and convert the resulting image to
			# RGB format, which is compatible with PyGame
			if self._fullscreen:
				cv.Resize(self.src, self.src_tmp)
				cv.CvtColor(self.src_tmp, self.src_rgb, cv.CV_BGR2RGB)
			else:
				cv.CvtColor(self.src, self.src_rgb, cv.CV_BGR2RGB)
			# Convert the image to PyGame format
			pg_img = pygame.image.frombuffer(self.src_rgb.tostring(), \
				cv.GetSize(self.src_rgb), u"RGB")
			# Show the video frame!
			self.experiment.surface.blit(pg_img, (self._x, self._y))	
			pygame.display.flip()
			# Pause before jumping to the next frame
			pygame.time.wait(self.frame_dur - pygame.time.get_ticks() + t)
			t = pygame.time.get_ticks()
			if type(self.duration) == int:
				# Wait for a specified duration
				if t - start_t >= self.duration:
					go = False
			# Catch escape presses
			for event in pygame.event.get():		
				if event.type == KEYDOWN:					
					if event.key == pygame.K_ESCAPE:
						raise osexception(u"The escape key was pressed.")
					if self.duration == u"keypress":	
						go = False
				if event.type == MOUSEBUTTONDOWN and self.duration == \
					u"mouseclick":
					go = False
		# Release the camera	
		# Note: This function appears to be missing. Perhaps it's ok
		# and Python will release it automatically?
		# cv.ReleaseCapture(self.video)		

class qtvideo_player(video_player, qtautoplugin):

	def __init__(self, name, experiment, script=None):

		video_player.__init__(self, name, experiment, script)
		qtautoplugin.__init__(self, __file__)

########NEW FILE########
__FILENAME__ = Qsci
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
""" 

from libopensesame import debug
debug.msg('using dummy PyQt4.Qsci')

# These names are directly imported, so need to exist
QsciScintilla = None
QsciScintillaBase = None
QsciLexerPython = None
########NEW FILE########
__FILENAME__ = QtCore
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
""" 

from libopensesame import debug
debug.msg('using dummy PyQt4.QtCore')
# Indicates that we are in dummy mode
QCoreApplication = None
########NEW FILE########
__FILENAME__ = QtGui
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
""" 

from libopensesame import debug
debug.msg('using dummy PyQt4.QtGui')

########NEW FILE########
__FILENAME__ = __theme__
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

__author__ = "Sebastiaan Mathot"
__license__ = "GPLv3"

icon_map = "icon_map.csv"
icon_theme = "os-custom-icons"
qss = "stylesheet.qss"

########NEW FILE########
__FILENAME__ = __theme__
#-*- coding:utf-8 -*-

"""
This file is part of OpenSesame.

OpenSesame is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSesame is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSesame.  If not, see <http://www.gnu.org/licenses/>.
"""

__author__ = "Sebastiaan Mathot"
__license__ = "GPLv3"

icon_map = "icon_map.csv"
icon_theme = "os-custom-icons"
qss = "stylesheet.qss"

########NEW FILE########
