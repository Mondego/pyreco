__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# MapProxy documentation build configuration file, created by
# sphinx-quickstart on Thu Feb 25 15:36:04 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))
sys.path.append(os.path.abspath('_themes'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.todo']

todo_include_todos = False

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'MapProxy'
copyright = u'Oliver Tonnhofer, Omniscale'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.7'
# The full version, including alpha/beta/rc tags.
release = '1.7.0a'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%Y-%m-%d'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'mapproxy'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.

html_theme_options = {
}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
html_title = "MapProxy %s Docs" % (release, )

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
html_logo = 'logo.png'

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%Y-%m-%d'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'MapProxydoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
latex_paper_size = 'a4'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'MapProxy.tex', u'MapProxy Documentation',
   u'Oliver Tonnhofer', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = base
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import sys
import hashlib
import time

from contextlib import contextmanager

from mapproxy.util.lock import FileLock, cleanup_lockdir, DummyLock

class CacheBackendError(Exception):
    pass

@contextmanager
def tile_buffer(tile):
    data = tile.source.as_buffer(seekable=True)
    data.seek(0)
    yield data
    tile.size = data.tell()
    if not tile.timestamp:
        tile.timestamp = time.time()
    data.seek(0)
    tile.stored = True

class TileCacheBase(object):
    """
    Base implementation of a tile cache.
    """

    supports_timestamp = True

    def load_tile(self, tile, with_metadata=False):
        raise NotImplementedError()

    def load_tiles(self, tiles, with_metadata=False):
        all_succeed = True
        for tile in tiles:
            if not self.load_tile(tile, with_metadata=with_metadata):
                all_succeed = False
        return all_succeed

    def store_tile(self, tile):
        raise NotImplementedError()

    def store_tiles(self, tiles):
        all_succeed = True
        for tile in tiles:
            if not self.store_tile(tile):
                all_succeed = False
        return all_succeed

    def remove_tile(self, tile):
        raise NotImplementedError()

    def remove_tiles(self, tiles):
        for tile in tiles:
            self.remove_tile(tile)

    def is_cached(self, tile):
        """
        Return ``True`` if the tile is cached.
        """
        raise NotImplementedError()

    def load_tile_metadata(self, tile):
        """
        Fill the metadata attributes of `tile`.
        Sets ``.timestamp`` and ``.size``.
        """
        raise NotImplementedError()

# whether we immediately remove lock files or not
REMOVE_ON_UNLOCK = True
if sys.platform == 'win32':
    # windows does not handle this well
    REMOVE_ON_UNLOCK = False

class FileBasedLocking(object):
    """
    Mixin for file based tile locking.

    Requires the following attributes:

    `lock_cache_id`
        unique id for this cache, if not present it will be
        generated from `cache_dir`

    `lock_dir`
        where the lock files are store

    `lock_timeout`
        how long to wait for a lock
    """
    def lock_filename(self, tile):
        if getattr(self, 'lock_cache_id', None) is None:
            self.lock_cache_id = hashlib.md5(self.cache_dir).hexdigest()
        return os.path.join(self.lock_dir, self.lock_cache_id + '-' +
                            '-'.join(map(str, tile.coord)) + '.lck')

    def lock(self, tile):
        """
        Returns a lock object for this tile.
        """
        if getattr(self, 'locking_disabled', False):
            return DummyLock()
        lock_filename = self.lock_filename(tile)
        cleanup_lockdir(self.lock_dir, max_lock_time=self.lock_timeout + 10,
            force=False)
        return FileLock(lock_filename, timeout=self.lock_timeout,
            remove_on_unlock=REMOVE_ON_UNLOCK)

class TileLocker(FileBasedLocking):
    def __init__(self, lock_dir, lock_timeout, lock_cache_id):
        self.lock_dir = lock_dir
        self.lock_timeout = lock_timeout
        self.lock_cache_id = lock_cache_id

########NEW FILE########
__FILENAME__ = couchdb
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

import datetime
import socket
import time
import hashlib

from cStringIO import StringIO

from mapproxy.image import ImageSource
from mapproxy.cache.base import (
    TileCacheBase, FileBasedLocking,
    tile_buffer, CacheBackendError,)
from mapproxy.source import SourceError
from mapproxy.srs import SRS

from threading import Lock

try:
    import requests
except ImportError:
    requests = None

try:
    import simplejson as json
except ImportError:
    try:
        import json
    except ImportError:
        json = None

import logging
log = logging.getLogger(__name__)

class UnexpectedResponse(CacheBackendError):
    pass

class CouchDBCache(TileCacheBase, FileBasedLocking):
    def __init__(self, url, db_name, lock_dir,
        file_ext, tile_grid, md_template=None,
        tile_id_template=None):

        if requests is None:
            raise ImportError("CouchDB backend requires 'requests' package.")

        if json is None:
            raise ImportError("CouchDB backend requires 'simplejson' package or Python 2.6+.")

        self.lock_cache_id = 'couchdb-' + hashlib.md5(url + db_name).hexdigest()
        self.lock_dir = lock_dir
        self.lock_timeout = 60
        self.file_ext = file_ext
        self.tile_grid = tile_grid
        self.md_template = md_template
        self.couch_url = '%s/%s' % (url.rstrip('/'), db_name.lower())
        self.req_session = requests.Session()
        self.req_session.timeout = 5
        self.db_initialised = False
        self.app_init_db_lock = Lock()
        self.tile_id_template = tile_id_template

    def init_db(self):
        with self.app_init_db_lock:
            if self.db_initialised:
                return
            try:
                self.req_session.put(self.couch_url)
                self.db_initialised = True
            except requests.exceptions.RequestException, ex:
                log.warn('unable to initialize CouchDB: %s', ex)

    def tile_url(self, coord):
        return self.document_url(coord) + '/tile'

    def document_url(self, coord, relative=False):
        x, y, z = coord
        grid_name = self.tile_grid.name
        couch_url = self.couch_url
        if relative:
            if self.tile_id_template:
                if self.tile_id_template.startswith('%(couch_url)s/'):
                    tile_id_template = self.tile_id_template[len('%(couch_url)s/'):]
                else:
                    tile_id_template = self.tile_id_template
                return tile_id_template % locals()
            else:
                return '%(grid_name)s-%(z)s-%(x)s-%(y)s' % locals()
        else:
            if self.tile_id_template:
                return self.tile_id_template % locals()
            else:
                return '%(couch_url)s/%(grid_name)s-%(z)s-%(x)s-%(y)s' % locals()

    def is_cached(self, tile):
        if tile.coord is None or tile.source:
            return True
        url = self.document_url(tile.coord)
        try:
            self.init_db()
            resp = self.req_session.get(url)
            if resp.status_code == 200:
                doc = json.loads(resp.content)
                tile.timestamp = doc.get(self.md_template.timestamp_key)
                return True
        except (requests.exceptions.RequestException, socket.error), ex:
            # is_cached should not fail (would abort seeding for example),
            # so we catch these errors here and just return False
            log.warn('error while requesting %s: %s', url, ex)
            return False
        if resp.status_code == 404:
            return False
        raise SourceError('%r: %r' % (resp.status_code, resp.content))


    def _tile_doc(self, tile):
        tile_id = self.document_url(tile.coord, relative=True)
        if self.md_template:
            tile_doc = self.md_template.doc(tile, self.tile_grid)
        else:
            tile_doc = {}
        tile_doc['_id'] = tile_id

        with tile_buffer(tile) as buf:
            data = buf.read()
        tile_doc['_attachments'] = {
            'tile': {
                'content_type': 'image/' + self.file_ext,
                'data': data.encode('base64').replace('\n', ''),
            }
        }
        return tile_id, tile_doc

    def _store_bulk(self, tiles):
        tile_docs = {}
        for tile in tiles:
            tile_id, tile_doc = self._tile_doc(tile)
            tile_docs[tile_id] = tile_doc

        duplicate_tiles = self._post_bulk(tile_docs)

        if duplicate_tiles:
            self._fill_rev_ids(duplicate_tiles)
            self._post_bulk(duplicate_tiles, no_conflicts=True)

        return True

    def _post_bulk(self, tile_docs, no_conflicts=False):
        """
        POST multiple tiles, returns all tile docs with conflicts during POST.
        """
        doc = {'docs': tile_docs.values()}
        data = json.dumps(doc)
        self.init_db()
        resp = self.req_session.post(self.couch_url + '/_bulk_docs', data=data, headers={'Content-type': 'application/json'})
        if resp.status_code != 201:
            raise UnexpectedResponse('got unexpected resp (%d) from CouchDB: %s' % (resp.status_code, resp.content))

        resp_doc = json.loads(resp.content)
        duplicate_tiles = {}
        for tile in resp_doc:
            if tile.get('error', 'false') == 'conflict':
                duplicate_tiles[tile['id']] = tile_docs[tile['id']]

        if no_conflicts and duplicate_tiles:
            raise UnexpectedResponse('got unexpected resp (%d) from CouchDB: %s' % (resp.status_code, resp.content))

        return duplicate_tiles

    def _fill_rev_ids(self, tile_docs):
        """
        Request all revs for tile_docs and insert it into the tile_docs.
        """
        keys_doc = {'keys': tile_docs.keys()}
        data = json.dumps(keys_doc)
        self.init_db()
        resp = self.req_session.post(self.couch_url + '/_all_docs', data=data, headers={'Content-type': 'application/json'})
        if resp.status_code != 200:
            raise UnexpectedResponse('got unexpected resp (%d) from CouchDB: %s' % (resp.status_code, resp.content))

        resp_doc = json.loads(resp.content)
        for tile in resp_doc['rows']:
            tile_docs[tile['id']]['_rev'] = tile['value']['rev']

    def store_tile(self, tile):
        if tile.stored:
            return True

        return self._store_bulk([tile])

    def store_tiles(self, tiles):
        tiles = [t for t in tiles if not t.stored]
        return self._store_bulk(tiles)

    def load_tile_metadata(self, tile):
        if tile.timestamp:
            return

        # is_cached loads metadata
        self.is_cached(tile)

    def load_tile(self, tile, with_metadata=False):
        # bulk loading with load_tiles is not implemented, because
        # CouchDB's /all_docs? does not include attachments

        if tile.source or tile.coord is None:
            return True
        url = self.document_url(tile.coord) + '?attachments=true'
        self.init_db()
        resp = self.req_session.get(url, headers={'Accept': 'application/json'})
        if resp.status_code == 200:
            doc = json.loads(resp.content)
            tile_data = StringIO(doc['_attachments']['tile']['data'].decode('base64'))
            tile.source = ImageSource(tile_data)
            tile.timestamp = doc.get(self.md_template.timestamp_key)
            return True
        return False

    def remove_tile(self, tile):
        if tile.coord is None:
            return True
        url = self.document_url(tile.coord)
        resp = requests.head(url)
        if resp.status_code == 404:
            # already removed
            return True
        rev_id = resp.headers['etag']
        url += '?rev=' + rev_id.strip('"')
        self.init_db()
        resp = self.req_session.delete(url)
        if resp.status_code == 200:
            return True
        return False


def utc_now_isoformat():
    now = datetime.datetime.utcnow()
    now = now.isoformat()
    # remove milliseconds, add Zulu timezone
    now = now.rsplit('.', 1)[0] + 'Z'
    return now

class CouchDBMDTemplate(object):
    def __init__(self, attributes):
        self.attributes = attributes
        for key, value in attributes.iteritems():
            if value == '{{timestamp}}':
                self.timestamp_key = key
                break
        else:
            attributes['timestamp'] = '{{timestamp}}'
            self.timestamp_key = 'timestamp'

    def doc(self, tile, grid):
        doc = {}
        x, y, z = tile.coord
        for key, value in self.attributes.iteritems():
            if not isinstance(value, basestring) or not value.startswith('{{'):
                doc[key] = value
                continue

            if value == '{{timestamp}}':
                doc[key] = time.time()
            elif value == '{{x}}':
                doc[key] = x
            elif value == '{{y}}':
                doc[key] = y
            elif value in ('{{z}}', '{{level}}'):
                doc[key] = z
            elif value == '{{utc_iso}}':
                doc[key] = utc_now_isoformat()
            elif value == '{{wgs_tile_centroid}}':
                tile_bbox = grid.tile_bbox(tile.coord)
                centroid = (
                    tile_bbox[0] + (tile_bbox[2]-tile_bbox[0])/2,
                    tile_bbox[1] + (tile_bbox[3]-tile_bbox[1])/2
                )
                centroid = grid.srs.transform_to(SRS(4326), centroid)
                doc[key] = centroid
            elif value == '{{tile_centroid}}':
                tile_bbox = grid.tile_bbox(tile.coord)
                centroid = (
                    tile_bbox[0] + (tile_bbox[2]-tile_bbox[0])/2,
                    tile_bbox[1] + (tile_bbox[3]-tile_bbox[1])/2
                )
                doc[key] = centroid
            else:
                raise ValueError('unknown CouchDB tile_metadata value: %r' % (value, ))
        return doc

########NEW FILE########
__FILENAME__ = dummy
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from mapproxy.cache.base import TileCacheBase
from mapproxy.util.lock import DummyLock

class DummyCache(TileCacheBase):
    def is_cached(self, tile):
        return False
    
    def lock(self, tile):
        return DummyLock()
    
    def load_tile(self, tile, with_metadata=False):
        pass
    
    def store_tile(self, tile):
        pass
########NEW FILE########
__FILENAME__ = file
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os
import errno

from mapproxy.util.fs import ensure_directory, write_atomic
from mapproxy.image import ImageSource, is_single_color_image
from mapproxy.cache.base import TileCacheBase, FileBasedLocking, tile_buffer

import logging
log = logging.getLogger('mapproxy.cache.file')

class FileCache(TileCacheBase, FileBasedLocking):
    """
    This class is responsible to store and load the actual tile data.
    """
    def __init__(self, cache_dir, file_ext, lock_dir=None, directory_layout='tc',
                 link_single_color_images=False, lock_timeout=60.0):
        """
        :param cache_dir: the path where the tile will be stored
        :param file_ext: the file extension that will be appended to
            each tile (e.g. 'png')
        """
        super(FileCache, self).__init__()
        self.cache_dir = cache_dir
        if lock_dir is None:
            lock_dir = os.path.join(cache_dir, 'tile_locks')
        self.lock_dir = lock_dir
        self.lock_timeout = lock_timeout
        self.file_ext = file_ext
        self.link_single_color_images = link_single_color_images

        if directory_layout == 'tc':
            self.tile_location = self._tile_location_tc
        elif directory_layout == 'tms':
            self.tile_location = self._tile_location_tms
        elif directory_layout == 'quadkey':
            self.tile_location = self._tile_location_quadkey
        else:
            raise ValueError('unknown directory_layout "%s"' % directory_layout)

    def level_location(self, level):
        """
        Return the path where all tiles for `level` will be stored.

        >>> c = FileCache(cache_dir='/tmp/cache/', file_ext='png')
        >>> c.level_location(2)
        '/tmp/cache/02'
        """
        if isinstance(level, basestring):
            return os.path.join(self.cache_dir, level)
        else:
            return os.path.join(self.cache_dir, "%02d" % level)

    def _tile_location_tc(self, tile, create_dir=False):
        """
        Return the location of the `tile`. Caches the result as ``location``
        property of the `tile`.

        :param tile: the tile object
        :param create_dir: if True, create all necessary directories
        :return: the full filename of the tile

        >>> from mapproxy.cache.tile import Tile
        >>> c = FileCache(cache_dir='/tmp/cache/', file_ext='png')
        >>> c.tile_location(Tile((3, 4, 2))).replace('\\\\', '/')
        '/tmp/cache/02/000/000/003/000/000/004.png'
        """
        if tile.location is None:
            x, y, z = tile.coord
            parts = (self.level_location(z),
                     "%03d" % int(x / 1000000),
                     "%03d" % (int(x / 1000) % 1000),
                     "%03d" % (int(x) % 1000),
                     "%03d" % int(y / 1000000),
                     "%03d" % (int(y / 1000) % 1000),
                     "%03d.%s" % (int(y) % 1000, self.file_ext))
            tile.location = os.path.join(*parts)
        if create_dir:
            ensure_directory(tile.location)
        return tile.location

    def _tile_location_tms(self, tile, create_dir=False):
        """
        Return the location of the `tile`. Caches the result as ``location``
        property of the `tile`.

        :param tile: the tile object
        :param create_dir: if True, create all necessary directories
        :return: the full filename of the tile

        >>> from mapproxy.cache.tile import Tile
        >>> c = FileCache(cache_dir='/tmp/cache/', file_ext='png', directory_layout='tms')
        >>> c.tile_location(Tile((3, 4, 2))).replace('\\\\', '/')
        '/tmp/cache/2/3/4.png'
        """
        if tile.location is None:
            x, y, z = tile.coord
            tile.location = os.path.join(
                self.level_location(str(z)),
                str(x), str(y) + '.' + self.file_ext
            )
        if create_dir:
            ensure_directory(tile.location)
        return tile.location

    def _tile_location_quadkey(self, tile, create_dir=False):
        """
        Return the location of the `tile`. Caches the result as ``location``
        property of the `tile`.

        :param tile: the tile object
        :param create_dir: if True, create all necessary directories
        :return: the full filename of the tile

        >>> from mapproxy.cache.tile import Tile
        >>> from mapproxy.cache.file import FileCache
        >>> c = FileCache(cache_dir='/tmp/cache/', file_ext='png', directory_layout='quadkey')
        >>> c.tile_location(Tile((3, 4, 2))).replace('\\\\', '/')
        '/tmp/cache/11.png'
        """
        if tile.location is None:
            x, y, z = tile.coord
            quadKey = ""
            for i in range(z,0,-1):
                digit = 0
                mask = 1 << (i-1)
                if (x & mask) != 0:
                    digit += 1
                if (y & mask) != 0:
                    digit += 2
                quadKey += str(digit)
            tile.location = os.path.join(
                self.cache_dir, quadKey + '.' + self.file_ext
            )
        if create_dir:
            ensure_directory(tile.location)
        return tile.location

    def _single_color_tile_location(self, color, create_dir=False):
        """
        >>> c = FileCache(cache_dir='/tmp/cache/', file_ext='png')
        >>> c._single_color_tile_location((254, 0, 4)).replace('\\\\', '/')
        '/tmp/cache/single_color_tiles/fe0004.png'
        """
        parts = (
            self.cache_dir,
            'single_color_tiles',
            ''.join('%02x' % v for v in color) + '.' + self.file_ext
        )
        location = os.path.join(*parts)
        if create_dir:
            ensure_directory(location)
        return location

    def load_tile_metadata(self, tile):
        location = self.tile_location(tile)
        try:
            stats = os.lstat(location)
            tile.timestamp = stats.st_mtime
            tile.size = stats.st_size
        except OSError, ex:
            if ex.errno != errno.ENOENT: raise
            tile.timestamp = 0
            tile.size = 0

    def is_cached(self, tile):
        """
        Returns ``True`` if the tile data is present.
        """
        if tile.is_missing():
            location = self.tile_location(tile)
            if os.path.exists(location):
                return True
            else:
                return False
        else:
            return True

    def load_tile(self, tile, with_metadata=False):
        """
        Fills the `Tile.source` of the `tile` if it is cached.
        If it is not cached or if the ``.coord`` is ``None``, nothing happens.
        """
        if not tile.is_missing():
            return True

        location = self.tile_location(tile)

        if os.path.exists(location):
            if with_metadata:
                self.load_tile_metadata(tile)
            tile.source = ImageSource(location)
            return True
        return False

    def remove_tile(self, tile):
        location = self.tile_location(tile)
        try:
            os.remove(location)
        except OSError, ex:
            if ex.errno != errno.ENOENT: raise

    def store_tile(self, tile):
        """
        Add the given `tile` to the file cache. Stores the `Tile.source` to
        `FileCache.tile_location`.
        """
        if tile.stored:
            return

        tile_loc = self.tile_location(tile, create_dir=True)

        if self.link_single_color_images:
            color = is_single_color_image(tile.source.as_image())
            if color:
                self._store_single_color_tile(tile, tile_loc, color)
            else:
                self._store(tile, tile_loc)
        else:
            self._store(tile, tile_loc)

    def _store(self, tile, location):
        if os.path.islink(location):
            os.unlink(location)

        with tile_buffer(tile) as buf:
            log.debug('writing %r to %s' % (tile.coord, location))
            write_atomic(location, buf.read())

    def _store_single_color_tile(self, tile, tile_loc, color):
        real_tile_loc = self._single_color_tile_location(color, create_dir=True)
        if not os.path.exists(real_tile_loc):
            self._store(tile, real_tile_loc)

        log.debug('linking %r from %s to %s',
                  tile.coord, real_tile_loc, tile_loc)

        # remove any file before symlinking.
        # exists() returns False if it links to non-
        # existing file, islink() test to check that
        if os.path.exists(tile_loc) or os.path.islink(tile_loc):
            os.unlink(tile_loc)

        # Use relative path for the symlink if os.path.relpath is available
        # (only supported with >= Python 2.6)
        if hasattr(os.path, 'relpath'):
            real_tile_loc = os.path.relpath(real_tile_loc,
                                            os.path.dirname(tile_loc))

        try:
            os.symlink(real_tile_loc, tile_loc)
        except OSError, e:
            # ignore error if link was created by other process
            if e.errno != errno.EEXIST:
                raise e

        return

    def __repr__(self):
        return '%s(%r, %r)' % (self.__class__.__name__, self.cache_dir, self.file_ext)


########NEW FILE########
__FILENAME__ = legend
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

import os
import hashlib

from mapproxy.image import ImageSource
from mapproxy.image.opts import ImageOptions
from mapproxy.util.fs import ensure_directory, write_atomic

import logging
log = logging.getLogger(__name__)

def legend_identifier(legends):
    """
    >>> legend_identifier([("http://example/?", "foo"), ("http://example/?", "bar")])
    'http://example/?foohttp://example/?bar'

    :param legends: list of legend URL and layer tuples
    """
    parts = []
    for url, layer in legends:
        parts.append(url)
        if layer:
            parts.append(layer)
    return ''.join(parts)

def legend_hash(identifier, scale):
    md5 = hashlib.md5()
    md5.update(identifier)
    md5.update(str(scale))
    return md5.hexdigest()

class LegendCache(object):
    def __init__(self, cache_dir=None, file_ext='png'):
        self.cache_dir = cache_dir
        self.file_ext = file_ext

    def store(self, legend):
        if legend.stored:
            return

        if legend.location is None:
            hash = legend_hash(legend.id, legend.scale)
            legend.location = os.path.join(self.cache_dir, hash) + '.' + self.file_ext
            ensure_directory(legend.location)

        data = legend.source.as_buffer(ImageOptions(format='image/' + self.file_ext), seekable=True)
        data.seek(0)
        log.debug('writing to %s' % (legend.location))
        write_atomic(legend.location, data.read())
        data.seek(0)
        legend.stored = True

    def load(self, legend):
        hash = legend_hash(legend.id, legend.scale)
        legend.location = os.path.join(self.cache_dir, hash) + '.' + self.file_ext

        if os.path.exists(legend.location):
            legend.source = ImageSource(legend.location)
            return True
        return False

class Legend(object):
    def __init__(self, source=None, id=None, scale=None):
        self.source = source
        self.stored = None
        self.location = None
        self.id = id
        self.scale = scale

########NEW FILE########
__FILENAME__ = mbtiles
# This file is part of the MapProxy project.
# Copyright (C) 2011-2013 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os
import time
import sqlite3
import threading
from cStringIO import StringIO

from mapproxy.image import ImageSource
from mapproxy.cache.base import TileCacheBase, FileBasedLocking, tile_buffer, CacheBackendError
from mapproxy.util.fs import ensure_directory
from mapproxy.util.lock import FileLock

import logging
log = logging.getLogger(__name__)

def sqlite_datetime_to_timestamp(datetime):
    if datetime is None:
        return None
    d = time.strptime(datetime, "%Y-%m-%d %H:%M:%S")
    return time.mktime(d)

class MBTilesCache(TileCacheBase, FileBasedLocking):
    supports_timestamp = False

    def __init__(self, mbtile_file, lock_dir=None, with_timestamps=False):
        if lock_dir:
            self.lock_dir = lock_dir
        else:
            self.lock_dir = mbtile_file + '.locks'
        self.lock_timeout = 60
        self.cache_dir = mbtile_file # for lock_id generation by FileBasedLocking
        self.mbtile_file = mbtile_file
        self.supports_timestamp = with_timestamps
        self.ensure_mbtile()
        self._db_conn_cache = threading.local()

    @property
    def db(self):
        if not getattr(self._db_conn_cache, 'db', None):
            self.ensure_mbtile()
            self._db_conn_cache.db = sqlite3.connect(self.mbtile_file)
        return self._db_conn_cache.db

    def cleanup(self):
        """
        Close all open connection and remove them from cache.
        """
        if getattr(self._db_conn_cache, 'db', None):
            self._db_conn_cache.db.close()
        self._db_conn_cache.db = None

    def ensure_mbtile(self):
        if not os.path.exists(self.mbtile_file):
            with FileLock(os.path.join(self.lock_dir, 'init.lck'),
                timeout=self.lock_timeout,
                remove_on_unlock=True):
                if not os.path.exists(self.mbtile_file):
                    ensure_directory(self.mbtile_file)
                    self._initialize_mbtile()

    def _initialize_mbtile(self):
        log.info('initializing MBTile file %s', self.mbtile_file)
        db  = sqlite3.connect(self.mbtile_file)
        stmt = """
            CREATE TABLE tiles (
                zoom_level integer,
                tile_column integer,
                tile_row integer,
                tile_data blob
        """

        if self.supports_timestamp:
            stmt += """
                , last_modified datetime DEFAULT (datetime('now','localtime'))
            """
        stmt += """
            );
        """
        db.execute(stmt)

        db.execute("""
            CREATE TABLE metadata (name text, value text);
        """)
        db.execute("""
            CREATE UNIQUE INDEX idx_tile on tiles
                (zoom_level, tile_column, tile_row);
        """)
        db.commit()
        db.close()

    def update_metadata(self, name='', description='', version=1, overlay=True, format='png'):
        db  = sqlite3.connect(self.mbtile_file)
        db.execute("""
            CREATE TABLE IF NOT EXISTS metadata (name text, value text);
        """)
        db.execute("""DELETE FROM metadata;""")

        if overlay:
            layer_type = 'overlay'
        else:
            layer_type = 'baselayer'

        db.executemany("""
            INSERT INTO metadata (name, value) VALUES (?,?)
            """,
            (
                ('name', name),
                ('description', description),
                ('version', version),
                ('type', layer_type),
                ('format', format),
            )
        )
        db.commit()
        db.close()

    def is_cached(self, tile):
        if tile.coord is None:
            return True
        if tile.source:
            return True

        return self.load_tile(tile)

    def store_tile(self, tile):
        if tile.stored:
            return True
        with tile_buffer(tile) as buf:
            content = buffer(buf.read())
            x, y, level = tile.coord
            cursor = self.db.cursor()
            try:
                if self.supports_timestamp:
                    stmt = "INSERT OR REPLACE INTO tiles (zoom_level, tile_column, tile_row, tile_data, last_modified) VALUES (?,?,?,?, datetime(?, 'unixepoch', 'localtime'))"
                    cursor.execute(stmt, (level, x, y, content, time.time()))
                else:
                    stmt = "INSERT OR REPLACE INTO tiles (zoom_level, tile_column, tile_row, tile_data) VALUES (?,?,?,?)"
                    cursor.execute(stmt, (level, x, y, content))
                self.db.commit()
            except sqlite3.OperationalError, ex:
                log.warn('unable to store tile: %s', ex)
                return False
            return True

    def load_tile(self, tile, with_metadata=False):
        if tile.source or tile.coord is None:
            return True

        cur = self.db.cursor()
        if self.supports_timestamp:
            cur.execute('''SELECT tile_data, last_modified
                FROM tiles
                WHERE tile_column = ? AND
                      tile_row = ? AND
                      zoom_level = ?''', tile.coord)
        else:
            cur.execute('''SELECT tile_data FROM tiles
                WHERE tile_column = ? AND
                      tile_row = ? AND
                      zoom_level = ?''', tile.coord)

        content = cur.fetchone()
        if content:
            tile.source = ImageSource(StringIO(content[0]))
            if self.supports_timestamp:
                tile.timestamp = sqlite_datetime_to_timestamp(content[1])
            return True
        else:
            return False

    def load_tiles(self, tiles, with_metadata=False):
        #associate the right tiles with the cursor
        tile_dict = {}
        coords = []
        for tile in tiles:
            if tile.source or tile.coord is None:
                continue
            x, y, level = tile.coord
            coords.append(x)
            coords.append(y)
            coords.append(level)
            tile_dict[(x, y)] = tile

        if not tile_dict:
            # all tiles loaded or coords are None
            return True

        if len(coords) > 1000:
            # SQLite is limited to 1000 args
            raise CacheBackendError('cannot query SQLite for more than 333 tiles')

        if self.supports_timestamp:
            stmt = "SELECT tile_column, tile_row, tile_data, last_modified FROM tiles WHERE "
        else:
            stmt = "SELECT tile_column, tile_row, tile_data FROM tiles WHERE "
        stmt += ' OR '.join(['(tile_column = ? AND tile_row = ? AND zoom_level = ?)'] * (len(coords)//3))

        cursor = self.db.cursor()
        cursor.execute(stmt, coords)

        loaded_tiles = 0
        for row in cursor:
            loaded_tiles += 1
            tile = tile_dict[(row[0], row[1])]
            data = row[2]
            tile.size = len(data)
            tile.source = ImageSource(StringIO(data))
            if self.supports_timestamp:
                tile.timestamp = sqlite_datetime_to_timestamp(row[3])
        cursor.close()
        return loaded_tiles == len(tile_dict)

    def remove_tile(self, tile):
        cursor = self.db.cursor()
        cursor.execute(
            "DELETE FROM tiles WHERE (tile_column = ? AND tile_row = ? AND zoom_level = ?)",
            tile.coord)
        self.db.commit()
        if cursor.rowcount:
            return True
        return False

    def remove_level_tiles_before(self, level, timestamp):
        if timestamp == 0:
            cursor = self.db.cursor()
            cursor.execute(
                "DELETE FROM tiles WHERE (zoom_level = ?)",
                (level, ))
            self.db.commit()
            if cursor.rowcount:
                return True
            return False

        if self.supports_timestamp:
            cursor = self.db.cursor()
            cursor.execute(
                "DELETE FROM tiles WHERE (zoom_level = ? AND last_modified < datetime(?, 'unixepoch', 'localtime'))",
                (level, timestamp))
            self.db.commit()
            if cursor.rowcount:
                return True
            return False

    def load_tile_metadata(self, tile):
        if not self.supports_timestamp:
            # MBTiles specification does not include timestamps.
            # This sets the timestamp of the tile to epoch (1970s)
            tile.timestamp = -1
        else:
            self.load_tile(tile)

class MBTilesLevelCache(TileCacheBase, FileBasedLocking):
    supports_timestamp = True

    def __init__(self, mbtiles_dir, lock_dir=None):
        if lock_dir:
            self.lock_dir = lock_dir
        else:
            self.lock_dir = mbtiles_dir + '.locks'
        self.lock_timeout = 60
        self.cache_dir = mbtiles_dir
        self._mbtiles = {}
        self._mbtiles_lock = threading.Lock()

    def _get_level(self, level):
        if level in self._mbtiles:
            return self._mbtiles[level]

        with self._mbtiles_lock:
            if level not in self._mbtiles:
                mbtile_filename = os.path.join(self.cache_dir, '%s.mbtile' % level)
                self._mbtiles[level] = MBTilesCache(
                    mbtile_filename,
                    lock_dir=self.lock_dir,
                    with_timestamps=True,
                )

        return self._mbtiles[level]

    def is_cached(self, tile):
        if tile.coord is None:
            return True
        if tile.source:
            return True

        return self._get_level(tile.coord[2]).is_cached(tile)

    def store_tile(self, tile):
        if tile.stored:
            return True

        return self._get_level(tile.coord[2]).store_tile(tile)

    def load_tile(self, tile, with_metadata=False):
        if tile.source or tile.coord is None:
            return True

        return self._get_level(tile.coord[2]).load_tile(tile, with_metadata=with_metadata)

    def load_tiles(self, tiles, with_metadata=False):
        level = None
        for tile in tiles:
            if tile.source or tile.coord is None:
                continue
            level = tile.coord[2]
            break

        if not level:
            return True

        return self._get_level(level).load_tiles(tiles, with_metadata=with_metadata)

    def remove_tile(self, tile):
        if tile.coord is None:
            return True

        return self._get_level(tile.coord[2]).remove_tile(tile)

    def load_tile_metadata(self, tile):
        self.load_tile(tile)

    def remove_level_tiles_before(self, level, timestamp):
        level_cache = self._get_level(level)
        if timestamp == 0:
            level_cache.cleanup()
            os.unlink(level_cache.mbtile_file)
            return True
        else:
            return level_cache.remove_level_tiles_before(level, timestamp)


########NEW FILE########
__FILENAME__ = renderd
# This file is part of the MapProxy project.
# Copyright (C) 2012, 2013 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import time
import hashlib

try:
    import json; json
except ImportError:
    json = None

try:
    import requests; requests
except ImportError:
    requests = None

from mapproxy.client.log import log_request
from mapproxy.cache.tile import TileCreator, Tile
from mapproxy.source import SourceError

def has_renderd_support():
    if not json or not requests:
        return False
    return True

class RenderdTileCreator(TileCreator):
    def __init__(self, renderd_address, tile_mgr, dimensions=None, priority=100, tile_locker=None):
        TileCreator.__init__(self, tile_mgr, dimensions)
        self.tile_locker = tile_locker.lock or self.tile_mgr.lock
        self.renderd_address = renderd_address
        self.priority = priority

    def _create_single_tile(self, tile):
        with self.tile_locker(tile):
            if not self.is_cached(tile):
                self._create_renderd_tile(tile.coord)
            self.cache.load_tile(tile)
        return [tile]

    def _create_meta_tile(self, meta_tile):
        main_tile = Tile(meta_tile.main_tile_coord)
        with self.tile_locker(main_tile):
            if not all(self.is_cached(t) for t in meta_tile.tiles if t is not None):
                self._create_renderd_tile(main_tile.coord)

        tiles = [Tile(coord) for coord in meta_tile.tiles]
        self.cache.load_tiles(tiles)
        return tiles

    def _create_renderd_tile(self, tile_coord):
        start_time = time.time()
        result = self._send_tile_request(self.tile_mgr.identifier, [tile_coord])
        duration = time.time()-start_time

        address = '%s:%s:%r' % (self.renderd_address,
            self.tile_mgr.identifier, tile_coord)

        if result['status'] == 'error':
            log_request(address, 500, None, duration=duration, method='RENDERD')
            raise SourceError("Error from renderd: %s" % result.get('error_message', 'unknown error from renderd'))

        log_request(address, 200, None, duration=duration, method='RENDERD')

    def _send_tile_request(self, cache_identifier, tile_coords):
        identifier = hashlib.sha1(str((cache_identifier, tile_coords))).hexdigest()
        message = {
            'command': 'tile',
            'id': identifier,
            'tiles': tile_coords,
            'cache_identifier': cache_identifier,
            'priority': self.priority
        }
        try:
            resp = requests.post(self.renderd_address, data=json.dumps(message))
            return resp.json()
        except ValueError:
            raise SourceError("Error while communicating with renderd: invalid JSON")
        except requests.RequestException, ex:
            raise SourceError("Error while communicating with renderd: %s" % ex)
########NEW FILE########
__FILENAME__ = riak
# This file is part of the MapProxy project.
# Copyright (C) 2013 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, absolute_import

import threading
import hashlib

from cStringIO import StringIO

from mapproxy.image import ImageSource
from mapproxy.cache.tile import Tile
from mapproxy.cache.base import (
    TileCacheBase, FileBasedLocking,
    tile_buffer, CacheBackendError,)

try:
    import riak
except ImportError:
    riak = None

import logging
log = logging.getLogger(__name__)

class UnexpectedResponse(CacheBackendError):
    pass

class RiakCache(TileCacheBase, FileBasedLocking):
    def __init__(self, nodes, protocol, bucket, tile_grid, lock_dir, use_secondary_index=False):
        if riak is None:
            raise ImportError("Riak backend requires 'riak' package.")

        self.nodes = nodes
        self.protocol = protocol

        self.lock_cache_id = 'riak-' + hashlib.md5(nodes[0]['host'] + bucket).hexdigest()
        self.lock_dir = lock_dir
        self.lock_timeout = 60
        self.request_timeout = self.lock_timeout * 1000  # riak timeout is in miliseconds
        self.bucket_name = bucket
        self.tile_grid = tile_grid
        self.use_secondary_index = use_secondary_index
        self._db_conn_cache = threading.local()

    @property
    def connection(self):
        if not getattr(self._db_conn_cache, 'connection', None):
            self._db_conn_cache.connection = riak.RiakClient(protocol=self.protocol, nodes=self.nodes)
        return self._db_conn_cache.connection

    @property
    def bucket(self):
        return self.connection.bucket(self.bucket_name)

    def _get_object(self, coord):
        (x, y, z) = coord
        key = '%(z)d_%(x)d_%(y)d' % locals()
        obj = False
        try:
            obj = self.bucket.get(key, r=1, timeout=self.request_timeout)
        except Exception, e:
            log.warn('error while requesting %s: %s', key, e)

        if not obj:
            obj = self.bucket.new(key=key, data=None, content_type='application/octet-stream')
        return obj

    def _get_timestamp(self, obj):
        metadata = obj.usermeta
        timestamp = metadata.get('timestamp')
        if timestamp != None:
            return float(timestamp)
        
        obj.usermeta = {'timestamp': '0'}
        return 0.0

    def is_cached(self, tile):
        if tile.coord is None or tile.source:
            return True
        res = self._get_object(tile.coord)
        if not res.exists:
            return False

        tile.timestamp = self._get_timestamp(res)
        tile.size = len(res.encoded_data)

        return True

    def _store_bulk(self, tiles):
        for tile in tiles:
            res = self._get_object(tile.coord)
            with tile_buffer(tile) as buf:
                data = buf.read()
            res.encoded_data = data
            res.usermeta = {
                'timestamp': str(tile.timestamp),
                'size': str(tile.size),
            }
            if self.use_secondary_index:
                x, y, z = tile.coord
                res.add_index('tile_coord_bin', '%02d-%07d-%07d' % (z, x, y))
            
            try:
                res.store(return_body=False, timeout=self.request_timeout)
            except riak.RiakError, ex:
                log.warn('unable to store tile: %s', ex)
                return False

        return True

    def store_tile(self, tile):
        if tile.stored:
            return True

        return self._store_bulk([tile])

    def store_tiles(self, tiles):
        tiles = [t for t in tiles if not t.stored]
        return self._store_bulk(tiles)

    def load_tile_metadata(self, tile):
        if tile.timestamp:
            return

        # is_cached loads metadata
        self.is_cached(tile)

    def load_tile(self, tile, with_metadata=False):
        if not tile.is_missing():
            return True

        res = self._get_object(tile.coord)
        if res.exists:
            tile_data = StringIO(res.encoded_data)
            tile.source = ImageSource(tile_data)
            if with_metadata:
                tile.timestamp = self._get_timestamp(res)
                tile.size = len(res.encoded_data)
            return True

        return False

    def remove_tile(self, tile):
        if tile.coord is None:
            return True

        res = self._get_object(tile.coord)
        if not res.exists:
            # already removed
            return True

        try:
            res.delete(w=1, rw=1, dw=1, pw=1)
        except riak.RiakError, ex:
            log.warn('unable to remove tile: %s', ex)
            return False
        return True

    def _fill_metadata_from_obj(self, obj, tile):
        tile_md = obj.usermeta
        timestamp = tile_md.get('timestamp')
        if timestamp:
            tile.timestamp = float(timestamp)

    def _key_iterator(self, level):
        """
        Generator for all tile keys in `level`.
        """
        # index() returns a list of all keys so we check for tiles in
        # batches of `chunk_size`*`chunk_size`.
        grid_size = self.tile_grid.grid_sizes[level]
        chunk_size = 256
        for x in xrange(grid_size[0]/chunk_size):
            start_x = x * chunk_size
            end_x = start_x + chunk_size - 1
            for y in xrange(grid_size[1]/chunk_size):
                start_y = y * chunk_size
                end_y = start_y + chunk_size - 1
                query = self.bucket.get_index('tile_coord_bin',
                    '%02d-%07d-%07d' % (level, start_x, start_y),
                    '%02d-%07d-%07d' % (level, end_x, end_y))
                for link in query.run():
                    yield link.get_key()

    def remove_tiles_for_level(self, level, before_timestamp=None):
        bucket = self.bucket
        client = self.connection
        for key in self._key_iterator(level):
            if before_timestamp:
                obj = self.bucket.get(key, r=1)
                dummy_tile = Tile((0, 0, 0))
                self._fill_metadata_from_obj(obj, dummy_tile)
                if dummy_tile.timestamp < before_timestamp:
                    obj.delete()
            else:
                riak.RiakObject(client, bucket, key).delete()

########NEW FILE########
__FILENAME__ = tile
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Tile caching (creation, caching and retrieval of tiles).

.. digraph:: Schematic Call Graph

    ranksep = 0.1;
    node [shape="box", height="0", width="0"]

    cl  [label="CacheMapLayer" href="<mapproxy.core.layer.CacheMapLayer>"]
    tm  [label="TileManager",  href="<TileManager>"];
    fc      [label="FileCache", href="<FileCache>"];
    s       [label="Source", href="<mapproxy.core.source.Source>"];

    {
        cl -> tm [label="load_tile_coords"];
        tm -> fc [label="load\\nstore\\nis_cached"];
        tm -> s  [label="get_map"]
    }


"""

from __future__ import with_statement

from contextlib import contextmanager

from mapproxy.grid import MetaGrid
from mapproxy.image.merge import merge_images
from mapproxy.image.tile import TileSplitter
from mapproxy.layer import MapQuery, BlankImage
from mapproxy.util import async

class TileManager(object):
    """
    Manages tiles for a single grid.
    Loads tiles from the cache, creates new tiles from sources and stores them
    into the cache, or removes tiles.

    :param pre_store_filter: a list with filter. each filter will be called
        with a tile before it will be stored to disc. the filter should
        return this or a new tile object.
    """
    def __init__(self, grid, cache, sources, format, image_opts=None, request_format=None,
        meta_buffer=None, meta_size=None, minimize_meta_requests=False, identifier=None,
        pre_store_filter=None, concurrent_tile_creators=1, tile_creator_class=None):
        self.grid = grid
        self.cache = cache
        self.identifier = identifier
        self.meta_grid = None
        self.format = format
        self.image_opts = image_opts
        self.request_format = request_format or format
        self.sources = sources
        self.minimize_meta_requests = minimize_meta_requests
        self._expire_timestamp = None
        self.transparent = self.sources[0].transparent
        self.pre_store_filter = pre_store_filter or []
        self.concurrent_tile_creators = concurrent_tile_creators
        self.tile_creator_class = tile_creator_class or TileCreator

        if meta_buffer or (meta_size and not meta_size == [1, 1]):
            if all(source.supports_meta_tiles for source in sources):
                self.meta_grid = MetaGrid(grid, meta_size=meta_size, meta_buffer=meta_buffer)
            elif any(source.supports_meta_tiles for source in sources):
                raise ValueError('meta tiling configured but not supported by all sources')

    @contextmanager
    def session(self):
        """
        Context manager for access to the cache. Cleans up after usage
        for connection based caches.

        >>> with tile_manager.session(): #doctest: +SKIP
        ...    tile_manager.load_tile_coords(tile_coords)

        """
        yield
        self.cleanup()

    def cleanup(self):
        if hasattr(self.cache, 'cleanup'):
            self.cache.cleanup()

    def load_tile_coord(self, tile_coord, dimensions=None, with_metadata=False):
        tile = Tile(tile_coord)
        self.cache.load_tile(tile, with_metadata)

        if tile.coord is not None and not self.is_cached(tile, dimensions=dimensions):
            # missing or staled
            creator = self.creator(dimensions=dimensions)
            created_tiles = creator.create_tiles([tile])
            for created_tile in created_tiles:
                if created_tile.coord == tile_coord:
                    return created_tile

        return tile

    def load_tile_coords(self, tile_coords, dimensions=None, with_metadata=False):
        tiles = TileCollection(tile_coords)
        uncached_tiles = []

        # load all in batch
        self.cache.load_tiles(tiles, with_metadata)

        for tile in tiles:
            if tile.coord is not None and not self.is_cached(tile, dimensions=dimensions):
                # missing or staled
                uncached_tiles.append(tile)

        if uncached_tiles:
            creator = self.creator(dimensions=dimensions)
            created_tiles = creator.create_tiles(uncached_tiles)
            for created_tile in created_tiles:
                if created_tile.coord in tiles:
                    tiles[created_tile.coord].source = created_tile.source

        return tiles

    def remove_tile_coords(self, tile_coords, dimensions=None):
        tiles = TileCollection(tile_coords)
        self.cache.remove_tiles(tiles)

    def creator(self, dimensions=None):
        return self.tile_creator_class(self, dimensions=dimensions)

    def lock(self, tile):
        if self.meta_grid:
            tile = Tile(self.meta_grid.main_tile(tile.coord))
        return self.cache.lock(tile)

    def is_cached(self, tile, dimensions=None):
        """
        Return True if the tile is cached.
        """
        if isinstance(tile, tuple):
            tile = Tile(tile)
        if tile.coord is None:
            return True
        cached = self.cache.is_cached(tile)
        max_mtime = self.expire_timestamp(tile)
        if cached and max_mtime is not None:
            self.cache.load_tile_metadata(tile)
            stale = tile.timestamp < max_mtime
            if stale:
                cached = False
        return cached

    def is_stale(self, tile, dimensions=None):
        """
        Return True if tile exists _and_ is expired.
        """
        if isinstance(tile, tuple):
            tile = Tile(tile)
        if self.cache.is_cached(tile):
            # tile exists
            if not self.is_cached(tile):
                # expired
                return True
            return False
        return False

    def expire_timestamp(self, tile=None):
        """
        Return the timestamp until which a tile should be accepted as up-to-date,
        or ``None`` if the tiles should not expire.

        :note: Returns _expire_timestamp by default.
        """
        return self._expire_timestamp

    def apply_tile_filter(self, tile):
        """
        Apply all `pre_store_filter` to this tile.
        Returns filtered tile.
        """
        if tile.stored:
            return tile

        for img_filter in self.pre_store_filter:
            tile = img_filter(tile)
        return tile

class TileCreator(object):
    def __init__(self, tile_mgr, dimensions=None):
        self.cache = tile_mgr.cache
        self.sources = tile_mgr.sources
        self.grid = tile_mgr.grid
        self.meta_grid = tile_mgr.meta_grid
        self.tile_mgr = tile_mgr
        self.dimensions = dimensions

    def is_cached(self, tile):
        """
        Return True if the tile is cached.
        """
        return self.tile_mgr.is_cached(tile)

    def create_tiles(self, tiles):
        if not self.meta_grid:
            created_tiles = self._create_single_tiles(tiles)
        elif self.tile_mgr.minimize_meta_requests and len(tiles) > 1:
            # use minimal requests only for mulitple tile requests (ie not for TMS)
            meta_tile = self.meta_grid.minimal_meta_tile([t.coord for t in tiles])
            created_tiles = self._create_meta_tile(meta_tile)
        else:
            meta_tiles = []
            meta_bboxes = set()
            for tile in tiles:
                meta_tile = self.meta_grid.meta_tile(tile.coord)
                if meta_tile.bbox not in meta_bboxes:
                    meta_tiles.append(meta_tile)
                    meta_bboxes.add(meta_tile.bbox)

            created_tiles = self._create_meta_tiles(meta_tiles)

        return created_tiles

    def _create_single_tiles(self, tiles):
        if self.tile_mgr.concurrent_tile_creators > 1 and len(tiles) > 1:
            return self._create_threaded(self._create_single_tile, tiles)

        created_tiles = []
        for tile in tiles:
            created_tiles.extend(self._create_single_tile(tile))
        return created_tiles

    def _create_threaded(self, create_func, tiles):
        result = []
        async_pool = async.Pool(self.tile_mgr.concurrent_tile_creators)
        for new_tiles in async_pool.imap(create_func, tiles):
            result.extend(new_tiles)
        return result

    def _create_single_tile(self, tile):
        tile_bbox = self.grid.tile_bbox(tile.coord)
        query = MapQuery(tile_bbox, self.grid.tile_size, self.grid.srs,
                         self.tile_mgr.request_format, dimensions=self.dimensions)
        with self.tile_mgr.lock(tile):
            if not self.is_cached(tile):
                source = self._query_sources(query)
                if not source: return []
                # call as_buffer to force conversion into cache format
                source.as_buffer(self.tile_mgr.image_opts)
                source.image_opts = self.tile_mgr.image_opts
                tile.source = source
                tile.cacheable = source.cacheable
                tile = self.tile_mgr.apply_tile_filter(tile)
                if source.cacheable:
                    self.cache.store_tile(tile)
            else:
                self.cache.load_tile(tile)
        return [tile]

    def _query_sources(self, query):
        """
        Query all sources and return the results as a single ImageSource.
        Multiple sources will be merged into a single image.
        """
        if len(self.sources) == 1:
            try:
                return self.sources[0].get_map(query)
            except BlankImage:
                return None

        def get_map_from_source(source):
            try:
                img = source.get_map(query)
            except BlankImage:
                return None
            else:
                return img

        imgs = []
        for img in async.imap(get_map_from_source, self.sources):
            if img is not None:
                imgs.append(img)

        if not imgs: return None
        return merge_images(imgs, size=query.size, image_opts=self.tile_mgr.image_opts)

    def _create_meta_tiles(self, meta_tiles):
        if self.tile_mgr.concurrent_tile_creators > 1 and len(meta_tiles) > 1:
            return self._create_threaded(self._create_meta_tile, meta_tiles)

        created_tiles = []
        for meta_tile in meta_tiles:
            created_tiles.extend(self._create_meta_tile(meta_tile))
        return created_tiles

    def _create_meta_tile(self, meta_tile):
        tile_size = self.grid.tile_size
        query = MapQuery(meta_tile.bbox, meta_tile.size, self.grid.srs, self.tile_mgr.request_format,
            dimensions=self.dimensions)
        main_tile = Tile(meta_tile.main_tile_coord)
        with self.tile_mgr.lock(main_tile):
            if not all(self.is_cached(t) for t in meta_tile.tiles if t is not None):
                meta_tile_image = self._query_sources(query)
                if not meta_tile_image: return []
                splitted_tiles = split_meta_tiles(meta_tile_image, meta_tile.tile_patterns,
                                                  tile_size, self.tile_mgr.image_opts)
                splitted_tiles = map(self.tile_mgr.apply_tile_filter, splitted_tiles)
                if meta_tile_image.cacheable:
                    self.cache.store_tiles(splitted_tiles)
                return splitted_tiles
        # else
        tiles = [Tile(coord) for coord in meta_tile.tiles]
        self.cache.load_tiles(tiles)
        return tiles

class Tile(object):
    """
    Internal data object for all tiles. Stores the tile-``coord`` and the tile data.

    :ivar source: the data of this tile
    :type source: ImageSource
    """
    def __init__(self, coord, source=None, cacheable=True):
        self.coord = coord
        self.source = source
        self.location = None
        self.stored = False
        self._cacheable = cacheable
        self.size = None
        self.timestamp = None

    def _cacheable_get(self):
        return CacheInfo(cacheable=self._cacheable, timestamp=self.timestamp,
            size=self.size)

    def _cacheable_set(self, cacheable):
        if isinstance(cacheable, bool):
            self._cacheable = cacheable
        else: # assume cacheable is CacheInfo
            self._cacheable = cacheable.cacheable
            self.timestamp = cacheable.timestamp
            self.size = cacheable.size

    cacheable = property(_cacheable_get, _cacheable_set)

    def source_buffer(self, *args, **kw):
        if self.source is not None:
            return self.source.as_buffer(*args, **kw)
        else:
            return None

    def source_image(self, *args, **kw):
        if self.source is not None:
            return self.source.as_image(*args, **kw)
        else:
            return None

    def is_missing(self):
        """
        Returns ``True`` when the tile has no ``data``, except when the ``coord``
        is ``None``. It doesn't check if the tile exists.

        >>> Tile((1, 2, 3)).is_missing()
        True
        >>> Tile((1, 2, 3), './tmp/foo').is_missing()
        False
        >>> Tile(None).is_missing()
        False
        """
        if self.coord is None:
            return False
        return self.source is None

    def __eq__(self, other):
        """
        >>> Tile((0, 0, 1)) == Tile((0, 0, 1))
        True
        >>> Tile((0, 0, 1)) == Tile((1, 0, 1))
        False
        >>> Tile((0, 0, 1)) == None
        False
        """
        if isinstance(other, Tile):
            return  (self.coord == other.coord and
                     self.source == other.source)
        else:
            return NotImplemented
    def __ne__(self, other):
        """
        >>> Tile((0, 0, 1)) != Tile((0, 0, 1))
        False
        >>> Tile((0, 0, 1)) != Tile((1, 0, 1))
        True
        >>> Tile((0, 0, 1)) != None
        True
        """
        equal_result = self.__eq__(other)
        if equal_result is NotImplemented:
            return NotImplemented
        else:
            return not equal_result

    def __repr__(self):
        return 'Tile(%r, source=%r)' % (self.coord, self.source)

class CacheInfo(object):
    def __init__(self, cacheable=True, timestamp=None, size=None):
        self.cacheable = cacheable
        self.timestamp = timestamp
        self.size = size

    def __nonzero__(self):
        return self.cacheable

class TileCollection(object):
    def __init__(self, tile_coords):
        self.tiles = [Tile(coord) for coord in tile_coords]
        self.tiles_dict = {}
        for tile in self.tiles:
            self.tiles_dict[tile.coord] = tile

    def __getitem__(self, idx_or_coord):
        if isinstance(idx_or_coord, int):
            return self.tiles[idx_or_coord]
        if idx_or_coord in self.tiles_dict:
            return self.tiles_dict[idx_or_coord]
        return Tile(idx_or_coord)

    def __contains__(self, tile_or_coord):
        if isinstance(tile_or_coord, tuple):
            return tile_or_coord in self.tiles_dict
        if hasattr(tile_or_coord, 'coord'):
            return tile_or_coord.coord in self.tiles_dict
        return False

    def __len__(self):
        return len(self.tiles)

    def __iter__(self):
        return iter(self.tiles)

    @property
    def empty(self):
        """
        Returns True if no tile in this collection contains a source.
        """
        return all((t.source is None for t in self.tiles))

    def __repr__(self):
        return 'TileCollection(%r)' % self.tiles


def split_meta_tiles(meta_tile, tiles, tile_size, image_opts):
    try:
        # TODO png8
        # if not self.transparent and format == 'png':
        #     format = 'png8'
        splitter = TileSplitter(meta_tile, image_opts)
    except IOError:
        # TODO
        raise
    split_tiles = []
    for tile in tiles:
        tile_coord, crop_coord = tile
        if tile_coord is None: continue
        data = splitter.get_tile(crop_coord, tile_size)
        new_tile = Tile(tile_coord, cacheable=meta_tile.cacheable)
        new_tile.source = data
        split_tiles.append(new_tile)
    return split_tiles

########NEW FILE########
__FILENAME__ = cgi
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
HTTP client that directly calls CGI executable.
"""

import errno
import os
import re
import time

from mapproxy.source import SourceError
from mapproxy.image import ImageSource
from mapproxy.client.http import HTTPClientError
from mapproxy.client.log import log_request
from mapproxy.util.async import import_module
from StringIO import StringIO
from urlparse import urlparse

subprocess = import_module('subprocess')

def split_cgi_response(data):
    headers = []
    prev_n = 0
    while True:
        next_n = data.find('\n', prev_n)
        if next_n < 0:
            break 
        next_line_begin = data[next_n+1:next_n+3]
        headers.append(data[prev_n:next_n].rstrip('\r'))
        if next_line_begin[0] == '\n':
            return headers_dict(headers), data[next_n+2:]
        elif next_line_begin == '\r\n':
            return headers_dict(headers), data[next_n+3:]
        prev_n = next_n+1
    return {}, data

def headers_dict(header_lines):
    headers = {}
    for line in header_lines:
        if ':' in line:
            key, value = line.split(':', 1)
            value = value.strip()
        else:
            key = line
            value = None
        key = key[0].upper() + key[1:].lower()
        headers[key] = value
    return headers

class CGIClient(object):
    def __init__(self, script, no_headers=False, working_directory=None):
        self.script = script
        self.working_directory = working_directory
        self.no_headers = no_headers
    
    def open(self, url, data=None):
        assert data is None, 'POST requests not supported by CGIClient'
        
        parsed_url = urlparse(url)
        environ = os.environ.copy()
        environ.update({
            'QUERY_STRING': parsed_url.query,
            'REQUEST_METHOD': 'GET',
            'GATEWAY_INTERFACE': 'CGI/1.1',
            'SERVER_ADDR': '127.0.0.1',
            'SERVER_NAME': 'localhost',
            'SERVER_PROTOCOL': 'HTTP/1.0',
            'SERVER_SOFTWARE': 'MapProxy',
        })
        
        start_time = time.time()
        try:
            p = subprocess.Popen([self.script], env=environ,
                stdout=subprocess.PIPE,
                cwd=self.working_directory or os.path.dirname(self.script)
            )
        except OSError, ex:
            if ex.errno == errno.ENOENT:
                raise SourceError('CGI script not found (%s)' % (self.script,))
            elif ex.errno == errno.EACCES:
                raise SourceError('No permission for CGI script (%s)' % (self.script,))
            else:
                raise
            
        stdout = p.communicate()[0]
        ret = p.wait()
        if ret != 0:
            raise HTTPClientError('Error during CGI call (exit code: %d)' 
                                              % (ret, ))
        
        if self.no_headers:
            content = stdout
            headers = dict()
        else:
            headers, content = split_cgi_response(stdout)
        
        status_match = re.match('(\d\d\d) ', headers.get('Status', ''))
        if status_match:
            status_code = status_match.group(1)
        else:
            status_code = '-'
        size = len(content)
        content = StringIO(content)
        content.headers = headers
        
        log_request('%s:%s' % (self.script, parsed_url.query),
            status_code, size=size, method='CGI', duration=time.time()-start_time)
        return content
    
    def open_image(self, url, data=None):
        resp = self.open(url, data=data)
        if 'Content-type' in resp.headers:
            if not resp.headers['Content-type'].lower().startswith('image'):
                raise HTTPClientError('response is not an image: (%s)' % (resp.read()))
        return ImageSource(resp)


########NEW FILE########
__FILENAME__ = http
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Tile retrieval (WMS, TMS, etc.).
"""
import sys
import time
import httplib
import urllib2
from urllib2 import URLError, HTTPError
from urlparse import urlsplit
import warnings

from mapproxy.version import version
from mapproxy.image import ImageSource
from mapproxy.util.py import reraise_exception
from mapproxy.client.log import log_request

import socket

class HTTPClientError(Exception):
    def __init__(self, arg, response_code=None):
        Exception.__init__(self, arg)
        self.response_code = response_code

if sys.version_info >= (2, 6):
    _urllib2_has_timeout = True
else:
    _urllib2_has_timeout = False

_max_set_timeout = None

try:
    import ssl
    ssl # prevent pyflakes warnings
except ImportError:
    ssl = None


def _set_global_socket_timeout(timeout):
    global _max_set_timeout
    if _max_set_timeout is None:
        _max_set_timeout = timeout
    elif _max_set_timeout != timeout:
        _max_set_timeout = max(_max_set_timeout, timeout)
        warnings.warn("Python >=2.6 required for individual HTTP timeouts. Setting global timeout to %.1f." %
                     _max_set_timeout)
    socket.setdefaulttimeout(_max_set_timeout)


class _URLOpenerCache(object):
    """
    Creates custom URLOpener with BasicAuth and HTTPS handler.

    Caches and reuses opener if possible (i.e. if they share the same
    ssl_ca_certs).
    """
    def __init__(self):
        self._opener = {}

    def __call__(self, ssl_ca_certs, url, username, password):
        if ssl_ca_certs not in self._opener:
            handlers = []
            if ssl_ca_certs:
                connection_class = verified_https_connection_with_ca_certs(ssl_ca_certs)
                https_handler = VerifiedHTTPSHandler(connection_class=connection_class)
                handlers.append(https_handler)
            passman = urllib2.HTTPPasswordMgrWithDefaultRealm()
            authhandler = urllib2.HTTPBasicAuthHandler(passman)
            handlers.append(authhandler)
            authhandler = urllib2.HTTPDigestAuthHandler(passman)
            handlers.append(authhandler)

            opener = urllib2.build_opener(*handlers)
            opener.addheaders = [('User-agent', 'MapProxy-%s' % (version,))]

            self._opener[ssl_ca_certs] = (opener, passman)
        else:
            opener, passman = self._opener[ssl_ca_certs]

        if url is not None and username is not None and password is not None:
            passman.add_password(None, url, username, password)

        return opener

create_url_opener = _URLOpenerCache()

class HTTPClient(object):
    def __init__(self, url=None, username=None, password=None, insecure=False,
                 ssl_ca_certs=None, timeout=None, headers=None):
        if _urllib2_has_timeout:
            self._timeout = timeout
        else:
            self._timeout = None
            _set_global_socket_timeout(timeout)
        if url and url.startswith('https'):
            if insecure:
                ssl_ca_certs = None
            else:
                if ssl is None:
                    raise ImportError('No ssl module found. SSL certificate '
                        'verification requires Python 2.6 or ssl module. Upgrade '
                        'or disable verification with http.ssl_no_cert_checks option.')
                if ssl_ca_certs is None:
                    raise HTTPClientError('No ca_certs file set (http.ssl_ca_certs). '
                        'Set file or disable verification with http.ssl_no_cert_checks option.')

        self.opener = create_url_opener(ssl_ca_certs, url, username, password)
        self.header_list = headers.items() if headers else []

    def open(self, url, data=None):
        code = None
        result = None
        req = urllib2.Request(url, data=data)
        for key, value in self.header_list:
            req.add_header(key, value)
        try:
            start_time = time.time()
            if self._timeout is not None:
                result = self.opener.open(req, timeout=self._timeout)
            else:
                result = self.opener.open(req)
        except HTTPError, e:
            code = e.code
            reraise_exception(HTTPClientError('HTTP Error "%s": %d'
                % (url, e.code), response_code=code), sys.exc_info())
        except URLError, e:
            if ssl and isinstance(e.reason, ssl.SSLError):
                e = HTTPClientError('Could not verify connection to URL "%s": %s'
                                     % (url, e.reason.args[1]))
                reraise_exception(e, sys.exc_info())
            try:
                reason = e.reason.args[1]
            except (AttributeError, IndexError):
                reason = e.reason
            reraise_exception(HTTPClientError('No response from URL "%s": %s'
                                              % (url, reason)), sys.exc_info())
        except ValueError, e:
            reraise_exception(HTTPClientError('URL not correct "%s": %s'
                                              % (url, e.args[0])), sys.exc_info())
        except Exception, e:
            reraise_exception(HTTPClientError('Internal HTTP error "%s": %r'
                                              % (url, e)), sys.exc_info())
        else:
            code = getattr(result, 'code', 200)
            if code == 204:
                raise HTTPClientError('HTTP Error "204 No Content"', response_code=204)
            return result
        finally:
            log_request(url, code, result, duration=time.time()-start_time, method=req.get_method())

    def open_image(self, url, data=None):
        resp = self.open(url, data=data)
        if 'content-type' in resp.headers:
            if not resp.headers['content-type'].lower().startswith('image'):
                raise HTTPClientError('response is not an image: (%s)' % (resp.read()))
        return ImageSource(resp)

def auth_data_from_url(url):
    """
    >>> auth_data_from_url('http://localhost/bar')
    ('http://localhost/bar', (None, None))
    >>> auth_data_from_url('http://bar@localhost/bar')
    ('http://localhost/bar', ('bar', None))
    >>> auth_data_from_url('http://bar:baz@localhost/bar')
    ('http://localhost/bar', ('bar', 'baz'))
    >>> auth_data_from_url('http://bar:b:az@@localhost/bar')
    ('http://localhost/bar', ('bar', 'b:az@'))
    >>> auth_data_from_url('http://bar foo; foo@bar:b:az@@localhost/bar')
    ('http://localhost/bar', ('bar foo; foo@bar', 'b:az@'))
    """
    username = password = None
    if '@' in url:
        scheme, host, path, query, frag = urlsplit(url)
        if '@' in host:
            auth_data, host = host.rsplit('@', 1)
            url = url.replace(auth_data+'@', '', 1)
            if ':' in auth_data:
                username, password = auth_data.split(':', 1)
            else:
                username = auth_data
    return url, (username, password)


_http_client = HTTPClient()
def open_url(url):
    return _http_client.open(url)

retrieve_url = open_url

def retrieve_image(url, client=None):
    """
    Retrive an image from `url`.

    :return: the image as a file object (with url .header and .info)
    :raise HTTPClientError: if response content-type doesn't start with image
    """
    resp = open_url(url)
    if not resp.headers['content-type'].startswith('image'):
        raise HTTPClientError('response is not an image: (%s)' % (resp.read()))
    return ImageSource(resp)


class VerifiedHTTPSConnection(httplib.HTTPSConnection):
    def __init__(self, *args, **kw):
        self._ca_certs = kw.pop('ca_certs', None)
        httplib.HTTPSConnection.__init__(self, *args, **kw)

    def connect(self):
        # overrides the version in httplib so that we do
        #    certificate verification

        if hasattr(socket, 'create_connection') and hasattr(self, 'source_address'):
            sock = socket.create_connection((self.host, self.port),
                self.timeout, self.source_address)
        else:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.host, self.port))

        if hasattr(self, '_tunnel_host') and self._tunnel_host:
            # for Python >= 2.6 with proxy support
            self.sock = sock
            self._tunnel()

        # wrap the socket using verification with the root
        #    certs in self.ca_certs_path
        self.sock = ssl.wrap_socket(sock,
                                    self.key_file,
                                    self.cert_file,
                                    cert_reqs=ssl.CERT_REQUIRED,
                                    ca_certs=self._ca_certs)

def verified_https_connection_with_ca_certs(ca_certs):
    """
    Creates VerifiedHTTPSConnection classes with given ca_certs file.
    """
    def wrapper(*args, **kw):
        kw['ca_certs'] = ca_certs
        return VerifiedHTTPSConnection(*args, **kw)
    return wrapper

class VerifiedHTTPSHandler(urllib2.HTTPSHandler):
    def __init__(self, connection_class=VerifiedHTTPSConnection):
        self.specialized_conn_class = connection_class
        urllib2.HTTPSHandler.__init__(self)

    def https_open(self, req):
        return self.do_open(self.specialized_conn_class, req)
########NEW FILE########
__FILENAME__ = log
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import logging
logger = logging.getLogger('mapproxy.source.request')

def log_request(url, status, result=None, size=None, method='GET', duration=None):
    if not logger.isEnabledFor(logging.INFO):
        return
    
    if not size and result is not None:
        size = result.headers.get('Content-length')
    if size:
        size = '%.1f' % (int(size)/1024.0, )
    else:
        size = '-'
    if not status:
        status = '-'
    duration = '%d' % (duration*1000) if duration else '-'
    logger.info('%s %s %s %s %s', method, url.replace(' ', ''), status, size, duration)
    
########NEW FILE########
__FILENAME__ = tile
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from mapproxy.client.http import retrieve_image

class TMSClient(object):
    def __init__(self, url, format='png', http_client=None):
        self.url = url
        self.http_client = http_client
        self.format = format
    
    def get_tile(self, tile_coord, format=None):
        x, y, z = tile_coord
        url = '%s/%d/%d/%d.%s' % (self.url, z, x, y, format or self.format)
        if self.http_client:
            return self.http_client.open_image(url)
        else:
            return retrieve_image(url)
    
    def __repr__(self):
        return '%s(%r, %r)' % (self.__class__.__name__, self.url, self.format)

class TileClient(object):
    def __init__(self, url_template, http_client=None, grid=None):
        self.url_template = url_template
        self.http_client = http_client
        self.grid = grid
    
    def get_tile(self, tile_coord, format=None):
        url = self.url_template.substitute(tile_coord, format, self.grid)
        if self.http_client:
            return self.http_client.open_image(url)
        else:
            return retrieve_image(url)
    
    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.url_template)

class TileURLTemplate(object):
    """
    >>> t = TileURLTemplate('http://foo/tiles/%(z)s/%(x)d/%(y)s.png')
    >>> t.substitute((7, 4, 3))
    'http://foo/tiles/3/7/4.png'

    >>> t = TileURLTemplate('http://foo/tiles/%(z)s/%(x)d/%(y)s.png')
    >>> t.substitute((7, 4, 3))
    'http://foo/tiles/3/7/4.png'

    >>> t = TileURLTemplate('http://foo/tiles/%(tc_path)s.png')
    >>> t.substitute((7, 4, 3))
    'http://foo/tiles/03/000/000/007/000/000/004.png'
    
    >>> t = TileURLTemplate('http://foo/tms/1.0.0/%(tms_path)s.%(format)s')
    >>> t.substitute((7, 4, 3))
    'http://foo/tms/1.0.0/3/7/4.png'
    
    >>> t = TileURLTemplate('http://foo/tms/1.0.0/lyr/%(tms_path)s.%(format)s')
    >>> t.substitute((7, 4, 3), 'jpeg')
    'http://foo/tms/1.0.0/lyr/3/7/4.jpeg'
    
    """
    def __init__(self, template, format='png'):
        self.template= template
        self.format = format
        self.with_quadkey = True if '%(quadkey)' in template else False
        self.with_tc_path = True if '%(tc_path)' in template else False
        self.with_tms_path = True if '%(tms_path)' in template else False
        self.with_arcgiscache_path = True if '%(arcgiscache_path)' in template else False
        self.with_bbox = True if '%(bbox)' in template else False

    def substitute(self, tile_coord, format=None, grid=None):
        x, y, z = tile_coord
        data = dict(x=x, y=y, z=z)
        data['format'] = format or self.format
        if self.with_quadkey:
            data['quadkey'] = quadkey(tile_coord)
        if self.with_tc_path:
            data['tc_path'] = tilecache_path(tile_coord)
        if self.with_tms_path:
            data['tms_path'] = tms_path(tile_coord)
        if self.with_arcgiscache_path:
            data['arcgiscache_path'] = arcgiscache_path(tile_coord)
        if self.with_bbox:
            data['bbox'] = bbox(tile_coord, grid)

        return self.template % data
    
    def __repr__(self):
        return '%s(%r, format=%r)' % (
            self.__class__.__name__, self.template, self.format)

def tilecache_path(tile_coord):
    """
    >>> tilecache_path((1234567, 87654321, 9))
    '09/001/234/567/087/654/321'
    """
    x, y, z = tile_coord
    parts = ("%02d" % z,
             "%03d" % int(x / 1000000),
             "%03d" % (int(x / 1000) % 1000),
             "%03d" % (int(x) % 1000),
             "%03d" % int(y / 1000000),
             "%03d" % (int(y / 1000) % 1000),
             "%03d" % (int(y) % 1000))
    return '/'.join(parts)

def quadkey(tile_coord):
    """
    >>> quadkey((0, 0, 1))
    '0'
    >>> quadkey((1, 0, 1))
    '1'
    >>> quadkey((1, 2, 2))
    '21'
    """
    x, y, z = tile_coord
    quadKey = ""
    for i in range(z,0,-1):
        digit = 0
        mask = 1 << (i-1)
        if (x & mask) != 0:
            digit += 1
        if (y & mask) != 0:
            digit += 2
        quadKey += str(digit)
    return quadKey

def tms_path(tile_coord):
    """
    >>> tms_path((1234567, 87654321, 9))
    '9/1234567/87654321'
    """
    return '%d/%d/%d' % (tile_coord[2], tile_coord[0], tile_coord[1])

def arcgiscache_path(tile_coord):
   """
   >>> arcgiscache_path((1234567, 87654321, 9))
   'L09/R05397fb1/C0012d687'
   """
   return 'L%02d/R%08x/C%08x' % (tile_coord[2], tile_coord[1], tile_coord[0])

def bbox(tile_coord, grid):
    """
    >>> from mapproxy.grid import tile_grid
    >>> grid = tile_grid(4326, bbox=(0, -15, 10, -5))
    >>> bbox((0, 0, 0), grid)
    '0.00000000,-15.00000000,10.00000000,-5.00000000'
    >>> bbox((0, 0, 1), grid)
    '0.00000000,-15.00000000,5.00000000,-10.00000000'
    
    >>> grid = tile_grid(4326, bbox=(0, -15, 10, -5), origin='nw')
    >>> bbox((0, 0, 1), grid)
    '0.00000000,-10.00000000,5.00000000,-5.00000000'
    """
    return '%.8f,%.8f,%.8f,%.8f' % grid.tile_bbox(tile_coord)

########NEW FILE########
__FILENAME__ = wms
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
WMS clients for maps and information.
"""
from __future__ import with_statement
from mapproxy.request.base import split_mime_type
from mapproxy.layer import InfoQuery
from mapproxy.source import SourceError
from mapproxy.client.http import HTTPClient
from mapproxy.srs import make_lin_transf, SRS
from mapproxy.image import ImageSource
from mapproxy.image.opts import ImageOptions
from mapproxy.featureinfo import create_featureinfo_doc

import logging
log = logging.getLogger('mapproxy.source.wms')

class WMSClient(object):
    def __init__(self, request_template, http_client=None,
                 http_method=None, lock=None, fwd_req_params=None):
        self.request_template = request_template
        self.http_client = http_client or HTTPClient()
        self.http_method = http_method
        self.lock = lock
        self.fwd_req_params = fwd_req_params or set()

    def retrieve(self, query, format):
        if self.http_method == 'POST':
            request_method = 'POST'
        elif self.http_method == 'GET':
            request_method = 'GET'
        else: # 'AUTO'
            if 'sld_body' in self.request_template.params:
                request_method = 'POST'
            else:
                request_method = 'GET'

        if request_method == 'POST':
            url, data = self._query_data(query, format)
        else:
            url = self._query_url(query, format)
            data = None

        if self.lock:
            with self.lock():
                resp = self.http_client.open(url, data=data)
        else:
            resp = self.http_client.open(url, data=data)
        self._check_resp(resp, url)
        return resp

    def _check_resp(self, resp, url):
        if not resp.headers.get('Content-type', 'image/').startswith('image/'):
            # log response depending on content-type
            if resp.headers['Content-type'].startswith(('text/', 'application/vnd.ogc')):
                log_size = 8000 # larger xml exception
            else:
                log_size = 100 # image?
            data = resp.read(log_size)
            if len(data) == log_size:
                data += '... truncated'
            log.warn("no image returned from source WMS: %s, response was: %s" % (url, data))
            raise SourceError('no image returned from source WMS: %s' % (url, ))

    def _query_url(self, query, format):
        return self._query_req(query, format).complete_url

    def _query_data(self, query, format):
        req = self._query_req(query, format)
        return req.url.rstrip('?'), req.query_string

    def _query_req(self, query, format):
        req = self.request_template.copy()
        req.params.bbox = query.bbox
        req.params.size = query.size
        req.params.srs = query.srs.srs_code
        req.params.format = format
        # also forward dimension request params if available in the query
        req.params.update(query.dimensions_for_params(self.fwd_req_params))
        return req

    def combined_client(self, other, query):
        """
        Return a new WMSClient that combines this request with the `other`. Returns
        ``None`` if the clients are not combinable (e.g. different URLs).
        """
        if self.request_template.url != other.request_template.url:
            return None

        new_req = self.request_template.copy()
        new_req.params.layers = new_req.params.layers + other.request_template.params.layers

        return WMSClient(new_req, http_client=self.http_client,
                http_method=self.http_method, fwd_req_params=self.fwd_req_params)


class WMSInfoClient(object):
    def __init__(self, request_template, supported_srs=None, http_client=None):
        self.request_template = request_template
        self.http_client = http_client or HTTPClient()
        if not supported_srs and self.request_template.params.srs is not None:
            supported_srs = [SRS(self.request_template.params.srs)]
        self.supported_srs = supported_srs or []

    def get_info(self, query):
        if self.supported_srs and query.srs not in self.supported_srs:
            query = self._get_transformed_query(query)
        resp = self._retrieve(query)
        info_format = resp.headers.get('Content-type', None)
        if not info_format:
            info_format = query.info_format
        return create_featureinfo_doc(resp.read(), info_format)

    def _get_transformed_query(self, query):
        """
        Handle FI requests for unsupported SRS.
        """
        req_srs = query.srs
        req_bbox = query.bbox
        info_srs = self._best_supported_srs(req_srs)
        info_bbox = req_srs.transform_bbox_to(info_srs, req_bbox)

        req_coord = make_lin_transf((0, query.size[1], query.size[0], 0), req_bbox)(query.pos)

        info_coord = req_srs.transform_to(info_srs, req_coord)
        info_pos = make_lin_transf((info_bbox), (0, query.size[1], query.size[0], 0))(info_coord)

        info_query = InfoQuery(info_bbox, query.size, info_srs, info_pos, query.info_format)
        return info_query

    def _best_supported_srs(self, srs):
        # always choose the first, distortion should not matter
        return self.supported_srs[0]

    def _retrieve(self, query):
        url = self._query_url(query)
        return self.http_client.open(url)

    def _query_url(self, query):
        req = self.request_template.copy()
        req.params.bbox = query.bbox
        req.params.size = query.size
        req.params.pos = query.pos
        if query.feature_count:
            req.params['feature_count'] = query.feature_count
        req.params['query_layers'] = req.params['layers']
        if not 'info_format' in req.params and query.info_format:
            req.params['info_format'] = query.info_format
        if not req.params.format:
            req.params.format = query.format or 'image/png'
        req.params.srs = query.srs.srs_code

        return req.complete_url

class WMSLegendClient(object):
    def __init__(self, request_template, http_client=None):
        self.request_template = request_template
        self.http_client = http_client or HTTPClient()

    def get_legend(self, query):
        resp = self._retrieve(query)
        format = split_mime_type(query.format)[1]
        self._check_resp(resp)
        return ImageSource(resp, image_opts=ImageOptions(format=format))

    def _retrieve(self, query):
        url = self._query_url(query)
        return self.http_client.open(url)

    def _check_resp(self, resp):
        if not resp.headers.get('Content-type', 'image/').startswith('image/'):
            raise SourceError('no image returned from source WMS')

    def _query_url(self, query):
        req = self.request_template.copy()
        if not req.params.format:
            req.params.format = query.format or 'image/png'
        if query.scale:
            req.params['scale'] = query.scale
        return req.complete_url

    @property
    def identifier(self):
        return (self.request_template.url, self.request_template.params.layer)

class WMSLegendURLClient(object):
    def __init__(self, static_url, http_client=None):
        self.url = static_url
        self.http_client = http_client or HTTPClient()

    def get_legend(self, query):
        resp = self.http_client.open(self.url)
        format = split_mime_type(query.format)[1]
        self._check_resp(resp)
        return ImageSource(resp, image_opts=ImageOptions(format=format))

    def _check_resp(self, resp):
        if not resp.headers.get('Content-type', 'image/').startswith('image/'):
            raise SourceError('no image returned from static LegendURL')

    @property
    def identifier(self):
        return (self.url, None)


########NEW FILE########
__FILENAME__ = config
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
System-wide configuration.
"""
from __future__ import with_statement
import os
import copy
import contextlib
from mapproxy.util.yaml import load_yaml_file
from mapproxy.util.ext.local import LocalStack

class Options(dict):
    """
    Dictionary with attribute style access.

    >>> o = Options(bar='foo')
    >>> o.bar
    'foo'
    """
    def __repr__(self):
        return '%s(%s)' % (self.__class__.__name__, dict.__repr__(self))

    def __getattr__(self, name):
        if name in self:
            return self[name]
        else:
            raise AttributeError(name)

    __setattr__ = dict.__setitem__

    def __delattr__(self, name):
        if name in self:
            del self[name]
        else:
            raise AttributeError(name)

    def update(self, other=None, **kw):
        if other is not None:
            if hasattr(other, 'iteritems'):
                it = other.iteritems()
            else:
                it = iter(other)
        else:
            it = iter(kw)
        for key, value in it:
            if key in self and isinstance(self[key], Options):
                self[key].update(value)
            else:
                self[key] = value

    def __deepcopy__(self, memo):
        return Options(copy.deepcopy(self.items(), memo))

_config = LocalStack()
def base_config():
    """
    Returns the context-local system-wide configuration.
    """
    config = _config.top
    if config is None:
        import warnings
        import sys
        if 'nosetests' not in sys.argv[0]:
            warnings.warn("calling un-configured base_config",
                DeprecationWarning, stacklevel=2)
        config = load_default_config()
        config.conf_base_dir = os.getcwd()
        finish_base_config(config)
        _config.push(config)
    return config

@contextlib.contextmanager
def local_base_config(conf):
    """
    Temporarily set the global configuration (mapproxy.config.base_config).

    The global mapproxy.config.base_config object is thread-local and
    is set per-request in the MapProxyApp. Use `local_base_config` to
    set base_config outside of a request context (e.g. system loading
    or seeding).
    """
    import mapproxy.config.config
    mapproxy.config.config._config.push(conf)
    try:
        yield
    finally:
        mapproxy.config.config._config.pop()

def _to_options_map(mapping):
    if isinstance(mapping, dict):
        opt = Options()
        for key, value in mapping.iteritems():
            opt[key] = _to_options_map(value)
        return opt
    elif isinstance(mapping, list):
        return [_to_options_map(m) for m in mapping]
    else:
        return mapping

def abspath(path, base_path=None):
    """
    Convert path to absolute path. Uses ``conf_base_dir`` as base, if
    path is relative and ``base_path`` is not set.
    """
    if base_path:
        return os.path.abspath(os.path.join(base_path, path))
    return os.path.join(base_config().conf_base_dir, path)


def finish_base_config(bc=None):
    bc = bc or base_config()
    if 'srs' in bc:
        # build union of default axis_order_xx_ and the user configured axis_order_xx
        default_ne = bc.srs.axis_order_ne_
        default_en = bc.srs.axis_order_en_
        # remove from default to allow overwrites
        default_ne.difference_update(set(bc.srs.axis_order_en))
        default_en.difference_update(set(bc.srs.axis_order_ne))
        bc.srs.axis_order_ne = default_ne.union(set(bc.srs.axis_order_ne))
        bc.srs.axis_order_en = default_en.union(set(bc.srs.axis_order_en))
        if 'proj_data_dir' in bc.srs:
            bc.srs.proj_data_dir = os.path.join(bc.conf_base_dir, bc.srs.proj_data_dir)

    if 'wms' in bc:
        bc.wms.srs = set(bc.wms.srs)

    if 'conf_base_dir' in bc:
        if 'cache' in bc:
            if 'base_dir' in bc.cache:
                bc.cache.base_dir = os.path.join(bc.conf_base_dir, bc.cache.base_dir)
            if 'lock_dir' in bc.cache:
                bc.cache.lock_dir = os.path.join(bc.conf_base_dir, bc.cache.lock_dir)

def load_base_config(config_file=None, clear_existing=False):
    """
    Load system wide base configuration.

    :param config_file: the file name of the mapproxy.yaml configuration.
                        if ``None``, load the internal proxylib/default.yaml conf
    :param clear_existing: if ``True`` remove the existing configuration settings,
                           else overwrite the settings.
    """

    if config_file is None:
        from mapproxy.config import defaults
        config_dict = {}
        for k, v in defaults.__dict__.iteritems():
            if k.startswith('_'): continue
            config_dict[k] = v
        conf_base_dir = os.getcwd()
        load_config(base_config(), config_dict=config_dict, clear_existing=clear_existing)
    else:
        conf_base_dir = os.path.abspath(os.path.dirname(config_file))
        load_config(base_config(), config_file=config_file, clear_existing=clear_existing)

    bc = base_config()
    finish_base_config(bc)

    bc.conf_base_dir = conf_base_dir

def load_default_config():
    from mapproxy.config import defaults
    config_dict = {}
    for k, v in defaults.__dict__.iteritems():
        if k.startswith('_'): continue
        config_dict[k] = v

    default_conf = Options()
    load_config(default_conf, config_dict=config_dict)
    return default_conf

def load_config(config, config_file=None, config_dict=None, clear_existing=False):
    if clear_existing:
        for key in config.keys():
            del config[key]

    if config_dict is None:
        config_dict = load_yaml_file(config_file)

    defaults = _to_options_map(config_dict)

    if defaults:
        for key, value in defaults.iteritems():
            if key in config and hasattr(config[key], 'update'):
                config[key].update(value)
            else:
                config[key] = value

########NEW FILE########
__FILENAME__ = coverage
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

from mapproxy.srs import SRS
from mapproxy.config import abspath
from mapproxy.util.geom import (
    load_datasource,
    load_ogr_datasource,
    load_polygons,
    require_geom_support,
    build_multipolygon,
)
from mapproxy.util.coverage import coverage


bbox_string_re = re.compile(r'[-+]?\d*.?\d+,[-+]?\d*.?\d+,[-+]?\d*.?\d+,[-+]?\d*.?\d+')

def load_coverage(conf, base_path=None):
    if 'ogr_datasource' in conf:
        require_geom_support()
        srs = conf['ogr_srs']
        datasource = conf['ogr_datasource']
        if not re.match(r'^\w{2,}:', datasource):
            # looks like a file and not PG:, MYSQL:, etc
            # make absolute path
            datasource = abspath(datasource, base_path=base_path)
        where = conf.get('ogr_where', None)
        geom = load_ogr_datasource(datasource, where)
        bbox, geom = build_multipolygon(geom, simplify=True)
    elif 'polygons' in conf:
        require_geom_support()
        srs = conf['polygons_srs']
        geom = load_polygons(abspath(conf['polygons'], base_path=base_path))
        bbox, geom = build_multipolygon(geom, simplify=True)
    elif 'bbox' in conf:
        srs = conf.get('bbox_srs') or conf['srs']
        bbox = conf['bbox']
        if isinstance(bbox, basestring):
            bbox = map(float, bbox.split(','))
        geom = None
    elif 'datasource' in conf:
        require_geom_support()
        datasource = conf['datasource']
        srs = conf['srs']
        if isinstance(datasource, (list, tuple)):
            bbox = datasource
            geom = None
        elif bbox_string_re.match(datasource):
            bbox = map(float, datasource.split(','))
            geom = None
        else:
            if not re.match(r'^\w{2,}:', datasource):
                # looks like a file and not PG:, MYSQL:, etc
                # make absolute path
                datasource = abspath(datasource, base_path=base_path)
            where = conf.get('where', None)
            geom = load_datasource(datasource, where)
            bbox, geom = build_multipolygon(geom, simplify=True)
    else:
        return None
    return coverage(geom or bbox, SRS(srs))

########NEW FILE########
__FILENAME__ = defaults
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

server = ['wms', 'tms', 'kml']

wms = dict(
    image_formats = ['image/png', 'image/jpeg', 'image/gif', 'image/GeoTIFF', 'image/tiff'],
    srs = set(['EPSG:4326', 'EPSG:4258', 'CRS:84', 'EPSG:900913', 'EPSG:3857']),
    strict = False,
    request_parser = 'default',
    client_request = 'default',
    concurrent_layer_renderer = 1,
    max_output_pixels = 4000*4000,
)
debug_mode = False

srs = dict(
    # user sets
    axis_order_ne = set(),
    axis_order_en = set(),
    # default sets, both will be combined in config:load_base_config
    axis_order_ne_ = set(['EPSG:4326', 'EPSG:4258', 'EPSG:31466', 'EPSG:31467', 'EPSG:31468']),
    axis_order_en_ = set(['CRS:84', 'EPSG:900913', 'EPSG:25831', 'EPSG:25832', 'EPSG:25833']),
)

image = dict(
    # nearest, bilinear, bicubic
    resampling_method = 'bicubic',
    jpeg_quality = 90,
    stretch_factor = 1.15,
    max_shrink_factor = 4.0,
    paletted = True,
    transparent_color_tolerance = 5,
    font_dir = None,
)
# number of concurrent requests to a tile source


services_conf = 'services.yaml'
log_conf = 'log.ini'

# directory with mapproxy/service/templates/* files
template_dir = None

cache = dict(
    base_dir = './cache_data',
    lock_dir = './cache_data/tile_locks',
    max_tile_limit = 500,
    concurrent_tile_creators = 2,
    meta_size = (4, 4),
    meta_buffer = 80,
    minimize_meta_requests = False,
)

grid = dict(
    tile_size = (256, 256),
)

tiles = dict(
    expires_hours = 72,
)

http = dict(
    ssl_ca_certs = None,
    ssl_no_cert_checks = False,
    client_timeout = 60,
    concurrent_requests = 0,
    method = 'AUTO',
)

########NEW FILE########
__FILENAME__ = loader
# This file is part of the MapProxy project.
# Copyright (C) 2010-2012 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Configuration loading and system initializing.
"""
from __future__ import with_statement, division

import os
import sys
import hashlib
import urlparse
import warnings
from copy import deepcopy, copy
from functools import partial

import logging
log = logging.getLogger('mapproxy.config')

from mapproxy.config import load_default_config, finish_base_config
from mapproxy.config.spec import validate_mapproxy_conf
from mapproxy.util.py import memoize
from mapproxy.util.ext.odict import odict
from mapproxy.util.yaml import load_yaml_file, YAMLError

class ConfigurationError(Exception):
    pass

class ProxyConfiguration(object):
    def __init__(self, conf, conf_base_dir=None, seed=False, renderd=False):
        self.configuration = conf
        self.seed = seed
        self.renderd = renderd

        if conf_base_dir is None:
            conf_base_dir = os.getcwd()

        self.load_globals(conf_base_dir=conf_base_dir)
        self.load_grids()
        self.load_caches()
        self.load_sources()
        self.load_wms_root_layer()
        self.load_tile_layers()
        self.load_services()

    def load_globals(self, conf_base_dir):
        self.globals = GlobalConfiguration(conf_base_dir=conf_base_dir,
                                           conf=self.configuration.get('globals') or {},
                                           context=self)

    def load_grids(self):
        self.grids = {}

        self.grids['GLOBAL_GEODETIC'] = GridConfiguration(dict(srs='EPSG:4326', name='GLOBAL_GEODETIC'), context=self)
        self.grids['GLOBAL_MERCATOR'] = GridConfiguration(dict(srs='EPSG:900913', name='GLOBAL_MERCATOR'), context=self)
        self.grids['GLOBAL_WEBMERCATOR'] = GridConfiguration(dict(srs='EPSG:3857', origin='nw', name='GLOBAL_WEBMERCATOR'), context=self)

        for grid_name, grid_conf in (self.configuration.get('grids') or {}).iteritems():
            grid_conf.setdefault('name', grid_name)
            self.grids[grid_name] = GridConfiguration(grid_conf, context=self)

    def load_caches(self):
        self.caches = odict()
        caches_conf = self.configuration.get('caches')
        if not caches_conf: return
        if isinstance(caches_conf, list):
            caches_conf = list_of_dicts_to_ordered_dict(caches_conf)
        for cache_name, cache_conf in caches_conf.iteritems():
            cache_conf['name'] = cache_name
            self.caches[cache_name] = CacheConfiguration(conf=cache_conf, context=self)

    def load_sources(self):
        self.sources = SourcesCollection()
        for source_name, source_conf in (self.configuration.get('sources') or {}).iteritems():
            self.sources[source_name] = SourceConfiguration.load(conf=source_conf, context=self)

    def load_tile_layers(self):
        self.layers = odict()
        layers_conf = deepcopy(self._layers_conf_dict())
        if layers_conf is None: return
        layers = self._flatten_layers_conf_dict(layers_conf)
        for layer_name, layer_conf in layers.iteritems():
            layer_conf['name'] = layer_name
            self.layers[layer_name] = LayerConfiguration(conf=layer_conf, context=self)

    def _legacy_layers_conf_dict(self):
        """
        Read old style layer configuration with a dictionary where
        the key is the layer name. Optionally: a list an each layer
        is wrapped in such dictionary.

        ::
          layers:
            foo:
              title: xxx
              sources: []
            bar:
              title: xxx
              sources: []

        or

        ::

          layers:
            - foo:
               title: xxx
               sources: []
            - bar:
               title: xxx
               sources: []

        """
        warnings.warn('old layer configuration syntax is deprecated since 1.4.0. '
            'use list of dictionaries as documented', RuntimeWarning)
        layers = []
        layers_conf = self.configuration.get('layers')
        if not layers_conf: return None # TODO config error
        if isinstance(layers_conf, list):
            layers_conf = list_of_dicts_to_ordered_dict(layers_conf)
        for layer_name, layer_conf in layers_conf.iteritems():
            layer_conf['name'] = layer_name
            layers.append(layer_conf)
        return dict(title=None, layers=layers)


    def _layers_conf_dict(self):
        """
        Returns (recursive) layer configuration as a dictionary
        in unified structure:

        ::
            {
             title: 'xxx', # required, might be None
             name: 'xxx', # optional
             # sources or layers or both are required
             sources: [],
             layers: [
                {..., ...} # more layers like this
             ]
            }

        Multiple layers will be wrapped in an unnamed root layer, if the
        first level starts with multiple layers.
        """
        layers_conf = self.configuration.get('layers')
        if layers_conf is None: return

        if isinstance(layers_conf, list):
            if isinstance(layers_conf[0], dict) and len(layers_conf[0].keys()) == 1:
                # looks like ordered legacy config
                layers_conf = self._legacy_layers_conf_dict()
            elif len(layers_conf) == 1 and 'layers' in layers_conf[0]:
                # single root layer in list -> remove list
                layers_conf = layers_conf[0]
            else:
                # layer list without root -> wrap in root layer
                layers_conf = dict(title=None, layers=layers_conf)

        if len(set(layers_conf.keys()) &
               set('layers name title sources'.split())) < 2:
            # looks like unordered legacy config
            layers_conf = self._legacy_layers_conf_dict()

        return layers_conf

    def _flatten_layers_conf_dict(self, layers_conf, _layers=None):
        """
        Returns a dictionary with all layers that have a name and sources.
        Flattens the layer tree.
        """
        layers = _layers if _layers is not None else odict()

        if 'layers' in layers_conf:
            for layer in layers_conf.pop('layers'):
                self._flatten_layers_conf_dict(layer, layers)

        if 'sources' in layers_conf and 'name' in layers_conf:
            layers[layers_conf['name']] = layers_conf

        return layers


    def load_wms_root_layer(self):
        self.wms_root_layer = None

        layers_conf = self._layers_conf_dict()
        if layers_conf is None: return
        self.wms_root_layer = WMSLayerConfiguration(layers_conf, context=self)

    def load_services(self):
        self.services = ServiceConfiguration(self.configuration.get('services', {}), context=self)

    def configured_services(self):
        with self:
            return self.services.services()

    def __enter__(self):
        # push local base_config onto config stack
        import mapproxy.config.config
        mapproxy.config.config._config.push(self.base_config)

    def __exit__(self, type, value, traceback):
        # pop local base_config from config stack
        import mapproxy.config.config
        mapproxy.config.config._config.pop()

    @property
    def base_config(self):
        return self.globals.base_config

    def config_files(self):
        """
        Returns a dictionary with all configuration filenames and there timestamps.
        Contains any included files as well (see `base` option).
        """
        return self.configuration.get('__config_files__', {})

def list_of_dicts_to_ordered_dict(dictlist):
    """
    >>> d = list_of_dicts_to_ordered_dict([{'a': 1}, {'b': 2}, {'c': 3}])
    >>> d.items()
    [('a', 1), ('b', 2), ('c', 3)]
    """

    result = odict()
    for d in dictlist:
        for k, v in d.iteritems():
            result[k] = v
    return result

class ConfigurationBase(object):
    """
    Base class for all configurations.
    """
    defaults = {}

    def __init__(self, conf, context):
        """
        :param conf: the configuration part for this configurator
        :param context: the complete proxy configuration
        :type context: ProxyConfiguration
        """
        self.conf = conf
        self.context = context
        for k, v in self.defaults.iteritems():
            if k not in self.conf:
                self.conf[k] = v

class GridConfiguration(ConfigurationBase):
    @memoize
    def tile_grid(self):
        from mapproxy.grid import tile_grid

        if 'base' in self.conf:
            base_grid_name = self.conf['base']
            if not base_grid_name in self.context.grids:
                raise ConfigurationError('unknown base %s for grid %s' % (base_grid_name, self.conf['name']))
            conf = self.context.grids[base_grid_name].conf.copy()
            conf.update(self.conf)
            conf.pop('base')
            self.conf = conf
        else:
            conf = self.conf
        align_with = None
        if 'align_resolutions_with' in self.conf:
            align_with_grid_name = self.conf['align_resolutions_with']
            align_with = self.context.grids[align_with_grid_name].tile_grid()

        tile_size = self.context.globals.get_value('tile_size', conf,
            global_key='grid.tile_size')
        conf['tile_size'] = tuple(tile_size)
        tile_size = tuple(tile_size)

        stretch_factor = self.context.globals.get_value('stretch_factor', conf,
            global_key='image.stretch_factor')
        max_shrink_factor = self.context.globals.get_value('max_shrink_factor', conf,
            global_key='image.max_shrink_factor')


        grid = tile_grid(
            name=conf['name'],
            srs=conf.get('srs'),
            tile_size=tile_size,
            min_res=conf.get('min_res'),
            max_res=conf.get('max_res'),
            res=conf.get('res'),
            res_factor=conf.get('res_factor', 2.0),
            threshold_res=conf.get('threshold_res'),
            bbox=conf.get('bbox'),
            bbox_srs=conf.get('bbox_srs'),
            num_levels=conf.get('num_levels'),
            stretch_factor=stretch_factor,
            max_shrink_factor=max_shrink_factor,
            align_with=align_with,
            origin=conf.get('origin')
        )

        return grid


class GlobalConfiguration(ConfigurationBase):
    def __init__(self, conf_base_dir, conf, context):
        ConfigurationBase.__init__(self, conf, context)
        self.base_config = load_default_config()
        self._copy_conf_values(self.conf, self.base_config)
        self.base_config.conf_base_dir = conf_base_dir
        finish_base_config(self.base_config)

        self.image_options = ImageOptionsConfiguration(self.conf.get('image', {}), context)
        self.renderd_address = self.get_value('renderd.address')

    def _copy_conf_values(self, d, target):
        for k, v in d.iteritems():
            if v is None: continue
            if hasattr(v, 'iteritems') and k in target:
                self._copy_conf_values(v, target[k])
            else:
                target[k] = v

    def get_value(self, key, local={}, global_key=None, default_key=None):
        result = dotted_dict_get(key, local)
        if result is None:
            result = dotted_dict_get(global_key or key, self.conf)

        if result is None:
            result = dotted_dict_get(default_key or global_key or key, self.base_config)

        return result

    def get_path(self, key, local, global_key=None, default_key=None):
        value = self.get_value(key, local, global_key, default_key)
        if value is not None:
            value = self.abspath(value)
        return value

    def abspath(self, path):
        return os.path.join(self.base_config.conf_base_dir, path)



default_image_options = {
}

class ImageOptionsConfiguration(ConfigurationBase):
    def __init__(self, conf, context):
        ConfigurationBase.__init__(self, conf, context)
        self._init_formats()

    def _init_formats(self):
        self.formats = {}

        formats_config = default_image_options.copy()
        for format, conf in self.conf.get('formats', {}).iteritems():
            if format in formats_config:
                tmp = formats_config[format].copy()
                tmp.update(conf)
                conf = tmp
            if 'resampling_method' in conf:
                conf['resampling'] = conf.pop('resampling_method')
            if 'encoding_options' in conf:
                self._check_encoding_options(conf['encoding_options'])
            if 'merge_method' in conf:
                warnings.warn('merge_method now defaults to composite. option no longer required',
                    DeprecationWarning)
            formats_config[format] = conf
        for format, conf in formats_config.iteritems():
            if 'format' not in conf and format.startswith('image/'):
                conf['format'] = format
            self.formats[format] = conf

    def _check_encoding_options(self, options):
        if not options:
            return
        options = options.copy()
        jpeg_quality = options.pop('jpeg_quality', None)
        if jpeg_quality and not isinstance(jpeg_quality, int):
            raise ConfigurationError('jpeg_quality is not an integer')
        quantizer = options.pop('quantizer', None)
        if quantizer and quantizer not in ('fastoctree', 'mediancut'):
            raise ConfigurationError('unknown quantizer')

        if options:
            raise ConfigurationError('unknown encoding_options: %r' % options)

    def image_opts(self, image_conf, format):
        from mapproxy.image.opts import ImageOptions
        if not image_conf:
            image_conf = {}

        conf = {}
        if format in self.formats:
            conf = self.formats[format].copy()

        resampling = image_conf.get('resampling_method') or conf.get('resampling')
        if resampling is None:
            resampling = self.context.globals.get_value('image.resampling_method', {})
        transparent = image_conf.get('transparent')
        opacity = image_conf.get('opacity')
        img_format = image_conf.get('format')
        colors = image_conf.get('colors')
        mode = image_conf.get('mode')
        encoding_options = image_conf.get('encoding_options')
        if 'merge_method' in image_conf:
            warnings.warn('merge_method now defaults to composite. option no longer required',
                DeprecationWarning)

        self._check_encoding_options(encoding_options)

        # only overwrite default if it is not None
        for k, v in dict(transparent=transparent, opacity=opacity, resampling=resampling,
            format=img_format, colors=colors, mode=mode, encoding_options=encoding_options,
        ).iteritems():
            if v is not None:
                conf[k] = v

        if 'format' not in conf and format and format.startswith('image/'):
            conf['format'] = format

        # caches shall be able to store png and jpeg tiles with mixed format
        if format == 'mixed':
            conf['format'] = format

        # force 256 colors for image.paletted for backwards compat
        paletted = self.context.globals.get_value('image.paletted', self.conf)
        if conf.get('colors') is None and 'png' in conf.get('format', '') and paletted:
            conf['colors'] = 256

        opts = ImageOptions(**conf)
        return opts


def dotted_dict_get(key, d):
    """
    >>> dotted_dict_get('foo', {'foo': {'bar': 1}})
    {'bar': 1}
    >>> dotted_dict_get('foo.bar', {'foo': {'bar': 1}})
    1
    >>> dotted_dict_get('bar', {'foo': {'bar': 1}})
    """
    parts = key.split('.')
    try:
        while parts and d:
            d = d[parts.pop(0)]
    except KeyError:
        return None
    if parts: # not completely resolved
        return None
    return d


class SourcesCollection(dict):
    """
    Collection of SourceConfigurations.
    Allows access to tagged WMS sources, e.g.
    ``sc['source_name:lyr,lyr2']`` will return the source with ``source_name``
    and set ``req.layers`` to ``lyr1,lyr2``.
    """
    def __getitem__(self, key):
        layers = None
        source_name = key
        if ':' in source_name:
            source_name, layers = source_name.split(':', 1)
        source = dict.__getitem__(self, source_name)
        if not layers:
            return source

        if source.conf.get('type') not in ('wms', 'mapserver', 'mapnik'):
            raise ConfigurationError("found ':' in: '%s'."
                " tagged sources only supported for WMS/Mapserver/Mapnik" % key)

        uses_req = source.conf.get('type') != 'mapnik'

        source = copy(source)
        source.conf = deepcopy(source.conf)

        if uses_req:
            supported_layers = source.conf['req'].get('layers', [])
        else:
            supported_layers = source.conf.get('layers', [])
        supported_layer_set = SourcesCollection.layer_set(supported_layers)
        layer_set = SourcesCollection.layer_set(layers)

        if supported_layer_set and not layer_set.issubset(supported_layer_set):
            raise ConfigurationError('layers (%s) not supported by source (%s)' % (
                layers, ','.join(supported_layer_set)))

        if uses_req:
            source.conf['req']['layers'] = layers
        else:
            source.conf['layers'] = layers

        return source

    def __contains__(self, key):
        source_name = key
        if ':' in source_name:
            source_name, _ = source_name.split(':', 1)
        return dict.__contains__(self, source_name)

    @staticmethod
    def layer_set(layers):
        if isinstance(layers, (list, tuple)):
            return set(layers)
        return set(layers.split(','))


class SourceConfiguration(ConfigurationBase):

    supports_meta_tiles = True

    @classmethod
    def load(cls, conf, context):
        source_type = conf['type']

        subclass = source_configuration_types.get(source_type)
        if not subclass:
            raise ConfigurationError("unknown source type '%s'" % source_type)

        return subclass(conf, context)

    @memoize
    def coverage(self):
        if not 'coverage' in self.conf: return None
        from mapproxy.config.coverage import load_coverage
        return load_coverage(self.conf['coverage'])

    def image_opts(self, format=None):
        if 'transparent' in self.conf:
            self.conf.setdefault('image', {})['transparent'] = self.conf['transparent']
        return self.context.globals.image_options.image_opts(self.conf.get('image', {}), format)

    def http_client(self, url):
        from mapproxy.client.http import auth_data_from_url, HTTPClient

        http_client = None
        url, (username, password) = auth_data_from_url(url)
        insecure = ssl_ca_certs = None
        if 'https' in url:
            insecure = self.context.globals.get_value('http.ssl_no_cert_checks', self.conf)
            ssl_ca_certs = self.context.globals.get_path('http.ssl_ca_certs', self.conf)

        timeout = self.context.globals.get_value('http.client_timeout', self.conf)
        headers = self.context.globals.get_value('http.headers', self.conf)

        http_client = HTTPClient(url, username, password, insecure=insecure,
                                 ssl_ca_certs=ssl_ca_certs, timeout=timeout,
                                 headers=headers)
        return http_client, url

    @memoize
    def on_error_handler(self):
        if not 'on_error' in self.conf: return None
        from mapproxy.source.error import HTTPSourceErrorHandler

        error_handler = HTTPSourceErrorHandler()
        for status_code, response_conf in self.conf['on_error'].iteritems():
            if not isinstance(status_code, int) and status_code != 'other':
                raise ConfigurationError("invalid error code %r in on_error", status_code)
            cacheable = response_conf.get('cache', False)
            color = response_conf.get('response', 'transparent')
            if color == 'transparent':
                color = (255, 255, 255, 0)
            else:
                color = parse_color(color)
            error_handler.add_handler(status_code, color, cacheable)

        return error_handler

def resolution_range(conf):
    from mapproxy.grid import resolution_range as _resolution_range
    if 'min_res' in conf or 'max_res' in conf:
        return _resolution_range(min_res=conf.get('min_res'),
                                max_res=conf.get('max_res'))
    if 'min_scale' in conf or 'max_scale' in conf:
        return _resolution_range(min_scale=conf.get('min_scale'),
                                max_scale=conf.get('max_scale'))


class WMSSourceConfiguration(SourceConfiguration):
    source_type = ('wms',)

    @staticmethod
    def static_legend_source(url, context):
        from mapproxy.cache.legend import LegendCache
        from mapproxy.client.wms import WMSLegendURLClient
        from mapproxy.source.wms import WMSLegendSource

        cache_dir = os.path.join(context.globals.get_path('cache.base_dir', {}),
                                 'legends')
        if url.startswith('file://') and not url.startswith('file:///'):
            prefix = 'file://'
            url = prefix + context.globals.abspath(url[7:])
        lg_client = WMSLegendURLClient(url)
        legend_cache = LegendCache(cache_dir=cache_dir)
        return WMSLegendSource([lg_client], legend_cache, static=True)

    def fi_xslt_transformer(self, conf, context):
        from mapproxy.featureinfo import XSLTransformer, has_xslt_support
        fi_transformer = None
        fi_xslt = conf.get('featureinfo_xslt')
        if fi_xslt:
            if not has_xslt_support:
                raise ValueError('featureinfo_xslt requires lxml. Please install.')
            fi_xslt = context.globals.abspath(fi_xslt)
            fi_transformer = XSLTransformer(fi_xslt)
        return fi_transformer

    def image_opts(self, format=None):
        if 'transparent' not in (self.conf.get('image') or {}):
            transparent = self.conf['req'].get('transparent')
            if transparent is not None:
                transparent = bool(str(transparent).lower() == 'true')
                self.conf.setdefault('image', {})['transparent'] = transparent
        return SourceConfiguration.image_opts(self, format=format)

    def source(self, params=None):
        from mapproxy.client.wms import WMSClient
        from mapproxy.request.wms import create_request
        from mapproxy.source.wms import WMSSource
        from mapproxy.srs import SRS

        if not self.conf.get('wms_opts', {}).get('map', True):
            return None

        if not self.context.seed and self.conf.get('seed_only'):
            from mapproxy.source import DummySource
            return DummySource(coverage=self.coverage())

        if params is None: params = {}

        request_format = self.conf['req'].get('format')
        if request_format:
            params['format'] = request_format

        image_opts = self.image_opts(format=params.get('format'))

        supported_srs = [SRS(code) for code in self.conf.get('supported_srs', [])]
        supported_formats = [file_ext(f) for f in self.conf.get('supported_formats', [])]
        version = self.conf.get('wms_opts', {}).get('version', '1.1.1')

        lock = None
        concurrent_requests = self.context.globals.get_value('concurrent_requests', self.conf,
                                                        global_key='http.concurrent_requests')
        if concurrent_requests:
            from mapproxy.util.lock import SemLock
            lock_dir = self.context.globals.get_path('cache.lock_dir', self.conf)
            lock_timeout = self.context.globals.get_value('http.client_timeout', self.conf)
            url = urlparse.urlparse(self.conf['req']['url'])
            md5 = hashlib.md5(url.netloc)
            lock_file = os.path.join(lock_dir, md5.hexdigest() + '.lck')
            lock = lambda: SemLock(lock_file, concurrent_requests, timeout=lock_timeout)

        coverage = self.coverage()
        res_range = resolution_range(self.conf)

        transparent_color = (self.conf.get('image') or {}).get('transparent_color')
        transparent_color_tolerance = self.context.globals.get_value(
            'image.transparent_color_tolerance', self.conf)
        if transparent_color:
            transparent_color = parse_color(transparent_color)

        http_method = self.context.globals.get_value('http.method', self.conf)

        fwd_req_params = set(self.conf.get('forward_req_params', []))

        request = create_request(self.conf['req'], params, version=version,
            abspath=self.context.globals.abspath)
        http_client, request.url = self.http_client(request.url)
        client = WMSClient(request, http_client=http_client,
                           http_method=http_method, lock=lock,
                           fwd_req_params=fwd_req_params)
        return WMSSource(client, image_opts=image_opts, coverage=coverage,
                         res_range=res_range, transparent_color=transparent_color,
                         transparent_color_tolerance=transparent_color_tolerance,
                         supported_srs=supported_srs,
                         supported_formats=supported_formats or None,
                         fwd_req_params=fwd_req_params)

    def fi_source(self, params=None):
        from mapproxy.client.wms import WMSInfoClient
        from mapproxy.request.wms import create_request
        from mapproxy.source.wms import WMSInfoSource
        from mapproxy.srs import SRS

        if params is None: params = {}
        request_format = self.conf['req'].get('format')
        if request_format:
            params['format'] = request_format
        supported_srs = [SRS(code) for code in self.conf.get('supported_srs', [])]
        fi_source = None
        if self.conf.get('wms_opts', {}).get('featureinfo', False):
            wms_opts = self.conf['wms_opts']
            version = wms_opts.get('version', '1.1.1')
            if 'featureinfo_format' in wms_opts:
                params['info_format'] = wms_opts['featureinfo_format']
            fi_request = create_request(self.conf['req'], params,
                req_type='featureinfo', version=version,
                abspath=self.context.globals.abspath)

            fi_transformer = self.fi_xslt_transformer(self.conf.get('wms_opts', {}),
                                                     self.context)

            http_client, fi_request.url = self.http_client(fi_request.url)
            fi_client = WMSInfoClient(fi_request, supported_srs=supported_srs,
                                      http_client=http_client)
            fi_source = WMSInfoSource(fi_client, fi_transformer=fi_transformer)
        return fi_source

    def lg_source(self, params=None):
        from mapproxy.cache.legend import LegendCache
        from mapproxy.client.wms import WMSLegendClient
        from mapproxy.request.wms import create_request
        from mapproxy.source.wms import WMSLegendSource

        if params is None: params = {}
        request_format = self.conf['req'].get('format')
        if request_format:
            params['format'] = request_format
        lg_source = None
        cache_dir = os.path.join(self.context.globals.get_path('cache.base_dir', {}),
                                 'legends')

        if self.conf.get('wms_opts', {}).get('legendurl', False):
            lg_url = self.conf.get('wms_opts', {}).get('legendurl')
            lg_source = WMSSourceConfiguration.static_legend_source(lg_url, self.context)
        elif self.conf.get('wms_opts', {}).get('legendgraphic', False):
            version = self.conf.get('wms_opts', {}).get('version', '1.1.1')
            lg_req = self.conf['req'].copy()
            lg_clients = []
            lg_layers = str(lg_req['layers']).split(',')
            del lg_req['layers']
            for lg_layer in lg_layers:
                lg_req['layer'] = lg_layer
                lg_request = create_request(lg_req, params,
                    req_type='legendgraphic', version=version,
                    abspath=self.context.globals.abspath)
                http_client, lg_request.url = self.http_client(lg_request.url)
                lg_client = WMSLegendClient(lg_request, http_client=http_client)
                lg_clients.append(lg_client)
            legend_cache = LegendCache(cache_dir=cache_dir)
            lg_source = WMSLegendSource(lg_clients, legend_cache)
        return lg_source


class MapServerSourceConfiguration(WMSSourceConfiguration):
    source_type = ('mapserver',)

    def __init__(self, conf, context):
        WMSSourceConfiguration.__init__(self, conf, context)
        self.script = self.context.globals.get_path('mapserver.binary',
            self.conf)
        if not self.script or not os.path.isfile(self.script):
            raise ConfigurationError('could not find mapserver binary (%r)' %
                (self.script, ))

        # set url to dummy script name, required as identifier
        # for concurrent_request
        self.conf['req']['url'] = 'http://localhost' + self.script

        mapfile = self.context.globals.abspath(self.conf['req']['map'])
        self.conf['req']['map'] = mapfile

    def http_client(self, url):
        working_dir = self.context.globals.get_path('mapserver.working_dir', self.conf)
        if working_dir and not os.path.isdir(working_dir):
            raise ConfigurationError('could not find mapserver working_dir (%r)' % (working_dir, ))

        from mapproxy.client.cgi import CGIClient
        client = CGIClient(script=self.script, working_directory=working_dir)
        return client, url


class MapnikSourceConfiguration(SourceConfiguration):
    source_type = ('mapnik',)

    def source(self, params=None):
        if not self.context.seed and self.conf.get('seed_only'):
            from mapproxy.source import DummySource
            return DummySource(coverage=self.coverage())

        image_opts = self.image_opts()

        lock = None
        concurrent_requests = self.context.globals.get_value('concurrent_requests', self.conf,
                                                        global_key='http.concurrent_requests')
        if concurrent_requests:
            from mapproxy.util.lock import SemLock
            lock_dir = self.context.globals.get_path('cache.lock_dir', self.conf)
            md5 = hashlib.md5(self.conf['mapfile'])
            lock_file = os.path.join(lock_dir, md5.hexdigest() + '.lck')
            lock = lambda: SemLock(lock_file, concurrent_requests)

        coverage = self.coverage()
        res_range = resolution_range(self.conf)

        layers = self.conf.get('layers', None)
        if isinstance(layers, basestring):
            layers = layers.split(',')

        mapfile = self.context.globals.abspath(self.conf['mapfile'])

        if self.conf.get('use_mapnik2', False):
            warnings.warn('use_mapnik2 option is no longer needed for Mapnik 2 support',
                DeprecationWarning)

        from mapproxy.source.mapnik import MapnikSource, mapnik as mapnik_api
        if mapnik_api is None:
            raise ConfigurationError('Could not import Mapnik, please verify it is installed!')

        if self.context.renderd:
            # only renderd guarantees that we have a single proc/thread
            # that accesses the same mapnik map object
            reuse_map_objects = True
        else:
            reuse_map_objects = False

        return MapnikSource(mapfile, layers=layers, image_opts=image_opts,
            coverage=coverage, res_range=res_range, lock=lock,
            reuse_map_objects=reuse_map_objects)

class TileSourceConfiguration(SourceConfiguration):
    supports_meta_tiles = False
    source_type = ('tile',)
    defaults = {'grid': 'GLOBAL_MERCATOR'}

    def source(self, params=None):
        from mapproxy.client.tile import TileClient, TileURLTemplate
        from mapproxy.source.tile import TiledSource

        if not self.context.seed and self.conf.get('seed_only'):
            from mapproxy.source import DummySource
            return DummySource(coverage=self.coverage())

        if params is None: params = {}

        url = self.conf['url']

        if self.conf.get('origin'):
            warnings.warn('origin for tile sources is deprecated since 1.3.0 '
            'and will be ignored. use grid with correct origin.', RuntimeWarning)

        http_client, url = self.http_client(url)
        grid = self.context.grids[self.conf['grid']].tile_grid()
        coverage = self.coverage()
        res_range = resolution_range(self.conf)

        image_opts = self.image_opts()
        error_handler = self.on_error_handler()

        format = file_ext(params['format'])
        client = TileClient(TileURLTemplate(url, format=format), http_client=http_client, grid=grid)
        return TiledSource(grid, client, coverage=coverage, image_opts=image_opts,
            error_handler=error_handler, res_range=res_range)


def file_ext(mimetype):
    from mapproxy.request.base import split_mime_type
    _mime_class, format, _options = split_mime_type(mimetype)
    return format

class DebugSourceConfiguration(SourceConfiguration):
    source_type = ('debug',)
    required_keys = set('type'.split())

    def source(self, params=None):
        from mapproxy.source import DebugSource
        return DebugSource()


source_configuration_types = {
    'wms': WMSSourceConfiguration,
    'tile': TileSourceConfiguration,
    'debug': DebugSourceConfiguration,
    'mapserver': MapServerSourceConfiguration,
    'mapnik': MapnikSourceConfiguration,
}


class CacheConfiguration(ConfigurationBase):
    defaults = {'format': 'image/png', 'grids': ['GLOBAL_MERCATOR']}

    @memoize
    def cache_dir(self):
        cache_dir = self.conf.get('cache', {}).get('directory')
        if cache_dir:
            if self.conf.get('cache_dir'):
                log.warn('found cache.directory and cache_dir option for %s, ignoring cache_dir',
                self.conf['name'])
            return self.context.globals.abspath(cache_dir)

        return self.context.globals.get_path('cache_dir', self.conf,
            global_key='cache.base_dir')

    def lock_dir(self):
        lock_dir = self.context.globals.get_path('cache.tile_lock_dir', self.conf)
        if not lock_dir:
            lock_dir = os.path.join(self.cache_dir(), 'tile_locks')
        return lock_dir

    def _file_cache(self, grid_conf, file_ext):
        from mapproxy.cache.file import FileCache

        cache_dir = self.cache_dir()
        directory_layout = self.conf.get('cache', {}).get('directory_layout', 'tc')
        if self.conf.get('cache', {}).get('directory'):
            pass
        elif self.conf.get('cache', {}).get('use_grid_names'):
            cache_dir = os.path.join(cache_dir, self.conf['name'], grid_conf.tile_grid().name)
        else:
            suffix = grid_conf.conf['srs'].replace(':', '')
            cache_dir = os.path.join(cache_dir, self.conf['name'] + '_' + suffix)
        link_single_color_images = self.conf.get('link_single_color_images', False)
        if link_single_color_images and sys.platform == 'win32':
            log.warn('link_single_color_images not supported on windows')
            link_single_color_images = False

        lock_timeout = self.context.globals.get_value('http.client_timeout', {})

        return FileCache(
            cache_dir,
            lock_dir=self.lock_dir(),
            file_ext=file_ext,
            directory_layout=directory_layout,
            lock_timeout=lock_timeout,
            link_single_color_images=link_single_color_images,
        )

    def _mbtiles_cache(self, grid_conf, file_ext):
        from mapproxy.cache.mbtiles import MBTilesCache

        filename = self.conf['cache'].get('filename')
        if not filename:
            filename = self.conf['name'] + '.mbtiles'

        if filename.startswith('.' + os.sep):
            mbfile_path = self.context.globals.abspath(filename)
        else:
            mbfile_path = os.path.join(self.cache_dir(), filename)

        return MBTilesCache(
            mbfile_path,
            lock_dir=self.lock_dir(),
        )

    def _sqlite_cache(self, grid_conf, file_ext):
        from mapproxy.cache.mbtiles import MBTilesLevelCache

        cache_dir = self.conf.get('cache', {}).get('directory')
        if cache_dir:
            cache_dir = os.path.join(
                self.context.globals.abspath(cache_dir),
                grid_conf.tile_grid().name
            )
        else:
            cache_dir = self.cache_dir()
            cache_dir = os.path.join(
                cache_dir,
                self.conf['name'],
                grid_conf.tile_grid().name
            )

        return MBTilesLevelCache(
            cache_dir,
            lock_dir=self.lock_dir(),
        )

    def _couchdb_cache(self, grid_conf, file_ext):
        from mapproxy.cache.couchdb import CouchDBCache, CouchDBMDTemplate

        db_name = self.conf['cache'].get('db_name')
        if not db_name:
            suffix = grid_conf.conf['srs'].replace(':', '')
            db_name = self.conf['name'] + '_' + suffix

        url = self.conf['cache'].get('url')
        if not url:
            url = 'http://127.0.0.1:5984'

        md_template = CouchDBMDTemplate(self.conf['cache'].get('tile_metadata', {}))
        tile_id = self.conf['cache'].get('tile_id')

        return CouchDBCache(url=url, db_name=db_name,
            lock_dir=self.lock_dir(), file_ext=file_ext, tile_grid=grid_conf.tile_grid(),
            md_template=md_template, tile_id_template=tile_id)

    def _riak_cache(self, grid_conf, file_ext):
        from mapproxy.cache.riak import RiakCache

        default_ports = self.conf['cache'].get('default_ports', {})
        default_pb_port = default_ports.get('pb', 8087)
        default_http_port = default_ports.get('http', 8098)

        nodes = self.conf['cache'].get('nodes')
        if not nodes:
            nodes = [{'host': '127.0.0.1'}]

        for n in nodes:
            if 'pb_port' not in n:
                n['pb_port'] = default_pb_port
            if 'http_port' not in n:
                n['http_port'] = default_http_port

        protocol = self.conf['cache'].get('protocol', 'pbc')
        bucket = self.conf['cache'].get('bucket')
        if not bucket:
            suffix = grid_conf.tile_grid().name
            bucket = self.conf['name'] + '_' + suffix

        use_secondary_index = self.conf['cache'].get('secondary_index', False)

        return RiakCache(nodes=nodes, protocol=protocol, bucket=bucket,
            tile_grid=grid_conf.tile_grid(),
            lock_dir=self.lock_dir(),
            use_secondary_index=use_secondary_index,
        )

    def _tile_cache(self, grid_conf, file_ext):
        if self.conf.get('disable_storage', False):
            from mapproxy.cache.dummy import DummyCache
            return DummyCache()

        grid_conf.tile_grid() #create to resolve `base` in grid_conf.conf
        cache_type = self.conf.get('cache', {}).get('type', 'file')
        return getattr(self, '_%s_cache' % cache_type)(grid_conf, file_ext)

    def _tile_filter(self):
        filters = []
        if 'watermark' in self.conf:
            from mapproxy.tilefilter import create_watermark_filter
            if self.conf['watermark'].get('color'):
                self.conf['watermark']['color'] = parse_color(self.conf['watermark']['color'])
            f = create_watermark_filter(self.conf, self.context)
            if f:
                filters.append(f)
        return filters

    @memoize
    def image_opts(self):
        from mapproxy.image.opts import ImageFormat

        format = None
        if 'format' not in self.conf.get('image', {}):
            format = self.conf.get('format') or self.conf.get('request_format')
        image_opts = self.context.globals.image_options.image_opts(self.conf.get('image', {}), format)
        if image_opts.format is None:
            if format is not None and format.startswith('image/'):
                image_opts.format = ImageFormat(format)
            else:
                image_opts.format = ImageFormat('image/png')
        return image_opts

    def supports_tiled_only_access(self, params=None, tile_grid=None):
        caches = self.caches()
        if len(caches) > 1:
            return False

        cache_grid, extent, tile_manager = caches[0]
        image_opts = self.image_opts()

        if (tile_grid.is_subset_of(cache_grid)
            and params.get('format') == image_opts.format):
            return True

        return False

    def source(self, params=None, tile_grid=None, tiled_only=False):
        from mapproxy.source.tile import CacheSource
        from mapproxy.layer import map_extent_from_grid

        caches = self.caches()
        if len(caches) > 1:
            # cache with multiple grids/sources
            source = self.map_layer()
            source.supports_meta_tiles = True
            return source

        cache_grid, extent, tile_manager = caches[0]
        image_opts = self.image_opts()

        cache_extent = map_extent_from_grid(tile_grid)
        cache_extent = extent.intersection(cache_extent)

        source = CacheSource(tile_manager, extent=cache_extent,
            image_opts=image_opts, tiled_only=tiled_only)
        return source

    @memoize
    def caches(self):
        from mapproxy.cache.tile import TileManager
        from mapproxy.cache.base import TileLocker
        from mapproxy.image.opts import compatible_image_options
        from mapproxy.layer import map_extent_from_grid, merge_layer_extents

        base_image_opts = self.image_opts()
        if self.conf.get('format') == 'mixed' and not self.conf.get('request_format') == 'image/png':
            raise ConfigurationError('request_format must be set to image/png if mixed mode is enabled')
        request_format = self.conf.get('request_format') or self.conf.get('format')
        if '/' in request_format:
            request_format_ext = request_format.split('/', 1)[1]
        else:
            request_format_ext = request_format

        caches = []

        meta_buffer = self.context.globals.get_value('meta_buffer', self.conf,
            global_key='cache.meta_buffer')
        meta_size = self.context.globals.get_value('meta_size', self.conf,
            global_key='cache.meta_size')
        minimize_meta_requests = self.context.globals.get_value('minimize_meta_requests', self.conf,
            global_key='cache.minimize_meta_requests')
        concurrent_tile_creators = self.context.globals.get_value('concurrent_tile_creators', self.conf,
            global_key='cache.concurrent_tile_creators')

        renderd_address = self.context.globals.get_value('renderd.address', self.conf)

        for grid_name, grid_conf in self.grid_confs():
            sources = []
            source_image_opts = []

            # a cache can directly access source tiles when _all_ sources are caches too
            # and when they have compatible grids by using tiled_only on the CacheSource
            # check if all sources support tiled_only
            tiled_only = True
            for source_name in self.conf['sources']:
                if source_name in self.context.sources:
                    tiled_only = False
                    break
                elif source_name in self.context.caches:
                    cache_conf = self.context.caches[source_name]
                    tiled_only = cache_conf.supports_tiled_only_access(
                        params={'format': request_format},
                        tile_grid=grid_conf.tile_grid(),
                    )
                    if not tiled_only:
                        break

            for source_name in self.conf['sources']:
                if source_name in self.context.sources:
                    source_conf = self.context.sources[source_name]
                    source = source_conf.source({'format': request_format})
                elif source_name in self.context.caches:
                    cache_conf = self.context.caches[source_name]
                    source = cache_conf.source(
                        params={'format': request_format},
                        tile_grid=grid_conf.tile_grid(),
                        tiled_only=tiled_only,
                    )
                else:
                    raise ConfigurationError('unknown source %s' % source_name)
                if source:
                    sources.append(source)
                    source_image_opts.append(source.image_opts)
            if not sources:
                from mapproxy.source import DummySource
                sources = [DummySource()]
                source_image_opts.append(sources[0].image_opts)
            tile_grid = grid_conf.tile_grid()
            tile_filter = self._tile_filter()
            image_opts = compatible_image_options(source_image_opts, base_opts=base_image_opts)
            cache = self._tile_cache(grid_conf, image_opts.format.ext)
            identifier = self.conf['name'] + '_' + tile_grid.name

            tile_creator_class = None

            use_renderd = bool(renderd_address)
            if self.context.renderd:
                # we _are_ renderd
                use_renderd = False
            if self.conf.get('disable_storage', False):
                # can't ask renderd to create tiles that shouldn't be cached
                use_renderd = False

            if use_renderd:
                from mapproxy.cache.renderd import RenderdTileCreator, has_renderd_support
                if not has_renderd_support():
                    raise ConfigurationError("renderd requires Python >=2.6 and requests")
                if self.context.seed:
                    priority = 10
                else:
                    priority = 100

                cache_dir = self.cache_dir()

                lock_dir = self.context.globals.get_value('cache.tile_lock_dir')
                if not lock_dir:
                    lock_dir = os.path.join(cache_dir, 'tile_locks')

                lock_timeout = self.context.globals.get_value('http.client_timeout', {})
                locker = TileLocker(lock_dir, lock_timeout, identifier + '_renderd')
                tile_creator_class = partial(RenderdTileCreator, renderd_address,
                    priority=priority, tile_locker=locker)
            mgr = TileManager(tile_grid, cache, sources, image_opts.format.ext,
                              image_opts=image_opts, identifier=identifier,
                              request_format=request_format_ext,
                              meta_size=meta_size, meta_buffer=meta_buffer,
                              minimize_meta_requests=minimize_meta_requests,
                              concurrent_tile_creators=concurrent_tile_creators,
                              pre_store_filter=tile_filter,
                              tile_creator_class=tile_creator_class)
            extent = merge_layer_extents(sources)
            if extent.is_default:
                extent = map_extent_from_grid(tile_grid)
            caches.append((tile_grid, extent, mgr))
        return caches

    @memoize
    def grid_confs(self):
        return [(g, self.context.grids[g]) for g in self.conf['grids']]

    @memoize
    def map_layer(self):
        from mapproxy.layer import CacheMapLayer, SRSConditional, ResolutionConditional

        image_opts = self.image_opts()
        max_tile_limit = self.context.globals.get_value('max_tile_limit', self.conf,
            global_key='cache.max_tile_limit')
        caches = []
        main_grid = None
        for grid, extent, tile_manager in self.caches():
            if main_grid is None:
                main_grid = grid
            caches.append((CacheMapLayer(tile_manager, extent=extent, image_opts=image_opts,
                                         max_tile_limit=max_tile_limit),
                          (grid.srs,)))

        if len(caches) == 1:
            layer = caches[0][0]
        else:
            layer = SRSConditional(caches, caches[0][0].extent, caches[0][0].transparent, opacity=image_opts.opacity)

        if 'use_direct_from_level' in self.conf:
            self.conf['use_direct_from_res'] = main_grid.resolution(self.conf['use_direct_from_level'])
        if 'use_direct_from_res' in self.conf:
            if len(self.conf['sources']) != 1:
                raise ValueError('use_direct_from_level/res only supports single sources')
            source_conf = self.context.sources[self.conf['sources'][0]]
            layer = ResolutionConditional(layer, source_conf.source(), self.conf['use_direct_from_res'],
                                          main_grid.srs, layer.extent, opacity=image_opts.opacity)
        return layer


class WMSLayerConfiguration(ConfigurationBase):
    @memoize
    def wms_layer(self):
        from mapproxy.service.wms import WMSGroupLayer

        layers = []
        this_layer = None

        if 'layers' in self.conf:
            layers_conf = self.conf['layers']
            for layer_conf in layers_conf:
                layers.append(WMSLayerConfiguration(layer_conf, self.context).wms_layer())

        if 'sources' in self.conf or 'legendurl' in self.conf:
            this_layer = LayerConfiguration(self.conf, self.context).wms_layer()

        if not layers and not this_layer:
            raise ValueError('wms layer requires sources and/or layers')

        if not layers:
            layer = this_layer
        else:
            layer = WMSGroupLayer(name=self.conf.get('name'), title=self.conf.get('title'),
                                  this=this_layer, layers=layers, md=self.conf.get('md'))
        return layer

class LayerConfiguration(ConfigurationBase):
    @memoize
    def wms_layer(self):
        from mapproxy.service.wms import WMSLayer

        sources = []
        fi_sources = []
        lg_sources = []

        lg_sources_configured = False
        if self.conf.get('legendurl'):
            legend_url = self.conf['legendurl']
            lg_sources.append(WMSSourceConfiguration.static_legend_source(legend_url, self.context))
            lg_sources_configured = True

        for source_name in self.conf.get('sources', []):
            fi_source_names = []
            lg_source_names = []
            if source_name in self.context.caches:
                map_layer = self.context.caches[source_name].map_layer()
                fi_source_names = self.context.caches[source_name].conf['sources']
                lg_source_names = self.context.caches[source_name].conf['sources']
            elif source_name in self.context.sources:
                source_conf = self.context.sources[source_name]
                if not source_conf.supports_meta_tiles:
                    raise ConfigurationError('source "%s" of layer "%s" does not support un-tiled access'
                        % (source_name, self.conf.get('name')))
                map_layer = source_conf.source()
                fi_source_names = [source_name]
                lg_source_names = [source_name]
            else:
                raise ConfigurationError('source/cache "%s" not found' % source_name)

            if map_layer:
                sources.append(map_layer)

            for fi_source_name in fi_source_names:
                if fi_source_name not in self.context.sources: continue
                if not hasattr(self.context.sources[fi_source_name], 'fi_source'): continue
                fi_source = self.context.sources[fi_source_name].fi_source()
                if fi_source:
                    fi_sources.append(fi_source)
            if not lg_sources_configured:
                for lg_source_name in lg_source_names:
                    if lg_source_name not in self.context.sources: continue
                    if not hasattr(self.context.sources[lg_source_name], 'lg_source'): continue
                    lg_source = self.context.sources[lg_source_name].lg_source()
                    if lg_source:
                        lg_sources.append(lg_source)

        res_range = resolution_range(self.conf)

        layer = WMSLayer(self.conf.get('name'), self.conf.get('title'),
                         sources, fi_sources, lg_sources, res_range=res_range, md=self.conf.get('md'))
        return layer

    @memoize
    def dimensions(self):
        from mapproxy.layer import Dimension
        dimensions = {}

        for dimension, conf in self.conf.get('dimensions', {}).iteritems():
            values = [str(val) for val in  conf.get('values', ['default'])]
            default = conf.get('default', values[-1])
            dimensions[dimension.lower()] = Dimension(dimension, values, default=default)
        return dimensions

    @memoize
    def tile_layers(self):
        from mapproxy.service.tile import TileLayer
        from mapproxy.cache.dummy import DummyCache

        sources = []
        for source_name in self.conf.get('sources', []):
            # we only support caches for tiled access...
            if not source_name in self.context.caches:
                # but we ignore debug layers for convenience
                if source_name in self.context.sources:
                    if self.context.sources[source_name].conf['type'] == 'debug':
                        continue
                return []
            sources.append(source_name)

        if len(sources) > 1:
            return []

        dimensions = self.dimensions()

        tile_layers = []
        for cache_name in sources:
            for grid, extent, cache_source in self.context.caches[cache_name].caches():

                if dimensions and not isinstance(cache_source.cache, DummyCache):
                    # caching of dimension layers is not supported yet
                    raise ConfigurationError(
                        "caching of dimension layer (%s) is not supported yet."
                        " need to `disable_storage: true` on %s cache" % (self.conf['name'], cache_name)
                    )

                md = {}
                md['title'] = self.conf['title']
                md['name'] = self.conf['name']
                md['name_path'] = (self.conf['name'], grid.srs.srs_code.replace(':', '').upper())
                md['grid_name'] = grid.name
                md['name_internal'] = md['name_path'][0] + '_' + md['name_path'][1]
                md['format'] = self.context.caches[cache_name].image_opts().format
                md['cache_name'] = cache_name
                md['extent'] = extent
                tile_layers.append(TileLayer(self.conf['name'], self.conf['title'],
                                             md, cache_source, dimensions=dimensions))

        return tile_layers


def fi_xslt_transformers(conf, context):
    from mapproxy.featureinfo import XSLTransformer, has_xslt_support
    fi_transformers = {}
    fi_xslt = conf.get('featureinfo_xslt')
    if fi_xslt:
        if not has_xslt_support:
            raise ValueError('featureinfo_xslt requires lxml. Please install.')
        for info_type, fi_xslt in fi_xslt.items():
            fi_xslt = context.globals.abspath(fi_xslt)
            fi_transformers[info_type] = XSLTransformer(fi_xslt)
    return fi_transformers

def extents_for_srs(bbox_srs):
    from mapproxy.layer import DefaultMapExtent, MapExtent
    from mapproxy.srs import SRS
    extents = {}
    for srs in bbox_srs:
        if isinstance(srs, str):
            bbox = DefaultMapExtent()
        else:
            srs, bbox = srs['srs'], srs['bbox']
            bbox = MapExtent(bbox, SRS(srs))

        extents[srs] = bbox

    return extents


class ServiceConfiguration(ConfigurationBase):
    def services(self):
        services = []
        ows_services = []
        for service_name, service_conf in self.conf.iteritems():
            creator = getattr(self, service_name + '_service', None)
            if not creator:
                raise ValueError('unknown service: %s' % service_name)

            new_services = creator(service_conf or {})
            # a creator can return a list of services...
            if not isinstance(new_services, (list, tuple)):
                new_services = [new_services]

            for new_service in new_services:
                if getattr(new_service, 'service', None):
                    ows_services.append(new_service)
                else:
                    services.append(new_service)

        if ows_services:
            from mapproxy.service.ows import OWSServer
            services.append(OWSServer(ows_services))
        return services

    def tile_layers(self, conf, use_grid_names=False):
        layers = odict()
        for layer_name, layer_conf in self.context.layers.iteritems():
            for tile_layer in layer_conf.tile_layers():
                if not tile_layer: continue
                if use_grid_names:
                    # new style layer names are tuples
                    tile_layer.md['name_path'] = (tile_layer.md['name'], tile_layer.md['grid_name'])
                    layers[tile_layer.md['name_path']] = tile_layer
                else:
                    layers[tile_layer.md['name_internal']] = tile_layer
        return layers

    def kml_service(self, conf):
        from mapproxy.service.kml import KMLServer

        md = self.context.services.conf.get('wms', {}).get('md', {}).copy()
        md.update(conf.get('md', {}))
        max_tile_age = self.context.globals.get_value('tiles.expires_hours')
        max_tile_age *= 60 * 60 # seconds
        use_grid_names = conf.get('use_grid_names', False)
        layers = self.tile_layers(conf, use_grid_names=use_grid_names)
        return KMLServer(layers, md, max_tile_age=max_tile_age, use_dimension_layers=use_grid_names)

    def tms_service(self, conf):
        from mapproxy.service.tile import TileServer

        md = self.context.services.conf.get('wms', {}).get('md', {}).copy()
        md.update(conf.get('md', {}))
        max_tile_age = self.context.globals.get_value('tiles.expires_hours')
        max_tile_age *= 60 * 60 # seconds

        origin = conf.get('origin')
        use_grid_names = conf.get('use_grid_names', False)
        layers = self.tile_layers(conf, use_grid_names=use_grid_names)
        return TileServer(layers, md, max_tile_age=max_tile_age, use_dimension_layers=use_grid_names,
            origin=origin)

    def wmts_service(self, conf):
        from mapproxy.service.wmts import WMTSServer, WMTSRestServer

        md = self.context.services.conf.get('wms', {}).get('md', {}).copy()
        md.update(conf.get('md', {}))
        layers = self.tile_layers(conf)

        kvp = conf.get('kvp')
        restful = conf.get('restful')

        max_tile_age = self.context.globals.get_value('tiles.expires_hours')
        max_tile_age *= 60 * 60 # seconds

        if kvp is None and restful is None:
            kvp = restful = True

        services = []
        if kvp:
            services.append(WMTSServer(layers, md, max_tile_age=max_tile_age))
        if restful:
            template = conf.get('restful_template')
            if template and '{{' in template:
                # TODO remove warning in 1.6
                log.warn("double braces in WMTS restful_template are deprecated {{x}} -> {x}")
            services.append(WMTSRestServer(layers, md, template=template,
                max_tile_age=max_tile_age))

        return services

    def wms_service(self, conf):
        from mapproxy.service.wms import WMSServer
        from mapproxy.request.wms import Version

        md = conf.get('md', {})
        tile_layers = self.tile_layers(conf)
        attribution = conf.get('attribution')
        strict = self.context.globals.get_value('strict', conf, global_key='wms.strict')
        on_source_errors = self.context.globals.get_value('on_source_errors',
            conf, global_key='wms.on_source_errors')
        root_layer = self.context.wms_root_layer.wms_layer()
        if not root_layer.title:
            # set title of root layer to WMS title
            root_layer.title = md.get('title')
        concurrent_layer_renderer = self.context.globals.get_value(
            'concurrent_layer_renderer', conf,
            global_key='wms.concurrent_layer_renderer')
        image_formats_names = self.context.globals.get_value('image_formats', conf,
                                                       global_key='wms.image_formats')
        image_formats = odict()
        for format in image_formats_names:
            opts = self.context.globals.image_options.image_opts({}, format)
            if opts.format in image_formats:
                log.warn('duplicate mime-type for WMS image_formats: "%s" already configured',
                    opts.format)
            image_formats[opts.format] = opts
        info_types = conf.get('featureinfo_types')
        srs = self.context.globals.get_value('srs', conf, global_key='wms.srs')
        self.context.globals.base_config.wms.srs = srs
        srs_extents = extents_for_srs(conf.get('bbox_srs', []))

        versions = conf.get('versions')
        if versions:
            versions = sorted([Version(v) for v in versions])

        max_output_pixels = self.context.globals.get_value('max_output_pixels', conf,
            global_key='wms.max_output_pixels')
        if isinstance(max_output_pixels, list):
            max_output_pixels = max_output_pixels[0] * max_output_pixels[1]

        max_tile_age = self.context.globals.get_value('tiles.expires_hours')
        max_tile_age *= 60 * 60 # seconds

        server = WMSServer(root_layer, md, attribution=attribution,
            image_formats=image_formats, info_types=info_types,
            srs=srs, tile_layers=tile_layers, strict=strict, on_error=on_source_errors,
            concurrent_layer_renderer=concurrent_layer_renderer,
            max_output_pixels=max_output_pixels, srs_extents=srs_extents,
            max_tile_age=max_tile_age, versions=versions)

        server.fi_transformers = fi_xslt_transformers(conf, self.context)

        return server

    def demo_service(self, conf):
        from mapproxy.service.demo import DemoServer
        services = self.context.services.conf.keys()
        md = self.context.services.conf.get('wms', {}).get('md', {}).copy()
        md.update(conf.get('md', {}))
        layers = odict()
        for layer_name, layer_conf in self.context.layers.iteritems():
            layers[layer_name] = layer_conf.wms_layer()
        tile_layers = self.tile_layers(conf)
        image_formats = self.context.globals.get_value('image_formats', conf, global_key='wms.image_formats')
        srs = self.context.globals.get_value('srs', conf, global_key='wms.srs')

        # WMTS restful template
        wmts_conf = self.context.services.conf.get('wmts', {})
        from mapproxy.service.wmts import WMTSRestServer
        if wmts_conf:
            restful_template = wmts_conf.get('restful_template', WMTSRestServer.default_template)
        else:
            restful_template = WMTSRestServer.default_template

        return DemoServer(layers, md, tile_layers=tile_layers,
            image_formats=image_formats, srs=srs, services=services, restful_template=restful_template)


def load_configuration(mapproxy_conf, seed=False, ignore_warnings=True, renderd=False):
    conf_base_dir = os.path.abspath(os.path.dirname(mapproxy_conf))

    try:
        conf_dict = load_configuration_file([os.path.basename(mapproxy_conf)], conf_base_dir)
    except YAMLError, ex:
        raise ConfigurationError(ex)
    errors, informal_only = validate_mapproxy_conf(conf_dict)
    for error in errors:
        log.warn(error)
    if not informal_only or (errors and not ignore_warnings):
        raise ConfigurationError('invalid configuration')
    return ProxyConfiguration(conf_dict, conf_base_dir=conf_base_dir, seed=seed,
        renderd=renderd)

def load_configuration_file(files, working_dir):
    """
    Return configuration dict from imported files
    """
    # record all config files with timestamp for reloading
    conf_dict = {'__config_files__': {}}
    for conf_file in files:
        conf_file = os.path.normpath(os.path.join(working_dir, conf_file))
        log.info('reading: %s' % conf_file)
        current_dict = load_yaml_file(conf_file)

        conf_dict['__config_files__'][os.path.abspath(conf_file)] = os.path.getmtime(conf_file)

        if 'base' in current_dict:
            current_working_dir = os.path.dirname(conf_file)
            base_files = current_dict.pop('base')
            if isinstance(base_files, basestring):
                base_files = [base_files]
            imported_dict = load_configuration_file(base_files, current_working_dir)
            current_dict = merge_dict(current_dict, imported_dict)

        conf_dict = merge_dict(conf_dict, current_dict)

    return conf_dict

def merge_dict(conf, base):
    """
    Return `base` dict with values from `conf` merged in.
    """
    for k, v in conf.iteritems():
        if k not in base:
            base[k] = v
        else:
            if isinstance(base[k], dict):
                merge_dict(v, base[k])
            else:
                base[k] = v
    return base

def parse_color(color):
    """
    >>> parse_color((100, 12, 55))
    (100, 12, 55)
    >>> parse_color('0xff0530')
    (255, 5, 48)
    >>> parse_color('#FF0530')
    (255, 5, 48)
    >>> parse_color('#FF053080')
    (255, 5, 48, 128)
    """
    if isinstance(color, (list, tuple)) and 3 <= len(color) <= 4:
        return tuple(color)
    if not isinstance(color, basestring):
        raise ValueError('color needs to be a tuple/list or 0xrrggbb/#rrggbb(aa) string, got %r' % color)

    if color.startswith('0x'):
        color = color[2:]
    if color.startswith('#'):
        color = color[1:]

    r, g, b = map(lambda x: int(x, 16), [color[:2], color[2:4], color[4:6]])

    if len(color) == 8:
        a = int(color[6:8], 16)
        return r, g, b, a

    return r, g, b



########NEW FILE########
__FILENAME__ = spec
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from mapproxy.util.ext.dictspec.validator import validate, ValidationError
from mapproxy.util.ext.dictspec.spec import one_of, anything, number
from mapproxy.util.ext.dictspec.spec import recursive, required, type_spec, combined


def validate_mapproxy_conf(conf_dict):
    """
    Validate `conf_dict` agains mapproxy.yaml spec.
    Returns lists with errors. List is empty when no errors where found.
    """
    try:
        validate(mapproxy_yaml_spec, conf_dict)
    except ValidationError, ex:
        return ex.errors, ex.informal_only
    else:
        return [], True

coverage = {
    'polygons': str(),
    'polygons_srs': str(),
    'bbox': one_of(str(), [number()]),
    'bbox_srs': str(),
    'ogr_datasource': str(),
    'ogr_where': str(),
    'ogr_srs': str(),
    'datasource': one_of(str(), [number()]),
    'where': str(),
    'srs': str(),
}
image_opts = {
    'mode': str(),
    'colors': number(),
    'transparent': bool(),
    'resampling_method': str(),
    'format': str(),
    'encoding_options': {
        anything(): anything()
    },
    'merge_method': str(),
}

http_opts = {
    'method': str(),
    'client_timeout': number(),
    'ssl_no_cert_checks': bool(),
    'ssl_ca_certs': str(),
    'headers': {
        anything(): str()
    },
}

mapserver_opts = {
    'binary': str(),
    'working_dir': str(),
}

scale_hints = {
    'max_scale': number(),
    'min_scale': number(),
    'max_res': number(),
    'min_res': number(),
}

source_commons = combined(
    scale_hints,
    {
        'concurrent_requests': int(),
        'coverage': coverage,
        'seed_only': bool(),
    }
)

riak_node = {
    'host': str(),
    'pb_port': number(),
    'http_port': number(),
}

cache_types = {
    'file': {
        'directory_layout': str(),
        'use_grid_names': bool(),
        'directory': str(),
        'tile_lock_dir': str(),
    },
    'sqlite': {
        'directory': str(),
        'tile_lock_dir': str(),
    },
    'mbtiles': {
        'filename': str(),
        'tile_lock_dir': str(),
    },
    'couchdb': {
        'url': str(),
        'db_name': str(),
        'tile_metadata': {
            anything(): anything()
        },
        'tile_id': str(),
        'tile_lock_dir': str(),
    },
    'riak': {
        'nodes': [riak_node],
        'protocol': one_of('pbc', 'http', 'https'),
        'bucket': str(),
        'default_ports': {
            'pb': number(),
            'http': number(),
        },
        'secondary_index': bool(),
    }
}

on_error = {
    anything(): {
        required('response'): one_of([int], str),
        'cache': bool,
    }
}

wms_130_layer_md = {
    'abstract': basestring,
    'keyword_list': [
        {
            'vocabulary': basestring,
            'keywords': [basestring],
        }
    ],
    'attribution': {
        'title': basestring,
        'url':    str,
        'logo': {
            'url':    str,
            'width':  int,
            'height': int,
            'format': basestring,
       }
    },
    'identifier': [
        {
            'url': str,
            'name': basestring,
            'value': basestring,
        }
    ],
    'metadata': [
        {
            'url': str,
            'type': str,
            'format': str,
        },
    ],
    'data': [
        {
            'url': str,
            'format': str,
        }

    ],
    'feature_list': [
        {
            'url': str,
            'format': str,
        }
    ],
}

grid_opts = {
    'base': str(),
    'name': str(),
    'srs': str(),
    'bbox': one_of(str(), [number()]),
    'bbox_srs': str(),
    'num_levels': int(),
    'res': [number()],
    'res_factor': one_of(number(), str()),
    'max_res': number(),
    'min_res': number(),
    'stretch_factor': number(),
    'max_shrink_factor': number(),
    'align_resolutions_with': str(),
    'origin': str(),
    'tile_size': [int()],
    'threshold_res': [number()],
}

ogc_service_md = {
    'title': basestring,
    'abstract': basestring,
    'online_resource': basestring,
    'contact': anything(),
    'fees': basestring,
    'access_constraints': basestring,
}

mapproxy_yaml_spec = {
    '__config_files__': anything(), # only used internaly
    'globals': {
        'image': {
            'resampling_method': 'method',
            'paletted': bool(),
            'stretch_factor': number(),
            'max_shrink_factor': number(),
            'jpeg_quality': number(),
            'formats': {
                anything(): image_opts,
            },
            'font_dir': str(),
            'merge_method': str(),
        },
        'http': http_opts,
        'cache': {
            'base_dir': str(),
            'lock_dir': str(),
            'tile_lock_dir': str(),
            'meta_size': [number()],
            'meta_buffer': number(),
            'max_tile_limit': number(),
            'minimize_meta_requests': bool(),
            'concurrent_tile_creators': int(),
        },
        'grid': {
            'tile_size': [int()],
        },
        'srs': {
          'axis_order_ne': [str()],
          'axis_order_en': [str()],
          'proj_data_dir': str(),
        },
        'tiles': {
            'expires_hours': number(),
        },
        'mapserver': mapserver_opts,
        'renderd': {
            'address': str(),
        }
    },
    'grids': {
        anything(): grid_opts,
    },
    'caches': {
        anything(): {
            required('sources'): [str()],
            'name': str(),
            'grids': [str()],
            'cache_dir': str(),
            'meta_size': [number()],
            'meta_buffer': number(),
            'minimize_meta_requests': bool(),
            'concurrent_tile_creators': int(),
            'disable_storage': bool(),
            'format': str(),
            'image': image_opts,
            'request_format': str(),
            'use_direct_from_level': number(),
            'use_direct_from_res': number(),
            'link_single_color_images': bool(),
            'watermark': {
                'text': basestring,
                'font_size': number(),
                'color': one_of(str(), [number()]),
                'opacity': number(),
                'spacing': str(),
            },
            'cache': type_spec('type', cache_types)
        }
    },
    'services': {
        'demo': {},
        'kml': {
            'use_grid_names': bool(),
        },
        'tms': {
            'use_grid_names': bool(),
            'origin': str(),
        },
        'wmts': {
            'kvp': bool(),
            'restful': bool(),
            'restful_template': str(),
            'md': ogc_service_md,
        },
        'wms': {
            'srs': [str()],
            'bbox_srs': [one_of(str(), {'bbox': [number()], 'srs': str()})],
            'image_formats': [str()],
            'attribution': {
                'text': basestring,
            },
            'featureinfo_types': [str()],
            'featureinfo_xslt': {
                anything(): str()
            },
            'on_source_errors': str(),
            'max_output_pixels': one_of(number(), [number()]),
            'strict': bool(),
            'md': ogc_service_md,
            'versions': [str()],
        },
    },

    'sources': {
        anything(): type_spec('type', {
            'wms': combined(source_commons, {
                'wms_opts': {
                    'version': str(),
                    'map': bool(),
                    'featureinfo': bool(),
                    'legendgraphic': bool(),
                    'legendurl': str(),
                    'featureinfo_format': str(),
                    'featureinfo_xslt': str(),
                },
                'image': combined(image_opts, {
                    'opacity':number(),
                    'transparent_color': one_of(str(), [number()]),
                    'transparent_color_tolerance': number(),
                }),
                'supported_formats': [str()],
                'supported_srs': [str()],
                'http': http_opts,
                'forward_req_params': [str()],
                required('req'): {
                    required('url'): str(),
                    anything(): anything()
                }
            }),
            'mapserver': combined(source_commons, {
                    'wms_opts': {
                        'version': str(),
                        'map': bool(),
                        'featureinfo': bool(),
                        'legendgraphic': bool(),
                        'legendurl': str(),
                        'featureinfo_format': str(),
                        'featureinfo_xslt': str(),
                    },
                    'image': combined(image_opts, {
                        'opacity':number(),
                        'transparent_color': one_of(str(), [number()]),
                        'transparent_color_tolerance': number(),
                    }),
                    'supported_formats': [str()],
                    'supported_srs': [str()],
                    'forward_req_params': [str()],
                    required('req'): {
                        required('map'): str(),
                        anything(): anything()
                    },
                    'mapserver': mapserver_opts,
            }),
            'tile': combined(source_commons, {
                required('url'): str(),
                'transparent': bool(),
                'image': image_opts,
                'grid': str(),
                'request_format': str(),
                'origin': str(), # TODO: remove with 1.5
                'http': http_opts,
                'on_error': on_error,
            }),
            'mapnik': combined(source_commons, {
                required('mapfile'): str(),
                'transparent': bool(),
                'image': image_opts,
                'layers': one_of(str(), [str()]),
                'use_mapnik2': bool(),
            }),
            'debug': {
            },
        })
    },

    'layers': one_of(
        {
            anything(): combined(scale_hints, {
                'sources': [str()],
                required('title'): basestring,
                'legendurl': str(),
                'md': wms_130_layer_md,
            })
        },
        recursive([combined(scale_hints, {
            'sources': [str()],
            'name': str(),
            required('title'): basestring,
            'legendurl': str(),
            'layers': recursive(),
            'md': wms_130_layer_md,
            'dimensions': {
                anything(): {
                    required('values'): [one_of(basestring, float, int)],
                    'default': one_of(basestring, float, int),
                }
            }
        })])
    ),
     # `parts` can be used for partial configurations that are referenced
     # from other sections (e.g. coverages, dimensions, etc.)
    'parts': anything(),
}

if __name__ == '__main__':
    import sys
    import yaml
    for f in sys.argv[1:]:
        data = yaml.load(open(f))
        try:
            validate(mapproxy_yaml_spec, data)
        except ValidationError, ex:
            for err in ex.errors:
                print '%s: %s' % (f, err)

########NEW FILE########
__FILENAME__ = exception
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Service exception handling (WMS exceptions, XML, in_image, etc.).
"""
import cgi
from mapproxy.response import Response

class RequestError(Exception):
    """
    Exception for all request related errors.
    
    :ivar internal: True if the error was an internal error, ie. the request itself
                    was valid (e.g. the source server is unreachable
    """
    def __init__(self, message, code=None, request=None, internal=False, status=None):
        Exception.__init__(self, message)
        self.msg = message
        self.code = code
        self.request = request
        self.internal = internal
        self.status = status
    
    def render(self):
        """
        Return a response with the rendered exception.
        The rendering is delegated to the ``exception_handler`` that issued
        the ``RequestError``.
        
        :rtype: `Response`
        """
        if self.request is not None:
            handler = self.request.exception_handler
            return handler.render(self)
        elif self.status is not None:
            return Response(self.msg, status=self.status)
        else:
            return Response('internal error: %s' % self.msg, status=500)
    
    def __str__(self):
        return 'RequestError("%s", code=%r, request=%r)' % (self.msg, self.code,
                                                            self.request)


class ExceptionHandler(object):
    """
    Base class for exception handler.
    """
    def render(self, request_error):
        """
        Return a response with the rendered exception.
        
        :param request_error: the exception to render
        :type request_error: `RequestError`
        :rtype: `Response`
        """
        raise NotImplementedError()

def _not_implemented(*args, **kw):
    raise NotImplementedError()

class XMLExceptionHandler(ExceptionHandler):
    """
    Mixin class for tempita-based template renderer.
    """
    template_file = None
    """The filename of the tempita xml template"""
    
    content_type = None
    """
    The mime type of the exception response (use this or mimetype).
    The content_type is sent as defined here.
    """
    
    status_code = 200
    """
    The HTTP status code.
    """
    
    status_codes = {}
    """
    Mapping of exceptionCodes to status_codes. If not defined
    status_code is used.
    """
    
    mimetype = None
    """
    The mime type of the exception response. (use this or content_type).
    A character encoding might be added to the mimetype (like text/xml;charset=UTF-8) 
    """
    
    template_func = _not_implemented
    """
    Function that returns the named template.
    """
    
    def render(self, request_error):
        """
        Render the template of this exception handler. Passes the 
        ``request_error.msg`` and ``request_error.code`` to the template.
        
        :type request_error: `RequestError`
        """
        status_code = self.status_codes.get(request_error.code, self.status_code)
        # escape &<> in error message (e.g. URL params)
        msg = cgi.escape(request_error.msg)
        result = self.template.substitute(exception=msg,
                                          code=request_error.code)
        return Response(result, mimetype=self.mimetype, content_type=self.content_type,
                        status=status_code)
    
    @property
    def template(self):
        """
        The template for this ExceptionHandler.
        """
        return self.template_func(self.template_file)

class PlainExceptionHandler(ExceptionHandler):
    mimetype = 'text/plain'
    status_code = 404

    def render(self, request_error):
        if request_error.internal:
            self.status_code = 500
        return Response(request_error.msg, status=self.status_code,
                        mimetype=self.mimetype)

########NEW FILE########
__FILENAME__ = featureinfo
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import copy
from cStringIO import StringIO
from mapproxy.request.base import split_mime_type

try:
    from lxml import etree, html
    has_xslt_support = True
    etree, html # prevent pyflakes warning
except ImportError:
    has_xslt_support = False
    etree = html = None

class FeatureInfoDoc(object):
    content_type = None

    def as_etree(self):
        raise NotImplementedError()

    def as_string(self):
        raise NotImplementedError()


class TextFeatureInfoDoc(FeatureInfoDoc):
    info_type = 'text'

    def __init__(self, content):
        self.content = content

    def as_string(self):
        return self.content

    @classmethod
    def combine(cls, docs):
        result_content = [doc.as_string() for doc in docs]
        return cls('\n'.join(result_content))

class XMLFeatureInfoDoc(FeatureInfoDoc):
    info_type = 'xml'

    def __init__(self, content):
        if isinstance(content, basestring):
            self._str_content = content
            self._etree = None
        else:
            self._str_content = None
            if hasattr(content, 'getroottree'):
                content = content.getroottree()
            self._etree = content
            assert hasattr(content, 'getroot'), "expected etree like object"

    def as_string(self):
        if self._str_content is None:
            self._str_content = self._serialize_etree()
        return self._str_content

    def as_etree(self):
        if self._etree is None:
            self._etree = self._parse_str_content()
        return self._etree

    def _serialize_etree(self):
        return etree.tostring(self._etree)

    def _parse_str_content(self):
        doc = StringIO(self._str_content)
        return etree.parse(doc)

    @classmethod
    def combine(cls, docs):
        if etree is None: return TextFeatureInfoDoc.combine(docs)
        doc = docs.pop(0)
        result_tree = copy.deepcopy(doc.as_etree())
        for doc in docs:
            tree = doc.as_etree()
            result_tree.getroot().extend(tree.getroot().iterchildren())

        return cls(result_tree)

class HTMLFeatureInfoDoc(XMLFeatureInfoDoc):
    info_type = 'html'

    def _parse_str_content(self):
        root = html.document_fromstring(self._str_content)
        return root

    def _serialize_etree(self):
        return html.tostring(self._etree)

    @classmethod
    def combine(cls, docs):
        if etree is None:
            return TextFeatureInfoDoc.combine(docs)

        doc = docs.pop(0)
        result_tree = copy.deepcopy(doc.as_etree())

        for doc in docs:
            tree = doc.as_etree()

            try:
                body = tree.body.getchildren()
            except IndexError:
                body = tree.getchildren()
            result_tree.body.extend(body)

        return cls(result_tree)

def create_featureinfo_doc(content, info_format):
    info_format = info_format.split(';', 1)[0].strip() # remove mime options like charset
    if info_format in ('text/xml', 'application/vnd.ogc.gml'):
        return XMLFeatureInfoDoc(content)
    if info_format == 'text/html':
        return HTMLFeatureInfoDoc(content)

    return TextFeatureInfoDoc(content)


class XSLTransformer(object):
    def __init__(self, xsltscript):
        self.xsltscript = xsltscript

    def transform(self, input_doc):
        input_tree = input_doc.as_etree()
        xslt_tree = etree.parse(self.xsltscript)
        transform = etree.XSLT(xslt_tree)
        output_tree = transform(input_tree)
        return XMLFeatureInfoDoc(output_tree)

    __call__ = transform

def combined_inputs(input_docs):
    doc = input_docs.pop(0)
    input_tree = etree.parse(StringIO(doc))
    for doc in input_docs:
        doc_tree = etree.parse(StringIO(doc))
        input_tree.getroot().extend(doc_tree.getroot().iterchildren())
    return input_tree

########NEW FILE########
__FILENAME__ = grid
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
(Meta-)Tile grids (data and calculations).
"""
from __future__ import division
import math

from mapproxy.srs import SRS, get_epsg_num, merge_bbox, bbox_equals
from mapproxy.util.collections import ImmutableDictList

geodetic_epsg_codes = [4326]

class GridError(Exception):
    pass

class NoTiles(GridError):
    pass

def get_resolution(bbox, size):
    """
    Calculate the highest resolution needed to draw the bbox
    into an image with given size.

    >>> get_resolution((-180,-90,180,90), (256, 256))
    0.703125

    :returns: the resolution
    :rtype: float
    """
    w = abs(bbox[0] - bbox[2])
    h = abs(bbox[1] - bbox[3])
    return min(w/size[0], h/size[1])

def tile_grid_for_epsg(epsg, bbox=None, tile_size=(256, 256), res=None):
    """
    Create a tile grid that matches the given epsg code:

    :param epsg: the epsg code
    :type epsg: 'EPSG:0000', '0000' or 0000
    :param bbox: the bbox of the grid
    :param tile_size: the size of each tile
    :param res: a list with all resolutions
    """
    epsg = get_epsg_num(epsg)
    if epsg in geodetic_epsg_codes:
        return TileGrid(epsg, is_geodetic=True, bbox=bbox, tile_size=tile_size, res=res)
    return TileGrid(epsg, bbox=bbox, tile_size=tile_size, res=res)


# defer loading of default bbox since custom proj settings
# are not loaded on import time
class _default_bboxs(object):
    _defaults = {
        4326: (-180, -90, 180, 90),
    }
    for epsg_num in (900913, 3857, 102100, 102113):
        _defaults[epsg_num] = (-20037508.342789244,
                                -20037508.342789244,
                                20037508.342789244,
                                20037508.342789244)
    defaults = None
    def get(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            return default
    def __getitem__(self, key):
        if self.defaults is None:
            defaults = {}
            for epsg, bbox in self._defaults.iteritems():
                defaults[SRS(epsg)] = bbox
            self.defaults = defaults
        return self.defaults[key]
default_bboxs = _default_bboxs()

def tile_grid(srs=None, bbox=None, bbox_srs=None, tile_size=(256, 256),
              res=None, res_factor=2.0, threshold_res=None,
              num_levels=None, min_res=None, max_res=None,
              stretch_factor=1.15, max_shrink_factor=4.0,
              align_with=None, origin='ll', name=None
              ):
    """
    This function creates a new TileGrid.
    """
    if srs is None: srs = 'EPSG:900913'
    srs = SRS(srs)

    if not bbox:
        bbox = default_bboxs.get(srs)
        if not bbox:
            raise ValueError('need a bbox for grid with %s' % srs)

    bbox = grid_bbox(bbox, srs=srs, bbox_srs=bbox_srs)

    if res:
        if isinstance(res, list):
            if isinstance(res[0], (tuple, list)):
                # named resolutions
                res = sorted(res, key=lambda x: x[1], reverse=True)
            else:
                res = sorted(res, reverse=True)
            assert min_res is None
            assert max_res is None
            assert align_with is None
        else:
            raise ValueError("res is not a list, use res_factor for float values")


    elif align_with is not None:
        res = aligned_resolutions(min_res, max_res, res_factor, num_levels, bbox, tile_size,
                                  align_with)
    else:
        res = resolutions(min_res, max_res, res_factor, num_levels, bbox, tile_size)

    origin = origin_from_string(origin)

    return TileGrid(srs, bbox=bbox, tile_size=tile_size, res=res, threshold_res=threshold_res,
                    stretch_factor=stretch_factor, max_shrink_factor=max_shrink_factor,
                    origin=origin, name=name)

ORIGIN_UL = 'ul'
ORIGIN_LL = 'll'

def origin_from_string(origin):
    if origin == None:
        origin = ORIGIN_LL
    elif origin.lower() in ('ll', 'sw'):
        origin = ORIGIN_LL
    elif origin.lower() in ('ul', 'nw'):
        origin =  ORIGIN_UL
    else:
        raise ValueError("unknown origin value '%s'" % origin)
    return origin

def aligned_resolutions(min_res=None, max_res=None, res_factor=2.0, num_levels=None,
                bbox=None, tile_size=(256, 256), align_with=None):


    alinged_res = align_with.resolutions
    res = list(alinged_res)

    if not min_res:
        width = bbox[2] - bbox[0]
        height = bbox[3] - bbox[1]
        min_res = max(width/tile_size[0], height/tile_size[1])

    res = [r for r in res if r <= min_res]

    if max_res:
        res = [r for r in res if r >= max_res]

    if num_levels:
        res = res[:num_levels]

    factor_calculated = res[0]/res[1]
    if res_factor == 'sqrt2' and round(factor_calculated, 8) != round(math.sqrt(2), 8):
        if round(factor_calculated, 8) == 2.0:
            new_res = []
            for r in res:
                new_res.append(r)
                new_res.append(r/math.sqrt(2))
            res = new_res
    elif res_factor == 2.0 and round(factor_calculated, 8) != round(2.0, 8):
        if round(factor_calculated, 8) == round(math.sqrt(2), 8):
            res = res[::2]
    return res


def resolutions(min_res=None, max_res=None, res_factor=2.0, num_levels=None,
                bbox=None, tile_size=(256, 256)):
    if res_factor == 'sqrt2':
        res_factor = math.sqrt(2)

    res = []
    if not min_res:
        width = bbox[2] - bbox[0]
        height = bbox[3] - bbox[1]
        min_res = max(width/tile_size[0], height/tile_size[1])

    if max_res:
        if num_levels:
            res_step = (math.log10(min_res) - math.log10(max_res)) / (num_levels-1)
            res = [10**(math.log10(min_res) - res_step*i) for i in range(num_levels)]
        else:
            res = [min_res]
            while True:
                next_res = res[-1]/res_factor
                if max_res >= next_res:
                    break
                res.append(next_res)
    else:
        if not num_levels:
            num_levels = 20 if res_factor != math.sqrt(2) else 40
        res = [min_res]
        while len(res) < num_levels:
            res.append(res[-1]/res_factor)

    return res

def grid_bbox(bbox, bbox_srs, srs):
    bbox = bbox_tuple(bbox)
    if bbox_srs:
        bbox = SRS(bbox_srs).transform_bbox_to(srs, bbox)
    return bbox

def bbox_tuple(bbox):
    """
    >>> bbox_tuple('20,-30,40,-10')
    (20.0, -30.0, 40.0, -10.0)
    >>> bbox_tuple([20,-30,40,-10])
    (20.0, -30.0, 40.0, -10.0)

    """
    if isinstance(bbox, basestring):
        bbox = bbox.split(',')
    bbox = tuple(map(float, bbox))
    return bbox



def bbox_width(bbox):
    return bbox[2] - bbox[0]

def bbox_height(bbox):
    return bbox[3] - bbox[1]

def bbox_size(bbox):
    return bbox_width(bbox), bbox_height(bbox)


class NamedGridList(ImmutableDictList):
    def __init__(self, items):
        tmp = []
        for i, value in enumerate(items):
            if isinstance(value, (tuple, list)):
                name, value = value
            else:
                name = str('%02d' % i)
            tmp.append((name, value))
        ImmutableDictList.__init__(self, tmp)

class TileGrid(object):
    """
    This class represents a regular tile grid. The first level (0) contains a single
    tile, the origin is bottom-left.

    :ivar levels: the number of levels
    :ivar tile_size: the size of each tile in pixel
    :type tile_size: ``int(with), int(height)``
    :ivar srs: the srs of the grid
    :type srs: `SRS`
    :ivar bbox: the bbox of the grid, tiles may overlap this bbox
    """

    spheroid_a = 6378137.0 # for 900913
    flipped_y_axis = False

    def __init__(self, srs=900913, bbox=None, tile_size=(256, 256), res=None,
                 threshold_res=None, is_geodetic=False, levels=None,
                 stretch_factor=1.15, max_shrink_factor=4.0, origin='ll',
                 name=None):
        """
        :param stretch_factor: allow images to be scaled up by this factor
            before the next level will be selected
        :param max_shrink_factor: allow images to be scaled down by this
            factor before NoTiles is raised

        >>> grid = TileGrid(srs=900913)
        >>> [round(x, 2) for x in grid.bbox]
        [-20037508.34, -20037508.34, 20037508.34, 20037508.34]
        """
        if isinstance(srs, (int, basestring)):
            srs = SRS(srs)
        self.srs = srs
        self.tile_size = tile_size
        self.origin = origin_from_string(origin)
        self.name = name

        if self.origin == 'ul':
            self.flipped_y_axis = True

        self.is_geodetic = is_geodetic

        self.stretch_factor = stretch_factor
        self.max_shrink_factor = max_shrink_factor

        if levels is None:
            self.levels = 20
        else:
            self.levels = levels

        if bbox is None:
            bbox = self._calc_bbox()
        self.bbox = bbox

        factor = None

        if res is None:
            factor = 2.0
            res = self._calc_res(factor=factor)
        elif res == 'sqrt2':
            if levels is None:
                self.levels = 40
            factor = math.sqrt(2)
            res = self._calc_res(factor=factor)
        elif is_float(res):
            factor = float(res)
            res = self._calc_res(factor=factor)

        self.levels = len(res)
        self.resolutions = NamedGridList(res)

        self.threshold_res = None
        if threshold_res:
            self.threshold_res = sorted(threshold_res)


        self.grid_sizes = self._calc_grids()

    def _calc_grids(self):
        width = self.bbox[2] - self.bbox[0]
        height = self.bbox[3] - self.bbox[1]
        grids = []
        for idx, res in self.resolutions.iteritems():
            x = max(math.ceil(width // res / self.tile_size[0]), 1)
            y = max(math.ceil(height // res / self.tile_size[1]), 1)
            grids.append((idx, (int(x), int(y))))
        return NamedGridList(grids)

    def _calc_bbox(self):
        if self.is_geodetic:
            return (-180.0, -90.0, 180.0, 90.0)
        else:
            circum = 2 * math.pi * self.spheroid_a
            offset = circum / 2.0
            return (-offset, -offset, offset, offset)

    def _calc_res(self, factor=None):
        width = self.bbox[2] - self.bbox[0]
        height = self.bbox[3] - self.bbox[1]
        initial_res = max(width/self.tile_size[0], height/self.tile_size[1])
        if factor is None:
            return pyramid_res_level(initial_res, levels=self.levels)
        else:
            return pyramid_res_level(initial_res, factor, levels=self.levels)

    def resolution(self, level):
        """
        Returns the resolution of the `level` in units/pixel.

        :param level: the zoom level index (zero is top)

        >>> grid = TileGrid(SRS(900913))
        >>> '%.5f' % grid.resolution(0)
        '156543.03393'
        >>> '%.5f' % grid.resolution(1)
        '78271.51696'
        >>> '%.5f' % grid.resolution(4)
        '9783.93962'
        """
        return self.resolutions[level]

    def closest_level(self, res):
        """
        Returns the level index that offers the required resolution.

        :param res: the required resolution
        :returns: the level with the requested or higher resolution

        >>> grid = TileGrid(SRS(900913))
        >>> grid.stretch_factor = 1.1
        >>> l1_res = grid.resolution(1)
        >>> [grid.closest_level(x) for x in (320000.0, 160000.0, l1_res+50, l1_res, \
                                             l1_res-50, l1_res*0.91, l1_res*0.89, 8000.0)]
        [0, 0, 1, 1, 1, 1, 2, 5]
        """
        prev_l_res = self.resolutions[0]
        threshold = None
        thresholds = []
        if self.threshold_res:
            thresholds = self.threshold_res[:]
            threshold = thresholds.pop()
            # skip thresholds above first res
            while threshold > prev_l_res and thresholds:
                threshold = thresholds.pop()

        threshold_result = None
        for level, l_res in enumerate(self.resolutions):
            if threshold and prev_l_res > threshold >= l_res:
                if res > threshold:
                    return level-1
                elif res >= l_res:
                    return level
                threshold = thresholds.pop() if thresholds else None

            if threshold_result is not None:
                return threshold_result

            if l_res <= res*self.stretch_factor:
                threshold_result = level
            prev_l_res = l_res
        return level

    def tile(self, x, y, level):
        """
        Returns the tile id for the given point.

        >>> grid = TileGrid(SRS(900913))
        >>> grid.tile(1000, 1000, 0)
        (0, 0, 0)
        >>> grid.tile(1000, 1000, 1)
        (1, 1, 1)
        >>> grid = TileGrid(SRS(900913), tile_size=(512, 512))
        >>> grid.tile(1000, 1000, 2)
        (2, 2, 2)
        """
        res = self.resolution(level)
        x = x - self.bbox[0]
        if self.flipped_y_axis:
            y = self.bbox[3] - y
        else:
            y = y - self.bbox[1]
        tile_x = x/float(res*self.tile_size[0])
        tile_y = y/float(res*self.tile_size[1])
        return (int(math.floor(tile_x)), int(math.floor(tile_y)), level)

    def flip_tile_coord(self, (x, y, z)):
        """
        Flip the tile coord on the y-axis. (Switch between bottom-left and top-left
        origin.)

        >>> grid = TileGrid(SRS(900913))
        >>> grid.flip_tile_coord((0, 1, 1))
        (0, 0, 1)
        >>> grid.flip_tile_coord((1, 3, 2))
        (1, 0, 2)
        """
        return (x, self.grid_sizes[z][1]-1-y, z)

    def supports_access_with_origin(self, origin):
        if origin_from_string(origin) == self.origin:
            return True

        # check for each level if the top and bottom coordinates of the tiles
        # match the bbox of the grid. only in this case we can flip y-axis
        # without any issues

        # allow for some rounding errors in the _tiles_bbox calculations
        delta = max(abs(self.bbox[1]), abs(self.bbox[3])) / 1e12

        for level, grid_size in enumerate(self.grid_sizes):
            level_bbox = self._tiles_bbox([(0, 0, level),
                (grid_size[0] - 1, grid_size[1] - 1, level)])

            if abs(self.bbox[1] - level_bbox[1]) > delta or abs(self.bbox[3] - level_bbox[3]) > delta:
                return False
        return True

    def origin_tile(self, level, origin):
        assert self.supports_access_with_origin(origin), 'tile origins are incompatible'
        tile = (0, 0, level)

        if origin_from_string(origin) == self.origin:
            return tile

        return self.flip_tile_coord(tile)

    def get_affected_tiles(self, bbox, size, req_srs=None):
        """
        Get a list with all affected tiles for a bbox and output size.

        :returns: the bbox, the size and a list with tile coordinates, sorted row-wise
        :rtype: ``bbox, (xs, yz), [(x, y, z), ...]``

        >>> grid = TileGrid()
        >>> bbox = (-20037508.34, -20037508.34, 20037508.34, 20037508.34)
        >>> tile_size = (256, 256)
        >>> grid.get_affected_tiles(bbox, tile_size)
        ... #doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
        ((-20037508.342789244, -20037508.342789244,\
          20037508.342789244, 20037508.342789244), (1, 1),\
          <generator object ...>)
        """
        src_bbox, level = self.get_affected_bbox_and_level(bbox, size, req_srs=req_srs)
        return self.get_affected_level_tiles(src_bbox, level)

    def get_affected_bbox_and_level(self, bbox, size, req_srs=None):
        if req_srs and req_srs != self.srs:
            src_bbox = req_srs.transform_bbox_to(self.srs, bbox)
        else:
            src_bbox = bbox

        if not bbox_intersects(self.bbox, src_bbox):
            raise NoTiles()

        res = get_resolution(src_bbox, size)
        level = self.closest_level(res)

        if res > self.resolutions[0]*self.max_shrink_factor:
            raise NoTiles()

        return src_bbox, level

    def get_affected_level_tiles(self, bbox, level):
        """
        Get a list with all affected tiles for a `bbox` in the given `level`.
        :returns: the bbox, the size and a list with tile coordinates, sorted row-wise
        :rtype: ``bbox, (xs, yz), [(x, y, z), ...]``

        >>> grid = TileGrid()
        >>> bbox = (-20037508.34, -20037508.34, 20037508.34, 20037508.34)
        >>> grid.get_affected_level_tiles(bbox, 0)
        ... #doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
        ((-20037508.342789244, -20037508.342789244,\
          20037508.342789244, 20037508.342789244), (1, 1),\
          <generator object ...>)
        """
        # remove 1/10 of a pixel so we don't get a tiles we only touch
        delta = self.resolutions[level] / 10.0
        x0, y0, _ = self.tile(bbox[0]+delta, bbox[1]+delta, level)
        x1, y1, _ = self.tile(bbox[2]-delta, bbox[3]-delta, level)
        try:
            return self._tile_iter(x0, y0, x1, y1, level)
        except IndexError:
            raise GridError('Invalid BBOX')

    def _tile_iter(self, x0, y0, x1, y1, level):
        xs = range(x0, x1+1)
        if self.flipped_y_axis:
            y0, y1 = y1, y0
            ys = range(y0, y1+1)
        else:
            ys = range(y1, y0-1, -1)

        ll = (xs[0], ys[-1], level)
        ur = (xs[-1], ys[0], level)

        abbox = self._tiles_bbox([ll, ur])
        return (abbox, (len(xs), len(ys)),
                _create_tile_list(xs, ys, level, self.grid_sizes[level]))

    def _tiles_bbox(self, tiles):
        """
        Returns the bbox of multiple tiles.
        The tiles should be ordered row-wise, bottom-up.

        :param tiles: ordered list of tiles
        :returns: the bbox of all tiles
        """
        ll_bbox = self.tile_bbox(tiles[0])
        ur_bbox = self.tile_bbox(tiles[-1])
        return merge_bbox(ll_bbox, ur_bbox)

    def tile_bbox(self, tile_coord, limit=False):
        """
        Returns the bbox of the given tile.

        >>> grid = TileGrid(SRS(900913))
        >>> [round(x, 2) for x in grid.tile_bbox((0, 0, 0))]
        [-20037508.34, -20037508.34, 20037508.34, 20037508.34]
        >>> [round(x, 2) for x in grid.tile_bbox((1, 1, 1))]
        [0.0, 0.0, 20037508.34, 20037508.34]
        """
        x, y, z = tile_coord
        res = self.resolution(z)

        x0 = self.bbox[0] + round(x * res * self.tile_size[0], 12)
        x1 = x0 + round(res * self.tile_size[0], 12)

        if self.flipped_y_axis:
            y1 = self.bbox[3] - round(y * res * self.tile_size[1], 12)
            y0 = y1 - round(res * self.tile_size[1], 12)
        else:
            y0 = self.bbox[1] + round(y * res * self.tile_size[1], 12)
            y1 = y0 + round(res * self.tile_size[1], 12)

        if limit:
            return (
                max(x0, self.bbox[0]),
                max(y0, self.bbox[1]),
                min(x1, self.bbox[2]),
                min(y1, self.bbox[3])
            )

        return x0, y0, x1, y1

    def limit_tile(self, tile_coord):
        """
        Check if the `tile_coord` is in the grid.

        :returns: the `tile_coord` if it is within the ``grid``,
                  otherwise ``None``.

        >>> grid = TileGrid(SRS(900913))
        >>> grid.limit_tile((-1, 0, 2)) == None
        True
        >>> grid.limit_tile((1, 2, 1)) == None
        True
        >>> grid.limit_tile((1, 2, 2))
        (1, 2, 2)
        """
        x, y, z = tile_coord
        if isinstance(z, basestring):
            if z not in self.grid_sizes:
                return None
        elif z < 0 or z >= self.levels:
            return None
        grid = self.grid_sizes[z]
        if x < 0 or y < 0 or x >= grid[0] or y >= grid[1]:
            return None
        return x, y, z

    def __repr__(self):
        return '%s(%r, (%.4f, %.4f, %.4f, %.4f),...)' % (self.__class__.__name__,
            self.srs, self.bbox[0], self.bbox[1], self.bbox[2], self.bbox[3])

    def is_subset_of(self, other):
        """
        Returns ``True`` if every tile in `self` is present in `other`.
        Tile coordinates might differ and `other` may contain more
        tiles (more levels, larger bbox).
        """
        if self.srs != other.srs:
            return False

        if self.tile_size != other.tile_size:
            return False

        # check if all level tiles from self align with (affected)
        # tiles from other
        for self_level, self_level_res in self.resolutions.iteritems():
            level_size = (
                self.grid_sizes[self_level][0] * self.tile_size[0],
                self.grid_sizes[self_level][1] * self.tile_size[1]
            )
            level_bbox = self._tiles_bbox([
                (0, 0, self_level),
                (self.grid_sizes[self_level][0] - 1, self.grid_sizes[self_level][1] - 1, self_level)
            ])

            try:
                bbox, level = other.get_affected_bbox_and_level(level_bbox, level_size)
            except NoTiles:
                return False
            try:
                bbox, grid_size, tiles = other.get_affected_level_tiles(level_bbox, level)
            except GridError:
                return False

            if other.resolution(level) != self_level_res:
                return False
            if not bbox_equals(bbox, level_bbox):
                return False

        return True

def _create_tile_list(xs, ys, level, grid_size):
    """
    Returns an iterator tile_coords for the given tile ranges (`xs` and `ys`).
    If the one tile_coord is negative or out of the `grid_size` bound,
    the coord is None.
    """
    x_limit = grid_size[0]
    y_limit = grid_size[1]
    for y in ys:
        for x in xs:
            if x < 0 or y < 0 or x >= x_limit or y >= y_limit:
                yield None
            else:
                yield x, y, level

def is_float(x):
    try:
        float(x)
        return True
    except TypeError:
        return False

def pyramid_res_level(initial_res, factor=2.0, levels=20):
    """
    Return resolutions of an image pyramid.

    :param initial_res: the resolution of the top level (0)
    :param factor: the factor between each level, for tms access 2
    :param levels: number of resolutions to generate

    >>> pyramid_res_level(10000, levels=5)
    [10000.0, 5000.0, 2500.0, 1250.0, 625.0]
    >>> map(lambda x: round(x, 4),
    ...     pyramid_res_level(10000, factor=1/0.75, levels=5))
    [10000.0, 7500.0, 5625.0, 4218.75, 3164.0625]
    """
    return [initial_res/factor**n for n in range(levels)]

class MetaGrid(object):
    """
    This class contains methods to calculate bbox, etc. of metatiles.

    :param grid: the grid to use for the metatiles
    :param meta_size: the number of tiles a metatile consist
    :type meta_size: ``(x_size, y_size)``
    :param meta_buffer: the buffer size in pixel that is added to each metatile.
        the number is added to all four borders.
        this buffer may improve the handling of lables overlapping (meta)tile borders.
    :type meta_buffer: pixel
    """
    def __init__(self, grid, meta_size, meta_buffer=0):
        self.grid = grid
        self.meta_size = meta_size or 0
        self.meta_buffer = meta_buffer

    def _meta_bbox(self, tile_coord=None, tiles=None, limit_to_bbox=True):
        """
        Returns the bbox of the metatile that contains `tile_coord`.

        :type tile_coord: ``(x, y, z)``

        >>> mgrid = MetaGrid(grid=TileGrid(), meta_size=(2, 2))
        >>> [round(x, 2) for x in mgrid._meta_bbox((0, 0, 2))[0]]
        [-20037508.34, -20037508.34, 0.0, 0.0]
        >>> mgrid = MetaGrid(grid=TileGrid(), meta_size=(2, 2))
        >>> [round(x, 2) for x in mgrid._meta_bbox((0, 0, 0))[0]]
        [-20037508.34, -20037508.34, 20037508.34, 20037508.34]
        """
        if tiles:
            assert tile_coord is None
            level = tiles[0][2]
            bbox = self.grid._tiles_bbox(tiles)
        else:
            level = tile_coord[2]
            bbox = self.unbuffered_meta_bbox(tile_coord)
        return self._buffered_bbox(bbox, level, limit_to_bbox)


    def unbuffered_meta_bbox(self, tile_coord):
        x, y, z = tile_coord

        meta_size = self._meta_size(z)

        return self.grid._tiles_bbox([(tile_coord),
            (x+meta_size[0]-1, y+meta_size[1]-1, z)])

    def _buffered_bbox(self, bbox, level, limit_to_grid_bbox=True):
        minx, miny, maxx, maxy = bbox

        buffers = (0, 0, 0, 0)
        if self.meta_buffer > 0:
            res = self.grid.resolution(level)
            minx -= self.meta_buffer * res
            miny -= self.meta_buffer * res
            maxx += self.meta_buffer * res
            maxy += self.meta_buffer * res
            buffers = [self.meta_buffer, self.meta_buffer, self.meta_buffer, self.meta_buffer]

            if limit_to_grid_bbox:
                if self.grid.bbox[0] > minx:
                    delta = self.grid.bbox[0] - minx
                    buffers[0] = buffers[0] - int(round(delta / res, 5))
                    minx = self.grid.bbox[0]
                if self.grid.bbox[1] > miny:
                    delta = self.grid.bbox[1] - miny
                    buffers[1] = buffers[1] - int(round(delta / res, 5))
                    miny = self.grid.bbox[1]
                if self.grid.bbox[2] < maxx:
                    delta = maxx - self.grid.bbox[2]
                    buffers[2] = buffers[2] - int(round(delta / res, 5))
                    maxx = self.grid.bbox[2]
                if self.grid.bbox[3] < maxy:
                    delta = maxy - self.grid.bbox[3]
                    buffers[3] = buffers[3] - int(round(delta / res, 5))
                    maxy = self.grid.bbox[3]
        return (minx, miny, maxx, maxy), tuple(buffers)

    def meta_tile(self, tile_coord):
        """
        Returns the meta tile for `tile_coord`.
        """
        tile_coord = self.main_tile(tile_coord)
        level = tile_coord[2]
        bbox, buffers = self._meta_bbox(tile_coord)
        grid_size = self._meta_size(level)
        size = self._size_from_buffered_bbox(bbox, level)

        tile_patterns = self._tiles_pattern(tile=tile_coord, grid_size=grid_size, buffers=buffers)

        return MetaTile(bbox=bbox, size=size, tile_patterns=tile_patterns,
            grid_size=grid_size
        )

    def minimal_meta_tile(self, tiles):
        """
        Returns a MetaTile that contains all `tiles` plus ``meta_buffer``,
        but nothing more.
        """

        tiles, grid_size, bounds = self._full_tile_list(tiles)
        tiles = list(tiles)
        bbox, buffers = self._meta_bbox(tiles=bounds)

        level = tiles[0][2]
        size = self._size_from_buffered_bbox(bbox, level)

        tile_pattern = self._tiles_pattern(tiles=tiles, grid_size=grid_size, buffers=buffers)

        return MetaTile(
            bbox=bbox,
            size=size,
            tile_patterns=tile_pattern,
            grid_size=grid_size,
        )

    def _size_from_buffered_bbox(self, bbox, level):
        # meta_size * tile_size + 2*buffer does not work,
        # since the buffer can get truncated at the grid border
        res = self.grid.resolution(level)
        width = int(round((bbox[2] - bbox[0]) / res))
        height = int(round((bbox[3] - bbox[1]) / res))
        return width, height

    def _full_tile_list(self, tiles):
        """
        Return a complete list of all tiles that a minimal meta tile with `tiles` contains.

        >>> mgrid = MetaGrid(grid=TileGrid(), meta_size=(2, 2))
        >>> mgrid._full_tile_list([(0, 0, 2), (1, 1, 2)])
        ([(0, 1, 2), (1, 1, 2), (0, 0, 2), (1, 0, 2)], (2, 2), ((0, 0, 2), (1, 1, 2)))
        """
        tile = tiles.pop()
        z = tile[2]
        minx = maxx = tile[0]
        miny = maxy = tile[1]

        for tile in tiles:
            x, y = tile[:2]
            minx = min(minx, x)
            maxx = max(maxx, x)
            miny = min(miny, y)
            maxy = max(maxy, y)

        grid_size = 1+maxx-minx, 1+maxy-miny

        if self.grid.flipped_y_axis:
            ys = xrange(miny, maxy+1)
        else:
            ys = xrange(maxy, miny-1, -1)
        xs = xrange(minx, maxx+1)

        bounds = (minx, miny, z), (maxx, maxy, z)

        return list(_create_tile_list(xs, ys, z, (maxx+1, maxy+1))), grid_size, bounds

    def main_tile(self, tile_coord):
        x, y, z = tile_coord

        meta_size = self._meta_size(z)

        x0 = x//meta_size[0] * meta_size[0]
        y0 = y//meta_size[1] * meta_size[1]

        return x0, y0, z

    def tile_list(self, main_tile):
        tile_grid = self._meta_size(main_tile[2])
        return self._meta_tile_list(main_tile, tile_grid)

    def _meta_tile_list(self, main_tile, tile_grid):
        """
        >>> mgrid = MetaGrid(grid=TileGrid(), meta_size=(2, 2))
        >>> mgrid._meta_tile_list((0, 1, 3), (2, 2))
        [(0, 1, 3), (1, 1, 3), (0, 0, 3), (1, 0, 3)]
        """
        minx, miny, z = self.main_tile(main_tile)
        maxx = minx + tile_grid[0] - 1
        maxy = miny + tile_grid[1] - 1
        if self.grid.flipped_y_axis:
            ys = xrange(miny, maxy+1)
        else:
            ys = xrange(maxy, miny-1, -1)
        xs = xrange(minx, maxx+1)

        return list(_create_tile_list(xs, ys, z, self.grid.grid_sizes[z]))

    def _tiles_pattern(self, grid_size, buffers, tile=None, tiles=None):
        """
        Returns the tile pattern for the given list of tiles.
        The result contains for each tile the ``tile_coord`` and the upper-left
        pixel coordinate of the tile in the meta tile image.

        >>> mgrid = MetaGrid(grid=TileGrid(), meta_size=(2, 2))
        >>> tiles = list(mgrid._tiles_pattern(tiles=[(0, 1, 2), (1, 1, 2)],
        ...                                   grid_size=(2, 1),
        ...                                   buffers=(0, 0, 10, 10)))
        >>> tiles[0], tiles[-1]
        (((0, 1, 2), (0, 10)), ((1, 1, 2), (256, 10)))

        >>> tiles = list(mgrid._tiles_pattern(tile=(1, 1, 2),
        ...                                   grid_size=(2, 2),
        ...                                   buffers=(10, 20, 30, 40)))
        >>> tiles[0], tiles[-1]
        (((0, 1, 2), (10, 40)), ((1, 0, 2), (266, 296)))

        """
        if tile:
            tiles = self._meta_tile_list(tile, grid_size)

        for i in range(grid_size[1]):
            for j in range(grid_size[0]):
                yield tiles[j+i*grid_size[0]], (
                            j*self.grid.tile_size[0] + buffers[0],
                            i*self.grid.tile_size[1] + buffers[3])

    def _meta_size(self, level):
        grid_size = self.grid.grid_sizes[level]
        return min(self.meta_size[0], grid_size[0]), min(self.meta_size[1], grid_size[1])

    def get_affected_level_tiles(self, bbox, level):
        """
        Get a list with all affected tiles for a `bbox` in the given `level`.

        :returns: the bbox, the size and a list with tile coordinates, sorted row-wise
        :rtype: ``bbox, (xs, yz), [(x, y, z), ...]``

        >>> grid = MetaGrid(TileGrid(), (2, 2))
        >>> bbox = (-20037508.34, -20037508.34, 20037508.34, 20037508.34)
        >>> grid.get_affected_level_tiles(bbox, 0)
        ... #doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
        ((-20037508.342789244, -20037508.342789244,\
          20037508.342789244, 20037508.342789244), (1, 1),\
          <generator object ...>)
        """

        # remove 1/10 of a pixel so we don't get a tiles we only touch
        delta = self.grid.resolutions[level] / 10.0
        x0, y0, _ = self.grid.tile(bbox[0]+delta, bbox[1]+delta, level)
        x1, y1, _ = self.grid.tile(bbox[2]-delta, bbox[3]-delta, level)

        meta_size = self._meta_size(level)

        x0 = x0//meta_size[0] * meta_size[0]
        x1 = x1//meta_size[0] * meta_size[0]
        y0 = y0//meta_size[1] * meta_size[1]
        y1 = y1//meta_size[1] * meta_size[1]

        try:
            return self._tile_iter(x0, y0, x1, y1, level)
        except IndexError:
            raise GridError('Invalid BBOX')

    def _tile_iter(self, x0, y0, x1, y1, level):
        meta_size = self._meta_size(level)

        xs = range(x0, x1+1, meta_size[0])
        if self.grid.flipped_y_axis:
            y0, y1 = y1, y0
            ys = range(y0, y1+1, meta_size[1])
        else:
            ys = range(y1, y0-1, -meta_size[1])

        ll = (xs[0], ys[-1], level)
        ur = (xs[-1], ys[0], level)
        # add meta_size to get full affected bbox
        ur = ur[0]+meta_size[0]-1, ur[1]+meta_size[1]-1, ur[2]
        abbox = self.grid._tiles_bbox([ll, ur])
        return (abbox, (len(xs), len(ys)),
                _create_tile_list(xs, ys, level, self.grid.grid_sizes[level]))


class MetaTile(object):
    def __init__(self, bbox, size, tile_patterns, grid_size):
        self.bbox = bbox
        self.size = size
        self.tile_patterns = list(tile_patterns)
        self.grid_size = grid_size

    @property
    def tiles(self):
        return [t[0] for t in self.tile_patterns]

    @property
    def main_tile_coord(self):
        """
        Returns the "main" tile of the meta tile. This tile(coord) can be used
        for locking.

        >>> t = MetaTile(None, None, [((0, 0, 0), (0, 0)), ((1, 0, 0), (100, 0))], (2, 1))
        >>> t.main_tile_coord
        (0, 0, 0)
        >>> t = MetaTile(None, None, [(None, None), ((1, 0, 0), (100, 0))], (2, 1))
        >>> t.main_tile_coord
        (1, 0, 0)
        """
        for t in self.tiles:
            if t is not None:
                return t

    def __repr__(self):
        return "MetaTile(%r, %r, %r, %r)" % (self.bbox, self.size, self.grid_size,
                                             self.tile_patterns)

def bbox_intersects(one, two):
    a_x0, a_y0, a_x1, a_y1 = one
    b_x0, b_y0, b_x1, b_y1 = two

    if (
        a_x0 < b_x1 and
        a_x1 > b_x0 and
        a_y0 < b_y1 and
        a_y1 > b_y0
        ): return True

    return False

def bbox_contains(one, two):
    """
    Returns ``True`` if `one` contains `two`.

    >>> bbox_contains([0, 0, 10, 10], [2, 2, 4, 4])
    True
    >>> bbox_contains([0, 0, 10, 10], [0, 0, 11, 10])
    False

    Allow tiny rounding errors:

    >>> bbox_contains([0, 0, 10, 10], [0.000001, 0.0000001, 10.000001, 10.000001])
    False
    >>> bbox_contains([0, 0, 10, 10], [0.0000000000001, 0.0000000000001, 10.0000000000001, 10.0000000000001])
    True
    """
    a_x0, a_y0, a_x1, a_y1 = one
    b_x0, b_y0, b_x1, b_y1 = two

    x_delta = abs(a_x1 - a_x0) / 10e12
    y_delta = abs(a_y1 - a_y0) / 10e12

    if (
        a_x0 <= b_x0 + x_delta and
        a_x1 >= b_x1 - x_delta and
        a_y0 <= b_y0 + y_delta and
        a_y1 >= b_y1 - y_delta
        ): return True

    return False

def deg_to_m(deg):
    return deg * (6378137 * 2 * math.pi) / 360

OGC_PIXLE_SIZE = 0.00028 #m/px

def ogc_scale_to_res(scale):
    return scale * OGC_PIXLE_SIZE
def res_to_ogc_scale(res):
    return res / OGC_PIXLE_SIZE

def resolution_range(min_res=None, max_res=None, max_scale=None, min_scale=None):
    if min_scale == max_scale == min_res == max_res == None:
        return None
    if min_res or max_res:
        if not max_scale and not min_scale:
            return ResolutionRange(min_res, max_res)
    elif max_scale or min_scale:
        if not min_res and not max_res:
            min_res = ogc_scale_to_res(max_scale)
            max_res = ogc_scale_to_res(min_scale)
            return ResolutionRange(min_res, max_res)

    raise ValueError('requires either min_res/max_res or max_scale/min_scale')

class ResolutionRange(object):
    def __init__(self, min_res, max_res):
        self.min_res = min_res
        self.max_res = max_res

        if min_res and max_res:
            assert min_res > max_res

    def scale_denominator(self):
        min_scale = res_to_ogc_scale(self.max_res) if self.max_res else None
        max_scale = res_to_ogc_scale(self.min_res) if self.min_res else None
        return min_scale, max_scale

    def scale_hint(self):
        """
        Returns the min and max diagonal resolution.
        """
        min_res = self.min_res
        max_res = self.max_res
        if min_res:
            min_res = math.sqrt(2*min_res**2)
        if max_res:
            max_res = math.sqrt(2*max_res**2)
        return min_res, max_res

    def contains(self, bbox, size, srs):
        width, height = bbox_size(bbox)
        if srs.is_latlong:
            width = deg_to_m(width)
            height = deg_to_m(height)

        x_res = width/size[0]
        y_res = height/size[1]

        if self.min_res:
            min_res = self.min_res + 1e-6
            if min_res <= x_res or min_res <= y_res:
                return False
        if self.max_res:
            max_res = self.max_res
            if max_res > x_res or max_res > y_res:
                return False

        return True

    def __eq__(self, other):
        if not isinstance(other, ResolutionRange):
            return NotImplemented

        return (self.min_res == other.min_res
            and self.max_res == other.max_res)

    def __ne__(self, other):
        if not isinstance(other, ResolutionRange):
            return NotImplemented
        return not self == other

    def __repr__(self):
        return '<ResolutionRange(min_res=%.3f, max_res=%.3f)>' % (
            self.min_res or 9e99, self.max_res or 0)


def max_with_none(a, b):
    if a is None or b is None:
        return None
    else:
        return max(a, b)

def merge_resolution_range(a, b):
    if a and b:
        return resolution_range(min_res=max_with_none(a.min_res, b.min_res),
            max_res=min(a.max_res, b.max_res))
    return None

########NEW FILE########
__FILENAME__ = mask
# This file is part of the MapProxy project.
# Copyright (C) 2012 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from mapproxy.platform.image import Image, ImageDraw
from mapproxy.srs import SRS, make_lin_transf
from mapproxy.image import ImageSource
from mapproxy.image.opts import create_image
from mapproxy.util.geom import flatten_to_polygons

def mask_image_source_from_coverage(img_source, bbox, bbox_srs, coverage,
    image_opts=None):
    if image_opts is None:
        image_opts = img_source.image_opts
    img = img_source.as_image()
    img = mask_image(img, bbox, bbox_srs, coverage)
    result = create_image(img.size, image_opts)
    result.paste(img, (0, 0), img)
    return ImageSource(result, image_opts=image_opts)

def mask_image(img, bbox, bbox_srs, coverage):
    geom = mask_polygons(bbox, SRS(bbox_srs), coverage)
    mask = image_mask_from_geom(img, bbox, geom)
    img = img.convert('RGBA')
    img.paste((255, 255, 255, 0), (0, 0), mask)
    return img

def mask_polygons(bbox, bbox_srs, coverage):
    coverage = coverage.transform_to(bbox_srs)
    coverage = coverage.intersection(bbox, bbox_srs)
    return flatten_to_polygons(coverage.geom)

def image_mask_from_geom(img, bbox, polygons):
    transf = make_lin_transf(bbox, (0, 0) + img.size)

    mask = Image.new('L', img.size, 255)
    draw = ImageDraw.Draw(mask)

    for p in polygons:
        draw.polygon([transf(coord) for coord in p.exterior.coords], fill=0)
        for ring in p.interiors:
            draw.polygon([transf(coord) for coord in ring.coords], fill=255)

    return mask

########NEW FILE########
__FILENAME__ = merge
# This file is part of the MapProxy project.
# Copyright (C) 2010,2012 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Image and tile manipulation (transforming, merging, etc).
"""
from __future__ import with_statement

from mapproxy.platform.image import Image, ImageColor, ImageChops
from mapproxy.platform.image import has_alpha_composite_support
from mapproxy.image import BlankImageSource, ImageSource
from mapproxy.image.opts import create_image, ImageOptions
from mapproxy.image.mask import mask_image

import logging
log = logging.getLogger('mapproxy.image')

class LayerMerger(object):
    """
    Merge multiple layers into one image.
    """
    def __init__(self):
        self.layers = []
        self.cacheable = True

    def add(self, layer_img, layer=None):
        """
        Add one layer image to merge. Bottom-layers first.
        """
        if layer_img is not None:
            self.layers.append((layer_img, layer))

    def merge(self, image_opts, size=None, bbox=None, bbox_srs=None, coverage=None):
        """
        Merge the layers. If the format is not 'png' just return the last image.

        :param format: The image format for the result.
        :param size: The size for the merged output.
        :rtype: `ImageSource`
        """
        if not self.layers:
            return BlankImageSource(size=size, image_opts=image_opts, cacheable=True)
        if len(self.layers) == 1:
            layer_img, layer = self.layers[0]
            layer_opts = layer_img.image_opts
            if (((layer_opts and not layer_opts.transparent) or image_opts.transparent)
                and (not size or size == layer_img.size)
                and (not layer or not layer.coverage or not layer.coverage.clip)
                and not coverage):
                # layer is opaque, no need to make transparent or add bgcolor
                return layer_img

        if size is None:
            size = self.layers[0][0].size

        cacheable = self.cacheable
        result = create_image(size, image_opts)
        for layer_img, layer in self.layers:
            if not layer_img.cacheable:
                cacheable = False
            img = layer_img.as_image()
            layer_image_opts = layer_img.image_opts
            if layer_image_opts is None:
                opacity = None
            else:
                opacity = layer_image_opts.opacity

            if layer and layer.coverage and layer.coverage.clip:
                img = mask_image(img, bbox, bbox_srs, layer.coverage)

            if result.mode != 'RGBA':
                merge_composite = False
            else:
                merge_composite = has_alpha_composite_support()

            if merge_composite:
                if opacity is not None and opacity < 1.0:
                    # fade-out img to add opacity value
                    img = img.convert("RGBA")
                    alpha = img.split()[3]
                    alpha = ImageChops.multiply(
                        alpha,
                        ImageChops.constant(alpha, 255 * opacity)
                    )
                    img.putalpha(alpha)
                if img.mode == 'RGB':
                    result.paste(img, (0, 0))
                else:
                    # assume paletted images have transparency
                    if img.mode == 'P':
                        img = img.convert('RGBA')
                    result = Image.alpha_composite(result, img)
            else:
                if opacity is not None and opacity < 1.0:
                    img = img.convert(result.mode)
                    result = Image.blend(result, img, layer_image_opts.opacity)
                elif img.mode == 'RGBA' or img.mode == 'P':
                    # assume paletted images have transparency
                    if img.mode == 'P':
                        img = img.convert('RGBA')
                    # paste w transparency mask from layer
                    result.paste(img, (0, 0), img)
                else:
                    result.paste(img, (0, 0))

        # apply global clip coverage
        if coverage:
            bg = create_image(size, image_opts)
            mask = mask_image(result, bbox, bbox_srs, coverage)
            bg.paste(result, (0, 0), mask)
            result = bg

        return ImageSource(result, size=size, image_opts=image_opts, cacheable=cacheable)

def merge_images(images, image_opts, size=None):
    """
    Merge multiple images into one.

    :param images: list of `ImageSource`, bottom image first
    :param format: the format of the output `ImageSource`
    :param size: size of the merged image, if ``None`` the size
                 of the first image is used
    :rtype: `ImageSource`
    """
    merger = LayerMerger()
    for img in images:
        merger.add(img)
    return merger.merge(image_opts=image_opts, size=size)

def concat_legends(legends, format='png', size=None, bgcolor='#ffffff', transparent=True):
    """
    Merge multiple legends into one
    :param images: list of `ImageSource`, bottom image first
    :param format: the format of the output `ImageSource`
    :param size: size of the merged image, if ``None`` the size
                 will be calculated
    :rtype: `ImageSource`
    """
    if not legends:
        return BlankImageSource(size=(1,1), image_opts=ImageOptions(bgcolor=bgcolor, transparent=transparent))
    if len(legends) == 1:
        return legends[0]

    legends = legends[:]
    legends.reverse()
    if size is None:
        legend_width = 0
        legend_height = 0
        legend_position_y = []
        #iterate through all legends, last to first, calc img size and remember the y-position
        for legend in legends:
            legend_position_y.append(legend_height)
            tmp_img = legend.as_image()
            legend_width = max(legend_width, tmp_img.size[0])
            legend_height += tmp_img.size[1] #images shall not overlap themselfs

        size = [legend_width, legend_height]
    bgcolor = ImageColor.getrgb(bgcolor)

    if transparent:
        img = Image.new('RGBA', size, bgcolor+(0,))
    else:
        img = Image.new('RGB', size, bgcolor)
    for i in range(len(legends)):
        legend_img = legends[i].as_image()
        if legend_img.mode == 'RGBA':
            # paste w transparency mask from layer
            img.paste(legend_img, (0, legend_position_y[i]), legend_img)
        else:
            img.paste(legend_img, (0, legend_position_y[i]))
    return ImageSource(img, image_opts=ImageOptions(format=format))

########NEW FILE########
__FILENAME__ = message
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import division
import os
import pkg_resources

from mapproxy.config import base_config, abspath
from mapproxy.platform.image import Image, ImageColor, ImageDraw, ImageFont
from mapproxy.image import ImageSource
from mapproxy.image.opts import create_image, ImageOptions

_pil_ttf_support = True


import logging
log_system = logging.getLogger('mapproxy.system')

def message_image(message, size, image_opts, bgcolor='#ffffff',
                  transparent=False):
    """
    Creates an image with text (`message`). This can be used
    to create in_image exceptions.

    For dark `bgcolor` the font color is white, otherwise black.

    :param message: the message to put in the image
    :param size: the size of the output image
    :param format: the output format of the image
    :param bgcolor: the background color of the image
    :param transparent: if True and the `format` supports it,
                        return a transparent image
    :rtype: `ImageSource`
    """
    eimg = ExceptionImage(message, image_opts=image_opts)
    return eimg.draw(size=size)

def attribution_image(message, size, image_opts=None, inverse=False):
    """
    Creates an image with text attribution (`message`).

    :param message: the message to put in the image
    :param size: the size of the output image
    :param format: the output format of the image
    :param inverse: if true, write white text
    :param transparent: if True and the `format` supports it,
                        return a transparent image
    :rtype: `ImageSource`
    """
    if image_opts is None:
        image_opts = ImageOptions(transparent=True)
    aimg = AttributionImage(message, image_opts=image_opts,
                            inverse=inverse)
    return aimg.draw(size=size)

class MessageImage(object):
    """
    Base class for text rendering in images (for watermarks, exception images, etc.)

    :ivar font_name: the font name for the text
    :ivar font_size: the font size of the text
    :ivar font_color: the color of the font as a tuple
    :ivar box_color: the color of the box behind the text.
                     color as a tuple or ``None``
    """
    font_name = 'DejaVu Sans Mono'
    font_size = 10
    font_color = ImageColor.getrgb('black')
    box_color = None
    linespacing = 5
    padding = 3
    placement = 'ul'

    def __init__(self, message, image_opts):
        self.message = message
        self.image_opts = image_opts
        self._font = None

    @property
    def font(self):
        global _pil_ttf_support
        if self._font is None:
            if self.font_name != 'default' and _pil_ttf_support:
                try:
                    self._font = ImageFont.truetype(font_file(self.font_name),
                        self.font_size)
                except ImportError:
                    _pil_ttf_support = False
                    log_system.warn("Couldn't load TrueType fonts, "
                        "PIL needs to be build with freetype support.")
                except IOError:
                    _pil_ttf_support = False
                    log_system.warn("Couldn't load find TrueType font ", self.font_name)
            if self._font is None:
                self._font = ImageFont.load_default()
        return self._font

    def new_image(self, size):
        return Image.new('RGBA', size)

    def draw(self, img=None, size=None, in_place=True):
        """
        Create the message image. Either draws on top of `img` or creates a
        new image with the given `size`.
        """
        if not ((img and not size) or (size and not img)):
            raise TypeError, 'need either img or size argument'

        if img is None:
            base_img = self.new_image(size)
        elif not in_place:
            size = img.size
            base_img = self.new_image(size)
        else:
            base_img = img.as_image()
            size = base_img.size

        if not self.message:
            if img is not None:
                return img
            return ImageSource(base_img, size=size, image_opts=self.image_opts)

        draw = ImageDraw.Draw(base_img)
        self.draw_msg(draw, size)
        image_opts = self.image_opts
        if not in_place and img:
            image_opts = image_opts or img.image_opts
            img = img.as_image()
            converted = False
            if len(self.font_color) == 4 and img.mode != 'RGBA':
                # we need RGBA to keep transparency from text
                converted = img.mode
                img = img.convert('RGBA')
            img.paste(base_img, (0, 0), base_img)
            if converted == 'RGB':
                # convert image back
                img = img.convert('RGB')
            base_img = img

        return ImageSource(base_img, size=size, image_opts=image_opts)

    def draw_msg(self, draw, size):
        td = TextDraw(self.message, font=self.font, bg_color=self.box_color,
                      font_color=self.font_color, placement=self.placement,
                      linespacing=self.linespacing, padding=self.padding)
        td.draw(draw, size)


class ExceptionImage(MessageImage):
    """
    Image for exceptions.
    """
    font_name = 'default'
    font_size = 9
    def __init__(self, message, image_opts):
        MessageImage.__init__(self, message, image_opts=image_opts.copy())
        if not self.image_opts.bgcolor:
            self.image_opts.bgcolor = '#ffffff'

    def new_image(self, size):
        return create_image(size, self.image_opts)

    @property
    def font_color(self):
        if self.image_opts.transparent:
            return ImageColor.getrgb('black')
        if _luminance(ImageColor.getrgb(self.image_opts.bgcolor)) < 128:
            return ImageColor.getrgb('white')
        return ImageColor.getrgb('black')


class WatermarkImage(MessageImage):
    """
    Image with large, faded message.
    """
    font_name = 'DejaVu Sans'
    font_size = 24
    font_color = (128, 128, 128)

    def __init__(self, message, image_opts, placement='c', opacity=None, font_color=None, font_size=None):
        MessageImage.__init__(self, message, image_opts=image_opts)
        if opacity is None:
            opacity = 30
        if font_size:
            self.font_size = font_size
        if font_color:
            self.font_color = font_color
        self.font_color = self.font_color + tuple([opacity])
        self.placement = placement

    def draw_msg(self, draw, size):
        td = TextDraw(self.message, self.font, self.font_color)
        if self.placement in ('l', 'b'):
            td.placement = 'cL'
            td.draw(draw, size)
        if self.placement in ('r', 'b'):
            td.placement = 'cR'
            td.draw(draw, size)
        if self.placement == 'c':
            td.placement = 'cc'
            td.draw(draw, size)


class AttributionImage(MessageImage):
    """
    Image with attribution information.
    """
    font_name = 'DejaVu Sans'
    font_size = 10
    placement = 'lr'

    def __init__(self, message, image_opts, inverse=False):
        MessageImage.__init__(self, message, image_opts=image_opts)
        self.inverse = inverse

    @property
    def font_color(self):
        if self.inverse:
            return ImageColor.getrgb('white')
        else:
            return ImageColor.getrgb('black')

    @property
    def box_color(self):
        if self.inverse:
            return (0, 0, 0, 100)
        else:
            return (255, 255, 255, 120)


class TextDraw(object):
    def __init__(self, text, font, font_color=None, bg_color=None,
                 placement='ul', padding=5, linespacing=3):
        if isinstance(text, basestring):
            text = text.split('\n')
        self.text = text
        self.font = font
        self.bg_color = bg_color
        self.font_color = font_color
        self.placement = placement
        self.padding = (padding, padding, padding, padding)
        self.linespacing = linespacing

    def text_boxes(self, draw, size):
        try:
            total_bbox, boxes = self._relative_text_boxes(draw)
        except UnicodeEncodeError:
            self.text = [l.encode('ascii', 'replace') for l in self.text]
            total_bbox, boxes = self._relative_text_boxes(draw)
        return self._place_boxes(total_bbox, boxes, size)

    def draw(self, draw, size):
        total_bbox, boxes = self.text_boxes(draw, size)
        if self.bg_color:
            draw.rectangle(
                (total_bbox[0]-self.padding[0],
                 total_bbox[1]-self.padding[1],
                 total_bbox[2]+self.padding[2],
                 total_bbox[3]+self.padding[3]),
                fill=self.bg_color)

        for text, box in zip(self.text, boxes):
            draw.text((box[0], box[1]), text, font=self.font, fill=self.font_color)

    def _relative_text_boxes(self, draw):
        total_bbox = (1e9, 1e9, -1e9, -1e9)
        boxes = []
        y_offset = 0
        for i, line in enumerate(self.text):
            text_size = draw.textsize(line, font=self.font)
            text_box = (0, y_offset, text_size[0], text_size[1]+y_offset)
            boxes.append(text_box)
            total_bbox = (min(total_bbox[0], text_box[0]),
                          min(total_bbox[1], text_box[1]),
                          max(total_bbox[2], text_box[2]),
                          max(total_bbox[3], text_box[3]),
                         )

            y_offset += text_size[1] + self.linespacing
        return total_bbox, boxes

    def _move_bboxes(self, boxes, offsets):
        result = []
        for box in boxes:
            box = box[0]+offsets[0], box[1]+offsets[1], box[2]+offsets[0], box[3]+offsets[1]
            result.append(tuple(int(x) for x in box))
        return result

    def _place_boxes(self, total_bbox, boxes, size):
        x_offset = y_offset = None
        text_size = (total_bbox[2] - total_bbox[0]), (total_bbox[3] - total_bbox[1])

        if self.placement[0] == 'u':
            y_offset = self.padding[1]
        elif self.placement[0] == 'l':
            y_offset = size[1] - self.padding[3] - text_size[1]
        elif self.placement[0] == 'c':
            y_offset = size[1] // 2 - text_size[1] // 2

        if self.placement[1] == 'l':
            x_offset = self.padding[0]
        if self.placement[1] == 'L':
            x_offset = -text_size[0] // 2
        elif self.placement[1] == 'r':
            x_offset = size[0] - self.padding[1] - text_size[0]
        elif self.placement[1] == 'R':
            x_offset = size[0] - text_size[0] // 2
        elif self.placement[1] == 'c':
            x_offset = size[0] // 2 - text_size[0] // 2

        if x_offset is None or y_offset is None:
            raise ValueError('placement %r not supported' % self.placement)

        offsets = x_offset, y_offset
        return self._move_bboxes([total_bbox], offsets)[0], self._move_bboxes(boxes, offsets)

def font_file(font_name):
    font_dir = base_config().image.font_dir
    font_name = font_name.replace(' ', '')
    if font_dir:
        abspath(font_dir)
        path = os.path.join(font_dir, font_name + '.ttf')
    else:
        path = pkg_resources.resource_filename(__name__, 'fonts/' + font_name + '.ttf')
    return path


def _luminance(color):
    """
    Returns the luminance of a RGB tuple. Uses ITU-R 601-2 luma transform.
    """
    r, g, b = color
    return r * 299/1000 + g * 587/1000 + b * 114/1000

########NEW FILE########
__FILENAME__ = opts
# -:- encoding: utf-8 -:-
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import copy

class ImageOptions(object):
    def __init__(self, mode=None, transparent=None, opacity=None, resampling=None,
        format=None, bgcolor=None, colors=None, encoding_options=None):
        self.transparent = transparent
        self.opacity = opacity
        self.resampling = resampling
        if format is not None:
            format = ImageFormat(format)
        self.format = format
        self.mode = mode
        self.bgcolor = bgcolor
        self.colors = colors
        self.encoding_options = encoding_options or {}

    def __repr__(self):
        options = []
        for k in dir(self):
            if k.startswith('_'):
                continue
            v = getattr(self, k)
            if v is not None and not hasattr(v, 'im_func'):
                options.append('%s=%r' % (k, v))
        return 'ImageOptions(%s)' % (', '.join(options), )

    def copy(self):
        return copy.copy(self)

class ImageFormat(str):
    def __new__(cls, value, *args, **keywargs):
        if isinstance(value, ImageFormat):
            return value
        return str.__new__(cls, value)

    @property
    def mime_type(self):
        if self.startswith('image/'):
            return self
        return 'image/' + self

    @property
    def ext(self):
        ext = self
        if '/' in ext:
            ext = ext.split('/', 1)[1]
        if ';' in ext:
            ext = ext.split(';', 1)[0]

        return ext.strip()

    def __eq__(self, other):
        if isinstance(other, basestring):
            other = ImageFormat(other)
        elif not isinstance(other, ImageFormat):
            return NotImplemented

        return self.ext == other.ext

    def __ne__(self, other):
        return not (self == other)

def create_image(size, image_opts=None):
    """
    Create a new image that is compatible with the given `image_opts`.
    Takes into account mode, transparent, bgcolor.
    """
    from mapproxy.platform.image import Image, ImageColor

    if image_opts is None:
        mode = 'RGB'
        bgcolor = (255, 255, 255)
    else:
        mode = image_opts.mode
        if mode in (None, 'P'):
            if image_opts.transparent:
                mode = 'RGBA'
            else:
                mode = 'RGB'

        bgcolor = image_opts.bgcolor or (255, 255, 255)

        if isinstance(bgcolor, basestring):
            bgcolor = ImageColor.getrgb(bgcolor)

        if image_opts.transparent and len(bgcolor) == 3:
            bgcolor = bgcolor + (0, )

        if image_opts.mode == 'I':
            bgcolor = bgcolor[0]

    return Image.new(mode, size, bgcolor)


class ImageFormats(object):
    def __init__(self):
        self.format_options = {}

    def add(self, opts):
        assert opts.format is not None
        self.format_options[opts.format] = opts

    def options(self, format):
        opts = self.format_options.get(format)
        if not opts:
            opts = ImageOptions(transparent=False, format=format)
        return opts

def compatible_image_options(img_opts, base_opts=None):
    """
    Return ImageOptions that is compatible with all given `img_opts`.

    """
    if any(True for o in img_opts if o.colors == 0):
        colors = 0
    else:
        colors = max(o.colors for o in img_opts)

    transparent = None
    for o in img_opts:
        if o.transparent == False:
            transparent = False
            break
        if o.transparent == True:
            transparent = True

    # I < P < RGB < RGBA :)
    mode = max(o.mode for o in img_opts)

    if base_opts:
        options = base_opts.copy()
        if options.colors is None:
            options.colors = colors
        if options.mode is None:
            options.mode = mode
        if options.transparent is None:
            options.transparent = transparent
    else:
        options = img_opts[0].copy()
        options.colors = colors
        options.transparent = transparent
        options.mode = mode

    return options
########NEW FILE########
__FILENAME__ = tile
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
from mapproxy.image import ImageSource
from mapproxy.image.transform import ImageTransformer
from mapproxy.image.opts import create_image

import logging
log = logging.getLogger(__name__)

class TileMerger(object):
    """
    Merge multiple tiles into one image.
    """
    def __init__(self, tile_grid, tile_size):
        """
        :param tile_grid: the grid size
        :type tile_grid: ``(int(x_tiles), int(y_tiles))``
        :param tile_size: the size of each tile
        """
        self.tile_grid = tile_grid
        self.tile_size = tile_size
    
    def merge(self, ordered_tiles, image_opts):
        """
        Merge all tiles into one image.
        
        :param ordered_tiles: list of tiles, sorted row-wise (top to bottom)
        :rtype: `ImageSource`
        """
        if self.tile_grid == (1, 1):
            assert len(ordered_tiles) == 1
            if ordered_tiles[0] is not None:
                tile = ordered_tiles.pop()
                return tile
        src_size = self._src_size()
        
        result = create_image(src_size, image_opts)

        cacheable = True

        for i, source in enumerate(ordered_tiles):
            if source is None:
                continue
            try:
                if not source.cacheable:
                    cacheable = False
                tile = source.as_image()
                pos = self._tile_offset(i)
                tile.draft(image_opts.mode, self.tile_size)
                result.paste(tile, pos)
                source.close_buffers()
            except IOError, e:
                if e.errno is None: # PIL error
                    log.warn('unable to load tile %s, removing it (reason was: %s)'
                             % (source, str(e)))
                    if getattr(source, 'filename'):
                        if os.path.exists(source.filename):
                            os.remove(source.filename)
                else:
                    raise
        return ImageSource(result, size=src_size, image_opts=image_opts, cacheable=cacheable)
    
    def _src_size(self):
        width = self.tile_grid[0]*self.tile_size[0]
        height = self.tile_grid[1]*self.tile_size[1]
        return width, height
    
    def _tile_offset(self, i):
        """
        Return the image offset (upper-left coord) of the i-th tile,
        where the tiles are ordered row-wise, top to bottom.
        """
        return (i%self.tile_grid[0]*self.tile_size[0],
                i//self.tile_grid[0]*self.tile_size[1])
    

class TileSplitter(object):
    """
    Splits a large image into multiple tiles.
    """
    def __init__(self, meta_tile, image_opts):
        self.meta_img = meta_tile.as_image()
        self.image_opts = image_opts

    def get_tile(self, crop_coord, tile_size):
        """
        Return the cropped tile.
        :param crop_coord: the upper left pixel coord to start
        :param tile_size: width and height of the new tile
        :rtype: `ImageSource`
        """
        minx, miny = crop_coord
        maxx = minx + tile_size[0]
        maxy = miny + tile_size[1]
        
        if (minx < 0 or miny < 0 or maxx > self.meta_img.size[0]
            or maxy > self.meta_img.size[1]):

            crop = self.meta_img.crop((
                max(minx, 0),
                max(miny, 0),
                min(maxx, self.meta_img.size[0]),
                min(maxy, self.meta_img.size[1])))
            result = create_image(tile_size, self.image_opts)
            result.paste(crop, (abs(min(minx, 0)), abs(min(miny, 0))))
            crop = result
        else:
            crop = self.meta_img.crop((minx, miny, maxx, maxy))
        return ImageSource(crop, size=tile_size, image_opts=self.image_opts)
    

class TiledImage(object):
    """
    An image built-up from multiple tiles.
    """
    def __init__(self, tiles, tile_grid, tile_size, src_bbox, src_srs):
        """
        :param tiles: all tiles (sorted row-wise, top to bottom)
        :param tile_grid: the tile grid size
        :type tile_grid: ``(int(x_tiles), int(y_tiles))``
        :param tile_size: the size of each tile
        :param src_bbox: the bbox of all tiles
        :param src_srs: the srs of the bbox
        :param transparent: if the sources are transparent
        """
        self.tiles = tiles
        self.tile_grid = tile_grid
        self.tile_size = tile_size
        self.src_bbox = src_bbox
        self.src_srs = src_srs
    
    def image(self, image_opts):
        """
        Return the tiles as one merged image.
        
        :rtype: `ImageSource`
        """
        tm = TileMerger(self.tile_grid, self.tile_size)
        return tm.merge(self.tiles, image_opts=image_opts)
    
    def transform(self, req_bbox, req_srs, out_size, image_opts):
        """
        Return the the tiles as one merged and transformed image.
        
        :param req_bbox: the bbox of the output image
        :param req_srs: the srs of the req_bbox
        :param out_size: the size in pixel of the output image
        :rtype: `ImageSource`
        """
        transformer = ImageTransformer(self.src_srs, req_srs)
        src_img = self.image(image_opts)
        return transformer.transform(src_img, self.src_bbox, out_size, req_bbox,
            image_opts)

########NEW FILE########
__FILENAME__ = transform
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import division

from mapproxy.platform.image import Image
from mapproxy.image import ImageSource, image_filter
from mapproxy.srs import make_lin_transf, bbox_equals

class ImageTransformer(object):
    """
    Transform images between different bbox and spatial reference systems.

    :note: The transformation doesn't make a real transformation for each pixel,
           but a mesh transformation (see `PIL Image.transform`_).
           It will divide the target image into rectangles (a mesh). The
           source coordinates for each rectangle vertex will be calculated.
           The quadrilateral will then be transformed with the source coordinates
           into the destination quad (affine).

           This method will perform good transformation results if the number of
           quads is high enough (even transformations with strong distortions).
           Tests on images up to 1500x1500 have shown that meshes beyond 8x8
           will not improve the results.

           .. _PIL Image.transform:
              http://www.pythonware.com/library/pil/handbook/image.htm#Image.transform

           ::

                    src quad                   dst quad
                    .----.   <- coord-           .----.
                   /    /       transformation   |    |
                  /    /                         |    |
                 .----.   img-transformation ->  .----.----
                           |                     |    |
            ---------------.
            large src image                   large dst image
    """
    def __init__(self, src_srs, dst_srs, mesh_div=8):
        """
        :param src_srs: the srs of the source image
        :param dst_srs: the srs of the target image
        :param resampling: the resampling method used for transformation
        :type resampling: nearest|bilinear|bicubic
        :param mesh_div: the number of quads in each direction to use
                         for transformation (totals to ``mesh_div**2`` quads)

        """
        self.src_srs = src_srs
        self.dst_srs = dst_srs
        self.mesh_div = mesh_div
        self.dst_bbox = self.dst_size = None

    def transform(self, src_img, src_bbox, dst_size, dst_bbox, image_opts):
        """
        Transforms the `src_img` between the source and destination SRS
        of this ``ImageTransformer`` instance.

        When the ``src_srs`` and ``dst_srs`` are equal the image will be cropped
        and not transformed. If the `src_bbox` and `dst_bbox` are equal,
        the `src_img` itself will be returned.

        :param src_img: the source image for the transformation
        :param src_bbox: the bbox of the src_img
        :param dst_size: the size of the result image (in pizel)
        :type dst_size: ``(int(width), int(height))``
        :param dst_bbox: the bbox of the result image
        :return: the transformed image
        :rtype: `ImageSource`
        """
        if self._no_transformation_needed(src_img.size, src_bbox, dst_size, dst_bbox):
            return src_img

        if self.src_srs == self.dst_srs:
            result = self._transform_simple(src_img, src_bbox, dst_size, dst_bbox,
                image_opts)
        else:
            result = self._transform(src_img, src_bbox, dst_size, dst_bbox, image_opts)

        result.cacheable = src_img.cacheable
        return result

    def _transform_simple(self, src_img, src_bbox, dst_size, dst_bbox, image_opts):
        """
        Do a simple crop/extent transformation.
        """
        src_quad = (0, 0, src_img.size[0], src_img.size[1])
        to_src_px = make_lin_transf(src_bbox, src_quad)
        minx, miny = to_src_px((dst_bbox[0], dst_bbox[3]))
        maxx, maxy = to_src_px((dst_bbox[2], dst_bbox[1]))

        src_res = ((src_bbox[0]-src_bbox[2])/src_img.size[0],
                   (src_bbox[1]-src_bbox[3])/src_img.size[1])
        dst_res = ((dst_bbox[0]-dst_bbox[2])/dst_size[0],
                   (dst_bbox[1]-dst_bbox[3])/dst_size[1])

        tenth_px_res = (abs(dst_res[0]/(dst_size[0]*10)),
                        abs(dst_res[1]/(dst_size[1]*10)))
        if (abs(src_res[0]-dst_res[0]) < tenth_px_res[0] and
            abs(src_res[1]-dst_res[1]) < tenth_px_res[1]):
            # rounding might result in subpixel inaccuracy
            # this exact resolutioni match should only happen in clients with
            # fixed resolutions like OpenLayers
            minx = int(round(minx))
            miny = int(round(miny))
            result = src_img.as_image().crop((minx, miny,
                                              minx+dst_size[0], miny+dst_size[1]))
        else:
            result = src_img.as_image().transform(dst_size, Image.EXTENT,
                                                  (minx, miny, maxx, maxy),
                                                  image_filter[image_opts.resampling])
        return ImageSource(result, size=dst_size, image_opts=image_opts)

    def _transform(self, src_img, src_bbox, dst_size, dst_bbox, image_opts):
        """
        Do a 'real' transformation with a transformed mesh (see above).
        """
        src_bbox = self.src_srs.align_bbox(src_bbox)
        dst_bbox = self.dst_srs.align_bbox(dst_bbox)
        src_size = src_img.size
        src_quad = (0, 0, src_size[0], src_size[1])
        dst_quad = (0, 0, dst_size[0], dst_size[1])
        to_src_px = make_lin_transf(src_bbox, src_quad)
        to_dst_w = make_lin_transf(dst_quad, dst_bbox)
        meshes = []
        def dst_quad_to_src(quad):
            src_quad = []
            for dst_px in [(quad[0], quad[1]), (quad[0], quad[3]),
                           (quad[2], quad[3]), (quad[2], quad[1])]:
                dst_w = to_dst_w((dst_px[0]+0.5, dst_px[1]+0.5))
                src_w = self.dst_srs.transform_to(self.src_srs, dst_w)
                src_px = to_src_px(src_w)
                src_quad.extend(src_px)
            return quad, src_quad

        mesh_div = self.mesh_div
        while mesh_div > 1 and (dst_size[0] / mesh_div < 10 or dst_size[1] / mesh_div < 10):
            mesh_div -= 1
        for quad in griddify(dst_quad, mesh_div):
            meshes.append(dst_quad_to_src(quad))

        result = src_img.as_image().transform(dst_size, Image.MESH, meshes,
                                              image_filter[image_opts.resampling])
        return ImageSource(result, size=dst_size, image_opts=image_opts)

    def _no_transformation_needed(self, src_size, src_bbox, dst_size, dst_bbox):
        """
        >>> src_bbox = (-2504688.5428486541, 1252344.271424327,
        ...             -1252344.271424327, 2504688.5428486541)
        >>> dst_bbox = (-2504688.5431999983, 1252344.2704,
        ...             -1252344.2719999983, 2504688.5416000001)
        >>> from mapproxy.srs import SRS
        >>> t = ImageTransformer(SRS(900913), SRS(900913))
        >>> t._no_transformation_needed((256, 256), src_bbox, (256, 256), dst_bbox)
        True
        """
        xres = (dst_bbox[2]-dst_bbox[0])/dst_size[0]
        yres = (dst_bbox[3]-dst_bbox[1])/dst_size[1]
        return (src_size == dst_size and
                self.src_srs == self.dst_srs and
                bbox_equals(src_bbox, dst_bbox, xres/10, yres/10))


def griddify(quad, steps):
    """
    Divides a box (`quad`) into multiple boxes (``steps x steps``).

    >>> list(griddify((0, 0, 500, 500), 2))
    [(0, 0, 250, 250), (250, 0, 500, 250), (0, 250, 250, 500), (250, 250, 500, 500)]
    """
    w = quad[2]-quad[0]
    h = quad[3]-quad[1]
    x_step = w / float(steps)
    y_step = h / float(steps)

    y = quad[1]
    for _ in range(steps):
        x = quad[0]
        for _ in range(steps):
            yield (int(x), int(y), int(x+x_step), int(y+y_step))
            x += x_step
        y += y_step

########NEW FILE########
__FILENAME__ = layer
# -:- encoding: utf-8 -:-
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Layers that can get maps/infos from different sources/caches.
"""

from __future__ import division, with_statement
from mapproxy.grid import NoTiles, GridError, merge_resolution_range, bbox_intersects, bbox_contains
from mapproxy.image import SubImageSource, bbox_position_in_image
from mapproxy.image.opts import ImageOptions
from mapproxy.image.tile import TiledImage
from mapproxy.srs import SRS, bbox_equals, merge_bbox, make_lin_transf
from mapproxy.platform.proj import ProjError

import logging
log = logging.getLogger(__name__)

class BlankImage(Exception):
    pass

class MapError(Exception):
    pass

class MapBBOXError(Exception):
    pass

class MapLayer(object):
    supports_meta_tiles = False

    res_range = None

    coverage = None

    def __init__(self, image_opts=None):
        self.image_opts = image_opts or ImageOptions()

    def _get_transparent(self):
        return self.image_opts.transparent

    def _set_transparent(self, value):
        self.image_opts.transparent = value

    transparent = property(_get_transparent, _set_transparent)

    def _get_opacity(self):
        return self.image_opts.opacity

    def _set_opacity(self, value):
        self.image_opts.opacity = value

    opacity = property(_get_opacity, _set_opacity)

    def is_opaque(self):
        if self.opacity is None:
            return not self.transparent
        return self.opacity >= 0.99

    def check_res_range(self, query):
        if (self.res_range and
          not self.res_range.contains(query.bbox, query.size, query.srs)):
            raise BlankImage()

    def get_map(self, query):
        raise NotImplementedError

    def combined_layer(self, other, query):
        return None

class LimitedLayer(object):
    """
    Wraps an existing layer temporary and stores additional
    attributes for geographical limits.
    """
    def __init__(self, layer, coverage):
        self._layer = layer
        self.coverage = coverage

    def __getattr__(self, name):
        return getattr(self._layer, name)

    def combined_layer(self, other, query):
        if self.coverage == other.coverage:
            combined = self._layer.combined_layer(other, query)
            if combined:
                return LimitedLayer(combined, self.coverage)
        return None

    def get_info(self, query):
        if self.coverage:
            if not self.coverage.contains(query.coord, query.srs):
                return None
        return self._layer.get_info(query)

class InfoLayer(object):
    def get_info(self, query):
        raise NotImplementedError

class MapQuery(object):
    """
    Internal query for a map with a specific extent, size, srs, etc.
    """
    def __init__(self, bbox, size, srs, format='image/png', transparent=False,
                 tiled_only=False, dimensions=None):
        self.bbox = bbox
        self.size = size
        self.srs = srs
        self.format = format
        self.transparent = transparent
        self.tiled_only = tiled_only
        self.dimensions = dimensions or {}

    def dimensions_for_params(self, params):
        """
        Return subset of the dimensions.

        >>> mq = MapQuery(None, None, None, dimensions={'Foo': 1, 'bar': 2})
        >>> mq.dimensions_for_params(set(['FOO', 'baz']))
        {'Foo': 1}
        """
        params = [p.lower() for p in params]
        return dict((k, v) for k, v in self.dimensions.iteritems() if k.lower() in params)

    def __repr__(self):
        return "MapQuery(bbox=%(bbox)s, size=%(size)s, srs=%(srs)r, format=%(format)s)" % self.__dict__

class InfoQuery(object):
    def __init__(self, bbox, size, srs, pos, info_format, format=None,
        feature_count=None):
        self.bbox = bbox
        self.size = size
        self.srs = srs
        self.pos = pos
        self.info_format = info_format
        self.format = format
        self.feature_count = feature_count

    @property
    def coord(self):
        return make_lin_transf((0, self.size[1], self.size[0], 0), self.bbox)(self.pos)

class LegendQuery(object):
    def __init__(self, format, scale):
        self.format = format
        self.scale = scale

class Dimension(list):
    def __init__(self, identifier, values, default=None):
        self.identifier = identifier
        if not default and values:
            default = values[0]
        self.default = default
        list.__init__(self, values)


def map_extent_from_grid(grid):
    """
    >>> from mapproxy.grid import tile_grid_for_epsg
    >>> map_extent_from_grid(tile_grid_for_epsg('EPSG:900913'))
    ... #doctest: +NORMALIZE_WHITESPACE
    MapExtent((-20037508.342789244, -20037508.342789244,
               20037508.342789244, 20037508.342789244), SRS('EPSG:900913'))
    """
    return MapExtent(grid.bbox, grid.srs)

class MapExtent(object):
    """
    >>> me = MapExtent((5, 45, 15, 55), SRS(4326))
    >>> me.llbbox
    (5, 45, 15, 55)
    >>> map(int, me.bbox_for(SRS(900913)))
    [556597, 5621521, 1669792, 7361866]
    >>> map(int, me.bbox_for(SRS(4326)))
    [5, 45, 15, 55]
    """
    is_default = False
    def __init__(self, bbox, srs):
        self._llbbox = None
        self.bbox = bbox
        self.srs = srs

    @property
    def llbbox(self):
        if not self._llbbox:
            self._llbbox = self.srs.transform_bbox_to(SRS(4326), self.bbox)
        return self._llbbox

    def bbox_for(self, srs):
        if srs == self.srs:
            return self.bbox

        return self.srs.transform_bbox_to(srs, self.bbox)

    def __repr__(self):
        return "%s(%r, %r)" % (self.__class__.__name__, self.bbox, self.srs)

    def __eq__(self, other):
        if not isinstance(other, MapExtent):
            return NotImplemented

        if self.srs != other.srs:
            return False

        if self.bbox != other.bbox:
            return False

        return True

    def __ne__(self, other):
        if not isinstance(other, MapExtent):
            return NotImplemented
        return not self.__eq__(other)

    def __add__(self, other):
        if not isinstance(other, MapExtent):
            raise NotImplemented
        if other.is_default:
            return self
        if self.is_default:
            return other
        return MapExtent(merge_bbox(self.llbbox, other.llbbox), SRS(4326))

    def contains(self, other):
        if not isinstance(other, MapExtent):
            raise NotImplemented
        if self.is_default:
            # DefaultMapExtent contains everything
            return True
        return bbox_contains(self.bbox, other.bbox_for(self.srs))

    def intersects(self, other):
        if not isinstance(other, MapExtent):
            raise NotImplemented
        return bbox_intersects(self.bbox, other.bbox_for(self.srs))

    def intersection(self, other):
        """
        Returns the intersection of `self` and `other`.

        >>> e = DefaultMapExtent().intersection(MapExtent((0, 0, 10, 10), SRS(4326)))
        >>> e.bbox, e.srs
        ((0, 0, 10, 10), SRS('EPSG:4326'))
        """
        if not self.intersects(other):
            return None

        source = self.bbox
        sub = other.bbox_for(self.srs)

        return MapExtent((
            max(source[0], sub[0]),
            max(source[1], sub[1]),
            min(source[2], sub[2]),
            min(source[3], sub[3])),
            self.srs)

class DefaultMapExtent(MapExtent):
    """
    Default extent that covers the whole world.
    Will not affect other extents when added.

    >>> m1 = MapExtent((0, 0, 10, 10), SRS(4326))
    >>> m2 = MapExtent((10, 0, 20, 10), SRS(4326))
    >>> m3 = DefaultMapExtent()
    >>> (m1 + m2).bbox
    (0, 0, 20, 10)
    >>> (m1 + m3).bbox
    (0, 0, 10, 10)
    """
    is_default = True
    def __init__(self):
        MapExtent.__init__(self, (-180, -90, 180, 90), SRS(4326))

def merge_layer_extents(layers):
    if not layers:
        return DefaultMapExtent()
    layers = layers[:]
    extent = layers.pop().extent
    for layer in layers:
        extent = extent + layer.extent
    return extent

class ResolutionConditional(MapLayer):
    supports_meta_tiles = True
    def __init__(self, one, two, resolution, srs, extent, opacity=None):
        MapLayer.__init__(self)
        self.one = one
        self.two = two
        self.res_range = merge_layer_res_ranges([one, two])
        self.resolution = resolution
        self.srs = srs

        #TODO
        self.transparent = self.one.transparent
        self.opacity = opacity
        self.extent = extent

    def get_map(self, query):
        self.check_res_range(query)
        bbox = query.bbox
        if query.srs != self.srs:
            bbox = query.srs.transform_bbox_to(self.srs, bbox)

        xres = (bbox[2] - bbox[0]) / query.size[0]
        yres = (bbox[3] - bbox[1]) / query.size[1]
        res = min(xres, yres)
        log.debug('actual res: %s, threshold res: %s', res, self.resolution)

        if res > self.resolution:
            return self.one.get_map(query)
        else:
            return self.two.get_map(query)

class SRSConditional(MapLayer):
    supports_meta_tiles = True
    PROJECTED = 'PROJECTED'
    GEOGRAPHIC = 'GEOGRAPHIC'

    def __init__(self, layers, extent, transparent=False, opacity=None):
        MapLayer.__init__(self)
        self.transparent = transparent
        # TODO geographic/projected fallback
        self.srs_map = {}
        self.res_range = merge_layer_res_ranges([l[0] for l in layers])
        for layer, srss in layers:
            for srs in srss:
                self.srs_map[srs] = layer

        self.extent = extent
        self.opacity = opacity

    def get_map(self, query):
        self.check_res_range(query)
        layer = self._select_layer(query.srs)
        return layer.get_map(query)

    def _select_layer(self, query_srs):
        # srs exists
        if query_srs in self.srs_map:
            return self.srs_map[query_srs]

        # srs_type exists
        srs_type = self.GEOGRAPHIC if query_srs.is_latlong else self.PROJECTED
        if srs_type in self.srs_map:
            return self.srs_map[srs_type]

        # first with same type
        is_latlong = query_srs.is_latlong
        for srs in self.srs_map:
            if hasattr(srs, 'is_latlong') and srs.is_latlong == is_latlong:
                return self.srs_map[srs]

        # return first
        return self.srs_map.itervalues().next()


class DirectMapLayer(MapLayer):
    supports_meta_tiles = True

    def __init__(self, source, extent):
        MapLayer.__init__(self)
        self.source = source
        self.res_range = getattr(source, 'res_range', None)
        self.extent = extent

    def get_map(self, query):
        self.check_res_range(query)
        return self.source.get_map(query)


def merge_layer_res_ranges(layers):
    ranges = [s.res_range for s in layers
              if hasattr(s, 'res_range')]

    if ranges:
        ranges = reduce(merge_resolution_range, ranges)

    return ranges


class CacheMapLayer(MapLayer):
    supports_meta_tiles = True

    def __init__(self, tile_manager, extent=None, image_opts=None,
        max_tile_limit=None):
        MapLayer.__init__(self, image_opts=image_opts)
        self.tile_manager = tile_manager
        self.grid = tile_manager.grid
        self.extent = extent or map_extent_from_grid(self.grid)
        self.res_range = merge_layer_res_ranges(self.tile_manager.sources)
        self.transparent = tile_manager.transparent
        self.max_tile_limit = max_tile_limit

    def get_map(self, query):
        self.check_res_range(query)

        if query.tiled_only:
            self._check_tiled(query)

        query_extent = MapExtent(query.bbox, query.srs)
        if not query.tiled_only and self.extent and not self.extent.contains(query_extent):
            if not self.extent.intersects(query_extent):
                raise BlankImage()
            size, offset, bbox = bbox_position_in_image(query.bbox, query.size, self.extent.bbox_for(query.srs))
            if size[0] == 0 or size[1] == 0:
                raise BlankImage()
            src_query = MapQuery(bbox, size, query.srs, query.format)
            resp = self._image(src_query)
            result = SubImageSource(resp, size=query.size, offset=offset, image_opts=self.image_opts,
                cacheable=resp.cacheable)
        else:
            result = self._image(query)
        return result

    def _check_tiled(self, query):
        if query.format != self.tile_manager.format:
            raise MapError("invalid tile format, use %s" % self.tile_manager.format)
        if query.size != self.grid.tile_size:
            raise MapError("invalid tile size (use %dx%d)" % self.grid.tile_size)

    def _image(self, query):
        try:
            src_bbox, tile_grid, affected_tile_coords = \
                self.grid.get_affected_tiles(query.bbox, query.size,
                                             req_srs=query.srs)
        except NoTiles:
            raise BlankImage()
        except GridError, ex:
            raise MapBBOXError(ex.args[0])

        num_tiles = tile_grid[0] * tile_grid[1]

        if self.max_tile_limit and num_tiles >= self.max_tile_limit:
            raise MapBBOXError("too many tiles")

        if query.tiled_only:
            if num_tiles > 1:
                raise MapBBOXError("not a single tile")
            bbox = query.bbox
            if not bbox_equals(bbox, src_bbox, abs((bbox[2]-bbox[0])/query.size[0]/10),
                                               abs((bbox[3]-bbox[1])/query.size[1]/10)):
                raise MapBBOXError("query does not align to tile boundaries")

        with self.tile_manager.session():
            tile_collection = self.tile_manager.load_tile_coords(affected_tile_coords, with_metadata=query.tiled_only)

        if tile_collection.empty:
            raise BlankImage()

        if query.tiled_only:
            tile = tile_collection[0].source
            tile.image_opts = self.tile_manager.image_opts
            tile.cacheable = tile_collection[0].cacheable
            return tile

        tile_sources = [tile.source for tile in tile_collection]
        tiled_image = TiledImage(tile_sources, src_bbox=src_bbox, src_srs=self.grid.srs,
                          tile_grid=tile_grid, tile_size=self.grid.tile_size)
        try:
            return tiled_image.transform(query.bbox, query.srs, query.size,
                self.tile_manager.image_opts)
        except ProjError:
            raise MapBBOXError("could not transform query BBOX")
        except IOError, ex:
            from mapproxy.source import SourceError
            raise SourceError("unable to transform image: %s" % ex)



########NEW FILE########
__FILENAME__ = multiapp
# -:- encoding: utf-8 -:-
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os

from mapproxy.request import Request
from mapproxy.response import Response
from mapproxy.util.collections import LRU
from mapproxy.wsgiapp import make_wsgi_app as make_mapproxy_wsgi_app
from threading import Lock

import logging
log = logging.getLogger(__name__)

def asbool(value):
    """
    >>> all([asbool(True), asbool('trUE'), asbool('ON'), asbool(1)])
    True
    >>> any([asbool(False), asbool('false'), asbool('foo'), asbool(None)])
    False
    """
    value = str(value).lower()
    return value in ('1', 'true', 'yes', 'on')

def app_factory(global_options, config_dir, allow_listing=False, **local_options):
    """
    Create a new MultiMapProxy app.

    :param config_dir: directory with all mapproxy configurations
    :param allow_listing: allow to list all available apps
    """
    return make_wsgi_app(config_dir, asbool(allow_listing))

def make_wsgi_app(config_dir, allow_listing=True, debug=False):
    """
    Create a MultiMapProxy with the given config directory.

    :param config_dir: the directory with all project configurations.
    :param allow_listing: True if MapProxy should list all instances
        at the root URL
    """
    config_dir = os.path.abspath(config_dir)
    loader = DirectoryConfLoader(config_dir)
    return MultiMapProxy(loader, list_apps=allow_listing, debug=debug)


class MultiMapProxy(object):

    def __init__(self, loader, list_apps=False, app_cache_size=100, debug=False):
        self.loader = loader
        self.list_apps = list_apps
        self._app_init_lock = Lock()
        self.apps = LRU(app_cache_size)
        self.debug = debug

    def __call__(self, environ, start_response):
        req = Request(environ)
        return self.handle(req)(environ, start_response)

    def handle(self, req):
        app_name = req.pop_path()
        if not app_name:
            return self.index_list(req)

        if not app_name or (
                app_name not in self.apps and not self.loader.app_available(app_name)
            ):
            return Response('not found', status=404)

        # safe instance/app name for authorization
        req.environ['mapproxy.instance_name'] = app_name
        return self.proj_app(app_name)

    def index_list(self, req):
        """
        Return greeting response with a list of available apps (if enabled with list_apps).
        """
        import mapproxy.version
        html = "<html><body><h1>Welcome to MapProxy %s</h1>" % mapproxy.version.version

        url = req.script_url
        if self.list_apps:
            html += "<h2>available instances:</h2><ul>"
            html += '\n'.join('<li><a href="%(url)s/%(name)s/">%(name)s</a></li>' % {'url': url, 'name': app}
                              for app in self.loader.available_apps())
            html += '</ul>'
        html += '</body></html>'
        return Response(html, content_type='text/html')

    def proj_app(self, proj_name):
        """
        Return the (cached) project app.
        """
        proj_app, timestamps = self.apps.get(proj_name, (None, None))

        if proj_app:
            if self.loader.needs_reload(proj_name, timestamps):
                # discard cached app
                proj_app = None

        if not proj_app:
            with self._app_init_lock:
                proj_app, timestamps = self.apps.get(proj_name, (None, None))
                if self.loader.needs_reload(proj_name, timestamps):
                    proj_app, timestamps = self.create_app(proj_name)
                    self.apps[proj_name] = proj_app, timestamps
                else:
                    proj_app, timestamps = self.apps[proj_name]

        return proj_app

    def create_app(self, proj_name):
        """
        Returns a new configured MapProxy app and a dict with the
        timestamps of all configuration files.
        """
        mapproxy_conf = self.loader.app_conf(proj_name)['mapproxy_conf']
        log.info('initializing project app %s with %s', proj_name, mapproxy_conf)
        app = make_mapproxy_wsgi_app(mapproxy_conf, debug=self.debug)
        return app, app.config_files


class ConfLoader(object):
    def needs_reload(self, app_name, timestamps):
        """
        Returns ``True`` if the configuration of `app_name` changed
        since `timestamp`.
        """
        raise NotImplementedError()

    def app_available(self, app_name):
        """
        Returns ``True`` if `app_name` is available.
        """
        raise NotImplementedError()

    def available_apps(self):
        """
        Returns a list with all available lists.
        """
        raise NotImplementedError()

    def app_conf(self, app_name):
        """
        Returns a configuration dict for the given `app_name`,
        None if the app is not found.

        The configuration dict contains at least 'mapproxy_conf'
        with the filename of the configuration.
        """
        raise NotImplementedError()


class DirectoryConfLoader(ConfLoader):
    """
    Load application configurations from a directory.
    """
    def __init__(self, base_dir, suffix='.yaml'):
        self.base_dir = base_dir
        self.suffix = suffix

    def needs_reload(self, app_name, timestamps):
        if not timestamps:
            return True
        for conf_file, timestamp in timestamps.iteritems():
            m_time = os.path.getmtime(conf_file)
            if m_time > timestamp:
                return True
        return False

    def _is_conf_file(self, fname):
        if not os.path.isfile(fname):
            return False
        if self.suffix:
            return fname.lower().endswith(self.suffix)
        else:
            return True

    def app_name_from_filename(self, fname):
        """
        >>> DirectoryConfLoader('/tmp/').app_name_from_filename('/tmp/foobar.yaml')
        'foobar'
        """
        _path, fname = os.path.split(fname)
        app_name, _ext = os.path.splitext(fname)
        return app_name

    def filename_from_app_name(self, app_name):
        """
        >>> DirectoryConfLoader('/tmp/').filename_from_app_name('foobar')
        '/tmp/foobar.yaml'
        """
        return os.path.join(self.base_dir, app_name + self.suffix or '')

    def available_apps(self):
        apps = []
        for f in os.listdir(self.base_dir):
            if self._is_conf_file(os.path.join(self.base_dir, f)):
                app_name = self.app_name_from_filename(f)
                apps.append(app_name)
        apps.sort()
        return apps

    def app_available(self, app_name):
        conf_file = self.filename_from_app_name(app_name)
        return self._is_conf_file(conf_file)

    def app_conf(self, app_name):
        conf_file = self.filename_from_app_name(app_name)
        if not self._is_conf_file(conf_file):
            return None
        return {'mapproxy_conf': conf_file}

########NEW FILE########
__FILENAME__ = lock
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Utility methods and classes (file locking, asynchronous execution pools, etc.).
"""
from __future__ import with_statement
import time
import os
import errno

from mapproxy.util.ext.lockfile import LockFile, LockError

import logging
log = logging.getLogger(__name__)

class LockTimeout(Exception):
    pass


class FileLock(object):
    def __init__(self, lock_file, timeout=60.0, step=0.01, remove_on_unlock=False):
        self.lock_file = lock_file
        self.timeout = timeout
        self.step = step
        self.remove_on_unlock = remove_on_unlock
        self._locked = False

    def __enter__(self):
        self.lock()

    def __exit__(self, _exc_type, _exc_value, _traceback):
        self.unlock()

    def _make_lockdir(self):
        if not os.path.exists(os.path.dirname(self.lock_file)):
            try:
                os.makedirs(os.path.dirname(self.lock_file))
            except OSError, e:
                if e.errno is not errno.EEXIST:
                    raise e

    def _try_lock(self):
        return LockFile(self.lock_file)

    def lock(self):
        self._make_lockdir()
        current_time = time.time()
        stop_time = current_time + self.timeout

        while not self._locked:
            try:
                self._lock = self._try_lock()
            except LockError:
                current_time = time.time()
                if current_time < stop_time:
                    time.sleep(self.step)
                    continue
                else:
                    raise LockTimeout('another process is still running with our lock')
            else:
                self._locked = True

    def unlock(self):
        if self._locked:
            self._locked = False
            if self.remove_on_unlock:
                try:
                    # try to release lock by removing
                    # this is not a clean way and more than one process might
                    # grab the lock afterwards but it is ok when the task is
                    # solved by the first process that got the lock (i.e. the
                    # tile is created)
                    os.remove(self.lock_file)
                except OSError:
                    self._lock.close()
            else:
                self._lock.close()

    def __del__(self):
        self.unlock()

_cleanup_counter = -1
def cleanup_lockdir(lockdir, suffix='.lck', max_lock_time=300, force=True):
    """
    Remove files ending with `suffix` from `lockdir` if they are older then
    `max_lock_time` seconds.
    It will not cleanup on every call if `force` is ``False``.
    """
    global _cleanup_counter
    _cleanup_counter += 1
    if not force and _cleanup_counter % 50 != 0:
        return
    expire_time = time.time() - max_lock_time
    if not os.path.exists(lockdir):
        return
    if not os.path.isdir(lockdir):
        log.warn('lock dir not a directory: %s', lockdir)
        return
    for entry in os.listdir(lockdir):
        name = os.path.join(lockdir, entry)
        try:
            if os.path.isfile(name) and name.endswith(suffix):
                if os.path.getmtime(name) < expire_time:
                    try:
                        os.unlink(name)
                    except IOError, ex:
                        log.warn('could not remove old lock file %s: %s', name, ex)
        except OSError, e:
            # some one might have removed the file (ENOENT)
            # or we don't have permissions to remove it (EACCES)
            if e.errno in (errno.ENOENT, errno.EACCES):
                # ignore
                pass
            else:
                raise e



########NEW FILE########
__FILENAME__ = proj
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
ctypes based replacement of pyroj (with pyproj fallback).

This module implements the `Proj`, `transform` and `set_datapath` class/functions. This
module is a drop-in replacement for pyproj. It does implement just enough to work for
MapProxy, i.e. there is no numpy support, etc.

It uses the C libproj library. If the library could not be found/loaded it will fallback
to pyroj. You can force the usage of either backend by setting the environment variables
MAPPROXY_USE_LIBPROJ or MAPPROXY_USE_PYPROJ to any value.

"""

import os
import sys
from mapproxy.util.lib import load_library

import ctypes
from ctypes import (
   c_void_p,
   c_char_p,
   c_int,
   c_double,
   c_long,
   POINTER,
   create_string_buffer,
   addressof,
)

c_double_p = POINTER(c_double)
FINDERCMD = ctypes.CFUNCTYPE(c_char_p, c_char_p)

import logging
log_system = logging.getLogger('mapproxy.system')

__all__ = ['Proj', 'transform', 'set_datapath']


def init_libproj():
    libproj = load_library('libproj')

    if libproj is None: return

    libproj.pj_init_plus.argtypes = [c_char_p]
    libproj.pj_init_plus.restype = c_void_p

    libproj.pj_is_latlong.argtypes = [c_void_p]
    libproj.pj_is_latlong.restype = c_int


    libproj.pj_get_def.argtypes = [c_void_p, c_int]
    libproj.pj_get_def.restype = c_void_p

    libproj.pj_strerrno.argtypes = [c_int]
    libproj.pj_strerrno.restype = c_char_p

    libproj.pj_get_errno_ref.argtypes = []
    libproj.pj_get_errno_ref.restype = POINTER(c_int)

    # free proj objects
    libproj.pj_free.argtypes = [c_void_p]
    # free() wrapper
    libproj.pj_dalloc.argtypes = [c_void_p]

    libproj.pj_transform.argtypes = [c_void_p, c_void_p, c_long, c_int,
                                     c_double_p, c_double_p, c_double_p]
    libproj.pj_transform.restype = c_int

    if hasattr(libproj, 'pj_set_searchpath'):
        libproj.pj_set_searchpath.argtypes = [c_int, POINTER(c_char_p)]
        libproj.pj_set_finder.argtypes = [FINDERCMD]

    return libproj

class SearchPath(object):
    def __init__(self):
        self.path = None
        self.finder_results = {}

    def clear(self):
        self.path = None
        self.finder_results = {}

    def set_searchpath(self, path):
        self.clear()
        self.path = path

    def finder(self, name):
        if self.path is None:
            return None

        if name in self.finder_results:
            result = self.finder_results[name]
        else:
            sysname = os.path.join(self.path, name)
            result = self.finder_results[name] = create_string_buffer(sysname)

        return addressof(result)

# search_path and finder_func must be defined in module
# context to avoid garbage collection
search_path = SearchPath()
finder_func = FINDERCMD(search_path.finder)
_finder_callback_set = False

class ProjError(RuntimeError):
    pass

class ProjInitError(ProjError):
    pass

def try_pyproj_import():
    try:
        from pyproj import Proj, transform, set_datapath
    except ImportError:
        return False
    log_system.info('using pyproj for coordinate transformation')
    return Proj, transform, set_datapath

def try_libproj_import():
    libproj = init_libproj()

    if libproj is None:
        return False

    log_system.info('using libproj for coordinate transformation')

    RAD_TO_DEG = 57.29577951308232
    DEG_TO_RAD = .0174532925199432958

    class Proj(object):
        def __init__(self, proj_def=None, init=None):
            if init:
                self._proj = libproj.pj_init_plus('+init=%s' % init)
            else:
                self._proj = libproj.pj_init_plus(proj_def)
            if not self._proj:
                errno = libproj.pj_get_errno_ref().contents
                raise ProjInitError('error initializing Proj(proj_def=%r, init=%r): %s' %
                    (proj_def, init, libproj.pj_strerrno(errno)))

            self.srs = self._srs()
            self._latlong = bool(libproj.pj_is_latlong(self._proj))

        def is_latlong(self):
            """
            >>> Proj(init='epsg:4326').is_latlong()
            True
            >>> Proj(init='epsg:4258').is_latlong()
            True
            >>> Proj(init='epsg:31467').is_latlong()
            False
            >>> Proj('+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 '
            ...      '+lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m '
            ...      '+nadgrids=@null +no_defs').is_latlong()
            False
            """
            return self._latlong

        def _srs(self):
            res = libproj.pj_get_def(self._proj, 0)
            srs_def = ctypes.c_char_p(res).value
            libproj.pj_dalloc(res)
            return srs_def

        def __del__(self):
            if self._proj and libproj:
                libproj.pj_free(self._proj)
                self._proj = None

    def transform(from_srs, to_srs, x, y, z=None):
        if from_srs == to_srs:
            return (x, y) if z is None else (x, y, z)

        if isinstance(x, (float, int)):
            x = [x]
            y = [y]
        assert len(x) == len(y)

        if from_srs.is_latlong():
            x = map(lambda x: x*DEG_TO_RAD, x)
            y = map(lambda y: y*DEG_TO_RAD, y)

        x = (c_double * len(x))(*x)
        y = (c_double * len(y))(*y)
        if z is not None:
            z = (c_double * len(z))(*z)
        else:
            # use explicit null pointer instead of None
            # http://bugs.python.org/issue4606
            z = c_double_p()

        res = libproj.pj_transform(from_srs._proj, to_srs._proj,
                                   len(x), 0, x, y, z)

        if res:
            raise ProjError(libproj.pj_strerrno(res))

        if to_srs.is_latlong():
            x = map(lambda x: x*RAD_TO_DEG, x)
            y = map(lambda y: y*RAD_TO_DEG, y)
        else:
            x = x[:]
            y = y[:]

        if len(x) == 1:
            x = x[0]
            y = y[0]
            z = z[0] if z else None

        return (x, y) if z is None else (x, y, z)

    def set_datapath(path):
        global _finder_callback_set
        if not _finder_callback_set:
            libproj.pj_set_finder(finder_func)
            _finder_callback_set = True
        search_path.set_searchpath(path)

    return Proj, transform, set_datapath


proj_imports = []

if 'MAPPROXY_USE_LIBPROJ' in os.environ:
    proj_imports = [try_libproj_import]

if 'MAPPROXY_USE_PYPROJ' in os.environ:
    proj_imports = [try_pyproj_import]

if not proj_imports:
    if sys.platform == 'win32':
        # prefer pyproj on windows
        proj_imports = [try_pyproj_import, try_libproj_import]
    else:
        proj_imports = [try_libproj_import, try_pyproj_import]

for try_import in proj_imports:
    res = try_import()
    if res:
        Proj, transform, set_datapath = res
        break
else:
    raise ImportError('could not find libproj or pyproj')

if __name__ == '__main__':

    prj1 = Proj(init='epsg:4326')
    prj2 = Proj(init='epsg:31467')

    coords = [(8.2, 8.22, 8.3), (53.1, 53.15, 53.2)]
    # coords = [(8, 9, 10), (50, 50, 50)]
    print coords
    coords = transform(prj1, prj2, *coords)
    print coords
    coords = transform(prj2, prj1, *coords)
    print coords

########NEW FILE########
__FILENAME__ = image
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import warnings

__all__ = ['Image', 'ImageColor', 'ImageDraw', 'ImageFont', 'ImagePalette',
           'ImageChops', 'quantize']

try:
    from PIL import Image, ImageColor, ImageDraw, ImageFont, ImagePalette, ImageChops
    # prevent pyflakes warnings
    Image, ImageColor, ImageDraw, ImageFont, ImagePalette, ImageChops
except ImportError:
    try:
        import Image, ImageColor, ImageDraw, ImageFont, ImagePalette, ImageChops
        # prevent pyflakes warnings
        Image, ImageColor, ImageDraw, ImageFont, ImagePalette, ImageChops
    except ImportError:
        # allow MapProxy to start without PIL (for tilecache only).
        # issue warning and raise ImportError on first use of
        # a function that requires PIL
        warnings.warn('PIL is not available')
        class NoPIL(object):
            def __getattr__(self, name):
                if name.startswith('__'):
                    raise AttributeError()
                raise ImportError('PIL is not available')
        ImageDraw = ImageFont = ImagePalette = ImageChops = NoPIL()
        # add some dummy stuff required on import/load time
        Image = NoPIL()
        Image.NEAREST = Image.BILINEAR = Image.BICUBIC = 1
        Image.Image = NoPIL
        ImageColor = NoPIL()
        ImageColor.getrgb = lambda x: x

def has_alpha_composite_support():
    return hasattr(Image, 'alpha_composite')

def quantize_pil(img, colors=256, alpha=False, defaults=None):
    if hasattr(Image, 'FASTOCTREE'):
        if not alpha:
            img = img.convert('RGB')
        img = img.quantize(colors, Image.FASTOCTREE)
    else:
        if alpha:
            img.load() # split might fail if image is not loaded
            alpha = img.split()[3]
            img = img.convert('RGB').convert('P', palette=Image.ADAPTIVE, colors=colors-1)
            mask = Image.eval(alpha, lambda a: 255 if a <=128 else 0)
            img.paste(255, mask)
            if defaults is not None:
                defaults['transparency'] = 255
        else:
            img = img.convert('RGB').convert('P', palette=Image.ADAPTIVE, colors=colors)

    return img
quantize = quantize_pil
########NEW FILE########
__FILENAME__ = lock
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

__all__ = ['LockTimeout', 'FileLock', 'LockError', 'cleanup_lockdir']

from mapproxy.platform.cpython.lock import (
    LockTimeout,
    FileLock,
    LockError,
    cleanup_lockdir)
LockTimeout, FileLock, LockError, cleanup_lockdir # prevent pyflakes warnings

########NEW FILE########
__FILENAME__ = proj
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

__all__ = ['Proj', 'transform', 'set_datapath', 'ProjInitError', 'ProjError']

from mapproxy.platform.cpython.proj import (
    Proj, transform, set_datapath, ProjInitError, ProjError
)

########NEW FILE########
__FILENAME__ = proj
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from mapproxy.platform.proj import Proj, transform, set_datapath, ProjInitError

__all__ = ['Proj', 'transform', 'set_datapath', 'ProjInitError']
########NEW FILE########
__FILENAME__ = base
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Service requests (parsing, handling, etc).
"""
import urllib
import cgi

from mapproxy.util.py import cached_property


class NoCaseMultiDict(dict):
    """
    This is a dictionary that allows case insensitive access to values.

    >>> d = NoCaseMultiDict([('A', 'b'), ('a', 'c'), ('B', 'f'), ('c', 'x'), ('c', 'y'), ('c', 'z')])
    >>> d
    NoCaseMultiDict([('A', ['b', 'c']), ('c', ['x', 'y', 'z']), ('B', ['f'])])
    >>> d['a']
    'b'
    >>> d.get_all('a')
    ['b', 'c']
    >>> 'a' in d and 'b' in d
    True
    """
    def _gen_dict(self, mapping=()):
        """A `NoCaseMultiDict` can be constructed from an iterable of
        ``(key, value)`` tuples or a dict.
        """
        tmp = {}
        if isinstance(mapping, NoCaseMultiDict):
            for key, value in mapping.iteritems(): #pylint: disable-msg=E1103
                tmp.setdefault(key.lower(), (key, []))[1].extend(value)
        else:
            if isinstance(mapping, dict):
                itr = mapping.iteritems() #pylint: disable-msg=E1103
            else:
                itr = iter(mapping)
            for key, value in itr:
                tmp.setdefault(key.lower(), (key, []))[1].append(value)
        return tmp

    def __init__(self, mapping=()):
        """A `NoCaseMultiDict` can be constructed from an iterable of
        ``(key, value)`` tuples or a dict.
        """
        dict.__init__(self, self._gen_dict(mapping))

    def update(self, mapping=(), append=False):
        """A `NoCaseMultiDict` can be updated from an iterable of
        ``(key, value)`` tuples or a dict.
        """
        for _, (key, values) in self._gen_dict(mapping).iteritems():
            self.set(key, values, append=append, unpack=True)

    def __getitem__(self, key):
        """
        Return the first data value for this key.

        :raise KeyError: if the key does not exist
        """
        if key in self:
            return dict.__getitem__(self, key.lower())[1][0]
        raise KeyError(key)

    def __setitem__(self, key, value):
        dict.setdefault(self, key.lower(), (key, []))[1][:] = [value]

    def __delitem__(self, key):
        dict.__delitem__(self, key.lower())

    def __contains__(self, key):
        return dict.__contains__(self, key.lower())

    def __getstate__(self):
        data = []
        for key, values in self.iteritems():
            for v in values:
                data.append((key, v))
        return data

    def __setstate__(self, data):
        self.__init__(data)

    def get(self, key, default=None, type_func=None):
        """Return the default value if the requested data doesn't exist.
        If `type_func` is provided and is a callable it should convert the value,
        return it or raise a `ValueError` if that is not possible.  In this
        case the function will return the default as if the value was not
        found.

        Example:

        >>> d = NoCaseMultiDict(dict(foo='42', bar='blub'))
        >>> d.get('foo', type_func=int)
        42
        >>> d.get('bar', -1, type_func=int)
        -1
        """
        try:
            rv = self[key]
            if type_func is not None:
                rv = type_func(rv)
        except (KeyError, ValueError):
            rv = default
        return rv

    def get_all(self, key):
        """
        Return all values for the key as a list. Returns an empty list, if
        the key doesn't exist.
        """
        if key in self:
            return dict.__getitem__(self, key.lower())[1]
        else:
            return []

    def set(self, key, value, append=False, unpack=False):
        """
        Set a `value` for the `key`. If `append` is ``True`` the value will be added
        to other values for this `key`.

        If `unpack` is True, `value` will be unpacked and each item will be added.
        """
        if key in self:
            if not append:
                dict.__getitem__(self, key.lower())[1][:] = []
        else:
            dict.__setitem__(self, key.lower(), (key, []))
        if unpack:
            for v in value:
                dict.__getitem__(self, key.lower())[1].append(v)
        else:
            dict.__getitem__(self, key.lower())[1].append(value)

    def iteritems(self):
        """
        Iterates over all keys and values.
        """
        for _, (key, values) in dict.iteritems(self):
            yield key, values

    def copy(self):
        """
        Returns a copy of this object.
        """
        return self.__class__(self)

    def __repr__(self):
        tmp = []
        for key, values in self.iteritems():
            tmp.append((key, values))
        return '%s(%r)' % (self.__class__.__name__, tmp)


def url_decode(qs, charset='utf-8', decode_keys=False, include_empty=True,
               errors='ignore'):
    """
    Parse query string `qs` and return a `NoCaseMultiDict`.
    """
    tmp = []
    for key, value in cgi.parse_qsl(str(qs), include_empty):
        if decode_keys:
            key = key.decode(charset, errors)
        tmp.append((key, value.decode(charset, errors)))
    return NoCaseMultiDict(tmp)

class Request(object):
    charset = 'utf8'

    def __init__(self, environ):
        self.environ = environ
        self.environ['mapproxy.request'] = self

        script_name = environ.get('HTTP_X_SCRIPT_NAME', '')
        if script_name:
            del environ['HTTP_X_SCRIPT_NAME']
            environ['SCRIPT_NAME'] = script_name
            path_info = environ['PATH_INFO']
            if path_info.startswith(script_name):
                environ['PATH_INFO'] = path_info[len(script_name):]

    @cached_property
    def args(self):
        if self.environ.get('QUERY_STRING'):
            return url_decode(self.environ['QUERY_STRING'], self.charset)
        else:
            return {}

    @property
    def path(self):
        return self.environ.get('PATH_INFO', '')

    def pop_path(self):
        path = self.path.lstrip('/')
        if '/' in path:
            result, rest = path.split('/', 1)
            self.environ['PATH_INFO'] = '/' + rest
        else:
            self.environ['PATH_INFO'] = ''
            result = path
        if result:
            self.environ['SCRIPT_NAME'] = self.environ['SCRIPT_NAME'] + '/' + result
        return result

    @cached_property
    def host(self):
        if 'HTTP_X_FORWARDED_HOST' in self.environ:
            # might be a list, return first host only
            host = self.environ['HTTP_X_FORWARDED_HOST']
            host = host.split(',', 1)[0].strip()
            return host
        elif 'HTTP_HOST' in self.environ:
            host = self.environ['HTTP_HOST']
            if ':' in host:
                port = host.split(':')[1]
                if ((self.url_scheme, port) in (('https', '443'), ('http', '80'))):
                    host = host.split(':')[0]
            return host
        result = self.environ['SERVER_NAME']
        if ((self.url_scheme, self.environ['SERVER_PORT'])
            not in (('https', '443'), ('http', '80'))):
            result += ':' + self.environ['SERVER_PORT']
        return result

    @cached_property
    def url_scheme(self):
        scheme = self.environ.get('HTTP_X_FORWARDED_PROTO')
        if not scheme:
            scheme = self.environ['wsgi.url_scheme']
        return scheme

    @cached_property
    def host_url(self):
        return '%s://%s/' % (self.url_scheme, self.host)

    @property
    def script_url(self):
        "Full script URL without trailing /"
        return (self.host_url.rstrip('/') +
                urllib.quote(self.environ.get('SCRIPT_NAME', '/').rstrip('/'))
               )

    @property
    def base_url(self):
        return (self.host_url.rstrip('/')
                + urllib.quote(self.environ.get('SCRIPT_NAME', '').rstrip('/'))
                + urllib.quote(self.environ.get('PATH_INFO', ''))
               )

class RequestParams(object):
    """
    This class represents key-value request parameters. It allows case-insensitive
    access to all keys. Multiple values for a single key will be concatenated
    (eg. to ``layers=foo&layers=bar`` becomes ``layers: foo,bar``).

    All values can be accessed as a property.

    :param param: A dict or ``NoCaseMultiDict``.
    """
    params = None
    def __init__(self, param=None):
        self.delimiter = ','

        if param is None:
            self.params = NoCaseMultiDict()
        else:
            self.params = NoCaseMultiDict(param)

    def __str__(self):
        return self.query_string

    def get(self, key, default=None, type_func=None):
        """
        Returns the value for `key` or the `default`. `type_func` is called on the
        value to alter the value (e.g. use ``type_func=int`` to get ints).
        """
        return self.params.get(key, default, type_func)

    def set(self, key, value, append=False, unpack=False):
        """
        Set a `value` for the `key`. If `append` is ``True`` the value will be added
        to other values for this `key`.

        If `unpack` is True, `value` will be unpacked and each item will be added.
        """
        self.params.set(key, value, append=append, unpack=unpack)

    def update(self, mapping=(), append=False):
        """
        Update internal request parameters from an iterable of ``(key, value)``
        tuples or a dict.

        If `append` is ``True`` the value will be added to other values for
        this `key`.
        """
        self.params.update(mapping, append=append)

    def __getattr__(self, name):
        if name in self:
            return self[name]
        else:
            raise AttributeError("'%s' object has no attribute '%s" %
                                 (self.__class__.__name__, name))

    def __getitem__(self, key):
        return self.delimiter.join(map(str, self.params.get_all(key)))

    def __setitem__(self, key, value):
        """
        Set `value` for the `key`. Does not append values (see ``MapRequest.set``).
        """
        self.set(key, value)

    def __delitem__(self, key):
        if key in self:
            del self.params[key]


    def iteritems(self):
        for key, values in self.params.iteritems():
            yield key, self.delimiter.join((str(x) for x in values))

    def __contains__(self, key):
        return self.params and key in self.params

    def copy(self):
        return self.__class__(self.params)

    @property
    def query_string(self):
        """
        The map request as a query string (the order is not guaranteed).

        >>> RequestParams(dict(foo='egg', bar='ham%eggs', baz=100)).query_string
        'baz=100&foo=egg&bar=ham%25eggs'
        """
        kv_pairs = []
        for key, values in self.params.iteritems():
            value = ','.join(str(v) for v in values)
            kv_pairs.append(key + '=' + urllib.quote_plus(value, safe=','))
        return '&'.join(kv_pairs)

    def with_defaults(self, defaults):
        """
        Return this MapRequest with all values from `defaults` overwritten.
        """
        new = self.copy()
        for key, value in defaults.params.iteritems():
            if value != [None]:
                new.set(key, value, unpack=True)
        return new

class BaseRequest(object):
    """
    This class represents a request with a URL and key-value parameters.

    :param param: A dict, `NoCaseMultiDict` or ``RequestParams``.
    :param url: The service URL for the request.
    :param validate: True if the request should be validated after initialization.
    """
    request_params = RequestParams

    def __init__(self, param=None, url='', validate=False, http=None):
        self.delimiter = ','
        self.http = http

        if param is None:
            self.params = self.request_params(NoCaseMultiDict())
        else:
            if isinstance(param, RequestParams):
                self.params = self.request_params(param.params)
            else:
                self.params = self.request_params(NoCaseMultiDict(param))
        self.url = url
        if validate:
            self.validate()

    def __str__(self):
        return self.complete_url

    def validate(self):
        pass

    @property
    def raw_params(self):
        params = {}
        for key, value in self.params.iteritems():
            params[key] = value
        return params


    @property
    def query_string(self):
        return self.params.query_string

    @property
    def complete_url(self):
        """
        The complete MapRequest as URL.
        """
        if not self.url:
            return self.query_string
        delimiter = '?'
        if '?' in self.url:
            delimiter = '&'
        if self.url[-1] == '?':
            delimiter = ''
        return self.url + delimiter + self.query_string

    def copy_with_request_params(self, req):
        """
        Return a copy of this request ond overwrite all param values from `req`.
        Use this method for templates
        (``req_template.copy_with_request_params(actual_values)``).
        """
        new_params = req.params.with_defaults(self.params)
        return self.__class__(param=new_params, url=self.url)

    def __repr__(self):
        return '%s(param=%r, url=%r)' % (self.__class__.__name__, self.params, self.url)

def split_mime_type(mime_type):
    """
    >>> split_mime_type('text/xml; charset=utf-8')
    ('text', 'xml', 'charset=utf-8')
    """
    options = None
    mime_class = None
    if '/' in mime_type:
        mime_class, mime_type = mime_type.split('/', 1)
    if ';' in mime_type:
        mime_type, options = [part.strip() for part in mime_type.split(';', 2)]
    return mime_class, mime_type, options


########NEW FILE########
__FILENAME__ = tile
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

from mapproxy.exception import (
    RequestError,
    XMLExceptionHandler,
    PlainExceptionHandler, )

import mapproxy.service
from mapproxy.template import template_loader
get_template = template_loader(mapproxy.service.__name__, 'templates')

class TileRequest(object):
    """
    Class for tile requests.
    """
    request_handler_name = 'map'
    tile_req_re = re.compile(r'''^(?P<begin>/[^/]+)/
            ((?P<version>1\.0\.0)/)?
            (?P<layer>[^/]+)/
            ((?P<layer_spec>[^/]+)/)?
            (?P<z>-?\d+)/
            (?P<x>-?\d+)/
            (?P<y>-?\d+)\.(?P<format>\w+)''', re.VERBOSE)
    use_profiles = False
    req_prefix = '/tiles'
    origin = None
    dimensions = {}

    def __init__(self, request):
        self.tile = None
        self.format = None
        self.http = request
        self._init_request()
        self.origin = self.http.args.get('origin')
        if self.origin not in ('sw', 'nw', None):
            self.origin = None

    def _init_request(self):
        """
        Initialize tile request. Sets ``tile`` and ``layer``.
        :raise RequestError: if the format is not ``/layer/z/x/y.format``
        """
        match = self.tile_req_re.search(self.http.path)
        if not match or match.group('begin') != self.req_prefix:
            raise RequestError('invalid request (%s)' % (self.http.path), request=self)

        self.layer = match.group('layer')
        self.dimensions = {}
        if match.group('layer_spec') is not None:
            self.dimensions['_layer_spec'] = match.group('layer_spec')
        if not self.tile:
            self.tile = tuple([int(match.group(v)) for v in ['x', 'y', 'z']])
        if not self.format:
            self.format = match.group('format')

    @property
    def exception_handler(self):
        return PlainExceptionHandler()


class TMSRequest(TileRequest):
    """
    Class for TMS 1.0.0 requests.
    """
    request_handler_name = 'map'
    req_prefix = '/tms'
    capabilities_re = re.compile(r'''
        ^.*/1\.0\.0/?
        (/(?P<layer>[^/]+))?
        (/(?P<layer_spec>[^/]+))?
        $''', re.VERBOSE)
    root_request_re = re.compile(r'/tms/?$')
    use_profiles = True
    origin = 'sw'

    def __init__(self, request):
        self.tile = None
        self.format = None
        self.http = request
        cap_match = self.capabilities_re.match(request.path)
        root_match = self.root_request_re.match(request.path)
        if cap_match:
            if cap_match.group('layer') is not None:
                self.layer = cap_match.group('layer')
                self.dimensions = {}
                if cap_match.group('layer_spec') is not None:
                    self.dimensions['_layer_spec'] = cap_match.group('layer_spec')
            self.request_handler_name = 'tms_capabilities'
        elif root_match:
            self.request_handler_name = 'tms_root_resource'
        else:
            self._init_request()

    @property
    def exception_handler(self):
        return TMSExceptionHandler()

def tile_request(req):
    if req.path.startswith('/tms'):
        return TMSRequest(req)
    else:
        return TileRequest(req)

class TMSExceptionHandler(XMLExceptionHandler):
    template_file = 'tms_exception.xml'
    template_func = get_template
    mimetype = 'text/xml'
    status_code = 404

    def render(self, request_error):
        if request_error.internal:
            self.status_code = 500
        return XMLExceptionHandler.render(self, request_error)
########NEW FILE########
__FILENAME__ = exception
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Service exception handling (WMS exceptions, XML, in_image, etc.).
"""
from mapproxy.exception import ExceptionHandler, XMLExceptionHandler
from mapproxy.response import Response
from mapproxy.image.message import message_image
from mapproxy.image.opts import ImageOptions
import mapproxy.service
from mapproxy.template import template_loader
get_template = template_loader(mapproxy.service.__name__, 'templates')

class WMSXMLExceptionHandler(XMLExceptionHandler):
    template_func = get_template

class WMS100ExceptionHandler(WMSXMLExceptionHandler):
    """
    Exception handler for OGC WMS 1.0.0 ServiceExceptionReports
    """
    template_file = 'wms100exception.xml'
    content_type = 'text/xml'

class WMS110ExceptionHandler(WMSXMLExceptionHandler):
    """
    Exception handler for OGC WMS 1.1.0 ServiceExceptionReports
    """
    template_file = 'wms110exception.xml'
    mimetype = 'application/vnd.ogc.se_xml'

class WMS111ExceptionHandler(WMSXMLExceptionHandler):
    """
    Exception handler for OGC WMS 1.1.1 ServiceExceptionReports
    """
    template_file = 'wms111exception.xml'
    mimetype = 'application/vnd.ogc.se_xml'

class WMS130ExceptionHandler(WMSXMLExceptionHandler):
    """
    Exception handler for OGC WMS 1.3.0 ServiceExceptionReports
    """
    template_file = 'wms130exception.xml'
    mimetype = 'text/xml'

class WMSImageExceptionHandler(ExceptionHandler):
    """
    Exception handler for image exceptions.
    """
    def render(self, request_error):
        request = request_error.request
        params = request.params
        format = params.format
        size = params.size
        if size is None:
            size = (256, 256)
        transparent = ('transparent' in params
                       and params['transparent'].lower() == 'true')
        bgcolor = WMSImageExceptionHandler._bgcolor(request.params)
        image_opts = ImageOptions(format=format, bgcolor=bgcolor, transparent=transparent)
        result = message_image(request_error.msg, size=size, image_opts=image_opts)
        return Response(result.as_buffer(), content_type=params.format_mime_type)

    @staticmethod
    def _bgcolor(params):
        """
        >>> WMSImageExceptionHandler._bgcolor({'bgcolor': '0Xf0ea42'})
        '#f0ea42'
        >>> WMSImageExceptionHandler._bgcolor({})
        '#ffffff'
        """
        if 'bgcolor' in params:
            color = params['bgcolor']
            if color.lower().startswith('0x'):
                color = '#' + color[2:]
        else:
            color = '#ffffff'
        return color

class WMSBlankExceptionHandler(WMSImageExceptionHandler):
    """
    Exception handler for blank image exceptions.
    """

    def render(self, request_error):
        request_error.msg = ''
        return WMSImageExceptionHandler.render(self, request_error)

########NEW FILE########
__FILENAME__ = wmts
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Service requests (parsing, handling, etc).
"""
import re

from mapproxy.exception import RequestError
from mapproxy.request.base import RequestParams, BaseRequest, split_mime_type
from mapproxy.request.tile import TileRequest
from mapproxy.exception import XMLExceptionHandler
from mapproxy.template import template_loader
import mapproxy.service
get_template = template_loader(mapproxy.service.__name__, 'templates')


class WMTS100ExceptionHandler(XMLExceptionHandler):
    template_func = get_template
    template_file = 'wmts100exception.xml'
    content_type = 'text/xml'

    status_codes = {
        None: 500,
        'TileOutOfRange': 400,
        'MissingParameterValue': 400,
        'InvalidParameterValue': 400,
        'OperationNotSupported': 501
    }

class WMTSTileRequestParams(RequestParams):
    """
    This class represents key-value parameters for WMTS map requests.

    All values can be accessed as a property.
    Some properties return processed values. ``size`` returns a tuple of the width
    and height, ``layers`` returns an iterator of all layers, etc.

    """
    @property
    def layer(self):
        """
        List with all layer names.
        """
        return self['layer']

    def _get_coord(self):
        x = int(self['tilecol'])
        y = int(self['tilerow'])
        z = self['tilematrix']
        return x, y, z
    def _set_coord(self, value):
        x, y, z = value
        self['tilecol'] = x
        self['tilerow'] = y
        self['tilematrix'] = z
    coord = property(_get_coord, _set_coord)
    del _get_coord
    del _set_coord


    def _get_format(self):
        """
        The requested format as string (w/o any 'image/', 'text/', etc prefixes)
        """
        _mime_class, format, options = split_mime_type(self.get('format', default=''))
        return format

    def _set_format(self, format):
        if '/' not in format:
            format = 'image/' + format
        self['format'] = format

    format = property(_get_format, _set_format)
    del _get_format
    del _set_format

    @property
    def format_mime_type(self):
        return self.get('format')

    @property
    def dimensions(self):
        expected_param = set(['version', 'request', 'layer', 'style', 'tilematrixset',
            'tilematrix', 'tilerow', 'tilecol', 'format', 'service'])
        dimensions = {}
        for key, value in self.iteritems():
            if key not in expected_param:
                dimensions[key.lower()] = value
        return dimensions

    def __repr__(self):
        return '%s(param=%r)' % (self.__class__.__name__, self.params)


class WMTSRequest(BaseRequest):
    request_params = WMTSTileRequestParams
    request_handler_name = None
    fixed_params = {}
    expected_param = []
    non_strict_params = set()
    #pylint: disable=E1102
    xml_exception_handler = None

    def __init__(self, param=None, url='', validate=False, non_strict=False, **kw):
        self.non_strict = non_strict
        BaseRequest.__init__(self, param=param, url=url, validate=validate, **kw)

    def validate(self):
        pass


    @property
    def query_string(self):
        return self.params.query_string

class WMTS100TileRequest(WMTSRequest):
    """
    Base class for all WMTS GetTile requests.

    :ivar requests: the ``RequestParams`` class for this request
    :ivar request_handler_name: the name of the server handler
    :ivar fixed_params: parameters that are fixed for a request
    :ivar expected_param: required parameters, used for validating
    """
    request_params = WMTSTileRequestParams
    request_handler_name = 'tile'
    fixed_params = {'request': 'GetTile', 'version': '1.0.0', 'service': 'WMTS'}
    xml_exception_handler = WMTS100ExceptionHandler
    expected_param = ['version', 'request', 'layer', 'style', 'tilematrixset',
                      'tilematrix', 'tilerow', 'tilecol', 'format']
    #pylint: disable=E1102

    def __init__(self, param=None, url='', validate=False, non_strict=False, **kw):
        WMTSRequest.__init__(self, param=param, url=url, validate=validate,
                            non_strict=non_strict, **kw)

    def make_tile_request(self):
        self.layer = self.params.layer
        self.tilematrixset = self.params.tilematrixset
        self.format = self.params.format # TODO
        self.tile = (int(self.params.coord[0]), int(self.params.coord[1]), self.params.coord[2]) # TODO
        self.origin = 'nw'
        self.dimensions = self.params.dimensions

    def validate(self):
        missing_param = []
        for param in self.expected_param:
            if self.non_strict and param in self.non_strict_params:
                continue
            if param not in self.params:
                missing_param.append(param)

        if missing_param:
            if 'format' in missing_param:
                self.params['format'] = 'image/png'
            raise RequestError('missing parameters ' + str(missing_param),
                               request=self)

        self.validate_styles()

    def validate_styles(self):
        if 'styles' in self.params:
            styles = self.params['styles']
            if styles.replace(',', '').strip() != '':
                raise RequestError('unsupported styles: ' + self.params['styles'],
                                   code='StyleNotDefined', request=self)


    @property
    def exception_handler(self):
        return self.xml_exception_handler()

    def copy(self):
        return self.__class__(param=self.params.copy(), url=self.url)



class WMTSFeatureInfoRequestParams(WMTSTileRequestParams):
    """
    RequestParams for WMTS GetFeatureInfo requests.
    """
    def _get_pos(self):
        """x, y query image coordinates (in pixel)"""
        return int(self['i']), int(self['j'])
    def _set_pos(self, value):
        self['i'] = str(int(round(value[0])))
        self['j'] = str(int(round(value[1])))
    pos = property(_get_pos, _set_pos)
    del _get_pos
    del _set_pos


class WMTS100FeatureInfoRequest(WMTS100TileRequest):
    request_params = WMTSFeatureInfoRequestParams
    request_handler_name = 'featureinfo'
    fixed_params = WMTS100TileRequest.fixed_params.copy()
    fixed_params['request'] = 'GetFeatureInfo'
    expected_param = WMTS100TileRequest.expected_param[:] + ['infoformat', 'i', 'j']
    non_strict_params = set(['format', 'styles'])


class WMTS100CapabilitiesRequest(WMTSRequest):
    request_handler_name = 'capabilities'
    capabilities_template = 'wmts100capabilities.xml'
    exception_handler = None
    mime_type = 'text/xml'
    fixed_params = {}
    def __init__(self, param=None, url='', validate=False, non_strict=False, **kw):
        WMTSRequest.__init__(self, param=param, url=url, validate=validate, **kw)



request_mapping = { 'featureinfo': WMTS100FeatureInfoRequest,
                    'tile': WMTS100TileRequest,
                    'capabilities': WMTS100CapabilitiesRequest
}


def _parse_request_type(req):
    if 'request' in req.args:
        request_type = req.args['request'].lower()
        if request_type.startswith('get'):
            request_type = request_type[3:]
            if request_type in ('tile', 'featureinfo', 'capabilities'):
                return request_type

    return None


def wmts_request(req, validate=True):
    req_type = _parse_request_type(req)

    req_class = request_mapping.get(req_type, None)
    if req_class is None:
        # use map request to get an exception handler for the requested version
        dummy_req = request_mapping['tile'](param=req.args, url=req.base_url,
                                            validate=False)
        raise RequestError("unknown WMTS request type '%s'" % req_type, request=dummy_req)
    return req_class(param=req.args, url=req.base_url, validate=True, http=req)

def create_request(req_data, param, req_type='tile'):
    url = req_data['url']
    req_data = req_data.copy()
    del req_data['url']
    if 'request_format' in param:
        req_data['format'] = param['request_format']
    elif 'format' in param:
        req_data['format'] = param['format']
    # req_data['bbox'] = param['bbox']
    # if isinstance(req_data['bbox'], types.ListType):
    #     req_data['bbox'] = ','.join(str(x) for x in req_data['bbox'])
    # req_data['srs'] = param['srs']

    return request_mapping[req_type](url=url, param=req_data)


class InvalidWMTSTemplate(Exception):
    pass

class URLTemplateConverter(object):
    var_re = re.compile(r'(?:\\{)?\\{(\w+)\\}(?:\\})?')
    # TODO {{}} format is deprecated, change to this in 1.6
    # var_re = re.compile(r'\\{(\w+)\\}')

    variables = {
        'TileMatrixSet': r'[\w_.:-]+',
        'TileMatrix': r'\d+',
        'TileRow': r'-?\d+',
        'TileCol': r'-?\d+',
        'Style': r'[\w_.:-]+',
        'Layer': r'[\w_.:-]+',
        'Format': r'\w+'
    }

    required = set(['TileCol', 'TileRow', 'TileMatrix', 'TileMatrixSet', 'Layer'])

    def __init__(self, template):
        self.template = template
        self.found = set()
        self.dimensions = []
        self._regexp = None
        self.regexp()

    def substitute_var(self, match):
        var = match.group(1)
        if var in self.variables:
            var_type_re = self.variables[var]
        else:
            self.dimensions.append(var)
            var = var.lower()
            var_type_re = r'[\w_.,:-]+'
        self.found.add(var)
        return r'(?P<%s>%s)' % (var, var_type_re)


    def regexp(self):
        if self._regexp:
            return self._regexp
        converted_re = self.var_re.sub(self.substitute_var, re.escape(self.template))
        wmts_re = re.compile(converted_re)
        if not self.found.issuperset(self.required):
            raise InvalidWMTSTemplate('missing required variables in WMTS restful template: %s' %
                self.required.difference(self.found))
        self._regexp = wmts_re
        return wmts_re

class WMTS100RestTileRequest(TileRequest):
    """
    Class for TMS-like KML requests.
    """
    xml_exception_handler = WMTS100ExceptionHandler
    request_handler_name = 'tile'
    origin = 'nw'
    url_converter = None

    def __init__(self, request):
        self.http = request
        self.url = request.base_url
        self.dimensions = {}

    def make_tile_request(self):
        """
        Initialize tile request. Sets ``tile`` and ``layer`` and ``format``.
        :raise RequestError: if the format does not match the URL template``
        """
        match = self.tile_req_re.search(self.http.path)
        if not match:
            raise RequestError('invalid request (%s)' % (self.http.path), request=self)

        req_vars = match.groupdict()

        self.layer = req_vars['Layer']
        self.tile = int(req_vars['TileCol']), int(req_vars['TileRow']), int(req_vars['TileMatrix'])
        self.format = req_vars.get('Format')
        self.tilematrixset = req_vars['TileMatrixSet']
        if self.url_converter and self.url_converter.dimensions:
            for dim in self.url_converter.dimensions:
                self.dimensions[dim.lower()] = req_vars[dim.lower()]

    @property
    def exception_handler(self):
        return self.xml_exception_handler()

RESTFUL_CAPABILITIES_PATH = '/1.0.0/WMTSCapabilities.xml'

class WMTS100RestCapabilitiesRequest(object):
    """
    Class for RESTful WMTS capabilities requests.
    """
    xml_exception_handler = WMTS100ExceptionHandler
    request_handler_name = 'capabilities'
    capabilities_template = 'wmts100capabilities.xml'

    def __init__(self, request):
        self.http = request
        self.url = request.base_url[:-len(RESTFUL_CAPABILITIES_PATH)]

    @property
    def exception_handler(self):
        return self.xml_exception_handler()


def make_wmts_rest_request_parser(url_converter_):
    class WMTSRequestWrapper(WMTS100RestTileRequest):
        url_converter = url_converter_
        tile_req_re = url_converter.regexp()

    def wmts_request(req):
        if req.path.endswith(RESTFUL_CAPABILITIES_PATH):
            return WMTS100RestCapabilitiesRequest(req)
        return WMTSRequestWrapper(req)

    return wmts_request

########NEW FILE########
__FILENAME__ = response
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Service responses.
"""

import hashlib
from mapproxy.util.times import format_httpdate, parse_httpdate, timestamp

class Response(object):
    charset = 'utf-8'
    default_content_type = 'text/plain'
    block_size = 1024 * 32

    def __init__(self, response, status=None, content_type=None, mimetype=None):
        self.response = response
        if status is None:
            status = 200
        self.status = status
        self._timestamp = None
        self.headers = {}
        if mimetype:
            if mimetype.startswith('text/'):
                content_type = mimetype + '; charset=' + self.charset
            else:
                content_type = mimetype
        if content_type is None:
            content_type = self.default_content_type
        self.headers['Content-type'] = content_type

    def _status_set(self, status):
        if isinstance(status, (int, long)):
            status = status_code(status)
        self._status = status

    def _status_get(self):
        return self._status

    status = property(_status_get, _status_set)

    def _last_modified_set(self, date):
        if not date: return
        self._timestamp = timestamp(date)
        self.headers['Last-modified'] = format_httpdate(self._timestamp)
    def _last_modified_get(self):
        return self.headers.get('Last-modified', None)

    last_modified = property(_last_modified_get, _last_modified_set)

    def _etag_set(self, value):
        self.headers['ETag'] = value

    def _etag_get(self):
        return self.headers.get('ETag', None)

    etag = property(_etag_get, _etag_set)

    def cache_headers(self, timestamp=None, etag_data=None, max_age=None, no_cache=False):
        """
        Set cache-related headers.

        :param timestamp: local timestamp of the last modification of the
            response content
        :param etag_data: list that will be used to build an ETag hash.
            calls the str function on each item.
        :param max_age: the maximum cache age in seconds
        """
        if etag_data:
            hash_src = ''.join((str(x) for x in etag_data))
            self.etag = hashlib.md5(hash_src).hexdigest()

        if no_cache:
            assert not timestamp and not max_age
            self.headers['Cache-Control'] = 'no-cache, no-store'
            self.headers['Pragma'] = 'no-cache'
            self.headers['Expires'] = '-1'

        self.last_modified = timestamp
        if (timestamp or etag_data) and max_age is not None:
            self.headers['Cache-control'] = 'max-age=%d public' % max_age

    def make_conditional(self, req):
        """
        Make the response conditional to the HTTP headers in the CGI/WSGI `environ`.
        Checks for ``If-none-match`` and ``If-modified-since`` headers and compares
        to the etag and timestamp of this response. If the content was not modified
        the repsonse will changed to HTTP 304 Not Modified.
        """
        if req is None:
            return
        environ = req.environ

        not_modified = False


        if self.etag == environ.get('HTTP_IF_NONE_MATCH', -1):
            not_modified = True
        elif self._timestamp is not None:
            date = environ.get('HTTP_IF_MODIFIED_SINCE', None)
            timestamp = parse_httpdate(date)
            if timestamp is not None and self._timestamp <= timestamp:
                not_modified = True

        if not_modified:
            self.status = 304
            self.response = []
            if 'Content-type' in self.headers:
                del self.headers['Content-type']

    @property
    def content_length(self):
        return int(self.headers.get('Content-length', 0))

    @property
    def content_type(self):
        return self.headers['Content-type']

    @property
    def data(self):
        if hasattr(self.response, 'read'):
            return self.response.read()
        else:
            return ''.join(chunk.encode() for chunk in self.response)

    @property
    def fixed_headers(self):
        headers = []
        for key, value in self.headers.iteritems():
            headers.append((key, value.encode()))
        return headers

    def __call__(self, environ, start_response):
        if hasattr(self.response, 'read'):
            if ((not hasattr(self.response, 'ok_to_seek') or
                self.response.ok_to_seek) and
               (hasattr(self.response, 'seek') and
                hasattr(self.response, 'tell'))):
                self.response.seek(0, 2) # to EOF
                self.headers['Content-length'] = str(self.response.tell())
                self.response.seek(0)
            if 'wsgi.file_wrapper' in environ:
                resp_iter = environ['wsgi.file_wrapper'](self.response, self.block_size)
            else:
                resp_iter = iter(lambda: self.response.read(self.block_size), '')
        else:
            if isinstance(self.response, basestring):
                self.headers['Content-length'] = str(len(self.response))
                self.response = [self.response]
            resp_iter = self.iter_encode(self.response)

        start_response(self.status, self.fixed_headers)
        return resp_iter

    def iter_encode(self, chunks):
        for chunk in chunks:
            if isinstance(chunk, unicode):
                chunk = chunk.encode(self.charset)
            yield chunk


# http://www.faqs.org/rfcs/rfc2616.html
_status_codes = {
    100: 'Continue',
    101: 'Switching Protocols',
    200: 'OK',
    201: 'Created',
    202: 'Accepted',
    203: 'Non-Authoritative Information',
    204: 'No Content',
    205: 'Reset Content',
    206: 'Partial Content',
    300: 'Multiple Choices',
    301: 'Moved Permanently',
    302: 'Found',
    303: 'See Other',
    304: 'Not Modified',
    305: 'Use Proxy',
    307: 'Temporary Redirect',
    400: 'Bad Request',
    401: 'Unauthorized',
    402: 'Payment Required',
    403: 'Forbidden',
    404: 'Not Found',
    405: 'Method Not Allowed',
    406: 'Not Acceptable',
    407: 'Proxy Authentication Required',
    408: 'Request Time-out',
    409: 'Conflict',
    410: 'Gone',
    411: 'Length Required',
    412: 'Precondition Failed',
    413: 'Request Entity Too Large',
    414: 'Request-URI Too Large',
    415: 'Unsupported Media Type',
    416: 'Requested range not satisfiable',
    417: 'Expectation Failed',
    500: 'Internal Server Error',
    501: 'Not Implemented',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Gateway Time-out',
    505: 'HTTP Version not supported',
}

def status_code(code):
    return str(code) + ' ' + _status_codes[code]

########NEW FILE########
__FILENAME__ = app
# -:- encoding: utf-8 -:-
# This file is part of the MapProxy project.
# Copyright (C) 2013 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

import sys
import os
import optparse
import logging
import textwrap
import datetime
import xml.etree.ElementTree
import yaml

from contextlib import contextmanager
from cStringIO import StringIO

from .sources import sources
from .layers import layers
from .caches import caches
from .seeds import seeds
from .utils import update_config, MapProxyYAMLDumper, download_capabilities

from mapproxy.config.loader import load_configuration
from mapproxy.util.ext.wmsparse import parse_capabilities

def setup_logging(level=logging.INFO):
    mapproxy_log = logging.getLogger('mapproxy')
    mapproxy_log.setLevel(level)

    ch = logging.StreamHandler(sys.stdout)
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter(
        "[%(asctime)s] %(name)s - %(levelname)s - %(message)s")
    ch.setFormatter(formatter)
    mapproxy_log.addHandler(ch)

def write_header(f, capabilities):
    print >>f, '# MapProxy configuration automatically generated from:'
    print >>f, '#   %s' % capabilities
    print >>f, '#'
    print >>f, '# NOTE: The generated configuration can be highly inefficient,'
    print >>f, '#       especially when multiple layers and caches are requested at once.'
    print >>f, '#       Make sure you understand the generated configuration!'
    print >>f, '#'
    print >>f, '# Created on %s with:' % datetime.datetime.now()
    print >>f, ' \\\n'.join(textwrap.wrap(' '.join(sys.argv), initial_indent='# ', subsequent_indent='#    '))
    print >>f, ''


@contextmanager
def file_or_stdout(name):
    if name == '-':
        yield sys.stdout
    else:
        with open(name, 'wb') as f:
            yield f

def config_command(args):
    parser = optparse.OptionParser("usage: %prog autoconfig [options]")

    parser.add_option('--capabilities',
        help="URL or filename of WMS 1.1.1/1.3.0 capabilities document")
    parser.add_option('--output', help="filename for created MapProxy config [default: -]", default="-")
    parser.add_option('--output-seed', help="filename for created seeding config")

    parser.add_option('--base', help='base config to include in created MapProxy config')

    parser.add_option('--overwrite',
        help='YAML file with overwrites for the created MapProxy config')
    parser.add_option('--overwrite-seed',
        help='YAML file with overwrites for the created seeding config')

    parser.add_option('--force', default=False, action='store_true',
        help="overwrite existing files")

    options, args = parser.parse_args(args)

    if not options.capabilities:
        parser.print_help()
        print >>sys.stderr, "\nERROR: --capabilities required"
        return 2

    if not options.output and not options.output_seed:
        parser.print_help()
        print >>sys.stderr, "\nERROR: --output and/or --output-seed required"
        return 2

    if not options.force:
        if options.output and options.output != '-' and os.path.exists(options.output):
            print >>sys.stderr, "\nERROR: %s already exists, use --force to overwrite" % options.output
            return 2
        if options.output_seed and options.output_seed != '-' and os.path.exists(options.output_seed):
            print >>sys.stderr, "\nERROR: %s already exists, use --force to overwrite" % options.output_seed
            return 2

    log = logging.getLogger('mapproxy_conf_cmd')
    log.addHandler(logging.StreamHandler())

    setup_logging(logging.WARNING)

    srs_grids = {}
    if options.base:
        base = load_configuration(options.base)
        for name, grid_conf in base.grids.iteritems():
            if name.startswith('GLOBAL_'):
                continue
            srs_grids[grid_conf.tile_grid().srs.srs_code] = name

    cap_doc = options.capabilities
    if cap_doc.startswith(('http://', 'https://')):
        cap_doc = download_capabilities(options.capabilities).read()
    else:
        cap_doc = open(cap_doc, 'rb').read()

    try:
        cap = parse_capabilities(StringIO(cap_doc))
    except (xml.etree.ElementTree.ParseError, ValueError), ex:
        print >>sys.stderr, ex
        print >>sys.stderr, cap_doc[:1000] + ('...' if len(cap_doc) > 1000 else '')
        return 3

    overwrite = None
    if options.overwrite:
        with open(options.overwrite, 'rb') as f:
            overwrite = yaml.load(f)

    overwrite_seed = None
    if options.overwrite_seed:
        with open(options.overwrite_seed, 'rb') as f:
            overwrite_seed = yaml.load(f)

    conf = {}
    if options.base:
        conf['base'] = os.path.abspath(options.base)

    conf['services'] = {'wms': {'md': {'title': cap.metadata()['title']}}}
    if overwrite:
        conf['services'] = update_config(conf['services'], overwrite.pop('service', {}))

    conf['sources'] = sources(cap)
    if overwrite:
        conf['sources'] = update_config(conf['sources'], overwrite.pop('sources', {}))

    conf['caches'] = caches(cap, conf['sources'], srs_grids=srs_grids)
    if overwrite:
        conf['caches'] = update_config(conf['caches'], overwrite.pop('caches', {}))

    conf['layers'] = layers(cap, conf['caches'])
    if overwrite:
        conf['layers'] = update_config(conf['layers'], overwrite.pop('layers', {}))

    if overwrite:
        conf = update_config(conf, overwrite)


    seed_conf = {}
    seed_conf['seeds'], seed_conf['cleanups'] = seeds(cap, conf['caches'])
    if overwrite_seed:
        seed_conf = update_config(seed_conf, overwrite_seed)


    if options.output:
        with file_or_stdout(options.output) as f:
            write_header(f, options.capabilities)
            yaml.dump(conf, f, default_flow_style=False, Dumper=MapProxyYAMLDumper)
    if options.output_seed:
        with file_or_stdout(options.output_seed) as f:
            write_header(f, options.capabilities)
            yaml.dump(seed_conf, f, default_flow_style=False, Dumper=MapProxyYAMLDumper)

    return 0
########NEW FILE########
__FILENAME__ = caches
# -:- encoding: utf-8 -:-
# This file is part of the MapProxy project.
# Copyright (C) 2013 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

def caches(cap, sources, srs_grids):
    caches = {}
    for name, source in sources.iteritems():
        conf = for_source(name, source, srs_grids)
        if not conf:
            continue
        caches[name[:-len('_wms')] + '_cache'] = conf

    return caches

def for_source(name, source, srs_grids):
    cache = {
        'sources': [name]
    }

    grids = []
    for srs in source['supported_srs']:
        if srs in srs_grids:
            grids.append(srs_grids[srs])

    if not grids:
        return None

    cache['grids'] = grids

    return cache


########NEW FILE########
__FILENAME__ = layers
# -:- encoding: utf-8 -:-
# This file is part of the MapProxy project.
# Copyright (C) 2013 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

def layers(cap, caches):
    return [_layer(cap.layers(), caches)]

def _layer(layer, caches):
    name, conf = for_layer(layer, caches)
    child_layers = []

    for child_layer in layer['layers']:
        child_layers.append(_layer(child_layer, caches))

    if child_layers:
        conf['layers'] = child_layers

    return conf


def for_layer(layer, caches):
    conf = {
        'title': layer['title'],
    }

    if layer['name']:
        conf['name'] = layer['name']

        if layer['name'] + '_cache' in caches:
            conf['sources'] = [layer['name'] + '_cache']
        else:
            conf['sources'] = [layer['name'] + '_wms']

    md = {}
    if layer['abstract']:
        md['abstract'] = layer['abstract']

    if md:
        conf['md'] = md

    return layer['name'], conf


########NEW FILE########
__FILENAME__ = seeds
# -:- encoding: utf-8 -:-
# This file is part of the MapProxy project.
# Copyright (C) 2013 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

def seeds(cap, caches):
    seeds = {}
    cleanups = {}

    for cache_name, cache in caches.iteritems():
        for grid in cache['grids']:
            seeds[cache_name + '_' + grid] = {
                'caches': [cache_name],
                'grids': [grid],
            }
            cleanups[cache_name + '_' + grid] = {
                'caches': [cache_name],
                'grids': [grid],
                'remove_before': {
                    'time': '1900-01-01T00:00:00',
                }
            }

    return seeds, cleanups
########NEW FILE########
__FILENAME__ = sources
# -:- encoding: utf-8 -:-
# This file is part of the MapProxy project.
# Copyright (C) 2013 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from mapproxy.srs import SRS

import logging

def sources(cap):
    sources = {}
    for layer in cap.layers_list():
        name, conf = for_layer(cap, layer)
        sources[name+'_wms'] = conf

    return sources

_checked_srs = {}

def check_srs(srs):
    if srs not in _checked_srs:
        try:
            SRS(srs)
            _checked_srs[srs] = True
        except Exception, ex:
            logging.getLogger(__name__).warn('unable to initialize srs for %s: %s', srs, ex)
            _checked_srs[srs] = False

    return _checked_srs[srs]

def for_layer(cap, layer):
    source = {'type': 'wms'}

    req = {
        'url': layer['url'],
        'layers': layer['name'],
    }

    if not layer['opaque']:
        req['transparent'] = True

    wms_opts = {}
    if cap.version != '1.1.1':
        wms_opts['version'] = cap.version
    if layer['queryable']:
        wms_opts['featureinfo'] = True
    if layer['legend']:
        wms_opts['legendurl'] = layer['legend']['url']
    if wms_opts:
        source['wms_opts'] = wms_opts

    source['req'] = req

    source['supported_srs'] = []
    for srs in layer['srs']:
        if check_srs(srs):
            source['supported_srs'].append(srs)

    if layer['llbbox']:
        source['coverage'] = {
            'srs': 'EPSG:4326',
            'bbox': layer['llbbox'],
        }

    res_hint = layer['res_hint']
    if res_hint:
        if res_hint[0]:
            source['min_res'] = res_hint[0]
        if res_hint[1]:
            source['max_res'] = res_hint[1]

    return layer['name'], source



########NEW FILE########
__FILENAME__ = utils
# -:- encoding: utf-8 -:-
# This file is part of the MapProxy project.
# Copyright (C) 2013 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from copy import copy

__all__ = ['update_config', 'MapProxyYAMLDumper']

def update_config(conf, overwrites):
    wildcard_keys = []
    for k, v in overwrites.iteritems():
        if k == '__all__':
            continue
        if  k.startswith('___') or k.endswith('___'):
            wildcard_keys.append(k)
            continue

        if k.endswith('__extend__'):
            k = k[:-len('__extend__')]
            if k not in conf:
                conf[k] = v
            elif isinstance(v, list):
                conf[k].extend(v)
            else:
                raise ValueError('cannot extend non-list:', v)
        elif k not in conf:
            conf[k] = copy(v)
        else:
            if isinstance(conf[k], dict) and isinstance(v, dict):
                conf[k] = update_config(conf[k], v)
            else:
                conf[k] = copy(v)

    if '__all__' in overwrites:
        v = overwrites['__all__']
        for conf_k, conf_v in conf.iteritems():
            if isinstance(conf_v, dict):
                conf[conf_k] = update_config(conf_v, v)
            else:
                conf[conf_k] = v

    if wildcard_keys:
        for key in wildcard_keys:
            v = overwrites[key]
            if key.startswith('___'):
                key = key[3:]
                key_check = lambda x: x.endswith(key)
            else:
                key = key[:-3]
                key_check = lambda x: x.startswith(key)
            for conf_k, conf_v in conf.iteritems():
                if not key_check(conf_k):
                    continue
                if isinstance(conf_v, dict):
                    conf[conf_k] = update_config(conf_v, v)
                else:
                    conf[conf_k] = v

    return conf


from yaml.serializer import Serializer
from yaml.nodes import ScalarNode, SequenceNode, MappingNode
from yaml.emitter import Emitter
from yaml.representer import Representer
from yaml.resolver import Resolver

class _MixedFlowSortedSerializer(Serializer):
    def serialize_node(self, node, parent, index):
        # reset any anchors
        if parent is None:
            for k in self.anchors:
                self.anchors[k] = None
        self.serialized_nodes = {}

        if isinstance(node, SequenceNode) and all(isinstance(item, ScalarNode) for item in node.value):
            node.flow_style = True
        elif isinstance(node, MappingNode):
            node.value.sort(key=lambda x: x[0].value)
        return Serializer.serialize_node(self, node, parent, index)

class _EmptyNoneRepresenter(Representer):
    def represent_none(self, data):
        return self.represent_scalar(u'tag:yaml.org,2002:null',
                u'')
_EmptyNoneRepresenter.add_representer(type(None), _EmptyNoneRepresenter.represent_none)

class MapProxyYAMLDumper(Emitter, _MixedFlowSortedSerializer, _EmptyNoneRepresenter, Resolver):
    """
    YAML dumper that uses block style by default, except for
    node-only sequences. Also sorts dicts by key, prevents `none`
    for empty entries and prevents any anchors.
    """
    def __init__(self, stream,
            default_style=None, default_flow_style=False,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None):
        Emitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width,
                allow_unicode=allow_unicode, line_break=line_break)
        Serializer.__init__(self, encoding=encoding,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        Representer.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style)
        Resolver.__init__(self)

import urlparse
from mapproxy.request.base import BaseRequest, url_decode
from mapproxy.client.http import open_url

def wms_capapilities_url(url):
    parsed_url = urlparse.urlparse(url)
    base_req = BaseRequest(
        url=url.split('?', 1)[0],
        param=url_decode(parsed_url.query),
    )

    base_req.params['service'] = 'WMS'
    if not base_req.params['version']:
        base_req.params['version'] = '1.1.1'
    base_req.params['request'] = 'GetCapabilities'
    return base_req.complete_url

def download_capabilities(url):
    capabilities_url = wms_capapilities_url(url)
    return open_url(capabilities_url)


########NEW FILE########
__FILENAME__ = export
# This file is part of the MapProxy project.
# Copyright (C) 2012 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from __future__ import with_statement, division

import os
import re
import shlex
import sys
import optparse

import yaml

from mapproxy.srs import SRS
from mapproxy.config.coverage import load_coverage
from mapproxy.config.loader import (
    load_configuration, ConfigurationError,
    CacheConfiguration, GridConfiguration,
)
from mapproxy.util.coverage import  BBOXCoverage
from mapproxy.seed.util import ProgressLog, format_bbox
from mapproxy.seed.seeder import SeedTask, seed_task
from mapproxy.config import spec as conf_spec
from mapproxy.util.ext.dictspec.validator import validate, ValidationError


def parse_levels(level_str):
    """
    >>> parse_levels('1,2,3,6')
    [1, 2, 3, 6]
    >>> parse_levels('1..6')
    [1, 2, 3, 4, 5, 6]
    >>> parse_levels('1..6, 8, 9, 13..14')
    [1, 2, 3, 4, 5, 6, 8, 9, 13, 14]
    """
    levels = set()
    for part in level_str.split(','):
        part = part.strip()
        if re.match('\d+..\d+', part):
            from_level, to_level = part.split('..')
            levels.update(range(int(from_level), int(to_level) + 1))
        else:
            levels.add(int(part))

    return sorted(levels)

def parse_grid_definition(definition):
    """
    >>> parse_grid_definition("res=[10000,1000,100,10] srs=EPSG:4326 bbox=5,50,10,60")
    {'res': [10000, 1000, 100, 10], 'bbox': '5,50,10,60', 'srs': 'EPSG:4326'}
    """
    args = shlex.split(definition)
    grid_conf = {}
    for arg in args:
        key, value = arg.split('=')
        value = yaml.load(value)
        grid_conf[key] = value

    validate(conf_spec.grid_opts, grid_conf)
    return grid_conf

def supports_tiled_access(mgr):
    if len(mgr.sources) == 1 and getattr(mgr.sources[0], 'supports_meta_tiles') == False:
        return True
    return False


def format_export_task(task, custom_grid):
    info = []
    if custom_grid:
        grid = "custom grid"
    else:
        grid = "grid '%s'" % task.md['grid_name']

    info.append("Exporting cache '%s' to '%s' with %s in %s" % (
                 task.md['cache_name'], task.md['dest'], grid, task.grid.srs.srs_code))
    if task.coverage:
        info.append('  Limited to: %s (EPSG:4326)' % (format_bbox(task.coverage.extent.llbbox), ))
    info.append('  Levels: %s' % (task.levels, ))

    return '\n'.join(info)

def export_command(args=None):
    parser = optparse.OptionParser("%prog grids [options] mapproxy_conf")
    parser.add_option("-f", "--mapproxy-conf", dest="mapproxy_conf",
        help="MapProxy configuration")

    parser.add_option("--source", dest="source",
        help="source to export (source or cache)")

    parser.add_option("--grid",
        help="grid for export. either the name of an existing grid or "
        "the grid definition as a string")

    parser.add_option("--dest",
        help="destination of the export (directory or filename)")

    parser.add_option("--type",
        help="type of the export format")

    parser.add_option("--levels",
        help="levels to export: e.g 1,2,3 or 1..10")

    parser.add_option("--fetch-missing-tiles", dest="fetch_missing_tiles",
        action='store_true', default=False,
        help="if missing tiles should be fetched from the sources")

    parser.add_option("--force",
        action='store_true', default=False,
        help="overwrite/append to existing --dest files/directories")

    parser.add_option("-n", "--dry-run",
        action="store_true", default=False,
        help="do not export, just print output")

    parser.add_option("-c", "--concurrency", type="int",
        dest="concurrency", default=1,
        help="number of parallel export processes")

    parser.add_option("--coverage",
        help="the coverage for the export as a BBOX string, WKT file "
        "or OGR datasource")
    parser.add_option("--srs",
        help="the SRS of the coverage")
    parser.add_option("--where",
        help="filter for OGR coverages")

    from mapproxy.script.util import setup_logging
    import logging
    setup_logging(logging.WARN)

    if args:
        args = args[1:] # remove script name

    (options, args) = parser.parse_args(args)

    if not options.mapproxy_conf:
        if len(args) != 1:
            parser.print_help()
            sys.exit(1)
        else:
            options.mapproxy_conf = args[0]

    required_options = ['mapproxy_conf', 'grid', 'source', 'dest', 'levels']
    for required in required_options:
        if not getattr(options, required):
            print >>sys.stderr, 'ERROR: missing required option --%s' % required.replace('_', '-')
            parser.print_help()
            sys.exit(1)

    try:
        conf = load_configuration(options.mapproxy_conf)
    except IOError, e:
        print >>sys.stderr, 'ERROR: ', "%s: '%s'" % (e.strerror, e.filename)
        sys.exit(2)
    except ConfigurationError, e:
        print >>sys.stderr, e
        print >>sys.stderr, 'ERROR: invalid configuration (see above)'
        sys.exit(2)


    if '=' in options.grid:
        try:
            grid_conf = parse_grid_definition(options.grid)
        except ValidationError, ex:
            print >>sys.stderr, 'ERROR: invalid grid configuration'
            for error in ex.errors:
                print >>sys.stderr, ' ', error
            sys.exit(2)
        except ValueError:
            print >>sys.stderr, 'ERROR: invalid grid configuration'
            sys.exit(2)
        options.grid = 'tmp_mapproxy_export_grid'
        grid_conf['name'] = options.grid
        custom_grid = True
        conf.grids[options.grid] = GridConfiguration(grid_conf, conf)
    else:
        custom_grid = False

    if os.path.exists(options.dest) and not options.force:
        print >>sys.stderr, 'ERROR: destination exists, remove first or use --force'
        sys.exit(2)


    cache_conf = {
        'name': 'export',
        'grids': [options.grid],
        'sources': [options.source],
    }
    if options.type == 'mbtile':
        cache_conf['cache'] = {
            'type': 'mbtiles',
            'filename': options.dest,
        }
    elif options.type in ('tc', 'mapproxy'):
        cache_conf['cache'] = {
            'type': 'file',
            'directory': options.dest,
        }
    elif options.type in ('tms', None): # default
        cache_conf['cache'] = {
            'type': 'file',
            'directory_layout': 'tms',
            'directory': options.dest,
        }
    else:
        print >>sys.stderr, 'ERROR: unsupported --type %s' % (options.type, )
        sys.exit(2)

    if not options.fetch_missing_tiles:
        for source in conf.sources.values():
            source.conf['seed_only'] = True

    tile_grid, extent, mgr = CacheConfiguration(cache_conf, conf).caches()[0]


    levels = parse_levels(options.levels)
    if levels[-1] >= tile_grid.levels:
        print >>sys.stderr, 'ERROR: destination grid only has %d levels' % tile_grid.levels
        sys.exit(2)

    if options.srs:
        srs = SRS(options.srs)
    else:
        srs = tile_grid.srs

    if options.coverage:
        seed_coverage = load_coverage(
            {'datasource': options.coverage, 'srs': srs, 'where': options.where},
            base_path=os.getcwd())
    else:
        seed_coverage = BBOXCoverage(tile_grid.bbox, tile_grid.srs)

    if not supports_tiled_access(mgr):
        print >>sys.stderr, 'WARN: grids are incompatible. needs to scale/reproject tiles for export.'

    md = dict(name='export', cache_name='cache', grid_name=options.grid, dest=options.dest)
    task = SeedTask(md, mgr, levels, None, seed_coverage)

    print format_export_task(task, custom_grid=custom_grid)

    logger = ProgressLog(verbose=True, silent=False)
    try:
        seed_task(task, progress_logger=logger, dry_run=options.dry_run,
             concurrency=options.concurrency)
    except KeyboardInterrupt:
        print >>sys.stderr, 'stopping...'
        sys.exit(2)


########NEW FILE########
__FILENAME__ = grids
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from __future__ import with_statement, division

import sys
import optparse

from mapproxy.config import local_base_config
from mapproxy.config.loader import load_configuration, ConfigurationError
from mapproxy.seed.config import (
    load_seed_tasks_conf, SeedConfigurationError, SeedingConfiguration
)

def format_conf_value(value):
    if isinstance(value, tuple):
        # YAMl only supports lists, convert for clarity
        value = list(value)
    return repr(value)

def _area_from_bbox(bbox):
    width = bbox[2] - bbox[0]
    height = bbox[3] - bbox[1]
    return width * height

def grid_coverage_ratio(bbox, srs, coverage):
    coverage = coverage.transform_to(srs)
    grid_area = _area_from_bbox(bbox)

    if coverage.geom:
        coverage_area = coverage.geom.area
    else:
        coverage_area = _area_from_bbox(coverage.bbox)

    return coverage_area / grid_area

def display_grid(grid_conf, coverage=None):
    print '%s:' % (grid_conf.conf['name'],)
    print '    Configuration:'
    conf_dict = grid_conf.conf.copy()

    tile_grid = grid_conf.tile_grid()
    if 'tile_size' not in conf_dict:
        conf_dict['tile_size*'] = tile_grid.tile_size
    if 'bbox' not in conf_dict:
        conf_dict['bbox*'] = tile_grid.bbox
    if 'origin' not in conf_dict:
        conf_dict['origin*'] = tile_grid.origin or 'sw'
    area_ratio = None
    if coverage:
        bbox = tile_grid.bbox
        area_ratio = grid_coverage_ratio(bbox, tile_grid.srs, coverage)

    for key in sorted(conf_dict):
        if key == 'name':
            continue
        print '        %s: %s' % (key, format_conf_value(conf_dict[key]))
    if coverage:
        print '    Coverage: %s covers approx. %.4f%% of the grid BBOX' % (coverage.name, area_ratio * 100)
        print '    Levels: Resolutions, # x * y = total tiles (approx. tiles within coverage)'
    else:
        print '    Levels: Resolutions, # x * y = total tiles'
    max_digits = max([len("%r" % (res,)) for level, res in enumerate(tile_grid.resolutions)])
    for level, res in enumerate(tile_grid.resolutions):
        tiles_in_x, tiles_in_y = tile_grid.grid_sizes[level]
        total_tiles = tiles_in_x * tiles_in_y
        spaces = max_digits - len("%r" % (res,)) + 1

        if coverage:
            coverage_tiles = total_tiles * area_ratio
            print "        %.2d:  %r,%s# %6d * %-6d = %8s (%s)" % (level, res, ' '*spaces, tiles_in_x, tiles_in_y, human_readable_number(total_tiles), human_readable_number(coverage_tiles))
        else:
            print "        %.2d:  %r,%s# %6d * %-6d = %8s" % (level, res, ' '*spaces, tiles_in_x, tiles_in_y, human_readable_number(total_tiles))

def human_readable_number(num):
    if num > 10**12:
        return '%.3fT' % (num/10**12)
    if num > 10**9:
        return '%.3fG' % (num/10**9)
    if num > 10**6:
        return '%.3fM' % (num/10**6)
    if num > 10**3:
        return '%.3fK' % (num/10**3)
    return '%d' % num

def display_grids_list(grids):
    for grid_name in sorted(grids.keys()):
        print grid_name

def display_grids(grids, coverage=None):
    for i, grid_name in enumerate(sorted(grids.keys())):
        if i != 0:
            print
        display_grid(grids[grid_name], coverage=coverage)

def grids_command(args=None):
    parser = optparse.OptionParser("%prog grids [options] mapproxy_conf")
    parser.add_option("-f", "--mapproxy-conf", dest="mapproxy_conf",
        help="MapProxy configuration.")
    parser.add_option("-g", "--grid", dest="grid_name",
        help="Display only information about the specified grid.")
    parser.add_option("--all", dest="show_all", action="store_true", default=False,
        help="Show also grids that are not referenced by any cache.")
    parser.add_option("-l", "--list", dest="list_grids", action="store_true", default=False, help="List names of configured grids, which are used by any cache")
    coverage_group = parser.add_option_group("Approximate the number of tiles within a given coverage")
    coverage_group.add_option("-s", "--seed-conf", dest="seed_config", help="Seed configuration, where the coverage is defined")
    coverage_group.add_option("-c", "--coverage-name", dest="coverage", help="Calculate number of tiles when a coverage is given")

    from mapproxy.script.util import setup_logging
    import logging
    setup_logging(logging.WARN)

    if args:
        args = args[1:] # remove script name

    (options, args) = parser.parse_args(args)
    if not options.mapproxy_conf:
        if len(args) != 1:
            parser.print_help()
            sys.exit(1)
        else:
            options.mapproxy_conf = args[0]
    try:
        proxy_configuration = load_configuration(options.mapproxy_conf)
    except IOError, e:
        print >>sys.stderr, 'ERROR: ', "%s: '%s'" % (e.strerror, e.filename)
        sys.exit(2)
    except ConfigurationError, e:
        print >>sys.stderr, e
        print >>sys.stderr, 'ERROR: invalid configuration (see above)'
        sys.exit(2)

    if options.show_all or options.grid_name:
        grids = proxy_configuration.grids
    else:
        caches = proxy_configuration.caches
        grids = {}
        for cache in caches.values():
            grids.update(cache.grid_confs())
        grids = dict(grids)

    if options.grid_name:
        options.grid_name = options.grid_name.lower()
        # ignore case for keys
        grids = dict((key.lower(), value) for (key, value) in grids.iteritems())
        if not grids.get(options.grid_name, False):
            print 'grid not found: %s' % (options.grid_name,)
            sys.exit(1)

    coverage = None
    if options.coverage and options.seed_config:
        with local_base_config(proxy_configuration.base_config):
            try:
                seed_conf = load_seed_tasks_conf(options.seed_config, proxy_configuration)
            except SeedConfigurationError, e:
                print >>sys.stderr, 'ERROR: invalid configuration (see above)'
                sys.exit(2)

            if not isinstance(seed_conf, SeedingConfiguration):
                print 'Old seed configuration format not supported'
                sys.exit(1)

            coverage = seed_conf.coverage(options.coverage)
            coverage.name = options.coverage

    elif (options.coverage and not options.seed_config) or (not options.coverage and options.seed_config):
        print '--coverage and --seed-conf can only be used together'
        sys.exit(1)

    if options.list_grids:
        display_grids_list(grids)
    elif options.grid_name:
        display_grids({options.grid_name: grids[options.grid_name]}, coverage=coverage)
    else:
        display_grids(grids, coverage=coverage)




########NEW FILE########
__FILENAME__ = scales
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import division, with_statement
import sys
import optparse
import itertools

DEFAULT_DPIS = {
    'OGC': 2.54/(0.00028 * 100),
}

def values_from_stdin():
    values = []
    for line in sys.stdin:
        line = line.split('#', 1)[0]
        if not line.strip():
            break
        values.append(float(line))
    return values

def scale_to_res(scale_denom, dpi, unit_factor):
    m_per_px = 2.54 / (dpi * 100)
    return scale_denom * m_per_px / unit_factor

def res_to_scale(res, dpi, unit_factor):
    m_per_px = 2.54 / (dpi * 100)
    return res / m_per_px * unit_factor

def format_simple(i, scale, res):
    return '%20.10f # %2d %20.8f' % (res, i, scale)

def format_list(i, scale, res):
    return '    %20.10f, # %2d %20.8f' % (res, i, scale)

def repeated_values(values, n):
    current_factor = 1
    step_factor = 10
    result = []
    for i, value in enumerate(itertools.islice(itertools.cycle(values), n)):
        if i != 0 and i % len(values) == 0:
            current_factor *= step_factor
        result.append(value/current_factor)
    return result

def fill_values(values, n):
    return values + [values[-1]/(2**x) for x in range(1, n)]


def scales_command(args=None):
    parser = optparse.OptionParser("%prog scales [options] scale/resolution[, ...]")
    parser.add_option("-l", "--levels", default=1, type=int, metavar='1',
        help="number of resolutions/scales to calculate")
    parser.add_option("-d", "--dpi", default='OGC',
        help="DPI to convert scales (use OGC for .28mm based DPI)")
    parser.add_option("--unit", default='m', metavar='m',
        help="use resolutions in meter (m) or degrees (d)")
    parser.add_option("--eval", default=False, action='store_true',
        help="evaluate args as Python expression. For example: 360/256")
    parser.add_option("--repeat", default=False, action='store_true',
        help="repeat all values, each time /10. For example: 1000 500 250 results in 1000 500 250 100 50 25 10...")
    parser.add_option("--res-to-scale", default=False, action='store_true',
        help="convert resolutions to scale")
    parser.add_option("--as-res-config", default=False, action='store_true',
        help="output as resolution list for MapProxy grid configuration")

    if args:
        args = args[1:] # remove script name
    (options, args) = parser.parse_args(args)
    options.levels = max(options.levels, len(args))

    dpi = float(DEFAULT_DPIS.get(options.dpi, options.dpi))

    if not args:
        parser.print_help()
        sys.exit(1)

    if args[0] == '-':
        values = values_from_stdin()
    elif options.eval:
        values = map(eval, args)
    else:
        values = map(float, args)

    values.sort(reverse=True)

    if options.repeat:
        values = repeated_values(values, options.levels)

    if len(values) < options.levels:
        values = fill_values(values, options.levels)

    unit_factor = 1
    if options.unit == 'd':
        # calculated from well-known scale set GoogleCRS84Quad
        unit_factor = 111319.4907932736

    calc = scale_to_res
    if options.res_to_scale:
        calc = res_to_scale

    if options.as_res_config:
        print '    res: ['
        print '         #  res            level     scale @%.1f DPI' % dpi
        format = format_list
    else:
        format = format_simple

    for i, value in enumerate(values):
        print format(i, value, calc(value, dpi, unit_factor))

    if options.as_res_config:
        print '    ]'

########NEW FILE########
__FILENAME__ = util
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os
import optparse
import re
import shutil
import sys
import textwrap
import logging

from mapproxy.version import version
from mapproxy.script.scales import scales_command
from mapproxy.script.wms_capabilities import wms_capabilities_command
from mapproxy.script.grids import grids_command
from mapproxy.script.export import export_command
from mapproxy.script.conf.app import config_command



def setup_logging(level=logging.INFO):
    mapproxy_log = logging.getLogger('mapproxy')
    mapproxy_log.setLevel(level)

    ch = logging.StreamHandler(sys.stdout)
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter(
        "[%(asctime)s] %(name)s - %(levelname)s - %(message)s")
    ch.setFormatter(formatter)
    mapproxy_log.addHandler(ch)

def serve_develop_command(args):
    parser = optparse.OptionParser("usage: %prog serve-develop [options] mapproxy.yaml")
    parser.add_option("-b", "--bind",
                      dest="address", default='127.0.0.1:8080',
                      help="Server socket [127.0.0.1:8080]")
    parser.add_option("--debug", default=False, action='store_true',
                      dest="debug",
                      help="Enable debug mode")
    options, args = parser.parse_args(args)

    if len(args) != 2:
        parser.print_help()
        print "\nERROR: MapProxy configuration required."
        sys.exit(1)

    mapproxy_conf = args[1]

    host, port = parse_bind_address(options.address)

    if options.debug and host not in ('localhost', '127.0.0.1'):
        print textwrap.dedent("""\
        ################# WARNING! ##################
        Running debug mode with non-localhost address
        is a serious security vulnerability.
        #############################################\
        """)


    if options.debug:
        setup_logging(level=logging.DEBUG)
    else:
        setup_logging()
    from mapproxy.wsgiapp import make_wsgi_app
    from mapproxy.config.loader import ConfigurationError
    from mapproxy.util.ext.serving import run_simple
    try:
        app = make_wsgi_app(mapproxy_conf, debug=options.debug)
    except ConfigurationError:
        sys.exit(2)

    run_simple(host, port, app, use_reloader=True, processes=1,
        threaded=True, passthrough_errors=True,
        extra_files=app.config_files.keys())

def serve_multiapp_develop_command(args):
    parser = optparse.OptionParser("usage: %prog serve-multiapp-develop [options] projects/")
    parser.add_option("-b", "--bind",
                      dest="address", default='127.0.0.1:8080',
                      help="Server socket [127.0.0.1:8080]")
    parser.add_option("--debug", default=False, action='store_true',
                      dest="debug",
                      help="Enable debug mode")
    options, args = parser.parse_args(args)

    if len(args) != 2:
        parser.print_help()
        print "\nERROR: MapProxy projects directory required."
        sys.exit(1)

    mapproxy_conf_dir = args[1]

    host, port = parse_bind_address(options.address)

    if options.debug and host not in ('localhost', '127.0.0.1'):
        print textwrap.dedent("""\
        ################# WARNING! ##################
        Running debug mode with non-localhost address
        is a serious security vulnerability.
        #############################################\
        """)

    setup_logging()
    from mapproxy.multiapp import make_wsgi_app
    from mapproxy.util.ext.serving import run_simple
    app = make_wsgi_app(mapproxy_conf_dir, debug=options.debug)

    run_simple(host, port, app, use_reloader=True, processes=1,
        threaded=True, passthrough_errors=True)


def parse_bind_address(address, default=('localhost', 8080)):
    """
    >>> parse_bind_address('80')
    ('localhost', 80)
    >>> parse_bind_address('0.0.0.0')
    ('0.0.0.0', 8080)
    >>> parse_bind_address('0.0.0.0:8081')
    ('0.0.0.0', 8081)
    """
    if ':' in address:
        host, port = address.split(':', 1)
        port = int(port)
    elif re.match('^\d+$', address):
        host = default[0]
        port = int(address)
    else:
        host = address
        port = default[1]
    return host, port


def create_command(args):
    cmd = CreateCommand(args)
    cmd.run()

class CreateCommand(object):
    templates = {
        'base-config': {},
        'wsgi-app': {},
        'log-ini': {},
    }

    def __init__(self, args):
        parser = optparse.OptionParser("usage: %prog create [options] [destination]")
        parser.add_option("-t", "--template", dest="template",
            help="Create a configuration from this template.")
        parser.add_option("-l", "--list-templates", dest="list_templates",
            action="store_true", default=False,
            help="List all available configuration templates.")
        parser.add_option("-f", "--mapproxy-conf", dest="mapproxy_conf",
            help="Existing MapProxy configuration (required for some templates).")
        parser.add_option("--force", dest="force", action="store_true",
            default=False, help="Force operation (e.g. overwrite existing files).")

        self.options, self.args = parser.parse_args(args)
        self.parser = parser

    def log_error(self, msg, *args):
        print >>sys.stderr, 'ERROR:', msg % args

    def run(self):

        if self.options.list_templates:
            print_items(self.templates, title="Available templates")
            sys.exit(1)
        elif self.options.template:
            if self.options.template not in self.templates:
                self.log_error("unknown template " + self.options.template)
                sys.exit(1)

            if len(self.args) != 2:
                self.log_error("template requires destination argument")
                sys.exit(1)

            sys.exit(
                getattr(self, 'template_' + self.options.template.replace('-', '_'))()
            )
        else:
            self.parser.print_help()
            sys.exit(1)

    @property
    def mapproxy_conf(self):
        if not self.options.mapproxy_conf:
            self.parser.print_help()
            self.log_error("template requires --mapproxy-conf option")
            sys.exit(1)
        return os.path.abspath(self.options.mapproxy_conf)

    def template_dir(self):
        import mapproxy.config_template
        template_dir = os.path.join(
            os.path.dirname(mapproxy.config_template.__file__),
            'base_config')
        return template_dir

    def template_wsgi_app(self):
        app_filename = self.args[1]
        if '.' not in os.path.basename(app_filename):
            app_filename += '.py'
        mapproxy_conf = self.mapproxy_conf
        if os.path.exists(app_filename) and not self.options.force:
            self.log_error("%s already exists, use --force", app_filename)
            return 1

        print "writing MapProxy app to %s" % (app_filename, )

        template_dir = self.template_dir()
        app_template = open(os.path.join(template_dir, 'config.wsgi')).read()
        with open(app_filename, 'w') as f:
            f.write(app_template % {'mapproxy_conf': mapproxy_conf,
                'here': os.path.dirname(mapproxy_conf)})

        return 0

    def template_base_config(self):
        outdir = self.args[1]
        if not os.path.exists(outdir):
            os.makedirs(outdir)

        template_dir = self.template_dir()

        for filename in ('mapproxy.yaml', 'seed.yaml',
            'full_example.yaml', 'full_seed_example.yaml'):
            to = os.path.join(outdir, filename)
            from_ = os.path.join(template_dir, filename)
            if os.path.exists(to) and not self.options.force:
                self.log_error("%s already exists, use --force", to)
                return 1
            print "writing %s" % (to, )
            shutil.copy(from_, to)

        return 0

    def template_log_ini(self):
        log_filename = self.args[1]

        if os.path.exists(log_filename) and not self.options.force:
            self.log_error("%s already exists, use --force", log_filename)
            return 1

        template_dir = self.template_dir()
        log_template = open(os.path.join(template_dir, 'log.ini')).read()
        with open(log_filename, 'w') as f:
            f.write(log_template)

        return 0

commands = {
    'serve-develop': {
        'func': serve_develop_command,
        'help': 'Run MapProxy development server.'
    },
    'serve-multiapp-develop': {
        'func': serve_multiapp_develop_command,
        'help': 'Run MultiMapProxy development server.'
    },
    'create': {
        'func': create_command,
        'help': 'Create example configurations.'
    },
    'scales': {
        'func': scales_command,
        'help': 'Convert between scales and resolutions.'
    },
    'wms-capabilities': {
        'func': wms_capabilities_command,
        'help': 'Display WMS capabilites.',
    },
    'grids': {
        'func': grids_command,
        'help': 'Display detailed informations for configured grids.'
    },
    'export': {
        'func': export_command,
        'help': 'Export existing caches.'
    },
    'autoconfig': {
        'func': config_command,
        'help': 'Create config from WMS capabilities.'
    }
}


class NonStrictOptionParser(optparse.OptionParser):
    def _process_args(self, largs, rargs, values):
        while rargs:
            arg = rargs[0]
            # We handle bare "--" explicitly, and bare "-" is handled by the
            # standard arg handler since the short arg case ensures that the
            # len of the opt string is greater than 1.
            try:
                if arg == "--":
                    del rargs[0]
                    return
                elif arg[0:2] == "--":
                    # process a single long option (possibly with value(s))
                    self._process_long_opt(rargs, values)
                elif arg[:1] == "-" and len(arg) > 1:
                    # process a cluster of short options (possibly with
                    # value(s) for the last one only)
                    self._process_short_opts(rargs, values)
                elif self.allow_interspersed_args:
                    largs.append(arg)
                    del rargs[0]
                else:
                    return
            except optparse.BadOptionError:
                largs.append(arg)


def print_items(data, title='Commands'):
    name_len = max(len(name) for name in data)

    if title:
        print >>sys.stdout, '%s:' % (title, )
    for name, item in data.iteritems():
        help = item.get('help', '')
        name = ('%%-%ds' % name_len) % name
        if help:
            help = '  ' + help
        print >>sys.stdout, '  %s%s' % (name, help)

def main():
    parser = NonStrictOptionParser("usage: %prog COMMAND [options]",
        add_help_option=False)
    options, args = parser.parse_args()

    if len(args) < 1 or args[0] in ('--help', '-h'):
        parser.print_help()
        print
        print_items(commands)
        sys.exit(1)

    if len(args) == 1 and args[0] == '--version':
        print 'MapProxy ' + version
        sys.exit(1)

    command = args[0]
    if command not in commands:
        parser.print_help()
        print
        print_items(commands)
        print >>sys.stdout, '\nERROR: unknown command %s' % (command,)
        sys.exit(1)

    args = sys.argv[0:1] + sys.argv[2:]
    commands[command]['func'](args)

if __name__ == '__main__':
    main()
########NEW FILE########
__FILENAME__ = wms_capabilities
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from __future__ import with_statement

import urlparse
import sys
import optparse
from cStringIO import StringIO
from xml.etree import ElementTree as etree
from xml.etree.ElementTree import XMLParser

from mapproxy.client.http import open_url, HTTPClientError
from mapproxy.request.base import BaseRequest, url_decode
from mapproxy.util.ext import wmsparse

ENCODING = sys.getdefaultencoding()
if ENCODING in (None, 'ascii'):
    ENCODING = 'UTF-8'

class PrettyPrinter(object):
    def __init__(self, indent=4, version='1.1.1'):
        self.indent = indent
        self.print_order = ['name', 'title', 'url', 'srs', 'llbbox', 'bbox']
        self.marker = '- '
        self.version = version

    def print_line(self, indent, key, value=None, mark_first=False):
        marker = ''
        if value is None:
            value = ''
        if mark_first:
            indent = indent - len(self.marker)
            marker = self.marker
        print ("%s%s%s: %s" % (' '*indent, marker, key, value)).encode(ENCODING)

    def _format_output(self, key, value, indent, mark_first=False):
        if key == 'bbox':
            self.print_line(indent, key)
            for srs_code, bbox in value.iteritems():
                self.print_line(indent+self.indent, srs_code, value=bbox, mark_first=mark_first)
        else:
            if isinstance(value, set):
                value = list(value)
            self.print_line(indent, key, value=value, mark_first=mark_first)

    def print_layers(self, capabilities, indent=None, root=False):
        if root:
            print "# Note: This is not a valid MapProxy configuration!"
            print 'Capabilities Document Version %s' % (self.version,)
            print 'Root-Layer:'
            layer_list = capabilities.layers()['layers']
        else:
            layer_list = capabilities['layers']

        indent = indent or self.indent
        for layer in layer_list:
            marked_first = False
            # print ordered items first
            for item in self.print_order:
                if layer.get(item, False):
                    if not marked_first:
                        marked_first = True
                        self._format_output(item, layer[item], indent, mark_first=marked_first)
                    else:
                        self._format_output(item, layer[item], indent)
            # print remaining items except sublayers
            for key, value in layer.iteritems():
                if key in self.print_order or key == 'layers':
                    continue
                self._format_output(key, value, indent)
            # print the sublayers now
            if layer.get('layers', False):
                self.print_line(indent, 'layers')
                self.print_layers(layer, indent=indent+self.indent)

def log_error(msg, *args):
    print >>sys.stderr, (msg % args).encode(ENCODING)

def wms_capapilities_url(url, version):
    parsed_url = urlparse.urlparse(url)
    base_req = BaseRequest(
        url=url.split('?', 1)[0],
        param=url_decode(parsed_url.query),
    )

    base_req.params['service'] = 'WMS'
    base_req.params['version'] = version
    base_req.params['request'] = 'GetCapabilities'
    return base_req.complete_url

def parse_capabilities(fileobj, version='1.1.1'):
    try:
        return wmsparse.parse_capabilities(fileobj)
    except ValueError, ex:
        log_error('%s\n%s\n%s\n%s\nNot a capabilities document: %s', 'Recieved document:', '-'*80, fileobj.getvalue(), '-'*80, ex.args[0])
        sys.exit(1)
    except Exception, ex:
        # catch all, etree.ParseError only avail since Python 2.7
        # 2.5 and 2.6 raises exc from underlying implementation like expat
        log_error('%s\n%s\n%s\n%s\nCould not parse the document: %s', 'Recieved document:', '-'*80, fileobj.getvalue(), '-'*80, ex.args[0])
        sys.exit(1)

def parse_capabilities_url(url, version='1.1.1'):
    try:
        capabilities_url = wms_capapilities_url(url, version)
        capabilities_response = open_url(capabilities_url)
    except HTTPClientError, ex:
        log_error('ERROR: %s', ex.args[0])
        sys.exit(1)

    # after parsing capabilities_response will be empty, therefore cache it
    capabilities = StringIO(capabilities_response.read())
    return parse_capabilities(capabilities, version=version)

def wms_capabilities_command(args=None):
    parser = optparse.OptionParser("%prog wms-capabilities [options] URL",
        description="Read and parse WMS 1.1.1 capabilities and print out"
        " information about each layer. It does _not_ return a valid"
        " MapProxy configuration.")
    parser.add_option("--host", dest="capabilities_url",
        help="WMS Capabilites URL")
    parser.add_option("--version", dest="version",
        choices=['1.1.1', '1.3.0'], default='1.1.1', help="Request GetCapabilities-document in version 1.1.1 or 1.3.0", metavar="<1.1.1 or 1.3.0>")

    if args:
        args = args[1:] # remove script name

    (options, args) = parser.parse_args(args)
    if not options.capabilities_url:
        if len(args) != 1:
            parser.print_help()
            sys.exit(2)
        else:
            options.capabilities_url = args[0]

    try:
        service = parse_capabilities_url(options.capabilities_url, version=options.version)

        printer = PrettyPrinter(indent=4, version=options.version)
        printer.print_layers(service, root=True)

    except KeyError, ex:
        log_error('XML-Element has no such attribute (%s).' % (ex.args[0],))
        sys.exit(1)

########NEW FILE########
__FILENAME__ = referrer
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re
from urlparse import urlparse
from mapproxy.response import Response


class _None(object):
    """
    Accept empty referrers.
    """
    def __call__(self, referrer, _environ):
        return referrer is None

NONE = _None()

class _Blocked(object):
    """
    Accept referrers that were blocked by proxies (XXX, xxx or *****, etc.)
    """
    blocked = re.compile('^[xX*]+$')
    def __call__(self, referrer, _environ):
        if referrer is None:
            return False
        return self.blocked.match(referrer)

BLOCKED = _Blocked()

class _Self(object):
    """
    Accept referrers that are part of the request url.
    http://localhost/foo/ for http://localhost/foo/bar.png
    """
    def __call__(self, referrer, environ):
        if referrer is None:
            return False
        scheme, netloc, path, _params, _query, _fragment = urlparse(referrer)
        if scheme != environ['wsgi.url_scheme']: return False
        if netloc != environ['HTTP_HOST']:
            if _split_netloc(netloc, scheme) != _split_netloc(environ['HTTP_HOST'], scheme):
                return False
        return True

SELF = _Self()

def _split_netloc(netloc, scheme):
    if ':' in netloc:
        return tuple(netloc.split(':'))
    else:
        return netloc, {'http': '80', 'https': '443'}.get(scheme, None)


class _Regex(object):
    def __init__(self, regex):
        self.regex_str = regex
        self.regex = re.compile(regex)
    def __call__(self, referrer, _environ):
        if referrer is None:
            return False
        return self.regex.match(referrer)
    def __repr__(self):
        return 'REGEX(%s)' % self.regex_str

REGEX = _Regex

class ReferrerFilter(object):
    def __init__(self, app, referrers=None):
        self.app = app
        if referrers is None:
            referrers = []
        self.referrers = referrers
    
    def check_referrer(self, environ):
        referrer = environ.get('HTTP_REFERER', None)
        for test in self.referrers:
            if isinstance(test, basestring):
                if referrer.startswith(test):
                    return True
            elif callable(test):
                if test(referrer, environ):
                    return True
        return False
    
    def restricted_response(self, environ, start_response):
        resp = Response('get out of here', status=404)
        return resp(environ, start_response)
    
    def __call__(self, environ, start_response):
        if not self.referrers or self.check_referrer(environ):
            return self.app(environ, start_response)
        else:
            return self.restricted_response(environ, start_response)
            
########NEW FILE########
__FILENAME__ = cachelock
# This file is part of the MapProxy project.
# Copyright (C) 2012 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

import errno
import os
import sqlite3
import sys
import time
from contextlib import contextmanager

class CacheLockedError(Exception):
    pass

class CacheLocker(object):
    def __init__(self, lockfile, polltime=0.1):
        self.lockfile = lockfile
        self.polltime = polltime
        self._initialize_lockfile()
    
    def _initialize_lockfile(self):
        db  = sqlite3.connect(self.lockfile)
        db.execute("""
            CREATE TABLE IF NOT EXISTS cache_locks (
                cache_name TEXT NOT NULL,
                created REAL NOT NULL,
                pid INTEGER NUT NULL
            );
        """)
        db.commit()
        db.close()

    @contextmanager
    def _exclusive_db_cursor(self):
        db  = sqlite3.connect(self.lockfile, isolation_level="EXCLUSIVE")
        db.row_factory = sqlite3.Row
        cur = db.cursor()
        
        try:
            yield cur
        finally:
            db.commit()
            db.close()
    
    @contextmanager
    def lock(self, cache_name, no_block=False):
        
        pid = os.getpid()
        
        while True:
            with self._exclusive_db_cursor() as cur:
                self._add_lock(cur, cache_name, pid)
                if self._poll(cur, cache_name, pid):
                    break
                elif no_block:
                    raise CacheLockedError()
            time.sleep(self.polltime)

        try:
            yield
        finally:
            with self._exclusive_db_cursor() as cur:
                self._remove_lock(cur, cache_name, pid)
    
    def _poll(self, cur, cache_name, pid):
        active_locks = False
        cur.execute("SELECT * from cache_locks where cache_name = ? ORDER BY created", (cache_name, ))

        for lock in cur:
            if not active_locks and lock['cache_name'] == cache_name and lock['pid'] == pid:
                # we are waiting and it is out turn
                return True
        
            if not is_running(lock['pid']):
                self._remove_lock(cur, lock['cache_name'], lock['pid'])
            else:
                active_locks = True
        
        return not active_locks
    
    def _add_lock(self, cur, cache_name, pid):
        cur.execute("SELECT count(*) from cache_locks WHERE cache_name = ? AND pid = ?", (cache_name, pid))
        if cur.fetchone()[0] == 0:
            cur.execute("INSERT INTO cache_locks (cache_name, pid, created) VALUES (?, ?, ?)", (cache_name, pid, time.time()))
    
    def _remove_lock(self, cur, cache_name, pid):
        cur.execute("DELETE FROM cache_locks WHERE cache_name = ?  AND pid = ?", (cache_name, pid))

class DummyCacheLocker(object):
    @contextmanager
    def lock(self, cache_name, no_block=False):
        yield

def is_running(pid):
    try:
        os.kill(pid, 0)
    except OSError, err:
        if err.errno == errno.ESRCH:
            return False
        elif err.errno == errno.EPERM:
            return True
        else:
            raise err
    else:
        return True

if __name__ == '__main__':
    locker = CacheLocker('/tmp/cachelock_test')
    with locker.lock('foo'):
        pass
########NEW FILE########
__FILENAME__ = cleanup
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
from mapproxy.seed.util import format_cleanup_task
from mapproxy.util.fs import cleanup_directory
from mapproxy.seed.seeder import TileWorkerPool, TileWalker, TileCleanupWorker

def cleanup(tasks, concurrency=2, dry_run=False, skip_geoms_for_last_levels=0,
               verbose=True, progress_logger=None):
    for task in tasks:
        print format_cleanup_task(task)

        if task.complete_extent:
            if hasattr(task.tile_manager.cache, 'level_location'):
                simple_cleanup(task, dry_run=dry_run, progress_logger=progress_logger)
                continue
            elif hasattr(task.tile_manager.cache, 'remove_level_tiles_before'):
                cache_cleanup(task, dry_run=dry_run, progress_logger=progress_logger)
                continue

        tilewalker_cleanup(task, dry_run=dry_run, concurrency=concurrency,
                         skip_geoms_for_last_levels=skip_geoms_for_last_levels,
                         progress_logger=progress_logger)

def simple_cleanup(task, dry_run, progress_logger=None):
    """
    Cleanup cache level on file system level.
    """
    for level in task.levels:
        level_dir = task.tile_manager.cache.level_location(level)
        if dry_run:
            def file_handler(filename):
                print 'removing ' + filename
        else:
            file_handler = None
        if progress_logger:
            progress_logger.log_message('removing old tiles in ' + normpath(level_dir))
        cleanup_directory(level_dir, task.remove_timestamp,
            file_handler=file_handler, remove_empty_dirs=True)

def cache_cleanup(task, dry_run, progress_logger=None):
    for level in task.levels:
        if progress_logger:
            progress_logger.log_message('removing old tiles for level %s' % level)
        if not dry_run:
            task.tile_manager.cache.remove_level_tiles_before(level, task.remove_timestamp)
            task.tile_manager.cleanup()

def normpath(path):
    # relpath doesn't support UNC
    if path.startswith('\\'):
        return path

    # only supported with >= Python 2.6
    if hasattr(os.path, 'relpath'):
        path = os.path.relpath(path)

    if path.startswith('../../'):
        path = os.path.abspath(path)
    return path

def tilewalker_cleanup(task, dry_run, concurrency, skip_geoms_for_last_levels,
    progress_logger=None):
    """
    Cleanup tiles with tile traversal.
    """
    task.tile_manager._expire_timestamp = task.remove_timestamp
    task.tile_manager.minimize_meta_requests = False
    tile_worker_pool = TileWorkerPool(task, TileCleanupWorker, progress_logger=progress_logger,
                                      dry_run=dry_run, size=concurrency)
    tile_walker = TileWalker(task, tile_worker_pool, handle_stale=True,
                             work_on_metatiles=False, progress_logger=progress_logger,
                             skip_geoms_for_last_levels=skip_geoms_for_last_levels)
    tile_walker.walk()
    tile_worker_pool.stop()

########NEW FILE########
__FILENAME__ = config
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

import os
import sys
import time
import operator

from mapproxy.config import abspath
from mapproxy.config.loader import ConfigurationError
from mapproxy.config.coverage import load_coverage
from mapproxy.srs import SRS
from mapproxy.util.py import memoize
from mapproxy.util.times import timestamp_from_isodate, timestamp_before
from mapproxy.util.coverage import MultiCoverage, BBOXCoverage, GeomCoverage
from mapproxy.util.yaml import load_yaml_file, YAMLError
from mapproxy.seed.util import bidict
from mapproxy.seed.seeder import SeedTask, CleanupTask
from mapproxy.seed.spec import validate_seed_conf


class SeedConfigurationError(ConfigurationError):
    pass


import logging
log = logging.getLogger('mapproxy.seed.config')

def load_seed_tasks_conf(seed_conf_filename, mapproxy_conf):
    try:
        conf = load_yaml_file(seed_conf_filename)
    except YAMLError, ex:
        raise SeedConfigurationError(ex)

    if 'views' in conf:
        # TODO: deprecate old config
        seed_conf = LegacySeedingConfiguration(conf, mapproxy_conf=mapproxy_conf)
    else:
        errors, informal_only = validate_seed_conf(conf)
        for error in errors:
            log.warn(error)
        if not informal_only:
            raise SeedConfigurationError('invalid configuration')
        seed_conf = SeedingConfiguration(conf, mapproxy_conf=mapproxy_conf)
    return seed_conf

class LegacySeedingConfiguration(object):
    """
    Read old seed.yaml configuration (with seed and views).
    """
    def __init__(self, seed_conf, mapproxy_conf):
        self.conf = seed_conf
        self.mapproxy_conf = mapproxy_conf
        self.grids = bidict((name, grid_conf.tile_grid()) for name, grid_conf in self.mapproxy_conf.grids.iteritems())
        self.seed_tasks = []
        self.cleanup_tasks = []
        self._init_tasks()

    def _init_tasks(self):
        for cache_name, options in self.conf['seeds'].iteritems():
            remove_before = None
            if 'remove_before' in options:
                remove_before = before_timestamp_from_options(options['remove_before'])
            try:
                caches = self.mapproxy_conf.caches[cache_name].caches()
            except KeyError:
                print >>sys.stderr, 'error: cache %s not found. available caches: %s' % (
                    cache_name, ','.join(self.mapproxy_conf.caches.keys()))
                return
            caches = dict((grid, tile_mgr) for grid, extent, tile_mgr in caches)
            for view in options['views']:
                view_conf = self.conf['views'][view]
                coverage = load_coverage(view_conf)

                cache_srs = view_conf.get('srs', None)
                if cache_srs is not None:
                    cache_srs = [SRS(s) for s in cache_srs]

                level = view_conf.get('level', None)
                assert len(level) == 2

                for grid, tile_mgr in caches.iteritems():
                    if cache_srs and grid.srs not in cache_srs: continue
                    md = dict(name=view, cache_name=cache_name, grid_name=self.grids[grid])
                    levels = range(level[0], level[1]+1)
                    if coverage:
                        if isinstance(coverage, GeomCoverage) and coverage.geom.is_empty:
                            continue
                        seed_coverage = coverage.transform_to(grid.srs)
                    else:
                        seed_coverage = BBOXCoverage(grid.bbox, grid.srs)

                    self.seed_tasks.append(SeedTask(md, tile_mgr, levels, remove_before, seed_coverage))

                    if remove_before:
                        levels = range(grid.levels)
                        complete_extent = bool(coverage)
                        self.cleanup_tasks.append(CleanupTask(md, tile_mgr, levels, remove_before,
                            seed_coverage, complete_extent=complete_extent))

    def seed_tasks_names(self):
        return self.conf['seeds'].keys()

    def cleanup_tasks_names(self):
        return self.conf['seeds'].keys()

    def seeds(self, names=None):
        if names is None:
            return self.seed_tasks
        else:
            return [t for t in self.seed_tasks if t.md['name'] in names]

    def cleanups(self, names=None):
        if names is None:
            return self.cleanup_tasks
        else:
            return [t for t in self.cleanup_tasks if t.md['name'] in names]

class SeedingConfiguration(object):
    def __init__(self, seed_conf, mapproxy_conf):
        self.conf = seed_conf
        self.mapproxy_conf = mapproxy_conf
        self.grids = bidict((name, grid_conf.tile_grid()) for name, grid_conf in self.mapproxy_conf.grids.iteritems())

    @memoize
    def coverage(self, name):
        coverage_conf = (self.conf.get('coverages') or {}).get(name)
        if coverage_conf is None:
            raise SeedConfigurationError('coverage %s not found. available coverages: %s' % (
                name, ','.join((self.conf.get('coverages') or {}).keys())))

        return load_coverage(coverage_conf)

    def cache(self, cache_name):
        cache = {}
        if cache_name not in self.mapproxy_conf.caches:
            raise SeedConfigurationError('cache %s not found. available caches: %s' % (
                cache_name, ','.join(self.mapproxy_conf.caches.keys())))
        for tile_grid, extent, tile_mgr in self.mapproxy_conf.caches[cache_name].caches():
            grid_name = self.grids[tile_grid]
            cache[grid_name] = tile_mgr
        return cache

    def seed_tasks_names(self):
        seeds = self.conf.get('seeds', {})
        if seeds:
            return seeds.keys()
        return []

    def cleanup_tasks_names(self):
        cleanups = self.conf.get('cleanups', {})
        if cleanups:
            return cleanups.keys()
        return []

    def seeds(self, names=None):
        """
        Return seed tasks.
        """
        tasks = []
        if names is None:
            names = self.conf.get('seeds', {}).keys()

        for seed_name in names:
            seed_conf = self.conf['seeds'][seed_name]
            seed_conf = SeedConfiguration(seed_name, seed_conf, self)
            for task in seed_conf.seed_tasks():
                tasks.append(task)
        return tasks

    def cleanups(self, names=None):
        """
        Return cleanup tasks.
        """
        tasks = []
        if names is None:
            names = self.conf.get('cleanups', {}).keys()

        for cleanup_name in names:
            cleanup_conf = self.conf['cleanups'][cleanup_name]
            cleanup_conf = CleanupConfiguration(cleanup_name, cleanup_conf, self)
            for task in cleanup_conf.cleanup_tasks():
                tasks.append(task)
        return tasks


class ConfigurationBase(object):
    def __init__(self, name, conf, seeding_conf):
        self.name = name
        self.conf = conf
        self.seeding_conf = seeding_conf

        self.coverage = self._coverages()
        self.caches = self._caches()
        self.grids = self._grids(self.caches)
        self.levels = levels_from_options(conf)

    def _coverages(self):
        coverage = None
        if 'coverages' in self.conf:
            coverages = [self.seeding_conf.coverage(c) for c in self.conf.get('coverages', {})]
            if len(coverages) == 1:
                coverage = coverages[0]
            else:
                coverage = MultiCoverage(coverages)
        return coverage

    def _grids(self, caches):
        grids = []

        if 'grids' in self.conf:
            # grids available for all caches
            available_grids = reduce(operator.and_, (set(cache) for cache in caches.values()))
            for grid_name in self.conf['grids']:
                if grid_name not in available_grids:
                    raise SeedConfigurationError('%s not defined for caches' % grid_name)
                grids.append(grid_name)
        else:
            # check that all caches have the same grids configured
            last = []
            for cache_grids in (set(cache.iterkeys()) for cache in caches.itervalues()):
                if not last:
                    last = cache_grids
                else:
                    if last != cache_grids:
                        raise SeedConfigurationError('caches in same seed task require identical grids')
            grids = list(last or [])
        return grids

    def _caches(self):
        """
        Returns a dictionary with all caches for this seed.

        e.g.: {'seed1': {'grid1': tilemanager1, 'grid2': tilemanager2}}
        """
        caches = {}
        for cache_name in self.conf.get('caches', []):
            caches[cache_name] = self.seeding_conf.cache(cache_name)
        return caches


class SeedConfiguration(ConfigurationBase):
    def __init__(self, name, conf, seeding_conf):
        ConfigurationBase.__init__(self, name, conf, seeding_conf)

        self.refresh_timestamp = None
        if 'refresh_before' in self.conf:
            self.refresh_timestamp = before_timestamp_from_options(self.conf['refresh_before'])

    def seed_tasks(self):
        for grid_name in self.grids:
            for cache_name, cache in self.caches.iteritems():
                tile_manager = cache[grid_name]
                grid = self.seeding_conf.grids[grid_name]
                if self.coverage:
                    if isinstance(self.coverage, GeomCoverage) and self.coverage.geom.is_empty:
                        continue
                    coverage = self.coverage.transform_to(grid.srs)
                else:
                    coverage = BBOXCoverage(grid.bbox, grid.srs)
                if self.levels:
                    levels = self.levels.for_grid(grid)
                else:
                    levels = list(xrange(0, grid.levels))

                if not tile_manager.cache.supports_timestamp:
                    if self.refresh_timestamp:
                        # remove everything
                        self.refresh_timestamp = 0

                md = dict(name=self.name, cache_name=cache_name, grid_name=grid_name)
                yield SeedTask(md, tile_manager, levels, self.refresh_timestamp, coverage)

class CleanupConfiguration(ConfigurationBase):
    def __init__(self, name, conf, seeding_conf):
        ConfigurationBase.__init__(self, name, conf, seeding_conf)
        self.init_time = time.time()

        if self.conf.get('remove_all') == True:
            self.remove_timestamp = 0
        elif 'remove_before' in self.conf:
            self.remove_timestamp = before_timestamp_from_options(self.conf['remove_before'])
        else:
            # use now as remove_before date. this should not remove
            # fresh seeded tiles, since this should be configured before seeding
            self.remove_timestamp = self.init_time

    def cleanup_tasks(self):
        for grid_name in self.grids:
            for cache_name, cache in self.caches.iteritems():
                tile_manager = cache[grid_name]
                grid = self.seeding_conf.grids[grid_name]
                if self.coverage:
                    coverage = self.coverage.transform_to(grid.srs)
                    complete_extent = False
                else:
                    coverage = BBOXCoverage(grid.bbox, grid.srs)
                    complete_extent = True
                if self.levels:
                    levels = self.levels.for_grid(grid)
                else:
                    levels = list(xrange(0, grid.levels))

                if not tile_manager.cache.supports_timestamp:
                    # for caches without timestamp support (like MBTiles)
                    if self.remove_timestamp is self.init_time or self.remove_timestamp == 0:
                        # remove everything
                        self.remove_timestamp = 0
                    else:
                        raise SeedConfigurationError("cleanup does not support remove_before for '%s'"
                            " because cache '%s' does not support timestamps" % (self.name, cache_name))
                md = dict(name=self.name, cache_name=cache_name, grid_name=grid_name)
                yield CleanupTask(md, tile_manager, levels, self.remove_timestamp,
                    coverage=coverage, complete_extent=complete_extent)


def levels_from_options(conf):
    levels = conf.get('levels')
    if levels:
        if isinstance(levels, list):
            return LevelsList(levels)
        from_level = levels.get('from')
        to_level = levels.get('to')
        return LevelsRange((from_level, to_level))
    resolutions = conf.get('resolutions')
    if resolutions:
        if isinstance(resolutions, list):
            return LevelsResolutionList(resolutions)
        from_res = resolutions.get('from')
        to_res = resolutions.get('to')
        return LevelsResolutionRange((from_res, to_res))
    return None

def before_timestamp_from_options(conf):
    """
    >>> import time
    >>> t = before_timestamp_from_options({'hours': 4})
    >>> time.time() - t - 4 * 60 * 60 < 1
    True
    """
    if 'time' in conf:
        try:
            return timestamp_from_isodate(conf['time'])
        except ValueError:
            raise SeedConfigurationError(
                "can't parse time '%s'. should be ISO time string" % (conf["time"], ))
    if 'mtime' in conf:
        datasource = abspath(conf['mtime'])
        try:
            return os.path.getmtime(datasource)
        except OSError, ex:
            raise SeedConfigurationError(
                "can't parse last modified time from file '%s'." % (datasource, ), ex)
    deltas = {}
    for delta_type in ('weeks', 'days', 'hours', 'minutes', 'seconds'):
        deltas[delta_type] = conf.get(delta_type, 0)
    return timestamp_before(**deltas)


class LevelsList(object):
    def __init__(self, levels=None):
        self.levels = levels

    def for_grid(self, grid):
        uniqe_valid_levels = set(l for l in self.levels if 0 <= l <= (grid.levels-1))
        return sorted(uniqe_valid_levels)

class LevelsRange(object):
    def __init__(self, level_range=None):
        self.level_range = level_range

    def for_grid(self, grid):
        start, stop = self.level_range
        if start is None:
            start = 0
        if stop is None:
            stop = 999

        stop = min(stop, grid.levels-1)

        return list(xrange(start, stop+1))

class LevelsResolutionRange(object):
    def __init__(self, res_range=None):
        self.res_range = res_range
    def for_grid(self, grid):
        start, stop = self.res_range
        if start is None:
            start = 0
        else:
            start = grid.closest_level(start)

        if stop is None:
            stop = grid.levels-1
        else:
            stop = grid.closest_level(stop)

        return list(xrange(start, stop+1))

class LevelsResolutionList(object):
    def __init__(self, resolutions=None):
        self.resolutions = resolutions

    def for_grid(self, grid):
        levels = set(grid.closest_level(res) for res in self.resolutions)
        return sorted(levels)


########NEW FILE########
__FILENAME__ = script
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

import sys
import logging
from logging.config import fileConfig

from optparse import OptionParser

from mapproxy.config.loader import load_configuration, ConfigurationError
from mapproxy.seed.config import load_seed_tasks_conf
from mapproxy.seed.seeder import seed
from mapproxy.seed.cleanup import cleanup
from mapproxy.seed.util import (format_seed_task, format_cleanup_task,
    ProgressLog, ProgressStore)
from mapproxy.seed.cachelock import CacheLocker

def setup_logging(logging_conf=None):
    if logging_conf is not None:
        fileConfig(logging_conf, {'here': './'})

    mapproxy_log = logging.getLogger('mapproxy')
    mapproxy_log.setLevel(logging.WARN)

    ch = logging.StreamHandler(sys.stdout)
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter(
        "[%(asctime)s] %(name)s - %(levelname)s - %(message)s")
    ch.setFormatter(formatter)
    mapproxy_log.addHandler(ch)

class SeedScript(object):
    usage = "usage: %prog [options] seed_conf"
    parser = OptionParser(usage)
    parser.add_option("-q", "--quiet",
                      action="count", dest="quiet", default=0,
                      help="don't print status messages to stdout")
    parser.add_option("-s", "--seed-conf",
                      dest="seed_file", default=None,
                      help="seed configuration")
    parser.add_option("-f", "--proxy-conf",
                      dest="conf_file", default=None,
                      help="proxy configuration")
    parser.add_option("-c", "--concurrency", type="int",
                      dest="concurrency", default=2,
                      help="number of parallel seed processes")
    parser.add_option("-n", "--dry-run",
                      action="store_true", dest="dry_run", default=False,
                      help="do not seed, just print output")
    parser.add_option("-l", "--skip-geoms-for-last-levels",
                      type="int", dest="geom_levels", default=0,
                      metavar="N",
                      help="do not check for intersections between tiles"
                           " and seed geometries on the last N levels")
    parser.add_option("--summary",
                      action="store_true", dest="summary", default=False,
                      help="print summary with all seeding tasks and exit."
                           " does not seed anything.")
    parser.add_option("-i", "--interactive",
                      action="store_true", dest="interactive", default=False,
                      help="print each task description and ask if it should be seeded")

    parser.add_option("--seed",
                      action="append", dest="seed_names", metavar='task1,task2,...',
                      help="seed only the named tasks. cleanup is disabled unless "
                      "--cleanup is used. use ALL to select all tasks")

    parser.add_option("--cleanup",
                      action="append", dest="cleanup_names", metavar='task1,task2,...',
                      help="cleanup only the named tasks. seeding is disabled unless "
                      "--seed is used. use ALL to select all tasks")

    parser.add_option("--use-cache-lock",
                      action="store_true", default=False,
                      help="use locking to prevent multiple mapproxy-seed calls "
                      "to seed the same cache")

    parser.add_option("--continue", dest='continue_seed',
                      action="store_true", default=False,
                      help="continue an aborted seed progress")

    parser.add_option("--progress-file", dest='progress_file',
                      default=None,
                      help="filename for storing the seed progress (for --continue option)")

    parser.add_option("--log-config", dest='logging_conf', default=None,
                      help="logging configuration")

    def __call__(self):
        (options, args) = self.parser.parse_args()

        if len(args) != 1 and not options.seed_file:
            self.parser.print_help()
            sys.exit(1)

        if not options.seed_file:
            if len(args) != 1:
                self.parser.error('missing seed_conf file as last argument or --seed-conf option')
            else:
                options.seed_file = args[0]

        if not options.conf_file:
            self.parser.error('missing mapproxy configuration -f/--proxy-conf')

        setup_logging(options.logging_conf)

        try:
            mapproxy_conf = load_configuration(options.conf_file, seed=True)
        except ConfigurationError, ex:
            print "ERROR: " + '\n\t'.join(str(ex).split('\n'))
            sys.exit(2)

        if options.use_cache_lock:
            cache_locker = CacheLocker('.mapproxy_seed.lck')
        else:
            cache_locker = None

        with mapproxy_conf:
            try:
                seed_conf = load_seed_tasks_conf(options.seed_file, mapproxy_conf)
                seed_names, cleanup_names = self.task_names(seed_conf, options)
                seed_tasks = seed_conf.seeds(seed_names)
                cleanup_tasks = seed_conf.cleanups(cleanup_names)
            except ConfigurationError, ex:
                print "error in configuration: " + '\n\t'.join(str(ex).split('\n'))
                sys.exit(2)

            if options.summary:
                print '========== Seeding tasks =========='
                for task in seed_tasks:
                    print format_seed_task(task)
                print '========== Cleanup tasks =========='
                for task in cleanup_tasks:
                    print format_cleanup_task(task)
                return 0

            progress = None
            if options.continue_seed or options.progress_file:
                if options.progress_file:
                    progress_file = options.progress_file
                else:
                    progress_file = '.mapproxy_seed_progress'
                progress = ProgressStore(progress_file,
                    continue_seed=options.continue_seed)

            try:
                if options.interactive:
                    seed_tasks, cleanup_tasks = self.interactive(seed_tasks, cleanup_tasks)

                if seed_tasks:
                    print '========== Seeding tasks =========='
                    print 'Start seeding process (%d task%s)' % (
                        len(seed_tasks), 's' if len(seed_tasks) > 1 else '')
                    logger = ProgressLog(verbose=options.quiet==0, silent=options.quiet>=2,
                        progress_store=progress)
                    seed(seed_tasks, progress_logger=logger, dry_run=options.dry_run,
                         concurrency=options.concurrency, cache_locker=cache_locker,
                         skip_geoms_for_last_levels=options.geom_levels)
                if cleanup_tasks:
                    print '========== Cleanup tasks =========='
                    print 'Start cleanup process (%d task%s)' % (
                        len(cleanup_tasks), 's' if len(cleanup_tasks) > 1 else '')
                    logger = ProgressLog(verbose=options.quiet==0, silent=options.quiet>=2)
                    cleanup(cleanup_tasks, verbose=options.quiet==0, dry_run=options.dry_run,
                            concurrency=options.concurrency, progress_logger=logger,
                            skip_geoms_for_last_levels=options.geom_levels)
            except KeyboardInterrupt:
                print '\nexiting...'
                return 2

            if progress:
                progress.remove()

    def task_names(self, seed_conf, options):
        seed_names = cleanup_names = []

        if options.seed_names:
            seed_names = split_comma_seperated_option(options.seed_names)
            if seed_names == ['ALL']:
                seed_names = None
            else:
                avail_seed_names = seed_conf.seed_tasks_names()
                missing = set(seed_names).difference(avail_seed_names)
                if missing:
                    print 'unknown seed tasks: %s' % (', '.join(missing), )
                    print 'available seed tasks: %s' % (', '.join(avail_seed_names), )
                    sys.exit(1)
        elif not options.cleanup_names:
            seed_names = None # seed all

        if options.cleanup_names:
            cleanup_names = split_comma_seperated_option(options.cleanup_names)
            if cleanup_names == ['ALL']:
                cleanup_names = None
            else:
                avail_cleanup_names = seed_conf.cleanup_tasks_names()
                missing = set(cleanup_names).difference(avail_cleanup_names)
                if missing:
                    print 'unknown cleanup tasks: %s' % (', '.join(missing), )
                    print 'available cleanup tasks: %s' % (', '.join(avail_cleanup_names), )
                    sys.exit(1)
        elif not options.seed_names:
            cleanup_names = None # cleanup all

        return seed_names, cleanup_names

    def interactive(self, seed_tasks, cleanup_tasks):
        selected_seed_tasks = []
        print '========== Select seeding tasks =========='
        for task in seed_tasks:
            print format_seed_task(task)
            if ask_yes_no_question('    Seed this task (y/n)? '):
                selected_seed_tasks.append(task)
        seed_tasks = selected_seed_tasks

        selected_cleanup_tasks = []
        print '========== Select cleanup tasks =========='
        for task in cleanup_tasks:
            print format_cleanup_task(task)
            if ask_yes_no_question('    Cleanup this task (y/n)? '):
                selected_cleanup_tasks.append(task)
        cleanup_tasks = selected_cleanup_tasks
        return seed_tasks, cleanup_tasks


def main():
    return SeedScript()()

def ask_yes_no_question(question):
    while True:
        resp = raw_input(question).lower()
        if resp in ('y', 'yes'): return True
        elif resp in ('n', 'no'): return False

def split_comma_seperated_option(option):
    """
    >>> split_comma_seperated_option(['foo,bar', 'baz'])
    ['foo', 'bar', 'baz']
    """
    result = []
    if option:
        for args in option:
            result.extend(args.split(','))
    return result

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = seeder
# This file is part of the MapProxy project.
# Copyright (C) 2010, 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division
import sys
from contextlib import contextmanager
import time

from mapproxy.config import base_config
from mapproxy.grid import MetaGrid
from mapproxy.source import SourceError
from mapproxy.config import local_base_config
from mapproxy.util.ext.itertools import izip_longest
from mapproxy.util.lock import LockTimeout
from mapproxy.seed.util import format_seed_task, timestamp
from mapproxy.seed.cachelock import DummyCacheLocker, CacheLockedError

from mapproxy.seed.util import (exp_backoff, ETA, limit_sub_bbox,
    status_symbol)

NONE = 0
CONTAINS = -1
INTERSECTS = 1

# do not use multiprocessing on windows, it blows
# no lambdas, no anonymous functions/classes, no base_config(), etc.
if sys.platform == 'win32':
    import Queue
    import threading
    proc_class = threading.Thread
    queue_class = Queue.Queue
else:
    import multiprocessing
    proc_class = multiprocessing.Process
    queue_class = multiprocessing.Queue


class TileProcessor(object):
    def __init__(self, dry_run=False):
        self._lastlog = time.time()
        self.dry_run = dry_run

    def log_progress(self, progress):
        if (self._lastlog + .1) < time.time():
            # log progress at most every 100ms
            print '[%s] %6.2f%% %s \tETA: %s\r' % (
                timestamp(), progress[1]*100, progress[0],
                progress[2]
            ),
            sys.stdout.flush()
            self._lastlog = time.time()

    def process(self, tiles, progress):
        if not self.dry_run:
            self.process_tiles(tiles)

        self.log_progress(progress)

    def stop(self):
        raise NotImplementedError()

    def process_tiles(self, tiles):
        raise NotImplementedError()


class TileWorkerPool(TileProcessor):
    """
    Manages multiple TileWorker.
    """
    def __init__(self, task, worker_class, size=2, dry_run=False, progress_logger=None):
        TileProcessor.__init__(self, dry_run=dry_run)
        self.tiles_queue = queue_class(size)
        self.task = task
        self.dry_run = dry_run
        self.procs = []
        self.progress_logger = progress_logger
        conf = base_config()
        for _ in xrange(size):
            worker = worker_class(self.task, self.tiles_queue, conf)
            worker.start()
            self.procs.append(worker)

    def process(self, tiles, progress):
        if not self.dry_run:
            self.tiles_queue.put(tiles)

            if self.progress_logger:
                self.progress_logger.log_step(progress)

    def stop(self):
        for _ in xrange(len(self.procs)):
            self.tiles_queue.put(None)

        for proc in self.procs:
            proc.join()


class TileWorker(proc_class):
    def __init__(self, task, tiles_queue, conf):
        proc_class.__init__(self)
        proc_class.daemon = True
        self.task = task
        self.tile_mgr = task.tile_manager
        self.tiles_queue = tiles_queue
        self.conf = conf

    def run(self):
        with local_base_config(self.conf):
            try:
                self.work_loop()
            except KeyboardInterrupt:
                return

class TileSeedWorker(TileWorker):
    def work_loop(self):
        while True:
            tiles = self.tiles_queue.get()
            if tiles is None:
                return
            with self.tile_mgr.session():
                exp_backoff(self.tile_mgr.load_tile_coords, args=(tiles,),
                        exceptions=(SourceError, IOError), ignore_exceptions=(LockTimeout, ))

class TileCleanupWorker(TileWorker):
    def work_loop(self):
        while True:
            tiles = self.tiles_queue.get()
            if tiles is None:
                return
            with self.tile_mgr.session():
                self.tile_mgr.remove_tile_coords(tiles)

class SeedProgress(object):
    def __init__(self, old_progress_identifier=None):
        self.progress = 0.0
        self.eta = ETA()
        self.level_progress_percentages = [1.0]
        self.level_progresses = []
        self.progress_str_parts = []
        self.old_level_progresses = None
        if old_progress_identifier is not None:
            self.old_level_progresses = old_progress_identifier

    def step_forward(self, subtiles=1):
        self.progress += self.level_progress_percentages[-1] / subtiles
        self.eta.update(self.progress)

    @property
    def progress_str(self):
        return ''.join(self.progress_str_parts)

    @contextmanager
    def step_down(self, i, subtiles):
        self.level_progresses.append((i, subtiles))
        self.progress_str_parts.append(status_symbol(i, subtiles))
        self.level_progress_percentages.append(self.level_progress_percentages[-1] / subtiles)
        yield
        self.level_progress_percentages.pop()
        self.progress_str_parts.pop()
        self.level_progresses.pop()

    def already_processed(self):
        if self.old_level_progresses == []:
            return True

        if self.old_level_progresses is None:
            return False

        if self.progress_is_behind(self.old_level_progresses, self.level_progresses):
            return True
        else:
            return False

    def current_progress_identifier(self):
        return self.level_progresses

    @staticmethod
    def progress_is_behind(old_progress, current_progress):
        """
        Return True if the `current_progress` is behind the `old_progress` -
        when it isn't as far as the old progress.

        >>> SeedProgress.progress_is_behind([], [(0, 1)])
        True
        >>> SeedProgress.progress_is_behind([(0, 1), (1, 4)], [(0, 1)])
        False
        >>> SeedProgress.progress_is_behind([(0, 1), (1, 4)], [(0, 1), (0, 4)])
        True
        >>> SeedProgress.progress_is_behind([(0, 1), (1, 4)], [(0, 1), (1, 4)])
        True
        >>> SeedProgress.progress_is_behind([(0, 1), (1, 4)], [(0, 1), (3, 4)])
        False

        """
        for old, current in izip_longest(old_progress, current_progress, fillvalue=(9e15, 9e15)):
            if old < current:
                return False
            if old > current:
                return True
        return True

    def running(self):
        return True

class StopProcess(Exception):
    pass

class TileWalker(object):
    def __init__(self, task, worker_pool, handle_stale=False, handle_uncached=False,
                 work_on_metatiles=True, skip_geoms_for_last_levels=0, progress_logger=None,
                 seed_progress=None):
        self.tile_mgr = task.tile_manager
        self.task = task
        self.worker_pool = worker_pool
        self.handle_stale = handle_stale
        self.handle_uncached = handle_uncached
        self.work_on_metatiles = work_on_metatiles
        self.skip_geoms_for_last_levels = skip_geoms_for_last_levels
        self.progress_logger = progress_logger

        num_seed_levels = len(task.levels)
        self.report_till_level = task.levels[int(num_seed_levels * 0.8)]
        meta_size = self.tile_mgr.meta_grid.meta_size if self.tile_mgr.meta_grid else (1, 1)
        self.tiles_per_metatile = meta_size[0] * meta_size[1]
        self.grid = MetaGrid(self.tile_mgr.grid, meta_size=meta_size, meta_buffer=0)
        self.count = 0
        self.seed_progress = seed_progress or SeedProgress()

    def walk(self):
        assert self.handle_stale or self.handle_uncached
        bbox = self.task.coverage.extent.bbox_for(self.tile_mgr.grid.srs)
        if self.seed_progress.already_processed():
            # nothing to seed
            self.seed_progress.step_forward()
        else:
            try:
                self._walk(bbox, self.task.levels)
            except StopProcess:
                pass
        self.report_progress(self.task.levels[0], self.task.coverage.bbox)

    def _walk(self, cur_bbox, levels, current_level=0, all_subtiles=False):
        """
        :param cur_bbox: the bbox to seed in this call
        :param levels: list of levels to seed
        :param all_subtiles: seed all subtiles and do not check for
                             intersections with bbox/geom
        """
        bbox_, tiles, subtiles = self.grid.get_affected_level_tiles(cur_bbox, current_level)
        total_subtiles = tiles[0] * tiles[1]
        if len(levels) < self.skip_geoms_for_last_levels:
            # do not filter in last levels
            all_subtiles = True
        subtiles = self._filter_subtiles(subtiles, all_subtiles)

        if current_level in levels and current_level <= self.report_till_level:
            self.report_progress(current_level, cur_bbox)

        if not self.seed_progress.running():
            if current_level in levels:
                self.report_progress(current_level, cur_bbox)
            self.tile_mgr.cleanup()
            raise StopProcess()

        process = False;
        if current_level in levels:
            levels = levels[1:]
            process = True
        current_level += 1

        for i, (subtile, sub_bbox, intersection) in enumerate(subtiles):
            if subtile is None: # no intersection
                self.seed_progress.step_forward(total_subtiles)
                continue
            if levels: # recurse to next level
                sub_bbox = limit_sub_bbox(cur_bbox, sub_bbox)
                if intersection == CONTAINS:
                    all_subtiles = True
                else:
                    all_subtiles = False

                with self.seed_progress.step_down(i, total_subtiles):
                    if self.seed_progress.already_processed():
                        self.seed_progress.step_forward()
                    else:
                        self._walk(sub_bbox, levels, current_level=current_level,
                            all_subtiles=all_subtiles)

            if not process:
                continue

            if not self.work_on_metatiles:
                # collect actual tiles
                handle_tiles = self.grid.tile_list(subtile)
            else:
                handle_tiles = [subtile]

            if self.handle_uncached:
                handle_tiles = [t for t in handle_tiles if
                                    t is not None and
                                    not self.tile_mgr.is_cached(t)]
            elif self.handle_stale:
                handle_tiles = [t for t in handle_tiles if
                                    t is not None and
                                    self.tile_mgr.is_stale(t)]
            if handle_tiles:
                self.count += 1
                self.worker_pool.process(handle_tiles, self.seed_progress)

            if not levels:
                self.seed_progress.step_forward(total_subtiles)

        if len(levels) >= 4:
            # call cleanup to close open caches
            # for connection based caches
            self.tile_mgr.cleanup()

    def report_progress(self, level, bbox):
        if self.progress_logger:
            self.progress_logger.log_progress(self.seed_progress, level, bbox,
                self.count * self.tiles_per_metatile)

    def _filter_subtiles(self, subtiles, all_subtiles):
        """
        Return an iterator with all sub tiles.
        Yields (None, None, None) for non-intersecting tiles,
        otherwise (subtile, subtile_bbox, intersection).
        """
        for subtile in subtiles:
            if subtile is None:
                yield None, None, None
            else:
                sub_bbox = self.grid.meta_tile(subtile).bbox
                if all_subtiles:
                    intersection = CONTAINS
                else:
                    intersection = self.task.intersects(sub_bbox)
                if intersection:
                    yield subtile, sub_bbox, intersection
                else:
                    yield None, None, None

class SeedTask(object):
    def __init__(self, md, tile_manager, levels, refresh_timestamp, coverage):
        self.md = md
        self.tile_manager = tile_manager
        self.grid = tile_manager.grid
        self.levels = levels
        self.refresh_timestamp = refresh_timestamp
        self.coverage = coverage

    @property
    def id(self):
        return self.md['name'], self.md['cache_name'], self.md['grid_name']

    def intersects(self, bbox):
        if self.coverage.contains(bbox, self.grid.srs): return CONTAINS
        if self.coverage.intersects(bbox, self.grid.srs): return INTERSECTS
        return NONE

class CleanupTask(object):
    """
    :param coverage: area for the cleanup
    :param complete_extent: ``True`` if `coverage` equals the extent of the grid
    """
    def __init__(self, md, tile_manager, levels, remove_timestamp, coverage, complete_extent=False):
        self.md = md
        self.tile_manager = tile_manager
        self.grid = tile_manager.grid
        self.levels = levels
        self.remove_timestamp = remove_timestamp
        self.coverage = coverage
        self.complete_extent = complete_extent

    def intersects(self, bbox):
        if self.coverage.contains(bbox, self.grid.srs): return CONTAINS
        if self.coverage.intersects(bbox, self.grid.srs): return INTERSECTS
        return NONE

def seed(tasks, concurrency=2, dry_run=False, skip_geoms_for_last_levels=0,
    progress_logger=None, cache_locker=None):
    if cache_locker is None:
        cache_locker = DummyCacheLocker()

    active_tasks = tasks[::-1]
    while active_tasks:
        task = active_tasks[-1]
        print format_seed_task(task)

        wait = len(active_tasks) == 1
        try:
            with cache_locker.lock(task.md['cache_name'], no_block=not wait):
                if progress_logger and progress_logger.progress_store:
                    progress_logger.current_task_id = task.id
                    start_progress = progress_logger.progress_store.get(task.id)
                else:
                    start_progress = None
                seed_progress = SeedProgress(old_progress_identifier=start_progress)
                seed_task(task, concurrency, dry_run, skip_geoms_for_last_levels, progress_logger,
                    seed_progress=seed_progress)
        except CacheLockedError:
            print '    ...cache is locked, skipping'
            active_tasks = [task] + active_tasks[:-1]
        else:
            active_tasks.pop()


def seed_task(task, concurrency=2, dry_run=False, skip_geoms_for_last_levels=0,
    progress_logger=None, seed_progress=None):
    if task.refresh_timestamp is not None:
        task.tile_manager._expire_timestamp = task.refresh_timestamp
    task.tile_manager.minimize_meta_requests = False
    tile_worker_pool = TileWorkerPool(task, TileSeedWorker, dry_run=dry_run,
        size=concurrency, progress_logger=progress_logger)
    tile_walker = TileWalker(task, tile_worker_pool, handle_uncached=True,
        skip_geoms_for_last_levels=skip_geoms_for_last_levels, progress_logger=progress_logger,
        seed_progress=seed_progress)
    tile_walker.walk()
    tile_worker_pool.stop()


########NEW FILE########
__FILENAME__ = spec
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from mapproxy.util.ext.dictspec.validator import validate, ValidationError
from mapproxy.util.ext.dictspec.spec import one_off, anything, number
from mapproxy.util.ext.dictspec.spec import required

from mapproxy.config.spec import coverage

def validate_seed_conf(conf_dict):
    """
    Validate `conf_dict` agains seed.yaml spec.
    Returns lists with errors. List is empty when no errors where found.
    """
    try:
        validate(seed_yaml_spec, conf_dict)
    except ValidationError, ex:
        return ex.errors, ex.informal_only
    else:
        return [], True

time_spec = {
    'seconds': number(),
    'minutes': number(),
    'hours': number(),
    'days': number(),
    'weeks': number(),
    'time': anything(),
    'mtime': str(),
}

from_to_spec = {
    'from': number(),
    'to': number(),
}

seed_yaml_spec = {
    'coverages': {
        anything(): coverage,
    },
    'seeds': {
        anything(): {
            required('caches'): [str()],
            'grids': [str()],
            'coverages': [str()],
            'refresh_before': time_spec,
            'levels': one_off([int()], from_to_spec),
            'resolutions': one_off([int()], from_to_spec),
        },
    },
    'cleanups': {
        anything(): {
            required('caches'): [str()],
            'grids': [str()],
            'coverages': [str()],
            'remove_before': time_spec,
            'remove_all': bool(),
            'levels': one_off([int()], from_to_spec),
            'resolutions': one_off([int()], from_to_spec),
        }
    },
}

########NEW FILE########
__FILENAME__ = util
# This file is part of the MapProxy project.
# Copyright (C) 2010, 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

import os
import sys
import stat
import math
import time
import cPickle as pickle
from datetime import datetime

from mapproxy.layer import map_extent_from_grid

import logging
log = logging.getLogger(__name__)

class bidict(dict):
    """
    Simplest bi-directional dictionary.
    """
    def __init__(self, iterator):
        for key, val in iterator:
            dict.__setitem__(self, key, val)
            dict.__setitem__(self, val, key)

class ETA(object):
    def __init__(self):
        self.avgs = []
        self.last_tick_start = time.time()
        self.progress = 0.0
        self.ticks = 10000
        self.tick_duration_sums = 0.0
        self.tick_duration_divisor = 0.0
        self.tick_count = 0

    def update(self, progress):
        self.progress = progress
        missing_ticks = (self.progress * self.ticks) - self.tick_count
        if missing_ticks:
            tick_duration = (time.time() - self.last_tick_start) / missing_ticks

            while missing_ticks > 0:

                # reduce the influence of older messurements
                self.tick_duration_sums *= 0.999
                self.tick_duration_divisor *= 0.999

                self.tick_count += 1

                self.tick_duration_sums += tick_duration
                self.tick_duration_divisor += 1

                missing_ticks -= 1

            self.last_tick_start = time.time()

    def eta_string(self):
        timestamp = self.eta()
        if timestamp is None:
            return 'N/A'
        try:
            return time.strftime('%Y-%m-%d-%H:%M:%S', time.localtime(timestamp))
        except ValueError:
            # raised when time is out of range (e.g. year >2038)
            return 'N/A'

    def eta(self):
        if not self.tick_count: return
        return (self.last_tick_start +
                ((self.tick_duration_sums/self.tick_duration_divisor)
                 * (self.ticks - self.tick_count)))

    def __str__(self):
        return self.eta_string()

class ProgressStore(object):
    """
    Reads and stores seed progresses to a file.
    """
    def __init__(self, filename=None, continue_seed=True):
        self.filename = filename
        if continue_seed:
            self.status = self.load()
        else:
            self.status = {}

    def load(self):
        if not os.path.exists(self.filename):
            pass
        elif os.stat(self.filename).st_mode & stat.S_IWOTH:
            log.error('progress file (%s) is world writable, ignoring file',
                self.filename)
        else:
            with open(self.filename) as f:
                try:
                    return pickle.load(f)
                except (pickle.UnpicklingError, AttributeError,
                    EOFError, ImportError, IndexError):
                    log.error('unable to read progress file (%s), ignoring file',
                        self.filename)

        return {}

    def write(self):
        try:
            with open(self.filename + '.tmp', 'w') as f:
                f.write(pickle.dumps(self.status))
                f.flush()
                os.fsync(f.fileno())
            os.rename(self.filename + '.tmp', self.filename)
        except (IOError, OSError), ex:
            log.error('unable to write seed progress: %s', ex)

    def remove(self):
        self.status = {}
        if os.path.exists(self.filename):
            os.remove(self.filename)

    def get(self, task_identifier):
        return self.status.get(task_identifier, None)

    def add(self, task_identifier, progress_identifier):
        self.status[task_identifier] = progress_identifier

class ProgressLog(object):
    def __init__(self, out=None, silent=False, verbose=True, progress_store=None):
        if not out:
            out = sys.stdout
        self.out = out
        self.lastlog = time.time()
        self.verbose = verbose
        self.silent = silent
        self.current_task_id = None
        self.progress_store = progress_store

    def log_message(self, msg):
        self.out.write('[%s] %s\n' % (
            timestamp(), msg,
        ))
        self.out.flush()

    def log_step(self, progress):
        if not self.verbose:
            return
        if (self.lastlog + .1) < time.time():
            # log progress at most every 100ms
            self.out.write('[%s] %6.2f%%\t%-20s ETA: %s\r' % (
                timestamp(), progress.progress*100, progress.progress_str,
                progress.eta
            ))
            self.out.flush()
            self.lastlog = time.time()

    def log_progress(self, progress, level, bbox, tiles):
        if self.progress_store and self.current_task_id:
            self.progress_store.add(self.current_task_id,
                progress.current_progress_identifier())
            self.progress_store.write()

        if self.silent:
            return
        self.out.write('[%s] %2s %6.2f%% %s (%d tiles) ETA: %s\n' % (
            timestamp(), level, progress.progress*100,
            format_bbox(bbox), tiles, progress.eta))
        self.out.flush()


def limit_sub_bbox(bbox, sub_bbox):
    """
    >>> limit_sub_bbox((0, 1, 10, 11), (-1, -1, 9, 8))
    (0, 1, 9, 8)
    >>> limit_sub_bbox((0, 0, 10, 10), (5, 2, 18, 18))
    (5, 2, 10, 10)
    """
    minx = max(bbox[0], sub_bbox[0])
    miny = max(bbox[1], sub_bbox[1])
    maxx = min(bbox[2], sub_bbox[2])
    maxy = min(bbox[3], sub_bbox[3])
    return minx, miny, maxx, maxy

def timestamp():
    return datetime.now().strftime('%H:%M:%S')

def format_bbox(bbox):
    return ('%.5f, %.5f, %.5f, %.5f') % tuple(bbox)

def status_symbol(i, total):
    """
    >>> status_symbol(0, 1)
    '0'
    >>> [status_symbol(i, 4) for i in range(5)]
    ['.', 'o', 'O', '0', 'X']
    >>> [status_symbol(i, 10) for i in range(11)]
    ['.', '.', 'o', 'o', 'o', 'O', 'O', '0', '0', '0', 'X']
    """
    symbols = list(' .oO0')
    i += 1
    if 0 < i > total:
        return 'X'
    else:
        return symbols[int(math.ceil(i/(total/4)))]

def exp_backoff(func, args=(), kw={}, max_repeat=47, start_backoff_sec=2,
        exceptions=(Exception,), ignore_exceptions=tuple(), max_backoff=600):
    n = 0
    while True:
        try:
            result = func(*args, **kw)
        except ignore_exceptions:
            time.sleep(0.01)
        except exceptions, ex:
            if (n+1) >= max_repeat:
                raise
            wait_for = start_backoff_sec * 2**n
            if wait_for > max_backoff:
                wait_for = max_backoff
            print >>sys.stderr, ("An error occured. Retry in %d seconds: %r. Retries left: %d" %
                (wait_for, ex, (max_repeat - n - 1)))
            time.sleep(wait_for)
            n += 1
        else:
            return result

def format_seed_task(task):
    info = []
    info.append('  %s:' % (task.md['name'], ))
    info.append("    Seeding cache '%s' with grid '%s' in %s" % (
                 task.md['cache_name'], task.md['grid_name'], task.grid.srs.srs_code))
    if task.coverage:
        info.append('    Limited to: %s (EPSG:4326)' % (format_bbox(task.coverage.extent.llbbox), ))
    else:
        info.append('   Complete grid: %s (EPSG:4326)' % (format_bbox(map_extent_from_grid(task.grid).llbbox), ))
    info.append('    Levels: %s' % (task.levels, ))

    if task.refresh_timestamp:
        info.append('    Overwriting: tiles older than %s' %
                    datetime.fromtimestamp(task.refresh_timestamp))
    elif task.refresh_timestamp == 0:
        info.append('    Overwriting: all tiles')
    else:
        info.append('    Overwriting: no tiles')

    return '\n'.join(info)

def format_cleanup_task(task):
    info = []
    info.append('  %s:' % (task.md['name'], ))
    info.append("    Cleaning up cache '%s' with grid '%s' in %s" % (
                 task.md['cache_name'], task.md['grid_name'], task.grid.srs.srs_code))
    if task.coverage:
        info.append('    Limited to: %s (EPSG:4326)' % (format_bbox(task.coverage.extent.llbbox), ))
    else:
        info.append('    Complete grid: %s (EPSG:4326)' % (format_bbox(map_extent_from_grid(task.grid).llbbox), ))
    info.append('    Levels: %s' % (task.levels, ))

    if task.remove_timestamp:
        info.append('    Remove: tiles older than %s' %
                    datetime.fromtimestamp(task.remove_timestamp))
    else:
        info.append('    Remove: all tiles')

    return '\n'.join(info)

########NEW FILE########
__FILENAME__ = base
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Service handler (WMS, TMS, etc.).
"""
from mapproxy.exception import RequestError

class Server(object):
    names = tuple()
    request_parser = lambda x: None
    request_methods = ()
    
    def handle(self, req):
        try:
            parsed_req = self.parse_request(req)
            handler = getattr(self, parsed_req.request_handler_name)
            return handler(parsed_req)
        except RequestError, e:
            return e.render()
    
    def parse_request(self, req):
        return self.request_parser(req)

    def decorate_img(self, image, service, layers, environ, query_extent):
        """ Callback that allows the ImageSource associated with a response to
            be modified before it is returned. The callback is passed the
            ImageSource instance and must return a valid ImageSource """
        if 'mapproxy.decorate_img' in environ:
            image = environ['mapproxy.decorate_img'](
                image, service, layers, environ=environ, query_extent=query_extent)
        return image



########NEW FILE########
__FILENAME__ = demo
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Demo service handler
"""
from __future__ import division

import os
import pkg_resources
import mimetypes
from urllib2 import urlopen
from collections import defaultdict

from mapproxy.config.config import base_config
from mapproxy.exception import RequestError
from mapproxy.service.base import Server
from mapproxy.response import Response
from mapproxy.srs import SRS, get_epsg_num
from mapproxy.layer import SRSConditional, CacheMapLayer, ResolutionConditional
from mapproxy.source.wms import WMSSource

from mapproxy.template import template_loader, bunch
env = {'bunch': bunch}
get_template = template_loader(__name__, 'templates', namespace=env)


def static_filename(name):
    if base_config().template_dir:
        return os.path.join(base_config().template_dir, name)
    else:
        return pkg_resources.resource_filename(__name__, os.path.join('templates', name))

class DemoServer(Server):
    names = ('demo',)
    def __init__(self, layers, md, request_parser=None, tile_layers=None,
                 srs=None, image_formats=None, services=None, restful_template=None):
        Server.__init__(self)
        self.layers = layers
        self.tile_layers = tile_layers or {}
        self.md = md
        self.image_formats = image_formats
        filter_image_format = []
        for format in self.image_formats:
            if 'image/jpeg' == format or 'image/png' == format:
                filter_image_format.append(format)
        self.image_formats = filter_image_format
        self.srs = srs
        self.services = services or []
        self.restful_template = restful_template

    def handle(self, req):
        if req.path.startswith('/demo/static/'):
            filename = req.path.lstrip('/')
            filename = static_filename(filename)
            if not os.path.isfile(filename):
                return Response('file not found', content_type='text/plain', status=404)
            type, encoding = mimetypes.guess_type(filename)
            return Response(open(filename, 'rb'), content_type=type)

        # we don't authorize the static files (css, js)
        # since they are not confidential
        try:
            authorized = self.authorized_demo(req.environ)
        except RequestError, ex:
            return ex.render()
        if not authorized:
            return Response('forbidden', content_type='text/plain', status=403)

        if 'wms_layer' in req.args:
            demo = self._render_wms_template('demo/wms_demo.html', req)
        elif 'tms_layer' in req.args:
            demo = self._render_tms_template('demo/tms_demo.html', req)
        elif 'wmts_layer' in req.args:
            demo = self._render_wmts_template('demo/wmts_demo.html', req)
        elif 'wms_capabilities' in req.args:
            url = '%s/service?REQUEST=GetCapabilities'%(req.script_url)
            capabilities = urlopen(url)
            demo = self._render_capabilities_template('demo/capabilities_demo.html', capabilities, 'WMS', url)
        elif 'wmsc_capabilities' in req.args:
            url = '%s/service?REQUEST=GetCapabilities&tiled=true'%(req.script_url)
            capabilities = urlopen(url)
            demo = self._render_capabilities_template('demo/capabilities_demo.html', capabilities, 'WMS-C', url)
        elif 'wmts_capabilities' in req.args:
            url = '%s/wmts/1.0.0/WMTSCapabilities.xml' % (req.script_url)
            capabilities = urlopen(url)
            demo = self._render_capabilities_template('demo/capabilities_demo.html', capabilities, 'WMTS', url)
        elif 'tms_capabilities' in req.args:
            if 'layer' in req.args and 'srs' in req.args:
                url = '%s/tms/1.0.0/%s_%s'%(req.script_url, req.args['layer'], req.args['srs'])
            else:
                url = '%s/tms/1.0.0/'%(req.script_url)
            capabilities = urlopen(url)
            demo = self._render_capabilities_template('demo/capabilities_demo.html', capabilities, 'TMS', url)
        elif req.path == '/demo/':
            demo = self._render_template('demo/demo.html')
        else:
            resp = Response('', status=301)
            resp.headers['Location'] = req.script_url.rstrip('/') + '/demo/'
            return resp
        return Response(demo, content_type='text/html')

    def layer_srs(self, layer):
        """
        Return a list tuples with title and name of all SRS for the layer.
        The title of SRS that are native to the layer are suffixed with a '*'.
        """
        cached_srs = []
        for map_layer in layer.map_layers:
            # TODO unify map_layers interface
            if isinstance(map_layer, SRSConditional):
                for srs_key in map_layer.srs_map.keys():
                    cached_srs.append(srs_key.srs_code)
            elif isinstance(map_layer, CacheMapLayer):
                cached_srs.append(map_layer.grid.srs.srs_code)
            elif isinstance(map_layer, ResolutionConditional):
                cached_srs.append(map_layer.srs.srs_code)
            elif isinstance(map_layer, WMSSource):
                if map_layer.supported_srs:
                    for supported_srs in map_layer.supported_srs:
                        cached_srs.append(supported_srs.srs_code)

        uncached_srs = []

        for srs_code in self.srs:
            if srs_code not in cached_srs:
                uncached_srs.append(srs_code)

        sorted_cached_srs = sorted(cached_srs, key=lambda srs: get_epsg_num(srs))
        sorted_uncached_srs = sorted(uncached_srs, key=lambda srs: get_epsg_num(srs))
        sorted_cached_srs = [(s + '*', s) for s in sorted_cached_srs]
        sorted_uncached_srs = [(s, s) for s in sorted_uncached_srs]
        return sorted_cached_srs + sorted_uncached_srs

    def _render_template(self, template):
        template = get_template(template, default_inherit="demo/static.html")
        tms_tile_layers = defaultdict(list)
        for layer in self.tile_layers:
            name = self.tile_layers[layer].md.get('name')
            tms_tile_layers[name].append(self.tile_layers[layer])
        wmts_layers = tms_tile_layers.copy()
        return template.substitute(layers=self.layers,
                                   formats=self.image_formats,
                                   srs=self.srs,
                                   layer_srs=self.layer_srs,
                                   tms_layers=tms_tile_layers,
                                   wmts_layers=wmts_layers,
                                   services=self.services)

    def _render_wms_template(self, template, req):
        template = get_template(template, default_inherit="demo/static.html")
        layer = self.layers[req.args['wms_layer']]
        srs = req.args['srs']
        bbox = layer.extent.bbox_for(SRS(srs))
        width = bbox[2] - bbox[0]
        height = bbox[3] - bbox[1]
        min_res = max(width/256, height/256)
        return template.substitute(layer=layer,
                                   image_formats=self.image_formats,
                                   format=req.args['format'],
                                   srs=srs,
                                   layer_srs=self.layer_srs,
                                   bbox=bbox,
                                   res=min_res)

    def _render_tms_template(self, template, req):
        template = get_template(template, default_inherit="demo/static.html")
        tile_layer = self.tile_layers['_'.join([req.args['tms_layer'], req.args['srs'].replace(':','')])]
        resolutions = tile_layer.grid.tile_sets
        res = []
        for level, resolution in resolutions:
            res.append(resolution)

        if tile_layer.grid.srs.is_latlong:
            units = 'degree'
        else:
            units = 'm'

        if tile_layer.grid.profile == 'local':
            add_res_to_options = True
        else:
            add_res_to_options = False
        return template.substitute(layer=tile_layer,
                                   srs=req.args['srs'],
                                   format=req.args['format'],
                                   resolutions=res,
                                   units=units,
                                   add_res_to_options=add_res_to_options,
                                   all_tile_layers=self.tile_layers)

    def _render_wmts_template(self, template, req):
        template = get_template(template, default_inherit="demo/static.html")
        wmts_layer = self.tile_layers['_'.join([req.args['wmts_layer'], req.args['srs'].replace(':','')])]

        restful_url = self.restful_template.replace('{Layer}', wmts_layer.name, 1)
        if '{Format}' in restful_url:
            restful_url = restful_url.replace('{Format}', wmts_layer.format)

        if wmts_layer.grid.srs.is_latlong:
            units = 'degree'
        else:
            units = 'm'
        return template.substitute(layer=wmts_layer,
                                   matrix_set=wmts_layer.grid.name,
                                   format=req.args['format'],
                                   srs=req.args['srs'],
                                   resolutions=wmts_layer.grid.resolutions,
                                   units=units,
                                   all_tile_layers=self.tile_layers,
                                   restful_url=restful_url)

    def _render_capabilities_template(self, template, xmlfile, service, url):
        template = get_template(template, default_inherit="demo/static.html")
        return template.substitute(capabilities = xmlfile,
                                   service = service,
                                   url = url)

    def authorized_demo(self, environ):
        if 'mapproxy.authorize' in environ:
            result = environ['mapproxy.authorize']('demo', [], environ=environ)
            if result['authorized'] == 'unauthenticated':
                raise RequestError('unauthorized', status=401)
            if result['authorized'] == 'full':
                return True
            return False
        return True

########NEW FILE########
__FILENAME__ = kml
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

from mapproxy.response import Response
from mapproxy.exception import RequestError, PlainExceptionHandler
from mapproxy.service.base import Server
from mapproxy.request.tile import TileRequest
from mapproxy.srs import SRS
from mapproxy.util.coverage import load_limited_to

class KMLRequest(TileRequest):
    """
    Class for TMS-like KML requests.
    """
    request_handler_name = 'map'
    req_prefix = '/kml'
    tile_req_re = re.compile(r'''^(?P<begin>/kml)/
            (?P<layer>[^/]+)/
            ((?P<layer_spec>[^/]+)/)?
            (?P<z>-?\d+)/
            (?P<x>-?\d+)/
            (?P<y>-?\d+)\.(?P<format>\w+)''', re.VERBOSE)

    def __init__(self, request):
        TileRequest.__init__(self, request)
        if self.format == 'kml':
            self.request_handler_name = 'kml'

    @property
    def exception_handler(self):
        return PlainExceptionHandler()

class KMLInitRequest(TileRequest):
    """
    Class for TMS-like KML requests.
    """
    request_handler_name = 'map'
    req_prefix = '/kml'
    tile_req_re = re.compile(r'''^(?P<begin>/kml)/
            (?P<layer>[^/]+)
            (/(?P<layer_spec>[^/]+))?
            /?$
    ''', re.VERBOSE)

    def __init__(self, request):
        self.http = request
        self.tile = (0, 0, 0)
        self.format = 'kml'
        self.request_handler_name = 'kml'
        self._init_request()

    @property
    def exception_handler(self):
        return PlainExceptionHandler()

def kml_request(req):
    if KMLInitRequest.tile_req_re.match(req.path):
        return KMLInitRequest(req)
    else:
        return KMLRequest(req)

class KMLServer(Server):
    """
    OGC KML 2.2 Server
    """
    names = ('kml',)
    request_parser = staticmethod(kml_request)
    request_methods = ('map', 'kml')

    def __init__(self, layers, md, max_tile_age=None, use_dimension_layers=False):
        Server.__init__(self)
        self.layers = layers
        self.md = md
        self.max_tile_age = max_tile_age
        self.use_dimension_layers = use_dimension_layers

    def map(self, map_request):
        """
        :return: the requested tile
        """
        # force 'sw' origin for kml
        map_request.origin = 'sw'
        layer = self.layer(map_request)
        limit_to = self.authorize_tile_layer(layer, map_request)
        tile = layer.render(map_request, coverage=limit_to)
        tile_format = getattr(tile, 'format', map_request.format)
        resp = Response(tile.as_buffer(),
                        content_type='image/' + tile_format)
        resp.cache_headers(tile.timestamp, etag_data=(tile.timestamp, tile.size),
                           max_age=self.max_tile_age)
        resp.make_conditional(map_request.http)
        return resp

    def authorize_tile_layer(self, tile_layer, request):
        if 'mapproxy.authorize' in request.http.environ:
            if request.tile:
                query_extent = (tile_layer.grid.srs.srs_code,
                    tile_layer.tile_bbox(request, use_profiles=request.use_profiles))
            else:
                query_extent = None # for layer capabilities
            result = request.http.environ['mapproxy.authorize']('kml', [tile_layer.name],
                query_extent=query_extent, environ=request.http.environ)
            if result['authorized'] == 'unauthenticated':
                raise RequestError('unauthorized', status=401)
            if result['authorized'] == 'full':
                return
            if result['authorized'] == 'partial':
                if result['layers'].get(tile_layer.name, {}).get('tile', False) == True:
                    limited_to = result['layers'][tile_layer.name].get('limited_to')
                    if not limited_to:
                        limited_to = result.get('limited_to')
                    if limited_to:
                        return load_limited_to(limited_to)
                    else:
                        return None
            raise RequestError('forbidden', status=403)


    def _internal_layer(self, tile_request):
        if '_layer_spec' in tile_request.dimensions:
            name = tile_request.layer + '_' + tile_request.dimensions['_layer_spec']
        else:
            name = tile_request.layer
        if name in self.layers:
            return self.layers[name]
        if name + '_EPSG4326' in self.layers:
            return self.layers[name + '_EPSG4326']
        if name + '_EPSG900913' in self.layers:
            return self.layers[name + '_EPSG900913']
        return None

    def _internal_dimension_layer(self, tile_request):
        key = (tile_request.layer, tile_request.dimensions.get('_layer_spec'))
        return self.layers.get(key)

    def layer(self, tile_request):
        if self.use_dimension_layers:
            internal_layer = self._internal_dimension_layer(tile_request)
        else:
            internal_layer = self._internal_layer(tile_request)
        if internal_layer is None:
            raise RequestError('unknown layer: ' + tile_request.layer, request=tile_request)
        return internal_layer

    def kml(self, map_request):
        """
        :return: the rendered KML response
        """
        # force 'sw' origin for kml
        map_request.origin = 'sw'
        layer = self.layer(map_request)
        self.authorize_tile_layer(layer, map_request)

        tile_coord = map_request.tile

        initial_level = False
        if tile_coord[2] == 0:
            initial_level = True

        bbox = self._tile_wgs_bbox(map_request, layer, limit=True)
        if bbox is None:
            raise RequestError('The requested tile is outside the bounding box '
                               'of the tile map.', request=map_request)
        tile = SubTile(tile_coord, bbox)

        subtiles = self._get_subtiles(map_request, layer)
        tile_size = layer.grid.tile_size[0]
        url = map_request.http.script_url.rstrip('/')
        result = KMLRenderer().render(tile=tile, subtiles=subtiles, layer=layer,
            url=url, name=map_request.layer, format=layer.format, name_path=layer.md['name_path'],
            initial_level=initial_level, tile_size=tile_size)
        resp = Response(result, content_type='application/vnd.google-earth.kml+xml')
        resp.cache_headers(etag_data=(result,), max_age=self.max_tile_age)
        resp.make_conditional(map_request.http)
        return resp

    def _get_subtiles(self, tile_request, layer):
        """
        Create four `SubTile` for the next level of `tile`.
        """
        tile = tile_request.tile
        bbox = layer.tile_bbox(tile_request, use_profiles=tile_request.use_profiles, limit=True)

        level = layer.grid.internal_tile_coord((tile[0], tile[1], tile[2]+1), use_profiles=False)[2]
        bbox_, tile_grid_, tiles = layer.grid.get_affected_level_tiles(bbox, level)
        subtiles = []
        for coord in tiles:
            if coord is None: continue
            sub_bbox = layer.grid.tile_bbox(coord)
            if sub_bbox is not None:
                # only add subtiles where the lower left corner is in the bbox
                # to prevent subtiles to appear in multiple KML docs
                DELTA = -1.0/10e6
                if (sub_bbox[0] - bbox[0]) > DELTA and (sub_bbox[1] - bbox[1]) > DELTA:
                    sub_bbox_wgs = self._tile_bbox_to_wgs(sub_bbox, layer.grid)
                    coord = layer.grid.external_tile_coord(coord, use_profiles=False)
                    if layer.grid.origin not in ('ll', 'sw', None):
                        coord = layer.grid.flip_tile_coord(coord)
                    subtiles.append(SubTile(coord, sub_bbox_wgs))

        return subtiles

    def _tile_wgs_bbox(self, tile_request, layer, limit=False):
        bbox = layer.tile_bbox(tile_request, use_profiles=tile_request.use_profiles,
            limit=limit)
        if bbox is None:
            return None
        return self._tile_bbox_to_wgs(bbox, layer.grid)

    def _tile_bbox_to_wgs(self, src_bbox, grid):
        bbox = grid.srs.transform_bbox_to(SRS(4326), src_bbox, with_points=4)
        if grid.srs == SRS(900913):
            bbox = list(bbox)
            if abs(src_bbox[1] -  -20037508.342789244) < 0.1:
                bbox[1] = -90.0
            if abs(src_bbox[3] -  20037508.342789244) < 0.1:
                bbox[3] = 90.0
        return bbox

    def check_map_request(self, map_request):
        if map_request.layer not in self.layers:
            raise RequestError('unknown layer: ' + map_request.layer, request=map_request)


class SubTile(object):
    """
    Contains the ``bbox`` and ``coord`` of a sub tile.
    """
    def __init__(self, coord, bbox):
        self.coord = coord
        self.bbox = bbox

class KMLRenderer(object):
    header = """<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>%(layer_name)s</name>
    <Region>
      <LatLonAltBox>
        <north>%(north)f</north><south>%(south)f</south>
        <east>%(east)f</east><west>%(west)f</west>
      </LatLonAltBox>
    </Region>
    """

    network_link = """<NetworkLink>
      <name>%(layer_name)s - %(coord)s</name>
      <Region>
        <LatLonAltBox>
          <north>%(north)f</north><south>%(south)f</south>
          <east>%(east)f</east><west>%(west)f</west>
        </LatLonAltBox>
        <Lod>
          <minLodPixels>%(min_lod)d</minLodPixels>
          <maxLodPixels>-1</maxLodPixels>
        </Lod>
      </Region>
      <Link>
        <href>%(href)s</href>
        <viewRefreshMode>onRegion</viewRefreshMode>
        <viewFormat/>
      </Link>
    </NetworkLink>
    """
    ground_overlay = """<GroundOverlay>
      <name>%(coord)s</name>
      <Region>
        <LatLonAltBox>
          <north>%(north)f</north><south>%(south)f</south>
          <east>%(east)f</east><west>%(west)f</west>
        </LatLonAltBox>
        <Lod>
          <minLodPixels>%(min_lod)d</minLodPixels>
          <maxLodPixels>%(max_lod)d</maxLodPixels>
          <minFadeExtent>8</minFadeExtent>
          <maxFadeExtent>8</maxFadeExtent>
        </Lod>
      </Region>
      <drawOrder>%(level)d</drawOrder>
      <Icon>
        <href>%(href)s</href>
      </Icon>
      <LatLonBox>
        <north>%(north)f</north><south>%(south)f</south>
        <east>%(east)f</east><west>%(west)f</west>
      </LatLonBox>
    </GroundOverlay>
    """
    footer = """</Document>
</kml>
"""
    def render(self, tile, subtiles, layer, url, name, name_path, format, initial_level, tile_size):
        response = []
        response.append(self.header % dict(east=tile.bbox[2], south=tile.bbox[1],
            west=tile.bbox[0], north=tile.bbox[3], layer_name=name))

        name_path = '/'.join(name_path)
        for subtile in subtiles:
            kml_href = '%s/kml/%s/%d/%d/%d.kml' % (url, name_path,
                subtile.coord[2], subtile.coord[0], subtile.coord[1])
            response.append(self.network_link % dict(east=subtile.bbox[2], south=subtile.bbox[1],
                west=subtile.bbox[0], north=subtile.bbox[3], min_lod=tile_size/2, href=kml_href,
                layer_name=name, coord=subtile.coord))

        for subtile in subtiles:
            tile_href = '%s/kml/%s/%d/%d/%d.%s' % ( url, name_path,
                subtile.coord[2], subtile.coord[0], subtile.coord[1], layer.format)
            response.append(self.ground_overlay % dict(east=subtile.bbox[2], south=subtile.bbox[1],
                west=subtile.bbox[0], north=subtile.bbox[3], coord=subtile.coord,
                min_lod=tile_size/2, max_lod=tile_size*3, href=tile_href, level=subtile.coord[2]))
        response.append(self.footer)
        return ''.join(response)
########NEW FILE########
__FILENAME__ = ows
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Wrapper service handler for all OWS services (/service?).
"""

class OWSServer(object):
    """
    Wraps all OWS services (/service?) and dispatches requests
    based on the ``services`` query argument.
    """
    names = ('service', )
    
    def __init__(self, services):
        self.services = {}
        for service in services:
            self.services[service.service] = service
    
    def handle(self, req):
        service = req.args.get('service', 'wms').lower()
        if service not in self.services:
            # TODO
            return
        
        return self.services[service].handle(req)
        
########NEW FILE########
__FILENAME__ = template_helper
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from cgi import escape
from mapproxy.template import bunch

__all__ = ['escape', 'indent', 'bunch', 'wms100format', 'wms100info_format',
    'wms111metadatatype', 'limit_llbbox']

def indent(text, n=2):
  return '\n'.join(' '*n + line for line in text.split('\n'))

def wms100format(format):
    """
    >>> wms100format('image/png')
    'PNG'
    >>> wms100format('image/GeoTIFF')
    """
    _mime_class, sub_type = format.split('/')
    sub_type = sub_type.upper()
    if sub_type in ['PNG', 'TIFF', 'GIF', 'JPEG']:
        return sub_type
    else:
        return None

def wms100info_format(format):
    """
    >>> wms100info_format('text/html')
    'MIME'
    >>> wms100info_format('application/vnd.ogc.gml')
    'GML.1'
    """
    if format in ('application/vnd.ogc.gml', 'text/xml'):
        return 'GML.1'
    return 'MIME'

def wms111metadatatype(type):
    if type == 'ISO19115:2003':
        return 'TC211'
    if type == 'FGDC:1998':
        return 'FGDC'

def limit_llbbox(bbox):
    """
    Limit the long/lat bounding box to +-180/89.99999999 degrees.

    Some clients can't handle +-90 north/south, so we subtract a tiny bit.

    >>> ', '.join('%.6f' % x for x in limit_llbbox((-200,-90.0, 180, 90)))
    '-180.000000, -89.999999, 180.000000, 89.999999'
    >>> ', '.join('%.6f' % x for x in limit_llbbox((-20,-9.0, 10, 10)))
    '-20.000000, -9.000000, 10.000000, 10.000000'
    """
    minx, miny, maxx, maxy = bbox

    minx = max(-180, minx)
    miny = max(-89.999999, miny)
    maxx = min(180, maxx)
    maxy = min(89.999999, maxy)

    return minx, miny, maxx, maxy
########NEW FILE########
__FILENAME__ = tile
# -:- encoding: utf-8 -:-
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import division, with_statement

import math
import time

from mapproxy.response import Response
from mapproxy.exception import RequestError
from mapproxy.service.base import Server
from mapproxy.request.tile import tile_request
from mapproxy.request.base import split_mime_type
from mapproxy.layer import map_extent_from_grid
from mapproxy.source import SourceError
from mapproxy.srs import SRS
from mapproxy.grid import default_bboxs
from mapproxy.image import BlankImageSource
from mapproxy.image.opts import ImageOptions
from mapproxy.image.mask import mask_image_source_from_coverage
from mapproxy.util.ext.odict import odict
from mapproxy.util.coverage import load_limited_to

import logging
log = logging.getLogger(__name__)


from mapproxy.template import template_loader, bunch
get_template = template_loader(__name__, 'templates')

class TileServer(Server):
    """
    A Tile Server. Supports strict TMS and non-TMS requests. The difference is the
    support for profiles. The our internal tile cache starts with one tile at the
    first level (like KML, etc.), but the global-geodetic and global-mercator
    start with two and four tiles. The ``tile_request`` should set ``use_profiles``
    accordingly (eg. False if first level is one tile)
    """
    names = ('tiles', 'tms')
    request_parser = staticmethod(tile_request)
    request_methods = ('map', 'tms_capabilities, tms_root_resource')
    template_file = 'tms_capabilities.xml'
    layer_template_file = 'tms_tilemap_capabilities.xml'
    root_resource_template_file = 'tms_root_resource.xml'

    def __init__(self, layers, md, max_tile_age=None, use_dimension_layers=False, origin=None):
        Server.__init__(self)
        self.layers = layers
        self.md = md
        self.max_tile_age = max_tile_age
        self.use_dimension_layers = use_dimension_layers
        self.origin = origin

    def map(self, tile_request):
        """
        :return: the requested tile
        :rtype: Response
        """
        if self.origin and not tile_request.origin:
            tile_request.origin = self.origin
        layer, limit_to = self.layer(tile_request)

        def decorate_img(image):
            query_extent = (layer.grid.srs.srs_code,
                layer.tile_bbox(tile_request, use_profiles=tile_request.use_profiles))
            return self.decorate_img(image, 'tms', [layer.name], tile_request.http.environ, query_extent)

        tile = layer.render(tile_request, use_profiles=tile_request.use_profiles, coverage=limit_to, decorate_img=decorate_img)

        tile_format = getattr(tile, 'format', tile_request.format)
        resp = Response(tile.as_buffer(), content_type='image/' + tile_format)
        if tile.cacheable:
            resp.cache_headers(tile.timestamp, etag_data=(tile.timestamp, tile.size),
                               max_age=self.max_tile_age)
        else:
            resp.cache_headers(no_cache=True)
        resp.make_conditional(tile_request.http)
        return resp

    def _internal_layer(self, tile_request):
        if '_layer_spec' in tile_request.dimensions:
            name = tile_request.layer + '_' + tile_request.dimensions['_layer_spec']
        else:
            name = tile_request.layer
        if name in self.layers:
            return self.layers[name]
        if name + '_EPSG900913' in self.layers:
            return self.layers[name + '_EPSG900913']
        if name + '_EPSG4326' in self.layers:
            return self.layers[name + '_EPSG4326']
        return None

    def _internal_dimension_layer(self, tile_request):
        key = (tile_request.layer, tile_request.dimensions.get('_layer_spec'))
        return self.layers.get(key)

    def layer(self, tile_request):
        if self.use_dimension_layers:
            internal_layer = self._internal_dimension_layer(tile_request)
        else:
            internal_layer = self._internal_layer(tile_request)
        if internal_layer is None:
            raise RequestError('unknown layer: ' + tile_request.layer, request=tile_request)

        limit_to = self.authorize_tile_layer(internal_layer, tile_request)
        return internal_layer, limit_to

    def authorize_tile_layer(self, tile_layer, request):
        if 'mapproxy.authorize' in request.http.environ:
            if request.tile:
                query_extent = (tile_layer.grid.srs.srs_code,
                    tile_layer.tile_bbox(request, use_profiles=request.use_profiles))
            else:
                query_extent = None # for layer capabilities
            result = request.http.environ['mapproxy.authorize']('tms', [tile_layer.name],
                query_extent=query_extent, environ=request.http.environ)
            if result['authorized'] == 'unauthenticated':
                raise RequestError('unauthorized', status=401)
            if result['authorized'] == 'full':
                return
            if result['authorized'] == 'partial':
                if result['layers'].get(tile_layer.name, {}).get('tile', False) == True:
                    limited_to = result['layers'][tile_layer.name].get('limited_to')
                    if not limited_to:
                        limited_to = result.get('limited_to')
                    if limited_to:
                        return load_limited_to(limited_to)
                    else:
                        return None
            raise RequestError('forbidden', status=403)

    def authorized_tile_layers(self, env):
        if 'mapproxy.authorize' in env:
            result = env['mapproxy.authorize']('tms', [l for l in self.layers],
                query_extent=None, environ=env)
            if result['authorized'] == 'unauthenticated':
                raise RequestError('unauthorized', status=401)
            if result['authorized'] == 'full':
                return self.layers
            if result['authorized'] == 'none':
                raise RequestError('forbidden', status=403)
            allowed_layers = odict()
            for layer in self.layers.itervalues():
                if result['layers'].get(layer.name, {}).get('tile', False) == True:
                    allowed_layers[layer.name] = layer
            return allowed_layers
        else:
            return self.layers

    def tms_capabilities(self, tms_request):
        """
        :return: the rendered tms capabilities
        :rtype: Response
        """
        service = self._service_md(tms_request)
        if hasattr(tms_request, 'layer'):
            layer, limit_to = self.layer(tms_request)
            result = self._render_layer_template(layer, service)
        else:
            layers = self.authorized_tile_layers(tms_request.http.environ)
            result = self._render_template(layers, service)

        return Response(result, mimetype='text/xml')

    def tms_root_resource(self, tms_request):
        """
        :return: root resource with all available versions of the service
        :rtype: Response
        """        
        service = self._service_md(tms_request)
        result = self._render_root_resource_template(service)
        return Response(result, mimetype='text/xml')

    def _service_md(self, map_request):
        md = dict(self.md)
        md['url'] = map_request.http.base_url
        return md

    def _render_template(self, layers, service):
        template = get_template(self.template_file)
        return template.substitute(service=bunch(default='', **service), layers=layers)

    def _render_layer_template(self, layer, service):
        template = get_template(self.layer_template_file)
        return template.substitute(service=bunch(default='', **service), layer=layer)

    def _render_root_resource_template(self, service):
        template = get_template(self.root_resource_template_file)
        return template.substitute(service=bunch(default='', **service))

class TileLayer(object):
    def __init__(self, name, title, md, tile_manager, dimensions=None):
        """
        :param md: the layer metadata
        :param tile_manager: the layer tile manager
        """
        self.name = name
        self.title = title
        self.md = md
        self.tile_manager = tile_manager
        self.dimensions = dimensions
        self.grid = TileServiceGrid(tile_manager.grid)
        self.extent = map_extent_from_grid(self.grid)
        self._empty_tile = None
        self._mixed_format = True if self.md.get('format', False) == 'mixed' else False
        self.empty_response_as_png = True

    @property
    def bbox(self):
        return self.grid.bbox

    @property
    def srs(self):
        return self.grid.srs

    @property
    def format(self):
        _mime_class, format, _options = split_mime_type(self.format_mime_type)
        return format

    @property
    def format_mime_type(self):
        # force png format for capabilities & requests if mixed format
        if self._mixed_format:
            return 'image/png'
        return self.md.get('format', 'image/png')

    def _internal_tile_coord(self, tile_request, use_profiles=False):
        tile_coord = self.grid.internal_tile_coord(tile_request.tile, use_profiles)
        if tile_coord is None:
            raise RequestError('The requested tile is outside the bounding box'
                               ' of the tile map.', request=tile_request,
                               code='TileOutOfRange')
        if tile_request.origin == 'nw' and self.grid.origin not in ('ul', 'nw'):
            tile_coord = self.grid.flip_tile_coord(tile_coord)
        elif tile_request.origin == 'sw' and self.grid.origin not in ('ll', 'sw', None):
            tile_coord = self.grid.flip_tile_coord(tile_coord)

        return tile_coord

    def empty_response(self):
        if self.empty_response_as_png:
            format = 'png'
        else:
            format = self.format
        if not self._empty_tile:
            img = BlankImageSource(size=self.grid.tile_size,
                image_opts=ImageOptions(format=format, transparent=True))
            self._empty_tile = img.as_buffer().read()
        return ImageResponse(self._empty_tile, format=format, timestamp=time.time())

    def tile_bbox(self, tile_request, use_profiles=False, limit=False):
        tile_coord = self._internal_tile_coord(tile_request, use_profiles=use_profiles)
        return self.grid.tile_bbox(tile_coord, limit=limit)

    def checked_dimensions(self, tile_request):
        dimensions = {}

        for dimension, values in self.dimensions.iteritems():
            value = tile_request.dimensions.get(dimension)
            if value in values:
                dimensions[dimension] = value
            elif not value or value == 'default':
                dimensions[dimension] = values.default
            else:
                raise RequestError('invalid dimension value (%s=%s).'
                    % (dimension, value), request=tile_request,
                       code='InvalidParameterValue')
        return dimensions

    def render(self, tile_request, use_profiles=False, coverage=None, decorate_img=None):
        if tile_request.format != self.format:
            raise RequestError('invalid format (%s). this tile set only supports (%s)'
                               % (tile_request.format, self.format), request=tile_request,
                               code='InvalidParameterValue')

        tile_coord = self._internal_tile_coord(tile_request, use_profiles=use_profiles)

        coverage_intersects = False
        if coverage:
            tile_bbox = self.grid.tile_bbox(tile_coord)
            if coverage.contains(tile_bbox, self.grid.srs):
                pass
            elif coverage.intersects(tile_bbox, self.grid.srs):
                coverage_intersects = True
            else:
                return self.empty_response()

        dimensions = self.checked_dimensions(tile_request)

        try:
            with self.tile_manager.session():
                tile = self.tile_manager.load_tile_coord(tile_coord,
                    dimensions=dimensions, with_metadata=True)
            if tile.source is None:
                return self.empty_response()

            # Provide the wrapping WSGI app or filter the opportunity to process the
            # image before it's wrapped up in a response
            if decorate_img:
                tile.source = decorate_img(tile.source)

            if coverage_intersects:
                if self.empty_response_as_png:
                    format = 'png'
                    image_opts = ImageOptions(transparent=True, format='png')
                else:
                    format = self.format
                    image_opts = tile.source.image_opts

                tile.source = mask_image_source_from_coverage(
                    tile.source, tile_bbox, self.grid.srs, coverage, image_opts)

                return TileResponse(tile, format=format, image_opts=image_opts)

            format = None if self._mixed_format else tile_request.format
            return TileResponse(tile, format=format, image_opts=self.tile_manager.image_opts)
        except SourceError, e:
            raise RequestError(e.args[0], request=tile_request, internal=True)

class ImageResponse(object):
    """
    Response from an image.
    """
    def __init__(self, img, format, timestamp):
        self.img = img
        self.timestamp = timestamp
        self.format = format
        self.size = 0
        self.cacheable = True

    def as_buffer(self):
        return self.img


class TileResponse(object):
    """
    Response from a Tile.
    """
    def __init__(self, tile, format=None, timestamp=None, image_opts=None):
        self.tile = tile
        self.timestamp = tile.timestamp
        self.size = tile.size
        self.cacheable = tile.cacheable
        self._buf = self.tile.source_buffer(format=format, image_opts=image_opts)
        self.format = format or self._format_from_magic_bytes()

    def as_buffer(self):
        return self._buf

    def _format_from_magic_bytes(self):
        #read the 2 magic bytes from the buffer
        magic_bytes = self._buf.read(2)
        self._buf.seek(0)
        if magic_bytes == '\xFF\xD8':
            return 'jpeg'
        return 'png'

class TileServiceGrid(object):
    """
    Wraps a `TileGrid` and adds some ``TileService`` specific methods.
    """
    def __init__(self, grid):
        self.grid = grid
        self.profile = None

        if self.grid.srs == SRS(900913) and self.grid.bbox == default_bboxs[SRS((900913))]:
            self.profile = 'global-mercator'
            self.srs_name = 'OSGEO:41001' # as required by TMS 1.0.0
            self._skip_first_level = True

        elif self.grid.srs == SRS(4326) and self.grid.bbox == default_bboxs[SRS((4326))]:
            self.profile = 'global-geodetic'
            self.srs_name = 'EPSG:4326'
            self._skip_first_level = True
        else:
            self.profile = 'local'
            self.srs_name = self.grid.srs.srs_code
            self._skip_first_level = False

        self._skip_odd_level = False

        res_factor = self.grid.resolutions[0]/self.grid.resolutions[1]
        if res_factor == math.sqrt(2):
            self._skip_odd_level = True

    def internal_level(self, level):
        """
        :return: the internal level
        """
        if self._skip_first_level:
            level += 1
            if self._skip_odd_level:
                level += 1
        if self._skip_odd_level:
            level *= 2
        return level

    @property
    def bbox(self):
        """
        :return: the bbox of all tiles of the first level
        """
        first_level = self.internal_level(0)
        grid_size = self.grid.grid_sizes[first_level]
        return self.grid._get_bbox([(0, 0, first_level),
                                    (grid_size[0]-1, grid_size[1]-1, first_level)])

    def __getattr__(self, key):
        return getattr(self.grid, key)

    @property
    def tile_sets(self):
        """
        Get all public tile sets for this layer.
        :return: the order and resolution of each tile set
        """
        tile_sets = []
        num_levels = self.grid.levels
        start = 0
        step = 1
        if self._skip_first_level:
            if self._skip_odd_level:
                start = 2
            else:
                start = 1
        if self._skip_odd_level:
            step = 2
        for order, level in enumerate(range(start, num_levels, step)):
            tile_sets.append((order, self.grid.resolutions[level]))
        return tile_sets

    def internal_tile_coord(self, tile_coord, use_profiles):
        """
        Converts public tile coords to internal tile coords.

        :param tile_coord: the public tile coord
        :param use_profiles: True if the tile service supports global
                             profiles (see `mapproxy.core.server.TileServer`)
        """
        x, y, z = tile_coord
        if z < 0:
            return None
        if use_profiles and self._skip_first_level:
            z += 1
        if self._skip_odd_level:
            z *= 2
        return self.grid.limit_tile((x, y, z))

    def external_tile_coord(self, tile_coord, use_profiles):
        """
        Converts internal tile coords to external tile coords.

        :param tile_coord: the internal tile coord
        :param use_profiles: True if the tile service supports global
                             profiles (see `mapproxy.core.server.TileServer`)
        """
        x, y, z = tile_coord
        if z < 0:
            return None
        if use_profiles and self._skip_first_level:
            z -= 1
        if self._skip_odd_level:
            z //= 2
        return (x, y, z)

########NEW FILE########
__FILENAME__ = wms
# This file is part of the MapProxy project.
# Copyright (C) 2010-2014 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
WMS service handler
"""
from itertools import chain
from functools import partial
from mapproxy.cache.tile import CacheInfo
from mapproxy.request.wms import (wms_request, WMS111LegendGraphicRequest,
    mimetype_from_infotype, infotype_from_mimetype, switch_bbox_epsg_axis_order)
from mapproxy.srs import SRS, TransformationError
from mapproxy.service.base import Server
from mapproxy.response import Response
from mapproxy.source import SourceError
from mapproxy.exception import RequestError
from mapproxy.image import bbox_position_in_image, SubImageSource, BlankImageSource
from mapproxy.image.merge import concat_legends, LayerMerger
from mapproxy.image.opts import ImageOptions
from mapproxy.image.message import attribution_image, message_image
from mapproxy.layer import BlankImage, MapQuery, InfoQuery, LegendQuery, MapError, LimitedLayer
from mapproxy.layer import MapBBOXError, merge_layer_extents, merge_layer_res_ranges
from mapproxy.util import async
from mapproxy.util.py import cached_property
from mapproxy.util.coverage import load_limited_to
from mapproxy.util.ext.odict import odict
from mapproxy.template import template_loader, bunch
from mapproxy.service import template_helper
from mapproxy.layer import DefaultMapExtent, MapExtent

get_template = template_loader(__name__, 'templates', namespace=template_helper.__dict__)


class PERMIT_ALL_LAYERS(object):
    pass

class WMSServer(Server):
    service = 'wms'
    fi_transformers = None

    def __init__(self, root_layer, md, srs, image_formats,
        request_parser=None, tile_layers=None, attribution=None,
        info_types=None, strict=False, on_error='raise',
        concurrent_layer_renderer=1, max_output_pixels=None,
        srs_extents=None, max_tile_age=None,
        versions=None):
        Server.__init__(self)
        self.request_parser = request_parser or partial(wms_request, strict=strict, versions=versions)
        self.root_layer = root_layer
        self.layers = root_layer.child_layers()
        self.tile_layers = tile_layers or {}
        self.strict = strict
        self.attribution = attribution
        self.md = md
        self.on_error = on_error
        self.concurrent_layer_renderer = concurrent_layer_renderer
        self.image_formats = image_formats
        self.info_types = info_types
        self.srs = srs
        self.srs_extents = srs_extents
        self.max_output_pixels = max_output_pixels
        self.max_tile_age = max_tile_age

    def map(self, map_request):
        self.check_map_request(map_request)

        params = map_request.params
        query = MapQuery(params.bbox, params.size, SRS(params.srs), params.format)

        if map_request.params.get('tiled', 'false').lower() == 'true':
            query.tiled_only = True
        orig_query = query

        if self.srs_extents and params.srs in self.srs_extents:
            # limit query to srs_extent if query is larger
            query_extent = MapExtent(params.bbox, SRS(params.srs))
            if not self.srs_extents[params.srs].contains(query_extent):
                limited_extent = self.srs_extents[params.srs].intersection(query_extent)
                if not limited_extent:
                    img_opts = self.image_formats[params.format_mime_type].copy()
                    img_opts.bgcolor = params.bgcolor
                    img_opts.transparent = params.transparent
                    img = BlankImageSource(size=params.size, image_opts=img_opts, cacheable=True)
                    return Response(img.as_buffer(), content_type=img_opts.format.mime_type)
                sub_size, offset, sub_bbox = bbox_position_in_image(params.bbox, params.size, limited_extent.bbox)
                query = MapQuery(sub_bbox, sub_size, SRS(params.srs), params.format)

        actual_layers = odict()
        for layer_name in map_request.params.layers:
            layer = self.layers[layer_name]
            # only add if layer renders the query
            if layer.renders_query(query):
                # if layer is not transparent and will be rendered,
                # remove already added (then hidden) layers
                if not layer.transparent:
                    actual_layers = odict()
                for layer_name, map_layers in layer.map_layers_for_query(query):
                    actual_layers[layer_name] = map_layers

        authorized_layers, coverage = self.authorized_layers('map', actual_layers.keys(),
            map_request.http.environ, query_extent=(query.srs.srs_code, query.bbox))

        self.filter_actual_layers(actual_layers, map_request.params.layers, authorized_layers)

        render_layers = []
        for layers in actual_layers.values():
            render_layers.extend(layers)

        self.update_query_with_fwd_params(query, params=params,
            layers=render_layers)

        raise_source_errors =  True if self.on_error == 'raise' else False
        renderer = LayerRenderer(render_layers, query, map_request,
                                 raise_source_errors=raise_source_errors,
                                 concurrent_rendering=self.concurrent_layer_renderer)

        merger = LayerMerger()
        renderer.render(merger)

        if self.attribution and not query.tiled_only:
            merger.add(attribution_image(self.attribution['text'], query.size))
        img_opts = self.image_formats[params.format_mime_type].copy()
        img_opts.bgcolor = params.bgcolor
        img_opts.transparent = params.transparent
        result = merger.merge(size=query.size, image_opts=img_opts,
            bbox=query.bbox, bbox_srs=params.srs, coverage=coverage)

        if query != orig_query:
            result = SubImageSource(result, size=orig_query.size, offset=offset, image_opts=img_opts)

        # Provide the wrapping WSGI app or filter the opportunity to process the
        # image before it's wrapped up in a response
        result = self.decorate_img(result, 'wms.map', actual_layers.keys(),
            map_request.http.environ, (query.srs.srs_code, query.bbox))

        try:
            result_buf = result.as_buffer(img_opts)
        except IOError, ex:
            raise RequestError('error while processing image file: %s' % ex,
                request=map_request)

        resp = Response(result_buf, content_type=img_opts.format.mime_type)

        if query.tiled_only and isinstance(result.cacheable, CacheInfo):
            cache_info = result.cacheable
            resp.cache_headers(cache_info.timestamp, etag_data=(cache_info.timestamp, cache_info.size),
                               max_age=self.max_tile_age)
            resp.make_conditional(map_request.http)

        if not result.cacheable:
            resp.cache_headers(no_cache=True)

        return resp

    def capabilities(self, map_request):
        # TODO: debug layer
        # if '__debug__' in map_request.params:
        #     layers = self.layers.values()
        # else:
        #     layers = [layer for name, layer in self.layers.iteritems()
        #               if name != '__debug__']

        if map_request.params.get('tiled', 'false').lower() == 'true':
            tile_layers = self.tile_layers.values()
        else:
            tile_layers = []

        service = self._service_md(map_request)
        root_layer = self.authorized_capability_layers(map_request.http.environ)

        info_types = ['text', 'html', 'xml'] # defaults
        if self.info_types:
            info_types = self.info_types
        elif self.fi_transformers:
            info_types = self.fi_transformers.keys()
        info_formats = [mimetype_from_infotype(map_request.version, info_type) for info_type in info_types]
        result = Capabilities(service, root_layer, tile_layers,
            self.image_formats, info_formats, srs=self.srs, srs_extents=self.srs_extents
            ).render(map_request)
        return Response(result, mimetype=map_request.mime_type)

    def featureinfo(self, request):
        infos = []
        self.check_featureinfo_request(request)

        p = request.params
        query = InfoQuery(p.bbox, p.size, SRS(p.srs), p.pos,
              p['info_format'], format=request.params.format or None,
              feature_count=p.get('feature_count'))

        actual_layers = odict()

        for layer_name in request.params.query_layers:
            layer = self.layers[layer_name]
            if not layer.queryable:
                raise RequestError('layer %s is not queryable' % layer_name, request=request)
            for layer_name, info_layers in layer.info_layers_for_query(query):
                actual_layers[layer_name] = info_layers

        authorized_layers, coverage = self.authorized_layers('featureinfo', actual_layers.keys(),
            request.http.environ, query_extent=(query.srs.srs_code, query.bbox))
        self.filter_actual_layers(actual_layers, request.params.layers, authorized_layers)

        # outside of auth-coverage
        if coverage and not coverage.contains(query.coord, query.srs):
            infos = []
        else:
            info_layers = []
            for layers in actual_layers.values():
                info_layers.extend(layers)

            for layer in info_layers:
                info = layer.get_info(query)
                if info is None:
                    continue
                infos.append(info)

        mimetype = None
        if 'info_format' in request.params:
            mimetype = request.params.info_format

        if not infos:
            return Response('', mimetype=mimetype)

        if self.fi_transformers:
            doc = infos[0].combine(infos)
            if doc.info_type == 'text':
                resp = doc.as_string()
                mimetype = 'text/plain'
            else:
                if not mimetype:
                    if 'xml' in self.fi_transformers:
                        info_type = 'xml'
                    elif 'html' in self.fi_transformers:
                        info_type = 'html'
                    else:
                        info_type = 'text'
                    mimetype = mimetype_from_infotype(request.version, info_type)
                else:
                    info_type = infotype_from_mimetype(request.version, mimetype)
                resp = self.fi_transformers[info_type](doc).as_string()
        else:
            mimetype = mimetype_from_infotype(request.version, infos[0].info_type)
            if len(infos) > 1:
                resp = infos[0].combine(infos).as_string()
            else:
                resp = infos[0].as_string()

        return Response(resp, mimetype=mimetype)

    def check_map_request(self, request):
        if self.max_output_pixels and \
            (request.params.size[0] * request.params.size[1]) > self.max_output_pixels:
            request.prevent_image_exception = True
            raise RequestError("image size too large", request=request)

        self.validate_layers(request)
        request.validate_format(self.image_formats)
        request.validate_srs(self.srs)

    def update_query_with_fwd_params(self, query, params, layers):
        # forward relevant request params into MapQuery.dimensions
        for layer in layers:
            if not hasattr(layer, 'fwd_req_params'):
                continue
            for p in layer.fwd_req_params:
                if p in params:
                    query.dimensions[p] = params[p]

    def check_featureinfo_request(self, request):
        self.validate_layers(request)
        request.validate_srs(self.srs)

    def validate_layers(self, request):
        query_layers = request.params.query_layers if hasattr(request, 'query_layers') else []
        for layer in chain(request.params.layers, query_layers):
            if layer not in self.layers:
                raise RequestError('unknown layer: ' + str(layer), code='LayerNotDefined',
                                   request=request)

    def check_legend_request(self, request):
        if request.params.layer not in self.layers:
            raise RequestError('unknown layer: ' + request.params.layer,
                               code='LayerNotDefined', request=request)

    #TODO: If layer not in self.layers raise RequestError
    def legendgraphic(self, request):
        legends = []
        self.check_legend_request(request)
        layer = request.params.layer
        if not self.layers[layer].has_legend:
            raise RequestError('layer %s has no legend graphic' % layer, request=request)
        legend = self.layers[layer].legend(request)

        [legends.append(i) for i in legend if i is not None]
        result = concat_legends(legends)
        if 'format' in request.params:
            mimetype = request.params.format_mime_type
        else:
            mimetype = 'image/png'
        img_opts = self.image_formats[request.params.format_mime_type]
        return Response(result.as_buffer(img_opts), mimetype=mimetype)

    def _service_md(self, map_request):
        md = dict(self.md)
        md['url'] = map_request.url
        md['has_legend'] = self.root_layer.has_legend
        return md

    def authorized_layers(self, feature, layers, env, query_extent):
        if 'mapproxy.authorize' in env:
            result = env['mapproxy.authorize']('wms.' + feature, layers[:],
                environ=env, query_extent=query_extent)
            if result['authorized'] == 'unauthenticated':
                raise RequestError('unauthorized', status=401)
            if result['authorized'] == 'full':
                return PERMIT_ALL_LAYERS, None
            layers = {}
            if result['authorized'] == 'partial':
                for layer_name, permissions in result['layers'].iteritems():
                    if permissions.get(feature, False) == True:
                        layers[layer_name] = permissions.get('limited_to')
            limited_to = result.get('limited_to')
            if limited_to:
                coverage = load_limited_to(limited_to)
            else:
                coverage = None
            return layers, coverage
        else:
            return PERMIT_ALL_LAYERS, None

    def filter_actual_layers(self, actual_layers, requested_layers, authorized_layers):
        if authorized_layers is not PERMIT_ALL_LAYERS:
            requested_layer_names = set(requested_layers)
            for layer_name in actual_layers.keys():
                if layer_name not in authorized_layers:
                    # check whether layer was requested explicit...
                    if layer_name in requested_layer_names:
                        raise RequestError('forbidden', status=403)
                    # or implicit (part of group layer)
                    else:
                        del actual_layers[layer_name]
                elif authorized_layers[layer_name] is not None:
                    limited_to = load_limited_to(authorized_layers[layer_name])
                    actual_layers[layer_name] = [LimitedLayer(lyr, limited_to) for lyr in actual_layers[layer_name]]

    def authorized_capability_layers(self, env):
        if 'mapproxy.authorize' in env:
            result = env['mapproxy.authorize']('wms.capabilities', self.layers.keys(), environ=env)
            if result['authorized'] == 'unauthenticated':
                raise RequestError('unauthorized', status=401)
            if result['authorized'] == 'full':
                return self.root_layer
            if result['authorized'] == 'partial':
                limited_to = result.get('limited_to')
                if limited_to:
                    coverage = load_limited_to(limited_to)
                else:
                    coverage = None
                return FilteredRootLayer(self.root_layer, result['layers'], coverage=coverage)
            raise RequestError('forbidden', status=403)
        else:
            return self.root_layer

class FilteredRootLayer(object):
    def __init__(self, root_layer, permissions, coverage=None):
        self.root_layer = root_layer
        self.permissions = permissions
        self.coverage = coverage

    def __getattr__(self, name):
        return getattr(self.root_layer, name)

    @cached_property
    def extent(self):
        layer_name = self.root_layer.name
        limited_to = self.permissions.get(layer_name, {}).get('limited_to')
        extent = self.root_layer.extent

        if limited_to:
            coverage = load_limited_to(limited_to)
            limited_coverage = coverage.intersection(extent.bbox, extent.srs)
            extent = limited_coverage.extent

        if self.coverage:
            limited_coverage = self.coverage.intersection(extent.bbox, extent.srs)
            extent = limited_coverage.extent
        return extent

    @property
    def queryable(self):
        if not self.root_layer.queryable: return False

        layer_name = self.root_layer.name
        if not layer_name or self.permissions.get(layer_name, {}).get('featureinfo', False):
            return True
        return False

    def layer_permitted(self, layer):
        if not self.permissions.get(layer.name, {}).get('map', False):
            return False
        extent = layer.extent

        limited_to = self.permissions.get(layer.name, {}).get('limited_to')
        if limited_to:
            coverage = load_limited_to(limited_to)
            if not coverage.intersects(extent.bbox, extent.srs):
                return False

        if self.coverage:
            if not self.coverage.intersects(extent.bbox, extent.srs):
                return False
        return True

    @cached_property
    def layers(self):
        layers = []
        for layer in self.root_layer.layers:
            if not layer.name or self.layer_permitted(layer):
                filtered_layer = FilteredRootLayer(layer, self.permissions, self.coverage)
                if filtered_layer.is_active or filtered_layer.layers:
                    # add filtered_layer only if it is active (no grouping layer)
                    # or if it contains other active layers
                    layers.append(filtered_layer)
        return layers

DEFAULT_EXTENTS = {
    'EPSG:3857': DefaultMapExtent(),
    'EPSG:4326': DefaultMapExtent(),
    'EPSG:900913': DefaultMapExtent(),
}

def limit_srs_extents(srs_extents, supported_srs):
    """
    Limit srs_extents to supported_srs.
    """
    if srs_extents:
        srs_extents = srs_extents.copy()
    else:
        srs_extents = DEFAULT_EXTENTS.copy()

    for srs in srs_extents.keys():
        if srs not in supported_srs:
            srs_extents.pop(srs)

    return srs_extents

class Capabilities(object):
    """
    Renders WMS capabilities documents.
    """
    def __init__(self, server_md, layers, tile_layers, image_formats, info_formats,
        srs, srs_extents=None, epsg_axis_order=False):
        self.service = server_md
        self.layers = layers
        self.tile_layers = tile_layers
        self.image_formats = image_formats
        self.info_formats = info_formats
        self.srs = srs
        self.srs_extents = limit_srs_extents(srs_extents, srs)

    def layer_srs_bbox(self, layer, epsg_axis_order=False):
        layer_srs_code = layer.extent.srs.srs_code
        for srs, extent in self.srs_extents.iteritems():
            if extent.is_default:
                bbox = layer.extent.bbox_for(SRS(srs))
            else:
                bbox = extent.bbox_for(SRS(srs))

            if epsg_axis_order:
                bbox = switch_bbox_epsg_axis_order(bbox, srs)
            yield srs, bbox

        # add native srs
        if layer_srs_code not in self.srs_extents:
            bbox = layer.extent.bbox
            if epsg_axis_order:
                bbox = switch_bbox_epsg_axis_order(bbox, layer_srs_code)
            yield layer_srs_code, bbox

    def render(self, _map_request):
        return self._render_template(_map_request.capabilities_template)

    def _render_template(self, template):
        template = get_template(template)
        doc = template.substitute(service=bunch(default='', **self.service),
                                   layers=self.layers,
                                   formats=self.image_formats,
                                   info_formats=self.info_formats,
                                   srs=self.srs,
                                   tile_layers=self.tile_layers,
                                   layer_srs_bbox=self.layer_srs_bbox,
        )
        # strip blank lines
        doc = '\n'.join(l for l in doc.split('\n') if l.rstrip())
        return doc

class LayerRenderer(object):
    def __init__(self, layers, query, request, raise_source_errors=True,
                 concurrent_rendering=1):
        self.layers = layers
        self.query = query
        self.request = request
        self.raise_source_errors = raise_source_errors
        self.concurrent_rendering = concurrent_rendering

    def render(self, layer_merger):
        render_layers = combined_layers(self.layers, self.query)
        if not render_layers: return

        async_pool = async.Pool(size=min(len(render_layers), self.concurrent_rendering))

        if self.raise_source_errors:
            return self._render_raise_exceptions(async_pool, render_layers, layer_merger)
        else:
            return self._render_capture_source_errors(async_pool, render_layers,
                                                      layer_merger)

    def _render_raise_exceptions(self, async_pool, render_layers, layer_merger):
        # call _render_layer, raise all exceptions
        try:
            for layer_task in async_pool.imap(self._render_layer, render_layers,
                                              use_result_objects=True):
                if layer_task.exception is None:
                    layer, layer_img = layer_task.result
                    if layer_img is not None:
                        layer_merger.add(layer_img, layer=layer)
                else:
                    ex = layer_task.exception
                    async_pool.shutdown(True)
                    raise ex[0], ex[1], ex[2]
        except SourceError, ex:
            raise RequestError(ex.args[0], request=self.request)

    def _render_capture_source_errors(self, async_pool, render_layers, layer_merger):
        # call _render_layer, capture SourceError exceptions
        errors = []
        rendered = 0

        for layer_task in async_pool.imap(self._render_layer, render_layers,
                                          use_result_objects=True):
            if layer_task.exception is None:
                layer, layer_img = layer_task.result
                if layer_img is not None:
                    layer_merger.add(layer_img, layer=layer)
                rendered += 1
            else:
                layer_merger.cacheable = False
                ex = layer_task.exception
                if isinstance(ex[1], SourceError):
                    errors.append(ex[1].args[0])
                else:
                    async_pool.shutdown(True)
                    raise ex[0], ex[1], ex[2]

        if render_layers and not rendered:
            errors = '\n'.join(errors)
            raise RequestError('Could not get any sources:\n'+errors, request=self.request)

        if errors:
            layer_merger.add(message_image('\n'.join(errors), self.query.size,
                image_opts=ImageOptions(transparent=True)))

    def _render_layer(self, layer):
        try:
            layer_img = layer.get_map(self.query)
            if layer_img is not None:
                layer_img.opacity = layer.opacity

            return layer, layer_img
        except SourceError:
            raise
        except MapBBOXError:
            raise RequestError('Request too large or invalid BBOX.', request=self.request)
        except MapError, e:
            raise RequestError('Invalid request: %s' % e.args[0], request=self.request)
        except TransformationError:
            raise RequestError('Could not transform BBOX: Invalid result.',
                request=self.request)
        except BlankImage:
            return layer, None

class WMSLayerBase(object):
    """
    Base class for WMS layer (layer groups and leaf layers).
    """

    "True if layer is an actual layer (not a group only)"
    is_active = True

    "list of sublayers"
    layers = []

    "metadata dictionary with tile, name, etc."
    md = {}

    "True if .info() is supported"
    queryable = False

    transparent = False

    "True is .legend() is supported"
    has_legend = False
    legend_url = None
    legend_size = None

    "resolution range (i.e. ScaleHint) of the layer"
    res_range = None
    "MapExtend of the layer"
    extent = None

    def is_opaque(self):
        return not self.transparent

    def map_layers_for_query(self, query):
        raise NotImplementedError()

    def legend(self, query):
        raise NotImplementedError()

    def info(self, query):
        raise NotImplementedError()

class WMSLayer(WMSLayerBase):
    """
    Class for WMS layers.

    Combines map, info and legend sources with metadata.
    """
    is_active = True
    layers = []
    def __init__(self, name, title, map_layers, info_layers=[], legend_layers=[],
                 res_range=None, md=None):
        self.name = name
        self.title = title
        self.md = md or {}
        self.map_layers = map_layers
        self.info_layers = info_layers
        self.legend_layers = legend_layers
        self.extent = merge_layer_extents(map_layers)
        if res_range is None:
            res_range = merge_layer_res_ranges(map_layers)
        self.res_range = res_range
        self.queryable = True if info_layers else False
        self.transparent = all(not map_lyr.is_opaque() for map_lyr in self.map_layers)
        self.has_legend = True if legend_layers else False

    def renders_query(self, query):
        if self.res_range and not self.res_range.contains(query.bbox, query.size, query.srs):
            return False
        return True

    def map_layers_for_query(self, query):
        if not self.map_layers:
            return []
        return [(self.name, self.map_layers)]

    def info_layers_for_query(self, query):
        if not self.info_layers:
            return []
        return [(self.name, self.info_layers)]

    def legend(self, request):
        p = request.params
        query = LegendQuery(p.format, p.scale)

        for lyr in self.legend_layers:
            yield lyr.get_legend(query)

    @property
    def legend_size(self):
        width = 0
        height = 0
        for layer in self.legend_layers:
            width = max(layer.size[0], width)
            height += layer.size[1]
        return (width, height)

    @property
    def legend_url(self):
        if self.has_legend:
            req = WMS111LegendGraphicRequest(url='?',
                param=dict(format='image/png', layer=self.name, sld_version='1.1.0'))
            return req.complete_url
        else:
            return None

class WMSGroupLayer(WMSLayerBase):
    """
    Class for WMS group layers.

    Groups multiple wms layers, but can also contain a single layer (``this``)
    that represents this layer.
    """
    def __init__(self, name, title, this, layers, md=None):
        self.name = name
        self.title = title
        self.this = this
        self.md = md or {}
        self.is_active = True if this is not None else False
        self.layers = layers
        self.transparent = True if this and not this.is_opaque() or all(not l.is_opaque() for l in layers) else False
        self.has_legend = True if this and this.has_legend or any(l.has_legend for l in layers) else False
        self.queryable = True if this and this.queryable or any(l.queryable for l in layers) else False
        all_layers = layers + ([self.this] if self.this else [])
        self.extent = merge_layer_extents(all_layers)
        self.res_range = merge_layer_res_ranges(all_layers)

    @property
    def legend_size(self):
        return self.this.legend_size

    @property
    def legend_url(self):
        return self.this.legend_url

    def renders_query(self, query):
        if self.res_range and not self.res_range.contains(query.bbox, query.size, query.srs):
            return False
        return True

    def map_layers_for_query(self, query):
        if self.this:
            return self.this.map_layers_for_query(query)
        else:
            layers = []
            for layer in self.layers:
                layers.extend(layer.map_layers_for_query(query))
            return layers

    def info_layers_for_query(self, query):
        if self.this:
            return self.this.info_layers_for_query(query)
        else:
            layers = []
            for layer in self.layers:
                layers.extend(layer.info_layers_for_query(query))
            return layers

    def child_layers(self):
        layers = odict()
        if self.name:
            layers[self.name] = self
        for lyr in self.layers:
            if hasattr(lyr, 'child_layers'):
                layers.update(lyr.child_layers())
            elif lyr.name:
                layers[lyr.name] = lyr
        return layers


def combined_layers(layers, query):
    """
    Returns a new list of the layers where all adjacent layers are combined
    if possible.
    """
    if len(layers) <= 1:
        return layers
    layers = layers[:]
    combined_layers = [layers.pop(0)]
    while layers:
        current_layer = layers.pop(0)
        combined = combined_layers[-1].combined_layer(current_layer, query)
        if combined:
            # change last layer with combined
            combined_layers[-1] = combined
        else:
            combined_layers.append(current_layer)
    return combined_layers

########NEW FILE########
__FILENAME__ = wmts
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
WMS service handler
"""

from functools import partial

from mapproxy.request.wmts import (
    wmts_request, make_wmts_rest_request_parser,
    URLTemplateConverter,
)
from mapproxy.service.base import Server
from mapproxy.response import Response
from mapproxy.exception import RequestError
from mapproxy.util.coverage import load_limited_to

from mapproxy.template import template_loader, bunch
env = {'bunch': bunch}
get_template = template_loader(__name__, 'templates', namespace=env)

import logging
log = logging.getLogger(__name__)

class WMTSServer(Server):
    service = 'wmts'

    def __init__(self, layers, md, request_parser=None, max_tile_age=None):
        Server.__init__(self)
        self.request_parser = request_parser or wmts_request
        self.md = md
        self.max_tile_age = max_tile_age
        self.layers, self.matrix_sets = self._matrix_sets(layers)
        self.capabilities_class = Capabilities

    def _matrix_sets(self, layers):
        sets = {}
        layers_grids = {}
        for layer in layers.values():
            grid = layer.grid
            if not grid.supports_access_with_origin('nw'):
                log.warn("skipping layer '%s' for WMTS, grid '%s' of cache '%s' is not compatible with WMTS",
                    layer.name, grid.name, layer.md['cache_name'])
                continue
            if grid.name not in sets:
                try:
                    sets[grid.name] = TileMatrixSet(grid)
                except AssertionError:
                    continue # TODO
            layers_grids.setdefault(layer.name, {})[grid.name] = layer
        wmts_layers = {}
        for layer_name, layers in layers_grids.items():
            wmts_layers[layer_name] = WMTSTileLayer(layers)
        return wmts_layers, sets.values()

    def capabilities(self, request):
        service = self._service_md(request)
        layers = self.authorized_tile_layers(request.http.environ)
        result = self.capabilities_class(service, layers, self.matrix_sets).render(request)
        return Response(result, mimetype='application/xml')

    def tile(self, request):
        self.check_request(request)

        tile_layer = self.layers[request.layer][request.tilematrixset]
        if not request.format:
            request.format = tile_layer.format

        self.check_request_dimensions(tile_layer, request)

        limited_to = self.authorize_tile_layer(tile_layer, request)

        def decorate_img(image):
            query_extent = tile_layer.grid.srs.srs_code, tile_layer.tile_bbox(request)
            return self.decorate_img(image, 'wmts', [tile_layer.name], request.http.environ, query_extent)

        tile = tile_layer.render(request, coverage=limited_to, decorate_img=decorate_img)

        # set the content_type to tile.format and not to request.format ( to support mixed_mode)
        resp = Response(tile.as_buffer(), content_type='image/' + tile.format)
        resp.cache_headers(tile.timestamp, etag_data=(tile.timestamp, tile.size),
                           max_age=self.max_tile_age)
        resp.make_conditional(request.http)
        return resp

    def authorize_tile_layer(self, tile_layer, request):
        if 'mapproxy.authorize' in request.http.environ:
            query_extent = tile_layer.grid.srs.srs_code, tile_layer.tile_bbox(request)
            result = request.http.environ['mapproxy.authorize']('wmts', [tile_layer.name],
                query_extent=query_extent, environ=request.http.environ)
            if result['authorized'] == 'unauthenticated':
                raise RequestError('unauthorized', status=401)
            if result['authorized'] == 'full':
                return
            if result['authorized'] == 'partial':
                if result['layers'].get(tile_layer.name, {}).get('tile', False) == True:
                    limited_to = result['layers'][tile_layer.name].get('limited_to')
                    if not limited_to:
                        limited_to = result.get('limited_to')
                    if limited_to:
                        return load_limited_to(limited_to)
                    else:
                        return None
            raise RequestError('forbidden', status=403)

    def authorized_tile_layers(self, env):
        if 'mapproxy.authorize' in env:
            result = env['mapproxy.authorize']('wmts', [l for l in self.layers],
                query_extent=None, environ=env)
            if result['authorized'] == 'unauthenticated':
                raise RequestError('unauthorized', status=401)
            if result['authorized'] == 'full':
                return self.layers.values()
            if result['authorized'] == 'none':
                raise RequestError('forbidden', status=403)
            allowed_layers = []
            for layer in self.layers.itervalues():
                if result['layers'].get(layer.name, {}).get('tile', False) == True:
                    allowed_layers.append(layer)
            return allowed_layers
        else:
            return self.layers.values()

    def check_request(self, request):
        request.make_tile_request()
        if request.layer not in self.layers:
            raise RequestError('unknown layer: ' + str(request.layer),
                code='InvalidParameterValue', request=request)
        if request.tilematrixset not in self.layers[request.layer]:
            raise RequestError('unknown tilematrixset: ' + str(request.tilematrixset),
                code='InvalidParameterValue', request=request)

    def check_request_dimensions(self, tile_layer, request):
        # allow arbitrary dimensions in KVP service
        # actual used values are checked later in TileLayer
        pass

    def _service_md(self, tile_request):
        md = dict(self.md)
        md['url'] = tile_request.url
        return md


class WMTSRestServer(WMTSServer):
    """
    OGC WMTS 1.0.0 RESTful Server
    """
    service = None
    names = ('wmts',)
    request_methods = ('tile', 'capabilities')
    default_template = '/{Layer}/{TileMatrixSet}/{TileMatrix}/{TileCol}/{TileRow}.{Format}'

    def __init__(self, layers, md, max_tile_age=None, template=None):
        WMTSServer.__init__(self, layers, md)
        self.max_tile_age = max_tile_age
        self.template = template or self.default_template
        self.url_converter = URLTemplateConverter(self.template)
        self.request_parser = make_wmts_rest_request_parser(self.url_converter)
        self.capabilities_class = partial(RestfulCapabilities, url_converter=self.url_converter)

    def check_request_dimensions(self, tile_layer, request):
        # check that unknown dimension for this layer are set to default
        if request.dimensions:
            for dimension, value in request.dimensions.iteritems():
                dimension = dimension.lower()
                if dimension not in tile_layer.dimensions and value != 'default':
                    raise RequestError('unknown dimension: ' + str(dimension),
                        code='InvalidParameterValue', request=request)


class Capabilities(object):
    """
    Renders WMS capabilities documents.
    """
    def __init__(self, server_md, layers, matrix_sets):
        self.service = server_md
        self.layers = layers
        self.matrix_sets = matrix_sets

    def render(self, _map_request):
        return self._render_template(_map_request.capabilities_template)

    def template_context(self):
        return dict(service=bunch(default='', **self.service),
                    restful=False,
                    layers=self.layers,
                    tile_matrix_sets=self.matrix_sets)

    def _render_template(self, template):
        template = get_template(template)
        doc = template.substitute(**self.template_context())
        # strip blank lines
        doc = '\n'.join(l for l in doc.split('\n') if l.rstrip())
        return doc

class RestfulCapabilities(Capabilities):
    def __init__(self, server_md, layers, matrix_sets, url_converter):
        Capabilities.__init__(self, server_md, layers, matrix_sets)
        self.url_converter = url_converter

    def template_context(self):
        return dict(service=bunch(default='', **self.service),
                    restful=True,
                    layers=self.layers,
                    tile_matrix_sets=self.matrix_sets,
                    resource_template=self.url_converter.template,
                    # dimension_key maps lowercase dimensions to the actual
                    # casing from the restful template
                    dimension_keys=dict((k.lower(), k) for k in self.url_converter.dimensions),
                    format_resource_template=format_resource_template,
                    )

def format_resource_template(layer, template, service):
    # TODO: remove {{Format}} in 1.6
    if '{{Format}}' in template:
        template = template.replace('{{Format}}', layer.format)
    if '{Format}' in template:
        template = template.replace('{Format}', layer.format)

    if '{Layer}' in template:
        template = template.replace('{Layer}', layer.name)

    return service.url + template

class WMTSTileLayer(object):
    """
    Wrap multiple TileLayers for the same cache but with different grids.
    """
    def __init__(self, layers):
        self.grids = [lyr.grid for lyr in layers.values()]
        self.layers = layers
        self._layer = layers[layers.keys()[0]]

    def __getattr__(self, name):
        return getattr(self._layer, name)

    def __contains__(self, gridname):
        return gridname in self.layers

    def __getitem__(self, gridname):
        return self.layers[gridname]


from mapproxy.grid import tile_grid

# calculated from well-known scale set GoogleCRS84Quad
METERS_PER_DEEGREE = 111319.4907932736

def meter_per_unit(srs):
    if srs.is_latlong:
        return METERS_PER_DEEGREE
    return 1

class TileMatrixSet(object):
    def __init__(self, grid):
        self.grid = grid
        self.name = grid.name
        self.srs_name = grid.srs.srs_code
        self.tile_matrices = list(self._tile_matrices())

    def __iter__(self):
        return iter(self.tile_matrices)

    def _tile_matrices(self):
        for level, res in self.grid.resolutions.iteritems():
            origin = self.grid.origin_tile(level, 'ul')
            bbox = self.grid.tile_bbox(origin)
            grid_size = self.grid.grid_sizes[level]
            scale_denom = res / (0.28 / 1000) * meter_per_unit(self.grid.srs)
            yield bunch(
                identifier=level,
                bbox=bbox,
                grid_size=grid_size,
                scale_denom=scale_denom,
                tile_size=self.grid.tile_size,
            )

if __name__ == '__main__':
    print TileMatrixSet(tile_grid(900913)).tile_matrixes()
    print TileMatrixSet(tile_grid(4326, origin='ul')).tile_matrixes()

########NEW FILE########
__FILENAME__ = error
# This file is part of the MapProxy project.
# Copyright (C) 2012 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from mapproxy.image.opts import ImageOptions
from mapproxy.image import BlankImageSource

class HTTPSourceErrorHandler(object):
	def __init__(self):
		self.response_error_codes = {}
	
	def add_handler(self, http_code, color, cacheable=False):
		self.response_error_codes[http_code] = (color, cacheable)

	def handle(self, status_code, query):
		color = cacheable = None
		if status_code in self.response_error_codes:
			color, cacheable = self.response_error_codes[status_code]
		elif 'other' in self.response_error_codes:
			color, cacheable = self.response_error_codes['other']
		else:
			return None

		transparent = len(color) == 4
		image_opts = ImageOptions(bgcolor=color, transparent=transparent)
		img_source = BlankImageSource(query.size, image_opts, cacheable=cacheable)
		return img_source
########NEW FILE########
__FILENAME__ = mapnik
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, absolute_import

import sys
import time
import threading
from cStringIO import StringIO

from mapproxy.grid import tile_grid
from mapproxy.image import ImageSource
from mapproxy.image.opts import ImageOptions
from mapproxy.layer import MapExtent, DefaultMapExtent, BlankImage, MapLayer
from mapproxy.source import  SourceError
from mapproxy.client.log import log_request
from mapproxy.util.py import reraise_exception
from mapproxy.util.async import run_non_blocking

try:
    import mapnik
    mapnik
except ImportError:
    try:
        # for 2.0 alpha/rcs and first 2.0 release
        import mapnik2 as mapnik
    except ImportError:
        mapnik = None

# fake 2.0 API for older versions
if mapnik and not hasattr(mapnik, 'Box2d'):
    mapnik.Box2d = mapnik.Envelope

import logging
log = logging.getLogger(__name__)

class MapnikSource(MapLayer):
    supports_meta_tiles = True
    def __init__(self, mapfile, layers=None, image_opts=None, coverage=None,
        res_range=None, lock=None, reuse_map_objects=False):
        MapLayer.__init__(self, image_opts=image_opts)
        self.mapfile = mapfile
        self.coverage = coverage
        self.res_range = res_range
        self.layers = set(layers) if layers else None
        self.lock = lock
        self._map_objs = {}
        self._map_objs_lock = threading.Lock()
        self._cache_map_obj = reuse_map_objects
        if self.coverage:
            self.extent = MapExtent(self.coverage.bbox, self.coverage.srs)
        else:
            self.extent = DefaultMapExtent()

    def get_map(self, query):
        if self.res_range and not self.res_range.contains(query.bbox, query.size,
                                                          query.srs):
            raise BlankImage()
        if self.coverage and not self.coverage.intersects(query.bbox, query.srs):
            raise BlankImage()

        try:
            resp = self.render(query)
        except RuntimeError, ex:
            log.error('could not render Mapnik map: %s', ex)
            reraise_exception(SourceError(ex.args[0]), sys.exc_info())
        resp.opacity = self.opacity
        return resp

    def render(self, query):
        mapfile = self.mapfile
        if '%(webmercator_level)' in mapfile:
            _bbox, level = tile_grid(3857).get_affected_bbox_and_level(
                query.bbox, query.size, req_srs=query.srs)
            mapfile = mapfile % {'webmercator_level': level}

        if self.lock:
            with self.lock():
                return self.render_mapfile(mapfile, query)
        else:
            return self.render_mapfile(mapfile, query)

    def map_obj(self, mapfile):
        if not self._cache_map_obj:
            m = mapnik.Map(0, 0)
            mapnik.load_map(m, str(mapfile))
            return m

        # cache loaded map objects
        # only works when a single proc/thread accesses this object
        # (forking the render process doesn't work because of open database
        #  file handles that gets passed to the child)
        if mapfile not in self._map_objs:
            with self._map_objs_lock:
                if mapfile not in self._map_objs:
                    m = mapnik.Map(0, 0)
                    mapnik.load_map(m, str(mapfile))
                    self._map_objs[mapfile] = m

        return self._map_objs[mapfile]

    def render_mapfile(self, mapfile, query):
        return run_non_blocking(self._render_mapfile, (mapfile, query))

    def _render_mapfile(self, mapfile, query):
        start_time = time.time()

        m = self.map_obj(mapfile)
        m.resize(query.size[0], query.size[1])
        m.srs = '+init=%s' % str(query.srs.srs_code.lower())
        envelope = mapnik.Box2d(*query.bbox)
        m.zoom_to_box(envelope)
        data = None

        try:
            if self.layers:
                i = 0
                for layer in m.layers[:]:
                    if layer.name != 'Unkown' and layer.name not in self.layers:
                        del m.layers[i]
                    else:
                        i += 1

            img = mapnik.Image(query.size[0], query.size[1])
            mapnik.render(m, img)
            data = img.tostring(str(query.format))
        finally:
            size = None
            if data:
                size = len(data)
            log_request('%s:%s:%s:%s' % (mapfile, query.bbox, query.srs.srs_code, query.size),
                status='200' if data else '500', size=size, method='API', duration=time.time()-start_time)

        return ImageSource(StringIO(data), size=query.size,
            image_opts=ImageOptions(transparent=self.transparent, format=query.format))

########NEW FILE########
__FILENAME__ = tile
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Retrieve tiles from different tile servers (TMS/TileCache/etc.).
"""

import sys
from mapproxy.image.opts import ImageOptions
from mapproxy.source import SourceError
from mapproxy.client.http import HTTPClientError
from mapproxy.source import InvalidSourceQuery
from mapproxy.layer import BlankImage, map_extent_from_grid, CacheMapLayer, MapLayer
from mapproxy.util.py import reraise_exception

import logging
log = logging.getLogger('mapproxy.source.tile')
log_config = logging.getLogger('mapproxy.config')

class TiledSource(MapLayer):
    def __init__(self, grid, client, coverage=None, image_opts=None, error_handler=None,
        res_range=None):
        MapLayer.__init__(self, image_opts=image_opts)
        self.grid = grid
        self.client = client
        self.image_opts = image_opts or ImageOptions()
        self.coverage = coverage
        self.extent = coverage.extent if coverage else map_extent_from_grid(grid)
        self.res_range = res_range
        self.error_handler = error_handler

    def get_map(self, query):
        if self.grid.tile_size != query.size:
            ex = InvalidSourceQuery(
                'tile size of cache and tile source do not match: %s != %s'
                 % (self.grid.tile_size, query.size)
            )
            log_config.error(ex)
            raise ex

        if self.grid.srs != query.srs:
            ex = InvalidSourceQuery(
                'SRS of cache and tile source do not match: %r != %r'
                % (self.grid.srs, query.srs)
            )
            log_config.error(ex)
            raise ex

        if self.res_range and not self.res_range.contains(query.bbox, query.size,
                                                          query.srs):
            raise BlankImage()
        if self.coverage and not self.coverage.intersects(query.bbox, query.srs):
            raise BlankImage()

        _bbox, grid, tiles = self.grid.get_affected_tiles(query.bbox, query.size)

        if grid != (1, 1):
            raise InvalidSourceQuery('BBOX does not align to tile')

        tile_coord = tiles.next()

        try:
            return self.client.get_tile(tile_coord, format=query.format)
        except HTTPClientError, e:
            if self.error_handler:
                resp = self.error_handler.handle(e.response_code, query)
                if resp:
                    return resp
            log.warn('could not retrieve tile: %s', e)
            reraise_exception(SourceError(e.args[0]), sys.exc_info())

class CacheSource(CacheMapLayer):
    def __init__(self, tile_manager, extent=None, image_opts=None,
        max_tile_limit=None, tiled_only=False):
        CacheMapLayer.__init__(self, tile_manager, extent=extent, image_opts=image_opts,
            max_tile_limit=max_tile_limit)
        self.supports_meta_tiles = not tiled_only
        self.tiled_only = tiled_only

    def get_map(self, query):
        if self.tiled_only:
            query.tiled_only = True
        return CacheMapLayer.get_map(self, query)


########NEW FILE########
__FILENAME__ = wms
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Retrieve maps/information from WMS servers.
"""
import sys
from mapproxy.request.base import split_mime_type
from mapproxy.cache.legend import Legend, legend_identifier
from mapproxy.image import make_transparent, ImageSource, SubImageSource, bbox_position_in_image
from mapproxy.image.merge import concat_legends
from mapproxy.image.transform import ImageTransformer
from mapproxy.layer import MapExtent, DefaultMapExtent, BlankImage, LegendQuery, MapQuery, MapLayer
from mapproxy.source import InfoSource, SourceError, LegendSource
from mapproxy.client.http import HTTPClientError
from mapproxy.util.py import reraise_exception

import logging
log = logging.getLogger('mapproxy.source.wms')

class WMSSource(MapLayer):
    supports_meta_tiles = True
    def __init__(self, client, image_opts=None, coverage=None, res_range=None,
                 transparent_color=None, transparent_color_tolerance=None,
                 supported_srs=None, supported_formats=None, fwd_req_params=None):
        MapLayer.__init__(self, image_opts=image_opts)
        self.client = client
        self.supported_srs = supported_srs or []
        self.supported_formats = supported_formats or []
        self.fwd_req_params = fwd_req_params or set()

        self.transparent_color = transparent_color
        self.transparent_color_tolerance = transparent_color_tolerance
        if self.transparent_color:
            self.transparent = True
        self.coverage = coverage
        self.res_range = res_range
        if self.coverage:
            self.extent = MapExtent(self.coverage.bbox, self.coverage.srs)
        else:
            self.extent = DefaultMapExtent()

    def get_map(self, query):
        if self.res_range and not self.res_range.contains(query.bbox, query.size,
                                                          query.srs):
            raise BlankImage()
        if self.coverage and not self.coverage.intersects(query.bbox, query.srs):
            raise BlankImage()
        try:
            resp = self._get_map(query)
            if self.transparent_color:
                resp = make_transparent(resp, self.transparent_color,
                                        self.transparent_color_tolerance)
            resp.opacity = self.opacity
            return resp

        except HTTPClientError, e:
            log.warn('could not retrieve WMS map: %s', e)
            reraise_exception(SourceError(e.args[0]), sys.exc_info())

    def _get_map(self, query):
        format = self.image_opts.format
        if not format:
            format = query.format
        if self.supported_formats and format not in self.supported_formats:
            format = self.supported_formats[0]
        if self.supported_srs:
            if query.srs not in self.supported_srs:
                return self._get_transformed(query, format)
            # some srs are equal but not the same (e.g. 900913/3857)
            # use only supported srs so we use the right srs code.
            idx = self.supported_srs.index(query.srs)
            if self.supported_srs[idx] is not query.srs:
                query.srs = self.supported_srs[idx]
        if self.extent and not self.extent.contains(MapExtent(query.bbox, query.srs)):
            return self._get_sub_query(query, format)
        resp = self.client.retrieve(query, format)
        return ImageSource(resp, size=query.size, image_opts=self.image_opts)

    def _get_sub_query(self, query, format):
        size, offset, bbox = bbox_position_in_image(query.bbox, query.size, self.extent.bbox_for(query.srs))
        if size[0] == 0 or size[1] == 0:
            raise BlankImage()
        src_query = MapQuery(bbox, size, query.srs, format, dimensions=query.dimensions)
        resp = self.client.retrieve(src_query, format)
        return SubImageSource(resp, size=query.size, offset=offset, image_opts=self.image_opts)

    def _get_transformed(self, query, format):
        dst_srs = query.srs
        src_srs = self._best_supported_srs(dst_srs)
        dst_bbox = query.bbox
        src_bbox = dst_srs.transform_bbox_to(src_srs, dst_bbox)

        src_width, src_height = src_bbox[2]-src_bbox[0], src_bbox[3]-src_bbox[1]
        ratio = src_width/src_height
        dst_size = query.size
        xres, yres = src_width/dst_size[0], src_height/dst_size[1]
        if xres < yres:
            src_size = dst_size[0], int(dst_size[0]/ratio + 0.5)
        else:
            src_size = int(dst_size[1]*ratio +0.5), dst_size[1]

        src_query = MapQuery(src_bbox, src_size, src_srs, format, dimensions=query.dimensions)

        if self.coverage and not self.coverage.contains(src_bbox, src_srs):
            img = self._get_sub_query(src_query, format)
        else:
            resp = self.client.retrieve(src_query, format)
            img = ImageSource(resp, size=src_size, image_opts=self.image_opts)

        img = ImageTransformer(src_srs, dst_srs).transform(img, src_bbox,
            query.size, dst_bbox, self.image_opts)

        img.format = format
        return img

    def _best_supported_srs(self, srs):
        latlong = srs.is_latlong

        for srs in self.supported_srs:
            if srs.is_latlong == latlong:
                return srs

        # else
        return self.supported_srs[0]

    def _is_compatible(self, other, query):
        if not isinstance(other, WMSSource):
            return False

        if self.opacity is not None or other.opacity is not None:
            return False

        if self.supported_srs != other.supported_srs:
            return False

        if self.supported_formats != other.supported_formats:
            return False

        if self.transparent_color != other.transparent_color:
            return False

        if self.transparent_color_tolerance != other.transparent_color_tolerance:
            return False

        if self.coverage != other.coverage:
            return False


        if (query.dimensions_for_params(self.fwd_req_params) !=
            query.dimensions_for_params(other.fwd_req_params)):
            return False

        return True

    def combined_layer(self, other, query):
        if not self._is_compatible(other, query):
            return None

        client = self.client.combined_client(other.client, query)
        if not client:
            return None

        return WMSSource(client, image_opts=self.image_opts,
            transparent_color=self.transparent_color,
            transparent_color_tolerance=self.transparent_color_tolerance,
            supported_srs=self.supported_srs,
            supported_formats=self.supported_formats,
            res_range=None, # layer outside res_range should already be filtered out
            coverage=self.coverage,
            fwd_req_params=self.fwd_req_params,
        )

class WMSInfoSource(InfoSource):
    def __init__(self, client, fi_transformer=None):
        self.client = client
        self.fi_transformer = fi_transformer

    def get_info(self, query):
        doc = self.client.get_info(query)
        if self.fi_transformer:
            doc = self.fi_transformer(doc)
        return doc


class WMSLegendSource(LegendSource):
    def __init__(self, clients, legend_cache, static=False):
        self.clients = clients
        self.identifier = legend_identifier([c.identifier for c in self.clients])
        self._cache = legend_cache
        self._size = None
        self.static = static

    @property
    def size(self):
        if not self._size:
            legend = self.get_legend(LegendQuery(format='image/png', scale=None))
            # TODO image size without as_image?
            self._size = legend.as_image().size
        return self._size

    def get_legend(self, query):
        if self.static:
            # prevent caching of static legends for different scales
            legend = Legend(id=self.identifier, scale=None)
        else:
            legend = Legend(id=self.identifier, scale=query.scale)
        if not self._cache.load(legend):
            legends = []
            error_occured = False
            for client in self.clients:
                try:
                    legends.append(client.get_legend(query))
                except HTTPClientError, e:
                    error_occured = True
                    log.error(e.args[0])
                except SourceError, e:
                    error_occured = True
                    # TODO errors?
                    log.error(e.args[0])
            format = split_mime_type(query.format)[1]
            legend = Legend(source=concat_legends(legends, format=format),
                            id=self.identifier, scale=query.scale)
            if not error_occured:
                self._cache.store(legend)
        return legend.source


########NEW FILE########
__FILENAME__ = srs
# -*- coding: utf-8 -*-
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Spatial reference systems and transformation of coordinates.
"""
from __future__ import division

import math
import threading
from itertools import izip
from mapproxy.proj import Proj, transform, set_datapath, ProjInitError
from mapproxy.config import base_config

import logging
log_system = logging.getLogger('mapproxy.system')
log_proj = logging.getLogger('mapproxy.proj')

def get_epsg_num(epsg_code):
    """
    >>> get_epsg_num('ePsG:4326')
    4326
    >>> get_epsg_num(4313)
    4313
    >>> get_epsg_num('31466')
    31466
    """
    if isinstance(epsg_code, basestring):
        if ':' in epsg_code:
            epsg_code = int(epsg_code.split(':')[1])
        else:
            epsg_code = int(epsg_code)
    return epsg_code

def _clean_srs_code(code):
    """
    >>> _clean_srs_code(4326)
    'EPSG:4326'
    >>> _clean_srs_code('31466')
    'EPSG:31466'
    >>> _clean_srs_code('crs:84')
    'CRS:84'
    """
    if isinstance(code, basestring) and ':' in code:
        return code.upper()
    else:
        return 'EPSG:' + str(code)

class TransformationError(Exception):
    pass

_proj_initalized = False
def _init_proj():
    global _proj_initalized
    if not _proj_initalized and 'proj_data_dir' in base_config().srs:
        proj_data_dir = base_config().srs['proj_data_dir']
        log_system.info('loading proj data from %s', proj_data_dir)
        set_datapath(proj_data_dir)
        _proj_initalized = True

_thread_local = threading.local()
def SRS(srs_code):
    _init_proj()
    if isinstance(srs_code, _SRS):
        return srs_code

    srs_code = _clean_srs_code(srs_code)

    if not hasattr(_thread_local, 'srs_cache'):
        _thread_local.srs_cache = {}

    if srs_code in _thread_local.srs_cache:
        return _thread_local.srs_cache[srs_code]
    else:
        srs = _SRS(srs_code)
        _thread_local.srs_cache[srs_code] = srs
        return srs

WEBMERCATOR_EPSG = set(('EPSG:900913', 'EPSG:3857',
    'EPSG:102100', 'EPSG:102113'))

class _SRS(object):
    # http://trac.openlayers.org/wiki/SphericalMercator
    proj_init = {
                 'EPSG:4326': lambda: Proj('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +over'),
                 'CRS:84': lambda: Proj('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +over'),
                }
    for _epsg in WEBMERCATOR_EPSG:
        proj_init[_epsg] = lambda: Proj(
            '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 '
            '+lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m '
            '+nadgrids=@null +no_defs +over')

    """
    This class represents a Spatial Reference System.
    """
    def __init__(self, srs_code):
        """
        Create a new SRS with the given `srs_code` code.
        """
        self.srs_code = srs_code

        init = _SRS.proj_init.get(srs_code, None)
        if init is not None:
            self.proj = init()
        else:
            epsg_num = get_epsg_num(srs_code)
            self.proj = Proj(init='epsg:%d' % epsg_num)

    def transform_to(self, other_srs, points):
        """
        :type points: ``(x, y)`` or ``[(x1, y1), (x2, y2), ]``

        >>> srs1 = SRS(4326)
        >>> srs2 = SRS(900913)
        >>> [str(round(x, 5)) for x in srs1.transform_to(srs2, (8.22, 53.15))]
        ['915046.21432', '7010792.20171']
        >>> srs1.transform_to(srs1, (8.25, 53.5))
        (8.25, 53.5)
        >>> [(str(round(x, 5)), str(round(y, 5))) for x, y in
        ...  srs1.transform_to(srs2, [(8.2, 53.1), (8.22, 53.15), (8.3, 53.2)])]
        ... #doctest: +NORMALIZE_WHITESPACE
        [('912819.8245', '7001516.67745'),
         ('915046.21432', '7010792.20171'),
         ('923951.77358', '7020078.53264')]
        """
        if self == other_srs:
            return points
        if isinstance(points[0], (int, float)) and 2 >= len(points) <= 3:
            return transform(self.proj, other_srs.proj, *points)

        x = [p[0] for p in points]
        y = [p[1] for p in points]
        transf_pts = transform(self.proj, other_srs.proj, x, y)
        return izip(transf_pts[0], transf_pts[1])

    def transform_bbox_to(self, other_srs, bbox, with_points=16):
        """

        :param with_points: the number of points to use for the transformation.
            A bbox transformation with only two or four points may cut off some
            parts due to distortions.

        >>> ['%.3f' % x for x in
        ...  SRS(4326).transform_bbox_to(SRS(900913), (-180.0, -90.0, 180.0, 90.0))]
        ['-20037508.343', '-147730762.670', '20037508.343', '147730758.195']
        >>> ['%.5f' % x for x in
        ...  SRS(4326).transform_bbox_to(SRS(900913), (8.2, 53.1, 8.3, 53.2))]
        ['912819.82450', '7001516.67745', '923951.77358', '7020078.53264']
        >>> SRS(4326).transform_bbox_to(SRS(4326), (8.25, 53.0, 8.5, 53.75))
        (8.25, 53.0, 8.5, 53.75)
        """
        if self == other_srs:
            return bbox
        bbox = self.align_bbox(bbox)
        points = generate_envelope_points(bbox, with_points)
        transf_pts = self.transform_to(other_srs, points)
        result = calculate_bbox(transf_pts)

        log_proj.debug('transformed from %r to %r (%s -> %s)' %
                  (self, other_srs, bbox, result))

        return result

    def align_bbox(self, bbox):
        """
        Align bbox to reasonable values to prevent errors in transformations.
        E.g. transformations from EPSG:4326 with lat=90 or -90 will fail, so
        we subtract a tiny delta.

        At the moment only EPSG:4326 bbox will be modifyed.

        >>> bbox = SRS(4326).align_bbox((-180, -90, 180, 90))
        >>> -90 < bbox[1] < -89.99999998
        True
        >>> 90 > bbox[3] > 89.99999998
        True
        """
        # TODO should not be needed anymore since we transform with +over
        # still a few tests depend on the rounding behavior of this
        if self.srs_code == 'EPSG:4326':
            delta = 0.00000001
            (minx, miny, maxx, maxy) = bbox
            if abs(miny - -90.0) < 1e-6:
                miny = -90.0 + delta
            if abs(maxy - 90.0) < 1e-6:
                maxy = 90.0 - delta
            bbox = minx, miny, maxx, maxy
        return bbox

    @property
    def is_latlong(self):
        """
        >>> SRS(4326).is_latlong
        True
        >>> SRS(31466).is_latlong
        False
        """
        return self.proj.is_latlong()

    @property
    def is_axis_order_ne(self):
        """
        Returns `True` if the axis order is North, then East
        (i.e. y/x or lat/lon).

        >>> SRS(4326).is_axis_order_ne
        True
        >>> SRS('CRS:84').is_axis_order_ne
        False
        >>> SRS(31468).is_axis_order_ne
        True
        >>> SRS(31463).is_axis_order_ne
        False
        >>> SRS(25831).is_axis_order_ne
        False
        """
        if self.srs_code in base_config().srs.axis_order_ne:
            return True
        if self.srs_code in base_config().srs.axis_order_en:
            return False
        if self.is_latlong:
            return True
        return False

    @property
    def is_axis_order_en(self):
        """
        Returns `True` if the axis order is East then North
        (i.e. x/y or lon/lat).
        """
        return not self.is_axis_order_ne

    def __eq__(self, other):
        """
        >>> SRS(4326) == SRS("EpsG:4326")
        True
        >>> SRS(4326) == SRS("4326")
        True
        >>> SRS(4326) == SRS(900913)
        False
        >>> SRS(3857) == SRS(900913)
        True
        >>> SRS(900913) == SRS(3857)
        True

        """
        if isinstance(other, _SRS):
            if (self.srs_code in WEBMERCATOR_EPSG
                and other.srs_code in WEBMERCATOR_EPSG):
                return True
            return self.proj.srs == other.proj.srs
        else:
            return NotImplemented
    def __ne__(self, other):
        """
        >>> SRS(900913) != SRS(900913)
        False
        >>> SRS(4326) != SRS(900913)
        True
        """
        equal_result = self.__eq__(other)
        if equal_result is NotImplemented:
            return NotImplemented
        else:
            return not equal_result
    def __str__(self):
        #pylint: disable-msg=E1101
        return "SRS %s ('%s')" % (self.srs_code, self.proj.srs)

    def __repr__(self):
        """
        >>> repr(SRS(4326))
        "SRS('EPSG:4326')"
        """
        return "SRS('%s')" % (self.srs_code,)

    def __hash__(self):
        return hash(self.srs_code)


def generate_envelope_points(bbox, n):
    """
    Generates points that form a linestring around a given bbox.

    @param bbox: bbox to generate linestring for
    @param n: the number of points to generate around the bbox

    >>> generate_envelope_points((10.0, 5.0, 20.0, 15.0), 4)
    [(10.0, 5.0), (20.0, 5.0), (20.0, 15.0), (10.0, 15.0)]
    >>> generate_envelope_points((10.0, 5.0, 20.0, 15.0), 8)
    ... #doctest: +NORMALIZE_WHITESPACE
    [(10.0, 5.0), (15.0, 5.0), (20.0, 5.0), (20.0, 10.0),\
     (20.0, 15.0), (15.0, 15.0), (10.0, 15.0), (10.0, 10.0)]
    """
    (minx, miny, maxx, maxy) = bbox
    if n <= 4:
        n = 0
    else:
        n = int(math.ceil((n - 4) / 4.0))

    width = maxx - minx
    height = maxy - miny

    minx, maxx = min(minx, maxx), max(minx, maxx)
    miny, maxy = min(miny, maxy), max(miny, maxy)

    n += 1
    xstep = width / n
    ystep = height / n
    result = []
    for i in range(n+1):
        result.append((minx + i*xstep, miny))
    for i in range(1, n):
        result.append((maxx, miny + i*ystep))
    for i in range(n, -1, -1):
        result.append((minx + i*xstep, maxy))
    for i in range(n-1, 0, -1):
        result.append((minx, miny + i*ystep))
    return result

def calculate_bbox(points):
    """
    Calculates the bbox of a list of points.

    >>> calculate_bbox([(-5, 20), (3, 8), (99, 0)])
    (-5, 0, 99, 20)

    @param points: list of points [(x0, y0), (x1, y2), ...]
    @returns: bbox of the input points.
    """
    points = list(points)
    # points can be INF for invalid transformations, filter out
    # INF is not portable for <2.6 so we check against a large value
    MAX = 1e300
    try:
        minx = min(p[0] for p in points if p[0] <= MAX)
        miny = min(p[1] for p in points if p[1] <= MAX)
        maxx = max(p[0] for p in points if p[0] <= MAX)
        maxy = max(p[1] for p in points if p[1] <= MAX)
        return (minx, miny, maxx, maxy)
    except ValueError: # everything is INF
        raise TransformationError()

def merge_bbox(bbox1, bbox2):
    """
    Merge two bboxes.

    >>> merge_bbox((-10, 20, 0, 30), (30, -20, 90, 10))
    (-10, -20, 90, 30)

    """
    minx = min(bbox1[0], bbox2[0])
    miny = min(bbox1[1], bbox2[1])
    maxx = max(bbox1[2], bbox2[2])
    maxy = max(bbox1[3], bbox2[3])
    return (minx, miny, maxx, maxy)

def bbox_equals(src_bbox, dst_bbox, x_delta=None, y_delta=None):
    """
    Compares two bbox and checks if they are equal, or nearly equal.

    :param x_delta: how precise the comparison should be.
                    should be reasonable small, like a tenth of a pixel.
                    defaults to 1/1.000.000th of the width.
    :type x_delta: bbox units

    >>> src_bbox = (939258.20356824622, 6887893.4928338043,
    ...             1095801.2374962866, 7044436.5267618448)
    >>> dst_bbox = (939258.20260000182, 6887893.4908000007,
    ...             1095801.2365000017, 7044436.5247000009)
    >>> bbox_equals(src_bbox, dst_bbox, 61.1, 61.1)
    True
    >>> bbox_equals(src_bbox, dst_bbox, 0.0001)
    False
    """
    if x_delta is None:
        x_delta = abs(src_bbox[0] - src_bbox[2]) / 1000000.0
    if y_delta is None:
        y_delta = x_delta
    return (abs(src_bbox[0] - dst_bbox[0]) < x_delta and
            abs(src_bbox[1] - dst_bbox[1]) < x_delta and
            abs(src_bbox[2] - dst_bbox[2]) < y_delta and
            abs(src_bbox[3] - dst_bbox[3]) < y_delta)

def make_lin_transf(src_bbox, dst_bbox):
    """
    Create a transformation function that transforms linear between two
    plane coordinate systems.
    One needs to be cartesian (0, 0 at the lower left, x goes up) and one
    needs to be an image coordinate system (0, 0 at the top left, x goes down).

    :return: function that takes src x/y and returns dest x/y coordinates

    >>> transf = make_lin_transf((7, 50, 8, 51), (0, 0, 500, 400))
    >>> transf((7.5, 50.5))
    (250.0, 200.0)
    >>> transf((7.0, 50.0))
    (0.0, 400.0)
    >>> transf = make_lin_transf((7, 50, 8, 51), (200, 300, 700, 700))
    >>> transf((7.5, 50.5))
    (450.0, 500.0)
    """
    func = lambda (x, y): (dst_bbox[0] + (x - src_bbox[0]) *
                           (dst_bbox[2]-dst_bbox[0]) / (src_bbox[2] - src_bbox[0]),
                           dst_bbox[1] + (src_bbox[3] - y) *
                           (dst_bbox[3]-dst_bbox[1]) / (src_bbox[3] - src_bbox[1]))
    return func

########NEW FILE########
__FILENAME__ = template
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Loading of template files (e.g. capability documents)
"""
import os
import pkg_resources
from mapproxy.util.ext.tempita import Template, bunch
from mapproxy.config.config import base_config

__all__ = ['Template', 'bunch', 'template_loader']


def template_loader(module_name, location='templates', namespace={}):

    class loader(object):
        def __call__(self, name, from_template=None, default_inherit=None):
            if base_config().template_dir:
                template_file = os.path.join(base_config().template_dir, name)
            else:
                template_file = pkg_resources.resource_filename(module_name, location + '/' + name)
            return Template.from_filename(template_file, namespace=namespace,
                                          default_inherit=default_inherit, get_template=self)
    return loader()

########NEW FILE########
__FILENAME__ = helper
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import tempfile
import os
import re
from lxml import etree
import mocker

from nose.tools import eq_

class Mocker(object):
    """
    This is a base class for unit-tests that use ``mocker``. This class follows
    the nosetest naming conventions for setup and teardown methods.
    
    `setup` will initialize a `mocker.Mocker`. The `teardown` method
    will run ``mocker.verify()``.
    """
    def setup(self):
        self.mocker = mocker.Mocker()
    def expect_and_return(self, mock_call, return_val):
        """
        Register a return value for the mock call.
        :param return_val: The value mock_call should return.
        """
        self.mocker.result(return_val)
    def expect(self, mock_call):
        return mocker.expect(mock_call)
    def replay(self):
        """
        Finish mock-record phase.
        """
        self.mocker.replay()
    def mock(self, base_cls=None):
        """
        Return a new mock object.
        :param base_cls: check method signatures of the mock-calls with this
            base_cls signature (optional)
        """
        if base_cls:
            return self.mocker.mock(base_cls)
        return self.mocker.mock()
    def teardown(self):
        self.mocker.verify()

class TempFiles(object):
    """
    This class is a context manager for temporary files.
    
    >>> with TempFiles(n=2, suffix='.png') as tmp:
    ...     for f in tmp:
    ...         assert os.path.exists(f)
    >>> for f in tmp:
    ...     assert not os.path.exists(f)
    """
    def __init__(self, n=1, suffix='', no_create=False):
        self.n = n
        self.suffix = suffix
        self.no_create = no_create
        self.tmp_files = []
    
    def __enter__(self):
        for _ in range(self.n):
            fd, tmp_file = tempfile.mkstemp(suffix=self.suffix)
            os.close(fd)
            self.tmp_files.append(tmp_file)
            if self.no_create:
                os.remove(tmp_file)
        return self.tmp_files
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        for tmp_file in self.tmp_files:
            if os.path.exists(tmp_file):
                os.remove(tmp_file)
        self.tmp_files = []

class TempFile(TempFiles):
    def __init__(self, suffix='', no_create=False):
        TempFiles.__init__(self, suffix=suffix, no_create=no_create)
    def __enter__(self):
        return TempFiles.__enter__(self)[0]

class LogMock(object):
    log_methods = ('info', 'debug', 'warn', 'error', 'fail')
    def __init__(self, module, log_name='log'):
        self.module = module
        self.orig_logger = None
        self.logged_msgs = []
    
    def __enter__(self):
        self.orig_logger = self.module.log
        self.module.log = self
        return self
    
    def __getattr__(self, name):
        if name in self.log_methods:
            def _log(msg):
                self.logged_msgs.append((name, msg))
            return _log
        raise AttributeError("'%s' object has no attribute '%s'" %
                             (self.__class__.__name__, name))
    
    def assert_log(self, type, msg):
        log_type, log_msg = self.logged_msgs.pop(0)
        assert log_type == type, 'expected %s log message, but was %s' % (type, log_type)
        assert msg in log_msg.lower(), "expected string '%s' in log message '%s'" % \
            (msg, log_msg)
        
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.module.log = self.orig_logger
    

def assert_re(value, regex):
    """
    >>> assert_re('hello', 'l+')
    >>> assert_re('hello', 'l{3}')
    Traceback (most recent call last):
        ...
    AssertionError: hello ~= l{3}
    """
    match = re.search(regex, value)
    assert match is not None, '%s ~= %s' % (value, regex)

def validate_with_dtd(doc, dtd_name, dtd_basedir=None):
    if dtd_basedir is None:
        dtd_basedir = os.path.join(os.path.dirname(__file__), 'schemas')
    
    dtd_filename = os.path.join(dtd_basedir, dtd_name)
    with open(dtd_filename) as schema:
        dtd = etree.DTD(schema)
        if isinstance(doc, basestring):
            xml = etree.XML(doc)
        else:
            xml = doc
        is_valid = dtd.validate(xml)
        print dtd.error_log.filter_from_errors()
        return is_valid

def validate_with_xsd(doc, xsd_name, xsd_basedir=None):
    if xsd_basedir is None:
        xsd_basedir = os.path.join(os.path.dirname(__file__), 'schemas')
    
    xsd_filename = os.path.join(xsd_basedir, xsd_name)
    
    with open(xsd_filename) as schema:
        xsd = etree.parse(schema)
        xml_schema = etree.XMLSchema(xsd)
        if isinstance(doc, basestring):
            xml = etree.XML(doc)
        else:
            xml = doc
        is_valid = xml_schema.validate(xml)
        print xml_schema.error_log.filter_from_errors()
        return is_valid

class XPathValidator(object):
    def __init__(self, doc):
        self.xml = etree.XML(doc)
    
    def assert_xpath(self, xpath, expected=None):
        assert len(self.xml.xpath(xpath)) > 0, xpath + ' does not match anything'
        if expected is not None:
            if callable(expected):
                assert expected(self.xml.xpath(xpath)[0])
            else:
                eq_(self.xml.xpath(xpath)[0], expected)
    def xpath(self, xpath):
        return self.xml.xpath(xpath)


def strip_whitespace(text):
    """
    >>> strip_whitespace(' <foo> bar\\n zing\\t1')
    '<foo>barzing1'
    """
    return re.sub('\s+', '', text)
########NEW FILE########
__FILENAME__ = http
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

import threading
import sys
import cgi
import socket
import errno
import time
from cStringIO import StringIO
from urlparse import urlsplit
from BaseHTTPServer import HTTPServer as HTTPServer_, BaseHTTPRequestHandler
from contextlib import contextmanager

class HTTPServer(HTTPServer_):
    allow_reuse_address = True

    def handle_error(self, request, client_address):
        _exc_class, exc, _tb = sys.exc_info()
        if isinstance(exc, socket.error):
            if (hasattr(exc, 'errno') and exc.errno == errno.EPIPE
              or exc.args[0] == errno.EPIPE): # exc.errno since py2.6
                # suppres 'Broken pipe' errors raised in timeout tests
                return
        HTTPServer_.handle_error(self, request, client_address)

class ThreadedStopableHTTPServer(threading.Thread):
    def __init__(self, address, requests_responses, unordered=False, query_comparator=None):
        threading.Thread.__init__(self, **{'group': None})
        self.requests_responses = requests_responses
        self.daemon = True
        self.sucess = False
        self.shutdown = False
        self.httpd = HTTPServer(address,mock_http_handler(requests_responses,
            unordered=unordered, query_comparator=query_comparator))
        self.httpd.timeout = 1.0
        self.out = self.httpd.out = StringIO()

    @property
    def http_port(self):
        return self.httpd.socket.getsockname()[1]

    def run(self):
        while self.requests_responses:
            if self.shutdown: break
            self.httpd.handle_request()
        if self.requests_responses:
            missing_req = [req for req, resp in self.requests_responses]
            print >>self.out, 'missing requests: ' + ','.join(map(str, missing_req))
        if self.out.tell() > 0: # errors written
            self.out.seek(0)
        else:
            self.sucess = True
        # force socket close so next test can bind to same address
        self.httpd.socket.close()

class ThreadedSingleRequestHTTPServer(threading.Thread):
    def __init__(self, address, request_handler):
        threading.Thread.__init__(self, **{'group': None})
        self.daemon = True
        self.sucess = False
        self.shutdown = False
        self.httpd = HTTPServer(address, request_handler)
        self.httpd.timeout = 1.0
        self.out = self.httpd.out = StringIO()

    def run(self):
        self.httpd.handle_request()
        if self.out.tell() > 0: # errors written
            self.out.seek(0)
        else:
            self.sucess = True
        # force socket close so next test can bind to same address
        self.httpd.socket.close()


def mock_http_handler(requests_responses, unordered=False, query_comparator=None):
    if query_comparator is None:
        query_comparator = query_eq
    class MockHTTPHandler(BaseHTTPRequestHandler):
        def do_GET(self):
            self.query_data = self.path
            return self.do_mock_request('GET')

        def do_POST(self):
            length = int(self.headers['content-length'])
            self.query_data = self.path + '?' + self.rfile.read(length)
            return self.do_mock_request('POST')

        def _matching_req_resp(self):
            if len(requests_responses) == 0:
                return None, None
            if unordered:
                for req_resp in requests_responses:
                    req, resp = req_resp
                    if query_comparator(req['path'], self.query_data):
                        requests_responses.remove(req_resp)
                        return req, resp
                return None, None
            else:
                return requests_responses.pop(0)

        def do_mock_request(self, method):
            req, resp = self._matching_req_resp()
            if not req:
                print >>self.server.out, 'got unexpected request      ', self.query_data
                raise AssertionError
            if 'method' in req:
                if req['method'] != method:
                    print >>self.server.out, 'expected %s request, got %s' % (req['method'], method)
                    self.server.shutdown = True
            if req.get('require_basic_auth', False):
                if 'Authorization' not in self.headers:
                    requests_responses.insert(0, (req, resp)) # push back
                    self.send_response(401)
                    self.send_header('WWW-Authenticate', 'Basic realm="Secure Area"')
                    self.end_headers()
                    self.wfile.write('no access')
                    return
            if not query_comparator(req['path'], self.query_data):
                print >>self.server.out, 'got request      ', self.query_data
                print >>self.server.out, 'expected request ', req['path']
                query_actual = set(query_to_dict(self.query_data).items())
                query_expected = set(query_to_dict(req['path']).items())
                print >>self.server.out, 'param diff  %s|%s' % (
                    query_actual - query_expected, query_expected - query_actual)
                self.server.shutdown = True
            if 'req_assert_function' in req:
                if not req['req_assert_function'](self):
                    print >>self.server.out, 'req_assert_function failed'
                    self.server.shutdown = True
            if 'duration' in resp:
                time.sleep(float(resp['duration']))
            self.start_response(resp)
            if resp.get('body_file'):
                with open(resp['body_file'], 'rb') as f:
                    self.wfile.write(f.read())
            else:
                self.wfile.write(resp['body'])
            if not requests_responses:
                self.server.shutdown = True
            return
        def start_response(self, resp):
            self.send_response(int(resp.get('status', '200')))
            if 'headers' in resp:
                for key, value in resp['headers'].iteritems():
                    self.send_header(key, value)
            self.end_headers()
        def log_request(self, code, size=None):
            pass

    return MockHTTPHandler

class MockServ(object):
    def __init__(self, port=0, host='localhost', unordered=False):
        self._requested_port = port
        self.port = port
        self.host = host
        self.requests_responses = []
        self.unordered = unordered
        self._init_thread()

    def _init_thread(self):
        self._thread = ThreadedStopableHTTPServer((self.host, self._requested_port),
            [], unordered=self.unordered)
        if self._requested_port == 0:
            self.port = self._thread.http_port
        self.address = (self.host, self.port)

    def reset(self):
        self._init_thread()

    @property
    def base_url(self):
        return 'http://localhost:%d' % (self.port, )

    def expects(self, path, method='GET', headers=None):
        headers = headers or ()
        self.requests_responses.append(
            (dict(path=path, method=method, headers=headers), {}))
        return self

    def returns(self, body=None, body_file=None, status_code=200, headers=None):
        assert body or body_file
        headers = headers or {}
        self.requests_responses[-1][1].update(
            body=body, body_file=body_file, status_code=status_code, headers=headers)
        return self

    def __enter__(self):
        # copy request_responses to be able to reuse it after .reset()
        self._thread.requests_responses[:] = self.requests_responses
        self._thread.start()

    def __exit__(self, type, value, traceback):
        self._thread.shutdown = True
        self._thread.join()
        if value:
            raise type, value, traceback
        assert self._thread.sucess, ('requests to mock httpd did not '
            'match expectations:\n' + self._thread.out.read())

def wms_query_eq(expected, actual):
    """
    >>> wms_query_eq('bAR=baz&foo=bizz&bbOX=0,0,100000,100000', 'foO=bizz&BBOx=-.0001,0.01,99999.99,100000.09&bar=baz')
    True
    >>> wms_query_eq('bAR=baz&foo=bizz&bbOX=0,0,100000,100000', 'foO=bizz&BBOx=-.0001,0.01,99999.99,100000.11&bar=baz')
    False
    >>> wms_query_eq('/service?bar=baz&fOO=bizz', 'foo=bizz&bar=baz')
    False
    >>> wms_query_eq('/1/2/3.png', '/1/2/3.png')
    True
    >>> wms_query_eq('/1/2/3.png', '/1/2/0.png')
    False
    """
    from mapproxy.srs import bbox_equals
    if path_from_query(expected) != path_from_query(actual):
        return False

    expected = query_to_dict(expected)
    actual = query_to_dict(actual)

    if 'bbox' in expected and 'bbox' in actual:
        expected = expected.copy()
        expected_bbox = map(float, expected.pop('bbox').split(','))
        actual = actual.copy()
        actual_bbox = map(float, actual.pop('bbox').split(','))
        if expected != actual:
            return False
        if not bbox_equals(expected_bbox, actual_bbox):
            return False
    else:
        if expected != actual:
            return False

    return True

def query_eq(expected, actual):
    """
    >>> query_eq('bAR=baz&foo=bizz', 'foO=bizz&bar=baz')
    True
    >>> query_eq('/service?bar=baz&fOO=bizz', 'foo=bizz&bar=baz')
    False
    >>> query_eq('/1/2/3.png', '/1/2/3.png')
    True
    >>> query_eq('/1/2/3.png', '/1/2/0.png')
    False
    """
    return (query_to_dict(expected) == query_to_dict(actual) and
            path_from_query(expected) == path_from_query(actual))

def assert_query_eq(expected, actual):
    path_actual = path_from_query(actual)
    path_expected = path_from_query(expected)
    assert path_expected == path_actual, path_expected + '!=' + path_actual

    query_actual = set(query_to_dict(actual).items())
    query_expected = set(query_to_dict(expected).items())

    assert query_expected == query_actual, '%s != %s\t%s|%s' % (
        expected, actual, query_expected - query_actual, query_actual - query_expected)

def path_from_query(query):
    """
    >>> path_from_query('/service?foo=bar')
    '/service'
    >>> path_from_query('/1/2/3.png')
    '/1/2/3.png'
    >>> path_from_query('foo=bar')
    ''
    """
    if not ('&' in query or '=' in query):
        return query
    if '?' in query:
        return query.split('?', 1)[0]
    return ''

def query_to_dict(query):
    """
    >>> sorted(query_to_dict('/service?bar=baz&foo=bizz').items())
    [('bar', 'baz'), ('foo', 'bizz')]
    >>> sorted(query_to_dict('bar=baz&foo=bizz').items())
    [('bar', 'baz'), ('foo', 'bizz')]
    """
    if not ('&' in query or '=' in query):
        return {}
    d = {}
    if '?' in query:
        query = query.split('?', 1)[-1]
    for key, value in cgi.parse_qsl(query):
        d[key.lower()] = value
    return d

def assert_url_eq(url1, url2):
    parts1 = urlsplit(url1)
    parts2 = urlsplit(url2)

    assert parts1[0] == parts2[0], '%s != %s (%s)' % (url1, url2, 'schema')
    assert parts1[1] == parts2[1], '%s != %s (%s)' % (url1, url2, 'location')
    assert parts1[2] == parts2[2], '%s != %s (%s)' % (url1, url2, 'path')
    assert query_eq(parts1[3], parts2[3]), '%s != %s (%s)' % (url1, url2, 'query')
    assert parts1[4] == parts2[4], '%s != %s (%s)' % (url1, url2, 'fragment')

@contextmanager
def mock_httpd(address, requests_responses, unordered=False, bbox_aware_query_comparator=False):
    if bbox_aware_query_comparator:
        query_comparator = wms_query_eq
    else:
        query_comparator = query_eq
    t = ThreadedStopableHTTPServer(address, requests_responses, unordered=unordered,
        query_comparator=query_comparator)
    t.start()
    try:
        yield
    finally:
        t.shutdown = True
        t.join(1)
    assert t.sucess, 'requests to mock httpd did not match expectations:\n' + t.out.read()

@contextmanager
def mock_single_req_httpd(address, request_handler):
    t = ThreadedSingleRequestHTTPServer(address, request_handler)
    t.start()
    try:
        yield
    finally:
        t.shutdown = True
        t.join(1)
    assert t.sucess, 'requests to mock httpd did not match expectations:\n' + t.out.read()


def make_wsgi_env(query_string, extra_environ={}):
        env = {'QUERY_STRING': query_string,
               'wsgi.url_scheme': 'http',
               'HTTP_HOST': 'localhost',
              }
        env.update(extra_environ)
        return env

########NEW FILE########
__FILENAME__ = image
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import division
import os

from mapproxy.platform.image import (
    Image,
    ImageDraw,
    ImageColor,
)
import tempfile
from nose.tools import eq_
from cStringIO import StringIO
from contextlib import contextmanager


def assert_image_mode(img, mode):
    pos = img.tell()
    try:
        img = Image.open(img)
        eq_(img.mode, mode)
    finally:
        img.seek(pos)


def check_format(img, format):
    assert globals()['is_' + format.lower()](img), 'img is not %s' % format

def has_magic_bytes(fileobj, bytes):
    pos = fileobj.tell()
    for magic in bytes:
        fileobj.seek(0)
        it_is = fileobj.read(len(magic)) == magic
        fileobj.seek(pos)
        if it_is:
            return True
    return False

magic_bytes = { 'png': ["\211PNG\r\n\032\n"],
                'tiff': ["MM\x00\x2a", "II\x2a\x00"],
                'geotiff': ["MM\x00\x2a", "II\x2a\x00"],
                'gif': ["GIF87a", "GIF89a"],
                'jpeg': ["\xFF\xD8"],
                'bmp': ['BM']
                }

def create_is_x_functions():
    for type_, magic in magic_bytes.iteritems():
        def create_is_type(type_, magic):
            def is_type(fileobj):
                if not hasattr(fileobj, 'read'):
                    fileobj = StringIO(fileobj)
                return has_magic_bytes(fileobj, magic)
            return is_type
        globals()['is_' + type_] = create_is_type(type_, magic)

create_is_x_functions()
del create_is_x_functions


def is_transparent(img_data):
    data = StringIO(img_data)
    img = Image.open(data)
    if img.mode == 'P':
        img = img.convert('RGBA')
    if img.mode == 'RGBA':
        return any(img.histogram()[-256:-1])

    raise NotImplementedError(
        'assert_is_transparent works only for RGBA images, got %s image' % img.mode)


def img_from_buf(buf):
    data = StringIO(buf)
    return Image.open(data)


def bgcolor_ratio(img_data):
    """
    Return the ratio of the primary/bg color. 1 == only bg color.
    """
    data = StringIO(img_data)
    img = Image.open(data)
    total_colors = img.size[0] * img.size[1]
    colors = img.getcolors()
    colors.sort()
    bgcolor = colors[-1][0]
    return bgcolor/total_colors

def create_tmp_image_file(size, two_colored=False):
    fd, out_file = tempfile.mkstemp(suffix='.png')
    os.close(fd)
    print 'creating temp image %s (%r)' % (out_file, size)
    img = Image.new('RGBA', size)
    if two_colored:
        draw = ImageDraw.Draw(img)
        draw.rectangle((0, 0, img.size[0]//2, img.size[1]),
            fill=ImageColor.getrgb('white'))
    img.save(out_file, 'png')
    return out_file

def create_image(size, color=None, mode=None):
    if color is not None:
        if isinstance(color, basestring):
            if mode is None:
                mode = 'RGB'
            img = Image.new(mode, size, color=color)
        else:
            if mode is None:
                mode = 'RGBA' if len(color) == 4 else 'RGB'
            img = Image.new(mode, size, color=tuple(color))
    else:
        img = create_debug_img(size)
    return img

def create_tmp_image_buf(size, format='png', color=None, mode='RGB'):
    img = create_image(size, color, mode)
    data = StringIO()
    img.save(data, format)
    data.seek(0)
    return data

def create_tmp_image(size, format='png', color=None, mode='RGB'):
    data = create_tmp_image_buf(size, format, color, mode)
    return data.read()


def create_debug_img(size, transparent=True):
    if transparent:
        img = Image.new("RGBA", size)
    else:
        img = Image.new("RGB", size, ImageColor.getrgb("#EEE"))

    draw = ImageDraw.Draw(img)
    draw_pattern(draw, size)
    return img

def draw_pattern(draw, size):
    w, h = size
    black_color = ImageColor.getrgb("black")
    draw.rectangle((0, 0, w-1, h-1), outline=black_color)
    draw.ellipse((0, 0, w-1, h-1), outline=black_color)
    step = w/16.0
    for i in range(16):
        color = ImageColor.getrgb('#3' + hex(16-i)[-1] + hex(i)[-1])
        draw.line((i*step, 0, i*step, h), fill=color)
    step = h/16.0
    for i in range(16):
        color = ImageColor.getrgb('#' + hex(16-i)[-1] + hex(i)[-1] + '3')
        draw.line((0, i*step, w, i*step), fill=color)


@contextmanager
def tmp_image(size, format='png', color=None, mode='RGB'):
    if color is not None:
        img = Image.new(mode, size, color=color)
    else:
        img = create_debug_img(size)
    data = StringIO()
    img.save(data, format)
    data.seek(0)
    yield data


def assert_colors_equal(img1, img2, delta=1):
    """
    assert that the colors of two images are equal.
    Use `delta` to accept small color variations
    (e.g. (255, 0, 127) == (254, 1, 128) with delta=1)

    `img1` and `img2` needs to be an image or list of
    colors like ``[(n, (r, g, b)), (n, (r, g, b)), ...]``
    """
    colors1 = sorted(img1.getcolors() if hasattr(img1, 'getcolors') else img1)
    colors2 = sorted(img2.getcolors() if hasattr(img2, 'getcolors') else img2)

    for (n1, c1), (n2, c2) in zip(colors1, colors2):
        assert n1 == n2, 'colors not equal: %r != %r' % (colors1, colors2)
        assert abs(c1[0] - c2[0]) <= delta, 'colors not equal: %r != %r in %r != %r' % (c1, c2, colors1, colors2)
        assert abs(c1[1] - c2[1]) <= delta, 'colors not equal: %r != %r in %r != %r' % (c1, c2, colors1, colors2)
        assert abs(c1[2] - c2[2]) <= delta, 'colors not equal: %r != %r in %r != %r' % (c1, c2, colors1, colors2)

########NEW FILE########
__FILENAME__ = cgi
#! /usr/bin/env python

"""
CGI script that returns a red 256x256 PNG file.
"""

if __name__ == '__main__':
    import sys
    w = sys.stdout.write
    w("Content-type: image/png\r\n")
    w("\r\n")

    w('\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x01\x00\x00\x00\x01\x00\x01\x03\x00\x00\x00f\xbc:%\x00\x00\x00\x06PLTE\xff\x00\x00\x00\x00\x00A\xa3\x12\x03\x00\x00\x00\x1fIDATx\x9c\xed\xc1\x01\r\x00\x00\x00\xc2\xa0\xf7Om\x0e7\xa0\x00\x00\x00\x00\x00\x00\x00\x00\xbe\r!\x00\x00\x01\xf1g!\xee\x00\x00\x00\x00IEND\xaeB`\x82')
########NEW FILE########
__FILENAME__ = test_auth
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

from mapproxy.test.system import module_setup, module_teardown, SystemTest
from mapproxy.test.image import img_from_buf, create_tmp_image, is_transparent
from mapproxy.test.http import MockServ
from nose.tools import eq_
from mapproxy.util.geom import geom_support
from mapproxy.srs import bbox_equals


test_config = {}

def setup_module():
    module_setup(test_config, 'auth.yaml')

def teardown_module():
    module_teardown(test_config)

TESTSERVER_ADDRESS = 'localhost', 42423
CAPABILITIES_REQ = "/service?request=GetCapabilities&service=WMS&Version=1.1.1"
MAP_REQ = ("/service?request=GetMap&service=WMS&Version=1.1.1&SRS=EPSG:4326"
    "&BBOX=-80,-40,0,0&WIDTH=200&HEIGHT=100&styles=&FORMAT=image/png&")
FI_REQ = ("/service?request=GetFeatureInfo&service=WMS&Version=1.1.1&SRS=EPSG:4326"
    "&BBOX=-80,-40,0,0&WIDTH=200&HEIGHT=100&styles=&FORMAT=image/png&X=10&Y=10&")

if not geom_support:
    from nose.plugins.skip import SkipTest
    raise SkipTest('requires Shapely')

class TestWMSAuth(SystemTest):
    config = test_config

    # ###
    # see mapproxy.test.unit.test_auth for WMS GetMap request tests
    # ###
    def test_capabilities_authorize_all(self):
        def auth(service, layers, **kw):
            eq_(service, 'wms.capabilities')
            eq_(len(layers), 8)
            return {'authorized': 'full'}

        resp = self.app.get(CAPABILITIES_REQ, extra_environ={'mapproxy.authorize': auth})
        xml = resp.lxml
        eq_(xml.xpath('//Layer/Name/text()'), ['layer1', 'layer1a', 'layer1b', 'layer2', 'layer2a', 'layer2b', 'layer2b1', 'layer3'])

    def test_capabilities_authorize_none(self):
        def auth(service, layers, **kw):
            eq_(service, 'wms.capabilities')
            eq_(len(layers), 8)
            return {'authorized': 'none'}
        self.app.get(CAPABILITIES_REQ, extra_environ={'mapproxy.authorize': auth}, status=403)

    def test_capabilities_unauthenticated(self):
        def auth(service, layers, **kw):
            eq_(service, 'wms.capabilities')
            eq_(len(layers), 8)
            return {'authorized': 'unauthenticated'}
        self.app.get(CAPABILITIES_REQ, extra_environ={'mapproxy.authorize': auth}, status=401)

    def test_capabilities_authorize_partial(self):
        def auth(service, layers, **kw):
            eq_(service, 'wms.capabilities')
            eq_(len(layers), 8)
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1a': {'map': True},
                    'layer2': {'map': True},
                    'layer2b': {'map': True},
                    'layer2b1': {'map': True},
                }
            }
        resp = self.app.get(CAPABILITIES_REQ, extra_environ={'mapproxy.authorize': auth})
        xml = resp.lxml
        # layer1a not included cause root layer (layer1) is not permitted
        eq_(xml.xpath('//Layer/Name/text()'), ['layer2', 'layer2b', 'layer2b1'])

    def test_capabilities_authorize_partial_limited_to(self):
        def auth(service, layers, **kw):
            eq_(service, 'wms.capabilities')
            eq_(len(layers), 8)
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1a': {'map': True},
                    'layer2': {'map': True, 'limited_to': {'srs': 'EPSG:4326', 'geometry': [-40.0, -50.0, 0.0, 5.0]}},
                    'layer2b': {'map': True},
                    'layer2b1': {'map': True},
                }
            }
        resp = self.app.get(CAPABILITIES_REQ, extra_environ={'mapproxy.authorize': auth})
        xml = resp.lxml
        # layer1a not included cause root layer (layer1) is not permitted
        eq_(xml.xpath('//Layer/Name/text()'), ['layer2', 'layer2b', 'layer2b1'])
        limited_bbox = xml.xpath('//Layer/LatLonBoundingBox')[1]
        eq_(float(limited_bbox.attrib['minx']), -40.0)
        eq_(float(limited_bbox.attrib['miny']), -50.0)
        eq_(float(limited_bbox.attrib['maxx']), 0.0)
        eq_(float(limited_bbox.attrib['maxy']), 5.0)

    def test_capabilities_authorize_partial_global_limited(self):
        def auth(service, layers, **kw):
            eq_(service, 'wms.capabilities')
            eq_(len(layers), 8)
            return {
                'authorized': 'partial',
                'limited_to': {'srs': 'EPSG:4326', 'geometry': [-40.0, -50.0, 0.0, 5.0]},
                'layers': {
                    'layer1': {'map': True},
                    'layer1a': {'map': True},
                    'layer2': {'map': True},
                    'layer2b': {'map': True},
                    'layer2b1': {'map': True},
                }
            }
        resp = self.app.get(CAPABILITIES_REQ, extra_environ={'mapproxy.authorize': auth})
        xml = resp.lxml
        # print resp.body
        # layer2/2b/2b1 not included because coverage of 2b1 is outside of global limited_to
        eq_(xml.xpath('//Layer/Name/text()'), ['layer1', 'layer1a'])
        limited_bbox = xml.xpath('//Layer/LatLonBoundingBox')[1]
        eq_(float(limited_bbox.attrib['minx']), -40.0)
        eq_(float(limited_bbox.attrib['miny']), -50.0)
        eq_(float(limited_bbox.attrib['maxx']), 0.0)
        eq_(float(limited_bbox.attrib['maxy']), 5.0)

    def test_capabilities_authorize_partial_with_fi(self):
        def auth(service, layers, **kw):
            eq_(service, 'wms.capabilities')
            eq_(len(layers), 8)
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'map': True},
                    'layer1a': {'map': True},
                    'layer2': {'map': True, 'featureinfo': True},
                    'layer2b': {'map': True, 'featureinfo': True},
                    'layer2b1': {'map': True, 'featureinfo': True},
                }
            }
        resp = self.app.get(CAPABILITIES_REQ, extra_environ={'mapproxy.authorize': auth})
        xml = resp.lxml
        eq_(xml.xpath('//Layer/Name/text()'), ['layer1', 'layer1a', 'layer2', 'layer2b', 'layer2b1'])
        layers = xml.xpath('//Layer')
        assert layers[3][0].text == 'layer2'
        assert layers[3].attrib['queryable'] == '1'
        assert layers[4][0].text == 'layer2b'
        assert layers[4].attrib['queryable'] == '1'
        assert layers[5][0].text == 'layer2b1'
        assert layers[5].attrib['queryable'] == '1'

    def test_get_map_authorized(self):
        def auth(service, layers, query_extent, **kw):
            eq_(query_extent, ('EPSG:4326', (-80.0, -40.0, 0.0, 0.0)))
            eq_(service, 'wms.map')
            eq_(len(layers), 1)
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'map': True},
                }
            }
        resp = self.app.get(MAP_REQ + 'layers=layer1', extra_environ={'mapproxy.authorize': auth})
        eq_(resp.content_type, 'image/png')

    def test_get_map_authorized_limited(self):
        def auth(service, layers, query_extent, **kw):
            eq_(query_extent, ('EPSG:4326', (-80.0, -40.0, 0.0, 0.0)))
            eq_(service, 'wms.map')
            eq_(len(layers), 1)
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {
                        'map': True,
                        'limited_to': {'srs': 'EPSG:4326', 'geometry': [-40.0, -40.0, 0.0, 0.0]},
                    },
                }
            }
        resp = self.app.get(MAP_REQ + 'layers=layer1', extra_environ={'mapproxy.authorize': auth})
        eq_(resp.content_type, 'image/png')
        img = img_from_buf(resp.body)
        # left part not authorized, only bgcolor
        assert len(img.crop((0, 0, 100, 100)).getcolors()) == 1
        # right part authorized, bgcolor + text
        assert len(img.crop((100, 0, 200, 100)).getcolors()) >= 2

    def test_get_map_authorized_global_limited(self):
        def auth(service, layers, query_extent, **kw):
            eq_(query_extent, ('EPSG:4326', (-80.0, -40.0, 0.0, 0.0)))
            eq_(service, 'wms.map')
            eq_(len(layers), 1)
            return {
                'authorized': 'partial',
                'limited_to': {'srs': 'EPSG:4326', 'geometry': [-20.0, -40.0, 0.0, 0.0]},
                'layers': {
                    'layer1': {
                        'map': True,
                        'limited_to': {'srs': 'EPSG:4326', 'geometry': [-40.0, -40.0, 0.0, 0.0]},
                    },
                }
            }
        resp = self.app.get(MAP_REQ + 'layers=layer1', extra_environ={'mapproxy.authorize': auth})
        eq_(resp.content_type, 'image/png')
        img = img_from_buf(resp.body)
        # left part not authorized, only bgcolor
        assert len(img.crop((0, 0, 100, 100)).getcolors()) == 1
        # right part authorized, bgcolor + text
        assert len(img.crop((100, 0, 200, 100)).getcolors()) >= 2

    def test_get_map_authorized_none(self):
        def auth(service, layers, query_extent, **kw):
            eq_(query_extent, ('EPSG:4326', (-80.0, -40.0, 0.0, 0.0)))
            eq_(service, 'wms.map')
            eq_(len(layers), 1)
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'map': False},
                }
            }
        self.app.get(MAP_REQ + 'layers=layer1', extra_environ={'mapproxy.authorize': auth}, status=403)

    def test_get_featureinfo_limited_to_inside(self):
        def auth(service, layers, query_extent, **kw):
            eq_(query_extent, ('EPSG:4326', (-80.0, -40.0, 0.0, 0.0)))
            eq_(service, 'wms.featureinfo')
            eq_(len(layers), 1)
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1b': {'featureinfo': True, 'limited_to':  {'srs': 'EPSG:4326', 'geometry': [-80.0, -40.0, 0.0, 0.0]}},
                }
            }
        serv = MockServ(port=42423)
        serv.expects('/service?request=GetFeatureInfo&service=WMS&Version=1.1.1&SRS=EPSG:4326'
            '&BBOX=-80.0,-40.0,0.0,0.0&WIDTH=200&HEIGHT=100&styles=&FORMAT=image/png&X=10&Y=10'
            '&query_layers=fi&layers=fi')
        serv.returns('infoinfo')
        with serv:
            resp = self.app.get(FI_REQ + 'query_layers=layer1b&layers=layer1b', extra_environ={'mapproxy.authorize': auth})
            eq_(resp.body, 'infoinfo')

    def test_get_featureinfo_limited_to_outside(self):
        def auth(service, layers, query_extent, **kw):
            eq_(query_extent, ('EPSG:4326', (-80.0, -40.0, 0.0, 0.0)))
            eq_(service, 'wms.featureinfo')
            eq_(len(layers), 1)
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1b': {'featureinfo': True, 'limited_to':  {'srs': 'EPSG:4326', 'geometry': [-40.0, -40.0, 0.0, 0.0]}},
                }
            }

        resp = self.app.get(FI_REQ + 'query_layers=layer1b&layers=layer1b', extra_environ={'mapproxy.authorize': auth})
        # empty response, FI request is outside of limited_to geometry
        eq_(resp.body, '')

    def test_get_featureinfo_global_limited(self):
        def auth(service, layers, query_extent, **kw):
            eq_(query_extent, ('EPSG:4326', (-80.0, -40.0, 0.0, 0.0)))
            eq_(service, 'wms.featureinfo')
            eq_(len(layers), 1)
            return {
                'authorized': 'partial',
                'limited_to':  {'srs': 'EPSG:4326', 'geometry': [-40.0, -40.0, 0.0, 0.0]},
                'layers': {
                    'layer1b': {'featureinfo': True},
                },
            }
        resp = self.app.get(FI_REQ + 'query_layers=layer1b&layers=layer1b', extra_environ={'mapproxy.authorize': auth})
        # empty response, FI request is outside of limited_to geometry
        eq_(resp.body, '')


TMS_CAPABILITIES_REQ = '/tms/1.0.0'

class TestTMSAuth(SystemTest):
    config = test_config

    def test_capabilities_authorize_all(self):
        def auth(service, layers, environ, **kw):
            eq_(environ['PATH_INFO'], '/tms/1.0.0')
            eq_(service, 'tms')
            eq_(len(layers), 6)
            return {'authorized': 'full'}

        resp = self.app.get(TMS_CAPABILITIES_REQ, extra_environ={'mapproxy.authorize': auth})
        xml = resp.lxml
        eq_(xml.xpath('//TileMap/@title'), ['layer 1a', 'layer 1b', 'layer 1', 'layer 2a', 'layer 2b1', 'layer 3'])

    def test_capabilities_authorize_none(self):
        def auth(service, layers, **kw):
            eq_(service, 'tms')
            eq_(len(layers), 6)
            return {'authorized': 'none'}
        self.app.get(TMS_CAPABILITIES_REQ, extra_environ={'mapproxy.authorize': auth}, status=403)

    def test_capabilities_unauthenticated(self):
        def auth(service, layers, **kw):
            eq_(service, 'tms')
            eq_(len(layers), 6)
            return {'authorized': 'unauthenticated'}
        self.app.get(TMS_CAPABILITIES_REQ, extra_environ={'mapproxy.authorize': auth}, status=401)

    def test_capabilities_authorize_partial(self):
        def auth(service, layers, **kw):
            eq_(service, 'tms')
            eq_(len(layers), 6)
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1a': {'tile': True},
                    'layer1b': {'tile': False},
                    'layer2': {'tile': True},
                    'layer2b': {'tile': True},
                    'layer2b1': {'tile': True},
                }
            }
        resp = self.app.get(TMS_CAPABILITIES_REQ, extra_environ={'mapproxy.authorize': auth})
        xml = resp.lxml
        eq_(xml.xpath('//TileMap/@title'), ['layer 1a', 'layer 2b1'])

    def test_layer_capabilities_authorize_none(self):
        def auth(service, layers, **kw):
            eq_(service, 'tms')
            eq_(len(layers), 1)
            return {
                'authorized': 'none',
            }
        self.app.get(TMS_CAPABILITIES_REQ + '/layer1', extra_environ={'mapproxy.authorize': auth}, status=403)

    def test_layer_capabilities_authorize_all(self):
        def auth(service, layers, **kw):
            eq_(service, 'tms')
            eq_(len(layers), 1)
            return {
                'authorized': 'full',
            }
        resp = self.app.get(TMS_CAPABILITIES_REQ + '/layer1', extra_environ={'mapproxy.authorize': auth})
        xml = resp.lxml
        eq_(xml.xpath('//TileMap/Title/text()'), ['layer 1'])

    def test_layer_capabilities_authorize_partial(self):
        def auth(service, layers, **kw):
            eq_(service, 'tms')
            eq_(len(layers), 1)
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'tile': True},
                }
            }
        resp = self.app.get(TMS_CAPABILITIES_REQ + '/layer1', extra_environ={'mapproxy.authorize': auth})
        xml = resp.lxml
        eq_(xml.xpath('//TileMap/Title/text()'), ['layer 1'])

    def test_layer_capabilities_deny_partial(self):
        def auth(service, layers, **kw):
            eq_(service, 'tms')
            eq_(len(layers), 1)
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'tile': False},
                }
            }
        self.app.get(TMS_CAPABILITIES_REQ + '/layer1', extra_environ={'mapproxy.authorize': auth}, status=403)

    def test_get_tile(self):
        def auth(service, layers, environ, query_extent, **kw):
            eq_(environ['PATH_INFO'], '/tms/1.0.0/layer1_EPSG900913/0/0/0.png')
            eq_(service, 'tms')
            eq_(query_extent[0], 'EPSG:900913')
            assert bbox_equals(query_extent[1], (-20037508.342789244, -20037508.342789244, 0, 0))
            eq_(len(layers), 1)
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'tile': True},
                }
            }
        resp = self.app.get(TMS_CAPABILITIES_REQ + '/layer1_EPSG900913/0/0/0.png', extra_environ={'mapproxy.authorize': auth})
        eq_(resp.content_type, 'image/png')
        assert resp.content_length > 1000

    def test_get_tile_global_limited_to(self):
        # check with limited_to for all layers
        auth_dict = {
                'authorized': 'partial',
                'limited_to': {
                    'geometry': [-180, -89, -90, 89],
                    'srs': 'EPSG:4326',
                },
                'layers': {
                    'layer3': {'tile': True},
                }
            }
        self.check_get_tile_limited_to(auth_dict)

    def test_get_tile_layer_limited_to(self):
        # check with limited_to for one layer
        auth_dict = {
            'authorized': 'partial',
            'layers': {
                'layer3': {
                    'tile': True,
                    'limited_to': {
                        'geometry': [-180, -89, -90, 89],
                        'srs': 'EPSG:4326',
                    }
                },
            }
        }

        self.check_get_tile_limited_to(auth_dict)

    def check_get_tile_limited_to(self, auth_dict):
        def auth(service, layers, environ, query_extent, **kw):
            eq_(environ['PATH_INFO'], '/tms/1.0.0/layer3/0/0/0.jpeg')
            eq_(service, 'tms')
            eq_(len(layers), 1)
            eq_(query_extent[0], 'EPSG:900913')
            assert bbox_equals(query_extent[1], (-20037508.342789244, -20037508.342789244, 0, 0))

            return auth_dict

        serv = MockServ(port=42423)
        serv.expects('/1/0/0.png')
        serv.returns(create_tmp_image((256, 256), color=(255, 0, 0)), headers={'content-type': 'image/png'})
        with serv:
            resp = self.app.get(TMS_CAPABILITIES_REQ + '/layer3/0/0/0.jpeg', extra_environ={'mapproxy.authorize': auth})

        eq_(resp.content_type, 'image/png')

        img = img_from_buf(resp.body)
        img = img.convert('RGBA')
        # left part authorized, red
        eq_(img.crop((0, 0, 127, 255)).getcolors()[0], (127*255, (255, 0, 0, 255)))
        # right part not authorized, transparent
        eq_(img.crop((129, 0, 255, 255)).getcolors()[0][1][3], 0)

    def test_get_tile_authorize_none(self):
        def auth(service, layers, **kw):
            eq_(service, 'tms')
            eq_(len(layers), 1)
            return {
                'authorized': 'none',
            }
        self.app.get(TMS_CAPABILITIES_REQ + '/layer1/0/0/0.png', extra_environ={'mapproxy.authorize': auth}, status=403)


class TestKMLAuth(SystemTest):
    config = test_config

    def test_superoverlay_authorize_all(self):
        def auth(service, layers, environ, **kw):
            eq_(environ['PATH_INFO'], '/kml/layer1/0/0/0.kml')
            eq_(service, 'kml')
            eq_(len(layers), 1)
            return {'authorized': 'full'}

        resp = self.app.get('/kml/layer1/0/0/0.kml', extra_environ={'mapproxy.authorize': auth})
        xml = resp.lxml
        eq_(xml.xpath('kml:Document/kml:name/text()', namespaces={'kml': 'http://www.opengis.net/kml/2.2'}), ['layer1'])

    def test_superoverlay_authorize_none(self):
        def auth(service, layers, **kw):
            eq_(service, 'kml')
            eq_(len(layers), 1)
            return {'authorized': 'none'}

        self.app.get('/kml/layer1/0/0/0.kml', extra_environ={'mapproxy.authorize': auth}, status=403)

    def test_superoverlay_unauthenticated(self):
        def auth(service, layers, **kw):
            eq_(service, 'kml')
            eq_(len(layers), 1)
            return {'authorized': 'unauthenticated'}

        self.app.get('/kml/layer1/0/0/0.kml', extra_environ={'mapproxy.authorize': auth}, status=401)

    def test_superoverlay_authorize_partial(self):
        def auth(service, layers, query_extent, **kw):
            eq_(service, 'kml')
            eq_(len(layers), 1)
            eq_(query_extent[0], 'EPSG:900913')
            assert bbox_equals(query_extent[1], (-20037508.342789244, -20037508.342789244, 20037508.342789244, 20037508.342789244))

            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'tile': True},
                }
            }
        resp = self.app.get('/kml/layer1/0/0/0.kml', extra_environ={'mapproxy.authorize': auth})
        xml = resp.lxml
        eq_(xml.xpath('kml:Document/kml:name/text()', namespaces={'kml': 'http://www.opengis.net/kml/2.2'}), ['layer1'])

    def test_superoverlay_deny_partial(self):
        def auth(service, layers, **kw):
            eq_(service, 'kml')
            eq_(len(layers), 1)
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'tile': False},
                }
            }
        self.app.get('/kml/layer1/0/0/0.kml', extra_environ={'mapproxy.authorize': auth}, status=403)

    def test_get_tile_global_limited_to(self):
        # check with limited_to for all layers
        auth_dict = {
                'authorized': 'partial',
                'limited_to': {
                    'geometry': [-180, -89, -90, 89],
                    'srs': 'EPSG:4326',
                },
                'layers': {
                    'layer3': {'tile': True},
                }
            }
        self.check_get_tile_limited_to(auth_dict)

    def test_get_tile_layer_limited_to(self):
        # check with limited_to for one layer
        auth_dict = {
            'authorized': 'partial',
            'layers': {
                'layer3': {
                    'tile': True,
                    'limited_to': {
                        'geometry': [-180, -89, -90, 89],
                        'srs': 'EPSG:4326',
                    }
                },
            }
        }

        self.check_get_tile_limited_to(auth_dict)

    def check_get_tile_limited_to(self, auth_dict):
        def auth(service, layers, environ, query_extent, **kw):
            eq_(environ['PATH_INFO'], '/kml/layer3_EPSG900913/1/0/0.jpeg')
            eq_(service, 'kml')
            eq_(len(layers), 1)
            eq_(query_extent[0], 'EPSG:900913')
            assert bbox_equals(query_extent[1], (-20037508.342789244, -20037508.342789244, 0, 0))
            return auth_dict

        serv = MockServ(port=42423)
        serv.expects('/1/0/0.png')
        serv.returns(create_tmp_image((256, 256), color=(255, 0, 0)), headers={'content-type': 'image/png'})
        with serv:
            resp = self.app.get('/kml/layer3_EPSG900913/1/0/0.jpeg', extra_environ={'mapproxy.authorize': auth})

        eq_(resp.content_type, 'image/png')

        img = img_from_buf(resp.body)
        img = img.convert('RGBA')
        # left part authorized, red
        eq_(img.crop((0, 0, 127, 255)).getcolors()[0], (127*255, (255, 0, 0, 255)))
        # right part not authorized, transparent
        eq_(img.crop((129, 0, 255, 255)).getcolors()[0][1][3], 0)


WMTS_CAPABILITIES_REQ = '/wmts/1.0.0/WMTSCapabilities.xml'

class TestWMTSAuth(SystemTest):
    config = test_config

    def test_capabilities_authorize_all(self):
        def auth(service, layers, environ, **kw):
            eq_(environ['PATH_INFO'], '/wmts/1.0.0/WMTSCapabilities.xml')
            eq_(service, 'wmts')
            eq_(len(layers), 6)
            return {'authorized': 'full'}

        resp = self.app.get(WMTS_CAPABILITIES_REQ, extra_environ={'mapproxy.authorize': auth})
        xml = resp.lxml
        eq_(set(xml.xpath('//wmts:Layer/ows:Title/text()',
            namespaces={'wmts': 'http://www.opengis.net/wmts/1.0', 'ows': 'http://www.opengis.net/ows/1.1'})),
            set(['layer 1b', 'layer 1a', 'layer 2a', 'layer 2b1', 'layer 1', 'layer 3']))

    def test_capabilities_authorize_none(self):
        def auth(service, layers, **kw):
            eq_(service, 'wmts')
            eq_(len(layers), 6)
            return {'authorized': 'none'}
        self.app.get(WMTS_CAPABILITIES_REQ, extra_environ={'mapproxy.authorize': auth}, status=403)

    def test_capabilities_unauthenticated(self):
        def auth(service, layers, **kw):
            eq_(service, 'wmts')
            eq_(len(layers), 6)
            return {'authorized': 'unauthenticated'}
        self.app.get(WMTS_CAPABILITIES_REQ, extra_environ={'mapproxy.authorize': auth}, status=401)

    def test_capabilities_authorize_partial(self):
        def auth(service, layers, **kw):
            eq_(service, 'wmts')
            eq_(len(layers), 6)
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1a': {'tile': True},
                    'layer1b': {'tile': False},
                    'layer2': {'tile': True},
                    'layer2b': {'tile': True},
                    'layer2b1': {'tile': True},
                }
            }
        resp = self.app.get(WMTS_CAPABILITIES_REQ, extra_environ={'mapproxy.authorize': auth})
        xml = resp.lxml
        eq_(set(xml.xpath('//wmts:Layer/ows:Title/text()',
            namespaces={'wmts': 'http://www.opengis.net/wmts/1.0', 'ows': 'http://www.opengis.net/ows/1.1'})),
            set(['layer 1a', 'layer 2b1']))

    def test_get_tile(self):
        def auth(service, layers, environ, query_extent, **kw):
            eq_(environ['PATH_INFO'], '/wmts/layer1/GLOBAL_MERCATOR/0/0/0.png')
            eq_(service, 'wmts')
            eq_(len(layers), 1)
            eq_(query_extent[0], 'EPSG:900913')
            assert bbox_equals(query_extent[1], (-20037508.342789244, -20037508.342789244, 20037508.342789244, 20037508.342789244))
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'tile': True},
                }
            }
        resp = self.app.get('/wmts/layer1/GLOBAL_MERCATOR/0/0/0.png', extra_environ={'mapproxy.authorize': auth})
        eq_(resp.content_type, 'image/png')
        assert resp.content_length > 1000

    def test_get_tile_global_limited_to(self):
        # check with limited_to for all layers
        auth_dict = {
                'authorized': 'partial',
                'limited_to': {
                    'geometry': [-180, -89, -90, 89],
                    'srs': 'EPSG:4326',
                },
                'layers': {
                    'layer3': {'tile': True},
                }
            }
        self.check_get_tile_limited_to(auth_dict)

    def test_get_tile_layer_limited_to(self):
        # check with limited_to for one layer
        auth_dict = {
            'authorized': 'partial',
            'layers': {
                'layer3': {
                    'tile': True,
                    'limited_to': {
                        'geometry': [-180, -89, -90, 89],
                        'srs': 'EPSG:4326',
                    }
                },
            }
        }

        self.check_get_tile_limited_to(auth_dict)

    def check_get_tile_limited_to(self, auth_dict):
        def auth(service, layers, environ, query_extent, **kw):
            eq_(environ['PATH_INFO'], '/wmts/layer3/GLOBAL_MERCATOR/1/0/0.jpeg')
            eq_(service, 'wmts')
            eq_(len(layers), 1)
            eq_(query_extent[0], 'EPSG:900913')
            assert bbox_equals(query_extent[1], (-20037508.342789244, 0, 0, 20037508.342789244))
            return auth_dict

        serv = MockServ(port=42423)
        serv.expects('/1/0/1.png')
        serv.returns(create_tmp_image((256, 256), color=(255, 0, 0)), headers={'content-type': 'image/png'})
        with serv:
            resp = self.app.get('/wmts/layer3/GLOBAL_MERCATOR/1/0/0.jpeg', extra_environ={'mapproxy.authorize': auth})

        eq_(resp.content_type, 'image/png')

        img = img_from_buf(resp.body)
        img = img.convert('RGBA')
        # left part authorized, red
        eq_(img.crop((0, 0, 127, 255)).getcolors()[0], (127*255, (255, 0, 0, 255)))
        # right part not authorized, transparent
        eq_(img.crop((129, 0, 255, 255)).getcolors()[0][1][3], 0)

    def test_get_tile_limited_to_outside(self):
        def auth(service, layers, environ, **kw):
            eq_(environ['PATH_INFO'], '/wmts/layer3/GLOBAL_MERCATOR/2/0/0.jpeg')
            eq_(service, 'wmts')
            eq_(len(layers), 1)
            return {
                'authorized': 'partial',
                'limited_to': {
                    'geometry': [0, -89, 90, 89],
                    'srs': 'EPSG:4326',
                },
                'layers': {
                    'layer3': {'tile': True},
                }
            }

        resp = self.app.get('/wmts/layer3/GLOBAL_MERCATOR/2/0/0.jpeg', extra_environ={'mapproxy.authorize': auth})

        eq_(resp.content_type, 'image/png')
        is_transparent(resp.body)

    def test_get_tile_limited_to_inside(self):
        def auth(service, layers, environ, **kw):
            eq_(environ['PATH_INFO'], '/wmts/layer3/GLOBAL_MERCATOR/1/0/0.jpeg')
            eq_(service, 'wmts')
            eq_(len(layers), 1)
            return {
                'authorized': 'partial',
                'limited_to': {
                    'geometry': [-180, -89, 180, 89],
                    'srs': 'EPSG:4326',
                },
                'layers': {
                    'layer3': {'tile': True},
                }
            }

        serv = MockServ(port=42423)
        serv.expects('/1/0/1.png')
        serv.returns(create_tmp_image((256, 256), color=(255, 0, 0)), headers={'content-type': 'image/png'})
        with serv:
            resp = self.app.get('/wmts/layer3/GLOBAL_MERCATOR/1/0/0.jpeg', extra_environ={'mapproxy.authorize': auth})

        eq_(resp.content_type, 'image/jpeg')

        img = img_from_buf(resp.body)
        eq_(img.getcolors()[0], (256*256, (255, 0, 0)))

    def test_get_tile_kvp(self):
        def auth(service, layers, environ, **kw):
            eq_(environ['PATH_INFO'], '/service')
            eq_(service, 'wmts')
            eq_(len(layers), 1)
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'tile': True},
                }
            }
        resp = self.app.get('/service?service=WMTS&version=1.0.0&layer=layer1&request=GetTile&'
            'style=&tilematrixset=GLOBAL_MERCATOR&tilematrix=00&tilerow=0&tilecol=0&format=image/png', extra_environ={'mapproxy.authorize': auth})
        eq_(resp.content_type, 'image/png')

    def test_get_tile_authorize_none(self):
        def auth(service, layers, **kw):
            eq_(service, 'wmts')
            eq_(len(layers), 1)
            return {
                'authorized': 'none',
            }
        self.app.get('/wmts/layer1/GLOBAL_MERCATOR/0/0/0.png', extra_environ={'mapproxy.authorize': auth}, status=403)

    def test_get_tile_authorize_none_kvp(self):
        def auth(service, layers, environ, **kw):
            eq_(environ['PATH_INFO'], '/service')
            eq_(service, 'wmts')
            eq_(len(layers), 1)
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'tile': False},
                }
            }
        self.app.get('/service?service=WMTS&version=1.0.0&layer=layer1&request=GetTile&'
            'style=&tilematrixset=GLOBAL_MERCATOR&tilematrix=00&tilerow=0&tilecol=0&format=image/png',
            extra_environ={'mapproxy.authorize': auth}, status=403)

class TestDemoAuth(SystemTest):
    config = test_config

    def test_authorize_all(self):
        def auth(service, layers, environ, **kw):
            return {'authorized': 'full'}
        self.app.get('/demo', extra_environ={'mapproxy.authorize': auth})

    def test_authorize_none(self):
        def auth(service, layers, environ, **kw):
            return {'authorized': 'none'}
        self.app.get('/demo', extra_environ={'mapproxy.authorize': auth}, status=403)

    def test_unauthenticated(self):
        def auth(service, layers, environ, **kw):
            return {'authorized': 'unauthenticated'}
        self.app.get('/demo', extra_environ={'mapproxy.authorize': auth}, status=401)

    def test_superoverlay_authorize_none(self):
        def auth(service, layers, **kw):
            eq_(service, 'kml')
            eq_(len(layers), 1)
            return {'authorized': 'none'}

        self.app.get('/kml/layer1/0/0/0.kml', extra_environ={'mapproxy.authorize': auth}, status=403)

    def test_superoverlay_unauthenticated(self):
        def auth(service, layers, **kw):
            eq_(service, 'kml')
            eq_(len(layers), 1)
            return {'authorized': 'unauthenticated'}

        self.app.get('/kml/layer1/0/0/0.kml', extra_environ={'mapproxy.authorize': auth}, status=401)


########NEW FILE########
__FILENAME__ = test_behind_proxy
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'layer.yaml', with_cache_data=True)

def teardown_module():
    module_teardown(test_config)


class TestWMSBehindProxy(SystemTest):
    """
    Check WMS OnlineResources for requests behind HTTP proxies.
    """
    config = test_config

    def test_no_proxy(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetCapabilities'
                            '&VERSION=1.1.0')
        assert '"http://localhost/service' in resp

    def test_with_script_name(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetCapabilities'
                            '&VERSION=1.1.0', extra_environ={'HTTP_X_SCRIPT_NAME': '/foo'})
        assert '"http://localhost/service' not in resp
        assert '"http://localhost/foo/service' in resp

    def test_with_host(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetCapabilities'
                            '&VERSION=1.1.0', extra_environ={'HTTP_HOST': 'example.org'})
        assert '"http://localhost/service' not in resp
        assert '"http://example.org/service' in resp

    def test_with_host_and_script_name(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetCapabilities'
            '&VERSION=1.1.0', extra_environ={'HTTP_X_SCRIPT_NAME': '/foo', 'HTTP_HOST': 'example.org'})
        assert '"http://localhost/service' not in resp
        assert '"http://example.org/foo/service' in resp

    def test_with_forwarded_host(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetCapabilities'
                            '&VERSION=1.1.0', extra_environ={'HTTP_X_FORWARDED_HOST': 'example.org, bar.org'})
        assert '"http://localhost/service' not in resp
        assert '"http://example.org/service' in resp

    def test_with_forwarded_host_and_script_name(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetCapabilities'
            '&VERSION=1.1.0', extra_environ={'HTTP_X_FORWARDED_HOST': 'example.org', 'HTTP_X_SCRIPT_NAME': '/foo'})
        assert '"http://localhost/service' not in resp
        assert '"http://example.org/foo/service' in resp

    def test_with_forwarded_proto_and_script_name_and_host(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetCapabilities'
            '&VERSION=1.1.0', extra_environ={
                'HTTP_X_FORWARDED_PROTO': 'https',
                'HTTP_X_SCRIPT_NAME': '/foo',
                'HTTP_HOST': 'example.org:443'
            })
        assert '"http://localhost/service' not in resp
        assert '"https://example.org/foo/service' in resp


########NEW FILE########
__FILENAME__ = test_cache_grid_names
# This file is part of the MapProxy project.
# Copyright (C) 2012 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os
from mapproxy.test.image import tmp_image
from mapproxy.test.http import mock_httpd
from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config
from nose.tools import eq_

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'cache_grid_names.yaml')

def teardown_module():
    module_teardown(test_config)

class TestCacheGridNames(SystemTest):
    config = test_config
    
    def test_tms_capabilities(self):
        resp = self.app.get('/tms/1.0.0/')
        assert 'Cached Layer' in resp
        assert 'wms_cache/utm32n' in resp
        assert 'wms_cache_utm32n' not in resp
        xml = resp.lxml
        assert xml.xpath('count(//TileMap)') == 2

    def test_tms_layer_capabilities(self):
        resp = self.app.get('/tms/1.0.0/wms_cache/utm32n')
        assert 'Cached Layer' in resp
        assert 'wms_cache/utm32n' in resp
        assert 'wms_cache_utm32n' not in resp
        xml = resp.lxml
        eq_(xml.xpath('count(//TileSet)'), 12)

    def test_kml(self):
        resp = self.app.get('/kml/wms_cache/utm32n/4/2/2.kml')
        assert 'wms_cache/utm32n' in resp.body
        
    def test_get_tile(self):
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/service?LAYERs=bar&SERVICE=WMS&FORMAT=image%2Fjpeg'
                                      '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A25832&styles='
                                      '&VERSION=1.1.1&BBOX=283803.311362,5609091.90862,319018.942566,5644307.53982'
                                      '&WIDTH=256'},
                            {'body': img.read(), 'headers': {'content-type': 'image/jpeg'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get('/tms/1.0.0/wms_cache/utm32n/4/2/2.jpeg')
                eq_(resp.content_type, 'image/jpeg')
                self.created_tiles.append('wms_cache/utm32n/04/000/000/002/000/000/002.jpeg')

    def test_get_tile_no_grid_name(self):
        # access tiles with grid name from TMS but cache still uses old SRS-code path
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/service?LAYERs=bar&SERVICE=WMS&FORMAT=image%2Fjpeg'
                                      '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A25832&styles='
                                      '&VERSION=1.1.1&BBOX=283803.311362,5609091.90862,319018.942566,5644307.53982'
                                      '&WIDTH=256'},
                            {'body': img.read(), 'headers': {'content-type': 'image/jpeg'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get('/tms/1.0.0/wms_cache_no_grid_name/utm32n/4/2/2.jpeg')
                eq_(resp.content_type, 'image/jpeg')
                self.created_tiles.append('wms_cache_no_grid_name_EPSG25832/04/000/000/002/000/000/002.jpeg')

    def created_tiles_filenames(self):
        base_dir = base_config().cache.base_dir
        for filename in self.created_tiles:
            yield os.path.join(base_dir, filename)
    
    def check_created_tiles(self):
        for filename in self.created_tiles_filenames():
            if not os.path.exists(filename):
                assert False, "didn't found tile " + filename
    
    def teardown(self):
        self.check_created_tiles()
        for filename in self.created_tiles_filenames():
            if os.path.exists(filename):
                os.remove(filename)

########NEW FILE########
__FILENAME__ = test_cache_mbtiles
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

import os
import shutil

from cStringIO import StringIO

from mapproxy.request.wms import WMS111MapRequest
from mapproxy.test.http import MockServ
from mapproxy.test.image import is_png, create_tmp_image
from mapproxy.test.system import prepare_env, create_app, module_teardown, SystemTest
from nose.tools import eq_

test_config = {}

def setup_module():
    prepare_env(test_config, 'cache_mbtiles.yaml')

    shutil.copy(os.path.join(test_config['fixture_dir'], 'cache.mbtiles'),
        test_config['base_dir'])
    create_app(test_config)

def teardown_module():
    module_teardown(test_config)

class TestMBTilesCache(SystemTest):
    config = test_config
    def setup(self):
        SystemTest.setup(self)
        self.common_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS',
             version='1.1.1', bbox='-180,-80,0,0', width='200', height='200',
             layers='mb', srs='EPSG:4326', format='image/png',
             styles='', request='GetMap'))

    def test_get_map_cached(self):
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        data = StringIO(resp.body)
        assert is_png(data)

    def test_get_map_uncached(self):
        mbtiles_file = os.path.join(test_config['base_dir'], 'cache.mbtiles')
        tiles_lock_dir = os.path.join(test_config['base_dir'], 'testlockdir')

        assert os.path.exists(mbtiles_file) # already created on startup
        assert not os.path.exists(tiles_lock_dir)

        self.common_map_req.params.bbox = '-180,0,0,80'
        serv = MockServ(port=42423)
        serv.expects('/tiles/01/000/000/000/000/000/001.png')
        serv.returns(create_tmp_image((256, 256)))
        with serv:
            resp = self.app.get(self.common_map_req)
            eq_(resp.content_type, 'image/png')
            data = StringIO(resp.body)
            assert is_png(data)

        # now cached
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        data = StringIO(resp.body)
        assert is_png(data)

        # custom tile_lock_dir created
        assert os.path.exists(tiles_lock_dir)

########NEW FILE########
__FILENAME__ = test_cache_source
# This file is part of the MapProxy project.
# Copyright (C) 2012 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os
from mapproxy.request.wms import WMS111MapRequest
from mapproxy.test.image import tmp_image
from mapproxy.test.http import mock_httpd
from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config
from nose.tools import eq_

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'cache_source.yaml')

def teardown_module():
    module_teardown(test_config)

class TestCacheSource(SystemTest):
    config = test_config

    def test_tms_capabilities(self):
        resp = self.app.get('/tms/1.0.0/')
        assert 'transformed tile source' in resp
        xml = resp.lxml

        assert xml.xpath('count(//TileMap)') == 3

    def test_get_map_through_cache(self):
        map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS',
             version='1.1.1', width='100', height='100',
             bbox='432890.564641,5872387.45834,466833.867667,5928359.08814',
             layers='tms_transf', srs='EPSG:25832', format='image/png',
             styles='', request='GetMap'))

        expected_reqs = []
        with tmp_image((256, 256), format='jpeg') as img:
            img = img.read()
            # tms_cache_out has meta_size of [2, 2] but we need larger extent for transformation
            for tile in [(132, 172, 8), (133, 172, 8), (134, 172, 8), (132, 173, 8),
                (133, 173, 8), (134, 173, 8), (132, 174, 8), (133, 174, 8), (134, 174, 8)]:
                expected_reqs.append(
                    ({'path': r'/tiles/%02d/000/000/%03d/000/000/%03d.png' % (tile[2], tile[0], tile[1])},
                     {'body': img, 'headers': {'content-type': 'image/png'}}))
            with mock_httpd(('localhost', 42423), expected_reqs, unordered=True):
                resp = self.app.get(map_req)
                eq_(resp.content_type, 'image/png')

    def test_get_tile_through_cache(self):
        # request tile from tms_transf,
        # should get tile from tms_source via tms_cache_in/out
        expected_reqs = []
        with tmp_image((256, 256), format='jpeg') as img:
            for tile in [(8, 11, 4), (8, 10, 4)]:
                expected_reqs.append(
                    ({'path': r'/tiles/%02d/000/000/%03d/000/000/%03d.png' % (tile[2], tile[0], tile[1])},
                     {'body': img.read(), 'headers': {'content-type': 'image/png'}}))
            with mock_httpd(('localhost', 42423), expected_reqs, unordered=True):
                resp = self.app.get('/tms/1.0.0/tms_transf/EPSG25832/0/0/0.png')
                eq_(resp.content_type, 'image/png')

                self.created_tiles.append('tms_cache_out_EPSG25832/00/000/000/000/000/000/000.png')

    def test_get_tile_from_sub_grid(self):
        # create tile in old cache
        tile_filename = os.path.join(self.config['cache_dir'], 'old_cache_EPSG3857/01/000/000/001/000/000/000.png')
        os.makedirs(os.path.dirname(tile_filename))
        # use text to check that mapproxy does not access the tile as image
        open(tile_filename, 'w').write('foo')

        # access new cache, should get existing tile from old cache
        resp = self.app.get('/tiles/new_cache_EPSG3857/0/0/0.png')
        eq_(resp.content_type, 'image/png')
        eq_(resp.body, 'foo')

        self.created_tiles.append('old_cache_EPSG3857/01/000/000/001/000/000/000.png')
        self.created_tiles.append('new_cache_EPSG3857/00/000/000/000/000/000/000.png')


    def test_get_tile_combined_cache(self):
        # request from cache with two cache sources where only one
        # is compatible (supports tiled_only)
        expected_reqs = []
        with tmp_image((256, 256), format='jpeg') as img:
            img = img.read()
            for tile in [
                r'/tiles/04/000/000/008/000/000/011.png',
                r'/tiles/04/000/000/008/000/000/010.png',
                r'/tiles/utm/00/000/000/000/000/000/000.png',
            ]:
                expected_reqs.append(
                    ({'path': tile},
                     {'body': img, 'headers': {'content-type': 'image/png'}}))

            with mock_httpd(('localhost', 42423), expected_reqs, unordered=True):
                resp = self.app.get('/tms/1.0.0/combined/EPSG25832/0/0/0.png')
                eq_(resp.content_type, 'image/png')


########NEW FILE########
__FILENAME__ = test_combined_sources
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

from cStringIO import StringIO
from mapproxy.request.wms import WMS111MapRequest
from mapproxy.platform.image import Image
from mapproxy.test.image import is_png, tmp_image, create_tmp_image
from mapproxy.test.http import mock_httpd
from mapproxy.test.system import module_setup, module_teardown, SystemTest
from nose.tools import eq_

test_config = {}

def setup_module():
    module_setup(test_config, 'combined_sources.yaml')

def teardown_module():
    module_teardown(test_config)

class TestCoverageWMS(SystemTest):
    config = test_config
    def setup(self):
        SystemTest.setup(self)
        self.common_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS', 
             version='1.1.1', bbox='9,50,10,51', width='200', height='200',
             layers='combinable', srs='EPSG:4326', format='image/png',
             styles='', request='GetMap'))
    
    def test_combined(self):
        common_params = (r'?SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326&styles='
                                  '&VERSION=1.1.1&BBOX=9.0,50.0,10.0,51.0'
                                  '&WIDTH=200&transparent=True')
        
        with tmp_image((200, 200), format='png') as img:
            img = img.read()
            expected_req = [({'path': '/service_a' + common_params + '&layers=a_one,a_two,a_three,a_four'},
                             {'body': img, 'headers': {'content-type': 'image/png'}}),
                            ({'path': '/service_b' + common_params + '&layers=b_one'},
                             {'body': img, 'headers': {'content-type': 'image/png'}})
                            ]
                             
            with mock_httpd(('localhost', 42423), expected_req):
                self.common_map_req.params.layers = 'combinable'
                resp = self.app.get(self.common_map_req)
                eq_(resp.content_type, 'image/png')
                data = StringIO(resp.body)
                assert is_png(data)

    def test_uncombined(self):
        common_params = (r'?SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326&styles='
                                  '&VERSION=1.1.1&BBOX=9.0,50.0,10.0,51.0'
                                  '&WIDTH=200&transparent=True')
        
        with tmp_image((200, 200), format='png') as img:
            img = img.read()
            expected_req = [({'path': '/service_a' + common_params + '&layers=a_one'},
                             {'body': img, 'headers': {'content-type': 'image/png'}}),
                            ({'path': '/service_b' + common_params + '&layers=b_one'},
                             {'body': img, 'headers': {'content-type': 'image/png'}}),
                            ({'path': '/service_a' + common_params + '&layers=a_two,a_three'},
                             {'body': img, 'headers': {'content-type': 'image/png'}})
                            ]
                             
            with mock_httpd(('localhost', 42423), expected_req):
                self.common_map_req.params.layers = 'uncombinable'
                resp = self.app.get(self.common_map_req)
                eq_(resp.content_type, 'image/png')
                data = StringIO(resp.body)
                assert is_png(data)
    
    def test_combined_layers(self):
        common_params = (r'?SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326&styles='
                                  '&VERSION=1.1.1&BBOX=9.0,50.0,10.0,51.0'
                                  '&WIDTH=200&transparent=True')
        
        with tmp_image((200, 200), format='png') as img:
            img = img.read()
            expected_req = [
                            ({'path': '/service_a' + common_params + '&layers=a_one'},
                             {'body': img, 'headers': {'content-type': 'image/png'}}),
                            ({'path': '/service_b' + common_params + '&layers=b_one'},
                             {'body': img, 'headers': {'content-type': 'image/png'}}),
                            ({'path': '/service_a' + common_params + '&layers=a_two,a_three,a_four'},
                             {'body': img, 'headers': {'content-type': 'image/png'}}),
                            ]
                             
            with mock_httpd(('localhost', 42423), expected_req):
                self.common_map_req.params.layers = 'uncombinable,single'
                resp = self.app.get(self.common_map_req)
                eq_(resp.content_type, 'image/png')
                data = StringIO(resp.body)
                assert is_png(data)
    
    def test_layers_with_opacity(self):
        # overlay with opacity -> request should not be combined
        common_params = (r'?SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326&styles='
                                  '&VERSION=1.1.1&BBOX=9.0,50.0,10.0,51.0'
                                  '&WIDTH=200')
        
        img_bg = create_tmp_image((200, 200), color=(0, 0, 0))
        img_fg = create_tmp_image((200, 200), color=(255, 0, 128))
        
        expected_req = [
                        ({'path': '/service_a' + common_params + '&layers=a_one'},
                         {'body': img_bg, 'headers': {'content-type': 'image/png'}}),
                        ({'path': '/service_a' + common_params + '&layers=a_two'},
                         {'body': img_fg, 'headers': {'content-type': 'image/png'}}),
                        ]
                         
        with mock_httpd(('localhost', 42423), expected_req):
            self.common_map_req.params.layers = 'opacity_base,opacity_overlay'
            resp = self.app.get(self.common_map_req)
            eq_(resp.content_type, 'image/png')
            data = StringIO(resp.body)
            assert is_png(data)
            img = Image.open(data)
            eq_(img.getcolors()[0], ((200*200),(127, 0, 64)))

    def test_combined_transp_color(self):
        # merged to one request because both layers share the same transparent_color
        common_params = (r'?SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326&styles='
                                  '&VERSION=1.1.1&BBOX=9.0,50.0,10.0,51.0'
                                  '&WIDTH=200&transparent=True')
        
        with tmp_image((200, 200), color=(255, 0, 0), format='png') as img:
            img = img.read()
            expected_req = [({'path': '/service_a' + common_params + '&layers=a_iopts_one,a_iopts_two'},
                             {'body': img, 'headers': {'content-type': 'image/png'}}),
                            ]
                            
            with mock_httpd(('localhost', 42423), expected_req):
                self.common_map_req.params.layers = 'layer_image_opts1,layer_image_opts2'
                self.common_map_req.params.transparent = True
                resp = self.app.get(self.common_map_req)
                resp.content_type = 'image/png'
                data = StringIO(resp.body)
                assert is_png(data)
                img = Image.open(data)
                eq_(img.getcolors()[0], ((200*200),(255, 0, 0, 0)))
    
    def test_combined_mixed_transp_color(self):
        # not merged to one request because only one layer has transparent_color
        common_params = (r'?SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326&styles='
                                  '&VERSION=1.1.1&BBOX=9.0,50.0,10.0,51.0'
                                  '&WIDTH=200&transparent=True')
        
        with tmp_image((200, 200), color=(255, 0, 0), format='png') as img:
            img = img.read()
            expected_req = [({'path': '/service_a' + common_params + '&layers=a_four'},
                             {'body': img, 'headers': {'content-type': 'image/png'}}),
                            ({'path': '/service_a' + common_params + '&layers=a_iopts_one'},
                             {'body': img, 'headers': {'content-type': 'image/png'}}),
                            ]
                            
            with mock_httpd(('localhost', 42423), expected_req):
                self.common_map_req.params.layers = 'single,layer_image_opts1'
                self.common_map_req.params.transparent = True
                resp = self.app.get(self.common_map_req)
                resp.content_type = 'image/png'
                data = StringIO(resp.body)
                assert is_png(data)

    def test_combined_same_fwd_req_params(self):
        # merged to one request because all layers share the same time param in
        # fwd_req_params config
        with tmp_image((200, 200), format='png') as img:
            img = img.read()
            expected_req = [({'path': '/service_a?SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326&styles='
                                  '&VERSION=1.1.1&BBOX=9.0,50.0,10.0,51.0'
                                  '&WIDTH=200&transparent=True&TIME=20041012'
                                  '&layers=a_one,a_two,a_three,a_four'},
                             {'body': img, 'headers': {'content-type': 'image/png'}}),
                            ]

            with mock_httpd(('localhost', 42423), expected_req):
                self.common_map_req.params.layers = 'layer_fwdparams1,layer_fwdparams2'
                self.common_map_req.params['time'] = '20041012'
                self.common_map_req.params.transparent = True
                resp = self.app.get(self.common_map_req)
                resp.content_type = 'image/png'
                data = StringIO(resp.body)
                assert is_png(data)

    def test_combined_no_fwd_req_params(self):
        # merged to one request because no vendor param is set
        with tmp_image((200, 200), format='png') as img:
            img = img.read()
            expected_req = [({'path': '/service_a?SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326&styles='
                                  '&VERSION=1.1.1&BBOX=9.0,50.0,10.0,51.0'
                                  '&WIDTH=200&transparent=True'
                                  '&layers=a_one,a_two,a_four'},
                             {'body': img, 'headers': {'content-type': 'image/png'}}),
                            ]

            with mock_httpd(('localhost', 42423), expected_req):
                self.common_map_req.params.layers = 'layer_fwdparams1,single'
                self.common_map_req.params.transparent = True
                resp = self.app.get(self.common_map_req)
                resp.content_type = 'image/png'
                data = StringIO(resp.body)
                assert is_png(data)

    def test_combined_mixed_fwd_req_params(self):
        # not merged to one request because fwd_req_params are different
        common_params = (r'/service_a?SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326&styles='
                                  '&VERSION=1.1.1&BBOX=9.0,50.0,10.0,51.0'
                                  '&WIDTH=200&transparent=True')

        with tmp_image((200, 200), format='png') as img:
            img = img.read()
            expected_req = [({'path': common_params + '&layers=a_one&TIME=20041012'},
                             {'body': img, 'headers': {'content-type': 'image/png'}}),
                             ({'path': common_params + '&layers=a_two&TIME=20041012&VENDOR=foo'},
                             {'body': img, 'headers': {'content-type': 'image/png'}}),
                             ({'path': common_params + '&layers=a_four'},
                             {'body': img, 'headers': {'content-type': 'image/png'}}),
                            ]

            with mock_httpd(('localhost', 42423), expected_req):
                self.common_map_req.params.layers = 'layer_fwdparams1,single'
                self.common_map_req.params['time'] = '20041012'
                self.common_map_req.params['vendor'] = 'foo'
                self.common_map_req.params.transparent = True
                resp = self.app.get(self.common_map_req)
                resp.content_type = 'image/png'
                data = StringIO(resp.body)
                assert is_png(data)


########NEW FILE########
__FILENAME__ = test_coverage
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

from cStringIO import StringIO
from mapproxy.request.wms import WMS111MapRequest
from mapproxy.platform.image import Image
from mapproxy.test.image import is_png, tmp_image
from mapproxy.test.http import mock_httpd
from mapproxy.test.system import module_setup, module_teardown, SystemTest
from nose.tools import eq_

test_config = {}

def setup_module():
    module_setup(test_config, 'coverage.yaml')

def teardown_module():
    module_teardown(test_config)

class TestCoverageWMS(SystemTest):
    config = test_config
    def setup(self):
        SystemTest.setup(self)
        self.common_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS',
             version='1.1.1', bbox='-180,0,0,80', width='200', height='200',
             layers='wms_cache', srs='EPSG:4326', format='image/png',
             styles='', request='GetMap'))

    def test_capababilities(self):
        resp = self.app.get('/service?request=GetCapabilities&service=WMS&version=1.1.1')
        xml = resp.lxml
        # First: combined root, second: wms_cache, third: tms_cache, last: seed_only
        eq_(xml.xpath('//LatLonBoundingBox/@minx'), ['10', '10', '12', '14'])
        eq_(xml.xpath('//LatLonBoundingBox/@miny'), ['10', '15', '10', '13'])
        eq_(xml.xpath('//LatLonBoundingBox/@maxx'), ['35', '30', '35', '24'])
        eq_(xml.xpath('//LatLonBoundingBox/@maxy'), ['31', '31', '30', '23'])

    def test_get_map_outside(self):
        self.common_map_req.params.bbox = -90, 0, 0, 90
        self.common_map_req.params['bgcolor'] = '0xff0005'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        data = StringIO(resp.body)
        assert is_png(data)
        img = Image.open(data)
        eq_(img.mode, 'RGB')
        eq_(img.getcolors(), [(200*200, (255, 0, 5))])

    def test_get_map_outside_transparent(self):
        self.common_map_req.params.bbox = -90, 0, 0, 90
        self.common_map_req.params.transparent = True
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        data = StringIO(resp.body)
        assert is_png(data)
        img = Image.open(data)
        eq_(img.mode, 'RGBA')
        eq_(img.getcolors()[0][0], 200*200)
        eq_(img.getcolors()[0][1][3], 0) # transparent

    def test_get_map_intersection(self):
        self.created_tiles.append('wms_cache_EPSG4326/03/000/000/004/000/000/002.jpeg')
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fjpeg'
                                      '&REQUEST=GetMap&HEIGHT=91&SRS=EPSG%3A4326&styles='
                                      '&VERSION=1.1.1&BBOX=10,15,30,31'
                                      '&WIDTH=114'},
                            {'body': img.read(), 'headers': {'content-type': 'image/jpeg'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                self.common_map_req.params.bbox = 0, 0, 40, 40
                self.common_map_req.params.transparent = True
                resp = self.app.get(self.common_map_req)
                eq_(resp.content_type, 'image/png')
                data = StringIO(resp.body)
                assert is_png(data)
                eq_(Image.open(data).mode, 'RGBA')

class TestCoverageTMS(SystemTest):
    config = test_config

    def test_get_tile_intersections(self):
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fjpeg'
                                      '&REQUEST=GetMap&HEIGHT=25&SRS=EPSG%3A900913&styles='
                                      '&VERSION=1.1.1&BBOX=1113194.90793,1689200.13961,3339584.7238,3632749.14338'
                                      '&WIDTH=28'},
                            {'body': img.read(), 'headers': {'content-type': 'image/jpeg'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get('/tms/1.0.0/wms_cache/0/1/1.jpeg')
                eq_(resp.content_type, 'image/jpeg')
                self.created_tiles.append('wms_cache_EPSG900913/01/000/000/001/000/000/001.jpeg')

    def test_get_tile_intersection_tms(self):
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/tms/1.0.0/foo/1/1/1.jpeg'},
                            {'body': img.read(), 'headers': {'content-type': 'image/jpeg'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get('/tms/1.0.0/tms_cache/0/1/1.jpeg')
                eq_(resp.content_type, 'image/jpeg')
                self.created_tiles.append('tms_cache_EPSG900913/01/000/000/001/000/000/001.jpeg')


########NEW FILE########
__FILENAME__ = test_decorate_img
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from mapproxy.test.system import module_setup, module_teardown, SystemTest
from mapproxy.test.system import make_base_config
from mapproxy.test.image import is_png, is_jpeg
from mapproxy.request.wms import WMS111MapRequest
from mapproxy.request.wmts import WMTS100TileRequest
from cStringIO import StringIO

from mapproxy.platform.image import Image
from mapproxy.image import ImageSource
from nose.tools import eq_

test_config = {}
base_config = make_base_config(test_config)


def setup_module():
    module_setup(test_config, 'layer.yaml', with_cache_data=True)


def teardown_module():
    module_teardown(test_config)


def to_greyscale(image, service, layers, **kw):
    img = image.as_image()
    if (hasattr(image.image_opts, 'transparent') and
            image.image_opts.transparent):
        img = img.convert('LA').convert('RGBA')
    else:
        img = img.convert('L').convert('RGB')
    return ImageSource(img, image.image_opts)


class TestDecorateImg(SystemTest):

    config = test_config

    def setup(self):
        SystemTest.setup(self)
        self.common_tile_req = WMTS100TileRequest(url='/service?', param=dict(service='WMTS', 
             version='1.0.0', tilerow='0', tilecol='0', tilematrix='01', tilematrixset='GLOBAL_MERCATOR',
             layer='wms_cache', format='image/jpeg', style='', request='GetTile'))

    def test_wms(self):
        req = WMS111MapRequest(
            url='/service?',
            param=dict(
                service='WMS',
                version='1.1.1', bbox='-180,0,0,80', width='200', height='200',
                layers='wms_cache', srs='EPSG:4326', format='image/png',
                styles='', request='GetMap'
            )
        )
        resp = self.app.get(
            req,
            extra_environ={'mapproxy.decorate_img': to_greyscale}
        )
        data = StringIO(resp.body)
        assert is_png(data)
        img = Image.open(data)
        eq_(img.mode, 'RGB')

    def test_wms_transparent(self):
        req = WMS111MapRequest(
            url='/service?',
            param=dict(
                service='WMS', version='1.1.1', bbox='-180,0,0,80',
                width='200', height='200', layers='wms_cache_transparent',
                srs='EPSG:4326', format='image/png',
                styles='', request='GetMap', transparent='True'
            )
        )
        resp = self.app.get(
            req, extra_environ={'mapproxy.decorate_img': to_greyscale}
        )
        data = StringIO(resp.body)
        assert is_png(data)
        img = Image.open(data)
        eq_(img.mode, 'RGBA')

    def test_wms_bgcolor(self):
        req = WMS111MapRequest(
            url='/service?',
            param=dict(
                service='WMS', version='1.1.1', bbox='-180,0,0,80',
                width='200', height='200', layers='wms_cache_transparent',
                srs='EPSG:4326', format='image/png',
                styles='', request='GetMap', bgcolor='0xff00a0'
            )
        )
        resp = self.app.get(
            req, extra_environ={'mapproxy.decorate_img': to_greyscale}
        )
        data = StringIO(resp.body)
        assert is_png(data)
        img = Image.open(data)
        eq_(img.mode, 'RGB')
        eq_(sorted(img.getcolors())[-1][1], (94, 94, 94))

    def test_wms_args(self):
        req = WMS111MapRequest(
            url='/service?',
            param=dict(
                service='WMS', version='1.1.1', bbox='-180,0,0,80',
                width='200', height='200', layers='wms_cache,wms_cache_transparent',
                srs='EPSG:4326', format='image/png',
                styles='', request='GetMap', transparent='True'
            )
        )
        def callback(img_src, service, layers, environ, query_extent):
            assert isinstance(img_src, ImageSource)
            eq_('wms.map', service)
            eq_(len(layers), 2)
            assert 'wms_cache_transparent' in layers
            assert 'wms_cache' in layers
            assert isinstance(environ, dict)
            assert len(query_extent) == 2
            assert len(query_extent[1]) == 4
            eq_(query_extent[0], 'EPSG:4326')
            return img_src
        resp = self.app.get(
            req, extra_environ={'mapproxy.decorate_img': callback}
        )

    def test_tms(self):
        resp = self.app.get(
            '/tms/1.0.0/wms_cache/0/0/1.jpeg',
            extra_environ={'mapproxy.decorate_img': to_greyscale}
        )
        eq_(resp.content_type, 'image/jpeg')
        eq_(resp.content_length, len(resp.body))
        data = StringIO(resp.body)
        assert is_jpeg(data)

    def test_tms_args(self):
        def callback(img_src, service, layers, environ, query_extent):
            assert isinstance(img_src, ImageSource)
            eq_('tms', service)
            eq_('wms_cache', layers[0])
            assert isinstance(environ, dict)
            assert len(query_extent) == 2
            assert len(query_extent[1]) == 4
            eq_(query_extent[0], 'EPSG:900913')
            return img_src
        resp = self.app.get(
            '/tms/1.0.0/wms_cache/0/0/1.jpeg',
            extra_environ={'mapproxy.decorate_img': callback}
        )

    def test_wmts(self):
        resp = self.app.get(
            str(self.common_tile_req),
            extra_environ={'mapproxy.decorate_img': to_greyscale}
        )
        eq_(resp.content_type, 'image/jpeg')
        eq_(resp.content_length, len(resp.body))
        data = StringIO(resp.body)
        assert is_jpeg(data)

    def test_wmts_args(self):
        def callback(img_src, service, layers, environ, query_extent):
            assert isinstance(img_src, ImageSource)
            eq_('wmts', service)
            eq_('wms_cache', layers[0])
            assert isinstance(environ, dict)
            assert len(query_extent) == 2
            assert len(query_extent[1]) == 4
            eq_(query_extent[0], 'EPSG:900913')
            return img_src
        resp = self.app.get(
            str(self.common_tile_req),
            extra_environ={'mapproxy.decorate_img': callback}
        )

########NEW FILE########
__FILENAME__ = test_disable_storage
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os

from mapproxy.test.image import is_png, tmp_image
from mapproxy.test.http import mock_httpd
from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config
from nose.tools import eq_

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'disable_storage.yaml', with_cache_data=False)

def teardown_module():
    module_teardown(test_config)

class TestDisableStorage(SystemTest):
    config = test_config
    
    def test_get_tile_without_caching(self):
        with tmp_image((256, 256), format='png') as img:
            expected_req = ({'path': r'/tile.png'},
                            {'body': img.read(), 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get('/tms/1.0.0/tiles/0/0/0.png')
                eq_(resp.content_type, 'image/png')
                is_png(resp.body)

        assert not os.path.exists(test_config['cache_dir'])
        
        with tmp_image((256, 256), format='png') as img:
            expected_req = ({'path': r'/tile.png'},
                            {'body': img.read(), 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get('/tms/1.0.0/tiles/0/0/0.png')
                eq_(resp.content_type, 'image/png')
                is_png(resp.body)
        
########NEW FILE########
__FILENAME__ = test_formats
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division
import os
from cStringIO import StringIO
from mapproxy.request.wms import WMS111MapRequest, WMS111FeatureInfoRequest
from mapproxy.test.image import tmp_image, check_format
from mapproxy.test.http import mock_httpd
from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config
from nose.tools import eq_

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'formats.yaml', with_cache_data=True)

def teardown_module():
    module_teardown(test_config)

class TilesTest(SystemTest):
    config = test_config
    
    def created_tiles_filenames(self):
        base_dir = base_config().cache.base_dir
        for filename, format in self.created_tiles:
            yield os.path.join(base_dir, filename), format
    
    def _test_created_tiles(self):
        for filename, format in self.created_tiles_filenames():
            if not os.path.exists(filename):
                assert False, "didn't found tile " + filename
            else:
                check_format(open(filename, 'rb'), format)
            
    def teardown(self):
        self._test_created_tiles()
        for filename, _format in self.created_tiles_filenames():
            if os.path.exists(filename):
                os.remove(filename)


class TestWMS111(TilesTest):
    def setup(self):
        TilesTest.setup(self)
        self.common_req = WMS111MapRequest(url='/service?', param=dict(service='WMS', 
             version='1.1.1'))
        self.common_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS', 
             version='1.1.1', bbox='0,0,180,80', width='200', height='200',
             layers='wms_cache', srs='EPSG:4326', format='image/png',
             styles='', request='GetMap'))
        self.common_direct_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS', 
             version='1.1.1', bbox='0,0,10,10', width='200', height='200',
             layers='wms_cache', srs='EPSG:4326', format='image/png',
             styles='', request='GetMap'))
        self.common_fi_req = WMS111FeatureInfoRequest(url='/service?',
            param=dict(x='10', y='20', width='200', height='200', layers='wms_cache',
                       format='image/png', query_layers='wms_cache', styles='',
                       bbox='1000,400,2000,1400', srs='EPSG:900913'))
        self.expected_base_path = '/service?SERVICE=WMS&REQUEST=GetMap&HEIGHT=256' \
            '&SRS=EPSG%3A900913&styles=&VERSION=1.1.1&WIDTH=256' \
            '&BBOX=0.0,0.0,20037508.3428,20037508.3428'
        self.expected_direct_base_path = '/service?SERVICE=WMS&REQUEST=GetMap&HEIGHT=200' \
            '&SRS=EPSG%3A4326&styles=&VERSION=1.1.1&WIDTH=200' \
            '&BBOX=0.0,0.0,10.0,10.0'
                
    def test_cache_formats(self):
        yield self.check_get_cached, 'jpeg_cache_tiff_source', 'tiffsource', 'png', 'jpeg', 'tiff'
        yield self.check_get_cached, 'jpeg_cache_tiff_source', 'tiffsource', 'jpeg', 'jpeg', 'tiff'
        yield self.check_get_cached, 'jpeg_cache_tiff_source', 'tiffsource', 'tiff', 'jpeg', 'tiff'
        yield self.check_get_cached, 'jpeg_cache_tiff_source', 'tiffsource', 'gif', 'jpeg', 'tiff'

        yield self.check_get_cached, 'png_cache_all_source', 'allsource', 'png', 'png', 'png'
        yield self.check_get_cached, 'png_cache_all_source', 'allsource', 'jpeg', 'png', 'png'

        yield self.check_get_cached, 'jpeg_cache_png_jpeg_source', 'pngjpegsource', 'jpeg', 'jpeg', 'jpeg'
        yield self.check_get_cached, 'jpeg_cache_png_jpeg_source', 'pngjpegsource', 'png', 'jpeg', 'jpeg'
        
    def test_direct_formats(self):
        yield self.check_get_direct, 'jpeg_cache_tiff_source', 'tiffsource', 'gif', 'tiff'
        yield self.check_get_direct, 'jpeg_cache_tiff_source', 'tiffsource', 'jpeg', 'tiff'
        yield self.check_get_direct, 'jpeg_cache_tiff_source', 'tiffsource', 'png', 'tiff'

        yield self.check_get_direct, 'png_cache_all_source', 'allsource', 'gif', 'gif'
        yield self.check_get_direct, 'png_cache_all_source', 'allsource', 'png', 'png'
        yield self.check_get_direct, 'png_cache_all_source', 'allsource', 'tiff', 'tiff'
        
        yield self.check_get_direct, 'jpeg_cache_png_jpeg_source', 'pngjpegsource', 'jpeg', 'jpeg'
        yield self.check_get_direct, 'jpeg_cache_png_jpeg_source', 'pngjpegsource', 'png', 'png'
        yield self.check_get_direct, 'jpeg_cache_png_jpeg_source', 'pngjpegsource', 'tiff', 'png'
        yield self.check_get_direct, 'jpeg_cache_png_jpeg_source', 'pngjpegsource', 'gif', 'png'


    def check_get_cached(self, layer, source, wms_format, cache_format, req_format):
        self.created_tiles.append((layer+'_EPSG900913/01/000/000/001/000/000/001.'+cache_format, cache_format))
        with tmp_image((256, 256), format=req_format) as img:
            expected_req = ({'path': self.expected_base_path +
                                     '&layers=' + source +
                                     '&format=image%2F' + req_format},
                            {'body': img.read(), 'headers': {'content-type': 'image/'+req_format}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                self.common_map_req.params['layers'] = layer
                self.common_map_req.params['format'] = 'image/'+wms_format
                resp = self.app.get(self.common_map_req)
                eq_(resp.content_type, 'image/'+wms_format)
                check_format(StringIO(resp.body), wms_format)
                

    def check_get_direct(self, layer, source, wms_format, req_format):
        with tmp_image((256, 256), format=req_format) as img:
            expected_req = ({'path': self.expected_direct_base_path +
                                     '&layers=' + source +
                                     '&format=image%2F' + req_format},
                            {'body': img.read(), 'headers': {'content-type': 'image/'+req_format}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                self.common_direct_map_req.params['layers'] = layer
                self.common_direct_map_req.params['format'] = 'image/'+wms_format
                resp = self.app.get(self.common_direct_map_req)
                eq_(resp.content_type, 'image/'+wms_format)    
                check_format(StringIO(resp.body), wms_format)

class TestTMS(TilesTest):
    def setup(self):
        TilesTest.setup(self)
        self.expected_base_path = '/service?SERVICE=WMS&REQUEST=GetMap&HEIGHT=256' \
            '&SRS=EPSG%3A900913&styles=&VERSION=1.1.1&WIDTH=256' \
            '&BBOX=0.0,0.0,20037508.3428,20037508.3428'
        self.expected_direct_base_path = '/service?SERVICE=WMS&REQUEST=GetMap&HEIGHT=200' \
            '&SRS=EPSG%3A4326&styles=&VERSION=1.1.1&WIDTH=200' \
            '&BBOX=0.0,0.0,10.0,10.0'
            
    
    def test_cache_formats(self):
        yield self.check_get_cached, 'jpeg_cache_tiff_source', 'tiffsource', 'jpeg', 'jpeg', 'tiff'

        yield self.check_get_cached, 'png_cache_all_source', 'allsource', 'png', 'png', 'png'

        yield self.check_get_cached, 'jpeg_cache_png_jpeg_source', 'pngjpegsource', 'jpeg', 'jpeg', 'jpeg'
        

    def check_get_cached(self, layer, source, tms_format, cache_format, req_format):
        self.created_tiles.append((layer+'_EPSG900913/01/000/000/001/000/000/001.'+cache_format, cache_format))
        with tmp_image((256, 256), format=req_format) as img:
            expected_req = ({'path': self.expected_base_path +
                                     '&layers=' + source +
                                     '&format=image%2F' + req_format},
                            {'body': img.read(), 'headers': {'content-type': 'image/'+req_format}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get('/tms/1.0.0/%s/0/1/1.%s' % (layer, tms_format))
                eq_(resp.content_type, 'image/'+tms_format)
                # check_format(StringIO(resp.body), tms_format)

########NEW FILE########
__FILENAME__ = test_kml
# This file is part of the MapProxy project.
# Copyright (C) 2010-2012 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os
import hashlib
from cStringIO import StringIO
from mapproxy.srs import bbox_equals
from mapproxy.util.times import format_httpdate
from mapproxy.test.image import is_jpeg, tmp_image
from mapproxy.test.http import mock_httpd
from mapproxy.test.helper import validate_with_xsd
from nose.tools import eq_

ns = {'kml': 'http://www.opengis.net/kml/2.2'}

from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'kml_layer.yaml', with_cache_data=True)

def teardown_module():
    module_teardown(test_config)

class TestKML(SystemTest):
    config = test_config

    def test_get_out_of_bounds_tile(self):
        for coord in [(0, 0, -1), (-1, 0, 0), (0, -1, 0), (4, 2, 1), (1, 3, 0)]:
            yield self.check_out_of_bounds, coord

    def check_out_of_bounds(self, coord):
        x, y, z = coord
        url = '/kml/wms_cache/%d/%d/%d.kml' % (z, x, y)
        resp = self.app.get(url , status=404)
        assert 'outside the bounding box' in resp

    def test_invalid_layer(self):
        resp = self.app.get('/kml/inVAlid/0/0/0.png', status=404)
        eq_(resp.content_type, 'text/plain')
        assert 'unknown layer: inVAlid' in resp

    def test_invalid_format(self):
        resp = self.app.get('/kml/wms_cache/0/0/1.png', status=404)
        eq_(resp.content_type, 'text/plain')
        assert 'invalid format' in resp

    def test_get_tile_tile_source_error(self):
        resp = self.app.get('/kml/wms_cache/0/0/0.jpeg', status=500)
        eq_(resp.content_type, 'text/plain')
        assert 'No response from URL' in resp

    def _check_tile_resp(self, resp):
        eq_(resp.content_type, 'image/jpeg')
        eq_(resp.content_length, len(resp.body))
        data = StringIO(resp.body)
        assert is_jpeg(data)

    def _update_timestamp(self):
        timestamp = 1234567890.0
        size = 10214
        base_dir = base_config().cache.base_dir
        os.utime(os.path.join(base_dir,
                              'wms_cache_EPSG900913/01/000/000/000/000/000/001.jpeg'),
                 (timestamp, timestamp))
        max_age = base_config().tiles.expires_hours * 60 * 60
        etag = hashlib.md5(str(timestamp) + str(size)).hexdigest()
        return etag, max_age

    def _check_cache_control_headers(self, resp, etag, max_age, timestamp=1234567890.0):
        eq_(resp.headers['ETag'], etag)
        if timestamp is None:
            assert 'Last-modified' not in resp.headers
        else:
            eq_(resp.headers['Last-modified'], format_httpdate(timestamp))
        eq_(resp.headers['Cache-control'], 'max-age=%d public' % max_age)

    def test_get_cached_tile(self):
        etag, max_age = self._update_timestamp()
        resp = self.app.get('/kml/wms_cache/1/0/1.jpeg')
        self._check_cache_control_headers(resp, etag, max_age)
        self._check_tile_resp(resp)

    def test_if_none_match(self):
        etag, max_age = self._update_timestamp()
        resp = self.app.get('/kml/wms_cache/1/0/1.jpeg',
                            headers={'If-None-Match': etag})
        eq_(resp.status, '304 Not Modified')
        self._check_cache_control_headers(resp, etag, max_age)

        resp = self.app.get('/kml/wms_cache/1/0/1.jpeg',
                            headers={'If-None-Match': etag + 'foo'})
        self._check_cache_control_headers(resp, etag, max_age)
        eq_(resp.status, '200 OK')
        self._check_tile_resp(resp)

    def test_get_kml(self):
        resp = self.app.get('/kml/wms_cache/0/0/0.kml')
        xml = resp.lxml
        assert validate_with_xsd(xml, 'kml/2.2.0/ogckml22.xsd')
        assert bbox_equals(
            self._bbox(xml.xpath('/kml:kml/kml:Document', namespaces=ns)[0]),
            (-180, -90, 180, 90)
        )
        assert bbox_equals(
            self._bbox(xml.xpath('/kml:kml/kml:Document/kml:GroundOverlay', namespaces=ns)[0]),
            (-180, 0, 0, 90)
        )
        eq_(xml.xpath('/kml:kml/kml:Document/kml:GroundOverlay/kml:Icon/kml:href/text()',
                      namespaces=ns),
            ['http://localhost/kml/wms_cache/EPSG900913/1/0/1.jpeg',
             'http://localhost/kml/wms_cache/EPSG900913/1/1/1.jpeg',
             'http://localhost/kml/wms_cache/EPSG900913/1/0/0.jpeg',
             'http://localhost/kml/wms_cache/EPSG900913/1/1/0.jpeg']
        )
        eq_(xml.xpath('/kml:kml/kml:Document/kml:NetworkLink/kml:Link/kml:href/text()',
                      namespaces=ns),
              ['http://localhost/kml/wms_cache/EPSG900913/1/0/1.kml',
               'http://localhost/kml/wms_cache/EPSG900913/1/1/1.kml',
               'http://localhost/kml/wms_cache/EPSG900913/1/0/0.kml',
               'http://localhost/kml/wms_cache/EPSG900913/1/1/0.kml']
        )

        etag = hashlib.md5(resp.body).hexdigest()
        max_age = base_config().tiles.expires_hours * 60 * 60
        self._check_cache_control_headers(resp, etag, max_age, None)

        resp = self.app.get('/kml/wms_cache/0/0/0.kml',
                            headers={'If-None-Match': etag})
        eq_(resp.status, '304 Not Modified')

    def test_get_kml_init(self):
        resp = self.app.get('/kml/wms_cache')
        xml = resp.lxml
        assert validate_with_xsd(xml, 'kml/2.2.0/ogckml22.xsd')
        eq_(xml.xpath('/kml:kml/kml:Document/kml:GroundOverlay/kml:Icon/kml:href/text()',
                      namespaces=ns),
            ['http://localhost/kml/wms_cache/EPSG900913/1/0/1.jpeg',
             'http://localhost/kml/wms_cache/EPSG900913/1/1/1.jpeg',
             'http://localhost/kml/wms_cache/EPSG900913/1/0/0.jpeg',
             'http://localhost/kml/wms_cache/EPSG900913/1/1/0.jpeg']
        )
        eq_(xml.xpath('/kml:kml/kml:Document/kml:NetworkLink/kml:Link/kml:href/text()',
                      namespaces=ns),
              ['http://localhost/kml/wms_cache/EPSG900913/1/0/1.kml',
               'http://localhost/kml/wms_cache/EPSG900913/1/1/1.kml',
               'http://localhost/kml/wms_cache/EPSG900913/1/0/0.kml',
               'http://localhost/kml/wms_cache/EPSG900913/1/1/0.kml']
        )

    def test_get_kml_nw(self):
        resp = self.app.get('/kml/wms_cache_nw/1/0/0.kml')
        xml = resp.lxml

        assert validate_with_xsd(xml, 'kml/2.2.0/ogckml22.xsd')

        assert bbox_equals(
            self._bbox(xml.xpath('/kml:kml/kml:Document', namespaces=ns)[0]),
            (-180, -90, 0, 0)
        )
        assert bbox_equals(
            self._bbox(xml.xpath('/kml:kml/kml:Document/kml:GroundOverlay', namespaces=ns)[0]),
            (-180, -66.51326, -90, 0)
        )

        eq_(xml.xpath('/kml:kml/kml:Document/kml:GroundOverlay/kml:Icon/kml:href/text()',
                      namespaces=ns),
            ['http://localhost/kml/wms_cache_nw/EPSG900913/2/0/1.jpeg',
             'http://localhost/kml/wms_cache_nw/EPSG900913/2/1/1.jpeg',
             'http://localhost/kml/wms_cache_nw/EPSG900913/2/0/0.jpeg',
             'http://localhost/kml/wms_cache_nw/EPSG900913/2/1/0.jpeg']
        )
        eq_(xml.xpath('/kml:kml/kml:Document/kml:NetworkLink/kml:Link/kml:href/text()',
                      namespaces=ns),
              ['http://localhost/kml/wms_cache_nw/EPSG900913/2/0/1.kml',
               'http://localhost/kml/wms_cache_nw/EPSG900913/2/1/1.kml',
               'http://localhost/kml/wms_cache_nw/EPSG900913/2/0/0.kml',
               'http://localhost/kml/wms_cache_nw/EPSG900913/2/1/0.kml']
        )

    def test_get_kml2(self):
        resp = self.app.get('/kml/wms_cache/1/0/1.kml')
        xml = resp.lxml
        assert validate_with_xsd(xml, 'kml/2.2.0/ogckml22.xsd')

    def test_get_kml_multi_layer(self):
        resp = self.app.get('/kml/wms_cache_multi/1/0/0.kml')
        xml = resp.lxml
        assert validate_with_xsd(xml, 'kml/2.2.0/ogckml22.xsd')
        eq_(xml.xpath('/kml:kml/kml:Document/kml:GroundOverlay/kml:Icon/kml:href/text()',
                      namespaces=ns),
            ['http://localhost/kml/wms_cache_multi/EPSG4326/2/0/1.jpeg',
             'http://localhost/kml/wms_cache_multi/EPSG4326/2/1/1.jpeg',
             'http://localhost/kml/wms_cache_multi/EPSG4326/2/0/0.jpeg',
             'http://localhost/kml/wms_cache_multi/EPSG4326/2/1/0.jpeg']
        )
        eq_(xml.xpath('/kml:kml/kml:Document/kml:NetworkLink/kml:Link/kml:href/text()',
                      namespaces=ns),
          ['http://localhost/kml/wms_cache_multi/EPSG4326/2/0/1.kml',
           'http://localhost/kml/wms_cache_multi/EPSG4326/2/1/1.kml',
           'http://localhost/kml/wms_cache_multi/EPSG4326/2/0/0.kml',
           'http://localhost/kml/wms_cache_multi/EPSG4326/2/1/0.kml']
        )

    def test_get_tile(self):
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fjpeg'
                                      '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A900913&styles='
                                      '&VERSION=1.1.1&BBOX=-20037508.3428,-20037508.3428,0.0,0.0'
                                      '&WIDTH=256'},
                            {'body': img.read(), 'headers': {'content-type': 'image/jpeg'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get('/kml/wms_cache/1/0/0.jpeg')
                eq_(resp.content_type, 'image/jpeg')
                self.created_tiles.append('wms_cache_EPSG900913/01/000/000/000/000/000/000.jpeg')

    def _bbox(self, elem):
        elems = elem.xpath('kml:Region/kml:LatLonAltBox', namespaces=ns)[0]
        n, s, e, w = [float(elem.text) for elem in elems.getchildren()]
        return w, s, e, n


########NEW FILE########
__FILENAME__ = test_layergroups
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

from mapproxy.test.system import module_setup, module_teardown, SystemTest
from mapproxy.test.system.test_wms import is_111_capa, is_110_capa, is_100_capa, is_130_capa, ns130

from nose.tools import eq_

test_config = {}
test_config_with_root = {}

def setup_module():
    module_setup(test_config, 'layergroups.yaml')
    module_setup(test_config_with_root, 'layergroups_root.yaml')

def teardown_module():
    module_teardown(test_config)
    module_teardown(test_config_with_root)

TESTSERVER_ADDRESS = 'localhost', 42423

class TestWMSWithRoot(SystemTest):
    config = test_config_with_root
    def setup(self):
        SystemTest.setup(self)

    def _check_layernames(self, xml):
        eq_(xml.xpath('//Capability/Layer/Title/text()'),
            ['Root Layer'])
        eq_(xml.xpath('//Capability/Layer/Name/text()'),
            ['root'])
        eq_(xml.xpath('//Capability/Layer/Layer/Name/text()'),
            ['layer1', 'layer2'])
        eq_(xml.xpath('//Capability/Layer/Layer[1]/Layer/Name/text()'),
            ['layer1a', 'layer1b'])
        
    def _check_layernames_with_namespace(self, xml, namespaces=None):
        eq_(xml.xpath('//wms:Capability/wms:Layer/wms:Title/text()', namespaces=namespaces),
            ['Root Layer'])
        eq_(xml.xpath('//wms:Capability/wms:Layer/wms:Name/text()', namespaces=namespaces),
            ['root'])
        eq_(xml.xpath('//wms:Capability/wms:Layer/wms:Layer/wms:Name/text()', namespaces=namespaces),
            ['layer1', 'layer2'])
        eq_(xml.xpath('//wms:Capability/wms:Layer/wms:Layer[1]/wms:Layer/wms:Name/text()', namespaces=namespaces),
            ['layer1a', 'layer1b'])


    def test_100_capa(self):
        resp = self.app.get("/service?request=GetCapabilities&service=WMS&wmtver=1.0.0")
        xml = resp.lxml
        assert is_100_capa(xml)
        self._check_layernames(xml)
        
    def test_110_capa(self):
        resp = self.app.get("/service?request=GetCapabilities&service=WMS&version=1.1.0")
        xml = resp.lxml
        assert is_110_capa(xml)
        self._check_layernames(xml)

    def test_111_capa(self):
        resp = self.app.get("/service?request=GetCapabilities&service=WMS&version=1.1.1")
        xml = resp.lxml
        assert is_111_capa(xml)
        self._check_layernames(xml)

    def test_130_capa(self):
        resp = self.app.get("/service?request=GetCapabilities&service=WMS&version=1.3.0")
        xml = resp.lxml
        assert is_130_capa(xml)
        self._check_layernames_with_namespace(xml, ns130)


class TestWMSWithoutRoot(SystemTest):
    config = test_config
    def setup(self):
        SystemTest.setup(self)

    def _check_layernames(self, xml):
        eq_(xml.xpath('//Capability/Layer/Title/text()'),
            ['My WMS'])
        eq_(xml.xpath('//Capability/Layer/Name/text()'),
            [])
        eq_(xml.xpath('//Capability/Layer/Layer/Name/text()'),
            ['layer1', 'layer2'])
        eq_(xml.xpath('//Capability/Layer/Layer[1]/Layer/Name/text()'),
            ['layer1a', 'layer1b'])
        eq_(xml.xpath('//Capability/Layer/Layer[2]/Layer/Name/text()'),
            ['layer2a', 'layer2b'])
        eq_(xml.xpath('//Capability/Layer/Layer[2]/Layer/Layer[1]/Name/text()'),
            ['layer2b1'])
        
    def _check_layernames_with_namespace(self, xml, namespaces=None):
        eq_(xml.xpath('//wms:Capability/wms:Layer/wms:Title/text()', namespaces=namespaces),
            ['My WMS'])
        eq_(xml.xpath('//wms:Capability/wms:Layer/wms:Name/text()', namespaces=namespaces),
            [])
        eq_(xml.xpath('//wms:Capability/wms:Layer/wms:Layer/wms:Name/text()', namespaces=namespaces),
            ['layer1', 'layer2'])
        eq_(xml.xpath('//wms:Capability/wms:Layer/wms:Layer[1]/wms:Layer/wms:Name/text()', namespaces=namespaces),
            ['layer1a', 'layer1b'])
        eq_(xml.xpath('//wms:Capability/wms:Layer/wms:Layer[2]/wms:Layer/wms:Name/text()', namespaces=namespaces),
            ['layer2a', 'layer2b'])
        eq_(xml.xpath('//wms:Capability/wms:Layer/wms:Layer[2]/wms:Layer/wms:Layer[1]/wms:Name/text()', namespaces=namespaces),
            ['layer2b1'])


    def test_100_capa(self):
        resp = self.app.get("/service?request=GetCapabilities&service=WMS&wmtver=1.0.0")
        xml = resp.lxml
        assert is_100_capa(xml)
        self._check_layernames(xml)
        
    def test_110_capa(self):
        resp = self.app.get("/service?request=GetCapabilities&service=WMS&version=1.1.0")
        xml = resp.lxml
        assert is_110_capa(xml)
        self._check_layernames(xml)

    def test_111_capa(self):
        resp = self.app.get("/service?request=GetCapabilities&service=WMS&version=1.1.1")
        xml = resp.lxml
        assert is_111_capa(xml)
        self._check_layernames(xml)

    def test_130_capa(self):
        resp = self.app.get("/service?request=GetCapabilities&service=WMS&version=1.3.0")
        xml = resp.lxml
        assert is_130_capa(xml)
        self._check_layernames_with_namespace(xml, ns130)
########NEW FILE########
__FILENAME__ = test_legendgraphic
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division
from StringIO import StringIO

from mapproxy.platform.image import Image

from mapproxy.request.wms import (
    WMS111MapRequest, WMS111CapabilitiesRequest, WMS130CapabilitiesRequest,
    WMS111LegendGraphicRequest, WMS130LegendGraphicRequest
)

from mapproxy.test.system import module_setup, module_teardown, make_base_config, SystemTest
from mapproxy.test.image import is_png, tmp_image
from mapproxy.test.http import mock_httpd
from mapproxy.test.helper import validate_with_dtd, validate_with_xsd
from mapproxy.test.system.test_wms import is_111_capa, eq_xpath_wms130, ns130
from nose.tools import eq_

test_config = {}

def setup_module():
    module_setup(test_config, 'legendgraphic.yaml', with_cache_data=False)

def teardown_module():
    module_teardown(test_config)

base_config = make_base_config(test_config)


def is_130_capa(xml):
    return validate_with_xsd(xml, xsd_name='sld/1.1.0/sld_capabilities.xsd')


class TestWMS(SystemTest):
    config = test_config
    def setup(self):
        SystemTest.setup(self)
        self.common_req = WMS111MapRequest(url='/service?', param=dict(service='WMS', 
             version='1.1.1'))
        self.common_lg_req_111 = WMS111LegendGraphicRequest(url='/service?',
            param=dict(format='image/png', layer='wms_legend', sld_version='1.1.0'))
        self.common_lg_req_130 = WMS130LegendGraphicRequest(url='/service?',
            param=dict(format='image/png', layer='wms_legend', sld_version='1.1.0'))
    
    #test_00, test_01, test_02 need to run first in order to run the other tests properly
    def test_00_get_legendgraphic_multiple_sources_111(self):
        self.common_lg_req_111.params['layer'] = 'wms_mult_sources'
        with tmp_image((256, 256), format='png') as img:
            img_data = img.read()
            expected_req1 = ({'path': r'/service?LAYER=foo&SERVICE=WMS&FORMAT=image%2Fpng'
                                      '&REQUEST=GetLegendGraphic&'
                                      '&VERSION=1.1.1&SLD_VERSION=1.1.0'},
                             {'body': img_data, 'headers': {'content-type': 'image/png'}})
            expected_req2 = ({'path': r'/service?LAYER=bar&SERVICE=WMS&FORMAT=image%2Fpng'
                                      '&REQUEST=GetLegendGraphic&'
                                      '&VERSION=1.1.1&SLD_VERSION=1.1.0'},
                             {'body': img_data, 'headers': {'content-type': 'image/png'}})
            expected_req3 = ({'path': r'/service?LAYER=spam&SERVICE=WMS&FORMAT=image%2Fpng'
                                      '&REQUEST=GetLegendGraphic&'
                                      '&VERSION=1.1.1&SLD_VERSION=1.1.0'},
                            {'body': img_data, 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req1, expected_req2, expected_req3]):
                resp = self.app.get(self.common_lg_req_111)
                eq_(resp.content_type, 'image/png')
                data = StringIO(resp.body)
                assert is_png(data)
                assert Image.open(data).size == (256,768)
    
    def test_01_get_legendgraphic_source_static_url(self):
        self.common_lg_req_111.params['layer'] = 'wms_source_static_url'
        with tmp_image((256, 256), format='png') as img:
            img_data = img.read()
            expected_req1 = ({'path': r'/staticlegend_source.png'},
                             {'body': img_data, 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req1]):
                resp = self.app.get(self.common_lg_req_111)
                eq_(resp.content_type, 'image/png')
                data = StringIO(resp.body)
                assert is_png(data)
                assert Image.open(data).size == (256,256)
    
    def test_02_get_legendgraphic_layer_static_url(self):
        self.common_lg_req_111.params['layer'] = 'wms_layer_static_url'
        with tmp_image((256, 256), format='png') as img:
            img_data = img.read()
            expected_req1 = ({'path': r'/staticlegend_layer.png'},
                             {'body': img_data, 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req1]):
                resp = self.app.get(self.common_lg_req_111)
                eq_(resp.content_type, 'image/png')
                data = StringIO(resp.body)
                assert is_png(data)
                assert Image.open(data).size == (256,256)
    
    def test_capabilities_111(self):
        req = WMS111CapabilitiesRequest(url='/service?').copy_with_request_params(self.common_req)
        resp = self.app.get(req)
        xml = resp.lxml
        eq_(xml.xpath('//Request/GetLegendGraphic')[0].tag, 'GetLegendGraphic')
        legend_sizes = (xml.xpath('//Layer/Style/LegendURL/@width'),
                        xml.xpath('//Layer/Style/LegendURL/@height'))
        assert legend_sizes == (['256', '256', '256', '256'],['512', '768', '256', '256'])
        layer_urls = xml.xpath('//Layer/Style/LegendURL/OnlineResource/@xlink:href',
                         namespaces=ns130)
        for layer_url in layer_urls:
            assert layer_url.startswith('http://')
            assert 'GetLegendGraphic' in layer_url
        assert is_111_capa(xml)
    
    def test_capabilities_130(self):
        req = WMS130CapabilitiesRequest(url='/service?').copy_with_request_params(self.common_req)
        resp = self.app.get(req)
        xml = resp.lxml
        eq_(xml.xpath('//wms:Request/sld:GetLegendGraphic', namespaces=ns130)[0].tag,
                      '{%s}GetLegendGraphic'%(ns130['sld']))        
        layer_urls = xml.xpath('//Layer/Style/LegendURL/OnlineResource/@xlink:href',
                         namespaces=ns130)
        for layer_url in layer_urls:
            assert layer_url.startswith('http://')
            assert 'GetLegendGraphic' in layer_url
        assert is_130_capa(xml)
    
    def test_get_legendgraphic_111(self):
        self.common_lg_req_111.params['scale'] = '5.0'
        with tmp_image((256, 256), format='png') as img:
            img_data = img.read()
            expected_req1 = ({'path': r'/service?LAYER=foo&SERVICE=WMS&FORMAT=image%2Fpng'
                                      '&REQUEST=GetLegendGraphic&SCALE=5.0&'
                                      '&VERSION=1.1.1&SLD_VERSION=1.1.0'},
                             {'body': img_data, 'headers': {'content-type': 'image/png'}})
            expected_req2 = ({'path': r'/service?LAYER=bar&SERVICE=WMS&FORMAT=image%2Fpng'
                                      '&REQUEST=GetLegendGraphic&SCALE=5.0&'
                                      '&VERSION=1.1.1&SLD_VERSION=1.1.0'},
                             {'body': img_data, 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req1, expected_req2]):
                resp = self.app.get(self.common_lg_req_111)
                eq_(resp.content_type, 'image/png')
                data = StringIO(resp.body)
                assert is_png(data)
                assert Image.open(data).size == (256,512)
    
    def test_get_legendgraphic_no_legend_111(self):
        self.common_lg_req_111.params['layer'] = 'wms_no_legend'
        resp = self.app.get(self.common_lg_req_111)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        xml = resp.lxml
        assert 'wms_no_legend has no legend graphic' in xml.xpath('//ServiceException/text()')[0]
        assert validate_with_dtd(xml, 'wms/1.1.1/exception_1_1_1.dtd')
    
    def test_get_legendgraphic_missing_params_111(self):
        req = str(self.common_lg_req_111).replace('sld_version', 'invalid').replace('format', 'invalid')
        resp = self.app.get(req)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        xml = resp.lxml
        assert 'missing parameters' in xml.xpath('//ServiceException/text()')[0]
        assert validate_with_dtd(xml, 'wms/1.1.1/exception_1_1_1.dtd')
    
    def test_get_legendgraphic_invalid_sld_version_111(self):
        req = str(self.common_lg_req_111).replace('sld_version=1.1.0', 'sld_version=1.0.0')
        resp = self.app.get(req)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        xml = resp.lxml
        assert 'invalid sld_version' in xml.xpath('//ServiceException/text()')[0]
        assert validate_with_dtd(xml, 'wms/1.1.1/exception_1_1_1.dtd')
            
    def test_get_legendgraphic_no_legend_130(self):
        self.common_lg_req_130.params['layer'] = 'wms_no_legend'
        resp = self.app.get(self.common_lg_req_130)
        eq_(resp.content_type, 'text/xml')
        xml = resp.lxml
        eq_xpath_wms130(xml, '/ogc:ServiceExceptionReport/@version', '1.3.0')
        eq_xpath_wms130(xml, '//ogc:ServiceException/text()', 'layer wms_no_legend has no legend graphic')
        assert validate_with_xsd(xml, xsd_name='wms/1.3.0/exceptions_1_3_0.xsd')
    
    def test_get_legendgraphic_missing_params_130(self):
        req = str(self.common_lg_req_130).replace('format', 'invalid')
        resp = self.app.get(req)
        eq_(resp.content_type, 'text/xml')
        xml = resp.lxml
        eq_xpath_wms130(xml, '/ogc:ServiceExceptionReport/@version', '1.3.0')
        eq_xpath_wms130(xml, '//ogc:ServiceException/text()', "missing parameters ['format']")
        assert validate_with_xsd(xml, xsd_name='wms/1.3.0/exceptions_1_3_0.xsd')
    
    def test_get_legendgraphic_invalid_sld_version_130(self):
        req = str(self.common_lg_req_130).replace('sld_version=1.1.0', 'sld_version=1.0.0')
        resp = self.app.get(req)
        eq_(resp.content_type, 'text/xml')
        xml = resp.lxml
        eq_xpath_wms130(xml, '/ogc:ServiceExceptionReport/@version', '1.3.0')
        eq_xpath_wms130(xml, '//ogc:ServiceException/text()', 'invalid sld_version 1.0.0')
        assert validate_with_xsd(xml, xsd_name='wms/1.3.0/exceptions_1_3_0.xsd')
    

########NEW FILE########
__FILENAME__ = test_mapnik
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division
import os

from mapproxy.test.system import module_setup, module_teardown, SystemTest

from mapproxy.platform.image import Image
from cStringIO import StringIO

from nose.tools import eq_

test_config = {}


mapnik_xml = """
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE Map>
<Map background-color="#ff0000" bgcolor="#ff0000" srs="+proj=latlong +datum=WGS84">
</Map>
""".strip()

mapnik_transp_xml = """
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE Map>
<Map background-color="transparent" srs="+proj=latlong +datum=WGS84">
</Map>
""".strip()

def setup_module():

    try:
        import mapnik
        mapnik
    except ImportError:
        from nose.plugins.skip import SkipTest
        raise SkipTest('requires mapnik')

    module_setup(test_config, 'mapnik_source.yaml')
    with open(os.path.join(test_config['base_dir'], 'mapnik.xml'), 'w') as f:
        f.write(mapnik_xml)
    with open(os.path.join(test_config['base_dir'], 'mapnik-transparent.xml'), 'w') as f:
        f.write(mapnik_transp_xml)


def teardown_module():
    module_teardown(test_config)

class TestMapnikSource(SystemTest):
    config = test_config

    def test_get_map(self):
        req = (r'/service?LAYERs=mapnik&SERVICE=WMS&FORMAT=image%2Fpng'
                '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326'
                '&VERSION=1.1.1&BBOX=-90,-90,0,0&styles='
                '&WIDTH=200&')

        resp = self.app.get(req)
        data = StringIO(resp.body)
        img = Image.open(data)
        colors = img.getcolors(1)
        # map bg color
        eq_(colors[0], (40000, (255, 0, 0, 255)))

    def test_get_map_outside_coverage(self):
        req = (r'/service?LAYERs=mapnik&SERVICE=WMS&FORMAT=image%2Fpng'
                '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326'
                '&VERSION=1.1.1&BBOX=-175,-85,-172,-82&styles='
                '&WIDTH=200&&BGCOLOR=0x00ff00')

        resp = self.app.get(req)
        data = StringIO(resp.body)
        img = Image.open(data)
        colors = img.getcolors(1)
        # wms request bg color
        eq_(colors[0], (40000, (0, 255, 0)))

    def test_get_map_unknown_file(self):
        req = (r'/service?LAYERs=mapnik_unknown&SERVICE=WMS&FORMAT=image%2Fpng'
                '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326'
                '&VERSION=1.1.1&BBOX=-90,-90,0,0&styles='
                '&WIDTH=200&&BGCOLOR=0x00ff00')

        resp = self.app.get(req)
        assert 'unknown.xml' in resp.body, resp.body

    def test_get_map_transparent(self):
        req = (r'/service?LAYERs=mapnik_transparent&SERVICE=WMS&FORMAT=image%2Fpng'
                '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326'
                '&VERSION=1.1.1&BBOX=-90,-90,0,0&styles='
                '&WIDTH=200&transparent=True')

        resp = self.app.get(req)
        data = StringIO(resp.body)
        img = Image.open(data)
        colors = img.getcolors(1)
        eq_(colors[0], (40000, (0, 0, 0, 0)))


########NEW FILE########
__FILENAME__ = test_mapserver
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

import os
import stat
import platform
import shutil

from cStringIO import StringIO

from mapproxy.request.wms import WMS111MapRequest
from mapproxy.platform.image import Image
from mapproxy.test.image import is_png
from mapproxy.test.system import prepare_env, create_app, module_teardown, SystemTest
from nose.tools import eq_
from nose.plugins.skip import SkipTest

test_config = {}

def setup_module():
    if platform.system() == 'Windows':
        raise SkipTest('CGI test only works on Unix (for now)')
        
    prepare_env(test_config, 'mapserver.yaml')
    
    shutil.copy(os.path.join(test_config['fixture_dir'], 'cgi.py'),
        test_config['base_dir'])
    
    os.chmod(os.path.join(test_config['base_dir'], 'cgi.py'),
        stat.S_IXUSR | stat.S_IRUSR | stat.S_IWUSR)
    
    os.mkdir(os.path.join(test_config['base_dir'], 'tmp'))
    
    create_app(test_config)

def teardown_module():
    module_teardown(test_config)

class TestMapServerCGI(SystemTest):
    config = test_config
    def setup(self):
        SystemTest.setup(self)
        self.common_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS', 
             version='1.1.1', bbox='-180,0,0,80', width='200', height='200',
             layers='ms', srs='EPSG:4326', format='image/png',
             styles='', request='GetMap'))
    
    def test_get_map(self):
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        data = StringIO(resp.body)
        assert is_png(data)
        img = Image.open(data)
        img = img.convert('RGB')
        eq_(img.getcolors(), [(200*200, (255, 0, 0))])

########NEW FILE########
__FILENAME__ = test_mixed_mode_format
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division
import os
from cStringIO import StringIO
from mapproxy.platform.image import (
    Image,
    ImageDraw,
    ImageColor,
)
from mapproxy.request.wms import WMS111MapRequest
from mapproxy.request.wmts import WMTS100TileRequest
from mapproxy.test.image import check_format, is_transparent
from mapproxy.test.http import mock_httpd
from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config
from nose.tools import eq_
from contextlib import contextmanager

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'mixed_mode.yaml', with_cache_data=True)

def teardown_module():
    module_teardown(test_config)

class TestWMS(SystemTest):
    config = test_config

    def setup(self):
        SystemTest.setup(self)        
        self.common_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS', 
             version='1.1.1', bbox='0,0,180,80', width='200', height='200',
             layers='mixed_mode', srs='EPSG:4326', format='image/png',
             styles='', request='GetMap', transparent='true'))
        self.expected_base_path = '/service?SERVICE=WMS&REQUEST=GetMap&HEIGHT=256' \
            '&SRS=EPSG%3A900913&styles=&VERSION=1.1.1&WIDTH=512' \
            '&BBOX=-20037508.3428,0.0,20037508.3428,20037508.3428'
                
    def test_mixed_mode(self):
        req_format = 'png'
        transparent = 'True'
        with create_mixed_mode_img((512, 256)) as img:
            expected_req = ({'path': self.expected_base_path +
                                     '&layers=mixedsource' +
                                     '&format=image%2F' + req_format +
                                     '&transparent=' + transparent},
                            {'body': img.read(), 'headers': {'content-type': 'image/'+req_format}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                self.common_map_req.params['format'] = 'image/'+req_format
                resp = self.app.get(self.common_map_req)
                self.created_tiles.append('mixed_cache_EPSG900913/01/000/000/000/000/000/001.mixed')
                self.created_tiles.append('mixed_cache_EPSG900913/01/000/000/001/000/000/001.mixed')

                eq_(resp.content_type, 'image/'+req_format)
                check_format(StringIO(resp.body), req_format)
                # GetMap Request is fully within the opaque tile
                assert not is_transparent(resp.body)

                # check cache formats
                cache_dir = base_config().cache.base_dir
                check_format(open(os.path.join(cache_dir, self.created_tiles[0]), 'rb'), 'png')
                check_format(open(os.path.join(cache_dir, self.created_tiles[1]), 'rb'), 'jpeg')

class TestTMS(SystemTest):
    config = test_config

    def setup(self):
        SystemTest.setup(self)        
        self.expected_base_path = '/service?SERVICE=WMS&REQUEST=GetMap&HEIGHT=256' \
            '&SRS=EPSG%3A900913&styles=&VERSION=1.1.1&WIDTH=512' \
            '&BBOX=-20037508.3428,-20037508.3428,20037508.3428,0.0'

    def test_mixed_mode(self):
        with create_mixed_mode_img((512, 256)) as img:
            expected_req = ({'path': self.expected_base_path +
                                     '&layers=mixedsource' +
                                     '&format=image%2Fpng' +
                                     '&transparent=True'},
                            {'body': img.read(), 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get('/tms/1.0.0/mixed_mode/0/0/0.png')
                eq_(resp.content_type, 'image/png')
                assert is_transparent(resp.body)

                resp = self.app.get('/tms/1.0.0/mixed_mode/0/1/0.png')
                eq_(resp.content_type, 'image/jpeg')
                self.created_tiles.append('mixed_cache_EPSG900913/01/000/000/000/000/000/000.mixed')
                self.created_tiles.append('mixed_cache_EPSG900913/01/000/000/001/000/000/000.mixed')                   
class TestWMTS(SystemTest):
    config = test_config

    def setup(self):
        SystemTest.setup(self)
        self.common_tile_req = WMTS100TileRequest(url='/service?', param=dict(service='WMTS', 
             version='1.0.0', tilerow='0', tilecol='0', tilematrix='01', tilematrixset='GLOBAL_MERCATOR',
             layer='mixed_mode', format='image/png', style='', request='GetTile', transparent='True'))
        self.expected_base_path = '/service?SERVICE=WMS&REQUEST=GetMap&HEIGHT=256' \
            '&SRS=EPSG%3A900913&styles=&VERSION=1.1.1&WIDTH=512' \
            '&BBOX=-20037508.3428,0.0,20037508.3428,20037508.3428'

    def test_mixed_mode(self):
        with create_mixed_mode_img((512, 256)) as img:
            expected_req = ({'path': self.expected_base_path +
                                     '&layers=mixedsource' +
                                     '&format=image%2Fpng' +
                                     '&transparent=True'},
                            {'body': img.read(), 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get(self.common_tile_req)
                eq_(resp.content_type, 'image/png')
                assert is_transparent(resp.body)
                self.created_tiles.append('mixed_cache_EPSG900913/01/000/000/000/000/000/001.mixed')

                self.common_tile_req.params['tilecol'] = '1'
                resp = self.app.get(self.common_tile_req)
                eq_(resp.content_type, 'image/jpeg')
                self.created_tiles.append('mixed_cache_EPSG900913/01/000/000/001/000/000/001.mixed')

@contextmanager
def create_mixed_mode_img(size, format='png'):
    img = Image.new("RGBA", size)

    # draw a black rectangle into the image, rect_width = 3/4 img_width
    # thus 1/4 of the image is transparent and with square tiles, one of two
    # tiles (img size = 512x256) will be fully opaque and the other 
    # has transparency
    draw = ImageDraw.Draw(img)
    w, h = size
    red_color = ImageColor.getrgb("red")
    draw.rectangle((w/4, 0, w, h), fill=red_color)

    data = StringIO()
    img.save(data, format)
    data.seek(0)
    yield data


########NEW FILE########
__FILENAME__ = test_multiapp
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division
import os
import tempfile
import shutil
from webtest import TestApp
from mapproxy.multiapp import app_factory

def module_setup(test_config, config_files):
    fixture_dir = os.path.join(os.path.dirname(__file__), 'fixture')
    
    test_config['base_dir'] = tempfile.mkdtemp()
    test_config['config_files'] = []
    
    for config_file in config_files:
        config_file_src = os.path.join(fixture_dir, config_file)
        config_file_dst = os.path.join(test_config['base_dir'], config_file)
        shutil.copy(config_file_src, config_file_dst)
        test_config['config_files'].append(config_file_dst)
        
    app = app_factory({}, config_dir=test_config['base_dir'], allow_listing=False)
    test_config['multiapp'] = app
    test_config['app'] = TestApp(app, use_unicode=False)

def module_teardown(test_config):
    shutil.rmtree(test_config['base_dir'])
    test_config.clear()


test_config = {}

def setup_module():
    module_setup(test_config, ['multiapp1.yaml', 'multiapp2.yaml'])

def teardown_module():
    module_teardown(test_config)

class TestMultiapp(object):
    def setup(self):
        self.multiapp = test_config['multiapp']
        self.app = test_config['app']
    
    def test_index_without_list(self):
        resp = self.app.get('/')
        assert 'MapProxy' in resp
        assert 'multiapp1' not in resp

    def test_index_with_list(self):
        try:
            self.multiapp.list_apps = True
            resp = self.app.get('/')
            assert 'MapProxy' in resp
            assert 'multiapp1' in resp
        finally:
            self.multiapp.list_apps = False
    
    def test_unknown_app(self):
        self.app.get('/unknownapp', status=404)
        # assert status == 404 Not Found in app.get

    def test_known_app(self):
        resp = self.app.get('/multiapp1')
        assert 'demo' in resp

    def test_reloading(self):
        resp = self.app.get('/multiapp1')
        assert 'demo' in resp
        app_config = test_config['config_files'][0]

        replace_text_in_file(app_config, '  demo:', '  #demo:', ts_delta=5)

        resp = self.app.get('/multiapp1')
        assert 'demo' not in resp

        replace_text_in_file(app_config, '  #demo:', '  demo:', ts_delta=10)
        
        resp = self.app.get('/multiapp1')
        assert 'demo' in resp
    
def replace_text_in_file(filename, old, new, ts_delta=2):
    text = open(filename).read()
    text = text.replace(old, new)
    open(filename, 'w').write(text)
    
    # file timestamps are not precise enough (1sec)
    # add larger delta to force reload
    m_time = os.path.getmtime(filename)
    os.utime(filename, (m_time+ts_delta, m_time+ts_delta))
    
########NEW FILE########
__FILENAME__ = test_renderd_client
# This file is part of the MapProxy project.
# Copyright (C) 2010-2012 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os

try:
    import json; json
except ImportError:
    # test skipped later
    json = None

from mapproxy.test.image import img_from_buf
from mapproxy.test.http import mock_single_req_httpd
from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config
from mapproxy.request.wms import WMS111MapRequest, WMS111FeatureInfoRequest, WMS111CapabilitiesRequest
from mapproxy.test.helper import validate_with_dtd
from mapproxy.test.http import mock_httpd
from mapproxy.test.image import create_tmp_image
from mapproxy.test.system.test_wms import is_111_exception
from mapproxy.util.fs import ensure_directory
from mapproxy.cache.renderd import has_renderd_support

from nose.tools import eq_
from nose.plugins.skip import SkipTest

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    if not has_renderd_support():
        raise SkipTest("requests required")

    module_setup(test_config, 'renderd_client.yaml', with_cache_data=True)

def teardown_module():
    module_teardown(test_config)


from BaseHTTPServer import BaseHTTPRequestHandler

class TestWMS111(SystemTest):
    config = test_config

    def setup(self):
        SystemTest.setup(self)
        self.common_req = WMS111MapRequest(url='/service?', param=dict(service='WMS',
             version='1.1.1'))
        self.common_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS',
             version='1.1.1', bbox='-180,0,0,80', width='200', height='200',
             layers='wms_cache', srs='EPSG:4326', format='image/png',
             exceptions='xml',
             styles='', request='GetMap'))
        self.common_fi_req = WMS111FeatureInfoRequest(url='/service?',
            param=dict(x='10', y='20', width='200', height='200', layers='wms_cache',
                       format='image/png', query_layers='wms_cache', styles='',
                       bbox='1000,400,2000,1400', srs='EPSG:900913'))

    def test_wms_capabilities(self):
        req = WMS111CapabilitiesRequest(url='/service?').copy_with_request_params(self.common_req)
        resp = self.app.get(req)
        eq_(resp.content_type, 'application/vnd.ogc.wms_xml')
        xml = resp.lxml
        eq_(xml.xpath('//GetMap//OnlineResource/@xlink:href',
                      namespaces=dict(xlink="http://www.w3.org/1999/xlink"))[0],
            'http://localhost/service?')

        layer_names = set(xml.xpath('//Layer/Layer/Name/text()'))
        expected_names = set(['direct', 'wms_cache',
            'tms_cache'])
        eq_(layer_names, expected_names)
        assert validate_with_dtd(xml, dtd_name='wms/1.1.1/WMS_MS_Capabilities.dtd')

    def test_get_map(self):
        test_self = self
        class req_handler(BaseHTTPRequestHandler):
            def do_POST(self):
                length = int(self.headers['content-length'])
                json_data = self.rfile.read(length)
                task = json.loads(json_data)
                eq_(task['command'], 'tile')
                # request main tile of metatile
                eq_(task['tiles'], [[15, 17, 5]])
                eq_(task['cache_identifier'], 'wms_cache_GLOBAL_MERCATOR')
                eq_(task['priority'], 100)
                # this id should not change for the same tile/cache_identifier combination
                eq_(task['id'], 'aeb52b506e4e82d0a1edf649d56e0451cfd5862c')

                # manually create tile renderd should create
                tile_filename = os.path.join(test_self.config['cache_dir'],
                    'wms_cache_EPSG900913/05/000/000/016/000/000/016.jpeg')
                ensure_directory(tile_filename)
                with open(tile_filename, 'w') as f:
                    f.write(create_tmp_image((256, 256), format='jpeg', color=(255, 0, 100)))

                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write('{"status": "ok"}')

            def log_request(self, code, size=None):
                pass

        with mock_single_req_httpd(('localhost', 42423), req_handler):
            self.common_map_req.params['bbox'] = '0,0,9,9'
            resp = self.app.get(self.common_map_req)

            img = img_from_buf(resp.body)
            main_color = sorted(img.convert('RGBA').getcolors())[-1]
            # check for red color (jpeg/png conversion requires fuzzy comparision)
            assert main_color[0] == 40000
            assert main_color[1][0] > 250
            assert main_color[1][1] < 5
            assert 95 < main_color[1][2] < 105
            assert main_color[1][3] == 255

            eq_(resp.content_type, 'image/png')
            self.created_tiles.append('wms_cache_EPSG900913/05/000/000/016/000/000/016.jpeg')

    def test_get_map_error(self):
        class req_handler(BaseHTTPRequestHandler):
            def do_POST(self):
                length = int(self.headers['content-length'])
                json_data = self.rfile.read(length)
                task = json.loads(json_data)
                eq_(task['command'], 'tile')
                # request main tile of metatile
                eq_(task['tiles'], [[15, 17, 5]])
                eq_(task['cache_identifier'], 'wms_cache_GLOBAL_MERCATOR')
                eq_(task['priority'], 100)
                # this id should not change for the same tile/cache_identifier combination
                eq_(task['id'], 'aeb52b506e4e82d0a1edf649d56e0451cfd5862c')

                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write('{"status": "error", "error_message": "barf"}')

            def log_request(self, code, size=None):
                pass

        with mock_single_req_httpd(('localhost', 42423), req_handler):
            self.common_map_req.params['bbox'] = '0,0,9,9'
            resp = self.app.get(self.common_map_req)

            eq_(resp.content_type, 'application/vnd.ogc.se_xml')
            is_111_exception(resp.lxml, re_msg='Error from renderd: barf')

    def test_get_map_connection_error(self):
        self.common_map_req.params['bbox'] = '0,0,9,9'
        resp = self.app.get(self.common_map_req)

        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        is_111_exception(resp.lxml, re_msg='Error while communicating with renderd:')

    def test_get_map_non_json_response(self):
        class req_handler(BaseHTTPRequestHandler):
            def do_POST(self):
                length = int(self.headers['content-length'])
                json_data = self.rfile.read(length)
                json.loads(json_data)

                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write('{"invalid')

            def log_request(self, code, size=None):
                pass

        with mock_single_req_httpd(('localhost', 42423), req_handler):
            self.common_map_req.params['bbox'] = '0,0,9,9'
            resp = self.app.get(self.common_map_req)

        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        is_111_exception(resp.lxml, re_msg='Error while communicating with renderd: invalid JSON')


    def test_get_featureinfo(self):
        expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetFeatureInfo&HEIGHT=200&SRS=EPSG%3A900913'
                                  '&VERSION=1.1.1&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                  '&WIDTH=200&QUERY_LAYERS=foo,bar&X=10&Y=20&feature_count=100'},
                        {'body': 'info', 'headers': {'content-type': 'text/plain'}})
        with mock_httpd(('localhost', 42423), [expected_req]):
            self.common_fi_req.params['feature_count'] = 100
            resp = self.app.get(self.common_fi_req)
            eq_(resp.content_type, 'text/plain')
            eq_(resp.body, 'info')

class TestTiles(SystemTest):
    config = test_config

    def test_get_tile(self):
        test_self = self
        class req_handler(BaseHTTPRequestHandler):
            def do_POST(self):
                length = int(self.headers['content-length'])
                json_data = self.rfile.read(length)
                task = json.loads(json_data)
                eq_(task['command'], 'tile')
                eq_(task['tiles'], [[10, 20, 6]])
                eq_(task['cache_identifier'], 'tms_cache_GLOBAL_MERCATOR')
                eq_(task['priority'], 100)
                # this id should not change for the same tile/cache_identifier combination
                eq_(task['id'], 'cf35c1c927158e188d8fbe0db380c1772b536da9')

                # manually create tile renderd should create
                tile_filename = os.path.join(test_self.config['cache_dir'],
                    'tms_cache_EPSG900913/06/000/000/010/000/000/020.png')
                ensure_directory(tile_filename)
                with open(tile_filename, 'w') as f:
                    f.write("foobaz")

                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write('{"status": "ok"}')

            def log_request(self, code, size=None):
                pass

        with mock_single_req_httpd(('localhost', 42423), req_handler):
            resp = self.app.get('/tiles/tms_cache/EPSG900913/6/10/20.png')

            eq_(resp.content_type, 'image/png')
            eq_(resp.body, 'foobaz')
            self.created_tiles.append('tms_cache_EPSG900913/06/000/000/010/000/000/020.png')

    def test_get_tile_error(self):
        class req_handler(BaseHTTPRequestHandler):
            def do_POST(self):
                length = int(self.headers['content-length'])
                json_data = self.rfile.read(length)
                task = json.loads(json_data)
                eq_(task['command'], 'tile')
                eq_(task['tiles'], [[10, 20, 7]])
                eq_(task['cache_identifier'], 'tms_cache_GLOBAL_MERCATOR')
                eq_(task['priority'], 100)
                # this id should not change for the same tile/cache_identifier combination
                eq_(task['id'], 'c24b8c3247afec34fd0a53e5d3706e977877ef47')

                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write('{"status": "error", "error_message": "you told me to fail"}')

            def log_request(self, code, size=None):
                pass

        with mock_single_req_httpd(('localhost', 42423), req_handler):
            resp = self.app.get('/tiles/tms_cache/EPSG900913/7/10/20.png', status=500)
            eq_(resp.content_type, 'text/plain')
            eq_(resp.body, 'Error from renderd: you told me to fail')

########NEW FILE########
__FILENAME__ = test_scalehints
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division
import math


from mapproxy.request.wms import (
    WMS111MapRequest, WMS111CapabilitiesRequest, WMS130CapabilitiesRequest
)

from mapproxy.test.system import module_setup, module_teardown, make_base_config, SystemTest
from mapproxy.test.image import is_png, is_transparent, tmp_image
from mapproxy.test.http import mock_httpd
from mapproxy.test.system.test_wms import is_111_capa, is_130_capa, ns130
from nose.tools import assert_almost_equal

test_config = {}

def setup_module():
    module_setup(test_config, 'scalehints.yaml')

def teardown_module():
    module_teardown(test_config)

base_config = make_base_config(test_config)

def diagonal_res_to_pixel_res(res):
    """
    >>> '%.2f' % round(diagonal_res_to_pixel_res(14.14214), 4)
    '10.00'
    """
    return math.sqrt((float(res)**2)/2)

class TestWMS(SystemTest):
    config = test_config
    def setup(self):
        SystemTest.setup(self)
        self.common_req = WMS111MapRequest(url='/service?', param=dict(service='WMS',
             version='1.1.1'))
        self.common_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS',
             version='1.1.1', bbox='-180,0,0,80', width='200', height='200',
             layers='res', srs='EPSG:4326', format='image/png', transparent='true',
             styles='', request='GetMap'))

    def test_capabilities_111(self):
        req = WMS111CapabilitiesRequest(url='/service?').copy_with_request_params(self.common_req)
        resp = self.app.get(req)
        xml = resp.lxml
        assert is_111_capa(xml)
        hints = xml.xpath('//Layer/Layer/ScaleHint')
        assert_almost_equal(diagonal_res_to_pixel_res(hints[0].attrib['min']), 10, 2)
        assert_almost_equal(diagonal_res_to_pixel_res(hints[0].attrib['max']), 10000, 2)

        assert_almost_equal(diagonal_res_to_pixel_res(hints[1].attrib['min']), 2.8, 2)
        assert_almost_equal(diagonal_res_to_pixel_res(hints[1].attrib['max']), 280, 2)

        assert_almost_equal(diagonal_res_to_pixel_res(hints[2].attrib['min']), 0.28, 2)
        assert_almost_equal(diagonal_res_to_pixel_res(hints[2].attrib['max']), 2.8, 2)

    def test_capabilities_130(self):
        req = WMS130CapabilitiesRequest(url='/service?').copy_with_request_params(self.common_req)
        resp = self.app.get(req)
        xml = resp.lxml
        assert is_130_capa(xml)
        min_scales = xml.xpath('//wms:Layer/wms:Layer/wms:MinScaleDenominator/text()', namespaces=ns130)
        max_scales = xml.xpath('//wms:Layer/wms:Layer/wms:MaxScaleDenominator/text()', namespaces=ns130)

        assert_almost_equal(float(min_scales[0]), 35714.28, 1)
        assert_almost_equal(float(max_scales[0]), 35714285.7, 1)

        assert_almost_equal(float(min_scales[1]), 10000, 2)
        assert_almost_equal(float(max_scales[1]), 1000000, 2)

        assert_almost_equal(float(min_scales[2]), 1000, 2)
        assert_almost_equal(float(max_scales[2]), 10000, 2)

    def test_get_map_above_res(self):
        # no layer rendered
        resp = self.app.get(self.common_map_req)
        assert is_png(resp.body)
        assert is_transparent(resp.body)

    def test_get_map_mixed(self):
        # only res layer matches resolution range
        self.common_map_req.params['layers'] = 'res,scale'
        self.common_map_req.params['bbox'] = '0,0,100000,100000'
        self.common_map_req.params['srs'] = 'EPSG:900913'
        self.common_map_req.params.size = 100, 100
        self.created_tiles.append('res_cache_EPSG900913/08/000/000/128/000/000/128.jpeg')
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/service?LAYERs=reslayer&SERVICE=WMS&FORMAT=image%2Fjpeg'
                                      '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A900913&styles='
                                      '&VERSION=1.1.1&BBOX=0.0,0.0,156543.033928,156543.033928'
                                      '&WIDTH=256'},
                            {'body': img.read(), 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get(self.common_map_req)
                assert is_png(resp.body)
                assert not is_transparent(resp.body)

########NEW FILE########
__FILENAME__ = test_seed
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os
import time
import shutil
import tempfile
from mapproxy.config.loader import load_configuration
from mapproxy.cache.tile import Tile
from mapproxy.image import ImageSource
from mapproxy.image.opts import ImageOptions
from mapproxy.seed.seeder import seed
from mapproxy.seed.cleanup import cleanup
from mapproxy.seed.config import load_seed_tasks_conf
from mapproxy.config import local_base_config
from mapproxy.util.fs import ensure_directory

from mapproxy.test.http import mock_httpd
from mapproxy.test.image import tmp_image, create_tmp_image_buf, create_tmp_image

from nose.tools import eq_

FIXTURE_DIR = os.path.join(os.path.dirname(__file__), 'fixture')

class SeedTestEnvironment(object):
    def setup(self):
        self.dir = tempfile.mkdtemp()
        shutil.copy(os.path.join(FIXTURE_DIR, self.seed_conf_name), self.dir)
        shutil.copy(os.path.join(FIXTURE_DIR, self.mapproxy_conf_name), self.dir)
        shutil.copy(os.path.join(FIXTURE_DIR, self.empty_ogrdata), self.dir)
        self.seed_conf_file = os.path.join(self.dir, self.seed_conf_name)
        self.mapproxy_conf_file = os.path.join(self.dir, self.mapproxy_conf_name)
        self.mapproxy_conf = load_configuration(self.mapproxy_conf_file, seed=True)

    def teardown(self):
        shutil.rmtree(self.dir)

    def make_tile(self, coord=(0, 0, 0), timestamp=None):
        """
        Create file for tile at `coord` with given timestamp.
        """
        tile_dir = os.path.join(self.dir, 'cache/one_EPSG4326/%02d/000/000/%03d/000/000/' %
                                (coord[2], coord[0]))

        ensure_directory(tile_dir)
        tile = os.path.join(tile_dir + '%03d.png' % coord[1])
        open(tile, 'w').write('')
        if timestamp:
            os.utime(tile, (timestamp, timestamp))
        return tile

    def tile_exists(self, coord):
        tile_dir = os.path.join(self.dir, 'cache/one_EPSG4326/%02d/000/000/%03d/000/000/' %
                                (coord[2], coord[0]))
        tile = os.path.join(tile_dir + '%03d.png' % coord[1])
        return os.path.exists(tile)

class SeedTestBase(SeedTestEnvironment):

    def test_seed_dry_run(self):
        with local_base_config(self.mapproxy_conf.base_config):
            seed_conf  = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
            tasks, cleanup_tasks = seed_conf.seeds(['one']), seed_conf.cleanups()
            seed(tasks, dry_run=True)
            cleanup(cleanup_tasks, verbose=False, dry_run=True)

    def test_seed(self):
        with tmp_image((256, 256), format='png') as img:
            img_data = img.read()
            expected_req = ({'path': r'/service?LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetMap&VERSION=1.1.1&bbox=-180.0,-90.0,180.0,90.0'
                                  '&width=256&height=128&srs=EPSG:4326'},
                            {'body': img_data, 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                with local_base_config(self.mapproxy_conf.base_config):
                    seed_conf  = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
                    tasks, cleanup_tasks = seed_conf.seeds(['one']), seed_conf.cleanups()
                    seed(tasks, dry_run=False)
                    cleanup(cleanup_tasks, verbose=False, dry_run=False)

    def test_reseed_uptodate(self):
        # tile already there.
        self.make_tile((0, 0, 0))
        with local_base_config(self.mapproxy_conf.base_config):
            seed_conf  = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
            tasks, cleanup_tasks = seed_conf.seeds(['one']), seed_conf.cleanups()
            seed(tasks, dry_run=False)
            cleanup(cleanup_tasks, verbose=False, dry_run=False)

class TestSeedOldConfiguration(SeedTestBase):
    seed_conf_name = 'seed_old.yaml'
    mapproxy_conf_name = 'seed_mapproxy.yaml'
    empty_ogrdata = 'empty_ogrdata.geojson'

    def test_reseed_remove_before(self):
        # tile already there but too old
        t000 = self.make_tile((0, 0, 0), timestamp=time.time() - (60*60*25))
        # old tile outside the seed view (should be removed)
        t001 = self.make_tile((0, 0, 1), timestamp=time.time() - (60*60*25))
        assert os.path.exists(t000)
        assert os.path.exists(t001)
        with tmp_image((256, 256), format='png') as img:
            img_data = img.read()
            expected_req = ({'path': r'/service?LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetMap&VERSION=1.1.1&bbox=-180.0,-90.0,180.0,90.0'
                                  '&width=256&height=128&srs=EPSG:4326'},
                            {'body': img_data, 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                seed_conf  = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
                tasks, cleanup_tasks = seed_conf.seeds(), seed_conf.cleanups()
                seed(tasks, dry_run=False)
                cleanup(cleanup_tasks, verbose=False, dry_run=False)

        assert os.path.exists(t000)
        assert os.path.getmtime(t000) - 5 < time.time() < os.path.getmtime(t000) + 5
        assert not os.path.exists(t001)


tile_image_buf = create_tmp_image_buf((256, 256), color='blue')
tile_image = create_tmp_image((256, 256), color='blue')

class TestSeed(SeedTestBase):
    seed_conf_name = 'seed.yaml'
    mapproxy_conf_name = 'seed_mapproxy.yaml'
    empty_ogrdata = 'empty_ogrdata.geojson'

    def test_cleanup_levels(self):
        seed_conf  = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
        cleanup_tasks = seed_conf.cleanups(['cleanup'])

        self.make_tile((0, 0, 0))
        self.make_tile((0, 0, 1))
        self.make_tile((0, 0, 2))
        self.make_tile((0, 0, 3))

        cleanup(cleanup_tasks, verbose=False, dry_run=False)
        assert not self.tile_exists((0, 0, 0))
        assert not self.tile_exists((0, 0, 1))
        assert self.tile_exists((0, 0, 2))
        assert not self.tile_exists((0, 0, 3))

        eq_(sorted(os.listdir(os.path.join(self.dir, 'cache', 'one_EPSG4326'))),
            ['02'])

    def test_cleanup_remove_all(self):
        seed_conf  = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
        cleanup_tasks = seed_conf.cleanups(['remove_all'])

        self.make_tile((0, 0, 0))
        self.make_tile((0, 0, 1))
        self.make_tile((1, 0, 1))
        self.make_tile((0, 1, 1))
        self.make_tile((1, 1, 1))
        self.make_tile((0, 0, 2))
        self.make_tile((0, 0, 3))

        eq_(sorted(os.listdir(os.path.join(self.dir, 'cache', 'one_EPSG4326'))),
            ['00', '01', '02', '03'])

        cleanup(cleanup_tasks, verbose=False, dry_run=False)
        assert self.tile_exists((0, 0, 0))
        assert not self.tile_exists((0, 0, 1))
        assert not self.tile_exists((1, 0, 1))
        assert not self.tile_exists((0, 1, 1))
        assert not self.tile_exists((1, 1, 1))
        assert not self.tile_exists((0, 0, 1))
        assert self.tile_exists((0, 0, 2))
        assert self.tile_exists((0, 0, 3))

        # remove_all should remove the whole directory
        eq_(sorted(os.listdir(os.path.join(self.dir, 'cache', 'one_EPSG4326'))),
            ['00', '02', '03'])

    def test_cleanup_coverage(self):
        seed_conf = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
        cleanup_tasks = seed_conf.cleanups(['with_coverage'])

        self.make_tile((0, 0, 0))
        self.make_tile((1, 0, 1))
        self.make_tile((2, 0, 2))
        self.make_tile((2, 0, 3))
        self.make_tile((4, 0, 3))

        cleanup(cleanup_tasks, verbose=False, dry_run=False)
        assert not self.tile_exists((0, 0, 0))
        assert not self.tile_exists((1, 0, 1))
        assert self.tile_exists((2, 0, 2))
        assert not self.tile_exists((2, 0, 3))
        assert self.tile_exists((4, 0, 3))

    def test_seed_mbtile(self):
        with tmp_image((256, 256), format='png') as img:
            img_data = img.read()
            expected_req = ({'path': r'/service?LAYERS=bar&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetMap&VERSION=1.1.1&bbox=-180.0,-90.0,180.0,90.0'
                                  '&width=256&height=128&srs=EPSG:4326'},
                            {'body': img_data, 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                seed_conf  = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
                tasks, cleanup_tasks = seed_conf.seeds(['mbtile_cache']), seed_conf.cleanups(['cleanup_mbtile_cache'])
                seed(tasks, dry_run=False)
                cleanup(cleanup_tasks, verbose=False, dry_run=False)

    def create_tile(self, coord=(0, 0, 0)):
        return Tile(coord,
            ImageSource(tile_image_buf,
                image_opts=ImageOptions(format='image/png')))

    def test_reseed_mbtiles(self):
        seed_conf  = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
        tasks, cleanup_tasks = seed_conf.seeds(['mbtile_cache']), seed_conf.cleanups(['cleanup_mbtile_cache'])

        cache = tasks[0].tile_manager.cache
        cache.store_tile(self.create_tile())
        # no refresh before
        seed(tasks, dry_run=False)

    def test_reseed_mbtiles_with_refresh(self):
        seed_conf  = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
        tasks, cleanup_tasks = seed_conf.seeds(['mbtile_cache_refresh']), seed_conf.cleanups(['cleanup_mbtile_cache'])

        cache = tasks[0].tile_manager.cache
        cache.store_tile(self.create_tile())

        expected_req = ({'path': r'/service?LAYERS=bar&SERVICE=WMS&FORMAT=image%2Fpng'
                          '&REQUEST=GetMap&VERSION=1.1.1&bbox=-180.0,-90.0,180.0,90.0'
                          '&width=256&height=128&srs=EPSG:4326'},
                        {'body': tile_image, 'headers': {'content-type': 'image/png'}})
        with mock_httpd(('localhost', 42423), [expected_req]):
            # mbtiles does not support timestamps, refresh all tiles
            seed(tasks, dry_run=False)

    def test_cleanup_mbtiles(self):
        seed_conf  = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
        tasks, cleanup_tasks = seed_conf.seeds(['mbtile_cache_refresh']), seed_conf.cleanups(['cleanup_mbtile_cache'])

        cache = tasks[0].tile_manager.cache
        cache.store_tile(self.create_tile())

        cleanup(cleanup_tasks, verbose=False, dry_run=False)

    def test_cleanup_sqlite(self):
        seed_conf  = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
        cleanup_tasks = seed_conf.cleanups(['sqlite_cache'])

        cache = cleanup_tasks[0].tile_manager.cache
        cache.store_tile(self.create_tile((0, 0, 2)))
        cache.store_tile(self.create_tile((0, 0, 3)))
        assert cache.is_cached(Tile((0, 0, 2)))
        assert cache.is_cached(Tile((0, 0, 3)))

        eq_(sorted(os.listdir(os.path.join(self.dir, 'cache', 'sqlite_cache', 'GLOBAL_GEODETIC'))),
            ['2.mbtile', '3.mbtile'])

        cleanup(cleanup_tasks, verbose=False, dry_run=False)

        # 3.mbtile file is still there
        eq_(sorted(os.listdir(os.path.join(self.dir, 'cache', 'sqlite_cache', 'GLOBAL_GEODETIC'))),
            ['2.mbtile', '3.mbtile'])
        assert cache.is_cached(Tile((0, 0, 2)))
        assert not cache.is_cached(Tile((0, 0, 3)))

    def test_cleanup_sqlite_remove_all(self):
        seed_conf  = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
        cleanup_tasks = seed_conf.cleanups(['sqlite_cache_remove_all'])

        cache = cleanup_tasks[0].tile_manager.cache
        cache.store_tile(self.create_tile((0, 0, 2)))
        cache.store_tile(self.create_tile((0, 0, 3)))
        assert cache.is_cached(Tile((0, 0, 2)))
        assert cache.is_cached(Tile((0, 0, 3)))

        eq_(sorted(os.listdir(os.path.join(self.dir, 'cache', 'sqlite_cache', 'GLOBAL_GEODETIC'))),
            ['2.mbtile', '3.mbtile'])

        cleanup(cleanup_tasks, verbose=False, dry_run=False)

        # 3.mbtile file should be removed completely
        eq_(sorted(os.listdir(os.path.join(self.dir, 'cache', 'sqlite_cache', 'GLOBAL_GEODETIC'))),
            ['3.mbtile'])
        assert not cache.is_cached(Tile((0, 0, 2)))
        assert cache.is_cached(Tile((0, 0, 3)))

    def test_active_seed_tasks(self):
        with local_base_config(self.mapproxy_conf.base_config):
            seed_conf = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
            assert len(seed_conf.seed_tasks_names()) == 5
            assert len(seed_conf.seeds()) == 4

    def test_seed_refresh_remove_before_from_file(self):
        # tile already there but old
        t000 = self.make_tile((0, 0, 0), timestamp=time.time() - (60*60*25))

        # mtime is older than tile, no create of the tile
        timestamp = time.time() - (60*60*30)
        os.utime(self.seed_conf_file, (timestamp, timestamp))
        with local_base_config(self.mapproxy_conf.base_config):
            seed_conf  = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
            tasks = seed_conf.seeds(['refresh_from_file'])
            seed(tasks, dry_run=False)


        # touch the seed_conf file and refresh everything
        os.utime(self.seed_conf_file, None)
        img_data = create_tmp_image((256, 256), format='png')
        expected_req = ({'path': r'/service?LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
                              '&REQUEST=GetMap&VERSION=1.1.1&bbox=-180.0,-90.0,180.0,90.0'
                              '&width=256&height=128&srs=EPSG:4326'},
                        {'body': img_data, 'headers': {'content-type': 'image/png'}})
        with mock_httpd(('localhost', 42423), [expected_req]):
            # touch the seed_conf file and refresh everything
            timestamp = time.time() - 60
            os.utime(self.seed_conf_file, (timestamp, timestamp))

            with local_base_config(self.mapproxy_conf.base_config):
                seed_conf  = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
                tasks = seed_conf.seeds(['refresh_from_file'])
                seed(tasks, dry_run=False)

                assert os.path.exists(t000)
                assert os.path.getmtime(t000) - 5 < time.time() < os.path.getmtime(t000) + 5

        # mtime is older than tile, no cleanup
        timestamp = time.time() - 5
        os.utime(self.seed_conf_file, (timestamp, timestamp))
        with local_base_config(self.mapproxy_conf.base_config):
            seed_conf  = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
            cleanup_tasks = seed_conf.cleanups(['remove_from_file'])
            cleanup(cleanup_tasks, verbose=False, dry_run=False)
        assert os.path.exists(t000)

        # now touch the seed_conf again and remove everything
        timestamp = time.time() + 5
        os.utime(self.seed_conf_file, (timestamp, timestamp))
        with local_base_config(self.mapproxy_conf.base_config):
            seed_conf  = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
            cleanup_tasks = seed_conf.cleanups(['remove_from_file'])
            cleanup(cleanup_tasks, verbose=False, dry_run=False)
        assert not os.path.exists(t000)

class TestConcurrentRequestsSeed(SeedTestEnvironment):
    seed_conf_name = 'seed_timeouts.yaml'
    mapproxy_conf_name = 'seed_timeouts_mapproxy.yaml'
    empty_ogrdata = 'empty_ogrdata.geojson'

    def test_timeout(self):
        # test concurrent seeding where seed concurrency is higher than the permitted
        # concurrent_request value of the source and a lock times out

        seed_conf  = load_seed_tasks_conf(self.seed_conf_file, self.mapproxy_conf)
        tasks = seed_conf.seeds(['test'])

        expected_req1 = ({'path': r'/service?LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
                          '&REQUEST=GetMap&VERSION=1.1.1&bbox=-180.0,-90.0,180.0,90.0'
                          '&width=256&height=128&srs=EPSG:4326'},
                        {'body': tile_image, 'headers': {'content-type': 'image/png'}, 'duration': 0.1})

        expected_req2 = ({'path': r'/service?LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
                          '&REQUEST=GetMap&VERSION=1.1.1&bbox=-180.0,-90.0,180.0,90.0'
                          '&width=512&height=256&srs=EPSG:4326'},
                        {'body': tile_image, 'headers': {'content-type': 'image/png'}, 'duration': 0.1})

        expected_req3 = ({'path': r'/service?LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
                          '&REQUEST=GetMap&VERSION=1.1.1&bbox=-180.0,-90.0,180.0,90.0'
                          '&width=1024&height=512&srs=EPSG:4326'},
                        {'body': tile_image, 'headers': {'content-type': 'image/png'}, 'duration': 0.1})


        with mock_httpd(('localhost', 42423), [expected_req1, expected_req2, expected_req3], unordered=True):
            seed(tasks, dry_run=False, concurrency=3)
            # concurrency=3, concurrent_request=1, client_timeout=0.2, response delay=0.1
            # the third request should time out (3x0.1 > 0.2), but exp_backoff() in the seeder ignores this
            # timeout exception and tries a second time


########NEW FILE########
__FILENAME__ = test_seed_only
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

from cStringIO import StringIO
from mapproxy.request.wms import WMS111MapRequest
from mapproxy.platform.image import Image
from mapproxy.test.image import is_png, is_jpeg
from mapproxy.test.system import module_setup, module_teardown, SystemTest
from nose.tools import eq_

test_config = {}

def setup_module():
    module_setup(test_config, 'seedonly.yaml', with_cache_data=True)

def teardown_module():
    module_teardown(test_config)

class TestSeedOnlyWMS(SystemTest):
    config = test_config
    def setup(self):
        SystemTest.setup(self)
        self.common_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS',
             version='1.1.1', bbox='-180,0,0,80', width='200', height='200',
             layers='wms_cache', srs='EPSG:4326', format='image/png',
             styles='', request='GetMap', transparent=True))

    def test_get_map_cached(self):
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        data = StringIO(resp.body)
        assert is_png(data)
        img = Image.open(data)
        eq_(img.mode, 'RGB')
        # cached image has more that 256 colors, getcolors -> None
        eq_(img.getcolors(), None)

    def test_get_map_uncached(self):
        self.common_map_req.params['bbox'] = '10,10,20,20'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        data = StringIO(resp.body)
        assert is_png(data)
        img = Image.open(data)
        eq_(img.mode, 'RGBA')
        eq_(img.getcolors(), [(200*200, (255, 255, 255, 0))])

class TestSeedOnlyTMS(SystemTest):
    config = test_config

    def test_get_tile_cached(self):
        resp = self.app.get('/tms/1.0.0/wms_cache/0/0/1.jpeg')
        eq_(resp.content_type, 'image/jpeg')
        data = StringIO(resp.body)
        assert is_jpeg(data)
        img = Image.open(data)
        eq_(img.mode, 'RGB')
        # cached image has more that 256 colors, getcolors -> None
        eq_(img.getcolors(), None)

    def test_get_tile_uncached(self):
        resp = self.app.get('/tms/1.0.0/wms_cache/0/0/0.jpeg')
        eq_(resp.content_type, 'image/png')
        data = StringIO(resp.body)
        assert is_png(data)
        img = Image.open(data)
        eq_(img.mode, 'RGBA')
        eq_(img.getcolors(), [(256*256, (255, 255, 255, 0))])
########NEW FILE########
__FILENAME__ = test_sld
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division
import os
import tempfile
from urllib import quote

from mapproxy.request.wms import WMS111MapRequest
from mapproxy.test.system import module_setup, module_teardown, make_base_config, SystemTest
from mapproxy.test.http import mock_httpd
from mapproxy.test.image import create_tmp_image

from nose.tools import eq_

test_config = {}

def setup_module():
    test_config['base_dir'] = tempfile.mkdtemp()
    with open(os.path.join(test_config['base_dir'], 'mysld.xml'), 'w') as f:
        f.write('<sld>')
    module_setup(test_config, 'sld.yaml')

def teardown_module():
    module_teardown(test_config)

base_config = make_base_config(test_config)

TESTSERVER_ADDRESS = 'localhost', 42423

class TestWMS(SystemTest):
    config = test_config
    def setup(self):
        SystemTest.setup(self)
        self.common_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS',
             version='1.1.1', bbox='0,0,10,10', width='200', height='200',
             srs='EPSG:4326', format='image/png', styles='', request='GetMap',
             exceptions='xml'))
        self.common_wms_url = ("/service?styles=&srs=EPSG%3A4326&version=1.1.1&"
            "bbox=0.0,0.0,10.0,10.0&service=WMS&format=image%2Fpng&request=GetMap"
            "&width=200&height=200")

    def test_sld_url(self):
        self.common_map_req.params['layers'] = 'sld_url'
        with mock_httpd(TESTSERVER_ADDRESS, [
          ({'path': self.common_wms_url + '&sld=' +quote('http://example.org/sld.xml'),
            'method': 'GET'},
           {'body': create_tmp_image((200, 200), format='png')}
          )]):
            resp = self.app.get(self.common_map_req)
            eq_(resp.content_type, 'image/png')

    def test_sld_file(self):
        self.common_map_req.params['layers'] = 'sld_file'
        with mock_httpd(TESTSERVER_ADDRESS, [
          ({'path': self.common_wms_url + '&sld_body=' +quote('<sld>'), 'method': 'GET'},
           {'body': create_tmp_image((200, 200), format='png')}
          )]):
            resp = self.app.get(self.common_map_req)
            eq_(resp.content_type, 'image/png')

    def test_sld_body(self):
        self.common_map_req.params['layers'] = 'sld_body'
        with mock_httpd(TESTSERVER_ADDRESS, [
          ({'path': self.common_wms_url + '&sld_body=' +quote('<sld:StyledLayerDescriptor />'),
            'method': 'POST'},
           {'body': create_tmp_image((200, 200), format='png')}
          )]):
            resp = self.app.get(self.common_map_req)
            eq_(resp.content_type, 'image/png')



########NEW FILE########
__FILENAME__ = test_source_errors
# This file is part of the MapProxy project.
# Copyright (C) 2010-2014 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

import os

from mapproxy.request.wms import WMS111MapRequest
from mapproxy.test.image import is_transparent, create_tmp_image, bgcolor_ratio, img_from_buf
from mapproxy.test.http import mock_httpd
from mapproxy.test.system import module_setup, module_teardown, SystemTest
from mapproxy.test.system.test_wms import is_111_exception
from nose.tools import eq_

test_config = {}
test_config_raise = {}

def setup_module():
    module_setup(test_config, 'source_errors.yaml')
    module_setup(test_config_raise, 'source_errors_raise.yaml')

def teardown_module():
    module_teardown(test_config)
    module_teardown(test_config_raise)


transp = create_tmp_image((200, 200), mode='RGBA', color=(0, 0, 0, 0))

class TestWMS(SystemTest):
    config = test_config
    def setup(self):
        SystemTest.setup(self)
        self.common_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS',
             version='1.1.1', bbox='9,50,10,51', width='200', height='200',
             layers='online', srs='EPSG:4326', format='image/png',
             styles='', request='GetMap', transparent=True))

    def test_online(self):
        common_params = (r'?SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326&styles='
                                  '&VERSION=1.1.1&BBOX=9.0,50.0,10.0,51.0'
                                  '&WIDTH=200&transparent=True')

        expected_req = [({'path': '/service_a' + common_params + '&layers=a_one'},
                         {'body': transp, 'headers': {'content-type': 'image/png'}}),
                        ]

        with mock_httpd(('localhost', 42423), expected_req):
            self.common_map_req.params.layers = 'online'
            resp = self.app.get(self.common_map_req)
            assert 'Cache-Control' not in resp.headers
            eq_(resp.content_type, 'image/png')
            assert is_transparent(resp.body)

    def test_mixed_layer_source(self):
        common_params = (r'?SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326&styles='
                                  '&VERSION=1.1.1&BBOX=9.0,50.0,10.0,51.0'
                                  '&WIDTH=200&transparent=True')

        expected_req = [({'path': '/service_a' + common_params + '&layers=a_one'},
                         {'body': transp, 'headers': {'content-type': 'image/png'}}),
                        ]

        with mock_httpd(('localhost', 42423), expected_req):
            self.common_map_req.params.layers = 'mixed'
            resp = self.app.get(self.common_map_req)
            assert_no_cache(resp)
            eq_(resp.content_type, 'image/png')
            assert 0.99 > bgcolor_ratio(resp.body) > 0.95

    def test_mixed_sources(self):
        common_params = (r'?SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326&styles='
                                  '&VERSION=1.1.1&BBOX=9.0,50.0,10.0,51.0'
                                  '&WIDTH=200&transparent=True')

        expected_req = [({'path': '/service_a' + common_params + '&layers=a_one'},
                         {'body': transp, 'headers': {'content-type': 'image/png'}}),
                        ]

        with mock_httpd(('localhost', 42423), expected_req):
            self.common_map_req.params.layers = 'online,all_offline'
            resp = self.app.get(self.common_map_req)
            assert_no_cache(resp)
            eq_(resp.content_type, 'image/png')
            assert 0.99 > bgcolor_ratio(resp.body) > 0.95
            # open('/tmp/foo.png', 'wb').write(resp.body)

    def test_all_offline(self):
        self.common_map_req.params.layers = 'all_offline'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        is_111_exception(resp.lxml, re_msg='no response from url')


class TestWMSRaise(SystemTest):
    config = test_config_raise
    def setup(self):
        SystemTest.setup(self)
        self.common_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS',
             version='1.1.1', bbox='9,50,10,51', width='200', height='200',
             layers='online', srs='EPSG:4326', format='image/png',
             styles='', request='GetMap', transparent=True))

    def test_mixed_layer_source(self):
        common_params = (r'?SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326&styles='
                                  '&VERSION=1.1.1&BBOX=9.0,50.0,10.0,51.0'
                                  '&WIDTH=200&transparent=True')

        expected_req = [({'path': '/service_a' + common_params + '&layers=a_one'},
                         {'body': transp, 'headers': {'content-type': 'image/png'}}),
                        ]

        with mock_httpd(('localhost', 42423), expected_req):
            self.common_map_req.params.layers = 'mixed'
            resp = self.app.get(self.common_map_req)
            is_111_exception(resp.lxml, re_msg='no response from url')

    def test_all_offline(self):
        self.common_map_req.params.layers = 'all_offline'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        is_111_exception(resp.lxml, re_msg='no response from url')

class TestTileErrors(SystemTest):
    config = test_config
    def setup(self):
        SystemTest.setup(self)
        self.common_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS',
             version='1.1.1', bbox='0,-90,180,90', width='250', height='250',
             layers='tilesource', srs='EPSG:4326', format='image/png',
             styles='', request='GetMap', transparent=True))

        self.common_tile_req = '/tiles/tilesource/EPSG4326/1/1/0.png'

    def test_wms_uncached_response(self):
        expected_req = [({'path': '/foo/1/1/0.png'},
                         {'body': 'not found', 'status': 404, 'headers': {'content-type': 'text/plain'}}),
                        ]

        with mock_httpd(('localhost', 42423), expected_req):
            resp = self.app.get(self.common_map_req)
            eq_(resp.content_type, 'image/png')
            assert_no_cache(resp)
            img = img_from_buf(resp.body)
            eq_(img.getcolors(), [(250 * 250, (255, 0, 128))])
            assert not os.path.exists(os.path.join(self.base_config().cache.base_dir,
                'tilesource_cache_EPSG4326/01/000/000/001/000/000/000.png'))

    def test_wms_cached_response(self):
        expected_req = [({'path': '/foo/1/1/0.png'},
                         {'body': 'no content', 'status': 204, 'headers': {'content-type': 'text/plain'}}),
                        ]

        with mock_httpd(('localhost', 42423), expected_req):
            resp = self.app.get(self.common_map_req)
            eq_(resp.content_type, 'image/png')
            assert 'Cache-Control' not in resp.headers
            img = img_from_buf(resp.body)
            eq_(img.getcolors(), [(250 * 250, (100, 200, 50, 250))])
            self.created_tiles.append('tilesource_cache_EPSG4326/01/000/000/001/000/000/000.png')

    def test_wms_unhandled_error_code(self):
        expected_req = [({'path': '/foo/1/1/0.png'},
                         {'body': 'error', 'status': 500, 'headers': {'content-type': 'text/plain'}}),
                        ]

        with mock_httpd(('localhost', 42423), expected_req):
            resp = self.app.get(self.common_map_req)
            assert 'Cache-Control' not in resp.headers
            eq_(resp.content_type, 'application/vnd.ogc.se_xml')
            assert '500' in resp.body

    def test_wms_catchall_error_no_image_response(self):
        expected_req = [({'path': '/foo/1/1/0.png'},
                         {'body': 'error', 'status': 200, 'headers': {'content-type': 'text/plain'}}),
                        ]

        with mock_httpd(('localhost', 42423), expected_req):
            self.common_map_req.params['layers'] = 'tilesource_catchall'
            resp = self.app.get(self.common_map_req)
            assert_no_cache(resp)
            eq_(resp.content_type, 'image/png')
            img = img_from_buf(resp.body)
            eq_(img.getcolors(), [(250 * 250, (100, 50, 50))])

    def test_tile_uncached_response(self):
        expected_req = [({'path': '/foo/1/1/0.png'},
                         {'body': 'not found', 'status': 404, 'headers': {'content-type': 'text/plain'}}),
                        ]

        with mock_httpd(('localhost', 42423), expected_req):
            resp = self.app.get(self.common_tile_req)
            assert_no_cache(resp)
            eq_(resp.content_type, 'image/png')
            img = img_from_buf(resp.body)
            eq_(img.getcolors(), [(256 * 256, (255, 0, 128))])
            assert not os.path.exists(os.path.join(self.base_config().cache.base_dir,
                'tilesource_cache_EPSG4326/01/000/000/001/000/000/000.png'))

    def test_tile_cached_response(self):
        expected_req = [({'path': '/foo/1/1/0.png'},
                         {'body': 'no content', 'status': 204, 'headers': {'content-type': 'text/plain'}}),
                        ]

        with mock_httpd(('localhost', 42423), expected_req):
            resp = self.app.get(self.common_tile_req)
            assert 'public' in resp.headers['Cache-Control']
            eq_(resp.content_type, 'image/png')
            img = img_from_buf(resp.body)
            eq_(img.getcolors(), [(256 * 256, (100, 200, 50, 250))])
            self.created_tiles.append('tilesource_cache_EPSG4326/01/000/000/001/000/000/000.png')

    def test_tile_unhandled_error_code(self):
        expected_req = [({'path': '/foo/1/1/0.png'},
                         {'body': 'error', 'status': 500, 'headers': {'content-type': 'text/plain'}}),
                        ]

        with mock_httpd(('localhost', 42423), expected_req):
            resp = self.app.get(self.common_tile_req, status=500)
            assert 'Cache-Control' not in resp.headers
            # no assert_no_cache(resp): returns XML exception that bypasses cache control setting
            eq_(resp.content_type, 'text/plain')
            assert '500' in resp.body

    def test_tile_catchall_error_no_image_response(self):
        expected_req = [({'path': '/foo/1/1/0.png'},
                         {'body': 'error', 'status': 200, 'headers': {'content-type': 'text/plain'}}),
                        ]

        with mock_httpd(('localhost', 42423), expected_req):
            resp = self.app.get(self.common_tile_req.replace('tilesource', 'tilesource_catchall'))
            assert_no_cache(resp)
            eq_(resp.content_type, 'image/png')
            img = img_from_buf(resp.body)
            eq_(img.getcolors(), [(256 * 256, (100, 50, 50))])


def assert_no_cache(resp):
    eq_(resp.headers['Pragma'], 'no-cache')
    eq_(resp.headers['Expires'], '-1')
    eq_(resp.cache_control.no_store, True)

########NEW FILE########
__FILENAME__ = test_tilesource_minmax_res
# This file is part of the MapProxy project.
# Copyright (C) 2012 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
from mapproxy.test.image import tmp_image
from mapproxy.test.http import mock_httpd
from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config
from nose.tools import eq_

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'tilesource_minmax_res.yaml')

def teardown_module():
    module_teardown(test_config)

class TestTileSourceMinMaxRes(SystemTest):
    config = test_config

    def test_get_tile_res_a(self):
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/tiles_a/06/000/000/000/000/000/001.png'},
                            {'body': img.read(), 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get('/tiles/tms_cache/6/0/1.png')
                eq_(resp.content_type, 'image/png')
                self.created_tiles.append('tms_cache_EPSG900913/06/000/000/000/000/000/001.png')

    def test_get_tile_res_b(self):
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/tiles_b/07/000/000/000/000/000/001.png'},
                            {'body': img.read(), 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get('/tiles/tms_cache/7/0/1.png')
                eq_(resp.content_type, 'image/png')
                self.created_tiles.append('tms_cache_EPSG900913/07/000/000/000/000/000/001.png')

########NEW FILE########
__FILENAME__ = test_tms
# This file is part of the MapProxy project.
# Copyright (C) 2010-2012 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os
import hashlib
from cStringIO import StringIO
from mapproxy.platform.image import Image
from mapproxy.test.image import is_jpeg, tmp_image
from mapproxy.test.http import mock_httpd
from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config
from nose.tools import eq_

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'layer.yaml', with_cache_data=True)

def teardown_module():
    module_teardown(test_config)

class TestTMS(SystemTest):
    config = test_config
    
    def test_tms_capabilities(self):
        resp = self.app.get('/tms/1.0.0/')
        assert 'WMS Cache Layer' in resp
        assert 'WMS Cache Multi Layer' in resp
        assert 'TMS Cache Layer' in resp
        xml = resp.lxml
        assert xml.xpath('count(//TileMap)') == 10
        
        # without trailing space
        resp2 = self.app.get('/tms/1.0.0')
        eq_(resp.body, resp2.body)

    def test_tms_layer_capabilities(self):
        resp = self.app.get('/tms/1.0.0/wms_cache')
        assert 'WMS Cache Layer' in resp
        xml = resp.lxml
        eq_(xml.xpath('count(//TileSet)'), 19)
    
    def test_tms_root_resource(self):
        resp = self.app.get('/tms')
        resp2 = self.app.get('/tms/')
        assert 'TileMapService' in resp and 'TileMapService' in resp2
        xml = resp.lxml
        eq_(xml.xpath('//TileMapService/@version'),['1.0.0'])

    def test_tms_get_out_of_bounds_tile(self):
        for coord in [(0, 0, -1), (-1, 0, 0), (0, -1, 0), (4, 2, 1), (1, 3, 0)]:
            yield self.check_out_of_bounds, coord
    
    def check_out_of_bounds(self, coord):
        x, y, z = coord
        url = '/tms/1.0.0/wms_cache/%d/%d/%d.jpeg' % (z, x, y)
        resp = self.app.get(url , status=404)
        xml = resp.lxml
        assert ('outside the bounding box' 
                in xml.xpath('/TileMapServerError/Message/text()')[0])
    
    def test_invalid_layer(self):
        resp = self.app.get('/tms/1.0.0/inVAlid/0/0/0.png', status=404)
        xml = resp.lxml
        assert ('unknown layer: inVAlid' 
                in xml.xpath('/TileMapServerError/Message/text()')[0])
    
    def test_invalid_format(self):
        resp = self.app.get('/tms/1.0.0/wms_cache/0/0/1.png', status=404)
        xml = resp.lxml
        assert ('invalid format' 
                 in xml.xpath('/TileMapServerError/Message/text()')[0])
    
    def test_get_tile_tile_source_error(self):
        resp = self.app.get('/tms/1.0.0/wms_cache/0/0/0.jpeg', status=500)
        xml = resp.lxml
        assert ('No response from URL' 
                in xml.xpath('/TileMapServerError/Message/text()')[0])
    
    def test_get_cached_tile(self):
        resp = self.app.get('/tms/1.0.0/wms_cache/0/0/1.jpeg')
        eq_(resp.content_type, 'image/jpeg')
        eq_(resp.content_length, len(resp.body))
        data = StringIO(resp.body)
        assert is_jpeg(data)
    
    def test_get_tile(self):
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fjpeg'
                                      '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A900913&styles='
                                      '&VERSION=1.1.1&BBOX=-20037508.3428,-20037508.3428,0.0,0.0'
                                      '&WIDTH=256'},
                            {'body': img.read(), 'headers': {'content-type': 'image/jpeg'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get('/tms/1.0.0/wms_cache/0/0/0.jpeg')
                eq_(resp.content_type, 'image/jpeg')
                self.created_tiles.append('wms_cache_EPSG900913/01/000/000/000/000/000/000.jpeg')
    
    def test_get_tile_from_cache_with_tile_source(self):
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/tiles/01/000/000/000/000/000/001.png'},
                            {'body': img.read(), 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get('/tms/1.0.0/tms_cache/0/0/1.png')
                eq_(resp.content_type, 'image/png')
                self.created_tiles.append('tms_cache_EPSG900913/01/000/000/000/000/000/001.png')

    def test_get_tile_with_watermark_cache(self):
        with tmp_image((256, 256), format='png', color=(0, 0, 0)) as img:
            expected_req = ({'path': r'/tiles/01/000/000/000/000/000/000.png'},
                             {'body': img.read(), 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get('/tms/1.0.0/watermark_cache/0/0/0.png')
                eq_(resp.content_type, 'image/png')
                img = Image.open(StringIO(resp.body))
                colors = img.getcolors()
                assert len(colors) >= 2
                eq_(sorted(colors)[-1][1], (0, 0, 0))

class TestTileService(SystemTest):
    config = test_config
    
    def test_get_out_of_bounds_tile(self):
        for coord in [(0, 0, -1), (-1, 0, 0), (0, -1, 0), (4, 2, 1), (1, 3, 0)]:
            yield self.check_out_of_bounds, coord
    
    def check_out_of_bounds(self, coord):
        x, y, z = coord
        url = '/tiles/wms_cache/%d/%d/%d.jpeg' % (z, x, y)
        resp = self.app.get(url , status=404)
        assert 'outside the bounding box' in resp
        
    def test_invalid_layer(self):
        resp = self.app.get('/tiles/inVAlid/0/0/0.png', status=404)
        eq_(resp.content_type, 'text/plain')
        assert 'unknown layer: inVAlid' in resp
    
    def test_invalid_format(self):
        resp = self.app.get('/tiles/wms_cache/0/0/1.png', status=404)
        eq_(resp.content_type, 'text/plain')
        assert 'invalid format' in resp
    
    def test_get_tile_tile_source_error(self):
        resp = self.app.get('/tiles/wms_cache/0/0/0.jpeg', status=500)
        eq_(resp.content_type, 'text/plain')
        assert 'No response from URL' in resp
    
    def _check_tile_resp(self, resp):
        eq_(resp.content_type, 'image/jpeg')
        eq_(resp.content_length, len(resp.body))
        data = StringIO(resp.body)
        assert is_jpeg(data)
    
    def _update_timestamp(self):
        timestamp = 1234567890.0
        size = 10214
        base_dir = base_config().cache.base_dir
        os.utime(os.path.join(base_dir,
                              'wms_cache_EPSG900913/01/000/000/000/000/000/001.jpeg'),
                 (timestamp, timestamp))
        max_age = base_config().tiles.expires_hours * 60 * 60
        etag = hashlib.md5(str(timestamp) + str(size)).hexdigest()
        return etag, max_age
    
    def _check_cache_control_headers(self, resp, etag, max_age):
        eq_(resp.headers['ETag'], etag)
        eq_(resp.headers['Last-modified'], 'Fri, 13 Feb 2009 23:31:30 GMT')
        eq_(resp.headers['Cache-control'], 'max-age=%d public' % max_age)
        
    def test_get_cached_tile(self):
        etag, max_age = self._update_timestamp()
        resp = self.app.get('/tiles/wms_cache/1/0/1.jpeg')
        self._check_cache_control_headers(resp, etag, max_age)
        self._check_tile_resp(resp)
        
    def test_get_cached_tile_flipped_y(self):
        etag, max_age = self._update_timestamp()
        resp = self.app.get('/tiles/wms_cache/1/0/0.jpeg?origin=nw')
        self._check_cache_control_headers(resp, etag, max_age)
        self._check_tile_resp(resp)
        
    def test_if_none_match(self):
        etag, max_age = self._update_timestamp()
        resp = self.app.get('/tiles/wms_cache/1/0/1.jpeg',
                            headers={'If-None-Match': etag})
        eq_(resp.status, '304 Not Modified')
        self._check_cache_control_headers(resp, etag, max_age)
    
        resp = self.app.get('/tiles/wms_cache/1/0/1.jpeg',
                            headers={'If-None-Match': etag + 'foo'})
        self._check_cache_control_headers(resp, etag, max_age)
        eq_(resp.status, '200 OK')
        self._check_tile_resp(resp)
    
    def test_if_modified_since(self):
        etag, max_age = self._update_timestamp()
        for date, modified in (
                ('Fri, 15 Feb 2009 23:31:30 GMT', False),
                ('Fri, 13 Feb 2009 23:31:31 GMT', False),
                ('Fri, 13 Feb 2009 23:31:30 GMT', False),
                ('Fri, 13 Feb 2009 23:31:29 GMT', True),
                ('Fri, 11 Feb 2009 23:31:29 GMT', True),
                ('Friday, 13-Feb-09 23:31:30 GMT', False),
                ('Friday, 13-Feb-09 23:31:29 GMT', True),
                ('Fri Feb 13 23:31:30 2009', False),
                ('Fri Feb 13 23:31:29 2009', True),
                # and some invalid ones
                ('Fri Foo 13 23:31:29 2009', True),
                ('1234567890', True),
                ):
            yield self.check_modified_response, date, modified, etag, max_age
    
    def check_modified_response(self, date, modified, etag, max_age):
        resp = self.app.get('/tiles/wms_cache/1/0/1.jpeg', headers={
                            'If-Modified-Since': date})
        self._check_cache_control_headers(resp, etag, max_age)
        if modified:
            eq_(resp.status, '200 OK')
            self._check_tile_resp(resp)
        else:
            eq_(resp.status, '304 Not Modified')
    
    def test_get_tile(self):
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fjpeg'
                                      '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A900913&styles='
                                      '&VERSION=1.1.1&BBOX=-20037508.3428,-20037508.3428,0.0,0.0'
                                      '&WIDTH=256'},
                            {'body': img.read(), 'headers': {'content-type': 'image/jpeg'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get('/tiles/wms_cache/1/0/0.jpeg')
                eq_(resp.content_type, 'image/jpeg')
                self.created_tiles.append('wms_cache_EPSG900913/01/000/000/000/000/000/000.jpeg')
    
########NEW FILE########
__FILENAME__ = test_tms_origin
# This file is part of the MapProxy project.
# Copyright (C) 2010-2012 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
from mapproxy.test.image import is_jpeg
from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config
from nose.tools import eq_

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'tileservice_origin.yaml', with_cache_data=True)

def teardown_module():
    module_teardown(test_config)

class TestTileServicesOrigin(SystemTest):
    config = test_config

    ###
    # tile 0/0/1 is cached, check if we can access it with different URLs

    def test_get_cached_tile_tms(self):
        resp = self.app.get('/tms/1.0.0/wms_cache/0/0/1.jpeg')
        eq_(resp.content_type, 'image/jpeg')
        assert is_jpeg(resp.body)
 
    def test_get_cached_tile_service_origin(self):
        resp = self.app.get('/tiles/wms_cache/1/0/0.jpeg')
        eq_(resp.content_type, 'image/jpeg')
        assert is_jpeg(resp.body)

    def test_get_cached_tile_request_origin(self):
        resp = self.app.get('/tiles/wms_cache/1/0/1.jpeg?origin=sw')
        eq_(resp.content_type, 'image/jpeg')
        assert is_jpeg(resp.body)




########NEW FILE########
__FILENAME__ = test_util_conf
# -:- encoding: utf-8 -:-
# This file is part of the MapProxy project.
# Copyright (C) 2013 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

import os
import shutil
import tempfile
from contextlib import contextmanager

import yaml

from mapproxy.script.conf.app import config_command

from nose.tools import eq_


@contextmanager
def capture():
    import sys
    from cStringIO import StringIO

    # setup the environment
    backup_stdout = sys.stdout
    backup_stderr = sys.stderr

    try:
        sys.stdout = StringIO()
        sys.stderr = StringIO()
        yield sys.stdout, sys.stderr
    except Exception, ex:
        backup_stdout.write(str(ex))
        backup_stdout.write(sys.stdout.getvalue())
        backup_stderr.write(sys.stderr.getvalue())
        raise
    finally:
        sys.stdout = backup_stdout
        sys.stderr = backup_stderr

def filename(name):
    return os.path.join(
        os.path.dirname(__file__),
        'fixture',
        name,
    )

class TestMapProxyConfCmd(object):
    def setup(self):
        self.dir = tempfile.mkdtemp()

    def teardown(self):
        if os.path.exists(self.dir):
            shutil.rmtree(self.dir)

    def tmp_filename(self, name):
        return os.path.join(
            self.dir,
            name,
        )

    def test_cmd_no_args(self):
        with capture() as (stdout, stderr):
            assert config_command(['mapproxy-conf']) == 2

        assert '--capabilities required' in stderr.getvalue()

    def test_stdout_output(self):
        with capture() as (stdout, stderr):
            assert config_command(['mapproxy-conf', '--capabilities', filename('util-conf-wms-111-cap.xml')]) == 0

        assert stdout.getvalue().startswith('# MapProxy configuration')

    def test_test_cap_output_no_base(self):
        with capture() as (stdout, stderr):
            assert config_command(['mapproxy-conf',
                '--capabilities', filename('util-conf-wms-111-cap.xml'),
                '--output', self.tmp_filename('mapproxy.yaml'),
                ]) == 0


        with open(self.tmp_filename('mapproxy.yaml')) as f:
            conf = yaml.load(f)

            assert 'grids' not in conf
            eq_(conf['sources'], {
                'osm_roads_wms': {
                    'supported_srs': ['EPSG:31467', 'EPSG:31466', 'EPSG:25832', 'EPSG:3857', 'EPSG:25831', 'EPSG:25833', 'EPSG:4326', 'EPSG:31468', 'EPSG:900913', 'CRS:84', 'EPSG:4258'],
                    'req': {'layers': 'osm_roads', 'url': 'http://osm.omniscale.net/proxy/service?', 'transparent': True},
                    'type': 'wms',
                    'coverage': {'srs': 'EPSG:4326', 'bbox': [-180.0, -85.0511287798, 180.0, 85.0511287798]}
                },
                'osm_wms': {
                    'supported_srs': ['EPSG:31467', 'EPSG:31466', 'EPSG:25832', 'EPSG:3857', 'EPSG:25831', 'EPSG:25833', 'EPSG:4326', 'EPSG:31468', 'EPSG:900913', 'CRS:84', 'EPSG:4258'],
                    'req': {'layers': 'osm', 'url': 'http://osm.omniscale.net/proxy/service?', 'transparent': True},
                    'type': 'wms',
                    'coverage': {
                        'srs': 'EPSG:4326',
                        'bbox': [-180.0, -85.0511287798, 180.0, 85.0511287798],
                    },
                },
            })

            eq_(conf['layers'], [{
                'title': 'Omniscale OpenStreetMap WMS',
                'layers': [
                    {
                        'name': 'osm',
                        'title': 'OpenStreetMap (complete map)',
                        'sources': ['osm_wms'],
                    },
                    {
                        'name': 'osm_roads',
                        'title': 'OpenStreetMap (streets only)',
                        'sources': ['osm_roads_wms'],
                     },
                ]
            }])
            eq_(len(conf['layers'][0]['layers']), 2)

    def test_test_cap_output(self):
        with capture() as (stdout, stderr):
            assert config_command(['mapproxy-conf',
                '--capabilities', filename('util-conf-wms-111-cap.xml'),
                '--output', self.tmp_filename('mapproxy.yaml'),
                '--base', filename('util-conf-base-grids.yaml'),
                ]) == 0


        with open(self.tmp_filename('mapproxy.yaml')) as f:
            conf = yaml.load(f)

            assert 'grids' not in conf
            eq_(len(conf['sources']), 2)

            eq_(conf['caches'], {
                'osm_cache': {
                    'grids': ['webmercator', 'geodetic'],
                    'sources': ['osm_wms']
                },
                'osm_roads_cache': {
                    'grids': ['webmercator', 'geodetic'],
                    'sources': ['osm_roads_wms']
                },
            })


            eq_(conf['layers'], [{
                'title': 'Omniscale OpenStreetMap WMS',
                'layers': [
                    {
                        'name': 'osm',
                        'title': 'OpenStreetMap (complete map)',
                        'sources': ['osm_cache'],
                    },
                    {
                        'name': 'osm_roads',
                        'title': 'OpenStreetMap (streets only)',
                        'sources': ['osm_roads_cache'],
                    },
                ]
            }])
            eq_(len(conf['layers'][0]['layers']), 2)

    def test_overwrites(self):
        with capture() as (stdout, stderr):
            assert config_command(['mapproxy-conf',
                '--capabilities', filename('util-conf-wms-111-cap.xml'),
                '--output', self.tmp_filename('mapproxy.yaml'),
                '--overwrite', filename('util-conf-overwrite.yaml'),
                '--base', filename('util-conf-base-grids.yaml'),
                ]) == 0


        with open(self.tmp_filename('mapproxy.yaml')) as f:
            conf = yaml.load(f)

            assert 'grids' not in conf
            eq_(len(conf['sources']), 2)

            eq_(conf['sources'], {
                'osm_roads_wms': {
                    'supported_srs': ['EPSG:3857'],
                    'req': {'layers': 'osm_roads', 'url': 'http://osm.omniscale.net/proxy/service?', 'transparent': True, 'param': 42},
                    'type': 'wms',
                    'coverage': {'srs': 'EPSG:4326', 'bbox': [0, 0, 90, 90]}
                },
                'osm_wms': {
                    'supported_srs': ['EPSG:31467', 'EPSG:31466', 'EPSG:25832', 'EPSG:3857', 'EPSG:25831', 'EPSG:25833', 'EPSG:4326', 'EPSG:31468', 'EPSG:900913', 'CRS:84', 'EPSG:4258'],
                    'req': {'layers': 'osm', 'url': 'http://osm.omniscale.net/proxy/service?', 'transparent': True, 'param': 42},
                    'type': 'wms',
                    'coverage': {
                        'srs': 'EPSG:4326',
                        'bbox': [-180.0, -85.0511287798, 180.0, 85.0511287798],
                    },
                },
            })


            eq_(conf['caches'], {
                'osm_cache': {
                    'grids': ['webmercator', 'geodetic'],
                    'sources': ['osm_wms'],
                    'cache': {
                        'type': 'sqlite'
                    },
                },
                'osm_roads_cache': {
                    'grids': ['webmercator'],
                    'sources': ['osm_roads_wms'],
                    'cache': {
                        'type': 'sqlite'
                    },
                },
            })


            eq_(conf['layers'], [{
                'title': 'Omniscale OpenStreetMap WMS',
                'layers': [
                    {
                        'name': 'osm',
                        'title': 'OpenStreetMap (complete map)',
                        'sources': ['osm_cache'],
                    },
                    {
                        'name': 'osm_roads',
                        'title': 'OpenStreetMap (streets only)',
                        'sources': ['osm_roads_cache'],
                     },
                ]
            }])
            eq_(len(conf['layers'][0]['layers']), 2)




########NEW FILE########
__FILENAME__ = test_util_export
# This file is part of the MapProxy project.
# Copyright (C) 2012 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os
import sys
import tempfile
import shutil
import contextlib

from cStringIO import StringIO
from nose.tools import eq_, assert_raises
from mapproxy.script.export import export_command
from mapproxy.test.image import tmp_image
from mapproxy.test.http import mock_httpd

FIXTURE_DIR = os.path.join(os.path.dirname(__file__), 'fixture')

@contextlib.contextmanager
def capture_stderr(io=None):
    if io is None:
        io = StringIO()
    old_stderr = sys.stderr
    sys.stderr = io
    try:
        yield io
    finally:
        sys.stderr = old_stderr


@contextlib.contextmanager
def tile_server(tile_coords):
    with tmp_image((256, 256), format='jpeg') as img:
        img = img.read()
    expected_reqs = []
    for tile in tile_coords:
        expected_reqs.append(
            ({'path': r'/tiles/%d/%d/%d.png' % (tile[2], tile[0], tile[1])},
             {'body': img, 'headers': {'content-type': 'image/png'}}))
    with mock_httpd(('localhost', 42423), expected_reqs, unordered=True):
        yield

class TestUtilExport(object):
    def setup(self):
        self.dir = tempfile.mkdtemp()
        self.dest = os.path.join(self.dir, 'dest')
        self.mapproxy_conf_name = 'mapproxy_export.yaml'
        shutil.copy(os.path.join(FIXTURE_DIR, self.mapproxy_conf_name), self.dir)
        self.mapproxy_conf_file = os.path.join(self.dir, self.mapproxy_conf_name)
        self.args = ['command_dummy', '-f', self.mapproxy_conf_file]

    def teardown(self):
        shutil.rmtree(self.dir)

    def test_config_not_found(self):
        self.args = ['command_dummy', '-f', 'foo.bar']
        with capture_stderr() as err:
            try:
                export_command(self.args)
            except SystemExit, ex:
                assert ex.code != 0
            else:
                assert False, 'export command did not exit'
        assert err.getvalue().startswith("ERROR:")

    def test_no_fetch_missing_tiles(self):
        self.args += ['--grid', 'GLOBAL_MERCATOR', '--dest', self.dest,
            '--levels', '0', '--source', 'tms_cache']
        with capture_stderr():
            export_command(self.args)

        eq_(os.listdir(self.dest), ['tile_locks'])

    def test_fetch_missing_tiles(self):
        self.args += ['--grid', 'GLOBAL_MERCATOR', '--dest', self.dest,
            '--levels', '0,1', '--source', 'tms_cache', '--fetch-missing-tiles']
        with tile_server([(0, 0, 0), (0, 0, 1), (0, 1, 1), (1, 0, 1), (1, 1, 1)]):
            with capture_stderr():
                export_command(self.args)

        assert os.path.exists(os.path.join(self.dest, 'tile_locks'))
        assert os.path.exists(os.path.join(self.dest, '0', '0', '0.png'))
        assert os.path.exists(os.path.join(self.dest, '1', '0', '0.png'))
        assert os.path.exists(os.path.join(self.dest, '1', '0', '1.png'))
        assert os.path.exists(os.path.join(self.dest, '1', '1', '0.png'))
        assert os.path.exists(os.path.join(self.dest, '1', '1', '1.png'))

    def test_force(self):
        self.args += ['--grid', 'GLOBAL_MERCATOR', '--dest', self.dest,
            '--levels', '0', '--source', 'tms_cache']
        with capture_stderr():
            export_command(self.args)

        with capture_stderr():
            assert_raises(SystemExit, export_command, self.args)

        with capture_stderr():
            export_command(self.args + ['--force'])

    def test_invalid_grid_definition(self):
        self.args += ['--grid', 'foo=1', '--dest', self.dest,
            '--levels', '0', '--source', 'tms_cache']
        with capture_stderr() as err:
            assert_raises(SystemExit, export_command, self.args)
            assert 'foo' in err.getvalue()

    def test_custom_grid(self):
        self.args += ['--grid', 'base=GLOBAL_MERCATOR min_res=100000', '--dest', self.dest,
            '--levels', '1', '--source', 'tms_cache', '--fetch-missing-tiles']
        with tile_server([(0, 3, 2), (1, 3, 2), (2, 3, 2), (3, 3, 2),
                          (0, 2, 2), (1, 2, 2), (2, 2, 2), (3, 2, 2),
                          (0, 1, 2), (1, 1, 2), (2, 1, 2), (3, 1, 2),
                          (0, 0, 2), (1, 0, 2), (2, 0, 2), (3, 0, 2)]):
            with capture_stderr():
                export_command(self.args)

        assert os.path.exists(os.path.join(self.dest, 'tile_locks'))
        assert os.path.exists(os.path.join(self.dest, '1', '0', '0.png'))
        assert os.path.exists(os.path.join(self.dest, '1', '3', '3.png'))


    def test_coverage(self):
        self.args += ['--grid', 'GLOBAL_MERCATOR', '--dest', self.dest,
            '--levels', '0..2', '--source', 'tms_cache', '--fetch-missing-tiles',
            '--coverage', '10,10,20,20', '--srs', 'EPSG:4326']
        with tile_server([(0, 0, 0), (1, 1, 1), (2, 2, 2)]):
            with capture_stderr():
                export_command(self.args)

        assert os.path.exists(os.path.join(self.dest, 'tile_locks'))
        assert os.path.exists(os.path.join(self.dest, '0', '0', '0.png'))
        assert os.path.exists(os.path.join(self.dest, '1', '1', '1.png'))
        assert os.path.exists(os.path.join(self.dest, '2', '2', '2.png'))

########NEW FILE########
__FILENAME__ = test_util_grids
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os
import sys
import contextlib

from cStringIO import StringIO
from nose.tools import assert_raises
from mapproxy.script.grids import grids_command

FIXTURE_DIR = os.path.join(os.path.dirname(__file__), 'fixture')
GRID_NAMES = [
    'global_geodetic_sqrt2',
    'grid_full_example',
    'another_grid_full_example'
]
UNUSED_GRID_NAMES = [
    'GLOBAL_GEODETIC',
    'GLOBAL_MERCATOR',
    'GLOBAL_WEBMERCATOR',
]


@contextlib.contextmanager
def capture_stderr(io=None):
    if io is None:
        io = StringIO()
    old_stderr = sys.stderr
    sys.stderr = io
    try:
        yield io
    finally:
        sys.stderr = old_stderr

class TestUtilGrids(object):
    def setup(self):
        self.mapproxy_config_file = os.path.join(FIXTURE_DIR, 'util_grids.yaml')
        self.args = ['command_dummy', '-f', self.mapproxy_config_file]

    def test_config_not_found(self):
        self.args = ['command_dummy', '-f', 'foo.bar']
        with capture_stderr() as err:
            assert_raises(SystemExit, grids_command, self.args)
        assert err.getvalue().startswith("ERROR:")

    def test_list_configured(self):
        self.args.append('-l')
        grids_command(self.args)
        captured_output = sys.stdout.getvalue()
        for grid in GRID_NAMES:
            assert grid in captured_output

        number_of_lines = sum(1 for line in captured_output.split('\n') if line)

        assert number_of_lines == len(GRID_NAMES)

    def test_list_configured_all(self):
        self.args.append('-l')
        self.args.append('--all')
        grids_command(self.args)
        captured_output = sys.stdout.getvalue()
        for grid in GRID_NAMES + UNUSED_GRID_NAMES:
            assert grid in captured_output

        number_of_lines = sum(1 for line in captured_output.split('\n') if line)

        assert number_of_lines == len(UNUSED_GRID_NAMES) + len(GRID_NAMES)

    def test_display_single_grid(self):
        self.args.append('-g')
        self.args.append('GLOBAL_MERCATOR')
        grids_command(self.args)
        captured_output = sys.stdout.getvalue()
        assert "GLOBAL_MERCATOR" in captured_output

    def test_ignore_case(self):
        self.args.append('-g')
        self.args.append('global_geodetic')
        grids_command(self.args)
        captured_output = sys.stdout.getvalue()
        assert "GLOBAL_GEODETIC" in captured_output

    def test_all_grids(self):
        grids_command(self.args)
        captured_output = sys.stdout.getvalue()
        assert "GLOBAL_MERCATOR" in captured_output
        assert "origin*: 'll'" in captured_output



########NEW FILE########
__FILENAME__ = test_util_wms_capabilities
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os
import sys
import contextlib

from cStringIO import StringIO
from nose.tools import assert_raises

from mapproxy.client.http import HTTPClient
from mapproxy.script.wms_capabilities import wms_capabilities_command
from mapproxy.test.http import mock_httpd

TESTSERVER_ADDRESS = ('127.0.0.1', 56413)
TESTSERVER_URL = 'http://%s:%s' % TESTSERVER_ADDRESS
CAPABILITIES111_FILE = os.path.join(os.path.dirname(__file__), 'fixture', 'util_wms_capabilities111.xml')
CAPABILITIES130_FILE = os.path.join(os.path.dirname(__file__), 'fixture', 'util_wms_capabilities130.xml')
SERVICE_EXCEPTION_FILE = os.path.join(os.path.dirname(__file__), 'fixture', 'util_wms_capabilities_service_exception.xml')


@contextlib.contextmanager
def capture_out():
    old_stdout = sys.stdout
    old_stderr = sys.stderr
    try:
        sys.stdout = StringIO()
        sys.stderr = StringIO()
        yield sys.stdout, sys.stderr
    except:
        old_stderr.write(sys.stderr.getvalue())
        old_stdout.write(sys.stdout.getvalue())
        raise
    finally:
        sys.stdout = old_stdout
        sys.stderr = old_stderr

class TestUtilWMSCapabilities(object):
    def setup(self):
        self.client = HTTPClient()
        self.args = ['command_dummy', '--host', TESTSERVER_URL + '/service']

    def test_http_error(self):
        self.args = ['command_dummy', '--host', 'http://foo.bar']
        with capture_out() as (out,err):
            assert_raises(SystemExit, wms_capabilities_command, self.args)
        assert err.getvalue().startswith("ERROR:")

        self.args[2] = '/no/valid/url'
        with capture_out() as (out,err):
            assert_raises(SystemExit, wms_capabilities_command, self.args)
        assert err.getvalue().startswith("ERROR:")

    def test_request_not_parsable(self):
        with mock_httpd(TESTSERVER_ADDRESS, [({'path': '/service?request=GetCapabilities&version=1.1.1&service=WMS', 'method': 'GET'},
                                              {'status': '200', 'body': ''})]):
            with capture_out() as (out,err):
                assert_raises(SystemExit, wms_capabilities_command, self.args)
            error_msg = err.getvalue().rsplit('-'*80, 1)[1].strip()
            assert error_msg.startswith('Could not parse the document')

    def test_service_exception(self):
        self.args = ['command_dummy', '--host', TESTSERVER_URL + '/service?request=GetCapabilities']
        with open(SERVICE_EXCEPTION_FILE, 'r') as fp:
            capabilities_doc = fp.read()
            with mock_httpd(TESTSERVER_ADDRESS, [({'path': '/service?request=GetCapabilities&version=1.1.1&service=WMS', 'method': 'GET'},
                                                  {'status': '200', 'body': capabilities_doc})]):
                with capture_out() as (out,err):
                    assert_raises(SystemExit, wms_capabilities_command, self.args)
                error_msg = err.getvalue().rsplit('-'*80, 1)[1].strip()
                assert 'Not a capabilities document' in error_msg

    def test_parse_capabilities(self):
        self.args = ['command_dummy', '--host', TESTSERVER_URL + '/service?request=GetCapabilities', '--version', '1.1.1']
        with open(CAPABILITIES111_FILE, 'r') as fp:
            capabilities_doc = fp.read()
            with mock_httpd(TESTSERVER_ADDRESS, [({'path': '/service?request=GetCapabilities&version=1.1.1&service=WMS', 'method': 'GET'},
                                                  {'status': '200', 'body': capabilities_doc})]):
                with capture_out() as (out,err):
                    wms_capabilities_command(self.args)
                lines = out.getvalue().split('\n')
                assert lines[1].startswith('Capabilities Document Version 1.1.1')

    def test_parse_130capabilities(self):
        self.args = ['command_dummy', '--host', TESTSERVER_URL + '/service?request=GetCapabilities', '--version', '1.3.0']
        with open(CAPABILITIES130_FILE, 'r') as fp:
            capabilities_doc = fp.read()
            with mock_httpd(TESTSERVER_ADDRESS, [({'path': '/service?request=GetCapabilities&version=1.3.0&service=WMS', 'method': 'GET'},
                                                  {'status': '200', 'body': capabilities_doc})]):
                with capture_out() as (out,err):
                    wms_capabilities_command(self.args)
                lines = out.getvalue().split('\n')
                assert lines[1].startswith('Capabilities Document Version 1.3.0')

    def test_key_error(self):
        self.args = ['command_dummy', '--host', TESTSERVER_URL + '/service?request=GetCapabilities']
        with open(CAPABILITIES111_FILE, 'r') as fp:
            capabilities_doc = fp.read()
            capabilities_doc = capabilities_doc.replace('minx', 'foo')
            with mock_httpd(TESTSERVER_ADDRESS, [({'path': '/service?request=GetCapabilities&version=1.1.1&service=WMS', 'method': 'GET'},
                                                  {'status': '200', 'body': capabilities_doc})]):
                with capture_out() as (out,err):
                    assert_raises(SystemExit, wms_capabilities_command, self.args)

                assert err.getvalue().startswith('XML-Element has no such attribute')


########NEW FILE########
__FILENAME__ = test_watermark
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

from cStringIO import StringIO

from mapproxy.platform.image import Image
from mapproxy.request.wms import WMS111MapRequest
from mapproxy.test.http import mock_httpd
from mapproxy.test.image import tmp_image
from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config

from nose.tools import eq_

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'watermark.yaml', with_cache_data=True)

def teardown_module():
    module_teardown(test_config)

class WatermarkTest(SystemTest):
    config = test_config
    def setup(self):
        SystemTest.setup(self)
        self.common_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS', 
             version='1.1.1', bbox='-180,0,0,80', width='200', height='200',
             layers='watermark', srs='EPSG:4326', format='image/png',
             styles='', request='GetMap'))
        
    def test_watermark_tile(self):
        with tmp_image((256, 256), format='png', color=(0, 0, 0)) as img:
            expected_req = ({'path': r'/service?LAYERs=blank&SERVICE=WMS&FORMAT=image%2Fpng'
                                       '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A4326&styles='
                                       '&VERSION=1.1.1&BBOX=-180.0,-90.0,0.0,90.0'
                                       '&WIDTH=256'},
                             {'body': img.read(), 'headers': {'content-type': 'image/jpeg'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get('/tms/1.0.0/watermark/EPSG4326/0/0/0.png')
                eq_(resp.content_type, 'image/png')
                img = Image.open(StringIO(resp.body))
                colors = img.getcolors()
                assert len(colors) >= 2
                eq_(sorted(colors)[-1][1], (0, 0, 0))

    def test_transparent_watermark_tile(self):
        with tmp_image((256, 256), format='png', color=(0, 0, 0, 0), mode='RGBA') as img:
            expected_req = ({'path': r'/service?LAYERs=blank&SERVICE=WMS&FORMAT=image%2Fpng'
                                       '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A4326&styles='
                                       '&VERSION=1.1.1&BBOX=-180.0,-90.0,0.0,90.0'
                                       '&WIDTH=256'},
                             {'body': img.read(), 'headers': {'content-type': 'image/jpeg'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                resp = self.app.get('/tms/1.0.0/watermark_transp/EPSG4326/0/0/0.png')
                eq_(resp.content_type, 'image/png')
                img = Image.open(StringIO(resp.body))
                colors = img.getcolors()
                assert len(colors) >= 2
                eq_(sorted(colors)[-1][1], (0, 0, 0, 0))

########NEW FILE########
__FILENAME__ = test_wms
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division
import os
import re
import sys
import shutil
from mapproxy.platform.image import Image
import functools

from cStringIO import StringIO
from mapproxy.srs import SRS
from mapproxy.request.wms import WMS100MapRequest, WMS111MapRequest, WMS130MapRequest, \
                                 WMS111FeatureInfoRequest, WMS111CapabilitiesRequest, \
                                 WMS130CapabilitiesRequest, WMS100CapabilitiesRequest, \
                                 WMS100FeatureInfoRequest, WMS130FeatureInfoRequest, \
                                 WMS110MapRequest, WMS110FeatureInfoRequest, \
                                 WMS110CapabilitiesRequest, \
                                 wms_request
from mapproxy.test.image import is_jpeg, is_png, tmp_image, create_tmp_image
from mapproxy.test.http import mock_httpd
from mapproxy.test.helper import validate_with_dtd, validate_with_xsd
from nose.tools import eq_, assert_almost_equal

from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'layer.yaml', with_cache_data=True)

def teardown_module():
    module_teardown(test_config)

def test_invalid_url():
    test_config['app'].get('/invalid?fop', status=404)

def is_100_capa(xml):
    return validate_with_dtd(xml, dtd_name='wms/1.0.0/capabilities_1_0_0.dtd')

def is_110_capa(xml):
    return validate_with_dtd(xml, dtd_name='wms/1.1.0/capabilities_1_1_0.dtd')

def is_111_exception(xml, msg=None, code=None, re_msg=None):
    eq_(xml.xpath('/ServiceExceptionReport/@version')[0], '1.1.1')
    if msg:
        eq_(xml.xpath('//ServiceException/text()')[0], msg)
    if re_msg:
        exception_msg = xml.xpath('//ServiceException/text()')[0]
        assert re.findall(re_msg, exception_msg, re.I), "'%r' does not match '%s'" % (
            re_msg, exception_msg)
    if code is not None:
        eq_(xml.xpath('/ServiceExceptionReport/ServiceException/@code')[0], code)
    assert validate_with_dtd(xml, 'wms/1.1.1/exception_1_1_1.dtd')

def is_111_capa(xml):
    return validate_with_dtd(xml, dtd_name='wms/1.1.1/WMS_MS_Capabilities.dtd')
def is_130_capa(xml):
    return validate_with_xsd(xml, xsd_name='wms/1.3.0/capabilities_1_3_0.xsd')


class WMSTest(SystemTest):
    config = test_config

class TestCoverageWMS(WMSTest):

    def test_unknown_version_110(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetCapabilities'
                            '&VERSION=1.1.0')
        assert is_110_capa(resp.lxml)
    def test_unknown_version_113(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetCapabilities'
                            '&VERSION=1.1.3')
        assert is_111_capa(resp.lxml)
    def test_unknown_version_090(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetCapabilities'
                            '&WMTVER=0.9.0')
        assert is_100_capa(resp.lxml)
    def test_unknown_version_200(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetCapabilities'
                            '&VERSION=2.0.0')
        assert is_130_capa(resp.lxml)

def bbox_srs_from_boundingbox(bbox_elem):
    return bbox_elem.attrib['SRS'], [
        float(bbox_elem.attrib['minx']),
        float(bbox_elem.attrib['miny']),
        float(bbox_elem.attrib['maxx']),
        float(bbox_elem.attrib['maxy']),
    ]

class TestWMS111(WMSTest):
    def setup(self):
        WMSTest.setup(self)
        self.common_req = WMS111MapRequest(url='/service?', param=dict(service='WMS',
             version='1.1.1'))
        self.common_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS',
             version='1.1.1', bbox='-180,0,0,80', width='200', height='200',
             layers='wms_cache', srs='EPSG:4326', format='image/png',
             styles='', request='GetMap'))
        self.common_fi_req = WMS111FeatureInfoRequest(url='/service?',
            param=dict(x='10', y='20', width='200', height='200', layers='wms_cache',
                       format='image/png', query_layers='wms_cache', styles='',
                       bbox='1000,400,2000,1400', srs='EPSG:900913'))

    def test_invalid_request_type(self):
        req = str(self.common_map_req).replace('GetMap', 'invalid')
        resp = self.app.get(req)
        is_111_exception(resp.lxml, "unknown WMS request type 'invalid'")

    def test_wms_capabilities(self):
        req = WMS111CapabilitiesRequest(url='/service?').copy_with_request_params(self.common_req)
        resp = self.app.get(req)
        eq_(resp.content_type, 'application/vnd.ogc.wms_xml')
        xml = resp.lxml
        eq_(xml.xpath('//GetMap//OnlineResource/@xlink:href',
                      namespaces=dict(xlink="http://www.w3.org/1999/xlink"))[0],
            'http://localhost/service?')

        # test for MetadataURL
        eq_(xml.xpath('//Layer/MetadataURL/OnlineResource/@xlink:href',
                namespaces=dict(xlink="http://www.w3.org/1999/xlink"))[0],
            'http://some.url/')
        eq_(xml.xpath('//Layer/MetadataURL/@type')[0],
            'TC211')

        layer_names = set(xml.xpath('//Layer/Layer/Name/text()'))
        expected_names = set(['direct_fwd_params', 'direct', 'wms_cache',
            'wms_cache_100', 'wms_cache_130', 'wms_cache_transparent',
            'wms_merge', 'tms_cache', 'wms_cache_multi',
            'wms_cache_link_single', 'wms_cache_110', 'watermark_cache'])
        eq_(layer_names, expected_names)
        eq_(set(xml.xpath('//Layer/Layer[3]/Abstract/text()')),
            set(['Some abstract']))

        bboxs = xml.xpath('//Layer/Layer[1]/BoundingBox')
        eq_(bbox_srs_from_boundingbox(bboxs[0]),
            ('EPSG:31467', [2750000, 5000000, 4250000, 6500000]))
        eq_(bbox_srs_from_boundingbox(bboxs[1]),
            ('EPSG:3857', [-20037508.3428, -15538711.0963, 18924313.4349, 15538711.0963]))
        eq_(bbox_srs_from_boundingbox(bboxs[2]),
            ('EPSG:4326', [-180.0, -80.0, 170.0, 80.0]))

        assert validate_with_dtd(xml, dtd_name='wms/1.1.1/WMS_MS_Capabilities.dtd')

    def test_invalid_layer(self):
        self.common_map_req.params['layers'] = 'invalid'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        is_111_exception(resp.lxml, 'unknown layer: invalid', 'LayerNotDefined')

    def test_invalid_layer_img_exception(self):
        self.common_map_req.params['layers'] = 'invalid'
        self.common_map_req.params['exceptions'] = 'application/vnd.ogc.se_inimage'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        assert is_png(StringIO(resp.body))

    def test_invalid_format(self):
        self.common_map_req.params['format'] = 'image/ascii'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        is_111_exception(resp.lxml, 'unsupported image format: image/ascii',
                         'InvalidFormat')

    def test_invalid_format_img_exception(self):
        self.common_map_req.params['format'] = 'image/ascii'
        self.common_map_req.params['exceptions'] = 'application/vnd.ogc.se_inimage'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        assert is_png(StringIO(resp.body))

    def test_invalid_format_options_img_exception(self):
        self.common_map_req.params['format'] = 'image/png; mode=12bit'
        self.common_map_req.params['exceptions'] = 'application/vnd.ogc.se_inimage'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        assert is_png(StringIO(resp.body))

    def test_missing_format_img_exception(self):
        del self.common_map_req.params['format']
        self.common_map_req.params['exceptions'] = 'application/vnd.ogc.se_inimage'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        assert is_png(StringIO(resp.body))

    def test_invalid_srs(self):
        self.common_map_req.params['srs'] = 'EPSG:1234'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        is_111_exception(resp.lxml, 'unsupported srs: EPSG:1234', 'InvalidSRS')

    def test_get_map_unknown_style(self):
        self.common_map_req.params['styles'] = 'unknown'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        is_111_exception(resp.lxml, 'unsupported styles: unknown', 'StyleNotDefined')

    def test_get_map_too_large(self):
        self.common_map_req.params.size = (5000, 5000)
        self.common_map_req.params['exceptions'] = 'application/vnd.ogc.se_inimage'
        resp = self.app.get(self.common_map_req)
        # is xml, even if inimage was requested
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        is_111_exception(resp.lxml, 'image size too large')

    def test_get_map_default_style(self):
        self.common_map_req.params['styles'] = 'default'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        data = StringIO(resp.body)
        assert is_png(data)
        assert Image.open(data).mode == 'RGB'

    def test_get_map_png(self):
        resp = self.app.get(self.common_map_req)
        assert 'Cache-Control' not in resp.headers
        eq_(resp.content_type, 'image/png')
        data = StringIO(resp.body)
        assert is_png(data)
        assert Image.open(data).mode == 'RGB'

    def test_get_map_png8_custom_format(self):
        self.common_map_req.params['layers'] = 'wms_cache'
        self.common_map_req.params['format'] = 'image/png; mode=8bit'
        resp = self.app.get(self.common_map_req)
        eq_(resp.headers['Content-type'], 'image/png; mode=8bit')
        data = StringIO(resp.body)
        assert is_png(data)
        img = Image.open(data)
        eq_(img.mode, 'P')

    def test_get_map_png_transparent_non_transparent_data(self):
        self.common_map_req.params['transparent'] = 'True'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        data = StringIO(resp.body)
        assert is_png(data)
        img = Image.open(data)
        eq_(img.mode, 'RGB')

    def test_get_map_png_transparent(self):
        self.common_map_req.params['layers'] = 'wms_cache_transparent'
        self.common_map_req.params['transparent'] = 'True'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        data = StringIO(resp.body)
        assert is_png(data)
        assert Image.open(data).mode == 'RGBA'

    def test_get_map_png_w_default_bgcolor(self):
        self.common_map_req.params['layers'] = 'wms_cache_transparent'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        data = StringIO(resp.body)
        assert is_png(data)
        img = Image.open(data)
        eq_(img.mode, 'RGB')
        eq_(img.getcolors()[0][1], (255, 255, 255))

    def test_get_map_png_w_bgcolor(self):
        self.common_map_req.params['layers'] = 'wms_cache_transparent'
        self.common_map_req.params['bgcolor'] = '0xff00a0'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        data = StringIO(resp.body)
        assert is_png(data)
        img = Image.open(data)
        eq_(img.mode, 'RGB')
        eq_(sorted(img.getcolors())[-1][1], (255, 0, 160))

    def test_get_map_jpeg(self):
        self.common_map_req.params['format'] = 'image/jpeg'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/jpeg')
        assert is_jpeg(StringIO(resp.body))

    def test_get_map_xml_exception(self):
        self.common_map_req.params['bbox'] = '0,0,90,90'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        xml = resp.lxml
        eq_(xml.xpath('/ServiceExceptionReport/ServiceException/@code'), [])
        assert 'No response from URL' in xml.xpath('//ServiceException/text()')[0]
        assert validate_with_dtd(xml, 'wms/1.1.1/exception_1_1_1.dtd')

    def test_direct_layer_error(self):
        self.common_map_req.params['layers'] = 'direct'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        xml = resp.lxml
        eq_(xml.xpath('/ServiceExceptionReport/ServiceException/@code'), [])
        # TODO hide error
        # assert 'unable to get map for layers: direct' in \
        #     xml.xpath('//ServiceException/text()')[0]
        assert 'No response from URL' in \
             xml.xpath('//ServiceException/text()')[0]

        assert validate_with_dtd(xml, 'wms/1.1.1/exception_1_1_1.dtd')

    def test_direct_layer_non_image_response(self):
        self.common_map_req.params['layers'] = 'direct'
        expected_req = ({'path': r'/service?LAYERs=bar&SERVICE=WMS&FORMAT=image%2Fpng'
                          '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326&styles='
                          '&VERSION=1.1.1&BBOX=-180.0,0.0,0.0,80.0'
                          '&WIDTH=200'},
                            {'body': 'notanimage', 'headers': {'content-type': 'image/jpeg'}})
        with mock_httpd(('localhost', 42423), [expected_req]):
            resp = self.app.get(self.common_map_req)
            eq_(resp.content_type, 'application/vnd.ogc.se_xml')
            xml = resp.lxml
            eq_(xml.xpath('/ServiceExceptionReport/ServiceException/@code'), [])
            assert 'error while processing image file' in \
                 xml.xpath('//ServiceException/text()')[0]

            assert validate_with_dtd(xml, 'wms/1.1.1/exception_1_1_1.dtd')

    def test_get_map(self):
        # check custom tile lock directory
        tiles_lock_dir = os.path.join(test_config['base_dir'], 'wmscachetilelockdir')
        # make sure custom tile_lock_dir was not created by other tests
        shutil.rmtree(tiles_lock_dir, ignore_errors=True)
        assert not os.path.exists(tiles_lock_dir)

        self.created_tiles.append('wms_cache_EPSG900913/01/000/000/001/000/000/001.jpeg')
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fjpeg'
                                      '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A900913&styles='
                                      '&VERSION=1.1.1&BBOX=0.0,0.0,20037508.3428,20037508.3428'
                                      '&WIDTH=256'},
                            {'body': img.read(), 'headers': {'content-type': 'image/jpeg'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                self.common_map_req.params['bbox'] = '0,0,180,90'
                resp = self.app.get(self.common_map_req)
                assert 35000 < int(resp.headers['Content-length']) < 75000
                eq_(resp.content_type, 'image/png')

        # check custom tile_lock_dir
        assert os.path.exists(tiles_lock_dir)

    def test_get_map_non_image_response(self):
        self.created_tiles.append('wms_cache_EPSG900913/01/000/000/001/000/000/001.jpeg')
        expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fjpeg'
                                  '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A900913&styles='
                                  '&VERSION=1.1.1&BBOX=0.0,0.0,20037508.3428,20037508.3428'
                                  '&WIDTH=256'},
                        {'body': 'notanimage', 'headers': {'content-type': 'image/jpeg'}})
        with mock_httpd(('localhost', 42423), [expected_req]):
            self.common_map_req.params['bbox'] = '0,0,180,90'
            resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        xml = resp.lxml
        print resp.body
        eq_(xml.xpath('/ServiceExceptionReport/ServiceException/@code'), [])
        assert 'unable to transform image: cannot identify image file' in \
             xml.xpath('//ServiceException/text()')[0]

        assert validate_with_dtd(xml, 'wms/1.1.1/exception_1_1_1.dtd')

    def test_get_map_direct_fwd_params_layer(self):
        img = create_tmp_image((200, 200), format='png')
        expected_req = ({'path': r'/service?LAYERs=bar&SERVICE=WMS&FORMAT=image%2Fpng'
                                    '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326&styles='
                                    '&VERSION=1.1.1&BBOX=-180.0,0.0,0.0,80.0'
                                    '&WIDTH=200&TIME=20041012'},
                        {'body': img})
        with mock_httpd(('localhost', 42423), [expected_req]):
            self.common_map_req.params['layers'] = 'direct_fwd_params'
            self.common_map_req.params['time'] = '20041012'
            resp = self.app.get(self.common_map_req)
            eq_(resp.content_type, 'image/png')

    def test_get_map_use_direct_from_level(self):
        with tmp_image((200, 200), format='png') as img:
            expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fpng'
                                      '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A4326&styles='
                                      '&VERSION=1.1.1&BBOX=5.0,-10.0,6.0,-9.0'
                                      '&WIDTH=200'},
                            {'body': img.read(), 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                self.common_map_req.params['bbox'] = '5,-10,6,-9'
                resp = self.app.get(self.common_map_req)
                img.seek(0)
                assert resp.body == img.read()
                is_png(img)
                eq_(resp.content_type, 'image/png')

    def test_get_map_use_direct_from_level_with_transform(self):
        with tmp_image((200, 200), format='png') as img:
            expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fpng'
                                      '&REQUEST=GetMap&HEIGHT=200&SRS=EPSG%3A900913&styles='
                                      '&VERSION=1.1.1&BBOX=908822.944624,7004479.85652,920282.144964,7014491.63726'
                                      '&WIDTH=229'},
                            {'body': img.read(), 'headers': {'content-type': 'image/png'}})
            with mock_httpd(('localhost', 42423), [expected_req], bbox_aware_query_comparator=True):
                self.common_map_req.params['bbox'] = '444122.311736,5885498.04243,450943.508884,5891425.10484'
                self.common_map_req.params['srs'] = 'EPSG:25832'
                resp = self.app.get(self.common_map_req)
                img.seek(0)
                assert resp.body != img.read()
                is_png(img)
                eq_(resp.content_type, 'image/png')

    def test_get_map_invalid_bbox(self):
        # min x larger than max x
        url =  """/service?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&BBOX=7,2,-9,10&SRS=EPSG:4326&WIDTH=164&HEIGHT=388&LAYERS=wms_cache&STYLES=&FORMAT=image/png&TRANSPARENT=TRUE"""
        resp = self.app.get(url)
        is_111_exception(resp.lxml, 'invalid bbox 7,2,-9,10')

    def test_get_map_invalid_bbox2(self):
        # broken bbox for the requested srs
        url =  """/service?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&BBOX=-72988843.697212,-255661507.634227,142741550.188860,255661507.634227&SRS=EPSG:25833&WIDTH=164&HEIGHT=388&LAYERS=wms_cache_100&STYLES=&FORMAT=image/png&TRANSPARENT=TRUE"""
        resp = self.app.get(url)
        is_111_exception(resp.lxml, 'Request too large or invalid BBOX.')

    def test_get_map_broken_bbox(self):
        url = """/service?VERSION=1.1.11&REQUEST=GetMap&SRS=EPSG:31468&BBOX=-10000855.0573254,2847125.18913603,-9329367.42767611,4239924.78564583&WIDTH=130&HEIGHT=62&LAYERS=wms_cache&STYLES=&FORMAT=image/png&TRANSPARENT=TRUE"""
        resp = self.app.get(url)
        is_111_exception(resp.lxml, 'Could not transform BBOX: Invalid result.')

    def test_get_map100(self):
        # check global tile lock directory
        tiles_lock_dir = os.path.join(test_config['base_dir'], 'defaulttilelockdir')
        # make sure global tile_lock_dir was ot created by other tests
        shutil.rmtree(tiles_lock_dir, ignore_errors=True)
        assert not os.path.exists(tiles_lock_dir)

        self.created_tiles.append('wms_cache_100_EPSG900913/01/000/000/001/000/000/001.jpeg')
        # request_format tiff, cache format jpeg, wms request in png
        with tmp_image((256, 256), format='tiff') as img:
            expected_req = ({'path': r'/service?LAYERs=foo,bar&FORMAT=image%2Ftiff'
                                      '&REQUEST=map&HEIGHT=256&SRS=EPSG%3A900913&styles='
                                      '&WMTVER=1.0.0&BBOX=0.0,0.0,20037508.3428,20037508.3428'
                                      '&WIDTH=256'},
                            {'body': img.read(), 'headers': {'content-type': 'image/tiff'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                self.common_map_req.params['bbox'] = '0,0,180,90'
                self.common_map_req.params['layers'] = 'wms_cache_100'
                resp = self.app.get(self.common_map_req)
                eq_(resp.content_type, 'image/png')

        # check global tile lock directory was created
        assert os.path.exists(tiles_lock_dir)

    def test_get_map130(self):
        self.created_tiles.append('wms_cache_130_EPSG900913/01/000/000/001/000/000/001.jpeg')
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fjpeg'
                                      '&REQUEST=GetMap&HEIGHT=256&CRS=EPSG%3A900913&styles='
                                      '&VERSION=1.3.0&BBOX=0.0,0.0,20037508.3428,20037508.3428'
                                      '&WIDTH=256'},
                            {'body': img.read(), 'headers': {'content-type': 'image/jpeg'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                self.common_map_req.params['bbox'] = '0,0,180,90'
                self.common_map_req.params['layers'] = 'wms_cache_130'
                resp = self.app.get(self.common_map_req)
                eq_(resp.content_type, 'image/png')

    def test_get_map130_axis_order(self):
        self.created_tiles.append('wms_cache_multi_EPSG4326/02/000/000/003/000/000/001.jpeg')
        with tmp_image((256, 256), format='jpeg') as img:
            img = img.read()
            expected_reqs = [({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fjpeg'
                                      '&REQUEST=GetMap&HEIGHT=256&CRS=EPSG%3A4326&styles='
                                      '&VERSION=1.3.0&BBOX=0.0,90.0,90.0,180.0'
                                      '&WIDTH=256'},
                            {'body': img, 'headers': {'content-type': 'image/jpeg'}}),]
            with mock_httpd(('localhost', 42423), expected_reqs):
                self.common_map_req.params['bbox'] = '90,0,180,90'
                self.common_map_req.params['layers'] = 'wms_cache_multi'
                resp = self.app.get(self.common_map_req)
                eq_(resp.content_type, 'image/png')

    def test_get_featureinfo(self):
        expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetFeatureInfo&HEIGHT=200&SRS=EPSG%3A900913'
                                  '&VERSION=1.1.1&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                  '&WIDTH=200&QUERY_LAYERS=foo,bar&X=10&Y=20&feature_count=100'},
                        {'body': 'info', 'headers': {'content-type': 'text/plain'}})
        with mock_httpd(('localhost', 42423), [expected_req]):
            self.common_fi_req.params['feature_count'] = 100
            resp = self.app.get(self.common_fi_req)
            eq_(resp.content_type, 'text/plain')
            eq_(resp.body, 'info')

    def test_get_featureinfo_transformed(self):
        expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetFeatureInfo&HEIGHT=200&SRS=EPSG%3A900913'
                                  '&BBOX=5197367.93088,5312902.73895,5311885.44223,5434731.78213'
                                  '&styles=&VERSION=1.1.1'
                                  '&WIDTH=200&QUERY_LAYERS=foo,bar&X=14&Y=78'},
                        {'body': 'info', 'headers': {'content-type': 'text/plain'}})

        # out fi point at x=10,y=20
        p_25832  = (3570269+10*(3643458 - 3570269)/200, 5540889+20*(5614078 - 5540889)/200)
        # the transformed fi point at x=10,y=22
        p_900913 = (5197367.93088+14*(5311885.44223 - 5197367.93088)/200,
                    5312902.73895+78*(5434731.78213 - 5312902.73895)/200)

        # are they the same?
        # check with tolerance: pixel resolution is ~570 and x/y position is rounded to pizel
        assert abs(SRS(25832).transform_to(SRS(900913), p_25832)[0] - p_900913[0]) < 570/2
        assert abs(SRS(25832).transform_to(SRS(900913), p_25832)[1] - p_900913[1]) < 570/2

        with mock_httpd(('localhost', 42423), [expected_req], bbox_aware_query_comparator=True):
            self.common_fi_req.params['bbox'] = '3570269,5540889,3643458,5614078'
            self.common_fi_req.params['srs'] = 'EPSG:25832'
            self.common_fi_req.params.pos = 10, 20
            resp = self.app.get(self.common_fi_req)
            eq_(resp.content_type, 'text/plain')
            eq_(resp.body, 'info')

    def test_get_featureinfo_info_format(self):
        expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetFeatureInfo&HEIGHT=200&SRS=EPSG%3A900913'
                                  '&VERSION=1.1.1&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                  '&WIDTH=200&QUERY_LAYERS=foo,bar&X=10&Y=20'
                                  '&info_format=text%2Fhtml'},
                        {'body': 'info', 'headers': {'content-type': 'text/html'}})
        with mock_httpd(('localhost', 42423), [expected_req]):
            self.common_fi_req.params['info_format'] = 'text/html'
            resp = self.app.get(self.common_fi_req)
            eq_(resp.content_type, 'text/html')
            eq_(resp.body, 'info')

    def test_get_featureinfo_130(self):
        expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetFeatureInfo&HEIGHT=200&CRS=EPSG%3A900913'
                                  '&VERSION=1.3.0&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                  '&WIDTH=200&QUERY_LAYERS=foo,bar&I=10&J=20'},
                        {'body': 'info', 'headers': {'content-type': 'text/plain'}})
        with mock_httpd(('localhost', 42423), [expected_req]):
            self.common_fi_req.params['layers'] = 'wms_cache_130'
            self.common_fi_req.params['query_layers'] = 'wms_cache_130'
            resp = self.app.get(self.common_fi_req)
            eq_(resp.content_type, 'text/plain')
            eq_(resp.body, 'info')

    def test_get_featureinfo_missing_params(self):
        expected_req = (
            {'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fpng'
                      '&REQUEST=GetFeatureInfo&HEIGHT=200&SRS=EPSG%3A900913'
                      '&VERSION=1.1.1&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                      '&WIDTH=200&QUERY_LAYERS=foo,bar&X=10&Y=20'},
            {'body': 'info', 'headers': {'content-type': 'text/plain'}})
        with mock_httpd(('localhost', 42423), [expected_req]):
            del self.common_fi_req.params['format']
            del self.common_fi_req.params['styles']
            resp = self.app.get(self.common_fi_req)
            eq_(resp.content_type, 'text/plain')
            eq_(resp.body, 'info')

    def test_get_featureinfo_missing_params_strict(self):
        request_parser = self.app.app.handlers['service'].services['wms'].request_parser
        try:
            self.app.app.handlers['service'].services['wms'].request_parser = \
                functools.partial(wms_request, strict=True)

            del self.common_fi_req.params['format']
            del self.common_fi_req.params['styles']
            resp = self.app.get(self.common_fi_req)
            xml = resp.lxml
            assert 'missing parameters' in xml.xpath('//ServiceException/text()')[0]
            assert validate_with_dtd(xml, 'wms/1.1.1/exception_1_1_1.dtd')
        finally:
            self.app.app.handlers['service'].services['wms'].request_parser = request_parser
            self.app.app.handlers['service'].request_parser = request_parser

    def test_get_featureinfo_not_queryable(self):
        self.common_fi_req.params['query_layers'] = 'tms_cache'
        self.common_fi_req.params['exceptions'] = 'application/vnd.ogc.se_xml'
        resp = self.app.get(self.common_fi_req)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        xml = resp.lxml
        eq_(xml.xpath('/ServiceExceptionReport/ServiceException/@code'), [])
        assert 'tms_cache is not queryable' in xml.xpath('//ServiceException/text()')[0]
        assert validate_with_dtd(xml, 'wms/1.1.1/exception_1_1_1.dtd')


class TestWMS110(WMSTest):
    def setup(self):
        WMSTest.setup(self)
        self.common_req = WMS110MapRequest(url='/service?', param=dict(service='WMS',
             version='1.1.0'))
        self.common_map_req = WMS110MapRequest(url='/service?', param=dict(service='WMS',
             version='1.1.0', bbox='-180,0,0,80', width='200', height='200',
             layers='wms_cache', srs='EPSG:4326', format='image/png',
             styles='', request='GetMap'))
        self.common_fi_req = WMS110FeatureInfoRequest(url='/service?',
            param=dict(x='10', y='20', width='200', height='200', layers='wms_cache',
                       format='image/png', query_layers='wms_cache_110', styles='',
                       bbox='1000,400,2000,1400', srs='EPSG:900913'))

    def test_wms_capabilities(self):
        req = WMS110CapabilitiesRequest(url='/service?').copy_with_request_params(self.common_req)
        resp = self.app.get(req)
        eq_(resp.content_type, 'application/vnd.ogc.wms_xml')
        xml = resp.lxml
        eq_(xml.xpath('//GetMap//OnlineResource/@xlink:href',
                      namespaces=dict(xlink="http://www.w3.org/1999/xlink"))[0],
            'http://localhost/service?')

        llbox = xml.xpath('//Capability/Layer/LatLonBoundingBox')[0]
        # some clients don't like 90deg north/south
        assert_almost_equal(float(llbox.attrib['miny']), -89.999999, 6)
        assert_almost_equal(float(llbox.attrib['maxy']), 89.999999, 6)
        assert_almost_equal(float(llbox.attrib['minx']), -180.0, 6)
        assert_almost_equal(float(llbox.attrib['maxx']), 180.0, 6)

        layer_names = set(xml.xpath('//Layer/Layer/Name/text()'))
        expected_names = set(['direct_fwd_params', 'direct', 'wms_cache',
            'wms_cache_100', 'wms_cache_130', 'wms_cache_transparent',
            'wms_merge', 'tms_cache', 'wms_cache_multi',
            'wms_cache_link_single', 'wms_cache_110', 'watermark_cache'])
        eq_(layer_names, expected_names)
        assert validate_with_dtd(xml, dtd_name='wms/1.1.0/capabilities_1_1_0.dtd')

    def test_invalid_layer(self):
        self.common_map_req.params['layers'] = 'invalid'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        xml = resp.lxml
        eq_(xml.xpath('/ServiceExceptionReport/@version')[0], '1.1.0')
        eq_(xml.xpath('/ServiceExceptionReport/ServiceException/@code')[0], 'LayerNotDefined')
        eq_(xml.xpath('//ServiceException/text()')[0], 'unknown layer: invalid')
        assert validate_with_dtd(xml, dtd_name='wms/1.1.0/exception_1_1_0.dtd')

    def test_invalid_format(self):
        self.common_map_req.params['format'] = 'image/ascii'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        xml = resp.lxml
        eq_(xml.xpath('/ServiceExceptionReport/@version')[0], '1.1.0')
        eq_(xml.xpath('/ServiceExceptionReport/ServiceException/@code')[0], 'InvalidFormat')
        eq_(xml.xpath('//ServiceException/text()')[0], 'unsupported image format: image/ascii')
        assert validate_with_dtd(xml, dtd_name='wms/1.1.0/exception_1_1_0.dtd')

    def test_invalid_format_img_exception(self):
        self.common_map_req.params['format'] = 'image/ascii'
        self.common_map_req.params['exceptions'] = 'application/vnd.ogc.se_inimage'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        assert is_png(StringIO(resp.body))

    def test_missing_format_img_exception(self):
        del self.common_map_req.params['format']
        self.common_map_req.params['exceptions'] = 'application/vnd.ogc.se_inimage'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        assert is_png(StringIO(resp.body))

    def test_invalid_srs(self):
        self.common_map_req.params['srs'] = 'EPSG:1234'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        xml = resp.lxml
        eq_(xml.xpath('/ServiceExceptionReport/@version')[0], '1.1.0')
        eq_(xml.xpath('/ServiceExceptionReport/ServiceException/@code')[0], 'InvalidSRS')
        eq_(xml.xpath('//ServiceException/text()')[0], 'unsupported srs: EPSG:1234')
        assert validate_with_dtd(xml, dtd_name='wms/1.1.0/exception_1_1_0.dtd')

    def test_get_map_png(self):
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        data = StringIO(resp.body)
        assert is_png(data)
        assert Image.open(data).mode == 'RGB'

    def test_get_map_jpeg(self):
        self.common_map_req.params['format'] = 'image/jpeg'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/jpeg')
        assert is_jpeg(StringIO(resp.body))

    def test_get_map_xml_exception(self):
        self.common_map_req.params['bbox'] = '0,0,90,90'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        xml = resp.lxml
        eq_(xml.xpath('/ServiceExceptionReport/ServiceException/@code'), [])
        assert 'No response from URL' in xml.xpath('//ServiceException/text()')[0]
        assert validate_with_dtd(xml, 'wms/1.1.0/exception_1_1_0.dtd')

    def test_get_map(self):
        self.created_tiles.append('wms_cache_EPSG900913/01/000/000/001/000/000/001.jpeg')
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fjpeg'
                                      '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A900913&styles='
                                      '&VERSION=1.1.1&BBOX=0.0,0.0,20037508.3428,20037508.3428'
                                      '&WIDTH=256'},
                            {'body': img.read(), 'headers': {'content-type': 'image/jpeg'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                self.common_map_req.params['bbox'] = '0,0,180,90'
                resp = self.app.get(self.common_map_req)
                assert 35000 < int(resp.headers['Content-length']) < 75000
                eq_(resp.content_type, 'image/png')

    def test_get_map_110(self):
        self.created_tiles.append('wms_cache_110_EPSG900913/01/000/000/001/000/000/001.jpeg')
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fjpeg'
                                      '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A900913&styles='
                                      '&VERSION=1.1.0&BBOX=0.0,0.0,20037508.3428,20037508.3428'
                                      '&WIDTH=256'},
                            {'body': img.read(), 'headers': {'content-type': 'image/jpeg'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                self.common_map_req.params['bbox'] = '0,0,180,90'
                self.common_map_req.params['layers'] = 'wms_cache_110'
                resp = self.app.get(self.common_map_req)
                assert 35000 < int(resp.headers['Content-length']) < 75000
                eq_(resp.content_type, 'image/png')

    def test_get_featureinfo(self):
        expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetFeatureInfo&HEIGHT=200&SRS=EPSG%3A900913'
                                  '&VERSION=1.1.0&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                  '&WIDTH=200&QUERY_LAYERS=foo,bar&X=10&Y=20'},
                        {'body': 'info', 'headers': {'content-type': 'text/plain'}})
        with mock_httpd(('localhost', 42423), [expected_req]):
            resp = self.app.get(self.common_fi_req)
            eq_(resp.content_type, 'text/plain')
            eq_(resp.body, 'info')

    def test_get_featureinfo_not_queryable(self):
        self.common_fi_req.params['query_layers'] = 'tms_cache'
        self.common_fi_req.params['exceptions'] = 'application/vnd.ogc.se_xml'
        resp = self.app.get(self.common_fi_req)
        eq_(resp.content_type, 'application/vnd.ogc.se_xml')
        xml = resp.lxml
        eq_(xml.xpath('/ServiceExceptionReport/ServiceException/@code'), [])
        assert 'tms_cache is not queryable' in xml.xpath('//ServiceException/text()')[0]
        assert validate_with_dtd(xml, 'wms/1.1.0/exception_1_1_0.dtd')


class TestWMS100(WMSTest):
    def setup(self):
        WMSTest.setup(self)
        self.common_req = WMS100MapRequest(url='/service?', param=dict(wmtver='1.0.0'))
        self.common_map_req = WMS100MapRequest(url='/service?', param=dict(wmtver='1.0.0',
            bbox='-180,0,0,80', width='200', height='200',
            layers='wms_cache', srs='EPSG:4326', format='image/png',
            styles='', request='GetMap'))
        self.common_fi_req = WMS100FeatureInfoRequest(url='/service?',
            param=dict(x='10', y='20', width='200', height='200', layers='wms_cache_100',
                       format='image/png', query_layers='wms_cache_100', styles='',
                       bbox='1000,400,2000,1400', srs='EPSG:900913'))

    def test_wms_capabilities(self):
        req = WMS100CapabilitiesRequest(url='/service?').copy_with_request_params(self.common_req)
        resp = self.app.get(req)
        eq_(resp.content_type, 'text/xml')
        xml = resp.lxml
        eq_(xml.xpath('/WMT_MS_Capabilities/Service/Title/text()')[0],
            u'MapProxy test fixture \u2603')
        layer_names = set(xml.xpath('//Layer/Layer/Name/text()'))
        expected_names = set(['direct_fwd_params', 'direct', 'wms_cache',
            'wms_cache_100', 'wms_cache_130', 'wms_cache_transparent',
            'wms_merge', 'tms_cache', 'wms_cache_multi',
            'wms_cache_link_single', 'wms_cache_110', 'watermark_cache'])
        eq_(layer_names, expected_names)
        #TODO srs
        assert validate_with_dtd(xml, dtd_name='wms/1.0.0/capabilities_1_0_0.dtd')


    def test_invalid_layer(self):
        self.common_map_req.params['layers'] = 'invalid'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'text/xml')
        xml = resp.lxml
        eq_(xml.xpath('/WMTException/@version')[0], '1.0.0')
        eq_(xml.xpath('//WMTException/text()')[0].strip(), 'unknown layer: invalid')

    def test_invalid_format(self):
        self.common_map_req.params['format'] = 'image/ascii'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'text/xml')
        xml = resp.lxml
        eq_(xml.xpath('/WMTException/@version')[0], '1.0.0')
        eq_(xml.xpath('//WMTException/text()')[0].strip(),
                      'unsupported image format: image/ascii')

    def test_invalid_format_img_exception(self):
        self.common_map_req.params['format'] = 'image/ascii'
        self.common_map_req.params['exceptions'] = 'INIMAGE'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        assert is_png(StringIO(resp.body))

    def test_missing_format_img_exception(self):
        del self.common_map_req.params['format']
        self.common_map_req.params['exceptions'] = 'INIMAGE'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        assert is_png(StringIO(resp.body))

    def test_invalid_srs(self):
        self.common_map_req.params['srs'] = 'EPSG:1234'
        print self.common_map_req.complete_url
        resp = self.app.get(self.common_map_req.complete_url)
        xml = resp.lxml
        eq_(xml.xpath('//WMTException/text()')[0].strip(), 'unsupported srs: EPSG:1234')

    def test_get_map_png(self):
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        data = StringIO(resp.body)
        assert is_png(data)
        eq_(Image.open(data).mode, 'RGB')

    def test_get_map_png_transparent_paletted(self):
        try:
            base_config().image.paletted = True
            self.common_map_req.params['transparent'] = 'True'
            resp = self.app.get(self.common_map_req)
            eq_(resp.content_type, 'image/png')
            data = StringIO(resp.body)
            assert is_png(data)
            assert Image.open(data).mode == 'P'
        finally:
            base_config().image.paletted = False

    def test_get_map_jpeg(self):
        self.common_map_req.params['format'] = 'image/jpeg'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/jpeg')
        assert is_jpeg(StringIO(resp.body))

    def test_get_map_xml_exception(self):
         self.common_map_req.params['bbox'] = '0,0,90,90'
         resp = self.app.get(self.common_map_req)
         xml = resp.lxml
         assert 'No response from URL' in xml.xpath('//WMTException/text()')[0]

    def test_get_map(self):
        self.created_tiles.append('wms_cache_EPSG900913/01/000/000/001/000/000/001.jpeg')
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fjpeg'
                                      '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A900913&styles='
                                      '&VERSION=1.1.1&BBOX=0.0,0.0,20037508.3428,20037508.3428'
                                      '&WIDTH=256'},
                            {'body': img.read(), 'headers': {'content-type': 'image/jpeg'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                self.common_map_req.params['bbox'] = '0,0,180,90'
                resp = self.app.get(self.common_map_req)
                eq_(resp.content_type, 'image/png')

    def test_get_featureinfo(self):
        expected_req = ({'path': r'/service?LAYERs=foo,bar&FORMAT=image%2Fpng'
                                  '&REQUEST=feature_info&HEIGHT=200&SRS=EPSG%3A900913'
                                  '&WMTVER=1.0.0&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                  '&WIDTH=200&QUERY_LAYERS=foo,bar&X=10&Y=20'},
                        {'body': 'info', 'headers': {'content-type': 'text/plain'}})
        with mock_httpd(('localhost', 42423), [expected_req]):
            resp = self.app.get(self.common_fi_req)
            eq_(resp.content_type, 'text/plain')
            eq_(resp.body, 'info')

    def test_get_featureinfo_not_queryable(self):
        self.common_fi_req.params['query_layers'] = 'tms_cache'
        self.common_fi_req.params['exceptions'] = 'application/vnd.ogc.se_xml'
        resp = self.app.get(self.common_fi_req)
        eq_(resp.content_type, 'text/xml')
        xml = resp.lxml
        assert 'tms_cache is not queryable' in xml.xpath('//WMTException/text()')[0]

ns130 = {'wms': 'http://www.opengis.net/wms',
         'ogc': 'http://www.opengis.net/ogc',
         'sld': 'http://www.opengis.net/sld',
         'xlink': 'http://www.w3.org/1999/xlink'}

def eq_xpath(xml, xpath, expected, namespaces=None):
    eq_(xml.xpath(xpath, namespaces=namespaces)[0], expected)

eq_xpath_wms130 = functools.partial(eq_xpath, namespaces=ns130)

class TestWMS130(WMSTest):
    def setup(self):
        WMSTest.setup(self)
        self.common_req = WMS130MapRequest(url='/service?', param=dict(service='WMS',
             version='1.3.0'))
        self.common_map_req = WMS130MapRequest(url='/service?', param=dict(service='WMS',
             version='1.3.0', bbox='0,-180,80,0', width='200', height='200',
             layers='wms_cache', crs='EPSG:4326', format='image/png',
             styles='', request='GetMap'))
        self.common_fi_req = WMS130FeatureInfoRequest(url='/service?',
            param=dict(i='10', j='20', width='200', height='200', layers='wms_cache_130',
                       format='image/png', query_layers='wms_cache_130', styles='',
                       bbox='1000,400,2000,1400', crs='EPSG:900913'))

    def test_wms_capabilities(self):
        req = WMS130CapabilitiesRequest(url='/service?').copy_with_request_params(self.common_req)
        resp = self.app.get(req)
        eq_(resp.content_type, 'text/xml')
        xml = resp.lxml
        eq_xpath_wms130(xml, '/wms:WMS_Capabilities/wms:Service/wms:Title/text()',
            u'MapProxy test fixture \u2603')

        # test for extended layer metadata
        eq_xpath_wms130(xml, '/wms:WMS_Capabilities/wms:Capability/wms:Layer/wms:Layer/wms:Attribution/wms:Title/text()',
            u'My attribution title')

        layer_names = set(xml.xpath('//wms:Layer/wms:Layer/wms:Name/text()',
                                    namespaces=ns130))
        expected_names = set(['direct_fwd_params', 'direct', 'wms_cache',
            'wms_cache_100', 'wms_cache_130', 'wms_cache_transparent',
            'wms_merge', 'tms_cache', 'wms_cache_multi',
            'wms_cache_link_single', 'wms_cache_110', 'watermark_cache'])
        eq_(layer_names, expected_names)
        assert is_130_capa(xml)

    def test_invalid_layer(self):
        self.common_map_req.params['layers'] = 'invalid'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'text/xml')
        xml = resp.lxml
        eq_xpath_wms130(xml, '/ogc:ServiceExceptionReport/@version', '1.3.0')
        eq_xpath_wms130(xml, '/ogc:ServiceExceptionReport/ogc:ServiceException/@code',
            'LayerNotDefined')
        eq_xpath_wms130(xml, '//ogc:ServiceException/text()', 'unknown layer: invalid')
        assert validate_with_xsd(xml, xsd_name='wms/1.3.0/exceptions_1_3_0.xsd')

    def test_invalid_format(self):
        self.common_map_req.params['format'] = 'image/ascii'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'text/xml')
        xml = resp.lxml
        eq_xpath_wms130(xml, '/ogc:ServiceExceptionReport/@version', '1.3.0')
        eq_xpath_wms130(xml, '/ogc:ServiceExceptionReport/ogc:ServiceException/@code',
            'InvalidFormat')
        eq_xpath_wms130(xml, '//ogc:ServiceException/text()', 'unsupported image format: image/ascii')
        assert validate_with_xsd(xml, xsd_name='wms/1.3.0/exceptions_1_3_0.xsd')

    def test_invalid_format_img_exception(self):
        self.common_map_req.params['format'] = 'image/ascii'
        self.common_map_req.params['exceptions'] = 'application/vnd.ogc.se_inimage'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        assert is_png(StringIO(resp.body))

    def test_missing_format_img_exception(self):
        del self.common_map_req.params['format']
        self.common_map_req.params['exceptions'] = 'application/vnd.ogc.se_inimage'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        assert is_png(StringIO(resp.body))

    def test_invalid_srs(self):
        self.common_map_req.params['srs'] = 'EPSG:1234'
        self.common_map_req.params['exceptions'] = 'text/xml'

        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'text/xml')
        xml = resp.lxml
        eq_xpath_wms130(xml, '/ogc:ServiceExceptionReport/ogc:ServiceException/@code',
            'InvalidCRS')
        eq_xpath_wms130(xml, '//ogc:ServiceException/text()', 'unsupported crs: EPSG:1234')
        assert validate_with_xsd(xml, xsd_name='wms/1.3.0/exceptions_1_3_0.xsd')

    def test_get_map_png(self):
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/png')
        data = StringIO(resp.body)
        assert is_png(data)
        assert Image.open(data).mode == 'RGB'

    def test_get_map_jpeg(self):
        self.common_map_req.params['format'] = 'image/jpeg'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'image/jpeg')
        assert is_jpeg(StringIO(resp.body))

    def test_get_map_xml_exception(self):
        self.common_map_req.params['bbox'] = '0,0,90,90'
        resp = self.app.get(self.common_map_req)
        eq_(resp.content_type, 'text/xml')
        xml = resp.lxml
        eq_(xml.xpath('/ogc:ServiceExceptionReport/ogc:ServiceException/@code', namespaces=ns130), [])
        assert ('No response from URL' in
            xml.xpath('//ogc:ServiceException/text()', namespaces=ns130)[0])
        assert validate_with_xsd(xml, xsd_name='wms/1.3.0/exceptions_1_3_0.xsd')

    def test_get_map(self):
        self.created_tiles.append('wms_cache_EPSG900913/01/000/000/001/000/000/001.jpeg')
        with tmp_image((256, 256), format='jpeg') as img:
            expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fjpeg'
                                      '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A900913&styles='
                                      '&VERSION=1.1.1&BBOX=0.0,0.0,20037508.3428,20037508.3428'
                                      '&WIDTH=256'},
                            {'body': img.read(), 'headers': {'content-type': 'image/jpeg'}})
            with mock_httpd(('localhost', 42423), [expected_req]):
                self.common_map_req.params['bbox'] = '0,0,180,90' #internal axis-order
                resp = self.app.get(self.common_map_req)
                eq_(resp.content_type, 'image/png')

    def test_get_featureinfo(self):
        expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetFeatureInfo&HEIGHT=200&CRS=EPSG%3A900913'
                                  '&VERSION=1.3.0&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                  '&WIDTH=200&QUERY_LAYERS=foo,bar&I=10&J=20'},
                        {'body': 'info', 'headers': {'content-type': 'text/plain'}})
        with mock_httpd(('localhost', 42423), [expected_req]):
            resp = self.app.get(self.common_fi_req)
            eq_(resp.content_type, 'text/plain')
            eq_(resp.body, 'info')

    def test_get_featureinfo_111(self):
        expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetFeatureInfo&HEIGHT=200&SRS=EPSG%3A900913'
                                  '&VERSION=1.1.1&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                  '&WIDTH=200&QUERY_LAYERS=foo,bar&X=10&Y=20'},
                        {'body': 'info', 'headers': {'content-type': 'text/plain'}})
        with mock_httpd(('localhost', 42423), [expected_req]):
            self.common_fi_req.params['layers'] = 'wms_cache'
            self.common_fi_req.params['query_layers'] = 'wms_cache'
            resp = self.app.get(self.common_fi_req)
            eq_(resp.content_type, 'text/plain')
            eq_(resp.body, 'info')


if sys.platform != 'win32':
    class TestWMSLinkSingleColorImages(WMSTest):
        def setup(self):
            WMSTest.setup(self)
            self.common_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS',
                 version='1.1.1', bbox='-180,0,0,80', width='200', height='200',
                 layers='wms_cache_link_single', srs='EPSG:4326', format='image/jpeg',
                 styles='', request='GetMap'))

        def test_get_map(self):
            link_name = 'wms_cache_link_single_EPSG900913/01/000/000/001/000/000/001.png'
            real_name = 'wms_cache_link_single_EPSG900913/single_color_tiles/fe00a0.png'
            self.created_tiles.append(link_name)
            self.created_tiles.append(real_name)
            with tmp_image((256, 256), format='jpeg', color='#fe00a0') as img:
                expected_req = ({'path': r'/service?LAYERs=foo,bar&SERVICE=WMS&FORMAT=image%2Fjpeg'
                                          '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A900913&styles='
                                          '&VERSION=1.1.1&BBOX=0.0,0.0,20037508.3428,20037508.3428'
                                          '&WIDTH=256'},
                                {'body': img.read(), 'headers': {'content-type': 'image/jpeg'}})
                with mock_httpd(('localhost', 42423), [expected_req]):
                    self.common_map_req.params['bbox'] = '0,0,180,90'
                    resp = self.app.get(self.common_map_req)
                    eq_(resp.content_type, 'image/jpeg')

                base_dir = base_config().cache.base_dir
                single_loc = os.path.join(base_dir, real_name)
                tile_loc = os.path.join(base_dir, link_name)
                assert os.path.exists(single_loc)
                assert os.path.islink(tile_loc)

                self.common_map_req.params['format'] = 'image/png'
                resp = self.app.get(self.common_map_req)
                eq_(resp.content_type, 'image/png')


########NEW FILE########
__FILENAME__ = test_wmsc
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

from cStringIO import StringIO
from mapproxy.request.wms import (
    WMS111MapRequest, WMS111FeatureInfoRequest, WMS111CapabilitiesRequest
)
from mapproxy.test.image import is_jpeg
from mapproxy.test.helper import validate_with_dtd
from mapproxy.test.system.test_wms import is_111_exception
from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config
from nose.tools import eq_

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'layer.yaml', with_cache_data=True)

def teardown_module():
    module_teardown(test_config)

class TestWMSC(SystemTest):
    config = test_config
    def setup(self):
        SystemTest.setup(self)
        self.common_cap_req = WMS111CapabilitiesRequest(url='/service?', param=dict(service='WMS',
             version='1.1.1'))
        self.common_map_req = WMS111MapRequest(url='/service?', param=dict(service='WMS',
             version='1.1.1', bbox='-20037508,0.0,0.0,20037508', width='256', height='256',
             layers='wms_cache', srs='EPSG:900913', format='image/jpeg',
             styles='', request='GetMap'))
        self.common_fi_req = WMS111FeatureInfoRequest(url='/service?',
            param=dict(x='10', y='20', width='200', height='200', layers='wms_cache',
                       format='image/png', query_layers='wms_cache', styles='',
                       bbox='1000,400,2000,1400', srs='EPSG:900913'))

    def test_capabilities(self):
        req = str(self.common_cap_req) + '&tiled=true'
        resp = self.app.get(req)
        xml = resp.lxml
        assert validate_with_dtd(xml, dtd_name='wmsc/1.1.1/WMS_MS_Capabilities.dtd')
        srs = set([e.text for e in xml.xpath('//TileSet/SRS')])
        eq_(srs, set(['EPSG:4326', 'EPSG:900913']))
        eq_(len(xml.xpath('//TileSet')), 10)

    def test_get_tile(self):
        resp = self.app.get(str(self.common_map_req) + '&tiled=true')
        assert 'public' in resp.headers['Cache-Control']
        eq_(resp.content_type, 'image/jpeg')
        data = StringIO(resp.body)
        assert is_jpeg(data)

    def test_get_tile_w_rounded_bbox(self):
        self.common_map_req.params.bbox = '-20037400,0.0,0.0,20037400'
        resp = self.app.get(str(self.common_map_req) + '&tiled=true')
        assert 'public' in resp.headers['Cache-Control']
        eq_(resp.content_type, 'image/jpeg')
        data = StringIO(resp.body)
        assert is_jpeg(data)

    def test_get_tile_wrong_bbox(self):
        self.common_map_req.params.bbox = '-20037508,0.0,200000.0,20037508'
        resp = self.app.get(str(self.common_map_req) + '&tiled=true')
        assert 'Cache-Control' not in resp.headers
        is_111_exception(resp.lxml, re_msg='.*invalid bbox')

    def test_get_tile_wrong_fromat(self):
        self.common_map_req.params.format = 'image/png'
        resp = self.app.get(str(self.common_map_req) + '&tiled=true')
        assert 'Cache-Control' not in resp.headers
        is_111_exception(resp.lxml, re_msg='Invalid request: invalid.*format.*jpeg')

    def test_get_tile_wrong_size(self):
        self.common_map_req.params.size = (256, 255)
        resp = self.app.get(str(self.common_map_req) + '&tiled=true')
        assert 'Cache-Control' not in resp.headers
        is_111_exception(resp.lxml, re_msg='Invalid request: invalid.*size.*256x256')

########NEW FILE########
__FILENAME__ = test_wms_srs_extent
# This file is part of the MapProxy project.
# Copyright (C) 2014 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config
from mapproxy.test.image import is_png, is_transparent
from mapproxy.test.image import tmp_image, assert_colors_equal, img_from_buf
from mapproxy.test.http import mock_httpd
from nose.tools import eq_

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'wms_srs_extent.yaml')

def teardown_module():
    module_teardown(test_config)

class TestWMSSRSExtentTest(SystemTest):
    config = test_config

    def test_out_of_extent(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetMap'
            '&LAYERS=direct&STYLES='
            '&WIDTH=100&HEIGHT=100&FORMAT=image/png'
            '&BBOX=-10000,0,0,1000&SRS=EPSG:25832'
            '&VERSION=1.1.0&TRANSPARENT=TRUE')
        # empty/transparent response
        eq_(resp.content_type, 'image/png')
        assert is_png(resp.body)
        assert is_transparent(resp.body)

    def test_out_of_extent_bgcolor(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetMap'
            '&LAYERS=direct&STYLES='
            '&WIDTH=100&HEIGHT=100&FORMAT=image/png'
            '&BBOX=-10000,0,0,1000&SRS=EPSG:25832'
            '&VERSION=1.1.0&TRANSPARENT=FALSE&BGCOLOR=0xff0000')
        # red response
        eq_(resp.content_type, 'image/png')
        assert is_png(resp.body)
        assert_colors_equal(img_from_buf(resp.body).convert('RGBA'),
                [(100 * 100, [255, 0, 0, 255])])

    def test_clipped(self):
        with tmp_image((256, 256), format='png', color=(255, 0, 0)) as img:
            expected_req = ({'path':
                r'/service?LAYERs=bar&SERVICE=WMS&FORMAT=image%2Fpng'
                 '&REQUEST=GetMap&HEIGHT=100&SRS=EPSG%3A25832&styles='
                 '&VERSION=1.1.1&BBOX=0.0,3500000.0,150.0,3500100.0'
                 '&WIDTH=75'},
                {'body': img.read(), 'headers': {'content-type': 'image/png'}})
        with mock_httpd(('localhost', 42423), [expected_req]):
            resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetMap'
                '&LAYERS=direct&STYLES='
                '&WIDTH=100&HEIGHT=100&FORMAT=image/png'
                '&BBOX=-50,3500000,150,3500100&SRS=EPSG:25832'
                '&VERSION=1.1.0&TRANSPARENT=TRUE')
            eq_(resp.content_type, 'image/png')
            assert is_png(resp.body)
            colors = sorted(img_from_buf(resp.body).convert('RGBA').getcolors())
            # quarter is clipped, check if it's transparent
            eq_(colors[0][0], (25 * 100))
            eq_(colors[0][1][3], 0)
            eq_(colors[1], (75 * 100, (255, 0, 0, 255)))

    def test_clipped_bgcolor(self):
        with tmp_image((256, 256), format='png', color=(255, 0, 0)) as img:
            expected_req = ({'path':
                r'/service?LAYERs=bar&SERVICE=WMS&FORMAT=image%2Fpng'
                 '&REQUEST=GetMap&HEIGHT=100&SRS=EPSG%3A25832&styles='
                 '&VERSION=1.1.1&BBOX=0.0,3500000.0,100.0,3500100.0'
                 '&WIDTH=50'},
                {'body': img.read(), 'headers': {'content-type': 'image/png'}})
        with mock_httpd(('localhost', 42423), [expected_req]):
            resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetMap'
                '&LAYERS=direct&STYLES='
                '&WIDTH=100&HEIGHT=100&FORMAT=image/png'
                '&BBOX=-100,3500000,100,3500100&SRS=EPSG:25832'
                '&VERSION=1.1.0&TRANSPARENT=FALSE&BGCOLOR=0x00ff00')
            eq_(resp.content_type, 'image/png')
            assert is_png(resp.body)
            assert_colors_equal(img_from_buf(resp.body).convert('RGBA'),
                [(50 * 100, [255, 0, 0, 255]), (50 * 100, [0, 255, 0, 255])])
########NEW FILE########
__FILENAME__ = test_wms_version
# This file is part of the MapProxy project.
# Copyright (C) 2014 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config
from mapproxy.test.system.test_wms import is_110_capa, is_111_capa


test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'wms_versions.yaml')

def teardown_module():
    module_teardown(test_config)

class TestWMSVersionsTest(SystemTest):
    config = test_config

    def test_supported_version_110(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetCapabilities'
                            '&VERSION=1.1.0')
        assert is_110_capa(resp.lxml)

    def test_unknown_version_113(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetCapabilities'
                            '&VERSION=1.1.3')
        assert is_111_capa(resp.lxml)

    def test_unknown_version_090(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetCapabilities'
                            '&WMTVER=0.9.0')
        assert is_110_capa(resp.lxml)

    def test_unsupported_version_130(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetCapabilities'
                            '&VERSION=1.3.0')
        assert is_111_capa(resp.lxml)

    def test_unknown_version_200(self):
        resp = self.app.get('http://localhost/service?SERVICE=WMS&REQUEST=GetCapabilities'
                            '&VERSION=2.0.0')
        assert is_111_capa(resp.lxml)

########NEW FILE########
__FILENAME__ = test_wmts
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

import os
import shutil
import functools

from cStringIO import StringIO
from mapproxy.request.wmts import (
    WMTS100TileRequest, WMTS100CapabilitiesRequest
)
from mapproxy.test.image import is_jpeg, create_tmp_image
from mapproxy.test.http import MockServ
from mapproxy.test.helper import validate_with_xsd
from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config
from nose.tools import eq_

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'wmts.yaml', with_cache_data=True)

def teardown_module():
    module_teardown(test_config)

ns_wmts = {
    'wmts': 'http://www.opengis.net/wmts/1.0',
    'ows': 'http://www.opengis.net/ows/1.1',
    'xlink': 'http://www.w3.org/1999/xlink'
}

def eq_xpath(xml, xpath, expected, namespaces=None):
    eq_(xml.xpath(xpath, namespaces=namespaces)[0], expected)

eq_xpath_wmts = functools.partial(eq_xpath, namespaces=ns_wmts)


class TestWMTS(SystemTest):
    config = test_config
    def setup(self):
        SystemTest.setup(self)
        self.common_cap_req = WMTS100CapabilitiesRequest(url='/service?', param=dict(service='WMTS',
             version='1.0.0', request='GetCapabilities'))
        self.common_tile_req = WMTS100TileRequest(url='/service?', param=dict(service='WMTS',
             version='1.0.0', tilerow='0', tilecol='0', tilematrix='01', tilematrixset='GLOBAL_MERCATOR',
             layer='wms_cache', format='image/jpeg', style='', request='GetTile'))

    def test_capabilities(self):
        req = str(self.common_cap_req)
        resp = self.app.get(req)
        xml = resp.lxml
        assert validate_with_xsd(xml, xsd_name='wmts/1.0/wmtsGetCapabilities_response.xsd')
        eq_(len(xml.xpath('//wmts:Layer', namespaces=ns_wmts)), 4)
        eq_(len(xml.xpath('//wmts:Contents/wmts:TileMatrixSet', namespaces=ns_wmts)), 4)

    def test_get_tile(self):
        resp = self.app.get(str(self.common_tile_req))
        eq_(resp.content_type, 'image/jpeg')
        data = StringIO(resp.body)
        assert is_jpeg(data)

    def test_get_tile_flipped_axis(self):
        # test default tile lock directory
        tiles_lock_dir = os.path.join(test_config['base_dir'], 'cache_data', 'tile_locks')
        # make sure default tile_lock_dir was not created by other tests
        shutil.rmtree(tiles_lock_dir, ignore_errors=True)
        assert not os.path.exists(tiles_lock_dir)

        self.common_tile_req.params['layer'] = 'tms_cache_ul'
        self.common_tile_req.params['tilematrixset'] = 'ulgrid'
        self.common_tile_req.params['format'] = 'image/png'
        self.common_tile_req.tile = (0, 0, '01')
        serv = MockServ(port=42423)
        # source is ll, cache/service ul
        serv.expects('/tiles/01/000/000/000/000/000/001.png')
        serv.returns(create_tmp_image((256, 256)))
        with serv:
            resp = self.app.get(str(self.common_tile_req), status=200)
            eq_(resp.content_type, 'image/png')

        # test default tile lock directory was created
        assert os.path.exists(tiles_lock_dir)


    def test_get_tile_source_error(self):
        self.common_tile_req.params['layer'] = 'tms_cache'
        self.common_tile_req.params['format'] = 'image/png'
        resp = self.app.get(str(self.common_tile_req), status=500)
        xml = resp.lxml
        assert validate_with_xsd(xml, xsd_name='ows/1.1.0/owsExceptionReport.xsd')
        eq_xpath_wmts(xml, '/ows:ExceptionReport/ows:Exception/@exceptionCode',
            'NoApplicableCode')

    def test_get_tile_out_of_range(self):
        self.common_tile_req.params.coord = -1, 1, 1
        resp = self.app.get(str(self.common_tile_req), status=400)
        xml = resp.lxml
        eq_(resp.content_type, 'text/xml')
        assert validate_with_xsd(xml, xsd_name='ows/1.1.0/owsExceptionReport.xsd')
        eq_xpath_wmts(xml, '/ows:ExceptionReport/ows:Exception/@exceptionCode',
            'TileOutOfRange')

    def test_get_tile_invalid_format(self):
        self.common_tile_req.params['format'] = 'image/png'
        self.check_invalid_parameter()

    def test_get_tile_invalid_layer(self):
        self.common_tile_req.params['layer'] = 'unknown'
        self.check_invalid_parameter()

    def test_get_tile_invalid_matrixset(self):
        self.common_tile_req.params['tilematrixset'] = 'unknown'
        self.check_invalid_parameter()

    def check_invalid_parameter(self):
        resp = self.app.get(str(self.common_tile_req), status=400)
        xml = resp.lxml
        eq_(resp.content_type, 'text/xml')
        assert validate_with_xsd(xml, xsd_name='ows/1.1.0/owsExceptionReport.xsd')
        eq_xpath_wmts(xml, '/ows:ExceptionReport/ows:Exception/@exceptionCode',
            'InvalidParameterValue')


########NEW FILE########
__FILENAME__ = test_wmts_dimensions
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

import functools

from mapproxy.test.image import create_tmp_image
from mapproxy.test.http import MockServ
from mapproxy.test.helper import validate_with_xsd
from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config
from nose.tools import eq_

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'wmts_dimensions.yaml', with_cache_data=True)

def teardown_module():
    module_teardown(test_config)

ns_wmts = {
    'wmts': 'http://www.opengis.net/wmts/1.0',
    'ows': 'http://www.opengis.net/ows/1.1',
    'xlink': 'http://www.w3.org/1999/xlink'
}

def eq_xpath(xml, xpath, expected, namespaces=None):
    eq_(xml.xpath(xpath, namespaces=namespaces)[0], expected)

eq_xpath_wmts = functools.partial(eq_xpath, namespaces=ns_wmts)

DIMENSION_LAYER_BASE_REQ = (
    '/service1?styles=&format=image%2Fpng&height=256'
    '&bbox=-20037508.3428,0.0,0.0,20037508.3428'
    '&layers=foo,bar&service=WMS&srs=EPSG%3A900913'
    '&request=GetMap&width=256&version=1.1.1'
)
NO_DIMENSION_LAYER_BASE_REQ = DIMENSION_LAYER_BASE_REQ.replace('/service1?', '/service2?')

WMTS_KVP_URL = (
    '/service?service=wmts&request=GetTile&version=1.0.0'
    '&tilematrixset=GLOBAL_MERCATOR&tilematrix=01&tilecol=0&tilerow=0&format=png&style='
)

TEST_TILE = create_tmp_image((256, 256))

class TestWMTS(SystemTest):
    config = test_config
    def setup(self):
        SystemTest.setup(self)

    def test_capabilities(self):
        resp = self.app.get('/wmts/myrest/1.0.0/WMTSCapabilities.xml')
        xml = resp.lxml
        assert validate_with_xsd(xml, xsd_name='wmts/1.0/wmtsGetCapabilities_response.xsd')

        eq_(len(xml.xpath('//wmts:Layer', namespaces=ns_wmts)), 2)
        eq_(len(xml.xpath('//wmts:Contents/wmts:TileMatrixSet', namespaces=ns_wmts)), 1)

        eq_(xml.xpath('//wmts:Contents/wmts:Layer/wmts:ResourceURL/@template', namespaces=ns_wmts),
            ['http://localhost/wmts/myrest/dimension_layer/{TileMatrixSet}/{Time}/{Elevation}/{TileMatrix}/{TileCol}/{TileRow}.png',
             'http://localhost/wmts/myrest/no_dimension_layer/{TileMatrixSet}/{Time}/{Elevation}/{TileMatrix}/{TileCol}/{TileRow}.png'])

        # check dimension values for dimension_layer
        dimension_elems = xml.xpath(
            '//wmts:Layer/ows:Identifier[text()="dimension_layer"]/following-sibling::wmts:Dimension',
            namespaces=ns_wmts,
        )
        dimensions = {}
        for elem in dimension_elems:
            dim = elem.find('{http://www.opengis.net/ows/1.1}Identifier').text
            default = elem.find('{http://www.opengis.net/wmts/1.0}Default').text
            values = [e.text for e in elem.findall('{http://www.opengis.net/wmts/1.0}Value')]
            dimensions[dim] = (values, default)

        eq_(dimensions['Time'][0],
            ["2012-11-12T00:00:00", "2012-11-13T00:00:00",
             "2012-11-14T00:00:00", "2012-11-15T00:00:00"]
        )
        eq_(dimensions['Time'][1], '2012-11-15T00:00:00')
        eq_(dimensions['Elevation'][1], '0')
        eq_(dimensions['Elevation'][0],
            ["0", "1000", "3000"]
        )


    def test_get_tile_valid_dimension(self):
        serv = MockServ(42423)
        serv.expects(DIMENSION_LAYER_BASE_REQ + '&Time=2012-11-15T00:00:00&elevation=1000').returns(TEST_TILE)
        with serv:
            resp = self.app.get('/wmts/dimension_layer/GLOBAL_MERCATOR/2012-11-15T00:00:00/1000/01/0/0.png')
        eq_(resp.content_type, 'image/png')

    def test_get_tile_invalid_dimension(self):
        self.check_invalid_parameter('/wmts/dimension_layer/GLOBAL_MERCATOR/2042-11-15T00:00:00/default/01/0/0.png')

    def test_get_tile_default_dimension(self):
        serv = MockServ(42423)
        serv.expects(DIMENSION_LAYER_BASE_REQ + '&Time=2012-11-15T00:00:00&elevation=0').returns(TEST_TILE)
        with serv:
            resp = self.app.get('/wmts/dimension_layer/GLOBAL_MERCATOR/default/default/01/0/0.png')
        eq_(resp.content_type, 'image/png')

    def test_get_tile_invalid_no_dimension_source(self):
        # unsupported dimension need to be 'default' in RESTful request
        self.check_invalid_parameter('/wmts/no_dimension_layer/GLOBAL_MERCATOR/2042-11-15T00:00:00/default/01/0/0.png')

    def test_get_tile_default_no_dimension_source(self):
        # check if dimensions are ignored
        serv = MockServ(42423)
        serv.expects(NO_DIMENSION_LAYER_BASE_REQ).returns(TEST_TILE)
        with serv:
            resp = self.app.get('/wmts/no_dimension_layer/GLOBAL_MERCATOR/default/default/01/0/0.png')
        eq_(resp.content_type, 'image/png')


    def test_get_tile_kvp_valid_dimension(self):
        serv = MockServ(42423)
        serv.expects(DIMENSION_LAYER_BASE_REQ + '&Time=2012-11-14T00:00:00&elevation=3000').returns(TEST_TILE)
        with serv:
            resp = self.app.get(WMTS_KVP_URL + '&layer=dimension_layer&timE=2012-11-14T00:00:00&ELEvatioN=3000')
        eq_(resp.content_type, 'image/png')

    def test_get_tile_kvp_valid_dimension_defaults(self):
        serv = MockServ(42423)
        serv.expects(DIMENSION_LAYER_BASE_REQ + '&Time=2012-11-15T00:00:00&elevation=0').returns(TEST_TILE)
        with serv:
            resp = self.app.get(WMTS_KVP_URL + '&layer=dimension_layer')
        eq_(resp.content_type, 'image/png')

    def test_get_tile_kvp_invalid_dimension(self):
        self.check_invalid_parameter(WMTS_KVP_URL + '&layer=dimension_layer&elevation=500')


    def test_get_tile_kvp_default_no_dimension_source(self):
        # check if dimensions are ignored
        serv = MockServ(42423)
        serv.expects(NO_DIMENSION_LAYER_BASE_REQ).returns(TEST_TILE)
        with serv:
            resp = self.app.get(WMTS_KVP_URL + '&layer=no_dimension_layer&Time=2012-11-14T00:00:00&Elevation=3000')
        eq_(resp.content_type, 'image/png')

    def check_invalid_parameter(self, url):
        resp = self.app.get(url, status=400)
        xml = resp.lxml
        eq_(resp.content_type, 'text/xml')
        assert validate_with_xsd(xml, xsd_name='ows/1.1.0/owsExceptionReport.xsd')
        eq_xpath_wmts(xml, '/ows:ExceptionReport/ows:Exception/@exceptionCode',
            'InvalidParameterValue')


########NEW FILE########
__FILENAME__ = test_wmts_restful
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

import functools

from cStringIO import StringIO
from mapproxy.request.wmts import (
    WMTS100TileRequest, WMTS100CapabilitiesRequest
)
from mapproxy.test.image import is_jpeg, create_tmp_image
from mapproxy.test.http import MockServ
from mapproxy.test.helper import validate_with_xsd
from mapproxy.test.system import module_setup, module_teardown, SystemTest, make_base_config
from nose.tools import eq_

test_config = {}
base_config = make_base_config(test_config)

def setup_module():
    module_setup(test_config, 'wmts.yaml', with_cache_data=True)

def teardown_module():
    module_teardown(test_config)

ns_wmts = {
    'wmts': 'http://www.opengis.net/wmts/1.0',
    'ows': 'http://www.opengis.net/ows/1.1',
    'xlink': 'http://www.w3.org/1999/xlink'
}

def eq_xpath(xml, xpath, expected, namespaces=None):
    eq_(xml.xpath(xpath, namespaces=namespaces)[0], expected)

eq_xpath_wmts = functools.partial(eq_xpath, namespaces=ns_wmts)


class TestWMTS(SystemTest):
    config = test_config
    def setup(self):
        SystemTest.setup(self)
    
    def test_capabilities(self):
        resp = self.app.get('/wmts/myrest/1.0.0/WMTSCapabilities.xml')
        xml = resp.lxml
        assert validate_with_xsd(xml, xsd_name='wmts/1.0/wmtsGetCapabilities_response.xsd')
        eq_(len(xml.xpath('//wmts:Layer', namespaces=ns_wmts)), 4)
        eq_(len(xml.xpath('//wmts:Contents/wmts:TileMatrixSet', namespaces=ns_wmts)), 4)
    
    def test_get_tile(self):
        resp = self.app.get('/wmts/myrest/wms_cache/GLOBAL_MERCATOR/01/0/0.jpeg')
        eq_(resp.content_type, 'image/jpeg')
        data = StringIO(resp.body)
        assert is_jpeg(data)
        # test without leading 0 in level
        resp = self.app.get('/wmts/myrest/wms_cache/GLOBAL_MERCATOR/1/0/0.jpeg')
        eq_(resp.content_type, 'image/jpeg')
        data = StringIO(resp.body)
        assert is_jpeg(data)
    
    def test_get_tile_flipped_axis(self):
        serv = MockServ(port=42423)
        # source is ll, cache/service ul
        serv.expects('/tiles/01/000/000/000/000/000/001.png')
        serv.returns(create_tmp_image((256, 256)))
        with serv:
            resp = self.app.get('/wmts/myrest/tms_cache_ul/ulgrid/01/0/0.png', status=200)
            eq_(resp.content_type, 'image/png')
            
    def test_get_tile_source_error(self):
        resp = self.app.get('/wmts/myrest/tms_cache/GLOBAL_MERCATOR/01/0/0.png', status=500)
        xml = resp.lxml
        assert validate_with_xsd(xml, xsd_name='ows/1.1.0/owsExceptionReport.xsd')
        eq_xpath_wmts(xml, '/ows:ExceptionReport/ows:Exception/@exceptionCode',
            'NoApplicableCode')
    
    def test_get_tile_out_of_range(self):
        resp = self.app.get('/wmts/myrest/wms_cache/GLOBAL_MERCATOR/01/-1/0.jpeg', status=400)
        xml = resp.lxml
        eq_(resp.content_type, 'text/xml')
        assert validate_with_xsd(xml, xsd_name='ows/1.1.0/owsExceptionReport.xsd')
        eq_xpath_wmts(xml, '/ows:ExceptionReport/ows:Exception/@exceptionCode',
            'TileOutOfRange')

    def test_get_tile_invalid_format(self):
        url = '/wmts/myrest/wms_cache/GLOBAL_MERCATOR/01/0/0.png'
        self.check_invalid_parameter(url)
        
    def test_get_tile_invalid_layer(self):
        url = '/wmts/myrest/unknown/GLOBAL_MERCATOR/01/0/0.jpeg'
        self.check_invalid_parameter(url)
    
    def test_get_tile_invalid_matrixset(self):
        url = '/wmts/myrest/wms_cache/unknown/01/0/0.jpeg'
        self.check_invalid_parameter(url)
    
    def check_invalid_parameter(self, url):
        resp = self.app.get(url, status=400)
        xml = resp.lxml
        eq_(resp.content_type, 'text/xml')
        assert validate_with_xsd(xml, xsd_name='ows/1.1.0/owsExceptionReport.xsd')
        eq_xpath_wmts(xml, '/ows:ExceptionReport/ows:Exception/@exceptionCode',
            'InvalidParameterValue')        


########NEW FILE########
__FILENAME__ = test_xslt_featureinfo
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division
import os

from mapproxy.request.wms import WMS111FeatureInfoRequest, WMS130FeatureInfoRequest
from mapproxy.test.system import module_setup, module_teardown, SystemTest
from mapproxy.test.http import mock_httpd
from mapproxy.test.helper import strip_whitespace

from nose.tools import eq_

test_config = {}


xslt_input = """
<xsl:stylesheet version="1.0"
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
 <xsl:template match="/">
   <baz>
     <foo><xsl:value-of select="/a/b/text()" /></foo>
   </baz>
 </xsl:template>
</xsl:stylesheet>""".strip()

xslt_input_html = """
<xsl:stylesheet version="1.0"
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
 <xsl:template match="/">
   <baz>
     <foo><xsl:value-of select="/html/body/p" /></foo>
   </baz>
 </xsl:template>
</xsl:stylesheet>""".strip()


xslt_output = """
<xsl:stylesheet version="1.0"
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
 <xsl:template match="/">
    <bars>
      <xsl:apply-templates/>
    </bars>
 </xsl:template>

 <xsl:template match="foo">
     <bar><xsl:value-of select="text()" /></bar>
 </xsl:template>
</xsl:stylesheet>""".strip()

xslt_output_html = """
<xsl:stylesheet version="1.0"
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
 <xsl:template match="/">
    <html>
      <body>
        <h1>Bars</h1>
        <xsl:apply-templates/>
      </body>
    </html>
 </xsl:template>

 <xsl:template match="foo">
     <p><xsl:value-of select="text()" /></p>
 </xsl:template>
</xsl:stylesheet>""".strip()


def setup_module():
    module_setup(test_config, 'xslt_featureinfo.yaml')
    with open(os.path.join(test_config['base_dir'], 'fi_in.xsl'), 'w') as f:
        f.write(xslt_input)
    with open(os.path.join(test_config['base_dir'], 'fi_in_html.xsl'), 'w') as f:
        f.write(xslt_input_html)
    with open(os.path.join(test_config['base_dir'], 'fi_out.xsl'), 'w') as f:
        f.write(xslt_output)
    with open(os.path.join(test_config['base_dir'], 'fi_out_html.xsl'), 'w') as f:
        f.write(xslt_output_html)
def teardown_module():
    module_teardown(test_config)

TESTSERVER_ADDRESS = 'localhost', 42423

class TestWMSXSLTFeatureInfo(SystemTest):
    config = test_config
    def setup(self):
        SystemTest.setup(self)
        self.common_fi_req = WMS111FeatureInfoRequest(url='/service?',
            param=dict(x='10', y='20', width='200', height='200', layers='fi_layer',
                       format='image/png', query_layers='fi_layer', styles='',
                       bbox='1000,400,2000,1400', srs='EPSG:900913'))

    def test_get_featureinfo(self):
        fi_body = "<a><b>Bar</b></a>"
        expected_req = ({'path': r'/service_a?LAYERs=a_one&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetFeatureInfo&HEIGHT=200&CRS=EPSG%3A900913'
                                  '&VERSION=1.3.0&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                  '&WIDTH=200&QUERY_LAYERS=a_one&i=10&J=20&info_format=text/xml'},
                        {'body': fi_body, 'headers': {'content-type': 'text/xml; charset=UTF-8'}})
        with mock_httpd(('localhost', 42423), [expected_req]):
            resp = self.app.get(self.common_fi_req)
            eq_(resp.content_type, 'application/vnd.ogc.gml')
            eq_(strip_whitespace(resp.body), '<bars><bar>Bar</bar></bars>')

    def test_get_featureinfo_130(self):
        fi_body = "<a><b>Bar</b></a>"
        expected_req = ({'path': r'/service_a?LAYERs=a_one&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetFeatureInfo&HEIGHT=200&CRS=EPSG%3A900913'
                                  '&VERSION=1.3.0&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                  '&WIDTH=200&QUERY_LAYERS=a_one&i=10&J=20&info_format=text/xml'},
                        {'body': fi_body, 'headers': {'content-type': 'text/xml'}})
        with mock_httpd(('localhost', 42423), [expected_req]):
            req = WMS130FeatureInfoRequest(url='/service?').copy_with_request_params(self.common_fi_req)
            resp = self.app.get(req)
            eq_(resp.content_type, 'text/xml')
            eq_(strip_whitespace(resp.body), '<bars><bar>Bar</bar></bars>')

    def test_get_multiple_featureinfo(self):
        fi_body1 = "<a><b>Bar1</b></a>"
        fi_body2 = "<a><b>Bar2</b></a>"
        fi_body3 = "<body><h1>Hello<p>Bar3"
        expected_req1 = ({'path': r'/service_a?LAYERs=a_one&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetFeatureInfo&HEIGHT=200&CRS=EPSG%3A900913'
                                  '&VERSION=1.3.0&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                  '&WIDTH=200&QUERY_LAYERS=a_one&i=10&J=20&info_format=text/xml'},
                        {'body': fi_body1, 'headers': {'content-type': 'text/xml'}})
        expected_req2 = ({'path': r'/service_b?LAYERs=b_one&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetFeatureInfo&HEIGHT=200&SRS=EPSG%3A900913'
                                  '&VERSION=1.1.1&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                  '&WIDTH=200&QUERY_LAYERS=b_one&X=10&Y=20&info_format=text/xml'},
                        {'body': fi_body2, 'headers': {'content-type': 'text/xml'}})
        expected_req3 = ({'path': r'/service_d?LAYERs=d_one&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetFeatureInfo&HEIGHT=200&SRS=EPSG%3A900913'
                                  '&VERSION=1.1.1&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                  '&WIDTH=200&QUERY_LAYERS=d_one&X=10&Y=20&info_format=text/html'},
                        {'body': fi_body3, 'headers': {'content-type': 'text/html'}})
        with mock_httpd(('localhost', 42423), [expected_req1, expected_req2, expected_req3]):
            self.common_fi_req.params['layers'] = 'fi_multi_layer'
            self.common_fi_req.params['query_layers'] = 'fi_multi_layer'
            resp = self.app.get(self.common_fi_req)
            eq_(resp.content_type, 'application/vnd.ogc.gml')
            eq_(strip_whitespace(resp.body),
                '<bars><bar>Bar1</bar><bar>Bar2</bar><bar>Bar3</bar></bars>')

    def test_get_multiple_featureinfo_html_out(self):
        fi_body1 = "<a><b>Bar1</b></a>"
        fi_body2 = "<a><b>Bar2</b></a>"
        fi_body3 = "<body><h1>Hello<p>Bar3"
        expected_req1 = ({'path': r'/service_a?LAYERs=a_one&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetFeatureInfo&HEIGHT=200&CRS=EPSG%3A900913'
                                  '&VERSION=1.3.0&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                  '&WIDTH=200&QUERY_LAYERS=a_one&i=10&J=20&info_format=text/xml'},
                        {'body': fi_body1, 'headers': {'content-type': 'text/xml'}})
        expected_req2 = ({'path': r'/service_b?LAYERs=b_one&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetFeatureInfo&HEIGHT=200&SRS=EPSG%3A900913'
                                  '&VERSION=1.1.1&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                  '&WIDTH=200&QUERY_LAYERS=b_one&X=10&Y=20&info_format=text/xml'},
                        {'body': fi_body2, 'headers': {'content-type': 'text/xml'}})
        expected_req3 = ({'path': r'/service_d?LAYERs=d_one&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetFeatureInfo&HEIGHT=200&SRS=EPSG%3A900913'
                                  '&VERSION=1.1.1&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                  '&WIDTH=200&QUERY_LAYERS=d_one&X=10&Y=20&info_format=text/html'},
                        {'body': fi_body3, 'headers': {'content-type': 'text/html'}})
        with mock_httpd(('localhost', 42423), [expected_req1, expected_req2, expected_req3]):
            self.common_fi_req.params['layers'] = 'fi_multi_layer'
            self.common_fi_req.params['query_layers'] = 'fi_multi_layer'
            self.common_fi_req.params['info_format'] = 'text/html'
            resp = self.app.get(self.common_fi_req)
            eq_(resp.content_type, 'text/html')
            eq_(strip_whitespace(resp.body),
                '<html><body><h1>Bars</h1><p>Bar1</p><p>Bar2</p><p>Bar3</p></body></html>')

    def test_mixed_featureinfo(self):
        fi_body1 = "Hello"
        fi_body2 = "<a><b>Bar2</b></a>"
        expected_req1 = ({'path': r'/service_c?LAYERs=c_one&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetFeatureInfo&HEIGHT=200&SRS=EPSG%3A900913'
                                  '&VERSION=1.1.1&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                  '&WIDTH=200&QUERY_LAYERS=c_one&X=10&Y=20'},
                        {'body': fi_body1, 'headers': {'content-type': 'text/plain'}})
        expected_req2 = ({'path': r'/service_a?LAYERs=a_one&SERVICE=WMS&FORMAT=image%2Fpng'
                                   '&REQUEST=GetFeatureInfo&HEIGHT=200&CRS=EPSG%3A900913'
                                   '&VERSION=1.3.0&BBOX=1000.0,400.0,2000.0,1400.0&styles='
                                   '&WIDTH=200&QUERY_LAYERS=a_one&i=10&J=20&info_format=text/xml'},
                        {'body': fi_body2, 'headers': {'content-type': 'text/xml'}})
        with mock_httpd(('localhost', 42423), [expected_req1, expected_req2]):
            self.common_fi_req.params['layers'] = 'fi_without_xslt_layer,fi_layer'
            self.common_fi_req.params['query_layers'] = 'fi_without_xslt_layer,fi_layer'
            resp = self.app.get(self.common_fi_req)
            eq_(resp.content_type, 'text/plain')
            eq_(strip_whitespace(resp.body),
                'Hello<baz><foo>Bar2</foo></baz>')
########NEW FILE########
__FILENAME__ = test_async
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

import time
import threading
from mapproxy.util.async import imap_async_threaded, ThreadPool

from nose.tools import eq_
from nose.plugins.skip import SkipTest

class TestThreaded(object):
    def test_map(self):
        def func(x):
            time.sleep(0.05)
            return x
        start = time.time()
        result = list(imap_async_threaded(func, range(40)))
        stop = time.time()

        duration = stop - start
        assert duration < 0.2

        eq_(len(result), 40)

    def test_map_with_exception(self):
        def func(x):
            raise Exception()

        try:
            list(imap_async_threaded(func, range(40)))
        except Exception:
            pass
        else:
            assert False, 'exception expected'

try:
    import eventlet
    from mapproxy.util.async import imap_async_eventlet, EventletPool
    _has_eventlet = True
except ImportError:
    _has_eventlet = False

class TestEventlet(object):
    def setup(self):
        if not _has_eventlet:
            raise SkipTest('eventlet required')

    def test_map(self):
        def func(x):
            eventlet.sleep(0.05)
            return x
        start = time.time()
        result = list(imap_async_eventlet(func, range(40)))
        stop = time.time()

        duration = stop - start
        assert duration < 0.1

        eq_(len(result), 40)

    def test_map_with_exception(self):
        def func(x):
            raise Exception()

        try:
            list(imap_async_eventlet(func, range(40)))
        except Exception:
            pass
        else:
            assert False, 'exception expected'



class CommonPoolTests(object):
    def _check_single_arg(self, func):
        result = list(func())
        eq_(result, [3])

    def test_single_argument(self):
        f1 = lambda x, y: x+y
        pool = self.mk_pool()
        check = self._check_single_arg
        yield check, lambda: pool.map(f1, [1], [2])
        yield check, lambda: pool.imap(f1, [1], [2])
        yield check, lambda: pool.starmap(f1, [(1, 2)])
        yield check, lambda: pool.starcall([(f1, 1, 2)])


    def _check_single_arg_raise(self, func):
        try:
            list(func())
        except ValueError:
            pass
        else:
            assert False, 'expected ValueError'

    def test_single_argument_raise(self):
        def f1(x, y):
            raise ValueError
        pool = self.mk_pool()
        check = self._check_single_arg_raise
        yield check, lambda: pool.map(f1, [1], [2])
        yield check, lambda: pool.imap(f1, [1], [2])
        yield check, lambda: pool.starmap(f1, [(1, 2)])
        yield check, lambda: pool.starcall([(f1, 1, 2)])

    def _check_single_arg_result_object(self, func):
        result = list(func())
        assert result[0].result == None
        assert isinstance(result[0].exception[1], ValueError)

    def test_single_argument_result_object(self):
        def f1(x, y):
            raise ValueError
        pool = self.mk_pool()
        check = self._check_single_arg_result_object
        yield check, lambda: pool.map(f1, [1], [2], use_result_objects=True)
        yield check, lambda: pool.imap(f1, [1], [2], use_result_objects=True)
        yield check, lambda: pool.starmap(f1, [(1, 2)], use_result_objects=True)
        yield check, lambda: pool.starcall([(f1, 1, 2)], use_result_objects=True)


    def _check_multiple_args(self, func):
        result = list(func())
        eq_(result, [3, 5])

    def test_multiple_arguments(self):
        f1 = lambda x, y: x+y
        pool = self.mk_pool()
        check = self._check_multiple_args
        yield check, lambda: pool.map(f1, [1, 2], [2, 3])
        yield check, lambda: pool.imap(f1, [1, 2], [2, 3])
        yield check, lambda: pool.starmap(f1, [(1, 2), (2, 3)])
        yield check, lambda: pool.starcall([(f1, 1, 2), (f1, 2, 3)])

    def _check_multiple_args_with_exceptions_result_object(self, func):
        result = list(func())
        eq_(result[0].result, 3)
        eq_(type(result[1].exception[1]), ValueError)
        eq_(result[2].result, 7)

    def test_multiple_arguments_exceptions_result_object(self):
        def f1(x, y):
            if x+y == 5:
                raise ValueError()
            return x+y
        pool = self.mk_pool()
        check = self._check_multiple_args_with_exceptions_result_object
        yield check, lambda: pool.map(f1, [1, 2, 3], [2, 3, 4], use_result_objects=True)
        yield check, lambda: pool.imap(f1, [1, 2, 3], [2, 3, 4], use_result_objects=True)
        yield check, lambda: pool.starmap(f1, [(1, 2), (2, 3), (3, 4)], use_result_objects=True)
        yield check, lambda: pool.starcall([(f1, 1, 2), (f1, 2, 3), (f1, 3, 4)], use_result_objects=True)

    def _check_multiple_args_with_exceptions(self, func):
        result = func()
        try:
            # first result might aleady raise the exception when
            # when second result is returned faster by the ThreadPoolWorker
            eq_(result.next(), 3)
            result.next()
        except ValueError:
            pass
        else:
            assert False, 'expected ValueError'

    def test_multiple_arguments_exceptions(self):
        def f1(x, y):
            if x+y == 5:
                raise ValueError()
            return x+y
        pool = self.mk_pool()
        check = self._check_multiple_args_with_exceptions

        def check_pool_map():
            try:
                pool.map(f1, [1, 2, 3], [2, 3, 4])
            except ValueError:
                pass
            else:
                assert False, 'expected ValueError'
        yield check_pool_map
        yield check, lambda: pool.imap(f1, [1, 2, 3], [2, 3, 4])
        yield check, lambda: pool.starmap(f1, [(1, 2), (2, 3), (3, 4)])
        yield check, lambda: pool.starcall([(f1, 1, 2), (f1, 2, 3), (f1, 3, 4)])



class TestThreadPool(CommonPoolTests):
    def mk_pool(self):
        return ThreadPool()

    def test_base_config(self):
        # test that all concurrent have access to their
        # local base_config
        from mapproxy.config import base_config
        from mapproxy.config import local_base_config
        from copy import deepcopy

        # make two separate base_configs
        conf1 = deepcopy(base_config())
        conf1.conf = 1
        conf2 = deepcopy(base_config())
        conf2.conf = 2
        base_config().bar = 'baz'

        # run test in parallel, check1 and check2 should interleave
        # each with their local conf

        error_occured = False

        def check1(x):
            global error_occured
            if base_config().conf != 1 or 'bar' in base_config():
                error_occured = True

        def check2(x):
            global error_occured
            if base_config().conf != 2 or 'bar' in base_config():
                error_occured = True

        assert 'bar' in base_config()

        def test1():
            with local_base_config(conf1):
                pool1 = ThreadPool(5)
                list(pool1.imap(check1, range(200)))

        def test2():
            with local_base_config(conf2):
                pool2 = ThreadPool(5)
                list(pool2.imap(check2, range(200)))

        t1 = threading.Thread(target=test1)
        t2 = threading.Thread(target=test2)
        t1.start()
        t2.start()
        t1.join()
        t2.join()
        assert not error_occured
        assert 'bar' in base_config()


class TestEventletPool(CommonPoolTests):
    def setup(self):
        if not _has_eventlet:
            raise SkipTest('eventlet required')

    def mk_pool(self):
        if not _has_eventlet:
            raise SkipTest('eventlet required')
        return EventletPool()

    def test_base_config(self):
        # test that all concurrent have access to their
        # local base_config
        from mapproxy.config import base_config
        from mapproxy.config import local_base_config
        from copy import deepcopy

        # make two separate base_configs
        conf1 = deepcopy(base_config())
        conf1.conf = 1
        conf2 = deepcopy(base_config())
        conf2.conf = 2
        base_config().bar = 'baz'

        # run test in parallel, check1 and check2 should interleave
        # each with their local conf

        error_occured = False

        def check1(x):
            global error_occured
            if base_config().conf != 1 or 'bar' in base_config():
                error_occured = True

        def check2(x):
            global error_occured
            if base_config().conf != 2 or 'bar' in base_config():
                error_occured = True

        assert 'bar' in base_config()

        def test1():
            with local_base_config(conf1):
                pool1 = EventletPool(5)
                list(pool1.imap(check1, range(200)))

        def test2():
            with local_base_config(conf2):
                pool2 = EventletPool(5)
                list(pool2.imap(check2, range(200)))

        t1 = eventlet.spawn(test1)
        t2 = eventlet.spawn(test2)
        t1.wait()
        t2.wait()
        assert not error_occured
        assert 'bar' in base_config()


class DummyException(Exception):
    pass

class TestThreadedExecutorException(object):
    def setup(self):
        self.lock = threading.Lock()
        self.exec_count = 0
        self.te = ThreadPool(size=2)
    def execute(self, x):
        time.sleep(0.005)
        with self.lock:
            self.exec_count += 1
            if self.exec_count == 7:
                raise DummyException()
        return x
    def test_execute_w_exception(self):
        try:
            self.te.map(self.execute, range(100))
        except DummyException:
            print self.exec_count
            assert 7 <= self.exec_count <= 10, 'execution should be interrupted really '\
                                               'soon (exec_count should be 7+(max(3)))'
        else:
            assert False, 'expected DummyException'


########NEW FILE########
__FILENAME__ = test_auth
from mapproxy.grid import tile_grid
from mapproxy.layer import MapLayer, DefaultMapExtent
from mapproxy.image import BlankImageSource
from mapproxy.image.opts import ImageOptions
from mapproxy.request.base import Request
from mapproxy.exception import RequestError
from mapproxy.request.wms import wms_request
from mapproxy.request.tile import tile_request
from mapproxy.service.wms import WMSLayer, WMSGroupLayer, WMSServer
from mapproxy.service.tile import TileServer
from mapproxy.service.kml import KMLServer, kml_request
from mapproxy.test.http import make_wsgi_env
from nose.tools import raises, eq_

class DummyLayer(MapLayer):
    transparent = True
    extent = DefaultMapExtent()
    has_legend = False
    queryable = False
    def __init__(self, name):
        MapLayer.__init__(self)
        self.name = name
        self.requested = False
        self.queried = False
    def get_map(self, query):
        self.requested = True
    def get_info(self, query):
        self.queried = True
    def map_layers_for_query(self, query):
        return [(self.name, self)]
    def info_layers_for_query(self, query):
        return [(self.name, self)]

MAP_REQ = "FORMAT=image%2Fpng&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&STYLES=&SRS=EPSG%3A4326&BBOX=5,46,8,48&WIDTH=60&HEIGHT=40"
FI_REQ = "FORMAT=image%2Fpng&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetFeatureInfo&STYLES=&SRS=EPSG%3A4326&BBOX=5,46,8,48&WIDTH=60&HEIGHT=40&X=30&Y=20"

class TestWMSAuth(object):
    def setup(self):
        layers = {}
        wms_layers = {}

        # create test layer tree
        # - unnamed root
        #     - layer1
        #       - layer1a
        #       - layer1b
        #     - layer2
        #       - layer2a
        #       - layer2b
        #         - layer2b1

        layers['layer1a'] = DummyLayer('layer1a')
        wms_layers['layer1a'] = WMSLayer('layer1a', None, [layers['layer1a']],
                                         info_layers=[layers['layer1a']])
        layers['layer1b'] = DummyLayer('layer1b')
        wms_layers['layer1b'] = WMSLayer('layer1b', None, [layers['layer1b']],
                                         info_layers=[layers['layer1b']])
        wms_layers['layer1'] = WMSGroupLayer('layer1', None, None,
                                             [wms_layers['layer1a'], wms_layers['layer1b']])


        layers['layer2a'] = DummyLayer('layer2a')
        wms_layers['layer2a'] = WMSLayer('layer2a', None, [layers['layer2a']],
                                         info_layers=[layers['layer2a']])
        layers['layer2b1'] = DummyLayer('layer2b1')
        wms_layers['layer2b1'] = WMSLayer('layer2b1', None, [layers['layer2b1']],
                                          info_layers=[layers['layer2b1']])
        layers['layer2b'] = DummyLayer('layer2b')
        wms_layers['layer2b'] = WMSGroupLayer('layer2b', None, layers['layer2b'],
                                              [wms_layers['layer2b1']])
        wms_layers['layer2'] = WMSGroupLayer('layer2', None, None,
                                             [wms_layers['layer2a'], wms_layers['layer2b']])

        root_layer = WMSGroupLayer(None, 'root layer', None, [wms_layers['layer1'],
                                                  wms_layers['layer2']])
        self.wms_layers = wms_layers
        self.layers = layers
        self.server = WMSServer(md={}, root_layer=root_layer, srs=['EPSG:4326'],
            image_formats={'image/png': ImageOptions(format='image/png')})


# ###
# see mapproxy.test.system.test_auth for WMS GetCapabilities request tests
# ###

class TestWMSGetMapAuth(TestWMSAuth):
    def map_request(self, layers, auth):
        env = make_wsgi_env(MAP_REQ+'&layers=' + layers, extra_environ={'mapproxy.authorize': auth})
        req = Request(env)
        return wms_request(req)

    def test_allow_all(self):
        def auth(service, layers, **kw):
            eq_(layers, 'layer1a layer1b'.split())
            return { 'authorized': 'full' }
        self.server.map(self.map_request('layer1', auth))
        assert self.layers['layer1a'].requested
        assert self.layers['layer1b'].requested

    def test_root_with_partial_sublayers(self):
        # filter out sublayer layer1b
        def auth(service, layers, **kw):
            eq_(layers, 'layer1a layer1b'.split())
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'map': True},
                    'layer1a': {'map': True},
                    'layer1b': {'map': False},
                }
            }
        self.server.map(self.map_request('layer1', auth))
        assert self.layers['layer1a'].requested
        assert not self.layers['layer1b'].requested

    def test_accept_sublayer(self):
        def auth(service, layers, **kw):
            eq_(layers, 'layer1a'.split())
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'map': True},
                    'layer1a': {'map': True},
                    'layer1b': {'map': False},
                }
            }
        self.server.map(self.map_request('layer1a', auth))
        assert self.layers['layer1a'].requested
        assert not self.layers['layer1b'].requested

    def test_accept_sublayer_w_root_denied(self):
        def auth(service, layers, **kw):
            eq_(layers, 'layer1a'.split())
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'map': False},
                    'layer1a': {'map': True},
                    'layer1b': {'map': False},
                }
            }
        self.server.map(self.map_request('layer1a', auth))
        assert self.layers['layer1a'].requested
        assert not self.layers['layer1b'].requested

    @raises(RequestError)
    def test_deny_sublayer(self):
        def auth(service, layers, **kw):
            eq_(layers, 'layer1b'.split())
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'map': True},
                    'layer1a': {'map': True},
                    'layer1b': {'map': False},
                }
            }
        self.server.map(self.map_request('layer1b', auth))

    @raises(RequestError)
    def test_deny_group_layer_w_source(self):
        def auth(service, layers, **kw):
            eq_(layers, 'layer2b'.split())
            return {
                'authorized': 'partial',
                'layers': {
                    'layer2b': {'map': False},
                }
            }
        self.server.map(self.map_request('layer2b', auth))

    def test_nested_layers_with_partial_sublayers(self):
        def auth(service, layers, **kw):
            eq_(layers, 'layer1a layer1b layer2a layer2b'.split())
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1a': {'map': False},
                    # deny is the default
                    #'layer1b': {'map': False},
                    'layer2a': {'map': True},
                    'layer2b': {'map': False},
                }
            }
        self.server.map(self.map_request('layer1,layer2', auth))
        assert self.layers['layer2a'].requested
        assert not self.layers['layer2b'].requested
        assert not self.layers['layer1a'].requested
        assert not self.layers['layer1b'].requested

    def test_unauthenticated(self):
        def auth(service, layers, **kw):
            eq_(layers, 'layer1b'.split())
            return {
                'authorized': 'unauthenticated',
            }
        try:
            self.server.map(self.map_request('layer1b', auth))
        except RequestError, ex:
            assert ex.status == 401, '%s != 401' % (ex.status, )
        else:
            assert False, 'expected RequestError'

class TestWMSGetFeatureInfoAuth(TestWMSAuth):
    def fi_request(self, layers, auth):
        env = make_wsgi_env(FI_REQ+'&layers=%s&query_layers=%s' % (layers, layers),
                            extra_environ={'mapproxy.authorize': auth})
        req = Request(env)
        return wms_request(req)

    def test_root_with_partial_sublayers(self):
        # filter out sublayer layer1b
        def auth(service, layers, **kw):
            eq_(layers, 'layer1a layer1b'.split())
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'featureinfo': True},
                    'layer1a': {'featureinfo': True},
                    'layer1b': {'featureinfo': False},
                }
            }
        self.server.featureinfo(self.fi_request('layer1', auth))
        assert self.layers['layer1a'].queried
        assert not self.layers['layer1b'].queried

    def test_accept_sublayer(self):
        def auth(service, layers, **kw):
            eq_(layers, 'layer1a'.split())
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'featureinfo': True},
                    'layer1a': {'featureinfo': True},
                    'layer1b': {'featureinfo': False},
                }
            }
        self.server.featureinfo(self.fi_request('layer1a', auth))
        assert self.layers['layer1a'].queried
        assert not self.layers['layer1b'].queried

    def test_accept_sublayer_w_root_denied(self):
        def auth(service, layers, **kw):
            eq_(layers, 'layer1a'.split())
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'featureinfo': False},
                    'layer1a': {'featureinfo': True},
                    'layer1b': {'featureinfo': False},
                }
            }
        self.server.featureinfo(self.fi_request('layer1a', auth))
        assert self.layers['layer1a'].queried
        assert not self.layers['layer1b'].queried

    @raises(RequestError)
    def test_deny_sublayer(self):
        def auth(service, layers, **kw):
            eq_(layers, 'layer1b'.split())
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'featureinfo': True},
                    'layer1a': {'featureinfo': True},
                    'layer1b': {'featureinfo': False},
                }
            }
        self.server.featureinfo(self.fi_request('layer1b', auth))

    @raises(RequestError)
    def test_deny_group_layer_w_source(self):
        def auth(service, layers, **kw):
            eq_(layers, 'layer2b'.split())
            return {
                'authorized': 'partial',
                'layers': {
                    'layer2b': {'featureinfo': False},
                }
            }
        self.server.featureinfo(self.fi_request('layer2b', auth))

    def test_nested_layers_with_partial_sublayers(self):
        def auth(service, layers, **kw):
            eq_(layers, 'layer1a layer1b layer2a layer2b'.split())
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1a': {'featureinfo': False},
                    # deny is the default
                    #'layer1b': {'featureinfo': False},
                    'layer2a': {'featureinfo': True},
                    'layer2b': {'featureinfo': False},
                }
            }
        self.server.featureinfo(self.fi_request('layer1,layer2', auth))
        assert self.layers['layer2a'].queried
        assert not self.layers['layer2b'].queried
        assert not self.layers['layer1a'].queried
        assert not self.layers['layer1b'].queried


class DummyTileLayer(object):
    def __init__(self, name):
        self.requested = False
        self.name = name
        self.grid = tile_grid(900913)

    def tile_bbox(self, request, use_profiles=False):
        # this dummy code does not handle profiles and different tile origins!
        return self.grid.tile_bbox(request.tile)

    def render(self, tile_request, use_profiles=None, coverage=None, decorate_img=None):
        self.requested = True
        resp = BlankImageSource((256, 256), image_opts=ImageOptions(format='image/png'))
        resp.timestamp = 0
        return resp

class TestTMSAuth(object):
    service = 'tms'
    def setup(self):
        self.layers = {}

        self.layers['layer1'] = DummyTileLayer('layer1')
        self.layers['layer2'] = DummyTileLayer('layer2')
        self.layers['layer3'] = DummyTileLayer('layer3')
        self.server = TileServer(self.layers, {})

    def tile_request(self, tile, auth):
        env = make_wsgi_env('', extra_environ={'mapproxy.authorize': auth,
                                               'PATH_INFO': '/tms/1.0.0/'+tile})
        req = Request(env)
        return tile_request(req)

    @raises(RequestError)
    def test_deny_all(self):
        def auth(service, layers, **kw):
            eq_(service, self.service)
            eq_(layers, 'layer1'.split())
            return {
                'authorized': 'none',
            }
        self.server.map(self.tile_request('layer1/0/0/0.png', auth))

    @raises(RequestError)
    def test_deny_layer(self):
        def auth(service, layers, **kw):
            eq_(service, self.service)
            eq_(layers, 'layer1'.split())
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'tile': False},
                    'layer2': {'tile': True},
                }
            }
        self.server.map(self.tile_request('layer1/0/0/0.png', auth))

    def test_allow_all(self):
        def auth(service, layers, **kw):
            eq_(service, self.service)
            eq_(layers, 'layer1'.split())
            return {
                'authorized': 'full',
            }
        self.server.map(self.tile_request('layer1/0/0/0.png', auth))
        assert self.layers['layer1'].requested

    def test_allow_layer(self):
        def auth(service, layers, **kw):
            eq_(service, self.service)
            eq_(layers, 'layer1'.split())
            return {
                'authorized': 'partial',
                'layers': {
                    'layer1': {'tile': True},
                    'layer2': {'tile': False},
                }
            }
        self.server.map(self.tile_request('layer1/0/0/0.png', auth))
        assert self.layers['layer1'].requested

class TestTileAuth(TestTMSAuth):
    def tile_request(self, tile, auth):
        env = make_wsgi_env('', extra_environ={'mapproxy.authorize': auth,
                                               'PATH_INFO': '/tiles/'+tile})
        req = Request(env)
        return tile_request(req)

class TestKMLAuth(TestTMSAuth):
    service = 'kml'
    def setup(self):
        TestTMSAuth.setup(self)
        self.server = KMLServer(self.layers, {})

    def tile_request(self, tile, auth):
        env = make_wsgi_env('', extra_environ={'mapproxy.authorize': auth,
                                               'PATH_INFO': '/kml/'+tile})
        req = Request(env)
        return kml_request(req)

########NEW FILE########
__FILENAME__ = test_cache
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os
import re
import time
import threading
import shutil
import tempfile

from StringIO import StringIO
from mapproxy.platform.image import Image

from mapproxy.layer import (
    CacheMapLayer,
    SRSConditional,
    ResolutionConditional,
    DirectMapLayer,
    MapExtent,
    MapQuery,
)
from mapproxy.source import InvalidSourceQuery, SourceError
from mapproxy.client.wms import WMSClient
from mapproxy.source.wms import WMSSource
from mapproxy.source.tile import TiledSource
from mapproxy.cache.file import FileCache
from mapproxy.cache.tile import Tile, TileManager

from mapproxy.grid import TileGrid, resolution_range
from mapproxy.srs import SRS
from mapproxy.client.http import HTTPClient
from mapproxy.image import ImageSource
from mapproxy.image.opts import ImageOptions
from mapproxy.layer import BlankImage, MapLayer, MapBBOXError
from mapproxy.request.wms import WMS111MapRequest
from mapproxy.util.coverage import BBOXCoverage

from mapproxy.test.image import create_debug_img, is_png, tmp_image
from mapproxy.test.http import assert_query_eq, query_eq, mock_httpd

from collections import defaultdict

from nose.tools import eq_, raises, assert_not_equal, assert_raises

TEST_SERVER_ADDRESS = ('127.0.0.1', 56413)
GLOBAL_GEOGRAPHIC_EXTENT = MapExtent((-180, -90, 180, 90), SRS(4326))

tmp_lock_dir = None
def setup():
    global tmp_lock_dir
    tmp_lock_dir = tempfile.mkdtemp()

def teardown():
    shutil.rmtree(tmp_lock_dir)

class counting_set(object):
    def __init__(self, items):
        self.data = defaultdict(int)
        for item in items:
            self.data[item] += 1
    def add(self, item):
        self.data[item] += 1

    def __repr__(self):
        return 'counting_set(%r)' % dict(self.data)

    def __eq__(self, other):
        return self.data == other.data

class MockTileClient(object):
    def __init__(self):
        self.requested_tiles = []

    def get_tile(self, tile_coord, format=None):
        self.requested_tiles.append(tile_coord)
        return ImageSource(create_debug_img((256, 256)))

class TestTiledSourceGlobalGeodetic(object):
    def setup(self):
        self.grid = TileGrid(SRS(4326), bbox=[-180, -90, 180, 90])
        self.client = MockTileClient()
        self.source = TiledSource(self.grid, self.client)
    def test_match(self):
        self.source.get_map(MapQuery([-180, -90, 0, 90], (256, 256), SRS(4326)))
        self.source.get_map(MapQuery([0, -90, 180, 90], (256, 256), SRS(4326)))
        eq_(self.client.requested_tiles, [(0, 0, 1), (1, 0, 1)])
    @raises(InvalidSourceQuery)
    def test_wrong_size(self):
        self.source.get_map(MapQuery([-180, -90, 0, 90], (512, 256), SRS(4326)))
    @raises(InvalidSourceQuery)
    def test_wrong_srs(self):
        self.source.get_map(MapQuery([-180, -90, 0, 90], (512, 256), SRS(4326)))

class MockFileCache(FileCache):
    def __init__(self, *args, **kw):
        super(MockFileCache, self).__init__(*args, **kw)
        self.stored_tiles = set()
        self.loaded_tiles = counting_set([])

    def store_tile(self, tile):
        assert tile.coord not in self.stored_tiles
        self.stored_tiles.add(tile.coord)
        if self.cache_dir != '/dev/null':
            FileCache.store_tile(self, tile)

    def load_tile(self, tile, with_metadata=False):
        self.loaded_tiles.add(tile.coord)
        return FileCache.load_tile(self, tile, with_metadata)

    def is_cached(self, tile):
        return tile.coord in self.stored_tiles


def create_cached_tile(tile, cache, timestamp=None):
    loc = cache.tile_location(tile, create_dir=True)
    with open(loc, 'w') as f:
        f.write('foo')

    if timestamp:
        os.utime(loc, (timestamp, timestamp))


class TestTileManagerStaleTiles(object):
    def setup(self):
        self.cache_dir = tempfile.mkdtemp()
        self.file_cache = FileCache(cache_dir=self.cache_dir, file_ext='png')
        self.grid = TileGrid(SRS(4326), bbox=[-180, -90, 180, 90])
        self.client = MockTileClient()
        self.source = TiledSource(self.grid, self.client)
        self.tile_mgr = TileManager(self.grid, self.file_cache, [self.source], 'png')
    def teardown(self):
        shutil.rmtree(self.cache_dir)

    def test_is_stale_missing(self):
        assert not self.tile_mgr.is_stale(Tile((0, 0, 1)))

    def test_is_stale_not_expired(self):
        create_cached_tile(Tile((0, 0, 1)), self.file_cache)
        assert not self.tile_mgr.is_stale(Tile((0, 0, 1)))

    def test_is_stale_expired(self):
        create_cached_tile(Tile((0, 0, 1)), self.file_cache, timestamp=time.time()-3600)
        self.tile_mgr._expire_timestamp = time.time()
        assert self.tile_mgr.is_stale(Tile((0, 0, 1)))


class TestTileManagerRemoveTiles(object):
    def setup(self):
        self.cache_dir = tempfile.mkdtemp()
        self.file_cache = FileCache(cache_dir=self.cache_dir, file_ext='png')
        self.grid = TileGrid(SRS(4326), bbox=[-180, -90, 180, 90])
        self.client = MockTileClient()
        self.source = TiledSource(self.grid, self.client)
        self.image_opts = ImageOptions(format='image/png')
        self.tile_mgr = TileManager(self.grid, self.file_cache, [self.source], 'png',
            image_opts=self.image_opts)
    def teardown(self):
        shutil.rmtree(self.cache_dir)

    def test_remove_missing(self):
        self.tile_mgr.remove_tile_coords([(0, 0, 0), (0, 0, 1)])

    def test_remove_existing(self):
        create_cached_tile(Tile((0, 0, 1)), self.file_cache)
        assert self.tile_mgr.is_cached(Tile((0, 0, 1)))
        self.tile_mgr.remove_tile_coords([(0, 0, 0), (0, 0, 1)])
        assert not self.tile_mgr.is_cached(Tile((0, 0, 1)))

class TestTileManagerTiledSource(object):
    def setup(self):
        self.file_cache = MockFileCache('/dev/null', 'png', lock_dir=tmp_lock_dir)
        self.grid = TileGrid(SRS(4326), bbox=[-180, -90, 180, 90])
        self.client = MockTileClient()
        self.source = TiledSource(self.grid, self.client)
        self.image_opts = ImageOptions(format='image/png')
        self.tile_mgr = TileManager(self.grid, self.file_cache, [self.source], 'png',
            image_opts=self.image_opts)

    def test_create_tiles(self):
        self.tile_mgr.creator().create_tiles([Tile((0, 0, 1)), Tile((1, 0, 1))])
        eq_(self.file_cache.stored_tiles, set([(0, 0, 1), (1, 0, 1)]))
        eq_(sorted(self.client.requested_tiles), [(0, 0, 1), (1, 0, 1)])

class TestTileManagerDifferentSourceGrid(object):
    def setup(self):
        self.file_cache = MockFileCache('/dev/null', 'png', lock_dir=tmp_lock_dir)
        self.grid = TileGrid(SRS(4326), bbox=[-180, -90, 180, 90])
        self.source_grid = TileGrid(SRS(4326), bbox=[0, -90, 180, 90])
        self.client = MockTileClient()
        self.source = TiledSource(self.source_grid, self.client)
        self.image_opts = ImageOptions(format='image/png')
        self.tile_mgr = TileManager(self.grid, self.file_cache, [self.source], 'png',
            image_opts=self.image_opts)

    def test_create_tiles(self):
        self.tile_mgr.creator().create_tiles([Tile((1, 0, 1))])
        eq_(self.file_cache.stored_tiles, set([(1, 0, 1)]))
        eq_(self.client.requested_tiles, [(0, 0, 0)])

    @raises(InvalidSourceQuery)
    def test_create_tiles_out_of_bounds(self):
        self.tile_mgr.creator().create_tiles([Tile((0, 0, 0))])

class MockSource(MapLayer):
    def __init__(self, *args):
        MapLayer.__init__(self, *args)
        self.requested = []

    def _image(self, size):
        return create_debug_img(size)

    def get_map(self, query):
        self.requested.append((query.bbox, query.size, query.srs))
        return ImageSource(self._image(query.size))

class TestTileManagerSource(object):
    def setup(self):
        self.file_cache = MockFileCache('/dev/null', 'png', lock_dir=tmp_lock_dir)
        self.grid = TileGrid(SRS(4326), bbox=[-180, -90, 180, 90])
        self.source = MockSource()
        self.image_opts = ImageOptions(format='image/png')
        self.tile_mgr = TileManager(self.grid, self.file_cache, [self.source], 'png',
            image_opts=self.image_opts)

    def test_create_tile(self):
        self.tile_mgr.creator().create_tiles([Tile((0, 0, 1)), Tile((1, 0, 1))])
        eq_(self.file_cache.stored_tiles, set([(0, 0, 1), (1, 0, 1)]))
        eq_(sorted(self.source.requested),
            [((-180.0, -90.0, 0.0, 90.0), (256, 256), SRS(4326)),
             ((0.0, -90.0, 180.0, 90.0), (256, 256), SRS(4326))])

class MockWMSClient(object):
    def __init__(self):
        self.requested = []

    def retrieve(self, query, format):
        self.requested.append((query.bbox, query.size, query.srs))
        return create_debug_img(query.size)

class TestTileManagerWMSSource(object):
    def setup(self):
        self.file_cache = MockFileCache('/dev/null', 'png', lock_dir=tmp_lock_dir)
        self.grid = TileGrid(SRS(4326), bbox=[-180, -90, 180, 90])
        self.client = MockWMSClient()
        self.source = WMSSource(self.client)
        self.image_opts = ImageOptions(format='image/png')
        self.tile_mgr = TileManager(self.grid, self.file_cache, [self.source], 'png',
            meta_size=[2, 2], meta_buffer=0, image_opts=self.image_opts)

    def test_same_lock_for_meta_tile(self):
        eq_(self.tile_mgr.lock(Tile((0, 0, 1))).lock_file,
            self.tile_mgr.lock(Tile((1, 0, 1))).lock_file
        )
    def test_locks_for_meta_tiles(self):
        assert_not_equal(self.tile_mgr.lock(Tile((0, 0, 2))).lock_file,
                         self.tile_mgr.lock(Tile((2, 0, 2))).lock_file
        )

    def test_create_tile_first_level(self):
        self.tile_mgr.creator().create_tiles([Tile((0, 0, 1)), Tile((1, 0, 1))])
        eq_(self.file_cache.stored_tiles, set([(0, 0, 1), (1, 0, 1)]))
        eq_(self.client.requested,
            [((-180.0, -90.0, 180.0, 90.0), (512, 256), SRS(4326))])

    def test_create_tile(self):
        self.tile_mgr.creator().create_tiles([Tile((0, 0, 2))])
        eq_(self.file_cache.stored_tiles,
            set([(0, 0, 2), (1, 0, 2), (0, 1, 2), (1, 1, 2)]))
        eq_(sorted(self.client.requested),
            [((-180.0, -90.0, 0.0, 90.0), (512, 512), SRS(4326))])

    def test_create_tiles(self):
        self.tile_mgr.creator().create_tiles([Tile((0, 0, 2)), Tile((2, 0, 2))])
        eq_(self.file_cache.stored_tiles,
            set([(0, 0, 2), (1, 0, 2), (0, 1, 2), (1, 1, 2),
                 (2, 0, 2), (3, 0, 2), (2, 1, 2), (3, 1, 2)]))
        eq_(sorted(self.client.requested),
            [((-180.0, -90.0, 0.0, 90.0), (512, 512), SRS(4326)),
             ((0.0, -90.0, 180.0, 90.0), (512, 512), SRS(4326))])

    def test_load_tile_coords(self):
        tiles = self.tile_mgr.load_tile_coords(((0, 0, 2), (2, 0, 2)))
        eq_(tiles[0].coord, (0, 0, 2))
        assert isinstance(tiles[0].source, ImageSource)
        eq_(tiles[1].coord, (2, 0, 2))
        assert isinstance(tiles[1].source, ImageSource)

        eq_(self.file_cache.stored_tiles,
            set([(0, 0, 2), (1, 0, 2), (0, 1, 2), (1, 1, 2),
                 (2, 0, 2), (3, 0, 2), (2, 1, 2), (3, 1, 2)]))
        eq_(sorted(self.client.requested),
            [((-180.0, -90.0, 0.0, 90.0), (512, 512), SRS(4326)),
             ((0.0, -90.0, 180.0, 90.0), (512, 512), SRS(4326))])


class TestTileManagerWMSSourceMinimalMetaRequests(object):
    def setup(self):
        self.file_cache = MockFileCache('/dev/null', 'png', lock_dir=tmp_lock_dir)
        self.grid = TileGrid(SRS(4326), bbox=[-180, -90, 180, 90])
        self.client = MockWMSClient()
        self.source = WMSSource(self.client)
        self.tile_mgr = TileManager(self.grid, self.file_cache, [self.source], 'png',
            meta_size=[2, 2], meta_buffer=10, minimize_meta_requests=True)

    def test_create_tile_single(self):
        # not enabled for single tile requests
        self.tile_mgr.creator().create_tiles([Tile((0, 0, 2))])
        eq_(self.file_cache.stored_tiles,
            set([(0, 0, 2), (0, 1, 2), (1, 0, 2), (1, 1, 2)]))
        eq_(sorted(self.client.requested),
            [((-180.0, -90.0, 3.515625, 90.0), (522, 512), SRS(4326))])

    def test_create_tile_multiple(self):
        self.tile_mgr.creator().create_tiles([Tile((4, 0, 3)), Tile((4, 1, 3)), Tile((4, 2, 3))])
        eq_(self.file_cache.stored_tiles,
            set([(4, 0, 3), (4, 1, 3), (4, 2, 3)]))
        eq_(sorted(self.client.requested),
            [((-1.7578125, -90, 46.7578125, 46.7578125), (276, 778), SRS(4326))])

    def test_create_tile_multiple_fragmented(self):
        self.tile_mgr.creator().create_tiles([Tile((4, 0, 3)), Tile((5, 2, 3))])
        eq_(self.file_cache.stored_tiles,
            set([(4, 0, 3), (4, 1, 3), (4, 2, 3), (5, 0, 3), (5, 1, 3), (5, 2, 3)]))
        eq_(sorted(self.client.requested),
            [((-1.7578125, -90, 91.7578125, 46.7578125), (532, 778), SRS(4326))])

class SlowMockSource(MockSource):
    supports_meta_tiles = True
    def get_map(self, query):
        time.sleep(0.1)
        return MockSource.get_map(self, query)

class TestTileManagerLocking(object):
    def setup(self):
        self.tile_dir = tempfile.mkdtemp()
        self.file_cache = MockFileCache(self.tile_dir, 'png', lock_dir=tmp_lock_dir)
        self.grid = TileGrid(SRS(4326), bbox=[-180, -90, 180, 90])
        self.source = SlowMockSource()
        self.image_opts = ImageOptions(format='image/png')
        self.tile_mgr = TileManager(self.grid, self.file_cache, [self.source], 'png',
            meta_size=[2, 2], meta_buffer=0, image_opts=self.image_opts)

    def test_get_single(self):
        self.tile_mgr.creator().create_tiles([Tile((0, 0, 1)), Tile((1, 0, 1))])
        eq_(self.file_cache.stored_tiles, set([(0, 0, 1), (1, 0, 1)]))
        eq_(self.source.requested,
            [((-180.0, -90.0, 180.0, 90.0), (512, 256), SRS(4326))])

    def test_concurrent(self):
        def do_it():
            self.tile_mgr.creator().create_tiles([Tile((0, 0, 1)), Tile((1, 0, 1))])

        threads = [threading.Thread(target=do_it) for _ in range(3)]
        [t.start() for t in threads]
        [t.join() for t in threads]

        eq_(self.file_cache.stored_tiles, set([(0, 0, 1), (1, 0, 1)]))
        eq_(self.file_cache.loaded_tiles, counting_set([(0, 0, 1), (1, 0, 1), (0, 0, 1), (1, 0, 1)]))
        eq_(self.source.requested,
            [((-180.0, -90.0, 180.0, 90.0), (512, 256), SRS(4326))])

        assert os.path.exists(self.file_cache.tile_location(Tile((0, 0, 1))))

    def teardown(self):
        shutil.rmtree(self.tile_dir)


class TestTileManagerMultipleSources(object):
    def setup(self):
        self.file_cache = MockFileCache('/dev/null', 'png', lock_dir=tmp_lock_dir)
        self.grid = TileGrid(SRS(4326), bbox=[-180, -90, 180, 90])
        self.source_base = MockSource()
        self.source_overlay = MockSource()
        self.image_opts = ImageOptions(format='image/png')
        self.tile_mgr = TileManager(self.grid, self.file_cache,
            [self.source_base, self.source_overlay], 'png',
            image_opts=self.image_opts)
        self.layer = CacheMapLayer(self.tile_mgr)

    def test_get_single(self):
        self.tile_mgr.creator().create_tiles([Tile((0, 0, 1))])
        eq_(self.file_cache.stored_tiles, set([(0, 0, 1)]))
        eq_(self.source_base.requested,
            [((-180.0, -90.0, 0.0, 90.0), (256, 256), SRS(4326))])
        eq_(self.source_overlay.requested,
            [((-180.0, -90.0, 0.0, 90.0), (256, 256), SRS(4326))])

class SolidColorMockSource(MockSource):
    def __init__(self, color='#ff0000'):
        MockSource.__init__(self)
        self.color = color
    def _image(self, size):
        return Image.new('RGB', size, self.color)

class TestTileManagerMultipleSourcesWithMetaTiles(object):
    def setup(self):
        self.file_cache = MockFileCache('/dev/null', 'png', lock_dir=tmp_lock_dir)
        self.grid = TileGrid(SRS(4326), bbox=[-180, -90, 180, 90])
        self.source_base = SolidColorMockSource(color='#ff0000')
        self.source_base.supports_meta_tiles = True
        self.source_overlay = MockSource()
        self.source_overlay.supports_meta_tiles = True

        self.tile_mgr = TileManager(self.grid, self.file_cache,
            [self.source_base, self.source_overlay], 'png',
            meta_size=[2, 2], meta_buffer=0)

    def test_merged_tiles(self):
        tiles = self.tile_mgr.creator().create_tiles([Tile((0, 0, 1)), Tile((1, 0, 1))])
        eq_(self.file_cache.stored_tiles, set([(0, 0, 1), (1, 0, 1)]))
        eq_(self.source_base.requested,
            [((-180.0, -90.0, 180.0, 90.0), (512, 256), SRS(4326))])
        eq_(self.source_overlay.requested,
            [((-180.0, -90.0, 180.0, 90.0), (512, 256), SRS(4326))])

        hist = tiles[0].source.as_image().histogram()
        # lots of red (base), but not everything (overlay)
        assert 55000 < hist[255] < 60000 # red   = 0xff
        assert 55000 < hist[256]         # green = 0x00
        assert 55000 < hist[512]         # blue  = 0x00


    @raises(ValueError)
    def test_sources_with_mixed_support_for_meta_tiles(self):
        self.source_base.supports_meta_tiles = False
        self.tile_mgr = TileManager(self.grid, self.file_cache,
            [self.source_base, self.source_overlay], 'png',
            meta_size=[2, 2], meta_buffer=0)

    def test_sources_with_no_support_for_meta_tiles(self):
        self.source_base.supports_meta_tiles = False
        self.source_overlay.supports_meta_tiles = False

        self.tile_mgr = TileManager(self.grid, self.file_cache,
            [self.source_base, self.source_overlay], 'png',
            meta_size=[2, 2], meta_buffer=0)

        assert self.tile_mgr.meta_grid is None

default_image_opts = ImageOptions(resampling='bicubic')

class TestCacheMapLayer(object):
    def setup(self):
        self.file_cache = MockFileCache('/dev/null', 'png', lock_dir=tmp_lock_dir)
        self.grid = TileGrid(SRS(4326), bbox=[-180, -90, 180, 90])
        self.client = MockWMSClient()
        self.source = WMSSource(self.client)
        self.image_opts = ImageOptions(resampling='nearest')
        self.tile_mgr = TileManager(self.grid, self.file_cache, [self.source], 'png',
            meta_size=[2, 2], meta_buffer=0, image_opts=self.image_opts)
        self.layer = CacheMapLayer(self.tile_mgr, image_opts=default_image_opts)

    def test_get_map_small(self):
        result = self.layer.get_map(MapQuery((-180, -90, 180, 90), (300, 150), SRS(4326), 'png'))
        eq_(self.file_cache.stored_tiles, set([(0, 0, 1), (1, 0, 1)]))
        eq_(result.size, (300, 150))

    def test_get_map_large(self):
        # gets next resolution layer
        result = self.layer.get_map(MapQuery((-180, -90, 180, 90), (600, 300), SRS(4326), 'png'))
        eq_(self.file_cache.stored_tiles,
            set([(0, 0, 2), (1, 0, 2), (0, 1, 2), (1, 1, 2),
                 (2, 0, 2), (3, 0, 2), (2, 1, 2), (3, 1, 2)]))
        eq_(result.size, (600, 300))

    def test_transformed(self):
        result = self.layer.get_map(MapQuery(
            (-20037508.34, -20037508.34, 20037508.34, 20037508.34), (500, 500),
            SRS(900913), 'png'))
        eq_(self.file_cache.stored_tiles,
            set([(0, 0, 2), (1, 0, 2), (0, 1, 2), (1, 1, 2),
                 (2, 0, 2), (3, 0, 2), (2, 1, 2), (3, 1, 2)]))
        eq_(result.size, (500, 500))

    def test_single_tile_match(self):
        result = self.layer.get_map(MapQuery(
            (0.001, 0, 90, 90), (256, 256), SRS(4326), 'png', tiled_only=True))
        eq_(self.file_cache.stored_tiles,
            set([(3, 0, 2), (2, 0, 2), (3, 1, 2), (2, 1, 2)]))
        eq_(result.size, (256, 256))

    @raises(MapBBOXError)
    def test_single_tile_no_match(self):
        self.layer.get_map(MapQuery(
            (0.1, 0, 90, 90), (256, 256), SRS(4326), 'png', tiled_only=True))

    def test_get_map_with_res_range(self):
        res_range = resolution_range(1000, 10)
        self.source = WMSSource(self.client, res_range=res_range)
        self.tile_mgr = TileManager(self.grid, self.file_cache, [self.source], 'png',
            meta_size=[2, 2], meta_buffer=0, image_opts=self.image_opts)
        self.layer = CacheMapLayer(self.tile_mgr, image_opts=default_image_opts)

        try:
            result = self.layer.get_map(MapQuery(
                (-20037508.34, -20037508.34, 20037508.34, 20037508.34), (500, 500),
                SRS(900913), 'png'))
        except BlankImage:
            pass
        else:
            assert False, 'expected BlankImage exception'
        eq_(self.file_cache.stored_tiles, set())

        result = self.layer.get_map(MapQuery(
                (0, 0, 10000, 10000), (50, 50),
                SRS(900913), 'png'))
        eq_(self.file_cache.stored_tiles,
            set([(512, 257, 10), (513, 256, 10), (512, 256, 10), (513, 257, 10)]))
        eq_(result.size, (50, 50))

class TestCacheMapLayerWithExtent(object):
    def setup(self):
        self.file_cache = MockFileCache('/dev/null', 'png', lock_dir=tmp_lock_dir)
        self.grid = TileGrid(SRS(4326), bbox=[-180, -90, 180, 90])
        self.client = MockWMSClient()
        self.source = WMSSource(self.client)
        self.image_opts = ImageOptions(resampling='nearest', format='png')
        self.tile_mgr = TileManager(self.grid, self.file_cache, [self.source], 'png',
            meta_size=[1, 1], meta_buffer=0, image_opts=self.image_opts)
        self.layer = CacheMapLayer(self.tile_mgr, image_opts=default_image_opts)
        self.layer.extent = BBOXCoverage([0, 0, 90, 45], SRS(4326)).extent

    def test_get_outside_extent(self):
        assert_raises(BlankImage, self.layer.get_map, MapQuery((-180, -90, 0, 0), (300, 150), SRS(4326), 'png'))

    def test_get_map_small(self):
        result = self.layer.get_map(MapQuery((-180, -90, 180, 90), (300, 150), SRS(4326), 'png'))
        eq_(self.file_cache.stored_tiles, set([(1, 0, 1)]))
        # source requests one tile (no meta-tiling configured)
        eq_(self.client.requested, [((0.0, -90.0, 180.0, 90.0), (256, 256), SRS('EPSG:4326'))])
        eq_(result.size, (300, 150))

    def test_get_map_small_with_source_extent(self):
        self.source.extent = BBOXCoverage([0, 0, 90, 45], SRS(4326)).extent
        result = self.layer.get_map(MapQuery((-180, -90, 180, 90), (300, 150), SRS(4326), 'png'))
        eq_(self.file_cache.stored_tiles, set([(1, 0, 1)]))
        # source requests one tile (no meta-tiling configured) limited to source.extent
        eq_(self.client.requested, [((0, 0, 90, 45), (128, 64), (SRS(4326)))])
        eq_(result.size, (300, 150))

class TestDirectMapLayer(object):
    def setup(self):
        self.client = MockWMSClient()
        self.source = WMSSource(self.client)
        self.layer = DirectMapLayer(self.source, GLOBAL_GEOGRAPHIC_EXTENT)

    def test_get_map(self):
        result = self.layer.get_map(MapQuery((-180, -90, 180, 90), (300, 150), SRS(4326), 'png'))
        eq_(self.client.requested, [((-180, -90, 180, 90), (300, 150), SRS(4326))])
        eq_(result.size, (300, 150))

    def test_get_map_mercator(self):
        result = self.layer.get_map(MapQuery(
            (-20037508.34, -20037508.34, 20037508.34, 20037508.34), (500, 500),
            SRS(900913), 'png'))
        eq_(self.client.requested,
            [((-20037508.34, -20037508.34, 20037508.34, 20037508.34), (500, 500),
              SRS(900913))])
        eq_(result.size, (500, 500))

class TestDirectMapLayerWithSupportedSRS(object):
    def setup(self):
        self.client = MockWMSClient()
        self.source = WMSSource(self.client)
        self.layer = DirectMapLayer(self.source, GLOBAL_GEOGRAPHIC_EXTENT)

    def test_get_map(self):
        result = self.layer.get_map(MapQuery((-180, -90, 180, 90), (300, 150), SRS(4326), 'png'))
        eq_(self.client.requested, [((-180, -90, 180, 90), (300, 150), SRS(4326))])
        eq_(result.size, (300, 150))

    def test_get_map_mercator(self):
        result = self.layer.get_map(MapQuery(
            (-20037508.34, -20037508.34, 20037508.34, 20037508.34), (500, 500),
            SRS(900913), 'png'))
        eq_(self.client.requested,
            [((-20037508.34, -20037508.34, 20037508.34, 20037508.34), (500, 500),
              SRS(900913))])
        eq_(result.size, (500, 500))


class MockHTTPClient(object):
    def __init__(self):
        self.requested = []

    def open(self, url, data=None):
        self.requested.append(url)
        w = int(re.search(r'width=(\d+)', url, re.IGNORECASE).group(1))
        h = int(re.search(r'height=(\d+)', url, re.IGNORECASE).group(1))
        format = re.search(r'format=image(/|%2F)(\w+)', url, re.IGNORECASE).group(2)
        transparent = re.search(r'transparent=(\w+)', url, re.IGNORECASE)
        transparent = True if transparent and transparent.group(1).lower() == 'true' else False
        result = StringIO()
        create_debug_img((int(w), int(h)), transparent).save(result, format=format)
        result.seek(0)
        result.headers = {'Content-type': 'image/'+format}
        return result

class TestWMSSourceTransform(object):
    def setup(self):
        self.http_client = MockHTTPClient()
        self.req_template = WMS111MapRequest(url='http://localhost/service?', param={
            'format': 'image/png', 'layers': 'foo'
        })
        self.client = WMSClient(self.req_template, http_client=self.http_client)
        self.source = WMSSource(self.client, supported_srs=[SRS(4326)],
            image_opts=ImageOptions(resampling='bilinear'))

    def test_get_map(self):
        self.source.get_map(MapQuery((-180, -90, 180, 90), (300, 150), SRS(4326)))
        assert query_eq(self.http_client.requested[0], "http://localhost/service?"
            "layers=foo&width=300&version=1.1.1&bbox=-180,-90,180,90&service=WMS"
            "&format=image%2Fpng&styles=&srs=EPSG%3A4326&request=GetMap&height=150")

    def test_get_map_transformed(self):
        self.source.get_map(MapQuery(
           (556597, 4865942, 1669792, 7361866), (300, 150), SRS(900913)))
        assert_query_eq(self.http_client.requested[0], "http://localhost/service?"
            "layers=foo&width=300&version=1.1.1"
            "&bbox=4.99999592195,39.9999980766,14.999996749,54.9999994175&service=WMS"
            "&format=image%2Fpng&styles=&srs=EPSG%3A4326&request=GetMap&height=450")

class TestWMSSourceWithClient(object):
    def setup(self):
        self.req_template = WMS111MapRequest(
            url='http://%s:%d/service?' % TEST_SERVER_ADDRESS,
            param={'format': 'image/png', 'layers': 'foo'})
        self.client = WMSClient(self.req_template)
        self.source = WMSSource(self.client)

    def test_get_map(self):
        with tmp_image((512, 512)) as img:
            expected_req = ({'path': r'/service?LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
                                     '&REQUEST=GetMap&HEIGHT=512&SRS=EPSG%3A4326&styles='
                                     '&VERSION=1.1.1&BBOX=0.0,10.0,10.0,20.0&WIDTH=512'},
                           {'body': img.read(), 'headers': {'content-type': 'image/png'}})
            with mock_httpd(TEST_SERVER_ADDRESS, [expected_req]):
                q = MapQuery((0.0, 10.0, 10.0, 20.0), (512, 512), SRS(4326))
                result = self.source.get_map(q)
                assert isinstance(result, ImageSource)
                eq_(result.size, (512, 512))
                assert is_png(result.as_buffer(seekable=True))
                eq_(result.as_image().size, (512, 512))
    def test_get_map_non_image_content_type(self):
        with tmp_image((512, 512)) as img:
            expected_req = ({'path': r'/service?LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
                                     '&REQUEST=GetMap&HEIGHT=512&SRS=EPSG%3A4326&styles='
                                     '&VERSION=1.1.1&BBOX=0.0,10.0,10.0,20.0&WIDTH=512'},
                           {'body': img.read(), 'headers': {'content-type': 'text/plain'}})
            with mock_httpd(TEST_SERVER_ADDRESS, [expected_req]):
                q = MapQuery((0.0, 10.0, 10.0, 20.0), (512, 512), SRS(4326))
                try:
                    self.source.get_map(q)
                except SourceError, e:
                    assert 'no image returned' in e.args[0]
                else:
                    assert False, 'no SourceError raised'
    def test_basic_auth(self):
        http_client = HTTPClient(self.req_template.url, username='foo', password='bar@')
        self.client.http_client = http_client
        def assert_auth(req_handler):
            assert 'Authorization' in req_handler.headers
            auth_data = req_handler.headers['Authorization'].split()[1]
            auth_data = auth_data.decode('base64')
            eq_(auth_data, 'foo:bar@')
            return True
        expected_req = ({'path': r'/service?LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
                                  '&REQUEST=GetMap&HEIGHT=512&SRS=EPSG%3A4326'
                                  '&VERSION=1.1.1&BBOX=0.0,10.0,10.0,20.0&WIDTH=512&STYLES=',
                         'require_basic_auth': True,
                         'req_assert_function': assert_auth},
                        {'body': 'no image', 'headers': {'content-type': 'image/png'}})
        with mock_httpd(TEST_SERVER_ADDRESS, [expected_req]):
            q = MapQuery((0.0, 10.0, 10.0, 20.0), (512, 512), SRS(4326))
            self.source.get_map(q)

TESTSERVER_URL = 'http://%s:%d' % TEST_SERVER_ADDRESS

class TestWMSSource(object):
    def setup(self):
        self.req = WMS111MapRequest(url=TESTSERVER_URL + '/service?map=foo', param={'layers':'foo'})
        self.http = MockHTTPClient()
        self.wms = WMSClient(self.req, http_client=self.http)
        self.source = WMSSource(self.wms, supported_srs=[SRS(4326)],
            image_opts=ImageOptions(resampling='bilinear'))
    def test_request(self):
        req = MapQuery((-180.0, -90.0, 180.0, 90.0), (512, 256), SRS(4326), 'png')
        self.source.get_map(req)
        eq_(len(self.http.requested), 1)
        assert_query_eq(self.http.requested[0],
            TESTSERVER_URL+'/service?map=foo&LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
                           '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A4326'
                           '&VERSION=1.1.1&BBOX=-180.0,-90.0,180.0,90.0&WIDTH=512&STYLES=')

    def test_transformed_request(self):
        req = MapQuery((-200000, -200000, 200000, 200000), (512, 512), SRS(900913), 'png')
        resp = self.source.get_map(req)
        eq_(len(self.http.requested), 1)

        assert_query_eq(self.http.requested[0],
            TESTSERVER_URL+'/service?map=foo&LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
                           '&REQUEST=GetMap&HEIGHT=512&SRS=EPSG%3A4326'
                           '&VERSION=1.1.1&WIDTH=512&STYLES='
                           '&BBOX=-1.79663056824,-1.7963362121,1.79663056824,1.7963362121')
        img = resp.as_image()
        assert img.mode in ('P', 'RGB')

    def test_similar_srs(self):
        # request in 3857 and source supports only 900913
        # 3857 and 900913 are equal but the client requests must use 900913
        self.req = WMS111MapRequest(url=TESTSERVER_URL + '/service?map=foo',
                                    param={'layers':'foo', 'transparent': 'true'})
        self.wms = WMSClient(self.req, http_client=self.http)
        self.source = WMSSource(self.wms, supported_srs=[SRS(900913)],
            image_opts=ImageOptions(resampling='bilinear'))
        req = MapQuery((-200000, -200000, 200000, 200000), (512, 512), SRS(3857), 'png')
        self.source.get_map(req)
        eq_(len(self.http.requested), 1)

        assert_query_eq(self.http.requested[0],
            TESTSERVER_URL+'/service?map=foo&LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
                           '&REQUEST=GetMap&HEIGHT=512&SRS=EPSG%3A900913'
                           '&VERSION=1.1.1&WIDTH=512&STYLES=&transparent=true'
                           '&BBOX=-200000,-200000,200000,200000')

    def test_transformed_request_transparent(self):
        self.req = WMS111MapRequest(url=TESTSERVER_URL + '/service?map=foo',
                                    param={'layers':'foo', 'transparent': 'true'})
        self.wms = WMSClient(self.req, http_client=self.http)
        self.source = WMSSource(self.wms, supported_srs=[SRS(4326)],
            image_opts=ImageOptions(resampling='bilinear'))

        req = MapQuery((-200000, -200000, 200000, 200000), (512, 512), SRS(900913), 'png')
        resp = self.source.get_map(req)
        eq_(len(self.http.requested), 1)

        assert_query_eq(self.http.requested[0],
            TESTSERVER_URL+'/service?map=foo&LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
                           '&REQUEST=GetMap&HEIGHT=512&SRS=EPSG%3A4326'
                           '&VERSION=1.1.1&WIDTH=512&STYLES=&transparent=true'
                           '&BBOX=-1.79663056824,-1.7963362121,1.79663056824,1.7963362121')
        img = resp.as_image()
        assert img.mode in ('P', 'RGBA')
        img = img.convert('RGBA')
        eq_(img.getpixel((5, 5))[3], 0)


class MockLayer(object):
    def __init__(self):
        self.requested = []
    def get_map(self, query):
        self.requested.append((query.bbox, query.size, query.srs))

class TestResolutionConditionalLayers(object):
    def setup(self):
        self.low = MockLayer()
        self.low.transparent = False #TODO
        self.high = MockLayer()
        self.layer = ResolutionConditional(self.low, self.high, 10, SRS(900913),
            GLOBAL_GEOGRAPHIC_EXTENT)
    def test_resolution_low(self):
        self.layer.get_map(MapQuery((0, 0, 10000, 10000), (100, 100), SRS(900913)))
        assert self.low.requested
        assert not self.high.requested
    def test_resolution_high(self):
        self.layer.get_map(MapQuery((0, 0, 100, 100), (100, 100), SRS(900913)))
        assert not self.low.requested
        assert self.high.requested
    def test_resolution_match(self):
        self.layer.get_map(MapQuery((0, 0, 10, 10), (100, 100), SRS(900913)))
        assert not self.low.requested
        assert self.high.requested
    def test_resolution_low_transform(self):
        self.layer.get_map(MapQuery((0, 0, 0.1, 0.1), (100, 100), SRS(4326)))
        assert self.low.requested
        assert not self.high.requested
    def test_resolution_high_transform(self):
        self.layer.get_map(MapQuery((0, 0, 0.005, 0.005), (100, 100), SRS(4326)))
        assert not self.low.requested
        assert self.high.requested

class TestSRSConditionalLayers(object):
    def setup(self):
        self.l4326 = MockLayer()
        self.l900913 = MockLayer()
        self.l32632 = MockLayer()
        self.layer = SRSConditional([
            (self.l4326, (SRS('EPSG:4326'),)),
            (self.l900913, (SRS('EPSG:900913'), SRS('EPSG:31467'))),
            (self.l32632, (SRSConditional.PROJECTED,)),
        ], GLOBAL_GEOGRAPHIC_EXTENT)
    def test_srs_match(self):
        assert self.layer._select_layer(SRS(4326)) == self.l4326
        assert self.layer._select_layer(SRS(900913)) == self.l900913
        assert self.layer._select_layer(SRS(31467)) == self.l900913
    def test_srs_match_type(self):
        assert self.layer._select_layer(SRS(31466)) == self.l32632
        assert self.layer._select_layer(SRS(32633)) == self.l32632
    def test_no_match_first_type(self):
        assert self.layer._select_layer(SRS(4258)) == self.l4326

class TestNeastedConditionalLayers(object):
    def setup(self):
        self.direct = MockLayer()
        self.l900913 = MockLayer()
        self.l4326 = MockLayer()
        self.layer = ResolutionConditional(
            SRSConditional([
                (self.l900913, (SRS('EPSG:900913'),)),
                (self.l4326, (SRS('EPSG:4326'),))
            ], GLOBAL_GEOGRAPHIC_EXTENT),
            self.direct, 10, SRS(900913), GLOBAL_GEOGRAPHIC_EXTENT
            )
    def test_resolution_high_900913(self):
        self.layer.get_map(MapQuery((0, 0, 100, 100), (100, 100), SRS(900913)))
        assert self.direct.requested
    def test_resolution_high_4326(self):
        self.layer.get_map(MapQuery((0, 0, 0.0001, 0.0001), (100, 100), SRS(4326)))
        assert self.direct.requested
    def test_resolution_low_4326(self):
        self.layer.get_map(MapQuery((0, 0, 10, 10), (100, 100), SRS(4326)))
        assert self.l4326.requested
    def test_resolution_low_projected(self):
        self.layer.get_map(MapQuery((0, 0, 10000, 10000), (100, 100), SRS(31467)))
        assert self.l900913.requested
########NEW FILE########
__FILENAME__ = test_cache_couchdb
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

import re
import glob
import os
import time
import random

from nose.plugins.skip import SkipTest

from mapproxy.cache.couchdb import CouchDBCache, CouchDBMDTemplate
from mapproxy.cache.tile import Tile
from mapproxy.grid import tile_grid
from mapproxy.test.image import create_tmp_image_buf

from mapproxy.test.unit.test_cache_tile import TileCacheTestBase

from nose.tools import assert_almost_equal, eq_

tile_image = create_tmp_image_buf((256, 256), color='blue')
tile_image2 = create_tmp_image_buf((256, 256), color='red')

class TestCouchDBCache(TileCacheTestBase):
    always_loads_metadata = True
    def setup(self):
        if not os.environ.get('MAPPROXY_TEST_COUCHDB'):
            raise SkipTest()
        
        couch_address = os.environ['MAPPROXY_TEST_COUCHDB']
        db_name = 'mapproxy_test_%d' % random.randint(0, 100000)
        
        TileCacheTestBase.setup(self)
        
        md_template = CouchDBMDTemplate({'row': '{{y}}', 'tile_column': '{{x}}',
            'zoom': '{{level}}', 'time': '{{timestamp}}', 'coord': '{{wgs_tile_centroid}}'})
        self.cache = CouchDBCache(couch_address, db_name, lock_dir=self.cache_dir,
            file_ext='png', tile_grid=tile_grid(3857, name='global-webmarcator'),
            md_template=md_template)

    def teardown(self):
        import requests
        requests.delete(self.cache.couch_url)
        TileCacheTestBase.teardown(self)
    
    def test_store_bulk_with_overwrite(self):
        tile = self.create_tile((0, 0, 4))
        self.create_cached_tile(tile)
        
        assert self.cache.is_cached(Tile((0, 0, 4)))
        loaded_tile = Tile((0, 0, 4))
        assert self.cache.load_tile(loaded_tile)
        assert loaded_tile.source_buffer().read() == tile.source_buffer().read()
        
        assert not self.cache.is_cached(Tile((1, 0, 4)))
        
        tiles = [self.create_another_tile((x, 0, 4)) for x in range(2)]
        assert self.cache.store_tiles(tiles)
    
        assert self.cache.is_cached(Tile((0, 0, 4)))
        loaded_tile = Tile((0, 0, 4))
        assert self.cache.load_tile(loaded_tile)
        # check that tile is overwritten
        assert loaded_tile.source_buffer().read() != tile.source_buffer().read()
        assert loaded_tile.source_buffer().read() == tiles[0].source_buffer().read()

    def test_double_remove(self):
        tile = self.create_tile()
        self.create_cached_tile(tile)
        assert self.cache.remove_tile(tile)
        assert self.cache.remove_tile(tile)

    def test_lock(self):
        with self.cache.lock(Tile((0, 0, 0))):
            lockfile = glob.glob(os.path.join(self.cache_dir, 'couchdb-*-0-0-0.lck'))[0]
            assert re.match('.*/couchdb-[0-9a-f]+-0-0-0.lck$', lockfile)

class TestCouchDBMDTemplate(object):
    def test_empty(self):
        template = CouchDBMDTemplate({})
        doc = template.doc(Tile((0, 0, 1)), tile_grid(4326))
        
        assert_almost_equal(doc['timestamp'], time.time(), 2)

    def test_fixed_values(self):
        template = CouchDBMDTemplate({'hello': 'world', 'foo': 123})
        doc = template.doc(Tile((0, 0, 1)), tile_grid(4326))
        
        assert_almost_equal(doc['timestamp'], time.time(), 2)
        eq_(doc['hello'], 'world')
        eq_(doc['foo'], 123)

    def test_template_values(self):
        template = CouchDBMDTemplate({'row': '{{y}}', 'tile_column': '{{x}}',
            'zoom': '{{level}}', 'time': '{{timestamp}}', 'coord': '{{wgs_tile_centroid}}',
            'datetime': '{{utc_iso}}', 'coord_webmerc': '{{tile_centroid}}'})
        doc = template.doc(Tile((1, 0, 2)), tile_grid(3857))
        
        assert_almost_equal(doc['time'], time.time(), 2)
        assert 'timestamp' not in doc
        eq_(doc['row'], 0)
        eq_(doc['tile_column'], 1)
        eq_(doc['zoom'], 2)
        assert_almost_equal(doc['coord'][0], -45.0)
        assert_almost_equal(doc['coord'][1], -79.17133464081945)
        assert_almost_equal(doc['coord_webmerc'][0], -5009377.085697311)
        assert_almost_equal(doc['coord_webmerc'][1], -15028131.257091932)
        assert re.match('20\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ', doc['datetime']), doc['datetime']
########NEW FILE########
__FILENAME__ = test_cache_riak
# This file is part of the MapProxy project.
# Copyright (C) 2013 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

import os
import random
import urlparse

from nose.plugins.skip import SkipTest

from mapproxy.cache.riak import RiakCache
from mapproxy.grid import tile_grid
from mapproxy.test.image import create_tmp_image_buf
from mapproxy.test.unit.test_cache_tile import TileCacheTestBase

tile_image = create_tmp_image_buf((256, 256), color='blue')
tile_image2 = create_tmp_image_buf((256, 256), color='red')

class RiakCacheTestBase(TileCacheTestBase):
    always_loads_metadata = True
    def setup(self):
        if not os.environ.get(self.riak_url_env):
            raise SkipTest()

        url = os.environ[self.riak_url_env]
        urlparts = urlparse.urlparse(url)
        protocol = urlparts.scheme.lower()
        node = {'host': urlparts.hostname}
        if ':' in urlparts.hostname:
            if protocol == 'pbc':
                node['pb_port'] = urlparts.port
            if protocol in ('http', 'https'):
                node['http_port'] = urlparts.port
   
        db_name = 'mapproxy_test_%d' % random.randint(0, 100000)

        TileCacheTestBase.setup(self)

        self.cache = RiakCache([node], protocol, db_name, tile_grid=tile_grid(3857, name='global-webmarcator'),
                lock_dir=self.cache_dir)

    def teardown(self):
        import riak
        bucket = self.cache.bucket
        for k in bucket.get_keys():
            riak.RiakObject(self.cache.connection, bucket, k).delete()
        TileCacheTestBase.teardown(self)

    def test_double_remove(self):
        tile = self.create_tile()
        self.create_cached_tile(tile)
        assert self.cache.remove_tile(tile)
        assert self.cache.remove_tile(tile)

class TestRiakCacheHTTP(RiakCacheTestBase):
    riak_url_env = 'MAPPROXY_TEST_RIAK_HTTP'

class TestRiakCachePBC(RiakCacheTestBase):
    riak_url_env = 'MAPPROXY_TEST_RIAK_PBC'
########NEW FILE########
__FILENAME__ = test_cache_tile
# This file is part of the MapProxy project.
# Copyright (C) 2011-2013 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

import os
import shutil
import threading
import tempfile
import time
import sqlite3

from cStringIO import StringIO

from PIL import Image

from mapproxy.cache.tile import Tile
from mapproxy.cache.file import FileCache
from mapproxy.cache.mbtiles import MBTilesCache, MBTilesLevelCache
from mapproxy.cache.base import CacheBackendError
from mapproxy.image import ImageSource
from mapproxy.image.opts import ImageOptions
from mapproxy.test.image import create_tmp_image_buf, is_png

from nose.tools import eq_, assert_raises

tile_image = create_tmp_image_buf((256, 256), color='blue')
tile_image2 = create_tmp_image_buf((256, 256), color='red')

def timestamp_is_now(timestamp, delta=5):
    return abs(timestamp - time.time()) <= delta

class TileCacheTestBase(object):
    always_loads_metadata = False

    def setup(self):
        self.cache_dir = tempfile.mkdtemp()

    def teardown(self):
        if hasattr(self, 'cache_dir') and os.path.exists(self.cache_dir):
            shutil.rmtree(self.cache_dir)

    def create_tile(self, coord=(0, 0, 4)):
        return Tile(coord,
            ImageSource(tile_image,
                image_opts=ImageOptions(format='image/png')))

    def create_another_tile(self, coord=(0, 0, 4)):
        return Tile(coord,
            ImageSource(tile_image2,
                image_opts=ImageOptions(format='image/png')))

    def test_is_cached_miss(self):
        assert not self.cache.is_cached(Tile((0, 0, 4)))

    def test_is_cached_hit(self):
        tile = self.create_tile()
        self.create_cached_tile(tile)
        assert self.cache.is_cached(Tile((0, 0, 4)))

    def test_is_cached_none(self):
        assert self.cache.is_cached(Tile(None))

    def test_load_tile_none(self):
        assert self.cache.load_tile(Tile(None))

    def test_load_tile_not_cached(self):
        tile = Tile((0, 0, 4))
        assert not self.cache.load_tile(tile)
        assert tile.source is None
        assert tile.is_missing()

    def test_load_tile_cached(self):
        tile = self.create_tile()
        self.create_cached_tile(tile)
        tile = Tile((0, 0, 4))
        assert self.cache.load_tile(tile) == True
        assert not tile.is_missing()

    def test_store_tiles(self):
        tiles = [self.create_tile((x, 0, 4)) for x in range(4)]
        tiles[0].stored = True
        self.cache.store_tiles(tiles)

        tiles = [Tile((x, 0, 4)) for x in range(4)]
        assert tiles[0].is_missing()
        assert self.cache.load_tile(tiles[0]) == False
        assert tiles[0].is_missing()

        for tile in tiles[1:]:
            assert tile.is_missing()
            assert self.cache.load_tile(tile) == True
            assert not tile.is_missing()

    def test_load_tiles_cached(self):
        self.cache.store_tile(self.create_tile((0, 0, 1)))
        self.cache.store_tile(self.create_tile((0, 1, 1)))
        tiles = [Tile((0, 0, 1)), Tile((0, 1, 1))]
        assert self.cache.load_tiles(tiles)

        assert not tiles[0].is_missing()
        assert not tiles[1].is_missing()

    def test_load_tiles_mixed(self):
        tile = self.create_tile((1, 0, 4))
        self.create_cached_tile(tile)
        tiles = [Tile(None), Tile((0, 0, 4)), Tile((1, 0, 4))]
        assert self.cache.load_tiles(tiles) == False
        assert not tiles[0].is_missing()
        assert tiles[1].is_missing()
        assert not tiles[2].is_missing()

    def test_load_stored_tile(self):
        tile = self.create_tile((5, 12, 4))
        self.cache.store_tile(tile)
        size = tile.size

        # check stored tile
        tile = Tile((5, 12, 4))
        assert tile.source is None

        assert self.cache.load_tile(tile)
        if not self.always_loads_metadata:
            assert tile.source is not None
            assert tile.timestamp is None
            assert tile.size is None
        stored_size = len(tile.source.as_buffer().read())
        assert stored_size == size

        # check loading of metadata (timestamp, size)
        tile = Tile((5, 12, 4))
        assert tile.source is None
        assert self.cache.load_tile(tile, with_metadata=True)
        assert tile.source is not None
        if tile.timestamp:
            assert timestamp_is_now(tile.timestamp, delta=10)
        if tile.size:
            assert tile.size == size

    def test_overwrite_tile(self):
        tile = self.create_tile((5, 12, 4))
        self.cache.store_tile(tile)

        tile = Tile((5, 12, 4))
        self.cache.load_tile(tile)
        tile1_content = tile.source.as_buffer().read()
        assert tile1_content == tile_image.getvalue()

        tile = self.create_another_tile((5, 12, 4))
        self.cache.store_tile(tile)

        tile = Tile((5, 12, 4))
        self.cache.load_tile(tile)
        tile2_content = tile.source.as_buffer().read()
        assert tile2_content == tile_image2.getvalue()

        assert tile1_content != tile2_content

    def test_store_tile_already_stored(self):
        # tile object is marked as stored,
        # check that is is not stored 'again'
        # (used for disable_storage)
        tile = Tile((0, 0, 4), ImageSource(StringIO('foo')))
        tile.stored = True
        self.cache.store_tile(tile)

        assert self.cache.is_cached(tile)

        tile = Tile((0, 0, 4))
        assert not self.cache.is_cached(tile)

    def test_remove(self):
        tile = self.create_tile((1, 0, 4))
        self.create_cached_tile(tile)
        assert self.cache.is_cached(Tile((1, 0, 4)))

        self.cache.remove_tile(Tile((1, 0, 4)))
        assert not self.cache.is_cached(Tile((1, 0, 4)))

    def create_cached_tile(self, tile):
        self.cache.store_tile(tile)

class TestFileTileCache(TileCacheTestBase):
    def setup(self):
        TileCacheTestBase.setup(self)
        self.cache = FileCache(self.cache_dir, 'png')

    def test_store_tile(self):
        tile = self.create_tile((5, 12, 4))
        self.cache.store_tile(tile)
        tile_location = os.path.join(self.cache_dir,
            '04', '000', '000', '005', '000', '000', '012.png' )
        assert os.path.exists(tile_location), tile_location

    def test_single_color_tile_store(self):
        img = Image.new('RGB', (256, 256), color='#ff0105')
        tile = Tile((0, 0, 4), ImageSource(img, image_opts=ImageOptions(format='image/png')))
        self.cache.link_single_color_images = True
        self.cache.store_tile(tile)
        assert self.cache.is_cached(tile)
        loc = self.cache.tile_location(tile)
        assert os.path.islink(loc)
        assert os.path.realpath(loc).endswith('ff0105.png')
        assert is_png(open(loc, 'rb'))

        tile2 = Tile((0, 0, 1), ImageSource(img))
        self.cache.store_tile(tile2)
        assert self.cache.is_cached(tile2)
        loc2 = self.cache.tile_location(tile2)
        assert os.path.islink(loc2)
        assert os.path.realpath(loc2).endswith('ff0105.png')
        assert is_png(open(loc2, 'rb'))

        assert loc != loc2
        assert os.path.samefile(loc, loc2)

    def test_single_color_tile_store_w_alpha(self):
        img = Image.new('RGBA', (256, 256), color='#ff0105')
        tile = Tile((0, 0, 4), ImageSource(img, image_opts=ImageOptions(format='image/png')))
        self.cache.link_single_color_images = True
        self.cache.store_tile(tile)
        assert self.cache.is_cached(tile)
        loc = self.cache.tile_location(tile)
        assert os.path.islink(loc)
        assert os.path.realpath(loc).endswith('ff0105ff.png')
        assert is_png(open(loc, 'rb'))

    def test_load_metadata_missing_tile(self):
        tile = Tile((0, 0, 0))
        self.cache.load_tile_metadata(tile)
        assert tile.timestamp == 0
        assert tile.size == 0

    def create_cached_tile(self, tile):
        loc = self.cache.tile_location(tile, create_dir=True)
        with open(loc, 'w') as f:
            f.write('foo')


class TestMBTileCache(TileCacheTestBase):
    def setup(self):
        TileCacheTestBase.setup(self)
        self.cache = MBTilesCache(os.path.join(self.cache_dir, 'tmp.mbtiles'))

    def test_load_empty_tileset(self):
        assert self.cache.load_tiles([Tile(None)]) == True
        assert self.cache.load_tiles([Tile(None), Tile(None), Tile(None)]) == True

    def test_load_1001_tiles(self):
        assert_raises(CacheBackendError, self.cache.load_tiles, [Tile((19, 1, 1))] * 1001)

    def test_timeouts(self):
        self.cache._db_conn_cache.db = sqlite3.connect(self.cache.mbtile_file, timeout=0.05)

        def block():
            # block database by delaying the commit
            db = sqlite3.connect(self.cache.mbtile_file)
            cur = db.cursor()
            stmt = "INSERT OR REPLACE INTO tiles (zoom_level, tile_column, tile_row, tile_data) VALUES (?,?,?,?)"
            cur.execute(stmt, (3, 1, 1, '1234'))
            time.sleep(0.2)
            db.commit()

        try:
            assert self.cache.store_tile(self.create_tile((0, 0, 1))) == True

            t = threading.Thread(target=block)
            t.start()
            time.sleep(0.05)
            assert self.cache.store_tile(self.create_tile((0, 0, 1))) == False
        finally:
            t.join()

        assert self.cache.store_tile(self.create_tile((0, 0, 1))) == True


class TestQuadkeyFileTileCache(TileCacheTestBase):
    def setup(self):
        TileCacheTestBase.setup(self)
        self.cache = FileCache(self.cache_dir, 'png', directory_layout='quadkey')

    def test_store_tile(self):
        tile = self.create_tile((3, 4, 2))
        self.cache.store_tile(tile)
        tile_location = os.path.join(self.cache_dir, '11.png' )
        assert os.path.exists(tile_location), tile_location


class TestMBTileLevelCache(TileCacheTestBase):
    always_loads_metadata = True

    def setup(self):
        TileCacheTestBase.setup(self)
        self.cache = MBTilesLevelCache(self.cache_dir)

    def test_level_files(self):
        eq_(os.listdir(self.cache_dir), [])

        self.cache.store_tile(self.create_tile((0, 0, 1)))
        eq_(os.listdir(self.cache_dir), ['1.mbtile'])

        self.cache.store_tile(self.create_tile((0, 0, 5)))
        eq_(sorted(os.listdir(self.cache_dir)), ['1.mbtile', '5.mbtile'])

    def test_remove_level_files(self):
        self.cache.store_tile(self.create_tile((0, 0, 1)))
        self.cache.store_tile(self.create_tile((0, 0, 2)))
        eq_(sorted(os.listdir(self.cache_dir)), ['1.mbtile', '2.mbtile'])

        self.cache.remove_level_tiles_before(1, timestamp=0)
        eq_(os.listdir(self.cache_dir), ['2.mbtile'])

    def test_remove_level_tiles_before(self):
        self.cache.store_tile(self.create_tile((0, 0, 1)))
        self.cache.store_tile(self.create_tile((0, 0, 2)))

        eq_(sorted(os.listdir(self.cache_dir)), ['1.mbtile', '2.mbtile'])
        assert self.cache.is_cached(Tile((0, 0, 1)))

        self.cache.remove_level_tiles_before(1, timestamp=time.time() - 60)
        assert self.cache.is_cached(Tile((0, 0, 1)))

        self.cache.remove_level_tiles_before(1, timestamp=time.time() + 60)
        assert not self.cache.is_cached(Tile((0, 0, 1)))

        eq_(sorted(os.listdir(self.cache_dir)), ['1.mbtile', '2.mbtile'])
        assert self.cache.is_cached(Tile((0, 0, 2)))

########NEW FILE########
__FILENAME__ = test_client
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

import os
import time
import sys

from mapproxy.client.http import HTTPClient, HTTPClientError
from mapproxy.client.tile import TMSClient, TileClient, TileURLTemplate
from mapproxy.client.wms import WMSClient, WMSInfoClient
from mapproxy.grid import tile_grid
from mapproxy.layer import MapQuery, InfoQuery
from mapproxy.request.wms import WMS111MapRequest, WMS100MapRequest,\
                                 WMS130MapRequest, WMS111FeatureInfoRequest
from mapproxy.srs import SRS
from mapproxy.test.unit.test_cache import MockHTTPClient
from mapproxy.test.http import mock_httpd, query_eq, assert_query_eq
from mapproxy.test.helper import assert_re, TempFile

from nose.tools import eq_
from nose.plugins.skip import SkipTest
from nose.plugins.attrib import attr

TESTSERVER_ADDRESS = ('127.0.0.1', 56413)
TESTSERVER_URL = 'http://%s:%s' % TESTSERVER_ADDRESS

class TestHTTPClient(object):
    def setup(self):
        self.client = HTTPClient()
    
    def test_post(self):
        with mock_httpd(TESTSERVER_ADDRESS, [({'path': '/service?foo=bar', 'method': 'POST'},
                                              {'status': '200', 'body': ''})]):
            self.client.open(TESTSERVER_URL + '/service', data="foo=bar")
    
    def test_internal_error_response(self):
        try:
            with mock_httpd(TESTSERVER_ADDRESS, [({'path': '/'},
                                                  {'status': '500', 'body': ''})]):
                self.client.open(TESTSERVER_URL + '/')
        except HTTPClientError, e:
            assert_re(e.args[0], r'HTTP Error ".*": 500')
        else:
            assert False, 'expected HTTPClientError'
    def test_invalid_url_type(self):
        try:
            self.client.open('htp://example.org')
        except HTTPClientError, e:
            assert_re(e.args[0], r'No response .* "htp://example.*": unknown url type')
        else:
            assert False, 'expected HTTPClientError'
    def test_invalid_url(self):
        try:
            self.client.open('this is not a url')
        except HTTPClientError, e:
            assert_re(e.args[0], r'URL not correct "this is not.*": unknown url type')
        else:
            assert False, 'expected HTTPClientError'
    def test_unknown_host(self):
        try:
            self.client.open('http://thishostshouldnotexist000136really42.org')
        except HTTPClientError, e:
            assert_re(e.args[0], r'No response .* "http://thishost.*": .*')
        else:
            assert False, 'expected HTTPClientError'
    def test_no_connect(self):
        try:
            self.client.open('http://localhost:53871')
        except HTTPClientError, e:
            assert_re(e.args[0], r'No response .* "http://localhost.*": Connection refused')
        else:
            assert False, 'expected HTTPClientError'
    
    @attr('online')
    def test_https_no_ssl_module_error(self):
        from mapproxy.client import http
        old_ssl = http.ssl
        try:
            http.ssl = None
            try:
                self.client = HTTPClient('https://www.google.com/')
            except ImportError:
                pass
            else:
                assert False, 'no ImportError for missing ssl module'
        finally:
            http.ssl = old_ssl
    
    @attr('online')
    def test_https_no_ssl_module_insecure(self):
        from mapproxy.client import http
        old_ssl = http.ssl
        try:
            http.ssl = None
            self.client = HTTPClient('https://www.google.com/', insecure=True)
            self.client.open('https://www.google.com/')
        finally:
            http.ssl = old_ssl
    
    @attr('online')
    def test_https_valid_cert(self):
        try:
            import ssl; ssl
        except ImportError:
            raise SkipTest()
        
        cert_file = '/etc/ssl/certs/ca-certificates.crt'
        if os.path.exists(cert_file):
            self.client = HTTPClient('https://www.google.com/', ssl_ca_certs=cert_file)
            self.client.open('https://www.google.com/')
        else:
            with TempFile() as tmp:
                with open(tmp, 'w') as f:
                    f.write(GOOGLE_ROOT_CERT)
                self.client = HTTPClient('https://www.google.com/', ssl_ca_certs=tmp)
                self.client.open('https://www.google.com/')
    
    @attr('online')
    def test_https_invalid_cert(self):
        try:
            import ssl; ssl
        except ImportError:
            raise SkipTest()
        
        with TempFile() as tmp:
            self.client = HTTPClient('https://www.google.com/', ssl_ca_certs=tmp)
            try:
                self.client.open('https://www.google.com/')
            except HTTPClientError, e:
                assert_re(e.args[0], r'Could not verify connection to URL')
        
    def test_timeouts(self):
        test_req = ({'path': '/', 'req_assert_function': lambda x: time.sleep(0.5) or True},
                    {'body': 'nothing'})

        import mapproxy.client.http

        old_timeout = mapproxy.client.http._max_set_timeout
        mapproxy.client.http._max_set_timeout = None

        client1 = HTTPClient(timeout=0.1)
        client2 = HTTPClient(timeout=0.2)
        with mock_httpd(TESTSERVER_ADDRESS, [test_req]):
            try:
                start = time.time()
                client1.open(TESTSERVER_URL+'/')
            except HTTPClientError, ex:
                assert 'timed out' in ex.args[0]
            else:
                assert False, 'HTTPClientError expected'
            duration1 = time.time() - start

        with mock_httpd(TESTSERVER_ADDRESS, [test_req]):
            try:
                start = time.time()
                client2.open(TESTSERVER_URL+'/')
            except HTTPClientError, ex:
                assert 'timed out' in ex.args[0]
            else:
                assert False, 'HTTPClientError expected'
            duration2 = time.time() - start

        if sys.version_info >= (2, 6):
            # check individual timeouts
            assert 0.1 <= duration1 < 0.2
            assert 0.2 <= duration2 < 0.3
        else:
            # use max timeout in Python 2.5
            assert 0.2 <= duration1 < 0.3
            assert 0.2 <= duration2 < 0.3

        mapproxy.client.http._max_set_timeout = old_timeout

# Equifax Secure Certificate Authority
# Expires: 2018-08-22
GOOGLE_ROOT_CERT = """
-----BEGIN CERTIFICATE-----
MIIDIDCCAomgAwIBAgIENd70zzANBgkqhkiG9w0BAQUFADBOMQswCQYDVQQGEwJV
UzEQMA4GA1UEChMHRXF1aWZheDEtMCsGA1UECxMkRXF1aWZheCBTZWN1cmUgQ2Vy
dGlmaWNhdGUgQXV0aG9yaXR5MB4XDTk4MDgyMjE2NDE1MVoXDTE4MDgyMjE2NDE1
MVowTjELMAkGA1UEBhMCVVMxEDAOBgNVBAoTB0VxdWlmYXgxLTArBgNVBAsTJEVx
dWlmYXggU2VjdXJlIENlcnRpZmljYXRlIEF1dGhvcml0eTCBnzANBgkqhkiG9w0B
AQEFAAOBjQAwgYkCgYEAwV2xWGcIYu6gmi0fCG2RFGiYCh7+2gRvE4RiIcPRfM6f
BeC4AfBONOziipUEZKzxa1NfBbPLZ4C/QgKO/t0BCezhABRP/PvwDN1Dulsr4R+A
cJkVV5MW8Q+XarfCaCMczE1ZMKxRHjuvK9buY0V7xdlfUNLjUA86iOe/FP3gx7kC
AwEAAaOCAQkwggEFMHAGA1UdHwRpMGcwZaBjoGGkXzBdMQswCQYDVQQGEwJVUzEQ
MA4GA1UEChMHRXF1aWZheDEtMCsGA1UECxMkRXF1aWZheCBTZWN1cmUgQ2VydGlm
aWNhdGUgQXV0aG9yaXR5MQ0wCwYDVQQDEwRDUkwxMBoGA1UdEAQTMBGBDzIwMTgw
ODIyMTY0MTUxWjALBgNVHQ8EBAMCAQYwHwYDVR0jBBgwFoAUSOZo+SvSspXXR9gj
IBBPM5iQn9QwHQYDVR0OBBYEFEjmaPkr0rKV10fYIyAQTzOYkJ/UMAwGA1UdEwQF
MAMBAf8wGgYJKoZIhvZ9B0EABA0wCxsFVjMuMGMDAgbAMA0GCSqGSIb3DQEBBQUA
A4GBAFjOKer89961zgK5F7WF0bnj4JXMJTENAKaSbn+2kmOeUJXRmm/kEd5jhW6Y
7qj/WsjTVbJmcVfewCHrPSqnI0kBBIZCe/zuf6IWUrVnZ9NA2zsmWLIodz2uFHdh
1voqZiegDfqnc1zqcPGUIWVEX/r87yloqaKHee9570+sB3c4
-----END CERTIFICATE-----
"""

# class TestWMSClient(object):
#     def setup(self):
#         self.req = WMS111MapRequest(url=TESTSERVER_URL + '/service?map=foo')
#         self.wms = WMSClient(self.req)
#     def test_request(self):
#         expected_req = ({'path': r'/service?map=foo&LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
#                                   '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A4326'
#                                   '&VERSION=1.1.1&BBOX=-180.0,-90.0,180.0,90.0&WIDTH=512&STYLES='},
#                         {'body': 'no image', 'headers': {'content-type': 'image/png'}})
#         with mock_httpd(TESTSERVER_ADDRESS, [expected_req]):
#             req = WMS111MapRequest(url=TESTSERVER_URL + '/service?map=foo',
#                                    param={'layers': 'foo', 'bbox': '-180.0,-90.0,180.0,90.0'})
#             req.params.size = (512, 256)
#             req.params['format'] = 'image/png'
#             req.params['srs'] = 'EPSG:4326'
#             resp = self.wms.get_map(req)
#     
#     def test_request_w_auth(self):
#         wms = WMSClient(self.req, http_client=HTTPClient(self.req.url, username='foo', password='bar'))
#         def assert_auth(req_handler):
#             assert 'Authorization' in req_handler.headers
#             auth_data = req_handler.headers['Authorization'].split()[1]
#             auth_data = auth_data.decode('base64')
#             eq_(auth_data, 'foo:bar')
#             return True
#         expected_req = ({'path': r'/service?map=foo&LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
#                                   '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A4326'
#                                   '&VERSION=1.1.1&BBOX=-180.0,-90.0,180.0,90.0&WIDTH=512&STYLES=',
#                          'require_basic_auth': True,
#                          'req_assert_function': assert_auth},
#                         {'body': 'no image', 'headers': {'content-type': 'image/png'}})
#         with mock_httpd(TESTSERVER_ADDRESS, [expected_req]):
#             req = WMS111MapRequest(url=TESTSERVER_URL + '/service?map=foo',
#                                    param={'layers': 'foo', 'bbox': '-180.0,-90.0,180.0,90.0'})
#             req.params.size = (512, 256)
#             req.params['format'] = 'image/png'
#             req.params['srs'] = 'EPSG:4326'
#             resp = wms.get_map(req)
# 
#     def test_get_tile_non_image_content_type(self):
#         expected_req = ({'path': r'/service?map=foo&LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
#                                   '&REQUEST=GetMap&HEIGHT=256&SRS=EPSG%3A4326&STYLES='
#                                   '&VERSION=1.1.1&BBOX=-180.0,-90.0,180.0,90.0&WIDTH=512'},
#                         {'body': 'error', 'headers': {'content-type': 'text/plain'}})
#         with mock_httpd(TESTSERVER_ADDRESS, [expected_req]):
#             try:
#                 req = WMS111MapRequest(url=TESTSERVER_URL + '/service?map=foo',
#                                        param={'layers': 'foo', 'bbox': '-180.0,-90.0,180.0,90.0'})
#                 req.params.size = (512, 256)
#                 req.params['format'] = 'image/png'
#                 req.params['srs'] = 'EPSG:4326'
#                 resp = self.wms.get_map(req)
#             except HTTPClientError, e:
#                 assert_re(e.args[0], r'response is not an image')
#             else:
#                 assert False, 'expected HTTPClientError'
#     
#     def test__transform_fi_request(self):
#         default_req = WMS111MapRequest(url_decode('srs=EPSG%3A4326'))
#         fi_req = Request(make_wsgi_env('''LAYERS=mapserver_cache&
#          QUERY_LAYERS=mapnik_mapserver&X=601&Y=528&FORMAT=image%2Fpng&SERVICE=WMS&
#          VERSION=1.1.1&REQUEST=GetFeatureInfo&STYLES=&
#          EXCEPTIONS=application%2Fvnd.ogc.se_inimage&SRS=EPSG%3A900913&
#          BBOX=730930.9303206909,6866851.379301955,1031481.3254841676,7170153.507483206&
#          WIDTH=983&HEIGHT=992'''.replace('\n', '').replace(' ', '')))
#         wms_client = WMSClient(default_req)
#         orig_req = wms_request(fi_req)
#         req = wms_request(fi_req)
#         wms_client._transform_fi_request(req)
#         
#         eq_(req.params.srs, 'EPSG:4326')
#         eq_(req.params.pos, (601, 523))
# 
#         default_req = WMS111MapRequest(url_decode('srs=EPSG%3A900913'))
#         wms_client = WMSClient(default_req)
#         wms_client._transform_fi_request(req)
#         
#         eq_(req.params.srs, 'EPSG:900913')
#         eq_(req.params.pos, (601, 528))
#         assert bbox_equals(orig_req.params.bbox, req.params.bbox, 0.1)
        
class TestTMSClient(object):
    def setup(self):
        self.client = TMSClient(TESTSERVER_URL)
    def test_get_tile(self):
        with mock_httpd(TESTSERVER_ADDRESS, [({'path': '/9/5/13.png'},
                                                {'body': 'tile', 'headers': {'content-type': 'image/png'}})]):
            resp = self.client.get_tile((5, 13, 9)).source.read()
            eq_(resp, 'tile')

class TestTileClient(object):
    def test_tc_path(self):
        template = TileURLTemplate(TESTSERVER_URL + '/%(tc_path)s.png')
        client = TileClient(template)
        with mock_httpd(TESTSERVER_ADDRESS, [({'path': '/09/000/000/005/000/000/013.png'},
                                              {'body': 'tile',
                                               'headers': {'content-type': 'image/png'}})]):
            resp = client.get_tile((5, 13, 9)).source.read()
            eq_(resp, 'tile')

    def test_quadkey(self):
        template = TileURLTemplate(TESTSERVER_URL + '/key=%(quadkey)s&format=%(format)s')
        client = TileClient(template)
        with mock_httpd(TESTSERVER_ADDRESS, [({'path': '/key=000002303&format=png'},
                                              {'body': 'tile',
                                               'headers': {'content-type': 'image/png'}})]):
            resp = client.get_tile((5, 13, 9)).source.read()
            eq_(resp, 'tile')
    def test_xyz(self):
        template = TileURLTemplate(TESTSERVER_URL + '/x=%(x)s&y=%(y)s&z=%(z)s&format=%(format)s')
        client = TileClient(template)
        with mock_httpd(TESTSERVER_ADDRESS, [({'path': '/x=5&y=13&z=9&format=png'},
                                              {'body': 'tile',
                                               'headers': {'content-type': 'image/png'}})]):
            resp = client.get_tile((5, 13, 9)).source.read()
            eq_(resp, 'tile')

    def test_arcgiscache_path(self):
        template = TileURLTemplate(TESTSERVER_URL + '/%(arcgiscache_path)s.png')
        client = TileClient(template)
        with mock_httpd(TESTSERVER_ADDRESS, [({'path': '/L09/R0000000d/C00000005.png'},
                                              {'body': 'tile',
                                               'headers': {'content-type': 'image/png'}})]):
            resp = client.get_tile((5, 13, 9)).source.read()
            eq_(resp, 'tile')

    def test_bbox(self):
        grid = tile_grid(4326)
        template = TileURLTemplate(TESTSERVER_URL + '/service?BBOX=%(bbox)s')
        client = TileClient(template, grid=grid)
        with mock_httpd(TESTSERVER_ADDRESS, [({'path': '/service?BBOX=-180.00000000,0.00000000,-90.00000000,90.00000000'},
                                              {'body': 'tile',
                                               'headers': {'content-type': 'image/png'}})]):
            resp = client.get_tile((0, 1, 2)).source.read()
            eq_(resp, 'tile')

class TestCombinedWMSClient(object):
    def setup(self):
        self.http = MockHTTPClient()
    def test_combine(self):
        req1 = WMS111MapRequest(url=TESTSERVER_URL + '/service?map=foo',
                                    param={'layers':'foo', 'transparent': 'true'})
        wms1 = WMSClient(req1, http_client=self.http)
        req2 = WMS111MapRequest(url=TESTSERVER_URL + '/service?map=foo',
                                    param={'layers':'bar', 'transparent': 'true'})
        wms2 = WMSClient(req2, http_client=self.http)
        
        req = MapQuery((-200000, -200000, 200000, 200000), (512, 512), SRS(900913), 'png')
        
        combined = wms1.combined_client(wms2, req)
        eq_(combined.request_template.params.layers, ['foo', 'bar'])
        eq_(combined.request_template.url, TESTSERVER_URL + '/service?map=foo')

    def test_combine_different_url(self):
        req1 = WMS111MapRequest(url=TESTSERVER_URL + '/service?map=bar',
                                    param={'layers':'foo', 'transparent': 'true'})
        wms1 = WMSClient(req1, http_client=self.http)
        req2 = WMS111MapRequest(url=TESTSERVER_URL + '/service?map=foo',
                                    param={'layers':'bar', 'transparent': 'true'})
        wms2 = WMSClient(req2, http_client=self.http)
        
        req = MapQuery((-200000, -200000, 200000, 200000), (512, 512), SRS(900913), 'png')
        
        combined = wms1.combined_client(wms2, req)
        assert combined is None
        
class TestWMSInfoClient(object):
    def test_transform_fi_request_supported_srs(self):
        req = WMS111FeatureInfoRequest(url=TESTSERVER_URL + '/service?map=foo', param={'layers':'foo'})
        http = MockHTTPClient()
        wms = WMSInfoClient(req, http_client=http, supported_srs=[SRS(25832)])
        fi_req = InfoQuery((8, 50, 9, 51), (512, 512),
                           SRS(4326), (256, 256), 'text/plain')
        
        wms.get_info(fi_req)
        
        assert_query_eq(http.requested[0],
            TESTSERVER_URL+'/service?map=foo&LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
                           '&REQUEST=GetFeatureInfo&HEIGHT=512&SRS=EPSG%3A25832&info_format=text/plain'
                           '&query_layers=foo'
                           '&VERSION=1.1.1&WIDTH=512&STYLES=&x=259&y=255'
                           '&BBOX=428333.552496,5538630.70275,500000.0,5650300.78652')

    def test_transform_fi_request(self):
        req = WMS111FeatureInfoRequest(url=TESTSERVER_URL + '/service?map=foo', param={'layers':'foo', 'srs': 'EPSG:25832'})
        http = MockHTTPClient()
        wms = WMSInfoClient(req, http_client=http)
        fi_req = InfoQuery((8, 50, 9, 51), (512, 512),
                           SRS(4326), (256, 256), 'text/plain')
        
        wms.get_info(fi_req)
        
        assert_query_eq(http.requested[0],
            TESTSERVER_URL+'/service?map=foo&LAYERS=foo&SERVICE=WMS&FORMAT=image%2Fpng'
                           '&REQUEST=GetFeatureInfo&HEIGHT=512&SRS=EPSG%3A25832&info_format=text/plain'
                           '&query_layers=foo'
                           '&VERSION=1.1.1&WIDTH=512&STYLES=&x=259&y=255'
                           '&BBOX=428333.552496,5538630.70275,500000.0,5650300.78652')

class TestWMSMapRequest100(object):
    def setup(self):
        self.r = WMS100MapRequest(param=dict(layers='foo', version='1.1.1', request='GetMap'))
        self.r.params = self.r.adapt_params_to_version()
    def test_version(self):
        eq_(self.r.params['WMTVER'], '1.0.0')
        assert 'VERSION' not in self.r.params
    def test_service(self):
        assert 'SERVICE' not in self.r.params 
    def test_request(self):
        eq_(self.r.params['request'], 'map')
    def test_str(self):
        assert_query_eq(str(self.r.params), 'layers=foo&styles=&request=map&wmtver=1.0.0')

class TestWMSMapRequest130(object):
    def setup(self):
        self.r = WMS130MapRequest(param=dict(layers='foo', WMTVER='1.0.0'))
        self.r.params = self.r.adapt_params_to_version()
    def test_version(self):
        eq_(self.r.params['version'], '1.3.0')
        assert 'WMTVER' not in self.r.params
    def test_service(self):
        eq_(self.r.params['service'], 'WMS' )
    def test_request(self):
        eq_(self.r.params['request'], 'GetMap')
    def test_str(self):
        query_eq(str(self.r.params), 'layers=foo&styles=&service=WMS&request=GetMap&version=1.3.0')

class TestWMSMapRequest111(object):
    def setup(self):
        self.r = WMS111MapRequest(param=dict(layers='foo', WMTVER='1.0.0'))
        self.r.params = self.r.adapt_params_to_version()
    def test_version(self):
        eq_(self.r.params['version'], '1.1.1')
        assert 'WMTVER' not in self.r.params

########NEW FILE########
__FILENAME__ = test_client_cgi
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os
import shutil
import stat
import tempfile

from mapproxy.client.http import HTTPClientError
from mapproxy.client.cgi import CGIClient, split_cgi_response
from mapproxy.source import SourceError

from nose.tools import eq_

class TestSplitHTTPResponse(object):
    def test_n(self):
        eq_(split_cgi_response('header1: foo\nheader2: bar\n\ncontent\n\ncontent'),
            ({'Header1':'foo', 'Header2': 'bar'}, 'content\n\ncontent'))
    def test_rn(self):
        eq_(split_cgi_response('header1\r\nheader2\r\n\r\ncontent\r\n\r\ncontent'),
            ({'Header1': None, 'Header2': None}, 'content\r\n\r\ncontent'))
    def test_mixed(self):
        eq_(split_cgi_response('header1: bar:foo\r\nheader2\n\r\ncontent\r\n\r\ncontent'),
            ({'Header1': 'bar:foo', 'Header2': None}, 'content\r\n\r\ncontent'))
        eq_(split_cgi_response('header1\r\nheader2\n\ncontent\r\n\r\ncontent'),
            ({'Header1': None, 'Header2': None}, 'content\r\n\r\ncontent'))
        eq_(split_cgi_response('header1\nheader2\r\n\r\ncontent\r\n\r\ncontent'),
            ({'Header1': None, 'Header2': None}, 'content\r\n\r\ncontent'))
    def test_no_header(self):
        eq_(split_cgi_response('content\r\ncontent'),
            ({}, 'content\r\ncontent'))


TEST_CGI_SCRIPT = r"""#! /usr/bin/env python
import sys
import os
w = sys.stdout.write
w("Content-type: text/plain\r\n")
w("\r\n")
w(os.environ['QUERY_STRING'])
"""

TEST_CGI_SCRIPT_FAIL = TEST_CGI_SCRIPT + '\nexit(1)'

TEST_CGI_SCRIPT_CWD = TEST_CGI_SCRIPT + r"""
if not os.path.exists('testfile'):
    exit(2)
"""

class TestCGIClient(object):
    def setup(self):
        self.script_dir = tempfile.mkdtemp()
    
    def teardown(self):
        shutil.rmtree(self.script_dir)
    
    def create_script(self, script=TEST_CGI_SCRIPT, executable=True):
        script_file = os.path.join(self.script_dir, 'cgi.py')
        with open(script_file, 'w') as f:
            f.write(script)
        if executable:
            os.chmod(script_file, stat.S_IXUSR | stat.S_IRUSR | stat.S_IWUSR)
        return script_file
    
    def test_missing_script(self):
        client = CGIClient('/tmp/doesnotexist')
        try:
            client.open('http://example.org/service?hello=bar')
        except SourceError:
            pass
        else:
            assert False, 'expected SourceError'
    
    def test_script_not_executable(self):
        script = self.create_script(executable=False)
        client = CGIClient(script)
        try:
            client.open('http://example.org/service?hello=bar')
        except SourceError:
            pass
        else:
            assert False, 'expected SourceError'
    
    def test_call(self):
        script = self.create_script()
        client = CGIClient(script)
        resp = client.open('http://example.org/service?hello=bar')
        eq_(resp.headers['Content-type'], 'text/plain')
        eq_(resp.read(), 'hello=bar')
    
    def test_failed_call(self):
        script = self.create_script(TEST_CGI_SCRIPT_FAIL)
        client = CGIClient(script)
        try:
            client.open('http://example.org/service?hello=bar')
        except HTTPClientError:
            pass
        else:
            assert False, 'expected HTTPClientError'
    
    def test_working_directory(self):
        tmp_work_dir = os.path.join(self.script_dir, 'tmp')
        os.mkdir(tmp_work_dir)
        tmp_file = os.path.join(tmp_work_dir, 'testfile')
        open(tmp_file, 'w')
        
        # start script in default directory
        script = self.create_script(TEST_CGI_SCRIPT_CWD)
        client = CGIClient(script)
        try:
            client.open('http://example.org/service?hello=bar')
        except HTTPClientError:
            pass
        else:
            assert False, 'expected HTTPClientError'

        # start in tmp_work_dir
        client = CGIClient(script, working_directory=tmp_work_dir)
        client.open('http://example.org/service?hello=bar')
        

########NEW FILE########
__FILENAME__ = test_collections
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from mapproxy.util.collections import LRU, ImmutableDictList

from nose.tools import eq_, raises

class TestLRU(object):
    @raises(KeyError)
    def test_missing_key(self):
        lru = LRU(10)
        lru['foo']
    
    def test_contains(self):
        lru = LRU(10)
        lru['foo1'] = 1
        
        assert 'foo1' in lru
        assert 'foo2' not in lru
    
    def test_repr(self):
        lru = LRU(10)
        lru['foo1'] = 1
        assert 'size=10' in repr(lru)
        assert 'foo1' in repr(lru)
        
    def test_getitem(self):
        lru = LRU(10)
        lru['foo1'] = 1
        lru['foo2'] = 2
        eq_(lru['foo1'], 1)
        eq_(lru['foo2'], 2)
    
    def test_get(self):
        lru = LRU(10)
        lru['foo1'] = 1
        eq_(lru.get('foo1'), 1)
        eq_(lru.get('foo1', 2), 1)
    
    def test_get_default(self):
        lru = LRU(10)
        lru['foo1'] = 1
        eq_(lru.get('foo2'), None)
        eq_(lru.get('foo2', 2), 2)
        
    def test_delitem(self):
        lru = LRU(10)
        lru['foo1'] = 1
        assert 'foo1' in lru
        del lru['foo1']
        assert 'foo1' not in lru
        
    def test_empty(self):
        lru = LRU(10)
        assert bool(lru) == False
        lru['foo1'] = '1'
        assert bool(lru) == True
    
    def test_setitem_overflow(self):
        lru = LRU(2)
        lru['foo1'] = 1
        lru['foo2'] = 2
        lru['foo3'] = 3
        
        assert 'foo1' not in lru
        assert 'foo2' in lru
        assert 'foo3' in lru

    def test_length(self):
        lru = LRU(2)
        eq_(len(lru), 0)
        lru['foo1'] = 1
        eq_(len(lru), 1)
        lru['foo2'] = 2
        eq_(len(lru), 2)
        lru['foo3'] = 3
        eq_(len(lru), 2)
        
        del lru['foo3']
        eq_(len(lru), 1)


class TestImmutableDictList(object):
    def test_named(self):
        res = ImmutableDictList([('one', 10), ('two', 5), ('three', 3)])
        assert res[0] == 10
        assert res[2] == 3
        assert res['one'] == 10
        assert res['three'] == 3
        assert len(res) == 3
    
    def test_named_iteritems(self):
        res = ImmutableDictList([('one', 10), ('two', 5), ('three', 3)])
        itr = res.iteritems()
        eq_(itr.next(), ('one', 10))
        eq_(itr.next(), ('two', 5))
        eq_(itr.next(), ('three', 3))
        try:
            itr.next()
        except StopIteration:
            pass
        else:
            assert False, 'StopIteration expected'
########NEW FILE########
__FILENAME__ = test_concat_legends
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
from mapproxy.platform.image import Image
from mapproxy.image import ImageSource
from mapproxy.image.merge import concat_legends
from mapproxy.test.image import is_png

class Test_Concat_Legends(object):
    def test_concatenation(self):
        legends = []
        img_1 = Image.new(mode='RGBA', size=(30,10), color="red")
        img_2 = Image.new(mode='RGBA', size=(10,10), color="black")
        img_3 = Image.new(mode='RGBA', size=(50,80), color="blue")
        legends.append(ImageSource(img_1))
        legends.append(ImageSource(img_2))
        legends.append(ImageSource(img_3))
        source = concat_legends(legends)
        src_img = source.as_image()
        assert src_img.getpixel((0,90)) == (255,0,0,255)
        assert src_img.getpixel((0,80)) == (0,0,0,255)
        assert src_img.getpixel((0,0)) == (0,0,255,255)
        assert src_img.getpixel((49,99)) == (255,255,255,0)
        assert is_png(source.as_buffer())

########NEW FILE########
__FILENAME__ = test_config
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

from mapproxy.config import Options, base_config, load_base_config

from mapproxy.test.helper import TempFiles

def teardown_module():
    load_base_config(clear_existing=True)

class TestOptions(object):
    def test_update_overwrite(self):
        d = Options(foo='bar', baz=4)
        d.update(Options(baz=5))
        assert d.baz == 5
        assert d.foo == 'bar'
    def test_update_new(self):
        d = Options(foo='bar', baz=4)
        d.update(Options(biz=5))
        assert d.baz == 4
        assert d.biz == 5
        assert d.foo == 'bar'
    def test_update_recursive(self):
        d = Options(
            foo='bar',
            baz=Options(ham=2, eggs=4))
        d.update(Options(baz=Options(eggs=5)))
        assert d.foo == 'bar'
        assert d.baz.ham == 2
        assert d.baz.eggs == 5
    def test_compare(self):
        assert Options(foo=4) == Options(foo=4)
        assert Options(foo=Options(bar=4)) == Options(foo=Options(bar=4))
        

class TestDefaultsLoading(object):
    defaults_yaml = """
    foo:
        bar:
            ham: 2
            eggs: 4
    biz: 'foobar'
    wiz: 'foobar'
    """
    
    def test_defaults(self):
        with TempFiles() as tmp:
            with open(tmp[0], 'w') as f:
                f.write(TestDefaultsLoading.defaults_yaml)
            load_base_config(config_file=tmp[0], clear_existing=True)
            
            assert base_config().biz == 'foobar'
            assert base_config().wiz == 'foobar'
            assert base_config().foo.bar.ham == 2
            assert base_config().foo.bar.eggs == 4
            assert not hasattr(base_config(), 'wms')
    def test_defaults_overwrite(self):
        with TempFiles(2) as tmp:
            with open(tmp[0], 'w') as f:
                f.write(TestDefaultsLoading.defaults_yaml)
            with open(tmp[1], 'w') as f:
                f.write("""
                baz: [9, 2, 1, 4]
                biz: 'barfoo'
                foo:
                    bar:
                        eggs: 5
                """)
            
            load_base_config(config_file=tmp[0], clear_existing=True)
            load_base_config(config_file=tmp[1])
            
            assert base_config().biz == 'barfoo'
            assert base_config().wiz == 'foobar'
            assert base_config().baz == [9, 2, 1, 4]
            assert base_config().foo.bar.ham == 2
            assert base_config().foo.bar.eggs == 5
            assert not hasattr(base_config(), 'wms')
        

class TestSRSConfig(object):
    def setup(self):
        import mapproxy.config.config
        mapproxy.config.config._config.pop()
    
    def test_user_srs_definitions(self):
        user_yaml = """
        srs:
          axis_order_ne: ['EPSG:9999']
        """
        with TempFiles() as tmp:
            with open(tmp[0], 'w') as f:
                f.write(user_yaml)
        
            load_base_config(config_file=tmp[0])
            
            assert 'EPSG:9999' in base_config().srs.axis_order_ne
            assert 'EPSG:9999' not in base_config().srs.axis_order_en
            
            #defaults still there
            assert 'EPSG:31468' in base_config().srs.axis_order_ne
            assert 'CRS:84' in base_config().srs.axis_order_en
            
            
        
########NEW FILE########
__FILENAME__ = test_conf_loader
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import division, with_statement
import yaml
import time
from mapproxy.srs import SRS
from mapproxy.config.loader import (
    ProxyConfiguration,
    load_configuration,
    merge_dict,
    ConfigurationError,
)
from mapproxy.cache.tile import TileManager
from mapproxy.test.helper import TempFile
from mapproxy.test.unit.test_grid import assert_almost_equal_bbox
from nose.tools import eq_, assert_raises
from nose.plugins.skip import SkipTest

class TestLayerConfiguration(object):
    def _test_conf(self, yaml_part):
        base = {'sources': {'s': {'type': 'wms', 'req': {'url': ''}}}}
        base.update(yaml.load(yaml_part))
        return base

    def test_legacy_ordered(self):
        conf = self._test_conf('''
            layers:
              - one:
                 title: Layer One
                 sources: [s]
              - two:
                 title: Layer Two
                 sources: [s]
              - three:
                 title: Layer Three
                 sources: [s]
        ''')
        conf = ProxyConfiguration(conf)
        root = conf.wms_root_layer.wms_layer()

        # no root layer defined
        eq_(root.title, None)
        eq_(root.name, None)
        layers = root.child_layers()

        # names are in order
        eq_(layers.keys(), ['one', 'two', 'three'])

        eq_(len(layers), 3)
        eq_(layers['one'].title, 'Layer One')
        eq_(layers['two'].title, 'Layer Two')
        eq_(layers['three'].title, 'Layer Three')

        layers_conf = conf.layers
        eq_(len(layers_conf), 3)

    def test_legacy_unordered(self):
        conf = self._test_conf('''
            layers:
              one:
                title: Layer One
                sources: [s]
              two:
                title: Layer Two
                sources: [s]
              three:
                title: Layer Three
                sources: [s]
        ''')
        conf = ProxyConfiguration(conf)
        root = conf.wms_root_layer.wms_layer()

        # no root layer defined
        eq_(root.title, None)
        eq_(root.name, None)
        layers = root.child_layers()

        # names might not be in order
        # layers.keys() != ['one', 'two', 'three']

        eq_(len(layers), 3)
        eq_(layers['one'].title, 'Layer One')
        eq_(layers['two'].title, 'Layer Two')
        eq_(layers['three'].title, 'Layer Three')

    def test_with_root(self):
        conf = self._test_conf('''
            layers:
              name: root
              title: Root Layer
              layers:
                - name: one
                  title: Layer One
                  sources: [s]
                - name: two
                  title: Layer Two
                  sources: [s]
        ''')
        conf = ProxyConfiguration(conf)
        root = conf.wms_root_layer.wms_layer()

        eq_(root.title, 'Root Layer')
        eq_(root.name, 'root')
        layers = root.child_layers()

        # names are in order
        eq_(layers.keys(), ['root', 'one', 'two'])

        eq_(len(layers), 3)
        eq_(layers['root'].title, 'Root Layer')
        eq_(layers['one'].title, 'Layer One')
        eq_(layers['two'].title, 'Layer Two')

        layers_conf = conf.layers
        eq_(len(layers_conf), 2)

    def test_with_unnamed_root(self):
        conf = self._test_conf('''
            layers:
              title: Root Layer
              layers:
                - name: one
                  title: Layer One
                  sources: [s]
                - name: two
                  title: Layer Two
                  sources: [s]
        ''')
        conf = ProxyConfiguration(conf)
        root = conf.wms_root_layer.wms_layer()

        eq_(root.title, 'Root Layer')
        eq_(root.name, None)

        layers = root.child_layers()
        # names are in order
        eq_(layers.keys(), ['one', 'two'])

    def test_without_root(self):
        conf = self._test_conf('''
            layers:
                - name: one
                  title: Layer One
                  sources: [s]
                - name: two
                  title: Layer Two
                  sources: [s]
        ''')
        conf = ProxyConfiguration(conf)
        root = conf.wms_root_layer.wms_layer()

        eq_(root.title, None)
        eq_(root.name, None)

        layers = root.child_layers()
        # names are in order
        eq_(layers.keys(), ['one', 'two'])

    def test_hierarchy(self):
        conf = self._test_conf('''
            layers:
              title: Root Layer
              layers:
                - name: one
                  title: Layer One
                  layers:
                    - name: onea
                      title: Layer One A
                      sources: [s]
                    - name: oneb
                      title: Layer One B
                      layers:
                        - name: oneba
                          title: Layer One B A
                          sources: [s]
                        - name: onebb
                          title: Layer One B B
                          sources: [s]
                - name: two
                  title: Layer Two
                  sources: [s]
        ''')
        conf = ProxyConfiguration(conf)
        root = conf.wms_root_layer.wms_layer()

        eq_(root.title, 'Root Layer')
        eq_(root.name, None)

        layers = root.child_layers()
        # names are in order
        eq_(layers.keys(), ['one', 'onea', 'oneb', 'oneba', 'onebb', 'two'])

        layers_conf = conf.layers
        eq_(len(layers_conf), 4)
        eq_(layers_conf.keys(), ['onea', 'oneba', 'onebb', 'two'])
        eq_(layers_conf['onea'].conf['title'], 'Layer One A')
        eq_(layers_conf['onea'].conf['name'], 'onea')
        eq_(layers_conf['onea'].conf['sources'], ['s'])

    def test_hierarchy_root_is_list(self):
        conf = self._test_conf('''
            layers:
              - title: Root Layer
                layers:
                    - name: one
                      title: Layer One
                      sources: [s]
                    - name: two
                      title: Layer Two
                      sources: [s]
        ''')
        conf = ProxyConfiguration(conf)
        root = conf.wms_root_layer.wms_layer()

        eq_(root.title, 'Root Layer')
        eq_(root.name, None)

        layers = root.child_layers()
        # names are in order
        eq_(layers.keys(), ['one', 'two'])

    def test_without_sources_or_layers(self):
        conf = self._test_conf('''
            layers:
              title: Root Layer
              layers:
                - name: one
                  title: Layer One
        ''')
        conf = ProxyConfiguration(conf)
        try:
            conf.wms_root_layer.wms_layer()
        except ValueError:
            pass
        else:
            assert False, 'expected ValueError'


class TestGridConfiguration(object):
    def test_default_grids(self):
        conf = {}
        conf = ProxyConfiguration(conf)
        grid = conf.grids['GLOBAL_MERCATOR'].tile_grid()
        eq_(grid.srs, SRS(900913))

        grid = conf.grids['GLOBAL_GEODETIC'].tile_grid()
        eq_(grid.srs, SRS(4326))


    def test_simple(self):
        conf = {'grids': {'grid': {'srs': 'EPSG:4326', 'bbox': [5, 50, 10, 55]}}}
        conf = ProxyConfiguration(conf)
        grid = conf.grids['grid'].tile_grid()
        eq_(grid.srs, SRS(4326))

    def test_with_base(self):
        conf = {'grids': {
            'base_grid': {'srs': 'EPSG:4326', 'bbox': [5, 50, 10, 55]},
            'grid': {'base': 'base_grid'}
        }}
        conf = ProxyConfiguration(conf)
        grid = conf.grids['grid'].tile_grid()
        eq_(grid.srs, SRS(4326))

    def test_with_num_levels(self):
        conf = {'grids': {'grid': {'srs': 'EPSG:4326', 'bbox': [5, 50, 10, 55], 'num_levels': 8}}}
        conf = ProxyConfiguration(conf)
        grid = conf.grids['grid'].tile_grid()
        eq_(len(grid.resolutions), 8)

    def test_with_bbox_srs(self):
        conf = {'grids': {'grid': {'srs': 'EPSG:25832', 'bbox': [5, 50, 10, 55], 'bbox_srs': 'EPSG:4326'}}}
        conf = ProxyConfiguration(conf)
        grid = conf.grids['grid'].tile_grid()
        assert_almost_equal_bbox([213372, 5538660, 571666, 6102110], grid.bbox, -3)

    def test_with_min_res(self):
        conf = {'grids': {'grid': {'srs': 'EPSG:4326', 'bbox': [5, 50, 10, 55], 'min_res': 0.0390625}}}
        conf = ProxyConfiguration(conf)
        grid = conf.grids['grid'].tile_grid()
        assert_almost_equal_bbox([5, 50, 10, 55], grid.bbox, 2)
        eq_(grid.resolution(0), 0.0390625)
        eq_(grid.resolution(1), 0.01953125)

    def test_with_max_res(self):
        conf = {'grids': {'grid': {'srs': 'EPSG:4326', 'bbox': [5, 50, 10, 55], 'max_res': 0.0048828125}}}
        conf = ProxyConfiguration(conf)
        grid = conf.grids['grid'].tile_grid()
        assert_almost_equal_bbox([5, 50, 10, 55], grid.bbox, 2)
        eq_(grid.resolution(0), 0.01953125)
        eq_(grid.resolution(1), 0.01953125/2)

class TestWMSSourceConfiguration(object):
    def test_simple_grid(self):
        conf_dict = {
            'grids': {
                'grid': {'srs': 'EPSG:4326', 'bbox': [5, 50, 10, 55]},
            },
            'sources': {
                'osm': {
                    'type': 'wms',
                    'req': {
                        'url': 'http://localhost/service?',
                        'layers': 'base',
                    },
                },
            },
            'caches': {
                'osm': {
                    'sources': ['osm'],
                    'grids': ['grid'],
                }
            }
        }

        conf = ProxyConfiguration(conf_dict)

        caches = conf.caches['osm'].caches()
        eq_(len(caches), 1)
        grid, extent, manager = caches[0]

        eq_(grid.srs, SRS(4326))
        eq_(grid.bbox, (5.0, 50.0, 10.0, 55.0))

        assert isinstance(manager, TileManager)

    def check_source_layers(self, conf_dict, layers):
        conf = ProxyConfiguration(conf_dict)
        caches = conf.caches['osm'].caches()
        eq_(len(caches), 1)
        grid, extent, manager = caches[0]
        source_layers = manager.sources[0].client.request_template.params.layers
        eq_(source_layers, layers)

    def test_tagged_source(self):
        conf_dict = {
            'sources': {
                'osm': {
                    'type': 'wms',
                    'req': {
                        'url': 'http://localhost/service?',
                    },
                },
            },
            'caches': {
                'osm': {
                    'sources': ['osm:base,roads'],
                    'grids': ['GLOBAL_MERCATOR'],
                }
            }
        }
        self.check_source_layers(conf_dict, ['base', 'roads'])

    def test_tagged_source_with_layers(self):
        conf_dict = {
            'sources': {
                'osm': {
                    'type': 'wms',
                    'req': {
                        'url': 'http://localhost/service?',
                        'layers': 'base,roads,poi'
                    },
                },
            },
            'caches': {
                'osm': {
                    'sources': ['osm:base,roads'],
                    'grids': ['GLOBAL_MERCATOR'],
                }
            }
        }
        self.check_source_layers(conf_dict, ['base', 'roads'])

    def test_tagged_source_with_layers_missing(self):
        conf_dict = {
            'sources': {
                'osm': {
                    'type': 'wms',
                    'req': {
                        'url': 'http://localhost/service?',
                        'layers': 'base,poi'
                    },
                },
            },
            'caches': {
                'osm': {
                    'sources': ['osm:base,roads'],
                    'grids': ['GLOBAL_MERCATOR'],
                }
            }
        }
        conf = ProxyConfiguration(conf_dict)
        try:
            conf.caches['osm'].caches()
        except ConfigurationError, ex:
            assert 'base,roads' in ex.args[0]
            assert 'base,poi' in ex.args[0]
        else:
            assert False, 'expected ConfigurationError'

    def test_tagged_source_on_non_wms_source(self):
        conf_dict = {
            'sources': {
                'osm': {
                    'type': 'tile',
                    'url': 'http://example.org/'
                },
            },
            'caches': {
                'osm': {
                    'sources': ['osm:base,roads'],
                    'grids': ['GLOBAL_MERCATOR'],
                }
            }
        }
        conf = ProxyConfiguration(conf_dict)
        try:
            conf.caches['osm'].caches()
        except ConfigurationError, ex:
            assert 'osm:base,roads' in ex.args[0]
        else:
            assert False, 'expected ConfigurationError'


    def test_layer_tagged_source(self):
        conf_dict = {
            'layers': [
                {
                    'name': 'osm',
                    'title': 'OSM',
                    'sources': ['osm:base,roads']
                }
            ],
            'sources': {
                'osm': {
                    'type': 'wms',
                    'req': {
                        'url': 'http://localhost/service?',
                    },
                },
            },
        }
        conf = ProxyConfiguration(conf_dict)
        wms_layer = conf.layers['osm'].wms_layer()
        layers = wms_layer.map_layers[0].client.request_template.params.layers
        eq_(layers, ['base', 'roads'])

    def test_https_source_insecure(self):
        conf_dict = {
            'sources': {
                'osm': {
                    'type': 'wms',
                    'http':{'ssl_no_cert_checks': True},
                    'req': {
                        'url': 'https://foo:bar@localhost/service?',
                        'layers': 'base',
                    },
                },
            },
        }

        conf = ProxyConfiguration(conf_dict)
        try:
            conf.sources['osm'].source({'format': 'image/png'})
        except ImportError:
            raise SkipTest('no ssl support')


def load_services(conf_file):
    conf = load_configuration(conf_file)
    return conf.configured_services()

class TestConfLoading(object):
    yaml_string = """
services:
  wms:

layers:
  - name: osm
    title: OSM
    sources: [osm]

sources:
  osm:
    type: wms
    supported_srs: ['EPSG:31467']
    req:
        url: http://foo
        layers: base
"""

    def test_loading(self):
        with TempFile() as f:
            open(f, 'w').write(self.yaml_string)
            services = load_services(f)
        assert 'service' in services[0].names

    def test_loading_broken_yaml(self):
        with TempFile() as f:
            open(f, 'w').write('\tbroken:foo')
            try:
                load_services(f)
            except ConfigurationError:
                pass
            else:
                assert False, 'expected configuration error'


class TestConfImport(object):

    yaml_string = """
globals:
  http:
    client_timeout: 1
    headers:
      baz: quux
"""

    yaml_parent = """
globals:
  http:
    client_timeout: 2
    headers:
      foo: bar
      bar: qux
      baz: qax
"""

    yaml_grand_parent = """
globals:
  http:
    client_timeout: 3
    method: GET
    headers:
      bar: baz
"""

    def test_loading(self):
        with TempFile() as gp:
            open(gp, 'w').write(self.yaml_grand_parent)
            self.yaml_parent = """
base:
  - %s
%s
""" % (gp, self.yaml_parent)

            with TempFile() as p:
                open(p, 'w').write(self.yaml_parent)

                self.yaml_string = """
base: [%s]
%s
""" % (p, self.yaml_string)

                with TempFile() as cfg:
                    open(cfg, 'w').write(self.yaml_string)


                    config = load_configuration(cfg)

                    http = config.globals.get_value('http')
                    eq_(http['client_timeout'], 1)
                    eq_(http['headers']['bar'], 'qux')
                    eq_(http['headers']['foo'], 'bar')
                    eq_(http['headers']['baz'], 'quux')
                    eq_(http['method'], 'GET')

                    config_files = config.config_files()
                    eq_(set(config_files.keys()), set([gp, p, cfg]))
                    assert abs(config_files[gp] - time.time()) < 10
                    assert abs(config_files[p] - time.time()) < 10
                    assert abs(config_files[cfg] - time.time()) < 10


class TestConfMerger(object):
    def test_empty_base(self):
        a = {'a': 1, 'b': [12, 13]}
        b = {}
        m = merge_dict(a, b)
        eq_(a, m)

    def test_empty_conf(self):
        a = {}
        b = {'a': 1, 'b': [12, 13]}
        m = merge_dict(a, b)
        eq_(b, m)

    def test_differ(self):
        a = {'a': 12}
        b = {'b': 42}
        m = merge_dict(a, b)
        eq_({'a': 12, 'b': 42}, m)

    def test_recursive(self):
        a = {'a': {'aa': 12, 'a':{'aaa': 100}}}
        b = {'a': {'aa': 11, 'ab': 13, 'a':{'aaa': 101, 'aab': 101}}}
        m = merge_dict(a, b)
        eq_({'a': {'aa': 12, 'ab': 13, 'a':{'aaa': 100, 'aab': 101}}}, m)


class TestLoadConfiguration(object):
    def test_with_warnings(object):
        with TempFile() as f:
            open(f, 'w').write("""
services:
  unknown:
                """)
            load_configuration(f) # defaults to ignore_warnings=True

            assert_raises(ConfigurationError, load_configuration, f, ignore_warnings=False)


class TestImageOptions(object):
    def test_default_format(self):
        conf_dict = {
        }
        conf = ProxyConfiguration(conf_dict)
        image_opts = conf.globals.image_options.image_opts({}, 'image/png')
        eq_(image_opts.format, 'image/png')
        eq_(image_opts.mode, None)
        eq_(image_opts.colors, 256)
        eq_(image_opts.transparent, None)
        eq_(image_opts.resampling, 'bicubic')

    def test_default_format_paletted_false(self):
        conf_dict = {'globals': {'image': { 'paletted': False }}}
        conf = ProxyConfiguration(conf_dict)
        image_opts = conf.globals.image_options.image_opts({}, 'image/png')
        eq_(image_opts.format, 'image/png')
        eq_(image_opts.mode, None)
        eq_(image_opts.colors, None)
        eq_(image_opts.transparent, None)
        eq_(image_opts.resampling, 'bicubic')

    def test_update_default_format(self):
        conf_dict = {'globals': {'image': {'formats': {
            'image/png': {'colors': 16, 'resampling_method': 'nearest',
                     'encoding_options': {'quantizer': 'mediancut'}}
        }}}}
        conf = ProxyConfiguration(conf_dict)
        image_opts = conf.globals.image_options.image_opts({}, 'image/png')
        eq_(image_opts.format, 'image/png')
        eq_(image_opts.mode, None)
        eq_(image_opts.colors, 16)
        eq_(image_opts.transparent, None)
        eq_(image_opts.resampling, 'nearest')
        eq_(image_opts.encoding_options['quantizer'], 'mediancut')

    def test_custom_format(self):
        conf_dict = {'globals': {'image': {'resampling_method': 'bilinear',
            'formats': {
                'image/foo': {'mode': 'RGBA', 'colors': 42}
            }
        }}}
        conf = ProxyConfiguration(conf_dict)
        image_opts = conf.globals.image_options.image_opts({}, 'image/foo')
        eq_(image_opts.format, 'image/foo')
        eq_(image_opts.mode, 'RGBA')
        eq_(image_opts.colors, 42)
        eq_(image_opts.transparent, None)
        eq_(image_opts.resampling, 'bilinear')

    def test_format_grid(self):
        conf_dict = {
            'globals': {
                'image': {
                    'resampling_method': 'bilinear',
                }
            },
            'caches': {
                'test': {
                    'sources': [],
                    'grids': ['GLOBAL_MERCATOR'],
                    'format': 'image/png',
                }
            }
        }
        conf = ProxyConfiguration(conf_dict)
        image_opts = conf.caches['test'].image_opts()
        eq_(image_opts.format, 'image/png')
        eq_(image_opts.mode, None)
        eq_(image_opts.colors, 256)
        eq_(image_opts.transparent, None)
        eq_(image_opts.resampling, 'bilinear')

    def test_custom_format_grid(self):
        conf_dict = {
            'globals': {
                'image': {
                    'resampling_method': 'bilinear',
                    'formats': {
                        'png8': {'mode': 'P', 'colors': 256},
                        'image/png': {'mode': 'RGBA', 'transparent': True}
                    },
                }
            },
            'caches': {
                'test': {
                    'sources': [],
                    'grids': ['GLOBAL_MERCATOR'],
                    'format': 'png8',
                    'image': {
                        'colors': 16,
                    }
                },
                'test2': {
                    'sources': [],
                    'grids': ['GLOBAL_MERCATOR'],
                    'format': 'image/png',
                    'image': {
                        'colors': 8,
                    }
                }
            }
        }
        conf = ProxyConfiguration(conf_dict)
        image_opts = conf.caches['test'].image_opts()
        eq_(image_opts.format, 'image/png')
        eq_(image_opts.mode, 'P')
        eq_(image_opts.colors, 16)
        eq_(image_opts.transparent, None)
        eq_(image_opts.resampling, 'bilinear')

        image_opts = conf.caches['test2'].image_opts()
        eq_(image_opts.format, 'image/png')
        eq_(image_opts.mode, 'RGBA')
        eq_(image_opts.colors, 8)
        eq_(image_opts.transparent, True)
        eq_(image_opts.resampling, 'bilinear')

    def test_custom_format_source(self):
        conf_dict = {
            'globals': {
                'image': {
                    'resampling_method': 'bilinear',
                    'formats': {
                        'png8': {'mode': 'P', 'colors': 256, 'format': 'image/png'},
                        'image/png': {'mode': 'RGBA', 'transparent': True}
                    },
                }
            },
            'caches': {
                'test': {
                    'sources': ['test_source'],
                    'grids': ['GLOBAL_MERCATOR'],
                    'format': 'png8',
                    'image': {
                        'colors': 16,
                    }
                },
            },
            'sources': {
                'test_source': {
                    'type': 'wms',
                    'req': {
                        'url': 'http://example.org/',
                        'layers': 'foo',
                    }
                }
            }
        }
        conf = ProxyConfiguration(conf_dict)
        _grid, _extent, tile_mgr = conf.caches['test'].caches()[0]
        image_opts = tile_mgr.image_opts
        eq_(image_opts.format, 'image/png')
        eq_(image_opts.mode, 'P')
        eq_(image_opts.colors, 16)
        eq_(image_opts.transparent, None)
        eq_(image_opts.resampling, 'bilinear')

        image_opts = tile_mgr.sources[0].image_opts
        eq_(image_opts.format, 'image/png')
        eq_(image_opts.mode, 'P')
        eq_(image_opts.colors, 256)
        eq_(image_opts.transparent, None)
        eq_(image_opts.resampling, 'bilinear')


        conf_dict['caches']['test']['request_format'] = 'image/tiff'
        conf = ProxyConfiguration(conf_dict)
        _grid, _extent, tile_mgr = conf.caches['test'].caches()[0]
        image_opts = tile_mgr.image_opts
        eq_(image_opts.format, 'image/png')
        eq_(image_opts.mode, 'P')
        eq_(image_opts.colors, 16)
        eq_(image_opts.transparent, None)
        eq_(image_opts.resampling, 'bilinear')

        image_opts = tile_mgr.sources[0].image_opts
        eq_(image_opts.format, 'image/tiff')
        eq_(image_opts.mode, None)
        eq_(image_opts.colors, None)
        eq_(image_opts.transparent, None)
        eq_(image_opts.resampling, 'bilinear')

    def test_encoding_options_errors(self):
        conf_dict = {
            'globals': {
                'image': {
                    'formats': {
                        'image/jpeg': {
                            'encoding_options': {
                                'foo': 'baz',
                            }
                        }
                    },
                }
            },
        }

        try:
            conf = ProxyConfiguration(conf_dict)
        except ConfigurationError:
            pass
        else:
            raise False, 'expected ConfigurationError'


        conf_dict['globals']['image']['formats']['image/jpeg']['encoding_options'] = {
            'quantizer': 'foo'
        }
        try:
            conf = ProxyConfiguration(conf_dict)
        except ConfigurationError:
            pass
        else:
            raise False, 'expected ConfigurationError'


        conf_dict['globals']['image']['formats']['image/jpeg']['encoding_options'] = {}
        conf = ProxyConfiguration(conf_dict)
        try:
            conf.globals.image_options.image_opts({'encoding_options': {'quantizer': 'foo'}}, 'image/jpeg')
        except ConfigurationError:
            pass
        else:
            raise False, 'expected ConfigurationError'


        conf_dict['globals']['image']['formats']['image/jpeg']['encoding_options'] = {
            'quantizer': 'fastoctree'
        }
        conf = ProxyConfiguration(conf_dict)

        conf.globals.image_options.image_opts({}, 'image/jpeg')


########NEW FILE########
__FILENAME__ = test_decorate_img
from mapproxy.grid import tile_grid
from mapproxy.image import BlankImageSource
from mapproxy.image import ImageSource
from mapproxy.image.opts import ImageOptions
from mapproxy.layer import MapLayer, DefaultMapExtent
from mapproxy.platform.image import Image
from mapproxy.service.base import Server
from mapproxy.service.tile import TileServer
from mapproxy.service.wms import WMSGroupLayer, WMSServer
from mapproxy.service.wmts import WMTSServer
from mapproxy.test.http import make_wsgi_env
from mapproxy.util.ext.odict import odict
from nose.tools import eq_


class DummyLayer(MapLayer):
    transparent = True
    extent = DefaultMapExtent()
    has_legend = False
    queryable = False

    def __init__(self, name):
        MapLayer.__init__(self)
        self.name = name
        self.requested = False
        self.queried = False

    def get_map(self, query):
        self.requested = True

    def get_info(self, query):
        self.queried = True

    def map_layers_for_query(self, query):
        return [(self.name, self)]

    def info_layers_for_query(self, query):
        return [(self.name, self)]


class DummyTileLayer(object):
    def __init__(self, name):
        self.requested = False
        self.name = name
        self.grid = tile_grid(900913)

    def tile_bbox(self, request, use_profiles=False):
        # this dummy code does not handle profiles and different tile origins!
        return self.grid.tile_bbox(request.tile)

    def render(self, tile_request, use_profiles=None, coverage=None, decorate_img=None):
        self.requested = True
        resp = BlankImageSource((256, 256), image_opts=ImageOptions(format='image/png'))
        resp.timestamp = 0
        return resp


class TestDecorateImg(object):

    def setup(self):
        # Base server
        self.server = Server()
        # WMS Server
        root_layer = WMSGroupLayer(None, 'root layer', None, [DummyLayer('wms_cache')])
        self.wms_server = WMSServer(
            md={}, root_layer=root_layer, srs=['EPSG:4326'],
            image_formats={'image/png': ImageOptions(format='image/png')}
        )
        # Tile Servers
        layers = odict()
        layers["wms_cache_EPSG900913"] = DummyTileLayer('wms_cache')
        self.tile_server = TileServer(layers, {})
        self.wmts_server = WMTSServer(layers, {})
        # Common arguments
        self.query_extent = ('EPSG:27700', (0, 0, 700000, 1300000))

    def test_original_imagesource_returned_when_no_callback(self):
        img_src1 = ImageSource(Image.new('RGBA', (100, 100)))
        env = make_wsgi_env('', extra_environ={})
        img_src2 = self.server.decorate_img(
            img_src1, 'wms.map', ['layer1'],
            env, self.query_extent
        )
        eq_(img_src1, img_src2)

    def test_returns_imagesource(self):
        img_src1 = ImageSource(Image.new('RGBA', (100, 100)))
        env = make_wsgi_env('', extra_environ={})
        img_src2 = self.server.decorate_img(
            img_src1, 'wms.map', ['layer1'],
            env, self.query_extent
        )
        assert isinstance(img_src2, ImageSource)

    def set_called_callback(self, img_src, service, layers, **kw):
        self.called = True
        return img_src

    def test_calls_callback(self):
        img_src1 = ImageSource(Image.new('RGBA', (100, 100)))
        self.called = False
        env = make_wsgi_env('', extra_environ={'mapproxy.decorate_img': self.set_called_callback})
        img_src2 = self.server.decorate_img(
            img_src1, 'wms.map', ['layer1'],
            env, self.query_extent
        )
        eq_(self.called, True)

    def return_new_imagesource_callback(self, img_src, service, layers, **kw):
        new_img_src = ImageSource(Image.new('RGBA', (100, 100)))
        self.new_img_src = new_img_src
        return new_img_src

    def test_returns_callbacks_return_value(self):
        img_src1 = ImageSource(Image.new('RGBA', (100, 100)))
        env = make_wsgi_env('', extra_environ={'mapproxy.decorate_img': self.return_new_imagesource_callback})
        self.new_img_src = None
        img_src2 = self.server.decorate_img(
            img_src1, 'wms.map', ['layer1'],
            env, self.query_extent
        )
        eq_(img_src2, self.new_img_src)

    def test_wms_server(self):
        ''' Test that the decorate_img method is available on a WMSServer instance '''
        img_src1 = ImageSource(Image.new('RGBA', (100, 100)))
        self.called = False
        env = make_wsgi_env('', extra_environ={'mapproxy.decorate_img': self.set_called_callback})
        img_src2 = self.wms_server.decorate_img(
            img_src1, 'wms.map', ['layer1'],
            env, self.query_extent
        )
        eq_(self.called, True)

    def test_tile_server(self):
        ''' Test that the decorate_img method is available on a TileServer instance '''
        img_src1 = ImageSource(Image.new('RGBA', (100, 100)))
        self.called = False
        env = make_wsgi_env('', extra_environ={'mapproxy.decorate_img': self.set_called_callback})
        img_src2 = self.tile_server.decorate_img(
            img_src1, 'tms', ['layer1'],
            env, self.query_extent
        )
        eq_(self.called, True)

    def test_wmts_server(self):
        ''' Test that the decorate_img method is available on a WMTSServer instance '''
        img_src1 = ImageSource(Image.new('RGBA', (100, 100)))
        self.called = False
        env = make_wsgi_env('', extra_environ={'mapproxy.decorate_img': self.set_called_callback})
        img_src2 = self.wmts_server.decorate_img(
            img_src1, 'wmts', ['layer1'],
            env, self.query_extent
        )
        eq_(self.called, True)

    def test_args(self):
        def callback(img_src, service, layers, environ, query_extent, **kw):
            assert isinstance(img_src, ImageSource)
            eq_('wms.map', service)
            assert isinstance(layers, list)
            assert isinstance(environ, dict)
            assert len(query_extent) == 2
            assert len(query_extent[1]) == 4
            return img_src
        img_src1 = ImageSource(Image.new('RGBA', (100, 100)))
        env = make_wsgi_env('', extra_environ={'mapproxy.decorate_img': callback})
        img_src2 = self.tile_server.decorate_img(
            img_src1, 'wms.map', ['layer1'],
            env, self.query_extent
        )

########NEW FILE########
__FILENAME__ = test_exceptions
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from mapproxy.platform.image import Image
from cStringIO import StringIO
from mapproxy.test.helper import Mocker, validate_with_dtd, validate_with_xsd
from mapproxy.test.image import is_png
from mapproxy.request.wms import WMSMapRequest
from mapproxy.request import url_decode
from mapproxy.exception import (RequestError, ExceptionHandler)
from mapproxy.request.wms.exception import (WMS100ExceptionHandler, WMS111ExceptionHandler,
                                     WMS130ExceptionHandler, WMS110ExceptionHandler)
from nose.tools import eq_

class TestRequestError(Mocker):
    def test_render(self):
        req = self.mock(WMSMapRequest)
        ex_handler = self.mock(ExceptionHandler)
        
        req_ex = RequestError('the exception message', request=req)
        self.expect(req.exception_handler).result(ex_handler)
        self.expect(ex_handler.render(req_ex))
        
        self.replay()
        req_ex.render()

class ExceptionHandlerTest(Mocker):
    def setup(self):
        Mocker.setup(self)
        req = url_decode("""LAYERS=foo&FORMAT=image%2Fpng&SERVICE=WMS&VERSION=1.1.1&
REQUEST=GetMap&STYLES=&EXCEPTIONS=application%2Fvnd.ogc.se_xml&SRS=EPSG%3A900913&
BBOX=8,4,9,5&WIDTH=150&HEIGHT=100""".replace('\n', ''))
        self.req = req

class TestWMS111ExceptionHandler(Mocker):
    def test_render(self):
        req = self.mock(WMSMapRequest)
        req_ex = RequestError('the exception message', request=req)
        ex_handler = WMS111ExceptionHandler()
        self.expect(req.exception_handler).result(ex_handler)
        
        self.replay()
        response = req_ex.render()
        assert response.content_type == 'application/vnd.ogc.se_xml'
        expected_resp = """
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE ServiceExceptionReport SYSTEM "http://schemas.opengis.net/wms/1.1.1/exception_1_1_1.dtd">
<ServiceExceptionReport version="1.1.1">
    <ServiceException>the exception message</ServiceException>
</ServiceExceptionReport>
"""
        assert expected_resp.strip() == response.data
        assert validate_with_dtd(response.data, 'wms/1.1.1/exception_1_1_1.dtd')
    def test_render_w_code(self):
        req = self.mock(WMSMapRequest)
        req_ex = RequestError('the exception message', code='InvalidFormat',
                                  request=req)
        ex_handler = WMS111ExceptionHandler()
        self.expect(req.exception_handler).result(ex_handler)
        
        self.replay()
        response = req_ex.render()
        assert response.content_type == 'application/vnd.ogc.se_xml'
        expected_resp = """
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE ServiceExceptionReport SYSTEM "http://schemas.opengis.net/wms/1.1.1/exception_1_1_1.dtd">
<ServiceExceptionReport version="1.1.1">
    <ServiceException code="InvalidFormat">the exception message</ServiceException>
</ServiceExceptionReport>
"""
        assert expected_resp.strip() == response.data
        assert validate_with_dtd(response.data, 'wms/1.1.1/exception_1_1_1.dtd')
        
class TestWMS110ExceptionHandler(Mocker):
    def test_render(self):
        req = self.mock(WMSMapRequest)
        req_ex = RequestError('the exception message', request=req)
        ex_handler = WMS110ExceptionHandler()
        self.expect(req.exception_handler).result(ex_handler)
        
        self.replay()
        response = req_ex.render()
        assert response.content_type == 'application/vnd.ogc.se_xml'
        expected_resp = """
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE ServiceExceptionReport SYSTEM "http://schemas.opengis.net/wms/1.1.0/exception_1_1_0.dtd">
<ServiceExceptionReport version="1.1.0">
    <ServiceException>the exception message</ServiceException>
</ServiceExceptionReport>
"""
        assert expected_resp.strip() == response.data
        assert validate_with_dtd(response.data, 'wms/1.1.0/exception_1_1_0.dtd')
    def test_render_w_code(self):
        req = self.mock(WMSMapRequest)
        req_ex = RequestError('the exception message', code='InvalidFormat',
                                  request=req)
        ex_handler = WMS110ExceptionHandler()
        self.expect(req.exception_handler).result(ex_handler)
        
        self.replay()
        response = req_ex.render()
        assert response.content_type == 'application/vnd.ogc.se_xml'
        expected_resp = """
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE ServiceExceptionReport SYSTEM "http://schemas.opengis.net/wms/1.1.0/exception_1_1_0.dtd">
<ServiceExceptionReport version="1.1.0">
    <ServiceException code="InvalidFormat">the exception message</ServiceException>
</ServiceExceptionReport>
"""
        eq_(expected_resp.strip(), response.data)
        assert validate_with_dtd(response.data, 'wms/1.1.0/exception_1_1_0.dtd')

class TestWMS130ExceptionHandler(Mocker):
    def test_render(self):
        req = self.mock(WMSMapRequest)
        req_ex = RequestError('the exception message', request=req)
        ex_handler = WMS130ExceptionHandler()
        self.expect(req.exception_handler).result(ex_handler)
        
        self.replay()
        response = req_ex.render()
        assert response.content_type == 'text/xml; charset=utf-8'
        expected_resp = """
<?xml version='1.0' encoding="UTF-8"?>
<ServiceExceptionReport version="1.3.0"
  xmlns="http://www.opengis.net/ogc"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.opengis.net/ogc
http://schemas.opengis.net/wms/1.3.0/exceptions_1_3_0.xsd">
    <ServiceException>the exception message</ServiceException>
</ServiceExceptionReport>
"""
        assert expected_resp.strip() == response.data
        assert validate_with_xsd(response.data, 'wms/1.3.0/exceptions_1_3_0.xsd')
    def test_render_w_code(self):
        req = self.mock(WMSMapRequest)
        req_ex = RequestError('the exception message', code='InvalidFormat',
                                  request=req)
        ex_handler = WMS130ExceptionHandler()
        self.expect(req.exception_handler).result(ex_handler)
        
        self.replay()
        response = req_ex.render()
        assert response.content_type == 'text/xml; charset=utf-8'
        expected_resp = """
<?xml version='1.0' encoding="UTF-8"?>
<ServiceExceptionReport version="1.3.0"
  xmlns="http://www.opengis.net/ogc"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.opengis.net/ogc
http://schemas.opengis.net/wms/1.3.0/exceptions_1_3_0.xsd">
    <ServiceException code="InvalidFormat">the exception message</ServiceException>
</ServiceExceptionReport>
"""
        assert expected_resp.strip() == response.data
        assert validate_with_xsd(response.data, 'wms/1.3.0/exceptions_1_3_0.xsd')

class TestWMS100ExceptionHandler(Mocker):
    def test_render(self):
        req = self.mock(WMSMapRequest)
        req_ex = RequestError('the exception message', request=req)
        ex_handler = WMS100ExceptionHandler()
        self.expect(req.exception_handler).result(ex_handler)
        
        self.replay()
        response = req_ex.render()
        
        assert response.content_type == 'text/xml'
        expected_resp = """
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<WMTException version="1.0.0">
the exception message
</WMTException>
"""
        assert expected_resp.strip() == response.data

class TestWMSImageExceptionHandler(ExceptionHandlerTest):
    def test_exception(self):
        self.req.set('exceptions', 'inimage')
        self.req.set('transparent', 'true' )
        
        req = WMSMapRequest(self.req)
        req_ex = RequestError('the exception message', request=req)
        
        response = req_ex.render()
        assert response.content_type == 'image/png'
        data = StringIO(response.data)
        assert is_png(data)
        img = Image.open(data)
        assert img.size == (150, 100)
    def test_exception_w_transparent(self):
        self.req.set('exceptions', 'inimage')
        self.req.set('transparent', 'true' )
        
        req = WMSMapRequest(self.req)
        req_ex = RequestError('the exception message', request=req)
        
        response = req_ex.render()
        assert response.content_type == 'image/png'
        data = StringIO(response.data)
        assert is_png(data)
        img = Image.open(data)
        assert img.size == (150, 100)
        eq_(sorted([x for x in img.histogram() if x > 25]),
            [377, 14623])
        img = img.convert('RGBA')
        eq_(img.getpixel((0, 0))[3], 0)
    

class TestWMSBlankExceptionHandler(ExceptionHandlerTest):
    def test_exception(self):
        self.req['exceptions'] = 'blank'
        req = WMSMapRequest(self.req)
        req_ex = RequestError('the exception message', request=req)
        
        response = req_ex.render()
        assert response.content_type == 'image/png'
        data = StringIO(response.data)
        assert is_png(data)
        img = Image.open(data)
        assert img.size == (150, 100)
        eq_(img.getpixel((0, 0)), 0) #pallete image
        eq_(img.getpalette()[0:3], [255, 255, 255])
    def test_exception_w_bgcolor(self):
        self.req.set('exceptions', 'blank')
        self.req.set('bgcolor', '0xff00ff')
        
        req = WMSMapRequest(self.req)
        req_ex = RequestError('the exception message', request=req)
        
        response = req_ex.render()
        assert response.content_type == 'image/png'
        data = StringIO(response.data)
        assert is_png(data)
        img = Image.open(data)
        assert img.size == (150, 100)
        eq_(img.getpixel((0, 0)), 0) #pallete image
        eq_(img.getpalette()[0:3], [255, 0, 255])
    def test_exception_w_transparent(self):
        self.req.set('exceptions', 'blank')
        self.req.set('transparent', 'true' )
        
        req = WMSMapRequest(self.req)
        req_ex = RequestError('the exception message', request=req)
        
        response = req_ex.render()
        assert response.content_type == 'image/png'
        data = StringIO(response.data)
        assert is_png(data)
        img = Image.open(data)
        assert img.size == (150, 100)
        assert img.mode == 'P'
        img = img.convert('RGBA')
        eq_(img.getpixel((0, 0))[3], 0)
    
########NEW FILE########
__FILENAME__ = test_featureinfo
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

import os
import tempfile

from lxml import etree, html
from nose.tools import eq_

from mapproxy.featureinfo import (combined_inputs, XSLTransformer,
    XMLFeatureInfoDoc, HTMLFeatureInfoDoc)
from mapproxy.test.helper import strip_whitespace

def test_combined_inputs():
    foo = '<a><b>foo</b></a>'
    bar = '<a><b>bar</b></a>'
    
    result = combined_inputs([foo, bar])
    result = etree.tostring(result)
    eq_(result, '<a><b>foo</b><b>bar</b></a>')
    

class TestXSLTransformer(object):
    def setup(self):
        fd_, self.xsl_script = tempfile.mkstemp('.xsl')
        xsl = """
        <xsl:stylesheet version="1.0"
         xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
         <xsl:template match="/">
            <root>
                <xsl:apply-templates select='/a/b'/>
            </root>
         </xsl:template>
         <xsl:template match="/a/b">
             <foo><xsl:value-of select="text()" /></foo>
         </xsl:template>
        </xsl:stylesheet>""".strip()
        open(self.xsl_script, 'w').write(xsl)
    
    def teardown(self):
        os.remove(self.xsl_script)
        
    def test_transformer(self):
        t = XSLTransformer(self.xsl_script)
        doc = t.transform(XMLFeatureInfoDoc('<a><b>Text</b></a>'))
        eq_(strip_whitespace(doc.as_string()), '<root><foo>Text</foo></root>')

    def test_multiple(self):
        t = XSLTransformer(self.xsl_script)
        doc = t.transform(XMLFeatureInfoDoc.combine([
            XMLFeatureInfoDoc(x) for x in 
                ['<a><b>ab</b></a>', 
                 '<a><b>ab1</b><b>ab2</b><b>ab3</b></a>',
                 '<a><b>ab1</b><c>ac</c><b>ab2</b></a>',
            ]]))
        eq_(strip_whitespace(doc.as_string()), 
            strip_whitespace('''
            <root>
              <foo>ab</foo>
              <foo>ab1</foo><foo>ab2</foo><foo>ab3</foo>
              <foo>ab1</foo><foo>ab2</foo>
            </root>'''))
        eq_(doc.info_type, 'xml')
        

class TestXMLFeatureInfoDocs(object):
    def test_as_string(self):
        input_tree = etree.fromstring('<root></root>')
        doc = XMLFeatureInfoDoc(input_tree)
        eq_(strip_whitespace(doc.as_string()),
            '<root/>')
    
    def test_as_etree(self):
        doc = XMLFeatureInfoDoc('<root>hello</root>')
        eq_(doc.as_etree().getroot().text, 'hello')
    
    def test_combine(self):
        docs = [
            XMLFeatureInfoDoc('<root><a>foo</a></root>'),
            XMLFeatureInfoDoc('<root><b>bar</b></root>'),
            XMLFeatureInfoDoc('<other_root><a>baz</a></other_root>'),
        ]
        result = XMLFeatureInfoDoc.combine(docs)
        
        eq_(strip_whitespace(result.as_string()),
            strip_whitespace('<root><a>foo</a><b>bar</b><a>baz</a></root>'))
        eq_(result.info_type, 'xml')
        

class TestXMLFeatureInfoDocsNoLXML(object):
    def setup(self):
        from mapproxy import featureinfo
        self.old_etree = featureinfo.etree
        featureinfo.etree = None
    def teardown(self):
        from mapproxy import featureinfo
        featureinfo.etree = self.old_etree

    def test_combine(self):
        docs = [
            XMLFeatureInfoDoc('<root><a>foo</a></root>'),
            XMLFeatureInfoDoc('<root><b>bar</b></root>'),
            XMLFeatureInfoDoc('<other_root><a>baz</a></other_root>'),
        ]
        result = XMLFeatureInfoDoc.combine(docs)

        eq_('<root><a>foo</a></root>\n<root><b>bar</b></root>\n<other_root><a>baz</a></other_root>',
            result.as_string())
        eq_(result.info_type, 'text')
    
class TestHTMLFeatureInfoDocs(object):
    def test_as_string(self):
        input_tree = html.fromstring('<p>Foo')
        doc = HTMLFeatureInfoDoc(input_tree)
        assert '<body><p>Foo</p></body>' in strip_whitespace(doc.as_string())
    
    def test_as_etree(self):
        doc = HTMLFeatureInfoDoc('<p>hello</p>')
        eq_(doc.as_etree().find('body/p').text, 'hello')
    
    def test_combine(self):
        docs = [
            HTMLFeatureInfoDoc('<html><head><title>Hello<body><p>baz</p><p>baz2'),
            HTMLFeatureInfoDoc('<p>foo</p>'),
            HTMLFeatureInfoDoc('<body><p>bar</p></body>'),
        ]
        result = HTMLFeatureInfoDoc.combine(docs)
        assert '<title>Hello</title>' in result.as_string()
        assert ('<body><p>baz</p><p>baz2</p><p>foo</p><p>bar</p></body>' in
            result.as_string())
        eq_(result.info_type, 'html')
    
    def test_combine_parts(self):
        docs = [
            HTMLFeatureInfoDoc('<p>foo</p>'),
            HTMLFeatureInfoDoc('<body><p>bar</p></body>'),
            HTMLFeatureInfoDoc('<html><head><title>Hello<body><p>baz</p><p>baz2'),
        ]
        result = HTMLFeatureInfoDoc.combine(docs)
        
        assert ('<body><p>foo</p><p>bar</p><p>baz</p><p>baz2</p></body>' in
            result.as_string())
        eq_(result.info_type, 'html')

class TestHTMLFeatureInfoDocsNoLXML(object):
    def setup(self):
        from mapproxy import featureinfo
        self.old_etree = featureinfo.etree
        featureinfo.etree = None
    def teardown(self):
        from mapproxy import featureinfo
        featureinfo.etree = self.old_etree

    def test_combine(self):
        docs = [
            HTMLFeatureInfoDoc('<html><head><title>Hello<body><p>baz</p><p>baz2'),
            HTMLFeatureInfoDoc('<p>foo</p>'),
            HTMLFeatureInfoDoc('<body><p>bar</p></body>'),
        ]
        result = HTMLFeatureInfoDoc.combine(docs)
        
        eq_("<html><head><title>Hello<body><p>baz</p>"
            "<p>baz2\n<p>foo</p>\n<body><p>bar</p></body>",
            result.as_string())
        eq_(result.info_type, 'text')

########NEW FILE########
__FILENAME__ = test_file_lock_load
import tempfile
import os
import shutil
import time
import threading
import multiprocessing

from mapproxy.util.lock import FileLock

from nose.tools import eq_

lock_dir = tempfile.mkdtemp()
lock_file = os.path.join(lock_dir, 'lock.lck')
count_file = os.path.join(lock_dir, 'count.txt')
open(count_file, 'w').write('0')

def lock(p=None):
    l = FileLock(lock_file, timeout=60)
    l.lock()
    counter = int(open(count_file).read())
    open(count_file, 'w').write(str(counter+1))
    time.sleep(0.001)
    l.unlock()

def test_file_lock_load():
    def lock_x():
        for x in range(5):
            time.sleep(0.01)
            lock()
    threads = [threading.Thread(target=lock_x) for _ in range(20)]
    p = multiprocessing.Pool(5)
    [t.start() for t in threads]
    p.map(lock, xrange(50))
    [t.join() for t in threads]
    
    eq_(int(open(count_file).read()), 150)


def teardown():
    shutil.rmtree(lock_dir)


    
########NEW FILE########
__FILENAME__ = test_geom
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import division, with_statement

from mapproxy.srs import SRS, bbox_equals
from mapproxy.util.geom import (
    load_polygons,
    transform_geometry,
    geom_support,
    bbox_polygon,
    build_multipolygon,
)
from mapproxy.util.coverage import coverage, MultiCoverage
from mapproxy.layer import MapExtent, DefaultMapExtent
from mapproxy.test.helper import TempFile

if not geom_support:
    from nose.plugins.skip import SkipTest
    raise SkipTest('requires Shapely')
from mapproxy.util.coverage import BBOXCoverage

import shapely
import shapely.prepared

from nose.tools import eq_, raises

VALID_POLYGON1 = """POLYGON ((953296.704552185838111 7265916.626927595585585,
944916.907243740395643 7266183.505430161952972,
943803.712335807620548 7266450.200959664769471,
935361.798751499853097 7269866.750814219936728,
934743.530299633974209 7270560.353549793362617,
934743.530299633974209 7271628.176921582780778,
935794.720251194899902 7274619.979839355684817,
936567.834114754223265 7275849.767033117823303,
937959.439069160842337 7277078.402297221124172,
940062.041611264110543 7278254.31110474281013,
941948.350382756092586 7278948.856433514505625,
950513.717282353783958 7279590.533784243278205,
951905.099597778869793 7279323.193848768249154,
953976.97796042333357 7278628.807455806992948,
955337.636096389498562 7277987.20964437816292,
955646.770322322496213 7277612.74426197167486,
955894.122230865177698 7277238.489366835914552,
956759.965230255154893 7273070.375410236418247,
956790.912048695725389 7272483.464432151056826,
954255.388006897410378 7266929.622660100460052,
953760.684189812047407 7266129.1298723295331,
953296.704552185838111 7265916.626927595585585))""".replace('\n',' ')

VALID_POLYGON2 = """POLYGON ((929919.722805089084432 7252212.673410807736218,
929393.960850072442554 7252372.056830812245607,
928651.905124444281682 7252957.449742536991835,
927507.763398071052507 7254289.325379111804068,
923735.145855087204836 7261007.430086207576096,
923394.953491222811863 7261914.35770049970597,
923333.171173832495697 7262554.628265766426921,
923580.523082375293598 7263621.350993251428008,
924786.558445629663765 7266503.041579172946513,
925281.262262714910321 7267303.380754604935646,
928713.687441834714264 7270453.271698194555938,
929486.801305394037627 7271041.567251891829073,
929950.558304038597271 7271201.337567078880966,
930414.426622174330987 7270987.157654598355293,
935083.722663498250768 7255089.941797585226595,
931527.621530107106082 7252531.635323006659746,
931125.535529361688532 7252317.969672014936805,
929919.722805089084432 7252212.673410807736218))""".replace('\n',' ')

INTERSECTING_POLYGONS = """POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))
POLYGON ((5 0, 15 0, 15 10, 5 10, 5 0))
"""

class TestPolygonLoading(object):
    def test_loading_polygon(self):
        with TempFile() as fname:
            with open(fname, 'w') as f:
                f.write(VALID_POLYGON1)
            polygon = load_polygons(fname)
            bbox, polygon = build_multipolygon(polygon, simplify=True)
            assert polygon.is_valid
            eq_(polygon.type, 'Polygon')

    def test_loading_multipolygon(self):
        with TempFile() as fname:
            with open(fname, 'w') as f:
                f.write(VALID_POLYGON1)
                f.write('\n')
                f.write(VALID_POLYGON2)
            polygon = load_polygons(fname)
            bbox, polygon = build_multipolygon(polygon, simplify=True)
            assert polygon.is_valid
            eq_(polygon.type, 'MultiPolygon')

    @raises(shapely.geos.ReadingError)
    def test_loading_broken(self):
        with TempFile() as fname:
            with open(fname, 'w') as f:
                f.write("POLYGON((")
            polygon = load_polygons(fname)
            assert polygon.is_valid
            bbox, polygon = build_multipolygon(polygon, simplify=True)

    def test_loading_skip_non_polygon(self):
        with TempFile() as fname:
            with open(fname, 'w') as f:
                f.write("POINT(0 0)\n")
                f.write(VALID_POLYGON1)
            polygon = load_polygons(fname)
            bbox, polygon = build_multipolygon(polygon, simplify=True)
            assert polygon.is_valid
            eq_(polygon.type, 'Polygon')

    def test_loading_intersecting_polygons(self):
        # check that the self intersection is eliminated
        # otherwise the geometry will be invalid
        with TempFile() as fname:
            with open(fname, 'w') as f:
                f.write(INTERSECTING_POLYGONS)
            polygon = load_polygons(fname)
            bbox, polygon = build_multipolygon(polygon, simplify=True)
            assert polygon.is_valid
            eq_(polygon.type, 'Polygon')
            assert polygon.equals(shapely.geometry.Polygon([(0, 0), (15, 0), (15, 10), (0, 10)]))

class TestTransform(object):
    def test_polygon_transf(self):
        p1 = shapely.geometry.Polygon([(0, 0), (10, 0), (10, 10), (0, 10)])

        p2 = transform_geometry(SRS(4326), SRS(900913), p1)
        assert p2.contains(shapely.geometry.Point((1000000, 1000000)))
        p3 = transform_geometry(SRS(900913), SRS(4326), p2)

        assert p3.symmetric_difference(p1).area < 0.00001

    def test_multipolygon_transf(self):
        p1 = shapely.geometry.Polygon([(0, 0), (10, 0), (10, 10), (0, 10)])
        p2 = shapely.geometry.Polygon([(20, 20), (30, 20), (30, 30), (20, 30)])
        mp1 = shapely.geometry.MultiPolygon([p1, p2])

        mp2 = transform_geometry(SRS(4326), SRS(900913), mp1)
        assert mp2.contains(shapely.geometry.Point((1000000, 1000000)))
        assert not mp2.contains(shapely.geometry.Point((2000000, 2000000)))
        assert mp2.contains(shapely.geometry.Point((3000000, 3000000)))

        mp3 = transform_geometry(SRS(900913), SRS(4326), mp2)

        assert mp3.symmetric_difference(mp1).area < 0.00001

    @raises(ValueError)
    def test_invalid_transf(self):
        p = shapely.geometry.Point((0, 0))
        transform_geometry(SRS(4326), SRS(900913), p)

class TestBBOXPolygon(object):
    def test_bbox_polygon(self):
        p = bbox_polygon([5, 53, 6, 54])
        eq_(p.type, 'Polygon')


class TestGeomCoverage(object):
    def setup(self):
        # box from 10 10 to 80 80 with small spike/corner to -10 60 (upper left)
        self.geom = shapely.wkt.loads(
            "POLYGON((10 10, 10 50, -10 60, 10 80, 80 80, 80 10, 10 10))")
        self.coverage = coverage(self.geom, SRS(4326))

    def test_bbox(self):
        assert bbox_equals(self.coverage.bbox, [-10, 10, 80, 80], 0.0001)

    def test_geom(self):
        eq_(self.coverage.geom.type, 'Polygon')

    def test_contains(self):
        assert self.coverage.contains((15, 15, 20, 20), SRS(4326))
        assert self.coverage.contains((15, 15, 80, 20), SRS(4326))
        assert not self.coverage.contains((9, 10, 20, 20), SRS(4326))

    def test_intersects(self):
        assert self.coverage.intersects((15, 15, 20, 20), SRS(4326))
        assert self.coverage.intersects((15, 15, 80, 20), SRS(4326))
        assert self.coverage.intersects((9, 10, 20, 20), SRS(4326))
        assert self.coverage.intersects((-30, 10, -8, 70), SRS(4326))
        assert not self.coverage.intersects((-30, 10, -11, 70), SRS(4326))

        assert not self.coverage.intersects((0, 0, 1000, 1000), SRS(900913))
        assert self.coverage.intersects((0, 0, 1500000, 1500000), SRS(900913))

    def test_prepared(self):
        assert hasattr(self.coverage, '_prepared_max')
        self.coverage._prepared_max = 100
        for i in xrange(110):
            assert self.coverage.intersects((-30, 10, -8, 70), SRS(4326))

    def test_eq(self):
        g1 = shapely.wkt.loads("POLYGON((10 10, 10 50, -10 60, 10 80, 80 80, 80 10, 10 10))")
        g2 = shapely.wkt.loads("POLYGON((10 10, 10 50, -10 60, 10 80, 80 80, 80 10, 10 10))")
        assert coverage(g1, SRS(4326)) == coverage(g2, SRS(4326))
        assert coverage(g1, SRS(4326)) != coverage(g2, SRS(31467))
        g3 = shapely.wkt.loads("POLYGON((10.0 10, 10 50.0, -10 60, 10 80, 80 80, 80 10, 10 10))")
        assert coverage(g1, SRS(4326)) == coverage(g3, SRS(4326))
        g4 = shapely.wkt.loads("POLYGON((10 10, 10.1 50, -10 60, 10 80, 80 80, 80 10, 10 10))")
        assert coverage(g1, SRS(4326)) != coverage(g4, SRS(4326))

class TestBBOXCoverage(object):
    def setup(self):
        self.coverage = coverage([-10, 10, 80, 80], SRS(4326))

    def test_bbox(self):
        assert bbox_equals(self.coverage.bbox, [-10, 10, 80, 80], 0.0001)

    def test_geom(self):
        eq_(self.coverage.geom, None)

    def test_contains(self):
        assert self.coverage.contains((15, 15, 20, 20), SRS(4326))
        assert self.coverage.contains((15, 15, 79, 20), SRS(4326))
        assert self.coverage.contains((9, 10, 20, 20), SRS(4326))
        assert not self.coverage.contains((9, 9.99999999, 20, 20), SRS(4326))

    def test_intersects(self):
        assert self.coverage.intersects((15, 15, 20, 20), SRS(4326))
        assert self.coverage.intersects((15, 15, 80, 20), SRS(4326))
        assert self.coverage.intersects((9, 10, 20, 20), SRS(4326))
        assert self.coverage.intersects((-30, 10, -8, 70), SRS(4326))
        assert not self.coverage.intersects((-30, 10, -11, 70), SRS(4326))

        assert not self.coverage.intersects((0, 0, 1000, 1000), SRS(900913))
        assert self.coverage.intersects((0, 0, 1500000, 1500000), SRS(900913))

    def test_intersection(self):
        eq_(self.coverage.intersection((15, 15, 20, 20), SRS(4326)),
            BBOXCoverage((15, 15, 20, 20), SRS(4326)))
        eq_(self.coverage.intersection((15, 15, 80, 20), SRS(4326)),
            BBOXCoverage((15, 15, 80, 20), SRS(4326)))
        eq_(self.coverage.intersection((9, 10, 20, 20), SRS(4326)),
            BBOXCoverage((9, 10, 20, 20), SRS(4326)))
        eq_(self.coverage.intersection((-30, 10, -8, 70), SRS(4326)),
            BBOXCoverage((-10, 10, -8, 70), SRS(4326)))
        eq_(self.coverage.intersection((-30, 10, -11, 70), SRS(4326)),
            None)
        eq_(self.coverage.intersection((0, 0, 1000, 1000), SRS(900913)),
            None)
        assert bbox_equals(
            self.coverage.intersection((0, 0, 1500000, 1500000), SRS(900913)).bbox,
            (0.0, 10, 13.47472926179282, 13.352207626707813)
        )

    def test_eq(self):
        assert coverage([-10, 10, 80, 80], SRS(4326)) == coverage([-10, 10, 80, 80], SRS(4326))
        assert coverage([-10, 10, 80, 80], SRS(4326)) == coverage([-10, 10.0, 80.0, 80], SRS(4326))
        assert coverage([-10, 10, 80, 80], SRS(4326)) != coverage([-10.1, 10.0, 80.0, 80], SRS(4326))
        assert coverage([-10, 10, 80, 80], SRS(4326)) != coverage([-10, 10.0, 80.0, 80], SRS(31467))


class TestMultiCoverage(object):
    def setup(self):
        # box from 10 10 to 80 80 with small spike/corner to -10 60 (upper left)
        self.geom = shapely.wkt.loads(
            "POLYGON((10 10, 10 50, -10 60, 10 80, 80 80, 80 10, 10 10))")
        self.coverage1 = coverage(self.geom, SRS(4326))
        self.coverage2 = coverage([100, 0, 120, 20], SRS(4326))
        self.coverage = MultiCoverage([self.coverage1, self.coverage2])

    def test_bbox(self):
        assert bbox_equals(self.coverage.bbox, [-10, 0, 120, 80], 0.0001)

    def test_contains(self):
        assert self.coverage.contains((15, 15, 20, 20), SRS(4326))
        assert self.coverage.contains((15, 15, 79, 20), SRS(4326))
        assert not self.coverage.contains((9, 10, 20, 20), SRS(4326))
        assert self.coverage.contains((110, 5, 115, 15), SRS(4326))

    def test_intersects(self):
        assert self.coverage.intersects((15, 15, 20, 20), SRS(4326))
        assert self.coverage.intersects((15, 15, 80, 20), SRS(4326))
        assert self.coverage.intersects((9, 10, 20, 20), SRS(4326))
        assert self.coverage.intersects((-30, 10, -8, 70), SRS(4326))
        assert not self.coverage.intersects((-30, 10, -11, 70), SRS(4326))

        assert not self.coverage.intersects((0, 0, 1000, 1000), SRS(900913))
        assert self.coverage.intersects((0, 0, 1500000, 1500000), SRS(900913))

        assert self.coverage.intersects((110, 5, 115, 15), SRS(4326))
        assert self.coverage.intersects((90, 5, 105, 15), SRS(4326))

    def test_eq(self):
        g1 = shapely.wkt.loads("POLYGON((10 10, 10 50, -10 60, 10 80, 80 80, 80 10, 10 10))")
        g2 = shapely.wkt.loads("POLYGON((10 10, 10 50, -10 60, 10 80, 80 80, 80 10, 10 10))")
        assert MultiCoverage([coverage(g1, SRS(4326))]) == MultiCoverage([coverage(g2, SRS(4326))])
        assert MultiCoverage([coverage(g1, SRS(4326))]) != MultiCoverage([coverage(g2, SRS(31467))])
        c = coverage([-10, 10, 80, 80], SRS(4326))
        assert MultiCoverage([c, coverage(g1, SRS(4326))]) != MultiCoverage([c, coverage(g2, SRS(31467))])


class TestMapExtent(object):
    def setup(self):
        self.extent = MapExtent([-10, 10, 80, 80], SRS(4326))

    def test_bbox(self):
        assert bbox_equals(self.extent.bbox, [-10, 10, 80, 80], 0.0001)

    def test_contains(self):
        assert self.extent.contains(MapExtent((15, 15, 20, 20), SRS(4326)))
        assert self.extent.contains(MapExtent((15, 15, 79, 20), SRS(4326)))
        assert self.extent.contains(MapExtent((9, 10, 20, 20), SRS(4326)))
        assert not self.extent.contains(MapExtent((9, 9.99999999, 20, 20), SRS(4326)))

    def test_intersects(self):
        assert self.extent.intersects(MapExtent((15, 15, 20, 20), SRS(4326)))
        assert self.extent.intersects(MapExtent((15, 15, 80, 20), SRS(4326)))
        assert self.extent.intersects(MapExtent((9, 10, 20, 20), SRS(4326)))
        assert self.extent.intersects(MapExtent((-30, 10, -8, 70), SRS(4326)))
        assert not self.extent.intersects(MapExtent((-30, 10, -11, 70), SRS(4326)))

        assert not self.extent.intersects(MapExtent((0, 0, 1000, 1000), SRS(900913)))
        assert self.extent.intersects(MapExtent((0, 0, 1500000, 1500000), SRS(900913)))

    def test_eq(self):
        assert MapExtent([-10, 10, 80, 80], SRS(4326)) == MapExtent([-10, 10, 80, 80], SRS(4326))
        assert MapExtent([-10, 10, 80, 80], SRS(4326)) == MapExtent([-10, 10.0, 80.0, 80], SRS(4326))
        assert MapExtent([-10, 10, 80, 80], SRS(4326)) != MapExtent([-10.1, 10.0, 80.0, 80], SRS(4326))
        assert MapExtent([-10, 10, 80, 80], SRS(4326)) != MapExtent([-10, 10.0, 80.0, 80], SRS(31467))

    def test_intersection(self):
        assert (DefaultMapExtent().intersection(MapExtent((0, 0, 10, 10), SRS(4326)))
            == MapExtent((0, 0, 10, 10), SRS(4326)))

        assert (MapExtent((0, 0, 10, 10), SRS(4326)).intersection(MapExtent((20, 20, 30, 30), SRS(4326)))
            == None)

        sub = MapExtent((0, 0, 10, 10), SRS(4326)).intersection(MapExtent((-1000, -1000, 100000, 100000), SRS(3857)))
        bbox = SRS(3857).transform_bbox_to(SRS(4326), (0, 0, 100000, 100000), 0)
        assert bbox_equals(bbox, sub.bbox)


########NEW FILE########
__FILENAME__ = test_grid
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import division
from nose.tools import eq_, assert_almost_equal, raises
from mapproxy.grid import (
    MetaGrid,
    TileGrid,
    _create_tile_list,
    bbox_intersects,
    bbox_contains,
    NoTiles,
    tile_grid,
    resolutions,
    ResolutionRange,
    resolution_range,
    merge_resolution_range,
)
from mapproxy.srs import SRS, TransformationError

class TestResolution(object):
    def test_min_res(self):
        conf = dict(min_res=1000)
        res = resolutions(**conf)
        eq_(res[:5], [1000, 500.0, 250.0, 125.0, 62.5])
        eq_(len(res), 20)

    def test_min_res_max_res(self):
        conf = dict(min_res=1000, max_res=80)
        res = resolutions(**conf)
        eq_(res, [1000, 500.0, 250.0, 125.0])

    def test_min_res_levels(self):
        conf = dict(min_res=1600, num_levels=5)
        res = resolutions(**conf)
        eq_(res, [1600, 800.0, 400.0, 200.0, 100.0])

    def test_min_res_levels_res_factor(self):
        conf = dict(min_res=1600, num_levels=4, res_factor=4.0)
        res = resolutions(**conf)
        eq_(res, [1600, 400.0, 100.0, 25.0])

    def test_min_res_levels_sqrt2(self):
        conf = dict(min_res=1600, num_levels=5, res_factor='sqrt2')
        res = resolutions(**conf)
        eq_(map(round, res), [1600.0, 1131.0, 800.0, 566.0, 400.0])

    def test_min_res_max_res_levels(self):
        conf = dict(min_res=1600, max_res=10, num_levels=10)
        res = resolutions(**conf)
        eq_(len(res), 10)
        # will calculate log10 based factor of 1.75752...
        assert_almost_equal(res[0], 1600)
        assert_almost_equal(res[1], 1600/1.75752, 2)
        assert_almost_equal(res[8], 1600/1.75752**8, 2)
        assert_almost_equal(res[9], 10)

    def test_bbox_levels(self):
        conf = dict(bbox=[0,40,15,50], num_levels=10, tile_size=(256, 256))
        res = resolutions(**conf)
        eq_(len(res), 10)
        assert_almost_equal(res[0], 15/256)
        assert_almost_equal(res[1], 15/512)


class TestAlignedGrid(object):
    def test_epsg_4326_bbox(self):
        base = tile_grid(srs='epsg:4326')
        bbox = (10.0, -20.0, 40.0, 10.0)
        sub = tile_grid(align_with=base, bbox=bbox)

        eq_(sub.bbox, bbox)
        eq_(sub.resolution(0), 180/256/8)
        abbox, grid_size, tiles = sub.get_affected_level_tiles(bbox, 0)
        eq_(abbox, (10.0, -20.0, 55.0, 25.0))
        eq_(grid_size, (2, 2))
        eq_(list(tiles), [(0, 1, 0), (1, 1, 0), (0, 0, 0), (1, 0, 0)])

    def test_epsg_4326_bbox_from_sqrt2(self):
        base = tile_grid(srs='epsg:4326', res_factor='sqrt2')
        bbox = (10.0, -20.0, 40.0, 10.0)
        sub = tile_grid(align_with=base, bbox=bbox, res_factor=2.0)

        eq_(sub.bbox, bbox)
        eq_(sub.resolution(0), base.resolution(8))
        eq_(sub.resolution(1), base.resolution(10))
        eq_(sub.resolution(2), base.resolution(12))

    def test_epsg_4326_bbox_to_sqrt2(self):
        base = tile_grid(srs='epsg:4326', res_factor=2.0)
        bbox = (10.0, -20.0, 40.0, 10.0)
        sub = tile_grid(align_with=base, bbox=bbox, res_factor='sqrt2')

        eq_(sub.bbox, bbox)
        eq_(sub.resolution(0), base.resolution(4))
        eq_(sub.resolution(2), base.resolution(5))
        eq_(sub.resolution(4), base.resolution(6))

        assert sub.resolution(0) > sub.resolution(1) > sub.resolution(3)
        eq_(sub.resolution(3)/2, sub.resolution(5))


def test_metagrid_tiles():
    mgrid = MetaGrid(grid=TileGrid(), meta_size=(2, 2))
    assert list(mgrid.meta_tile((0, 0, 0)).tile_patterns) == \
        [((0, 0, 0), (0, 0))]
    assert list(mgrid.meta_tile((0, 1, 1)).tile_patterns) == \
        [((0, 1, 1), (0, 0)), ((1, 1, 1), (256, 0)),
         ((0, 0, 1), (0, 256)), ((1, 0, 1), (256, 256))]

    assert list(mgrid.meta_tile((1, 2, 2)).tile_patterns) == \
        [((0, 3, 2), (0, 0)), ((1, 3, 2), (256, 0)),
         ((0, 2, 2), (0, 256)), ((1, 2, 2), (256, 256))]

def test_metagrid_tiles_w_meta_size():
    mgrid = MetaGrid(grid=TileGrid(), meta_size=(4, 2))
    assert list(mgrid.meta_tile((1, 2, 2)).tile_patterns) == \
        [((0, 3, 2), (0, 0)), ((1, 3, 2), (256, 0)),
         ((2, 3, 2), (512, 0)), ((3, 3, 2), (768, 0)),
         ((0, 2, 2), (0, 256)), ((1, 2, 2), (256, 256)),
         ((2, 2, 2), (512, 256)), ((3, 2, 2), (768, 256))]

class TestMetaGridGeodetic(object):
    def setup(self):
        self.mgrid = MetaGrid(grid=tile_grid('EPSG:4326'), meta_size=(2, 2), meta_buffer=10)

    def test_meta_bbox_level_0(self):
        eq_(self.mgrid._meta_bbox((0, 0, 0)), ((-180, -90, 180, 90), (0, 0, 0, -128)))
        eq_(self.mgrid._meta_bbox((0, 0, 0), limit_to_bbox=False),
            ((-194.0625, -104.0625, 194.0625, 284.0625), (10, 10, 10, 10)))

        eq_(self.mgrid.meta_tile((0, 0, 0)).size, (256, 128))

    def test_tiles_level_0(self):
        meta_tile = self.mgrid.meta_tile((0, 0, 0))
        eq_(meta_tile.size, (256, 128))
        eq_(meta_tile.grid_size, (1, 1))
        eq_(meta_tile.tile_patterns, [((0, 0, 0), (0, -128))])

    def test_meta_bbox_level_1(self):
        eq_(self.mgrid._meta_bbox((0, 0, 1)), ((-180, -90, 180, 90), (0, 0, 0, 0)))
        eq_(self.mgrid._meta_bbox((0, 0, 1), limit_to_bbox=False),
            ((-187.03125, -97.03125, 187.03125, 97.03125), (10, 10, 10, 10)))
        eq_(self.mgrid.meta_tile((0, 0, 1)).size, (512, 256))

    def test_tiles_level_1(self):
        eq_(list(self.mgrid.meta_tile((0, 0, 1)).tile_patterns),
            [
                ((0, 0, 1), (0, 0)),
                ((1, 0, 1), (256, 0))
            ])
    def test_tile_list_level_1(self):
        eq_(list(self.mgrid.tile_list((0, 0, 1))),
            [(0, 0, 1), (1, 0, 1)])

    def test_meta_bbox_level_2(self):
        eq_(self.mgrid._meta_bbox((0, 0, 2)), ((-180, -90, 3.515625, 90), (0, 0, 10, 0)))
        eq_(self.mgrid._meta_bbox((0, 0, 2), limit_to_bbox=False),
            ((-183.515625, -93.515625, 3.515625, 93.515625), (10, 10, 10, 10)))
        eq_(self.mgrid.meta_tile((0, 0, 2)).size, (522, 512))

        eq_(self.mgrid._meta_bbox((2, 0, 2)), ((-3.515625, -90, 180, 90), (10, 0, 0, 0)))
        meta_tile = self.mgrid.meta_tile((2, 0, 2))
        eq_(meta_tile.size, (522, 512))
        eq_(meta_tile.grid_size, (2, 2))

    def test_tiles_level_2(self):
        eq_(list(self.mgrid.meta_tile((0, 0, 2)).tile_patterns),
            [
                ((0, 1, 2), (0, 0)),
                ((1, 1, 2), (256, 0)),
                ((0, 0, 2), (0, 256)),
                ((1, 0, 2), (256, 256)),
            ])
        eq_(list(self.mgrid.meta_tile((2, 0, 2)).tile_patterns),
            [
                ((2, 1, 2), (10, 0)),
                ((3, 1, 2), (266, 0)),
                ((2, 0, 2), (10, 256)),
                ((3, 0, 2), (266, 256)),
            ])

    def test_tile_list_level_2(self):
        eq_(list(self.mgrid.tile_list((0, 0, 2))),
            [(0, 1, 2), (1, 1, 2), (0, 0, 2), (1, 0, 2)])
        eq_(list(self.mgrid.tile_list((1, 1, 2))),
            [(0, 1, 2), (1, 1, 2), (0, 0, 2), (1, 0, 2)])

    def test_tiles_level_3(self):
        eq_(list(self.mgrid.meta_tile((2, 0, 3)).tile_patterns),
            [
                ((2, 1, 3), (10, 10)),
                ((3, 1, 3), (266, 10)),
                ((2, 0, 3), (10, 266)),
                ((3, 0, 3), (266, 266)),
            ])
        eq_(list(self.mgrid.meta_tile((2, 2, 3)).tile_patterns),
            [
                ((2, 3, 3), (10, 0)),
                ((3, 3, 3), (266, 0)),
                ((2, 2, 3), (10, 256)),
                ((3, 2, 3), (266, 256)),
            ])

class TestMetaGridGeodeticUL(object):
    def setup(self):
        self.tile_grid = tile_grid('EPSG:4326', origin='ul')
        self.mgrid = MetaGrid(grid=self.tile_grid, meta_size=(2, 2), meta_buffer=10)

    def test_tiles_level_0(self):
        meta_tile = self.mgrid.meta_tile((0, 0, 0))
        eq_(meta_tile.bbox, (-180, -90, 180, 90))
        eq_(meta_tile.size, (256, 128))
        eq_(meta_tile.grid_size, (1, 1))
        eq_(meta_tile.tile_patterns, [((0, 0, 0), (0, 0))])


    def test_tiles_level_1(self):
        meta_tile = self.mgrid.meta_tile((0, 0, 1))
        eq_(meta_tile.bbox, (-180, -90, 180, 90))
        eq_(meta_tile.size, (512, 256))
        eq_(meta_tile.grid_size, (2, 1))
        eq_(list(meta_tile.tile_patterns),
            [
                ((0, 0, 1), (0, 0)),
                ((1, 0, 1), (256, 0))
            ])

    def test_tile_list_level_1(self):
        eq_(list(self.mgrid.tile_list((0, 0, 1))),
            [(0, 0, 1), (1, 0, 1)])

    def test_tiles_level_2(self):
        meta_tile = self.mgrid.meta_tile((0, 0, 2))
        eq_(meta_tile.bbox, (-180, -90, 3.515625, 90))
        eq_(meta_tile.size, (522, 512))
        eq_(meta_tile.grid_size, (2, 2))
        eq_(meta_tile.tile_patterns,
            [
                ((0, 0, 2), (0, 0)),
                ((1, 0, 2), (256, 0)),
                ((0, 1, 2), (0, 256)),
                ((1, 1, 2), (256, 256)),
            ])
        eq_(list(self.mgrid.meta_tile((2, 0, 2)).tile_patterns),
            [
                ((2, 0, 2), (10, 0)),
                ((3, 0, 2), (266, 0)),
                ((2, 1, 2), (10, 256)),
                ((3, 1, 2), (266, 256)),
            ])

    def test_tile_list_level_2(self):
        eq_(list(self.mgrid.tile_list((0, 0, 2))),
            [(0, 0, 2), (1, 0, 2), (0, 1, 2), (1, 1, 2)])
        eq_(list(self.mgrid.tile_list((1, 1, 2))),
            [(0, 0, 2), (1, 0, 2), (0, 1, 2), (1, 1, 2)])

    def test_tiles_level_3(self):
        meta_tile = self.mgrid.meta_tile((2, 0, 3))
        eq_(meta_tile.bbox, (-91.7578125, -1.7578125, 1.7578125, 90))
        eq_(meta_tile.size, (532, 522))
        eq_(meta_tile.grid_size, (2, 2))
        eq_(list(self.mgrid.meta_tile((2, 0, 3)).tile_patterns),
            [
                ((2, 0, 3), (10, 0)),
                ((3, 0, 3), (266, 0)),
                ((2, 1, 3), (10, 256)),
                ((3, 1, 3), (266, 256)),
            ])
        eq_(list(self.mgrid.meta_tile((2, 2, 3)).tile_patterns),
            [
                ((2, 2, 3), (10, 10)),
                ((3, 2, 3), (266, 10)),
                ((2, 3, 3), (10, 266)),
                ((3, 3, 3), (266, 266)),
            ])


class TestMetaTile(object):
    def setup(self):
        self.mgrid = MetaGrid(grid=tile_grid('EPSG:4326'), meta_size=(2, 2), meta_buffer=10)
    def test_meta_tile(self):
        meta_tile = self.mgrid.meta_tile((2, 0, 2))
        eq_(meta_tile.size, (522, 512))

    def test_metatile_bbox(self):
        mgrid = MetaGrid(grid=TileGrid(), meta_size=(2, 2))
        meta_tile = mgrid.meta_tile((0, 0, 2))
        assert meta_tile.bbox == (-20037508.342789244, -20037508.342789244, 0.0, 0.0)
        meta_tile = mgrid.meta_tile((1, 1, 2))
        assert meta_tile.bbox == (-20037508.342789244, -20037508.342789244, 0.0, 0.0)
        meta_tile = mgrid.meta_tile((4, 5, 3))
        assert_almost_equal_bbox(meta_tile.bbox, (0.0, 0.0, 10018754.171394622, 10018754.171394622))

    def test_metatile_non_default_meta_size(self):
        mgrid = MetaGrid(grid=TileGrid(), meta_size=(4, 2))
        meta_tile = mgrid.meta_tile((4, 5, 3))
        assert_almost_equal_bbox(meta_tile.bbox, (0.0, 0.0, 20037508.342789244, 10018754.171394622))
        eq_(meta_tile.size, (1024, 512))
        eq_(meta_tile.grid_size, (4, 2))

class TestMetaTileSQRT2(object):
    def setup(self):
        self.grid = tile_grid('EPSG:4326', res_factor='sqrt2')
        self.mgrid = MetaGrid(grid=self.grid, meta_size=(4, 4), meta_buffer=10)
    def test_meta_tile(self):
        meta_tile = self.mgrid.meta_tile((0, 0, 8))
        eq_(meta_tile.size, (1034, 1034))

    def test_metatile_bbox(self):
        meta_tile = self.mgrid.meta_tile((0, 0, 2))
        eq_(meta_tile.bbox,  (-180, -90, 180, 90))
        eq_(meta_tile.size,  (512, 256))
        eq_(meta_tile.grid_size,  (2, 1))
        eq_(meta_tile.tile_patterns, [((0, 0, 2), (0, 0)), ((1, 0, 2), (256, 0))])

        meta_tile = self.mgrid.meta_tile((1, 0, 2))
        eq_(meta_tile.bbox, (-180.0, -90, 180.0, 90.0))
        eq_(meta_tile.size,  (512, 256))
        eq_(meta_tile.grid_size,  (2, 1))

        meta_tile = self.mgrid.meta_tile((0, 0, 3))
        eq_(meta_tile.bbox, (-180.0, -90, 180.0, 90.0))
        eq_(meta_tile.size,  (724, 362))
        eq_(meta_tile.tile_patterns, [((0, 1, 3), (0, -149)), ((1, 1, 3), (256, -149)),
            ((2, 1, 3), (512, -149)), ((0, 0, 3), (0, 107)), ((1, 0, 3), (256, 107)),
            ((2, 0, 3), (512, 107))])

    def test_metatile_non_default_meta_size(self):
        mgrid = MetaGrid(grid=self.grid, meta_size=(4, 2), meta_buffer=0)
        meta_tile = mgrid.meta_tile((4, 3, 6))
        eq_(meta_tile.bbox, (0.0, 0.0, 180.0, 90.0))
        eq_(meta_tile.size, (1024, 512))
        eq_(meta_tile.grid_size, (4, 2))
        eq_(meta_tile.tile_patterns, [((4, 3, 6), (0, 0)), ((5, 3, 6), (256, 0)),
            ((6, 3, 6), (512, 0)), ((7, 3, 6), (768, 0)), ((4, 2, 6), (0, 256)),
            ((5, 2, 6), (256, 256)), ((6, 2, 6), (512, 256)), ((7, 2, 6), (768, 256))])




class TestMinimalMetaTile(object):
    def setup(self):
        self.mgrid = MetaGrid(grid=tile_grid('EPSG:4326'), meta_size=(2, 2), meta_buffer=10)

    def test_minimal_tiles(self):
        sgrid = self.mgrid.minimal_meta_tile([(0, 0, 2), (1, 0, 2)])
        eq_(sgrid.grid_size, (2, 1))
        eq_(list(sgrid.tile_patterns),
            [
                ((0, 0, 2), (0, 10)),
                ((1, 0, 2), (256, 10)),
            ]
        )
        eq_(sgrid.bbox, (-180.0, -90.0, 3.515625, 3.515625))

    def test_minimal_tiles_fragmented(self):
        sgrid = self.mgrid.minimal_meta_tile(
            [
                           (2, 3, 3),
                (1, 2, 3),
                           (2, 1, 3),
            ])

        eq_(sgrid.grid_size, (2, 3))
        eq_(list(sgrid.tile_patterns),
            [
                ((1, 3, 3), (10, 0)), ((2, 3, 3), (266, 0)),
                ((1, 2, 3), (10, 256)), ((2, 2, 3), (266, 256)),
                ((1, 1, 3), (10, 512)), ((2, 1, 3), (266, 512)),
            ]
        )
        eq_(sgrid.bbox, (-136.7578125, -46.7578125, -43.2421875, 90.0))

    def test_minimal_tiles_fragmented_ul(self):
        self.mgrid = MetaGrid(grid=tile_grid('EPSG:4326', origin='ul'),
            meta_size=(2, 2), meta_buffer=10)
        sgrid = self.mgrid.minimal_meta_tile(
            [
                           (2, 0, 3),
                (1, 1, 3),
                           (2, 2, 3),
            ])

        eq_(sgrid.grid_size, (2, 3))
        eq_(list(sgrid.tile_patterns),
            [
                ((1, 0, 3), (10, 0)), ((2, 0, 3), (266, 0)),
                ((1, 1, 3), (10, 256)), ((2, 1, 3), (266, 256)),
                ((1, 2, 3), (10, 512)), ((2, 2, 3), (266, 512)),
            ]
        )
        eq_(sgrid.bbox, (-136.7578125, -46.7578125, -43.2421875, 90.0))


class TestMetaGridLevelMetaTiles(object):
    def __init__(self):
        self.meta_grid = MetaGrid(TileGrid(), meta_size=(2, 2))

    def test_full_grid_0(self):
        bbox = (-20037508.34, -20037508.34, 20037508.34, 20037508.34)
        abbox, tile_grid, meta_tiles = \
            self.meta_grid.get_affected_level_tiles(bbox, 0)
        meta_tiles = list(meta_tiles)
        assert_almost_equal_bbox(bbox, abbox)

        eq_(len(meta_tiles), 1)
        eq_(meta_tiles[0], (0, 0, 0))

    def test_full_grid_2(self):
        bbox = (-20037508.34, -20037508.34, 20037508.34, 20037508.34)
        abbox, tile_grid, meta_tiles = \
            self.meta_grid.get_affected_level_tiles(bbox, 2)
        meta_tiles = list(meta_tiles)
        assert_almost_equal_bbox(bbox, abbox)

        eq_(tile_grid, (2, 2))
        eq_(len(meta_tiles), 4)
        eq_(meta_tiles[0], (0, 2, 2))
        eq_(meta_tiles[1], (2, 2, 2))
        eq_(meta_tiles[2], (0, 0, 2))
        eq_(meta_tiles[3], (2, 0, 2))

class TestMetaGridLevelMetaTilesGeodetic(object):
    def __init__(self):
        self.meta_grid = MetaGrid(TileGrid(is_geodetic=True), meta_size=(2, 2))

    def test_full_grid_2(self):
        bbox = (-180.0, -90.0, 180.0, 90)
        abbox, tile_grid, meta_tiles = \
            self.meta_grid.get_affected_level_tiles(bbox, 2)
        meta_tiles = list(meta_tiles)
        assert_almost_equal_bbox(bbox, abbox)

        eq_(tile_grid, (2, 1))
        eq_(len(meta_tiles), 2)
        eq_(meta_tiles[0], (0, 0, 2))
        eq_(meta_tiles[1], (2, 0, 2))

    def test_partial_grid_3(self):
        bbox = (0.0, 5.0, 45, 40)
        abbox, tile_grid, meta_tiles = \
            self.meta_grid.get_affected_level_tiles(bbox, 3)
        meta_tiles = list(meta_tiles)
        assert_almost_equal_bbox((0.0, 0.0, 90.0, 90.0), abbox)

        eq_(tile_grid, (1, 1))
        eq_(len(meta_tiles), 1)
        eq_(meta_tiles[0], (4, 2, 3))


def assert_grid_size(grid, level, grid_size):
    print grid.grid_sizes[level], "==", grid_size
    assert grid.grid_sizes[level] == grid_size
    res = grid.resolutions[level]
    x, y = grid_size
    assert res * x * 256 >= grid.bbox[2] - grid.bbox[0]
    assert res * y * 256 >= grid.bbox[3] - grid.bbox[1]


class TileGridTest(object):
    def check_grid(self, level, grid_size):
        assert_grid_size(self.grid, level, grid_size)

class TestTileGridResolutions(object):
    def test_explicit_grid(self):
        grid = TileGrid(res=[0.1, 0.05, 0.01])
        eq_(grid.resolution(0), 0.1)
        eq_(grid.resolution(1), 0.05)
        eq_(grid.resolution(2), 0.01)

        eq_(grid.closest_level(0.00001), 2)

    def test_factor_grid(self):
        grid = TileGrid(is_geodetic=True, res=1/0.75, tile_size=(360, 180))
        eq_(grid.resolution(0), 1.0)
        eq_(grid.resolution(1), 0.75)
        eq_(grid.resolution(2), 0.75*0.75)

    def test_sqrt_grid(self):
        grid = TileGrid(is_geodetic=True, res='sqrt2', tile_size=(360, 180))
        eq_(grid.resolution(0), 1.0)
        assert_almost_equal(grid.resolution(2), 0.5)
        assert_almost_equal(grid.resolution(4), 0.25)


class TestWGS84TileGrid(object):
    def setup(self):
        self.grid = TileGrid(is_geodetic=True)

    def test_resolution(self):
        assert_almost_equal(self.grid.resolution(0), 1.40625)
        assert_almost_equal(self.grid.resolution(1), 1.40625/2)

    def test_bbox(self):
        eq_(self.grid.bbox, (-180.0, -90.0, 180.0, 90.0))

    def test_grid_size(self):
        eq_(self.grid.grid_sizes[0], (1, 1))
        eq_(self.grid.grid_sizes[1], (2, 1))
        eq_(self.grid.grid_sizes[2], (4, 2))

    def test_affected_tiles(self):
        bbox, grid, tiles = self.grid.get_affected_tiles((-180,-90,180,90), (512,256))
        eq_(bbox, (-180.0, -90.0, 180.0, 90.0))
        eq_(grid, (2, 1))
        eq_(list(tiles), [(0, 0, 1), (1, 0, 1)])

    def test_affected_level_tiles(self):
        bbox, grid, tiles = self.grid.get_affected_level_tiles((-180,-90,180,90), 1)
        eq_(grid, (2, 1))
        eq_(bbox, (-180.0, -90.0, 180.0, 90.0))
        eq_(list(tiles), [(0, 0, 1), (1, 0, 1)])
        bbox, grid, tiles = self.grid.get_affected_level_tiles((0,0,180,90), 2)
        eq_(grid, (2, 1))
        eq_(bbox, (0.0, 0.0, 180.0, 90.0))
        eq_(list(tiles), [(2, 1, 2), (3, 1, 2)])

class TestWGS83TileGridUL(object):
    def setup(self):
        self.grid = TileGrid(4326, bbox=(-180, -90, 180, 90), origin='ul')

    def test_resolution(self):
        assert_almost_equal(self.grid.resolution(0), 1.40625)
        assert_almost_equal(self.grid.resolution(1), 1.40625/2)

    def test_bbox(self):
        eq_(self.grid.bbox, (-180.0, -90.0, 180.0, 90.0))

    def test_tile_bbox(self):
        eq_(self.grid.tile_bbox((0, 0, 0)), (-180.0, -270.0, 180.0, 90.0))
        eq_(self.grid.tile_bbox((0, 0, 0), limit=True), (-180.0, -90.0, 180.0, 90.0))
        eq_(self.grid.tile_bbox((0, 0, 1)), (-180.0, -90.0, 0.0, 90.0))

    def test_tile(self):
        eq_(self.grid.tile(-170, -80, 0), (0, 0, 0))
        eq_(self.grid.tile(-170, -80, 1), (0, 0, 1))
        eq_(self.grid.tile(-170, -80, 2), (0, 1, 2))

    def test_grid_size(self):
        eq_(self.grid.grid_sizes[0], (1, 1))
        eq_(self.grid.grid_sizes[1], (2, 1))
        eq_(self.grid.grid_sizes[2], (4, 2))

    def test_affected_tiles(self):
        bbox, grid, tiles = self.grid.get_affected_tiles((-180,-90,180,90), (512,256))
        eq_(bbox, (-180.0, -90.0, 180.0, 90.0))
        eq_(grid, (2, 1))
        eq_(list(tiles), [(0, 0, 1), (1, 0, 1)])

        bbox, grid, tiles = self.grid.get_affected_tiles((-180,-90,0,90), (512, 512))
        eq_(bbox, (-180.0, -90.0, 0.0, 90.0))
        eq_(grid, (2, 2))
        eq_(list(tiles), [(0, 0, 2), (1, 0, 2), (0, 1, 2), (1, 1, 2)])

    def test_affected_level_tiles(self):
        bbox, grid, tiles = self.grid.get_affected_level_tiles((-180,-90,180,90), 1)
        eq_(grid, (2, 1))
        eq_(bbox, (-180.0, -90.0, 180.0, 90.0))
        eq_(list(tiles), [(0, 0, 1), (1, 0, 1)])
        bbox, grid, tiles = self.grid.get_affected_level_tiles((0,0,180,90), 2)
        eq_(grid, (2, 1))
        eq_(list(tiles), [(2, 0, 2), (3, 0, 2)])
        eq_(bbox, (0.0, 0.0, 180.0, 90.0))
        bbox, grid, tiles = self.grid.get_affected_level_tiles((0,-90,180,90), 2)
        eq_(grid, (2, 2))
        eq_(list(tiles), [(2, 0, 2), (3, 0, 2), (2, 1, 2), (3, 1, 2)])
        eq_(bbox, (0.0, -90.0, 180.0, 90.0))

class TestGKTileGrid(TileGridTest):
    def setup(self):
        self.grid = TileGrid(SRS(31467), bbox=(3250000, 5230000, 3930000, 6110000))

    def test_bbox(self):
        assert self.grid.bbox == (3250000, 5230000, 3930000, 6110000)

    def test_resolution(self):
        res = self.grid.resolution(0)
        width = self.grid.bbox[2] - self.grid.bbox[0]
        height = self.grid.bbox[3] - self.grid.bbox[1]
        assert height == 880000.0 and width == 680000.0
        assert res == 880000.0/256

    def test_tile_bbox(self):
        tile_bbox = self.grid.tile_bbox((0, 0, 0))
        assert tile_bbox == (3250000.0, 5230000.0, 4130000.0, 6110000.0)

    def test_tile(self):
        x, y = 3450000, 5890000
        assert [self.grid.tile(x, y, level) for level in range(5)] == \
            [(0, 0, 0), (0, 1, 1), (0, 3, 2), (1, 6, 3), (3, 12, 4)]

    def test_grids(self):
        for level, grid_size in [(0, (1, 1)), (1, (2, 2)), (2, (4, 4)), (3, (7, 8))]:
            yield self.check_grid, level, grid_size

    def test_closest_level(self):
        assert self.grid.closest_level(880000.0/256) == 0
        assert self.grid.closest_level(600000.0/256) == 1
        assert self.grid.closest_level(440000.0/256) == 1
        assert self.grid.closest_level(420000.0/256) == 1

    def test_adjacent_tile_bbox(self):
        t1 = self.grid.tile_bbox((0, 0, 1))
        t2 = self.grid.tile_bbox((1, 0, 1))
        t3 = self.grid.tile_bbox((0, 1, 1))
        assert t1[1] == t2[1]
        assert t1[3] == t2[3]
        assert t1[2] == t2[0]
        assert t1[0] == t3[0]
        assert t1[3] == t3[1]


class TestGKTileGridUL(TileGridTest):
    """
    Custom grid with ul origin.
    """
    def setup(self):
        self.grid = TileGrid(SRS(31467),
            bbox=(3300000, 5300000, 3900000, 6000000), origin='ul',
            res=[1500, 1000, 500, 300, 150, 100])

    def test_bbox(self):
        assert self.grid.bbox == (3300000, 5300000, 3900000, 6000000)

    def test_tile_bbox(self):
        eq_(self.grid.tile_bbox((0, 0, 0)),
            (3300000.0, 5616000.0, 3684000.0, 6000000.0))
        eq_(self.grid.tile_bbox((1, 0, 0)),
            (3684000.0, 5616000.0, 4068000.0, 6000000.0))
        eq_(self.grid.tile_bbox((1, 1, 0)),
            (3684000.0, 5232000.0, 4068000.0, 5616000.0))

    def test_tile(self):
        x, y = 3310000, 5990000
        eq_(self.grid.tile(x, y, 0), (0, 0, 0))
        eq_(self.grid.tile(x, y, 1), (0, 0, 1))
        eq_(self.grid.tile(x, y, 2), (0, 0, 2))

        x, y = 3890000, 5310000
        eq_(self.grid.tile(x, y, 0), (1, 1, 0))
        eq_(self.grid.tile(x, y, 1), (2, 2, 1))
        eq_(self.grid.tile(x, y, 2), (4, 5, 2))

    def test_grids(self):
        assert_grid_size(self.grid, 0, (2, 2))
        assert_grid_size(self.grid, 1, (3, 3))
        assert_grid_size(self.grid, 2, (5, 6))

    def test_closest_level(self):
        assert self.grid.closest_level(1500) == 0
        assert self.grid.closest_level(1000) == 1
        assert self.grid.closest_level(900) == 1
        assert self.grid.closest_level(600) == 2

    def test_adjacent_tile_bbox(self):
        t1 = self.grid.tile_bbox((0, 0, 1))
        t2 = self.grid.tile_bbox((1, 0, 1))
        t3 = self.grid.tile_bbox((0, 1, 1))
        assert t1[1] == t2[1]
        assert t1[3] == t2[3]
        assert t1[2] == t2[0]
        assert t1[0] == t3[0]
        assert t1[1] == t3[3]


class TestOrigins(object):
    def test_basic(self):
        grid = tile_grid(4326, bbox=(-180, -90, 180, 90), origin='ll')
        assert grid.supports_access_with_origin('ll')
        assert not grid.supports_access_with_origin('ul')

        grid = tile_grid(4326, bbox=(-180, -90, 180, 90), origin='ul')
        assert not grid.supports_access_with_origin('ll')
        assert grid.supports_access_with_origin('ul')

    def test_basic_no_level_zero(self):
        grid = tile_grid(4326, bbox=(-180, -90, 180, 90), origin='ll',
            min_res=360/256/2)
        assert grid.supports_access_with_origin('ll')
        assert grid.supports_access_with_origin('ul')

        grid = tile_grid(4326, bbox=(-180, -90, 180, 90), origin='ul',
            min_res=360/256/2)
        assert grid.supports_access_with_origin('ll')
        assert grid.supports_access_with_origin('ul')

    def test_basic_mixed_name(self):
        grid = tile_grid(4326, bbox=(-180, -90, 180, 90), origin='ll')
        assert grid.supports_access_with_origin('sw')
        assert not grid.supports_access_with_origin('nw')

        grid = tile_grid(4326, bbox=(-180, -90, 180, 90), origin='ul')
        assert not grid.supports_access_with_origin('sw')
        assert grid.supports_access_with_origin('nw')

    def test_custom_with_match(self):
        # height is divisible by res*tile_size
        grid = tile_grid(4326, bbox=(0, 0, 1024, 1024), origin='ll',
            min_res=1)
        assert grid.supports_access_with_origin('ll')
        assert grid.supports_access_with_origin('ul')

        grid = tile_grid(4326, bbox=(0, 0, 1024, 1024), origin='ul',
            min_res=1)
        assert grid.supports_access_with_origin('ll')
        assert grid.supports_access_with_origin('ul')

    def test_custom_without_match(self):
        # height is not divisible by res*tile_size
        grid = tile_grid(4326, bbox=(0, 0, 1024, 1000), origin='ll',
            min_res=1)
        assert grid.supports_access_with_origin('ll')
        assert not grid.supports_access_with_origin('ul')

        grid = tile_grid(4326, bbox=(0, 0, 1024, 1000), origin='ul',
            min_res=1)
        assert not grid.supports_access_with_origin('ll')
        assert grid.supports_access_with_origin('ul')

    def test_custom_res_with_match(self):
        grid = tile_grid(4326, bbox=(0, 0, 1024, 1024), origin='ll',
            res=[1, 0.5, 0.25])
        assert grid.supports_access_with_origin('ll')
        assert grid.supports_access_with_origin('ul')

        grid = tile_grid(4326, bbox=(0, 0, 1024, 1024), origin='ul',
            res=[1, 0.5, 0.25])
        assert grid.supports_access_with_origin('ll')
        assert grid.supports_access_with_origin('ul')

    def test_custom_res_without_match(self):
        grid = tile_grid(4326, bbox=(0, 0, 1024, 1023), origin='ll',
            res=[1, 0.5, 0.25])
        assert grid.supports_access_with_origin('ll')
        assert not grid.supports_access_with_origin('ul')

        grid = tile_grid(4326, bbox=(0, 0, 1024, 1023), origin='ul',
            res=[1, 0.5, 0.25])
        assert not grid.supports_access_with_origin('ll')
        assert grid.supports_access_with_origin('ul')

class TestFixedResolutionsTileGrid(TileGridTest):
    def setup(self):
        self.res = [1000.0, 500.0, 200.0, 100.0, 50.0, 20.0, 5.0]
        bbox = (3250000, 5230000, 3930000, 6110000)
        self.grid = TileGrid(SRS(31467), bbox=bbox, res=self.res)

    def test_resolution(self):
        for level, res in enumerate(self.res):
            assert res == self.grid.resolution(level)

    def test_closest_level(self):
        assert self.grid.closest_level(2000) == 0
        assert self.grid.closest_level(1000) == 0
        assert self.grid.closest_level(950) == 0
        assert self.grid.closest_level(210) == 2

    def test_affected_tiles(self):
        req_bbox = (3250000, 5230000, 3930000, 6110000)
        self.grid.max_shrink_factor = 10
        bbox, grid_size, tiles = \
            self.grid.get_affected_tiles(req_bbox, (256, 256))
        assert bbox == (req_bbox[0], req_bbox[1],
                        req_bbox[0]+1000*256*3, req_bbox[1]+1000*256*4)
        assert grid_size == (3, 4)
        tiles = list(tiles)
        assert tiles == [(0, 3, 0), (1, 3, 0), (2, 3, 0),
                         (0, 2, 0), (1, 2, 0), (2, 2, 0),
                         (0, 1, 0), (1, 1, 0), (2, 1, 0),
                         (0, 0, 0), (1, 0, 0), (2, 0, 0),
                         ]

    def test_affected_tiles_2(self):
        req_bbox = (3250000, 5230000, 3930000, 6110000)
        self.grid.max_shrink_factor = 2.0
        try:
            bbox, grid_size, tiles = \
                self.grid.get_affected_tiles(req_bbox, (256, 256))
        except NoTiles:
            pass
        else:
            assert False, 'got no exception'
    def test_grid(self):
        for level, grid_size in [(0, (3, 4)), (1, (6, 7)), (2, (14, 18))]:
            yield self.check_grid, level, grid_size

    def test_tile_bbox(self):
        tile_bbox = self.grid.tile_bbox((0, 0, 0)) # w: 1000x256
        assert tile_bbox == (3250000.0, 5230000.0, 3506000.0, 5486000.0)
        tile_bbox = self.grid.tile_bbox((0, 0, 1)) # w: 500x256
        assert tile_bbox == (3250000.0, 5230000.0, 3378000.0, 5358000.0)
        tile_bbox = self.grid.tile_bbox((0, 0, 2)) # w: 200x256
        assert tile_bbox == (3250000.0, 5230000.0, 3301200.0, 5281200.0)

class TestGeodeticTileGrid(TileGridTest):
    def setup(self):
        self.grid = TileGrid(is_geodetic=True, )
    def test_auto_resolution(self):
        grid = TileGrid(is_geodetic=True, bbox=(-10, 30, 10, 40), tile_size=(20, 20))
        tile_bbox = grid.tile_bbox((0, 0, 0))
        assert tile_bbox == (-10, 30, 10, 50)
        assert grid.resolution(0) == 1.0

    def test_grid(self):
        for level, grid_size in [(0, (1, 1)), (1, (2, 1)), (2, (4, 2))]:
            yield self.check_grid, level, grid_size

    def test_adjacent_tile_bbox(self):
        grid = TileGrid(is_geodetic=True, bbox=(-10, 30, 10, 40), tile_size=(20, 20))
        t1 = grid.tile_bbox((0, 0, 2))
        t2 = grid.tile_bbox((1, 0, 2))
        t3 = grid.tile_bbox((0, 1, 2))
        assert t1[1] == t2[1]
        assert t1[3] == t2[3]
        assert t1[2] == t2[0]
        assert t1[0] == t3[0]
        assert t1[2] == t3[2]
        assert t1[3] == t3[1]

    def test_w_resolution(self):
        res = [1, 0.5, 0.2]
        grid = TileGrid(is_geodetic=True, bbox=(-10, 30, 10, 40), tile_size=(20, 20), res=res)
        assert grid.grid_sizes[0] == (1, 1)
        assert grid.grid_sizes[1] == (2, 1)
        assert grid.grid_sizes[2] == (5, 3)

    def test_tile(self):
        assert self.grid.tile(-180, -90, 0) == (0, 0, 0)
        assert self.grid.tile(-180, -90, 1) == (0, 0, 1)
        assert self.grid.tile(-180, -90, 2) == (0, 0, 2)
        assert self.grid.tile(180-0.001, 90-0.001, 0) == (0, 0, 0)
        assert self.grid.tile(10, 50, 1) == (1, 0, 1)

    def test_affected_tiles(self):
        bbox, grid_size, tiles = \
            self.grid.get_affected_tiles((-45,-45,45,45), (512,512))
        assert self.grid.grid_sizes[3] == (8, 4)
        assert bbox == (-45.0, -45.0, 45.0, 45.0)
        assert grid_size == (2, 2)
        tiles = list(tiles)
        assert tiles == [(3, 2, 3), (4, 2, 3), (3, 1, 3), (4, 1, 3)]

class TestTileGrid(object):
    def test_tile_out_of_grid_bounds(self):
        grid = TileGrid(is_geodetic=True)
        eq_(grid.tile(-180.01, 50, 1), (-1, 0, 1))

    def test_affected_tiles_out_of_grid_bounds(self):
        grid = TileGrid()
        #bbox from open layers
        req_bbox = (-30056262.509599999, -10018754.170400001, -20037508.339999996, -0.00080000050365924835)
        bbox, grid_size, tiles = \
            grid.get_affected_tiles(req_bbox, (256, 256))
        assert_almost_equal_bbox(bbox, req_bbox)
        eq_(grid_size, (1, 1))
        tiles = list(tiles)
        eq_(tiles, [None])
    def test_broken_bbox(self):
        grid = TileGrid()
        # broken request from "ArcGIS Client Using WinInet"
        req_bbox = (-10000855.0573254,2847125.18913603,-9329367.42767611,4239924.78564583)
        try:
            grid.get_affected_tiles(req_bbox, (256, 256), req_srs=SRS(31467))
        except TransformationError:
            pass
        else:
            assert False, 'Expected TransformationError'

class TestTileGridThreshold(object):
    def test_lower_bound(self):
        # thresholds near the next lower res value
        grid = TileGrid(res=[1000, 500, 250, 100, 50], threshold_res=[300, 110])
        grid.stretch_factor = 1.1
        eq_(grid.closest_level(1100), 0)
        # regular transition (w/stretchfactor)
        eq_(grid.closest_level(950), 0)
        eq_(grid.closest_level(800), 1)
        eq_(grid.closest_level(500), 1)
        # transition at threshold
        eq_(grid.closest_level(301), 1)
        eq_(grid.closest_level(300), 2)
        eq_(grid.closest_level(250), 2)
        # transition at threshold
        eq_(grid.closest_level(111), 2)
        eq_(grid.closest_level(110), 3)
        eq_(grid.closest_level(100), 3)
        # regular transition (w/stretchfactor)
        eq_(grid.closest_level(92), 3)
        eq_(grid.closest_level(90), 4)
    def test_upper_bound(self):
        # thresholds near the next upper res value (within threshold)
        grid = TileGrid(res=[1000, 500, 250, 100, 50], threshold_res=[495, 240])
        grid.stretch_factor = 1.1
        eq_(grid.closest_level(1100), 0)
        # regular transition (w/stretchfactor)
        eq_(grid.closest_level(950), 0)
        eq_(grid.closest_level(800), 1)
        eq_(grid.closest_level(500), 1)
        # transition at threshold
        eq_(grid.closest_level(496), 1)
        eq_(grid.closest_level(495), 2)
        eq_(grid.closest_level(250), 2)
        # transition at threshold (within strechfactor)
        eq_(grid.closest_level(241), 2)
        eq_(grid.closest_level(240), 3)
        eq_(grid.closest_level(100), 3)
        # regular transition (w/stretchfactor)
        eq_(grid.closest_level(92), 3)
        eq_(grid.closest_level(90), 4)
    def test_above_first_res(self):
        grid = TileGrid(res=[1000, 500, 250, 100, 50], threshold_res=[1100, 750])
        grid.stretch_factor = 1.1
        eq_(grid.closest_level(1200), 0)
        eq_(grid.closest_level(1100), 0)
        eq_(grid.closest_level(1000), 0)
        eq_(grid.closest_level(800), 0)
        eq_(grid.closest_level(750.1), 0)
        eq_(grid.closest_level(750), 1)


class TestCreateTileList(object):
    def test(self):
        xs = range(-1, 2)
        ys = range(-2, 3)
        grid_size = (1, 2)
        tiles = list(_create_tile_list(xs, ys, 3, grid_size))

        expected = [None, None, None,
                    None, None, None,
                    None, (0, 0, 3), None,
                    None, (0, 1, 3), None,
                    None, None, None]
        eq_(expected, tiles)

    def _create_tile_list(self, xs, ys, level, grid_size):
        x_limit = grid_size[0]
        y_limit = grid_size[1]
        for y in ys:
            for x in xs:
                if x < 0 or y < 0 or x >= x_limit or y >= y_limit:
                    yield None
                else:
                    yield x, y, level


class TestBBOXIntersects(object):
    def test_no_intersect(self):
        b1 = (0, 0, 10, 10)
        b2 = (20, 20, 30, 30)
        assert not bbox_intersects(b1, b2)
        assert not bbox_intersects(b2, b1)

    def test_no_intersect_only_vertical(self):
        b1 = (0, 0, 10, 10)
        b2 = (20, 0, 30, 10)
        assert not bbox_intersects(b1, b2)
        assert not bbox_intersects(b2, b1)

    def test_no_intersect_touch_point(self):
        b1 = (0, 0, 10, 10)
        b2 = (10, 10, 20, 20)
        assert not bbox_intersects(b1, b2)
        assert not bbox_intersects(b2, b1)

    def test_no_intersect_touch_side(self):
        b1 = (0, 0, 10, 10)
        b2 = (0, 10, 10, 20)
        assert not bbox_intersects(b1, b2)
        assert not bbox_intersects(b2, b1)

    def test_full_contains(self):
        b1 = (0, 0, 10, 10)
        b2 = (2, 2, 8, 8)
        assert bbox_intersects(b1, b2)
        assert bbox_intersects(b2, b1)

    def test_overlap(self):
        b1 = (0, 0, 10, 10)
        b2 = (-5, -5, 5, 5)
        assert bbox_intersects(b1, b2)
        assert bbox_intersects(b2, b1)


class TestBBOXContains(object):
    def test_no_intersect(self):
        b1 = (0, 0, 10, 10)
        b2 = (20, 20, 30, 30)
        assert not bbox_contains(b1, b2)
        assert not bbox_contains(b2, b1)

    def test_no_intersect_only_vertical(self):
        b1 = (0, 0, 10, 10)
        b2 = (20, 0, 30, 10)
        assert not bbox_contains(b1, b2)
        assert not bbox_contains(b2, b1)

    def test_no_intersect_touch_point(self):
        b1 = (0, 0, 10, 10)
        b2 = (10, 10, 20, 20)
        assert not bbox_contains(b1, b2)
        assert not bbox_contains(b2, b1)

    def test_no_intersect_touch_side(self):
        b1 = (0, 0, 10, 10)
        b2 = (0, 10, 10, 20)
        assert not bbox_contains(b1, b2)
        assert not bbox_contains(b2, b1)

    def test_full_contains(self):
        b1 = (0, 0, 10, 10)
        b2 = (2, 2, 8, 8)
        assert bbox_contains(b1, b2)
        assert not bbox_contains(b2, b1)

    def test_contains_touch(self):
        b1 = (0, 0, 10, 10)
        b2 = (0, 0, 8, 8)
        assert bbox_contains(b1, b2)
        assert not bbox_contains(b2, b1)

    def test_overlap(self):
        b1 = (0, 0, 10, 10)
        b2 = (-5, -5, 5, 5)
        assert not bbox_contains(b1, b2)
        assert not bbox_contains(b2, b1)

def assert_almost_equal_bbox(bbox1, bbox2, places=2):
    for coord1, coord2 in zip(bbox1, bbox2):
        assert_almost_equal(coord1, coord2, places)


class TestResolutionRange(object):
    def test_meter(self):
        res_range = ResolutionRange(1000, 10)
        assert not res_range.contains([0, 0, 100000, 100000], (10, 10), SRS(900913))
        assert not res_range.contains([0, 0, 100000, 100000], (99, 99), SRS(900913))
        # min is exclusive but there is a delta
        assert     res_range.contains([0, 0, 100000, 100000], (100, 100), SRS(900913))
        assert     res_range.contains([0, 0, 100000, 100000], (1000, 1000), SRS(900913))
        # max is inclusive
        assert     res_range.contains([0, 0, 100000, 100000], (10000, 10000), SRS(900913))
        assert not res_range.contains([0, 0, 100000, 100000], (10001, 10001), SRS(900913))
    def test_deg(self):
        res_range = ResolutionRange(100000, 1000)
        assert not res_range.contains([0, 0, 10, 10], (10, 10), SRS(4326))
        assert not res_range.contains([0, 0, 10, 10], (11, 11), SRS(4326))
        assert     res_range.contains([0, 0, 10, 10], (12, 12), SRS(4326))
        assert     res_range.contains([0, 0, 10, 10], (100, 100), SRS(4326))
        assert     res_range.contains([0, 0, 10, 10], (1000, 1000), SRS(4326))
        assert     res_range.contains([0, 0, 10, 10], (1100, 1100), SRS(4326))
        assert not res_range.contains([0, 0, 10, 10], (1200, 1200), SRS(4326))

    def test_no_min(self):
        res_range = ResolutionRange(None, 10)
        assert     res_range.contains([0, 0, 100000, 100000], (1, 1), SRS(900913))
        assert     res_range.contains([0, 0, 100000, 100000], (10, 10), SRS(900913))
        assert     res_range.contains([0, 0, 100000, 100000], (99, 99), SRS(900913))
        assert     res_range.contains([0, 0, 100000, 100000], (100, 100), SRS(900913))
        assert     res_range.contains([0, 0, 100000, 100000], (1000, 1000), SRS(900913))
        # max is inclusive
        assert     res_range.contains([0, 0, 100000, 100000], (10000, 10000), SRS(900913))
        assert not res_range.contains([0, 0, 100000, 100000], (10001, 10001), SRS(900913))

    def test_no_max(self):
        res_range = ResolutionRange(1000, None)
        assert not res_range.contains([0, 0, 100000, 100000], (10, 10), SRS(900913))
        assert not res_range.contains([0, 0, 100000, 100000], (99, 99), SRS(900913))
        # min is exclusive but there is a delta
        assert     res_range.contains([0, 0, 100000, 100000], (100, 100), SRS(900913))
        assert     res_range.contains([0, 0, 100000, 100000], (1000, 1000), SRS(900913))
        assert     res_range.contains([0, 0, 100000, 100000], (10000, 10000), SRS(900913))
        assert     res_range.contains([0, 0, 100000, 100000], (10001, 10001), SRS(900913))
        assert     res_range.contains([0, 0, 100000, 100000], (1000000, 100000), SRS(900913))

    def test_none(self):
        res_range = resolution_range(None, None)
        assert res_range == None

    def test_from_scale(self):
        res_range = resolution_range(max_scale=1e6, min_scale=1e3)
        assert_almost_equal(res_range.min_res, 280)
        assert_almost_equal(res_range.max_res, 0.28)

    @raises(ValueError)
    def check_invalid_combination(self, min_res, max_res, max_scale, min_scale):
        resolution_range(min_res, max_res, max_scale, min_scale)

    def test_invalid_combinations(self):
        yield self.check_invalid_combination, 10, None, 10, None
        yield self.check_invalid_combination, 10, 20, 10, None
        yield self.check_invalid_combination, 10, None, 10, 20
        yield self.check_invalid_combination, 10, 20, 10, 20

    @raises(AssertionError)
    def test_wrong_order_res(self):
         resolution_range(min_res=10, max_res=100)

    @raises(AssertionError)
    def test_wrong_order_scale(self):
         resolution_range(min_scale=100, max_scale=10)


    def test_merge_resolutions(self):
        res_range = merge_resolution_range(
            ResolutionRange(None, 10), ResolutionRange(1000, None))
        eq_(res_range, None)

        res_range = merge_resolution_range(
            ResolutionRange(10000, 10), ResolutionRange(1000, None))
        eq_(res_range.min_res, 10000)
        eq_(res_range.max_res, None)

        res_range = merge_resolution_range(
            ResolutionRange(10000, 10), ResolutionRange(1000, 1))
        eq_(res_range.min_res, 10000)
        eq_(res_range.max_res, 1)

        res_range = merge_resolution_range(
            ResolutionRange(10000, 10), ResolutionRange(None, None))
        eq_(res_range, None)

        res_range = merge_resolution_range(
            None, ResolutionRange(None, None))
        eq_(res_range, None)

        res_range = merge_resolution_range(
            ResolutionRange(10000, 10), None)
        eq_(res_range, None)

    def test_eq(self):
        assert resolution_range(None, None) == resolution_range(None, None)
        assert resolution_range(None, 100) == resolution_range(None, 100.0)
        assert resolution_range(None, 100) != resolution_range(None, 100.1)
        assert resolution_range(1000, 100) == resolution_range(1000, 100)
        assert resolution_range(1000, 100) == resolution_range(1000.0, 100)
        assert resolution_range(1000, 100) != resolution_range(1000.1, 100)


class TestGridSubset(object):
    def test_different_srs(self):
        g1 = tile_grid(SRS(4326))
        g2 = tile_grid(SRS(3857))

        assert not g1.is_subset_of(g2)

    def test_same_grid(self):
        g1 = tile_grid(SRS(900913))

        assert g1.is_subset_of(g1)

    def test_similar_srs(self):
        g1 = tile_grid(SRS(900913))
        g2 = tile_grid(SRS(3857))

        assert g1.is_subset_of(g2)

    def test_less_levels(self):
        g1 = tile_grid(SRS(3857), num_levels=10)
        g2 = tile_grid(SRS(3857))

        assert g1.is_subset_of(g2)

    def test_more_levels(self):
        g1 = tile_grid(SRS(3857))
        g2 = tile_grid(SRS(3857), num_levels=10)

        assert not g1.is_subset_of(g2)

    def test_res_subset(self):
        g1 = tile_grid(SRS(3857), res=[50000, 10000, 100, 1])
        g2 = tile_grid(SRS(3857), res=[100000, 50000, 10000, 1000, 100, 10, 1, 0.5])

        assert g1.tile_bbox((0, 0, 0)) != g2.tile_bbox((0, 0, 0))
        assert g1.is_subset_of(g2)

        g1 = tile_grid(SRS(3857), bbox=[0, 0, 20037508.342789244, 20037508.342789244],
            min_res=78271.51696402048, num_levels=18)
        g2 = tile_grid(SRS(3857), origin='nw')
        assert g1.is_subset_of(g2)

    def test_subbbox(self):
        g2 = tile_grid(SRS(4326))
        g1 = tile_grid(SRS(4326), num_levels=10, min_res=g2.resolutions[3], bbox=(0, 0, 180, 90))

        assert g1.is_subset_of(g2)

    def test_incompatible_subbbox(self):
        g2 = tile_grid(SRS(4326))
        g1 = tile_grid(SRS(4326), min_res=g2.resolutions[3], num_levels=10, bbox=(-10, 0, 180, 90))

        assert not g1.is_subset_of(g2)

    def test_tile_size(self):
        g1 = tile_grid(SRS(4326), tile_size=(128, 128))
        g2 = tile_grid(SRS(4326))

        assert not g1.is_subset_of(g2)

    def test_non_matching_bboxfor_origins(self):
        g1 = tile_grid(SRS(21781), bbox=[420000, 30000, 900000, 360000],
            res=[250], origin='nw')
        g2 = tile_grid(SRS(21781), bbox=[420000, 30000, 900000, 360000],
            res=[250], origin='sw')

        assert not g1.is_subset_of(g2)

    def test_no_tile_errors(self):
        # g1 is not a subset, check that we don't get any NoTile errors
        g1 = tile_grid(SRS(3857), res=[100000, 50000, 10000, 1000, 100, 10, 1, 0.5])
        g2 = tile_grid(SRS(3857), res=[100, 1])

        assert not g1.is_subset_of(g2)

########NEW FILE########
__FILENAME__ = test_image
# -:- encoding: utf8 -:-
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

import os
from StringIO import StringIO
from mapproxy.platform.image import Image, ImageDraw
from mapproxy.image import ImageSource, ReadBufWrapper, is_single_color_image
from mapproxy.image import peek_image_format
from mapproxy.image.merge import merge_images
from mapproxy.image import _make_transparent as make_transparent, SubImageSource, img_has_transparency, quantize
from mapproxy.image.opts import ImageOptions
from mapproxy.image.tile import TileMerger, TileSplitter
from mapproxy.image.transform import ImageTransformer
from mapproxy.test.image import is_png, is_jpeg, is_tiff, create_tmp_image_file, check_format, create_debug_img, create_image
from mapproxy.srs import SRS
from nose.tools import eq_
from mapproxy.test.image import assert_colors_equal
from nose.plugins.skip import SkipTest


PNG_FORMAT = ImageOptions(format='image/png')
JPEG_FORMAT = ImageOptions(format='image/jpeg')
TIFF_FORMAT = ImageOptions(format='image/tiff')

class TestImageSource(object):
    def setup(self):
        self.tmp_filename = create_tmp_image_file((100, 100))

    def teardown(self):
        os.remove(self.tmp_filename)

    def test_from_filename(self):
        ir = ImageSource(self.tmp_filename, PNG_FORMAT)
        assert is_png(ir.as_buffer())
        assert ir.as_image().size == (100, 100)

    def test_from_file(self):
        with open(self.tmp_filename, 'rb') as tmp_file:
            ir = ImageSource(tmp_file, 'png')
            assert ir.as_buffer() == tmp_file
            assert ir.as_image().size == (100, 100)

    def test_from_image(self):
        img = Image.new('RGBA', (100, 100))
        ir = ImageSource(img, (100, 100), PNG_FORMAT)
        assert ir.as_image() == img
        assert is_png(ir.as_buffer())

    def test_from_non_seekable_file(self):
        with open(self.tmp_filename, 'rb') as tmp_file:
            data = tmp_file.read()

        class FileLikeDummy(object):
            # "file" without seek, like urlopen response
            def read(self):
                return data

        ir = ImageSource(FileLikeDummy(), 'png')
        assert ir.as_buffer(seekable=True).read() == data
        assert ir.as_image().size == (100, 100)
        assert ir.as_buffer().read() == data


    def test_output_formats(self):
        img = Image.new('RGB', (100, 100))
        for format in ['png', 'gif', 'tiff', 'jpeg', 'GeoTIFF', 'bmp']:
            ir = ImageSource(img, (100, 100), image_opts=ImageOptions(format=format))
            yield check_format, ir.as_buffer(), format

    def test_converted_output(self):
        ir = ImageSource(self.tmp_filename, (100, 100), PNG_FORMAT)
        assert is_png(ir.as_buffer())
        assert is_jpeg(ir.as_buffer(JPEG_FORMAT))
        assert is_jpeg(ir.as_buffer())
        assert is_tiff(ir.as_buffer(TIFF_FORMAT))
        assert is_tiff(ir.as_buffer())

    def test_output_formats_png8(self):
        img = Image.new('RGBA', (100, 100))
        ir = ImageSource(img, image_opts=PNG_FORMAT)
        img = Image.open(ir.as_buffer(ImageOptions(colors=256, transparent=True, format='image/png')))
        assert img.mode == 'P'
        assert img.getpixel((0, 0)) == 255

    def test_output_formats_png24(self):
        img = Image.new('RGBA', (100, 100))
        image_opts = PNG_FORMAT.copy()
        image_opts.colors = 0 # TODO image_opts
        ir = ImageSource(img, image_opts=image_opts)
        img = Image.open(ir.as_buffer())
        eq_(img.mode, 'RGBA')
        assert img.getpixel((0, 0)) == (0, 0, 0, 0)

class TestSubImageSource(object):
    def test_full(self):
        sub_img = create_image((100, 100), color=[100, 120, 130, 140])
        img = SubImageSource(sub_img, size=(100, 100), offset=(0, 0), image_opts=ImageOptions()).as_image()
        eq_(img.getcolors(), [(100*100, (100, 120, 130, 140))])

    def test_larger(self):
        sub_img = create_image((150, 150), color=[100, 120, 130, 140])
        img = SubImageSource(sub_img, size=(100, 100), offset=(0, 0), image_opts=ImageOptions()).as_image()
        eq_(img.getcolors(), [(100*100, (100, 120, 130, 140))])

    def test_negative_offset(self):
        sub_img = create_image((150, 150), color=[100, 120, 130, 140])
        img = SubImageSource(sub_img, size=(100, 100), offset=(-50, 0), image_opts=ImageOptions()).as_image()
        eq_(img.getcolors(), [(100*100, (100, 120, 130, 140))])

    def test_overlap_right(self):
        sub_img = create_image((50, 50), color=[100, 120, 130, 140])
        img = SubImageSource(sub_img, size=(100, 100), offset=(75, 25), image_opts=ImageOptions(transparent=True)).as_image()
        eq_(sorted(img.getcolors()), [(25*50, (100, 120, 130, 140)), (100*100-25*50, (255, 255, 255, 0))])

    def test_outside(self):
        sub_img = create_image((50, 50), color=[100, 120, 130, 140])
        img = SubImageSource(sub_img, size=(100, 100), offset=(200, 0), image_opts=ImageOptions(transparent=True)).as_image()
        eq_(img.getcolors(), [(100*100, (255, 255, 255, 0))])

class ROnly(object):
    def __init__(self):
        self.data = ['Hello World!']
    def read(self):
        if self.data:
            return self.data.pop()
        return ''
    def __iter__(self):
        it = iter(self.data)
        self.data = []
        return it

class TestReadBufWrapper(object):
    def setup(self):
        rbuf = ROnly()
        self.rbuf_wrapper = ReadBufWrapper(rbuf)
    def test_read(self):
        assert self.rbuf_wrapper.read() == 'Hello World!'
        self.rbuf_wrapper.seek(0)
        eq_(self.rbuf_wrapper.read(), '')
    def test_seek_read(self):
        self.rbuf_wrapper.seek(0)
        assert self.rbuf_wrapper.read() == 'Hello World!'
        self.rbuf_wrapper.seek(0)
        assert self.rbuf_wrapper.read() == 'Hello World!'
    def test_iter(self):
        data = list(self.rbuf_wrapper)
        eq_(data, ['Hello World!'])
        self.rbuf_wrapper.seek(0)
        data = list(self.rbuf_wrapper)
        eq_(data, [])
    def test_seek_iter(self):
        self.rbuf_wrapper.seek(0)
        data = list(self.rbuf_wrapper)
        eq_(data, ['Hello World!'])
        self.rbuf_wrapper.seek(0)
        data = list(self.rbuf_wrapper)
        eq_(data, ['Hello World!'])
    def test_hasattr(self):
        assert hasattr(self.rbuf_wrapper, 'seek')
        assert hasattr(self.rbuf_wrapper, 'readline')


class TestMergeAll(object):
    def setup(self):
        self.cleanup_tiles = []

    def test_full_merge(self):
        self.cleanup_tiles = [create_tmp_image_file((100, 100)) for _ in range(9)]
        self.tiles = [ImageSource(tile) for tile in self.cleanup_tiles]
        m = TileMerger(tile_grid=(3, 3), tile_size=(100, 100))
        img_opts = ImageOptions()
        result = m.merge(self.tiles, img_opts)
        img = result.as_image()
        eq_(img.size, (300, 300))

    def test_one(self):
        self.cleanup_tiles = [create_tmp_image_file((100, 100))]
        self.tiles = [ImageSource(self.cleanup_tiles[0])]
        m = TileMerger(tile_grid=(1, 1), tile_size=(100, 100))
        img_opts = ImageOptions(transparent=True)
        result = m.merge(self.tiles, img_opts)
        img = result.as_image()
        eq_(img.size, (100, 100))
        eq_(img.mode, 'RGBA')

    def test_missing_tiles(self):
        self.cleanup_tiles = [create_tmp_image_file((100, 100))]
        self.tiles = [ImageSource(self.cleanup_tiles[0])]
        self.tiles.extend([None]*8)
        m = TileMerger(tile_grid=(3, 3), tile_size=(100, 100))
        img_opts = ImageOptions()
        result = m.merge(self.tiles, img_opts)
        img = result.as_image()
        eq_(img.size, (300, 300))
        eq_(img.getcolors(), [(80000, (255, 255, 255)), (10000, (0, 0, 0)), ])

    def test_invalid_tile(self):
        self.cleanup_tiles = [create_tmp_image_file((100, 100)) for _ in range(9)]
        self.tiles = [ImageSource(tile) for tile in self.cleanup_tiles]
        invalid_tile = self.tiles[0].source
        with open(invalid_tile, 'w') as tmp:
            tmp.write('invalid')
        m = TileMerger(tile_grid=(3, 3), tile_size=(100, 100))
        img_opts = ImageOptions(bgcolor=(200, 0, 50))
        result = m.merge(self.tiles, img_opts)
        img = result.as_image()
        eq_(img.size, (300, 300))
        eq_(img.getcolors(), [(10000, (200, 0, 50)), (80000, (0, 0, 0))])
        assert not os.path.isfile(invalid_tile)

    def test_none_merge(self):
        tiles = [None]
        m = TileMerger(tile_grid=(1, 1), tile_size=(100, 100))
        img_opts = ImageOptions(mode='RGBA', bgcolor=(200, 100, 30, 40))
        result = m.merge(tiles, img_opts)
        img = result.as_image()
        eq_(img.size, (100, 100))
        eq_(img.getcolors(), [(100*100, (200, 100, 30, 40))])

    def teardown(self):
        for tile_fname in self.cleanup_tiles:
            if tile_fname and os.path.isfile(tile_fname):
                os.remove(tile_fname)

class TestGetCrop(object):
    def setup(self):
        self.tmp_file = create_tmp_image_file((100, 100), two_colored=True)
        self.img = ImageSource(self.tmp_file,
                               image_opts=ImageOptions(format='image/png'), size=(100, 100))

    def teardown(self):
        if os.path.exists(self.tmp_file):
            os.remove(self.tmp_file)

    def test_perfect_match(self):
        bbox = (-10, -5, 30, 35)
        transformer = ImageTransformer(SRS(4326), SRS(4326))
        result = transformer.transform(self.img, bbox, (100, 100), bbox, image_opts=None)
        assert self.img == result

    def test_simple_resize_nearest(self):
        bbox = (-10, -5, 30, 35)
        transformer = ImageTransformer(SRS(4326), SRS(4326))
        result = transformer.transform(self.img, bbox, (200, 200), bbox,
            image_opts=ImageOptions(resampling='nearest'))
        img = result.as_image()

        eq_(img.size, (200, 200))
        eq_(len(img.getcolors()), 2)

    def test_simple_resize_bilinear(self):
        bbox = (-10, -5, 30, 35)
        transformer = ImageTransformer(SRS(4326), SRS(4326))
        result = transformer.transform(self.img, bbox, (200, 200), bbox,
            image_opts=ImageOptions(resampling='bilinear'))
        img = result.as_image()

        eq_(img.size, (200, 200))
        # some shades of grey with bilinear
        assert len(img.getcolors()) >= 4


class TestLayerMerge(object):
    def test_opacity_merge(self):
        img1 = ImageSource(Image.new('RGB', (10, 10), (255, 0, 255)))
        img2 = ImageSource(Image.new('RGB', (10, 10), (0, 255, 255)),
            image_opts=ImageOptions(opacity=0.5))

        result = merge_images([img1, img2], ImageOptions(transparent=False))
        img = result.as_image()
        eq_(img.getpixel((0, 0)), (127, 127, 255))

    def test_opacity_merge_mixed_modes(self):
        img1 = ImageSource(Image.new('RGBA', (10, 10), (255, 0, 255, 255)))
        img2 = ImageSource(Image.new('RGB', (10, 10), (0, 255, 255)).convert('P'),
            image_opts=ImageOptions(opacity=0.5))

        result = merge_images([img1, img2], ImageOptions(transparent=True))
        img = result.as_image()
        assert_colors_equal(img, [
            (10*10, (127, 127, 255, 255)),
        ])

    def test_paletted_merge(self):
        if not hasattr(Image, 'FASTOCTREE'):
            raise SkipTest()

        # generate RGBA images with a transparent rectangle in the lower right
        img1 = ImageSource(Image.new('RGBA', (50, 50), (0, 255, 0, 255))).as_image()
        draw = ImageDraw.Draw(img1)
        draw.rectangle((25, 25, 49, 49), fill=(0, 0, 0, 0))
        paletted_img = quantize(img1, alpha=True)
        assert img_has_transparency(paletted_img)
        assert paletted_img.mode == 'P'

        rgba_img = Image.new('RGBA', (50, 50), (255, 0, 0, 255))
        draw = ImageDraw.Draw(rgba_img)
        draw.rectangle((25, 25, 49, 49), fill=(0, 0, 0, 0))

        img1 = ImageSource(paletted_img)
        img2 = ImageSource(rgba_img)

        # generate base image and merge the others above
        img3 = ImageSource(Image.new('RGBA', (50, 50), (0, 0, 255, 255)))
        result = merge_images([img3, img1, img2], ImageOptions(transparent=True))
        img = result.as_image()

        assert img.mode == 'RGBA'
        eq_(img.getpixel((49, 49)), (0, 0, 255, 255))
        eq_(img.getpixel((0, 0)), (255, 0, 0, 255))

    def test_solid_merge(self):
        img1 = ImageSource(Image.new('RGB', (10, 10), (255, 0, 255)))
        img2 = ImageSource(Image.new('RGB', (10, 10), (0, 255, 255)))

        result = merge_images([img1, img2], ImageOptions(transparent=False))
        img = result.as_image()
        eq_(img.getpixel((0, 0)), (0, 255, 255))


class TestLayerCompositeMerge(object):
    def test_composite_merge(self):
        # http://stackoverflow.com/questions/3374878

        if not hasattr(Image, 'alpha_composite'):
            raise SkipTest()

        img1 = Image.new('RGBA', size=(100, 100), color=(255, 0, 0, 255))
        draw = ImageDraw.Draw(img1)
        draw.rectangle((33, 0, 66, 100), fill=(255, 0, 0, 128))
        draw.rectangle((67, 0, 100, 100), fill=(255, 0, 0, 0))
        img1 = ImageSource(img1)
        img2 = Image.new('RGBA', size =(100, 100), color=(0, 255, 0, 255))
        draw = ImageDraw.Draw(img2)
        draw.rectangle((0, 33, 100, 66), fill=(0, 255, 0, 128))
        draw.rectangle((0, 67, 100, 100), fill=(0, 255, 0, 0))
        img2 = ImageSource(img2)

        result = merge_images([img2, img1], ImageOptions(transparent=True))
        img = result.as_image()
        eq_(img.mode, 'RGBA')
        assert_colors_equal(img, [
            (1089, (0, 255, 0, 255)),
            (1089, (255, 255, 255, 0)),
            (1122, (0, 255, 0, 128)),
            (1122, (128, 126, 0, 255)),
            (1122, (255, 0, 0, 128)),
            (1156, (170, 84, 0, 191)),
            (3300, (255, 0, 0, 255))])

    def test_composite_merge_opacity(self):
        if not hasattr(Image, 'alpha_composite'):
            raise SkipTest()

        bg = Image.new('RGBA', size=(100, 100), color=(255, 0, 255, 255))
        bg = ImageSource(bg)
        fg = Image.new('RGBA', size =(100, 100), color=(0, 0, 0, 0))
        draw = ImageDraw.Draw(fg)
        draw.rectangle((10, 10, 89, 89), fill=(0, 255, 255, 255))
        fg = ImageSource(fg, image_opts=ImageOptions(opacity=0.5))

        result = merge_images([bg, fg], ImageOptions(transparent=True))
        img = result.as_image()
        eq_(img.mode, 'RGBA')
        assert_colors_equal(img, [
            (3600, (255, 0, 255, 255)),
            (6400, (128, 127, 255, 255))])

class TestTransform(object):
    def setup(self):
        self.src_img = ImageSource(create_debug_img((200, 200), transparent=False))
        self.src_srs = SRS(31467)
        self.dst_size = (100, 150)
        self.dst_srs = SRS(4326)
        self.dst_bbox = (0.2, 45.1, 8.3, 53.2)
        self.src_bbox = self.dst_srs.transform_bbox_to(self.src_srs, self.dst_bbox)
    def test_transform(self, mesh_div=4):
        transformer = ImageTransformer(self.src_srs, self.dst_srs, mesh_div=mesh_div)
        result = transformer.transform(self.src_img, self.src_bbox, self.dst_size, self.dst_bbox,
            image_opts=ImageOptions(resampling='nearest'))
        assert isinstance(result, ImageSource)
        assert result.as_image() != self.src_img
        assert result.size == (100, 150)

    def _test_compare_mesh_div(self):
        """
        Create transformations with different div values.
        """
        for div in [1, 2, 4, 6, 8, 12, 16]:
            transformer = ImageTransformer(self.src_srs, self.dst_srs, mesh_div=div)
            result = transformer.transform(self.src_img, self.src_bbox,
                                           self.dst_size, self.dst_bbox)
            result.as_image().save('/tmp/transform-%d.png' % (div,))


class TestSingleColorImage(object):
    def test_one_point(self):
        img = Image.new('RGB', (100, 100), color='#ff0000')
        draw = ImageDraw.Draw(img)
        draw.point((99, 99))
        del draw

        assert not is_single_color_image(img)

    def test_solid(self):
        img = Image.new('RGB', (100, 100), color='#ff0102')
        eq_(is_single_color_image(img), (255, 1, 2))

    def test_solid_w_alpha(self):
        img = Image.new('RGBA', (100, 100), color='#ff0102')
        eq_(is_single_color_image(img), (255, 1, 2, 255))

    def test_solid_paletted_image(self):
        img = Image.new('P', (100, 100), color=20)
        palette = []
        for i in range(256):
            palette.extend((i, i//2, i%3))
        img.putpalette(palette)
        eq_(is_single_color_image(img), (20, 10, 2))

class TestMakeTransparent(object):
    def _make_test_image(self):
        img = Image.new('RGB', (50, 50), (130, 140, 120))
        draw = ImageDraw.Draw(img)
        draw.rectangle((10, 10, 39, 39), fill=(130, 150, 120))
        return img

    def _make_transp_test_image(self):
        img = Image.new('RGBA', (50, 50), (130, 140, 120, 100))
        draw = ImageDraw.Draw(img)
        draw.rectangle((10, 10, 39, 39), fill=(130, 150, 120, 120))
        return img

    def test_result(self):
        img = self._make_test_image()
        img = make_transparent(img, (130, 150, 120), tolerance=5)
        assert img.mode == 'RGBA'
        assert img.size == (50, 50)
        colors = img.getcolors()
        assert colors == [(1600, (130, 140, 120, 255)), (900, (130, 150, 120, 0))]

    def test_with_color_fuzz(self):
        img = self._make_test_image()
        img = make_transparent(img, (128, 154, 121), tolerance=5)
        assert img.mode == 'RGBA'
        assert img.size == (50, 50)
        colors = img.getcolors()
        assert colors == [(1600, (130, 140, 120, 255)), (900, (130, 150, 120, 0))]

    def test_no_match(self):
        img = self._make_test_image()
        img = make_transparent(img, (130, 160, 120), tolerance=5)
        assert img.mode == 'RGBA'
        assert img.size == (50, 50)
        colors = img.getcolors()
        assert colors == [(1600, (130, 140, 120, 255)), (900, (130, 150, 120, 255))]

    def test_from_paletted(self):
        img = self._make_test_image().quantize(256)
        img = make_transparent(img, (130, 150, 120), tolerance=5)
        assert img.mode == 'RGBA'
        assert img.size == (50, 50)
        colors = img.getcolors()
        eq_(colors, [(1600, (130, 140, 120, 255)), (900, (130, 150, 120, 0))])

    def test_from_transparent(self):
        img = self._make_transp_test_image()
        draw = ImageDraw.Draw(img)
        draw.rectangle((0, 0, 4, 4), fill=(130, 100, 120, 0))
        draw.rectangle((5, 5, 9, 9), fill=(130, 150, 120, 255))
        img = make_transparent(img, (130, 150, 120, 120), tolerance=5)
        assert img.mode == 'RGBA'
        assert img.size == (50, 50)
        colors = sorted(img.getcolors(), reverse=True)
        eq_(colors, [(1550, (130, 140, 120, 100)), (900, (130, 150, 120, 0)),
            (25, (130, 150, 120, 255)), (25, (130, 100, 120, 0))])


class TestTileSplitter(object):
    def test_background_larger_crop(self):
        img = ImageSource(Image.new('RGB', (356, 266), (130, 140, 120)))
        img_opts = ImageOptions('RGB')
        splitter = TileSplitter(img, img_opts)

        tile = splitter.get_tile((0, 0), (256, 256))

        eq_(tile.size, (256, 256))
        colors = tile.as_image().getcolors()
        eq_(colors, [(256*256, (130, 140, 120))])

        tile = splitter.get_tile((256, 256), (256, 256))

        eq_(tile.size, (256, 256))
        colors = tile.as_image().getcolors()
        eq_(sorted(colors), [(10*100, (130, 140, 120)), (256*256-10*100, (255, 255, 255))])

    def test_background_larger_crop_with_transparent(self):
        img = ImageSource(Image.new('RGBA', (356, 266), (130, 140, 120, 255)))
        img_opts = ImageOptions('RGBA', transparent=True)
        splitter = TileSplitter(img, img_opts)

        tile = splitter.get_tile((0, 0), (256, 256))

        eq_(tile.size, (256, 256))
        colors = tile.as_image().getcolors()
        eq_(colors, [(256*256, (130, 140, 120, 255))])

        tile = splitter.get_tile((256, 256), (256, 256))

        eq_(tile.size, (256, 256))
        colors = tile.as_image().getcolors()
        eq_(sorted(colors), [(10*100, (130, 140, 120, 255)), (256*256-10*100, (255, 255, 255, 0))])

class TestHasTransparency(object):
    def test_rgb(self):
        if not hasattr(Image, 'FASTOCTREE'):
            raise SkipTest()

        img = Image.new('RGB', (10, 10))
        assert not img_has_transparency(img)

        img = quantize(img, alpha=False)
        assert not img_has_transparency(img)

    def test_rbga(self):
        if not hasattr(Image, 'FASTOCTREE'):
            raise SkipTest()

        img = Image.new('RGBA', (10, 10), (100, 200, 50, 255))
        img.paste((255, 50, 50, 0), (3, 3, 7, 7))
        assert img_has_transparency(img)

        img = quantize(img, alpha=True)
        assert img_has_transparency(img)

class TestPeekImageFormat(object):
    def test_peek(self):
        yield self.check, 'png', 'png'
        yield self.check, 'tiff', 'tiff'
        yield self.check, 'gif', 'gif'
        yield self.check, 'jpeg', 'jpeg'
        yield self.check, 'bmp', None

    def check(self, format, expected_format):
        buf = StringIO()
        Image.new('RGB', (100, 100)).save(buf, format)
        eq_(peek_image_format(buf), expected_format)

########NEW FILE########
__FILENAME__ = test_image_mask
# This file is part of the MapProxy project.
# Copyright (C) 2012 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from mapproxy.platform.image import Image
from mapproxy.srs import SRS
from mapproxy.image import ImageSource
from mapproxy.image.opts import ImageOptions
from mapproxy.image.mask import mask_image_source_from_coverage
from mapproxy.util.coverage import load_limited_to

try:
    from shapely.geometry import Polygon
    geom_support = True
except ImportError:
    geom_support = False

if not geom_support:
    from nose.plugins.skip import SkipTest
    raise SkipTest('requires Shapely')

from nose.tools import eq_

def coverage(geom, srs='EPSG:4326'):
    return load_limited_to({'srs': srs, 'geometry': geom})

class TestMaskImage(object):
    def test_mask_outside_of_image_transparent(self):
        img = ImageSource(Image.new('RGB', (100, 100), color=(100, 0, 200)),
            image_opts=ImageOptions(transparent=True))
        result = mask_image_source_from_coverage(img, [0, 0, 10, 10], SRS(4326), coverage([20, 20, 30, 30]))
        eq_(result.as_image().getcolors(), [((100*100), (255, 255, 255, 0))])

    def test_mask_outside_of_image_bgcolor(self):
        img = ImageSource(Image.new('RGB', (100, 100), color=(100, 0, 200)),
            image_opts=ImageOptions(bgcolor=(200, 30, 120)))
            
        result = mask_image_source_from_coverage(img, [0, 0, 10, 10], SRS(4326), coverage([20, 20, 30, 30]))
        eq_(result.as_image().getcolors(), [((100*100), (200, 30, 120))])

    def test_mask_partial_image_bgcolor(self):
        img = ImageSource(Image.new('RGB', (100, 100), color=(100, 0, 200)),
            image_opts=ImageOptions(bgcolor=(200, 30, 120)))
            
        result = mask_image_source_from_coverage(img, [0, 0, 10, 10], SRS(4326), coverage([5, 5, 30, 30]))
        eq_(result.as_image().getcolors(),
            [(7500, (200, 30, 120)), (2500, (100, 0, 200))])

    def test_mask_partial_image_transparent(self):
        img = ImageSource(Image.new('RGB', (100, 100), color=(100, 0, 200)),
            image_opts=ImageOptions(transparent=True))
            
        result = mask_image_source_from_coverage(img, [0, 0, 10, 10], SRS(4326), coverage([5, 5, 30, 30]))
        eq_(result.as_image().getcolors(),
            [(7500, (255, 255, 255, 0)), (2500, (100, 0, 200, 255))])
    
    def test_wkt_mask_partial_image_transparent(self):
        img = ImageSource(Image.new('RGB', (100, 100), color=(100, 0, 200)),
            image_opts=ImageOptions(transparent=True))
        
        # polygon with hole
        geom = 'POLYGON((2 2, 2 8, 8 8, 8 2, 2 2), (4 4, 4 6, 6 6, 6 4, 4 4))'
        
        result = mask_image_source_from_coverage(img, [0, 0, 10, 10], SRS(4326), coverage(geom))
        # 60*61 - 20*21 = 3240
        eq_(result.as_image().getcolors(),
            [(10000-3240, (255, 255, 255, 0)), (3240, (100, 0, 200, 255))])
    
    def test_shapely_mask_with_transform_partial_image_transparent(self):
        img = ImageSource(Image.new('RGB', (100, 100), color=(100, 0, 200)),
            image_opts=ImageOptions(transparent=True))
        
        p = Polygon([(0, 0), (222000, 0), (222000, 222000), (0, 222000)]) # ~ 2x2 degres
        
        result = mask_image_source_from_coverage(img, [0, 0, 10, 10], SRS(4326), coverage(p, 'EPSG:3857'))
        # 20*20 = 400
        eq_(result.as_image().getcolors(),
            [(10000-400, (255, 255, 255, 0)), (400, (100, 0, 200, 255))])
    
########NEW FILE########
__FILENAME__ = test_image_messages
# -:- encoding: utf8 -:-
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

from mapproxy.platform.image import (
    Image,
    ImageDraw,
    ImageColor,
    ImageFont,
)

from mapproxy.cache.tile import Tile
from mapproxy.image import ImageSource
from mapproxy.image.message import TextDraw, message_image
from mapproxy.image.opts import ImageOptions
from mapproxy.tilefilter import watermark_filter

from nose.tools import eq_

PNG_FORMAT = ImageOptions(format='image/png')

class TestTextDraw(object):
    def test_ul(self):
        font = ImageFont.load_default()
        td = TextDraw('Hello', font)
        img = Image.new('RGB', (100, 100))
        draw = ImageDraw.Draw(img)
        total_box, boxes = td.text_boxes(draw, (100, 100))
        eq_(total_box, boxes[0])
        eq_(len(boxes), 1)

    def test_multiline_ul(self):
        font = ImageFont.load_default()
        td = TextDraw('Hello\nWorld', font)
        img = Image.new('RGB', (100, 100))
        draw = ImageDraw.Draw(img)
        total_box, boxes = td.text_boxes(draw, (100, 100))
        eq_(total_box, (5, 5, 35, 30))
        eq_(boxes, [(5, 5, 35, 16), (5, 19, 35, 30)])

    def test_multiline_lr(self):
        font = ImageFont.load_default()
        td = TextDraw('Hello\nWorld', font, placement='lr')
        img = Image.new('RGB', (100, 100))
        draw = ImageDraw.Draw(img)
        total_box, boxes = td.text_boxes(draw, (100, 100))
        eq_(total_box, (65, 70, 95, 95))
        eq_(boxes, [(65, 70, 95, 81), (65, 84, 95, 95)])

    def test_multiline_center(self):
        font = ImageFont.load_default()
        td = TextDraw('Hello\nWorld', font, placement='cc')
        img = Image.new('RGB', (100, 100))
        draw = ImageDraw.Draw(img)
        total_box, boxes = td.text_boxes(draw, (100, 100))
        eq_(total_box, (35, 38, 65, 63))
        eq_(boxes, [(35, 38, 65, 49), (35, 52, 65, 63)])

    def test_unicode(self):
        font = ImageFont.load_default()
        td = TextDraw(u'Hll\nWrld', font, placement='cc')
        img = Image.new('RGB', (100, 100))
        draw = ImageDraw.Draw(img)
        total_box, boxes = td.text_boxes(draw, (100, 100))
        eq_(total_box, (35, 38, 65, 63))
        eq_(boxes, [(35, 38, 65, 49), (35, 52, 65, 63)])

    def _test_all(self):
        for x in 'c':
            for y in 'LR':
                yield self.check_placement, x, y

    def check_placement(self, x, y):
        font = ImageFont.load_default()
        td = TextDraw('Hello\nWorld\n%s %s' % (x, y), font, placement=x+y,
            padding=5, linespacing=2)
        img = Image.new('RGB', (100, 100))
        draw = ImageDraw.Draw(img)
        td.draw(draw, img.size)
        img.show()

    def test_transparent(self):
        font = ImageFont.load_default()
        td = TextDraw('Hello\nWorld', font, placement='cc')
        img = Image.new('RGBA', (100, 100), (0, 0, 0, 0))
        draw = ImageDraw.Draw(img)
        td.draw(draw, img.size)
        eq_(len(img.getcolors()), 2)
        # top color (bg) is transparent
        eq_(sorted(img.getcolors())[1][1], (0, 0, 0, 0))


class TestMessageImage(object):
    def test_blank(self):
        image_opts = PNG_FORMAT.copy()
        image_opts.bgcolor = '#113399'
        img = message_image('', size=(100, 150), image_opts=image_opts)
        assert isinstance(img, ImageSource)
        eq_(img.size, (100, 150))
        pil_img = img.as_image()
        eq_(pil_img.getpixel((0, 0)), ImageColor.getrgb('#113399'))
        # 3 values in histogram (RGB)
        assert [x for x in pil_img.histogram() if x > 0] == [15000, 15000, 15000]
    def test_message(self):
        image_opts = PNG_FORMAT.copy()
        image_opts.bgcolor = '#113399'
        img = message_image('test', size=(100, 150), image_opts=image_opts)
        assert isinstance(img, ImageSource)
        assert img.size == (100, 150)
        # 6 values in histogram (3xRGB for background, 3xRGB for text message)
        eq_([x for x in img.as_image().histogram() if x > 10],
             [14923, 77, 14923, 77, 14923, 77])
    def test_transparent(self):
        image_opts = ImageOptions(transparent=True)
        print image_opts
        img = message_image('', size=(100, 150), image_opts=image_opts)
        assert isinstance(img, ImageSource)
        assert img.size == (100, 150)
        pil_img = img.as_image()
        eq_(pil_img.getpixel((0, 0)), (255, 255, 255, 0))
        # 6 values in histogram (3xRGB for background, 3xRGB for text message)
        assert [x for x in pil_img.histogram() if x > 0] == \
               [15000, 15000, 15000, 15000]


class TestWatermarkTileFilter(object):
    def setup(self):
        self.tile = Tile((0, 0, 0))
        self.filter = watermark_filter('Test')
    def test_filter(self):
        img = Image.new('RGB', (200, 200))
        orig_source = ImageSource(img)
        self.tile.source = orig_source
        filtered_tile = self.filter(self.tile)

        assert self.tile is filtered_tile
        assert orig_source != filtered_tile.source

        pil_img = filtered_tile.source.as_image()
        eq_(pil_img.getpixel((0, 0)), (0, 0, 0))

        colors = pil_img.getcolors()
        colors.sort()
        # most but not all parts are bg color
        assert 39950 > colors[-1][0] > 39000
        assert colors[-1][1] == (0, 0, 0)

    def test_filter_with_alpha(self):
        img = Image.new('RGBA', (200, 200), (10, 15, 20, 0))
        orig_source = ImageSource(img)
        self.tile.source = orig_source
        filtered_tile = self.filter(self.tile)

        assert self.tile is filtered_tile
        assert orig_source != filtered_tile.source

        pil_img = filtered_tile.source.as_image()
        eq_(pil_img.getpixel((0, 0)), (10, 15, 20, 0))

        colors = pil_img.getcolors()
        colors.sort()
        # most but not all parts are bg color
        assert 39950 > colors[-1][0] > 39000
        eq_(colors[-1][1], (10, 15, 20, 0))
########NEW FILE########
__FILENAME__ = test_image_options
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from mapproxy.image.opts import ImageOptions, create_image, compatible_image_options
from nose.tools import eq_

class TestCreateImage(object):
    def test_default(self):
        img = create_image((100, 100))
        eq_(img.size, (100, 100))
        eq_(img.mode, 'RGB')
        eq_(img.getcolors(), [(100*100, (255, 255, 255))])

    def test_transparent(self):
        img = create_image((100, 100), ImageOptions(transparent=True))
        eq_(img.size, (100, 100))
        eq_(img.mode, 'RGBA')
        eq_(img.getcolors(), [(100*100, (255, 255, 255, 0))])

    def test_transparent_rgb(self):
        img = create_image((100, 100), ImageOptions(mode='RGB', transparent=True))
        eq_(img.size, (100, 100))
        eq_(img.mode, 'RGB')
        eq_(img.getcolors(), [(100*100, (255, 255, 255))])

    def test_bgcolor(self):
        img = create_image((100, 100), ImageOptions(bgcolor=(200, 100, 0)))
        eq_(img.size, (100, 100))
        eq_(img.mode, 'RGB')
        eq_(img.getcolors(), [(100*100, (200, 100, 0))])

    def test_rgba_bgcolor(self):
        img = create_image((100, 100), ImageOptions(bgcolor=(200, 100, 0, 30)))
        eq_(img.size, (100, 100))
        eq_(img.mode, 'RGB')
        eq_(img.getcolors(), [(100*100, (200, 100, 0))])

    def test_rgba_bgcolor_transparent(self):
        img = create_image((100, 100), ImageOptions(bgcolor=(200, 100, 0, 30), transparent=True))
        eq_(img.size, (100, 100))
        eq_(img.mode, 'RGBA')
        eq_(img.getcolors(), [(100*100, (200, 100, 0, 30))])

    def test_rgba_bgcolor_rgba_mode(self):
        img = create_image((100, 100), ImageOptions(bgcolor=(200, 100, 0, 30), mode='RGBA'))
        eq_(img.size, (100, 100))
        eq_(img.mode, 'RGBA')
        eq_(img.getcolors(), [(100*100, (200, 100, 0, 30))])


class TestCompatibleImageOptions(object):
    def test_formats(self):
        img_opts = compatible_image_options([
            ImageOptions(format='image/png'),
            ImageOptions(format='image/jpeg'),
        ])
        eq_(img_opts.format, 'image/png')

        img_opts = compatible_image_options([
            ImageOptions(format='image/png'),
            ImageOptions(format='image/jpeg'),
        ],
        ImageOptions(format='image/tiff'),
        )
        eq_(img_opts.format, 'image/tiff')

    def test_colors(self):
        img_opts = compatible_image_options([
            ImageOptions(colors=None),
            ImageOptions(colors=16),
        ])
        eq_(img_opts.colors, 16)

        img_opts = compatible_image_options([
            ImageOptions(colors=256),
            ImageOptions(colors=16),
        ])
        eq_(img_opts.colors, 256)

        img_opts = compatible_image_options([
            ImageOptions(colors=256),
            ImageOptions(colors=16),
        ],
        ImageOptions(colors=4)
        )
        eq_(img_opts.colors, 4)

        img_opts = compatible_image_options([
            ImageOptions(colors=256),
            ImageOptions(colors=0),
        ])
        eq_(img_opts.colors, 0)

    def test_transparent(self):
        img_opts = compatible_image_options([
            ImageOptions(transparent=False),
            ImageOptions(transparent=True),
        ])
        eq_(img_opts.transparent, False)

        img_opts = compatible_image_options([
            ImageOptions(transparent=None),
            ImageOptions(transparent=True),
        ])
        eq_(img_opts.transparent, True)

        img_opts = compatible_image_options([
            ImageOptions(transparent=None),
            ImageOptions(transparent=True),
        ],
        ImageOptions(transparent=None)
        )
        eq_(img_opts.transparent, True)

        img_opts = compatible_image_options([
            ImageOptions(transparent=True),
            ImageOptions(transparent=True),
        ])
        eq_(img_opts.transparent, True)

    def test_mode(self):
        img_opts = compatible_image_options([
            ImageOptions(mode='RGB'),
            ImageOptions(mode='P'),
        ])
        eq_(img_opts.mode, 'RGB')

        img_opts = compatible_image_options([
            ImageOptions(mode='RGBA'),
            ImageOptions(mode='P'),
        ])
        eq_(img_opts.mode, 'RGBA')

        img_opts = compatible_image_options([
            ImageOptions(mode='RGB'),
            ImageOptions(mode='P'),
        ])
        eq_(img_opts.mode, 'RGB')

        img_opts = compatible_image_options([
            ImageOptions(mode='RGB'),
            ImageOptions(mode='P'),
        ],
        ImageOptions(mode='P')
        )
        eq_(img_opts.mode, 'P')


########NEW FILE########
__FILENAME__ = test_multiapp
# -:- encoding: utf-8 -:-
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os
import time
import tempfile
import shutil
from mapproxy.multiapp import DirectoryConfLoader, MultiMapProxy

from nose.tools import eq_

class TestDirectoryConfLoader(object):
    def setup(self):
        self.dir = tempfile.mkdtemp()

    def teardown(self):
        shutil.rmtree(self.dir)

    def make_conf_file(self, name):
        conf_file_name = os.path.join(self.dir, name)
        with open(conf_file_name, 'w'):
            pass
        return conf_file_name

    def test_available_apps_empty(self):
        loader = DirectoryConfLoader(self.dir)
        eq_(loader.available_apps(), [])

    def test_available_apps(self):
        self.make_conf_file('foo.yaml')
        self.make_conf_file('bar.yaml')
        loader = DirectoryConfLoader(self.dir)
        eq_(set(loader.available_apps()), set(['foo', 'bar']))
        self.make_conf_file('bazz.yaml')
        eq_(set(loader.available_apps()), set(['foo', 'bar', 'bazz']))

    def test_app_available(self):
        self.make_conf_file('foo.yaml')
        loader = DirectoryConfLoader(self.dir)
        assert loader.app_available('foo')
        assert not loader.app_available('bar')

    def test_app_conf(self):
        foo_conf_file = self.make_conf_file('foo.yaml')
        loader = DirectoryConfLoader(self.dir)
        app_conf = loader.app_conf('foo')
        eq_(app_conf['mapproxy_conf'], foo_conf_file)

    def test_app_conf_unknown_app(self):
        loader = DirectoryConfLoader(self.dir)
        app_conf = loader.app_conf('foo')
        assert app_conf is None

    def test_needs_reload(self):
        foo_conf_file = self.make_conf_file('foo.yaml')
        mtime = os.path.getmtime(foo_conf_file)
        timestamps = {foo_conf_file: mtime}
        loader = DirectoryConfLoader(self.dir)
        assert loader.needs_reload('foo', timestamps) == False

        timestamps[foo_conf_file] -= 10
        assert loader.needs_reload('foo', timestamps) == True

    def test_custom_suffix(self):
        self.make_conf_file('foo.conf')
        loader = DirectoryConfLoader(self.dir, suffix='.conf')
        assert loader.app_available('foo')


minimal_mapproxy_conf = """
services:
  wms:

layers:
  mylayer:
    title: My Layer
    sources: [mysource]

sources:
  mysource:
    type: wms
    req:
      url: http://example.org/service?
      layers: foo,bar
"""

class DummyReq(object):
    script_url = ''

class TestMultiMapProxy(object):
    def setup(self):
        self.dir = tempfile.mkdtemp()
        self.loader = DirectoryConfLoader(self.dir)

    def teardown(self):
        shutil.rmtree(self.dir)

    def make_conf_file(self, name):
        app_conf_file_name = os.path.join(self.dir, name)
        with open(app_conf_file_name, 'w') as f:
            f.write(minimal_mapproxy_conf)
        return app_conf_file_name

    def test_listing_with_apps(self):
        self.make_conf_file('foo.yaml')
        mmp = MultiMapProxy(self.loader, list_apps=True)
        resp = mmp.index_list(DummyReq())
        assert 'foo' in resp.response

    def test_listing_without_apps(self):
        self.make_conf_file('foo.yaml')
        mmp = MultiMapProxy(self.loader)
        resp = mmp.index_list(DummyReq())
        assert 'foo' not in resp.response
        assert mmp.proj_app('foo') is not None

    def test_cached_app_loading(self):
        self.make_conf_file('foo.yaml')
        mmp = MultiMapProxy(self.loader)
        app1 = mmp.proj_app('foo')
        app2 = mmp.proj_app('foo')

        # app is cached
        assert app1 is app2

    def test_app_reloading(self):
        app_conf_file_name = self.make_conf_file('foo.yaml')
        mmp = MultiMapProxy(self.loader)
        app = mmp.proj_app('foo')

        # touch configuration file
        os.utime(app_conf_file_name, (time.time()+10, time.time()+10))
        # app was reloaded
        assert app is not mmp.proj_app('foo')

    def test_app_unloading(self):
        self.make_conf_file('app1.yaml')
        self.make_conf_file('app2.yaml')
        self.make_conf_file('app3.yaml')
        mmp = MultiMapProxy(self.loader, app_cache_size=2)

        app1 = mmp.proj_app('app1')
        app2 = mmp.proj_app('app2')

        # lru cache [app1, app2]
        assert app1 is mmp.proj_app('app1')
        assert app2 is mmp.proj_app('app2')

        # lru cache [app1, app2]
        app3 = mmp.proj_app('app3')
        # lru cache [app2, app3]
        assert app3 is mmp.proj_app('app3')
        assert app2 is mmp.proj_app('app2')
        assert app1 is not mmp.proj_app('app1')

        # lru cache [app2, app1]
        assert app3 is not mmp.proj_app('app3')


########NEW FILE########
__FILENAME__ = test_ogr_reader
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
from mapproxy.util.ogr import OGRShapeReader, libgdal
from nose.tools import eq_
from nose.plugins.skip import SkipTest

if not libgdal:
    raise SkipTest('libgdal not found')
    
polygon_file = os.path.join(os.path.dirname(__file__), 'polygons', 'polygons.shp')

class TestOGRShapeReader(object):
    def setup(self):
        self.reader = OGRShapeReader(polygon_file)
    def test_read_all(self):
        wkts = list(self.reader.wkts())
        eq_(len(wkts), 3)
        for wkt in wkts:
            assert wkt.startswith('POLYGON ('), 'unexpected WKT: %s' % wkt
    def test_read_filter(self):
        wkts = list(self.reader.wkts(where='name = "germany"'))
        eq_(len(wkts), 2)
        for wkt in wkts:
            assert wkt.startswith('POLYGON ('), 'unexpected WKT: %s' % wkt
    def test_read_filter_no_match(self):
        wkts = list(self.reader.wkts(where='name = "foo"'))
        eq_(len(wkts), 0)
        
########NEW FILE########
__FILENAME__ = test_referrer
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from webtest import TestApp

from mapproxy.response import Response
from mapproxy.security.referrer import ReferrerFilter, NONE, SELF, REGEX


DENIED=404

class CheckApp(object):
    def __init__(self):
        self._called = False
    
    def __call__(self, environ, start_response):
        self._called = True
        return Response('')(environ, start_response)
    
    @property
    def called(self):
        result = self._called
        self._called = False
        return result

class TestReferrerFilter(object):
    def setup(self):
        self.check_app = CheckApp()

    def test_no_referrer(self):
        app = TestApp(ReferrerFilter(self.check_app))
        app.get('/')
        assert self.check_app.called
    
    def test_none(self):
        app = TestApp(ReferrerFilter(self.check_app, [NONE]))
        app.get('/')
        assert self.check_app.called

        app.get('/', headers={'Referer': 'http://localhost/'}, status=DENIED)
        assert not self.check_app.called
    
    def test_string(self):
        referrer_filter = ['http://omniscale.de/', 'http://localhost/']
        
        for referrer, allowed in (('http://localhost/bar', True),
                                  ('http://localhost:5050/bar', False),
                                  ('http://omniscale.net', False)):
            yield self.check_referrer, referrer_filter, referrer, allowed
        

    def test_self(self):
        referrer_filter = [SELF]
        
        for referrer, allowed in ((None, False),
                                  ('http://localhost:80/', True),
                                  ('http://localhost/bar', True),
                                  ('http:/localhost:5050/', False)):
            yield self.check_referrer, referrer_filter, referrer, allowed
    
    def test_regex(self):
        referrer_filter = [REGEX('http://([ab]\.)?osm/')]
        
        for referrer, allowed in (
            (None, False),
            ('http://osm/', True),
            ('http://a.osm/', True),
            ('http://b.osm/', True),
            ('http://c.osm/', False),
            ):
            yield self.check_referrer, referrer_filter, referrer, allowed
    
    def check_referrer(self, filter, referrer_header, allowed):
        app = TestApp(ReferrerFilter(self.check_app, filter))
        headers = {}
        if referrer_header:
            headers['Referer'] = referrer_header
        status = None
        if not allowed:
            status = DENIED
    
        app.get('/', headers=headers, status=status)
    
        if allowed:
            assert self.check_app.called 
        else:
            assert not self.check_app.called
    
########NEW FILE########
__FILENAME__ = test_request
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from mapproxy.srs import SRS
from mapproxy.request.base import url_decode, Request, NoCaseMultiDict, RequestParams
from mapproxy.request.tile import TMSRequest, tile_request, TileRequest
from mapproxy.request.wms import (wms_request, WMSMapRequest, WMSMapRequestParams,
                              WMS111MapRequest, WMS100MapRequest, WMS130MapRequest,
                              WMS111FeatureInfoRequest)
from mapproxy.exception import RequestError
from mapproxy.request.wms.exception import (WMS111ExceptionHandler, WMSImageExceptionHandler,
                                     WMSBlankExceptionHandler)
from mapproxy.test.http import make_wsgi_env, assert_url_eq, assert_query_eq

import pickle
from nose.tools import eq_

class TestNoCaseMultiDict(object):
    def test_from_iterable(self):
        data = (('layers', 'foo,bar'), ('laYERs', 'baz'), ('crs', 'EPSG:4326'))
        nc_dict = NoCaseMultiDict(data)
        print nc_dict

        for name in ('layers', 'LAYERS', 'lAYeRS'):
            assert name in nc_dict, name + ' not found'
        assert nc_dict.get_all('layers') == ['foo,bar', 'baz']
        assert nc_dict.get_all('crs') == ['EPSG:4326']

    def test_from_dict(self):
        data = [('layers', 'foo,bar'), ('laYERs', 'baz'), ('crs', 'EPSG:4326')]
        nc_dict = NoCaseMultiDict(data)
        print nc_dict

        for name in ('layers', 'LAYERS', 'lAYeRS'):
            assert name in nc_dict, name + ' not found'
        assert nc_dict.get_all('layers') == ['foo,bar', 'baz']
        assert nc_dict.get_all('crs') == ['EPSG:4326']

    def test_iteritems(self):
        data = dict([('LAYERS', 'foo,bar'), ('laYERs', 'baz'), ('crs', 'EPSG:4326')])
        nc_dict = NoCaseMultiDict(data)
        print nc_dict

        itr = nc_dict.iteritems()
        key, values = itr.next()
        assert key == 'LAYERS' and values == ['foo,bar', 'baz']
        key, values = itr.next()
        assert key == 'crs' and values == ['EPSG:4326']

    def test_multiple_sets(self):
        nc_dict = NoCaseMultiDict()
        nc_dict['foo'] = 'bar'
        assert nc_dict['FOO'] == 'bar'
        nc_dict['foo'] = 'baz'
        assert nc_dict['FOO'] == 'baz'

    def test_missing_key(self):
        nc_dict = NoCaseMultiDict([('foo', 'bar')])
        try:
            nc_dict['bar']
            assert False, 'Did not throw KeyError exception.'
        except KeyError:
            pass

    def test_get(self):
        nc_dict = NoCaseMultiDict([('foo', 'bar'), ('num', '42')])
        assert nc_dict.get('bar') == None
        assert nc_dict.get('bar', 'default_bar') == 'default_bar'
        assert nc_dict.get('num') == '42'
        assert nc_dict.get('num', type_func=int) == 42
        assert nc_dict.get('foo') == 'bar'

    def test_get_all(self):
        nc_dict = NoCaseMultiDict([('foo', 'bar'), ('num', '42'), ('foo', 'biz')])
        assert nc_dict.get_all('bar') == []
        assert nc_dict.get_all('foo') == ['bar', 'biz']
        assert nc_dict.get_all('num') == ['42']

    def test_set(self):
        nc_dict = NoCaseMultiDict()
        nc_dict.set('foo', 'bar')
        assert nc_dict.get_all('fOO') == ['bar']
        nc_dict.set('fOo', 'buzz', append=True)
        assert nc_dict.get_all('FOO') == ['bar', 'buzz']
        nc_dict.set('foO', 'bizz')
        assert nc_dict.get_all('FOO') == ['bizz']
        nc_dict.set('foO', ['ham', 'spam'], unpack=True)
        assert nc_dict.get_all('FOO') == ['ham', 'spam']
        nc_dict.set('FoO', ['egg', 'bacon'], append=True, unpack=True)
        assert nc_dict.get_all('FOo') == ['ham', 'spam', 'egg', 'bacon']

    def test_setitem(self):
        nc_dict = NoCaseMultiDict()
        nc_dict['foo'] = 'bar'
        assert nc_dict['foo'] == 'bar'
        nc_dict['foo'] = 'buz'
        assert nc_dict['foo'] == 'buz'
        nc_dict['bar'] = nc_dict['foo']
        assert nc_dict['bar'] == 'buz'

        nc_dict['bing'] = '1'
        nc_dict['bong'] = '2'
        nc_dict['bing'] = nc_dict['bong']
        assert nc_dict['bing'] == '2'
        assert nc_dict['bong'] == '2'

    def test_del(self):
        nc_dict = NoCaseMultiDict([('foo', 'bar'), ('num', '42')])
        assert nc_dict['fOO'] == 'bar'
        del nc_dict['FOO']
        assert nc_dict.get('foo') == None


class DummyRequest(object):
    def __init__(self, args, url=''):
        self.args = args
        self.base_url = url

class TestWMSMapRequest(object):
    def setup(self):
        self.base_req = url_decode('''SERVICE=WMS&format=image%2Fpng&layers=foo&styles=&
REQUEST=GetMap&height=300&srs=EPSG%3A4326&VERSION=1.1.1&
bbox=7,50,8,51&width=400'''.replace('\n',''))

class TestWMS100MapRequest(TestWMSMapRequest):
    def setup(self):
        TestWMSMapRequest.setup(self)
        del self.base_req['service']
        del self.base_req['version']
        self.base_req['wmtver'] = '1.0.0'
        self.base_req['request'] = 'Map'

    def test_basic_request(self):
        req = wms_request(DummyRequest(self.base_req), validate=False)
        assert isinstance(req, WMS100MapRequest)
        eq_(req.params.request, 'GetMap')

class TestWMS111MapRequest(TestWMSMapRequest):
    def test_basic_request(self):
        req = wms_request(DummyRequest(self.base_req), validate=False)
        assert isinstance(req, WMS111MapRequest)
        eq_(req.params.request, 'GetMap')

class TestWMS130MapRequest(TestWMSMapRequest):
    def setup(self):
        TestWMSMapRequest.setup(self)
        self.base_req['version'] = '1.3.0'
        self.base_req['crs'] = self.base_req['srs']
        del self.base_req['srs']

    def test_basic_request(self):
        req = wms_request(DummyRequest(self.base_req), validate=False)
        assert isinstance(req, WMS130MapRequest)
        eq_(req.params.request, 'GetMap')
        eq_(req.params.bbox, (50.0, 7.0, 51.0, 8.0))

    def test_copy_with_request_params(self):
        # check that we allways have our internal axis order
        req1 = WMS130MapRequest(param=dict(bbox="10,0,20,40", crs='EPSG:4326'))
        eq_(req1.params.bbox, (0.0, 10.0, 40.0, 20.0))
        req2 = WMS111MapRequest(param=dict(bbox="0,10,40,20", srs='EPSG:4326'))
        eq_(req2.params.bbox, (0.0, 10.0, 40.0, 20.0))

        # 130 <- 111
        req3 = req1.copy_with_request_params(req2)
        eq_(req3.params.bbox, (0.0, 10.0, 40.0, 20.0))
        assert isinstance(req3, WMS130MapRequest)

        # 130 <- 130
        req4 = req1.copy_with_request_params(req3)
        eq_(req4.params.bbox, (0.0, 10.0, 40.0, 20.0))
        assert isinstance(req4, WMS130MapRequest)

        # 111 <- 130
        req5 = req2.copy_with_request_params(req3)
        eq_(req5.params.bbox, (0.0, 10.0, 40.0, 20.0))
        assert isinstance(req5, WMS111MapRequest)


class TestWMS111FeatureInfoRequest(TestWMSMapRequest):
    def setup(self):
        TestWMSMapRequest.setup(self)
        self.base_req['request'] = 'GetFeatureInfo'
        self.base_req['x'] = '100'
        self.base_req['y'] = '150'
        self.base_req['query_layers'] = 'foo'

    def test_basic_request(self):
        req = wms_request(DummyRequest(self.base_req))#, validate=False)
        assert isinstance(req, WMS111FeatureInfoRequest)

    def test_pos(self):
        req = wms_request(DummyRequest(self.base_req))
        eq_(req.params.pos, (100, 150))

    def test_pos_coords(self):
        req = wms_request(DummyRequest(self.base_req))
        eq_(req.params.pos_coords, (7.25, 50.5))


class TestRequest(object):
    def setup(self):
        self.env = {
         'HTTP_HOST': 'localhost:5050',
         'PATH_INFO': '/service',
         'QUERY_STRING': 'LAYERS=osm_mapnik&FORMAT=image%2Fpng&SPHERICALMERCATOR=true&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&STYLES=&EXCEPTIONS=application%2Fvnd.ogc.se_inimage&SRS=EPSG%3A900913&bbox=1013566.9382067363,7051939.297837454,1030918.1436243634,7069577.142111099&WIDTH=908&HEIGHT=923',
         'REMOTE_ADDR': '127.0.0.1',
         'REQUEST_METHOD': 'GET',
         'SCRIPT_NAME': '',
         'SERVER_NAME': '127.0.0.1',
         'SERVER_PORT': '5050',
         'SERVER_PROTOCOL': 'HTTP/1.1',
         'wsgi.url_scheme': 'http',
         }
    def test_path(self):
        req = Request(self.env)
        assert req.path == '/service'

    def test_host_url(self):
        req = Request(self.env)
        assert req.host_url == 'http://localhost:5050/'

    def test_base_url(self):
        req = Request(self.env)
        assert req.base_url == 'http://localhost:5050/service'

        del self.env['HTTP_HOST']
        req = Request(self.env)
        assert req.base_url == 'http://127.0.0.1:5050/service'

        self.env['SERVER_PORT'] = '80'
        req = Request(self.env)
        assert req.base_url == 'http://127.0.0.1/service'

    def test_query_string(self):
        self.env['QUERY_STRING'] = 'Foo=boo&baz=baa&fOO=bizz'
        req = Request(self.env)
        print req.args['foo']
        assert req.args.get_all('foo') == ['boo', 'bizz']
    def test_query_string_encoding(self):
        env = {
            'QUERY_STRING': 'foo=some%20special%20chars%20%26%20%3D'
        }
        req = Request(env)
        print req.args['foo']
        assert req.args['foo'] == u'some special chars & ='

    def test_script_url(self):
        req = Request(self.env)
        eq_(req.script_url, 'http://localhost:5050')
        self.env['SCRIPT_NAME'] = '/'
        req = Request(self.env)
        eq_(req.script_url, 'http://localhost:5050')

        self.env['SCRIPT_NAME'] = '/proxy'
        req = Request(self.env)
        eq_(req.script_url, 'http://localhost:5050/proxy')

        self.env['SCRIPT_NAME'] = '/proxy/'
        req = Request(self.env)
        eq_(req.script_url, 'http://localhost:5050/proxy')

    def test_pop_path(self):
        self.env['PATH_INFO'] = '/foo/service'
        req = Request(self.env)
        part = req.pop_path()
        eq_(part, 'foo')
        eq_(self.env['PATH_INFO'], '/service')
        eq_(self.env['SCRIPT_NAME'], '/foo')

        part = req.pop_path()
        eq_(part, 'service')
        eq_(self.env['PATH_INFO'], '')
        eq_(self.env['SCRIPT_NAME'], '/foo/service')

        part = req.pop_path()
        eq_(part, '')
        eq_(self.env['PATH_INFO'], '')
        eq_(self.env['SCRIPT_NAME'], '/foo/service')


def test_maprequest_from_request():
    env = {
        'QUERY_STRING': 'layers=bar&bBOx=-90,-80,70.0,+80&format=image/png&'\
                        'WIdth=100&heIGHT=200&LAyerS=foo'
    }
    req = WMSMapRequest(param=Request(env).args)
    assert req.params.bbox == (-90.0, -80.0, 70.0, 80.0)
    assert req.params.layers == ['bar', 'foo']
    assert req.params.size == (100, 200)

class TestWMSMapRequestParams(object):
    def setup(self):
        self.m = WMSMapRequestParams(url_decode('layers=bar&bBOx=-90,-80,70.0, 80&format=image/png'
                                    '&WIdth=100&heIGHT=200&LAyerS=foo&srs=EPSG%3A0815'))
    def test_empty(self):
        m = WMSMapRequestParams()
        assert m.query_string == ''
    def test_size(self):
        assert self.m.size == (100, 200)
        self.m.size = (250, 350)
        assert self.m.size == (250, 350)
        assert self.m['width'] == '250'
        assert self.m['height'] == '350'
        del self.m['width']
        assert self.m.size == None
    def test_format(self):
        assert self.m.format == 'png'
        assert self.m.format_mime_type == 'image/png'
        self.m['transparent'] = 'True'
        assert self.m.format == 'png'
    def test_bbox(self):
        assert self.m.bbox == (-90.0, -80.0, 70.0, 80.0)
        del self.m['bbox']
        assert self.m.bbox is None
        self.m.bbox = (-90.0, -80.0, 70.0, 80.0)
        assert self.m.bbox == (-90.0, -80.0, 70.0, 80.0)
        self.m.bbox = '0.0, -40.0, 70.0, 80.0'
        assert self.m.bbox == (0.0, -40.0, 70.0, 80.0)
        self.m.bbox = None
        assert self.m.bbox is None
    def test_transparent(self):
        assert self.m.transparent == False
        self.m['transparent'] = 'trUe'
        assert self.m.transparent == True
    def test_transparent_bool(self):
        self.m['transparent'] = True
        assert self.m['transparent'] == 'True'
    def test_bgcolor(self):
        assert self.m.bgcolor == '#ffffff'
        self.m['bgcolor'] = '0x42cafe'
        assert self.m.bgcolor == '#42cafe'
    def test_srs(self):
        print self.m.srs
        assert self.m.srs == 'EPSG:0815'
        del self.m['srs']
        assert self.m.srs is None
        self.m.srs = SRS('EPSG:4326')
        assert self.m.srs == 'EPSG:4326'
    def test_layers(self):
        assert list(self.m.layers) == ['bar', 'foo']
    def test_query_string(self):
        print self.m.query_string
        assert_query_eq(self.m.query_string,
            'layers=bar,foo&WIdth=100&bBOx=-90,-80,70.0,+80'
            '&format=image%2Fpng&srs=EPSG%3A0815&heIGHT=200')
    def test_get(self):
        assert self.m.get('LAYERS') == 'bar'
        assert self.m.get('width', type_func=int) == 100
    def test_set(self):
        self.m.set('Layers', 'baz', append=True)
        assert self.m.get('LAYERS') == 'bar'
        self.m.set('Layers', 'baz')
        assert self.m.get('LAYERS') == 'baz'
    def test_attr_access(self):
        assert self.m['width'] == '100'
        assert self.m['height'] == '200'
        try:
            self.m.invalid
        except AttributeError:
            pass
        else:
            assert False
    def test_with_defaults(self):
        orig_req = WMSMapRequestParams(param=dict(layers='baz'))
        new_req = self.m.with_defaults(orig_req)
        assert new_req is not self.m
        assert self.m.get('LayErs') == 'bar'
        assert new_req.get('LAyers') == 'baz'
        assert new_req.size == (100, 200)

class TestURLDecode(object):
    def test_key_decode(self):
        d = url_decode('white+space=in+key&foo=bar', decode_keys=True)
        assert d['white space'] == 'in key'
        assert d['foo'] == 'bar'
    def test_include_empty(self):
        d = url_decode('bar&foo=baz&bing', include_empty=True)
        assert d['bar'] == ''
        assert d['foo'] == 'baz'
        assert d['bing'] == ''


def test_non_mime_format():
    m = WMSMapRequest(param={'format': 'jpeg'})
    assert m.params.format == 'jpeg'

def test_request_w_url():
    url = WMSMapRequest(url='http://localhost:8000/service?', param={'layers': 'foo,bar'}).complete_url
    assert_url_eq(url, 'http://localhost:8000/service?layers=foo,bar&styles=&request=GetMap&service=WMS')
    url = WMSMapRequest(url='http://localhost:8000/service',  param={'layers': 'foo,bar'}).complete_url
    assert_url_eq(url, 'http://localhost:8000/service?layers=foo,bar&styles=&request=GetMap&service=WMS')
    url = WMSMapRequest(url='http://localhost:8000/service?map=foo',  param={'layers': 'foo,bar'}).complete_url
    assert_url_eq(url, 'http://localhost:8000/service?map=foo&layers=foo,bar&styles=&request=GetMap&service=WMS')

class TestWMSRequest(object):
    env = make_wsgi_env("""LAYERS=foo&FORMAT=image%2Fjpeg&SERVICE=WMS&VERSION=1.1.1&
REQUEST=GetMap&STYLES=&EXCEPTIONS=application%2Fvnd.ogc.se_xml&SRS=EPSG%3A900913&
BBOX=8,4,9,5&WIDTH=984&HEIGHT=708""".replace('\n', ''))
    def setup(self):
        self.req = Request(self.env)
    def test_valid_request(self):
        map_req = wms_request(self.req)
        # constructor validates
        assert map_req.params.size == (984, 708)
    def test_invalid_request(self):
        del self.req.args['request']
        try:
            wms_request(self.req)
        except RequestError, e:
            assert 'request' in e.msg
        else:
            assert False, 'RequestError expected'
    def test_exception_handler(self):
        map_req = wms_request(self.req)
        assert isinstance(map_req.exception_handler, WMS111ExceptionHandler)
    def test_image_exception_handler(self):
        self.req.args['exceptions'] = 'application/vnd.ogc.se_inimage'
        map_req = wms_request(self.req)
        assert isinstance(map_req.exception_handler, WMSImageExceptionHandler)
    def test_blank_exception_handler(self):
        self.req.args['exceptions'] = 'blank'
        map_req = wms_request(self.req)
        assert isinstance(map_req.exception_handler, WMSBlankExceptionHandler)

class TestSRSAxisOrder(object):
    def setup(self):
        params111 =  url_decode("""LAYERS=foo&FORMAT=image%2Fjpeg&SERVICE=WMS&
VERSION=1.1.1&REQUEST=GetMap&STYLES=&EXCEPTIONS=application%2Fvnd.ogc.se_xml&
SRS=EPSG%3A4326&BBOX=8,4,9,5&WIDTH=984&HEIGHT=708""".replace('\n', ''))
        self.req111 = WMS111MapRequest(params111)
        self.params130 = params111.copy()
        self.params130['version'] = '1.3.0'
        self.params130['crs'] = self.params130['srs']
        del self.params130['srs']
    def test_111_order(self):
        eq_(self.req111.params.bbox, (8, 4, 9, 5))
    def test_130_order_geog(self):
        req130 = WMS130MapRequest(self.params130)
        eq_(req130.params.bbox, (4, 8, 5, 9))
        self.params130['crs'] = 'EPSG:4258'
        req130 = WMS130MapRequest(self.params130)
        eq_(req130.params.bbox, (4, 8, 5, 9))
    def test_130_order_geog_old(self):
        self.params130['crs'] = 'CRS:84'
        req130 = WMS130MapRequest(self.params130)
        eq_(req130.params.bbox, (8, 4, 9, 5))
    def test_130_order_proj_north_east(self):
        self.params130['crs'] = 'EPSG:31466'
        req130 = WMS130MapRequest(self.params130)
        eq_(req130.params.bbox, (4, 8, 5, 9))
    def test_130_order_proj(self):
        self.params130['crs'] = 'EPSG:31463'
        req130 = WMS130MapRequest(self.params130)
        eq_(req130.params.bbox, (8, 4, 9, 5))

class TestTileRequest(object):
    def test_tms_request(self):
        env = {
            'PATH_INFO': '/tms/1.0.0/osm/5/2/3.png',
            'QUERY_STRING': '',
        }
        req = Request(env)
        tms = tile_request(req)
        assert isinstance(tms, TMSRequest)
        eq_(tms.tile, (2, 3, 5))
        eq_(tms.format, 'png')
        eq_(tms.layer, 'osm')
        eq_(tms.dimensions, {})

    def test_tile_request(self):
        env = {
            'PATH_INFO': '/tiles/1.0.0/osm/5/2/3.png',
            'QUERY_STRING': '',
        }
        req = Request(env)
        tile_req = tile_request(req)
        assert isinstance(tile_req, TileRequest)
        eq_(tile_req.tile, (2, 3, 5))
        eq_(tile_req.origin, None)
        eq_(tile_req.format, 'png')
        eq_(tile_req.layer, 'osm')
        eq_(tile_req.dimensions, {})

    def test_tile_request_flipped_y(self):
        env = {
            'PATH_INFO': '/tiles/1.0.0/osm/5/2/3.png',
            'QUERY_STRING': 'origin=nw',
        }
        req = Request(env)
        tile_req = tile_request(req)
        assert isinstance(tile_req, TileRequest)
        eq_(tile_req.tile, (2, 3, 5)) # not jet flipped
        eq_(tile_req.origin, 'nw')
        eq_(tile_req.format, 'png')
        eq_(tile_req.layer, 'osm')
        eq_(tile_req.dimensions, {})

    def test_tile_request_w_epsg(self):
        env = {
            'PATH_INFO': '/tiles/1.0.0/osm/EPSG4326/5/2/3.png',
            'QUERY_STRING': '',
        }
        req = Request(env)
        tile_req = tile_request(req)
        assert isinstance(tile_req, TileRequest)
        eq_(tile_req.tile, (2, 3, 5))
        eq_(tile_req.format, 'png')
        eq_(tile_req.layer, 'osm')
        eq_(tile_req.dimensions, {'_layer_spec': 'EPSG4326'})

def test_request_params_pickle():
    params = RequestParams(dict(foo='bar', zing='zong'))
    params2 = pickle.loads(pickle.dumps(params, 2))
    assert params.params == params2.params


########NEW FILE########
__FILENAME__ = test_request_wmts
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from mapproxy.request.wmts import wmts_request, WMTS100CapabilitiesRequest
from mapproxy.request.wmts import URLTemplateConverter, InvalidWMTSTemplate
from mapproxy.request.base import url_decode

from nose.tools import eq_, raises

def dummy_req(url):
    return DummyRequest(url_decode(url.replace('\n', '')))

class DummyRequest(object):
    def __init__(self, args, url=''):
        self.args = args
        self.base_url = url

def test_tile_request():
    url = '''requeST=GetTile&service=wmts&tileMatrixset=EPSG900913&
tilematrix=2&tileROW=4&TILECOL=2&FORMAT=image/png&Style=&layer=Foo&version=1.0.0'''
    req = wmts_request(dummy_req(url))

    eq_(req.params.coord, (2, 4, '2'))
    eq_(req.params.layer, 'Foo')
    eq_(req.params.format, 'png')
    eq_(req.params.tilematrixset, 'EPSG900913')

def test_capabilities_request():
    url = '''requeST=GetCapabilities&service=wmts'''
    req = wmts_request(dummy_req(url))

    assert isinstance(req, WMTS100CapabilitiesRequest)

def test_template_converter():
    regexp = URLTemplateConverter('/{Layer}/{Style}/{TileMatrixSet}-{TileMatrix}-{TileCol}-{TileRow}/tile').regexp()
    match = regexp.match('/test/bar/foo-EPSG4326-4-12-99/tile')
    assert match
    assert match.groupdict()['Layer'] == 'test'
    assert match.groupdict()['TileMatrixSet'] == 'foo-EPSG4326'
    assert match.groupdict()['TileMatrix'] == '4'
    assert match.groupdict()['TileCol'] == '12'
    assert match.groupdict()['TileRow'] == '99'
    assert match.groupdict()['Style'] == 'bar'

def test_template_converter_deprecated_format():
    # old format that doesn't match the WMTS spec, now deprecated
    regexp = URLTemplateConverter('/{{Layer}}/{{Style}}/{{TileMatrixSet}}-{{TileMatrix}}-{{TileCol}}-{{TileRow}}/tile').regexp()
    match = regexp.match('/test/bar/foo-EPSG4326-4-12-99/tile')
    assert match
    assert match.groupdict()['Layer'] == 'test'
    assert match.groupdict()['TileMatrixSet'] == 'foo-EPSG4326'
    assert match.groupdict()['TileMatrix'] == '4'
    assert match.groupdict()['TileCol'] == '12'
    assert match.groupdict()['TileRow'] == '99'
    assert match.groupdict()['Style'] == 'bar'

@raises(InvalidWMTSTemplate)
def test_template_converter_missing_vars():
    URLTemplateConverter('/wmts/{Style}/{TileMatrixSet}/{TileCol}.png').regexp()

def test_template_converter_dimensions():
    converter = URLTemplateConverter('/{Layer}/{Dim1}/{Dim2}/{TileMatrixSet}-{TileMatrix}-{TileCol}-{TileRow}/tile')
    assert converter.dimensions == ['Dim1', 'Dim2']

########NEW FILE########
__FILENAME__ = test_response
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from cStringIO import StringIO

from mapproxy.test.helper import Mocker
from mocker import ANY
from mapproxy.response import Response

class TestResponse(Mocker):
    def test_str_response(self):
        resp = Response('string content')
        assert isinstance(resp.response, basestring)
        start_response = self.mock()
        self.expect(start_response('200 OK', ANY))
        self.replay()
        result = resp({'REQUEST_METHOD': 'GET'}, start_response)
        assert result.next() == 'string content'
    
    def test_itr_response(self):
        resp = Response(iter(['string content', 'as iterable']))
        assert hasattr(resp.response, 'next')
        start_response = self.mock()
        self.expect(start_response('200 OK', ANY))
        self.replay()
        result = resp({'REQUEST_METHOD': 'GET'}, start_response)
        assert result.next() == 'string content'
        assert result.next() == 'as iterable'
    
    def test_file_response(self):
        data = StringIO('foobar')
        resp = Response(data)
        assert resp.response == data
        start_response = self.mock()
        self.expect(start_response('200 OK', ANY))
        self.replay()
        result = resp({'REQUEST_METHOD': 'GET'}, start_response)
        assert result.next() == 'foobar'
    
    def test_file_response_w_file_wrapper(self):
        data = StringIO('foobar')
        resp = Response(data)
        assert resp.response == data
        start_response = self.mock()
        self.expect(start_response('200 OK', ANY))
        
        file_wrapper = self.mock()
        self.expect(file_wrapper(data, resp.block_size)).result('DUMMY')
        self.replay()
        
        result = resp({'REQUEST_METHOD': 'GET',
                       'wsgi.file_wrapper': file_wrapper}, start_response)
        assert result == 'DUMMY'
    def test_file_response_content_length(self):
        data = StringIO('*' * 342)
        resp = Response(data)
        assert resp.response == data
        start_response = self.mock()
        self.expect(start_response('200 OK', ANY))
        self.replay()
        resp({'REQUEST_METHOD': 'GET'}, start_response)
        assert resp.content_length == 342

########NEW FILE########
__FILENAME__ = test_seed
# This file is part of the MapProxy project.
# Copyright (C) 2010-2012 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, division

import os
import time
import cPickle as pickle

from mapproxy.seed.seeder import TileWalker, SeedTask, SeedProgress
from mapproxy.cache.tile import TileManager
from mapproxy.source.tile import TiledSource
from mapproxy.grid import tile_grid_for_epsg
from mapproxy.grid import TileGrid
from mapproxy.srs import SRS
from mapproxy.util.coverage import BBOXCoverage, GeomCoverage
from mapproxy.seed.config import before_timestamp_from_options, SeedConfigurationError
from mapproxy.seed.config import LevelsList, LevelsRange, LevelsResolutionList, LevelsResolutionRange
from mapproxy.seed.util import ProgressStore
from mapproxy.test.helper import TempFile

from collections import defaultdict
from nose.tools import eq_, assert_almost_equal, raises
from nose.plugins.skip import SkipTest

try:
    from shapely.wkt import loads as load_wkt
    load_wkt # prevent lint warning
except ImportError:
    load_wkt = None

class MockSeedPool(object):
    def __init__(self):
        self.seeded_tiles = defaultdict(set)
    def process(self, tiles, progess):
        for x, y, level in tiles:
            self.seeded_tiles[level].add((x, y))

class MockCache(object):
    def is_cached(self, tile):
        return False

class TestSeeder(object):
    def setup(self):
        self.grid = TileGrid(SRS(4326), bbox=[-180, -90, 180, 90])
        self.source = TiledSource(self.grid, None)
        self.tile_mgr = TileManager(self.grid, MockCache(), [self.source], 'png')
        self.seed_pool = MockSeedPool()

    def make_bbox_task(self, bbox, srs, levels):
        md = dict(name='', cache_name='', grid_name='')
        coverage = BBOXCoverage(bbox, srs)
        return SeedTask(md, self.tile_mgr, levels, refresh_timestamp=None, coverage=coverage)

    def make_geom_task(self, geom, srs, levels):
        md = dict(name='', cache_name='', grid_name='')
        coverage = GeomCoverage(geom, srs)
        return SeedTask(md, self.tile_mgr, levels, refresh_timestamp=None, coverage=coverage)

    def test_seed_full_bbox(self):
        task = self.make_bbox_task([-180, -90, 180, 90], SRS(4326), [0, 1, 2])
        seeder = TileWalker(task, self.seed_pool, handle_uncached=True)
        seeder.walk()

        eq_(len(self.seed_pool.seeded_tiles), 3)
        eq_(self.seed_pool.seeded_tiles[0], set([(0, 0)]))
        eq_(self.seed_pool.seeded_tiles[1], set([(0, 0), (1, 0)]))
        eq_(self.seed_pool.seeded_tiles[2], set([(0, 0), (1, 0), (2, 0), (3, 0),
                                                 (0, 1), (1, 1), (2, 1), (3, 1)]))

    def test_seed_small_bbox(self):
        task = self.make_bbox_task([-45, 0, 180, 90], SRS(4326), [0, 1, 2])
        seeder = TileWalker(task, self.seed_pool, handle_uncached=True)
        seeder.walk()

        eq_(len(self.seed_pool.seeded_tiles), 3)
        eq_(self.seed_pool.seeded_tiles[0], set([(0, 0)]))
        eq_(self.seed_pool.seeded_tiles[1], set([(0, 0), (1, 0)]))
        eq_(self.seed_pool.seeded_tiles[2], set([(1, 1), (2, 1), (3, 1)]))

    def test_seed_small_bbox_iregular_levels(self):
        task = self.make_bbox_task([-45, 0, 180, 90], SRS(4326), [0, 2])
        seeder = TileWalker(task, self.seed_pool, handle_uncached=True)
        seeder.walk()

        eq_(len(self.seed_pool.seeded_tiles), 2)
        eq_(self.seed_pool.seeded_tiles[0], set([(0, 0)]))
        eq_(self.seed_pool.seeded_tiles[2], set([(1, 1), (2, 1), (3, 1)]))

    def test_seed_small_bbox_transformed(self):
        bbox = SRS(4326).transform_bbox_to(SRS(900913), [-45, 0, 179, 80])
        task = self.make_bbox_task(bbox, SRS(900913), [0, 1, 2])
        seeder = TileWalker(task, self.seed_pool, handle_uncached=True)
        seeder.walk()

        eq_(len(self.seed_pool.seeded_tiles), 3)
        eq_(self.seed_pool.seeded_tiles[0], set([(0, 0)]))
        eq_(self.seed_pool.seeded_tiles[1], set([(0, 0), (1, 0)]))
        eq_(self.seed_pool.seeded_tiles[2], set([(1, 1), (2, 1), (3, 1)]))

    def test_seed_with_geom(self):
        if not load_wkt: raise SkipTest('no shapely installed')
        # box from 10 10 to 80 80 with small spike/corner to -10 60 (upper left)
        geom = load_wkt("POLYGON((10 10, 10 50, -10 60, 10 80, 80 80, 80 10, 10 10))")
        task = self.make_geom_task(geom, SRS(4326), [0, 1, 2, 3, 4])
        seeder = TileWalker(task, self.seed_pool, handle_uncached=True)
        seeder.walk()

        eq_(len(self.seed_pool.seeded_tiles), 5)
        eq_(self.seed_pool.seeded_tiles[0], set([(0, 0)]))
        eq_(self.seed_pool.seeded_tiles[1], set([(0, 0), (1, 0)]))
        eq_(self.seed_pool.seeded_tiles[2], set([(1, 1), (2, 1)]))
        eq_(self.seed_pool.seeded_tiles[3], set([(4, 2), (5, 2), (4, 3), (5, 3), (3, 3)]))
        eq_(len(self.seed_pool.seeded_tiles[4]), 4*4+2)

    def test_seed_with_res_list(self):
        if not load_wkt: raise SkipTest('no shapely installed')
        # box from 10 10 to 80 80 with small spike/corner to -10 60 (upper left)
        geom = load_wkt("POLYGON((10 10, 10 50, -10 60, 10 80, 80 80, 80 10, 10 10))")

        self.grid = TileGrid(SRS(4326), bbox=[-180, -90, 180, 90],
                             res=[360/256, 360/720, 360/2000, 360/5000, 360/8000])
        self.tile_mgr = TileManager(self.grid, MockCache(), [self.source], 'png')
        task = self.make_geom_task(geom, SRS(4326), [0, 1, 2, 3, 4])
        seeder = TileWalker(task, self.seed_pool, handle_uncached=True)
        seeder.walk()

        eq_(len(self.seed_pool.seeded_tiles), 5)
        eq_(self.seed_pool.seeded_tiles[0], set([(0, 0)]))
        eq_(self.grid.grid_sizes[1], (3, 2))
        eq_(self.seed_pool.seeded_tiles[1], set([(1, 0), (1, 1), (2, 0), (2, 1)]))
        eq_(self.grid.grid_sizes[2], (8, 4))
        eq_(self.seed_pool.seeded_tiles[2], set([(4, 2), (5, 2), (4, 3), (5, 3), (3, 3)]))
        eq_(self.grid.grid_sizes[3], (20, 10))
        eq_(len(self.seed_pool.seeded_tiles[3]), 5*5+2)

    def test_seed_full_bbox_continue(self):
        task = self.make_bbox_task([-180, -90, 180, 90], SRS(4326), [0, 1, 2])
        seed_progress = SeedProgress([(0, 1), (0, 2)])
        seeder = TileWalker(task, self.seed_pool, handle_uncached=True, seed_progress=seed_progress)
        seeder.walk()

        eq_(len(self.seed_pool.seeded_tiles), 3)
        eq_(self.seed_pool.seeded_tiles[0], set([(0, 0)]))
        eq_(self.seed_pool.seeded_tiles[1], set([(0, 0), (1, 0)]))
        eq_(self.seed_pool.seeded_tiles[2], set([(2, 0), (3, 0),
                                                 (2, 1), (3, 1)]))

class TestLevels(object):
    def test_level_list(self):
        levels = LevelsList([-10, 3, 1, 3, 5, 7, 50])
        eq_(levels.for_grid(tile_grid_for_epsg(4326)),
            [1, 3, 5, 7])

    def test_level_range(self):
        levels = LevelsRange([1, 5])
        eq_(levels.for_grid(tile_grid_for_epsg(4326)),
            [1, 2, 3, 4, 5])

    def test_level_range_open_from(self):
        levels = LevelsRange([None, 5])
        eq_(levels.for_grid(tile_grid_for_epsg(4326)),
            [0, 1, 2, 3, 4, 5])

    def test_level_range_open_to(self):
        levels = LevelsRange([13, None])
        eq_(levels.for_grid(tile_grid_for_epsg(4326)),
            [13, 14, 15, 16, 17, 18, 19])

    def test_level_range_open_tos_range(self):
        levels = LevelsResolutionRange([1000, 100])
        eq_(levels.for_grid(tile_grid_for_epsg(900913)),
            [8, 9, 10, 11])

    def test_res_range_open_from(self):
        levels = LevelsResolutionRange([None, 100])
        eq_(levels.for_grid(tile_grid_for_epsg(900913)),
            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])

    def test_res_range_open_to(self):
        levels = LevelsResolutionRange([1000, None])
        eq_(levels.for_grid(tile_grid_for_epsg(900913)),
            [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])

    def test_resolution_list(self):
        levels = LevelsResolutionList([1000, 100, 500])
        eq_(levels.for_grid(tile_grid_for_epsg(900913)),
            [8, 9, 11])


class TestProgressStore(object):
    def test_load_empty(self):
        store = ProgressStore('doesnotexist.no_realy.txt')
        store.load()
        assert store.get(('foo', 'bar', 'baz')) == None

    def test_load_store(self):
        with TempFile(no_create=True) as tmp:
            with open(tmp, 'w') as f:
                f.write(pickle.dumps({("view", "cache", "grid"): [(0, 1), (2, 4)]}))
            store = ProgressStore(tmp)
            assert store.get(('view', 'cache', 'grid')) == [(0, 1), (2, 4)]
            assert store.get(('view', 'cache', 'grid2')) == None
            store.add(('view', 'cache', 'grid'), [])
            store.add(('view', 'cache', 'grid2'), [(0, 1)])
            store.write()

            store = ProgressStore(tmp)
            assert store.get(('view', 'cache', 'grid')) == []
            assert store.get(('view', 'cache', 'grid2')) == [(0, 1)]

    def test_load_broken(self):
        with TempFile(no_create=True) as tmp:
            with open(tmp, 'w') as f:
                f.write('##invaliddata')
                f.write(pickle.dumps({("view", "cache", "grid"): [(0, 1), (2, 4)]}))

            store = ProgressStore(tmp)
            assert store.status == {}


class TestRemovebreforeTimetamp(object):
    def test_from_time(self):
        ts = before_timestamp_from_options({'time': '2010-12-01T20:12:00'})
        # we don't know the timezone this test will run
        assert (1291230720.0 - 14 * 3600) < ts < (1291230720.0 + 14 * 3600)

    def test_from_mtime(self):
        with TempFile() as tmp:
            os.utime(tmp, (12376512, 12376512))
            eq_(before_timestamp_from_options({'mtime': tmp}), 12376512)

    @raises(SeedConfigurationError)
    def test_from_mtime_missing_file(self):
        before_timestamp_from_options({'mtime': '/tmp/does-not-exist-at-all,really'})

    def test_from_empty(self):
        assert_almost_equal(
            before_timestamp_from_options({}),
            time.time(), -1
        )

    def test_from_delta(self):
        assert_almost_equal(
            before_timestamp_from_options({'minutes': 15}) + 60 * 15,
            time.time(), -1
        )

########NEW FILE########
__FILENAME__ = test_seed_cachelock
# This file is part of the MapProxy project.
# Copyright (C) 2012 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from __future__ import with_statement

import multiprocessing
import os
import shutil
import tempfile
import time

from mapproxy.seed.cachelock import CacheLocker, CacheLockedError

class TestCacheLock(object):
    
    def setup(self):
        self.tmp_dir = tempfile.mkdtemp()
        self.lock_file = os.path.join(self.tmp_dir, 'lock')
        
    def teardown(self):
        shutil.rmtree(self.tmp_dir)
    
    def test_free_lock(self):
        locker = CacheLocker(self.lock_file)
        with locker.lock('foo'):
            assert True
    
    def test_locked_by_process_no_block(self):
        proc_is_locked = multiprocessing.Event()
        def lock():
            locker = CacheLocker(self.lock_file)
            with locker.lock('foo'):
                proc_is_locked.set()
                time.sleep(10)
        
        p = multiprocessing.Process(target=lock)
        p.start()
        # wait for process to start
        proc_is_locked.wait()
        
        locker = CacheLocker(self.lock_file)
        
        # test unlocked bar
        with locker.lock('bar', no_block=True):
            assert True
        
        # test locked foo
        try:
            with locker.lock('foo', no_block=True):
                assert False
        except CacheLockedError:
            pass
        finally:
            p.terminate()
            p.join()
    
    def test_locked_by_process_waiting(self):
        proc_is_locked = multiprocessing.Event()
        def lock():
            locker = CacheLocker(self.lock_file)
            with locker.lock('foo'):
                proc_is_locked.set()
                time.sleep(.1)
        
        p = multiprocessing.Process(target=lock)
        start_time = time.time()
        p.start()
        # wait for process to start
        proc_is_locked.wait()
        
        locker = CacheLocker(self.lock_file, polltime=0.02)
        try:
            with locker.lock('foo', no_block=False):
                diff = time.time() - start_time
                assert diff > 0.1
        finally:
            p.terminate()
            p.join()
########NEW FILE########
__FILENAME__ = test_srs
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
from mapproxy.config import base_config
from mapproxy import srs
from mapproxy.srs import SRS

class Test_0_ProjDefaultDataPath(object):
    
    def test_known_srs(self):
        srs.SRS(4326)
    
    def test_unknown_srs(self):
        try:
            srs.SRS(1234)
        except RuntimeError:
            pass
        else:
            assert False, 'RuntimeError expected'
        

class Test_1_ProjDataPath(object):
    
    def setup(self):
        srs._proj_initalized = False
        srs._srs_cache = {}
        base_config().srs.proj_data_dir = os.path.dirname(__file__)
    
    def test_dummy_srs(self):
        srs.SRS(1234)
    
    def test_unknown_srs(self):
        try:
            srs.SRS(2339)
        except RuntimeError:
            pass
        else:
            assert False, 'RuntimeError expected'
    
    def teardown(self):
        srs._proj_initalized = False
        srs._srs_cache = {}
        base_config().srs.proj_data_dir = None


class TestSRS(object):
    def test_epsg4326(self):
        srs = SRS(4326)
        
        assert srs.is_latlong
        assert not srs.is_axis_order_en
        assert srs.is_axis_order_ne
        
    def test_crs84(self):
        srs = SRS('CRS:84')
        
        assert srs.is_latlong
        assert srs.is_axis_order_en
        assert not srs.is_axis_order_ne

        assert srs == SRS('EPSG:4326')

    def test_epsg31467(self):
        srs = SRS('EPSG:31467')
        
        assert not srs.is_latlong
        assert not srs.is_axis_order_en
        assert srs.is_axis_order_ne

    def test_epsg900913(self):
        srs = SRS('epsg:900913')
        
        assert not srs.is_latlong
        assert srs.is_axis_order_en
        assert not srs.is_axis_order_ne

    def test_from_srs(self):
        srs1 = SRS('epgs:4326')
        srs2 = SRS(srs1)
        assert srs1 == srs2
        
########NEW FILE########
__FILENAME__ = test_tiled_source
# This file is part of the MapProxy project.
# Copyright (C) 2012 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

from mapproxy.client.tile import TMSClient
from mapproxy.grid import TileGrid
from mapproxy.srs import SRS
from mapproxy.source.tile import TiledSource
from mapproxy.source.error import HTTPSourceErrorHandler
from mapproxy.layer import MapQuery

from mapproxy.test.http import mock_httpd
from nose.tools import eq_

TEST_SERVER_ADDRESS = ('127.0.0.1', 56413)
TESTSERVER_URL = 'http://%s:%d' % TEST_SERVER_ADDRESS

class TestTileClientOnError(object):
    def setup(self):
        self.grid = TileGrid(SRS(4326), bbox=[-180, -90, 180, 90])
        self.client = TMSClient(TESTSERVER_URL)

    def test_cacheable_response(self):
        error_handler = HTTPSourceErrorHandler()
        error_handler.add_handler(500, (255, 0, 0), cacheable=True)
        self.source = TiledSource(self.grid, self.client, error_handler=error_handler)

        with mock_httpd(TEST_SERVER_ADDRESS, [({'path': '/1/0/0.png'},
                                                {'body': 'error', 'status': 500, 'headers':{'content-type': 'text/plain'}})]):
            resp = self.source.get_map(MapQuery([-180, -90, 0, 90], (256, 256), SRS(4326), format='png'))
            assert resp.cacheable 
            eq_(resp.as_image().getcolors(), [((256*256), (255, 0, 0))])

    def test_image_response(self):
        error_handler = HTTPSourceErrorHandler()
        error_handler.add_handler(500, (255, 0, 0), cacheable=False)
        self.source = TiledSource(self.grid, self.client, error_handler=error_handler)

        with mock_httpd(TEST_SERVER_ADDRESS, [({'path': '/1/0/0.png'},
                                                {'body': 'error', 'status': 500, 'headers':{'content-type': 'text/plain'}})]):
            resp = self.source.get_map(MapQuery([-180, -90, 0, 90], (256, 256), SRS(4326), format='png'))
            assert not resp.cacheable 
            eq_(resp.as_image().getcolors(), [((256*256), (255, 0, 0))])

    def test_multiple_image_responses(self):
        error_handler = HTTPSourceErrorHandler()
        error_handler.add_handler(500, (255, 0, 0), cacheable=False)
        error_handler.add_handler(204, (255, 0, 127, 200), cacheable=True)
        self.source = TiledSource(self.grid, self.client, error_handler=error_handler)

        with mock_httpd(TEST_SERVER_ADDRESS, [
            ({'path': '/1/0/0.png'}, {'body': 'error', 'status': 500, 'headers':{'content-type': 'text/plain'}}),
            ({'path': '/1/0/0.png'}, {'body': 'error', 'status': 204, 'headers':{'content-type': 'text/plain'}})]):

            resp = self.source.get_map(MapQuery([-180, -90, 0, 90], (256, 256), SRS(4326), format='png'))
            assert not resp.cacheable 
            eq_(resp.as_image().getcolors(), [((256*256), (255, 0, 0))])

            resp = self.source.get_map(MapQuery([-180, -90, 0, 90], (256, 256), SRS(4326), format='png'))
            assert resp.cacheable 
            eq_(resp.as_image().getcolors(), [((256*256), (255, 0, 127, 200))])

########NEW FILE########
__FILENAME__ = test_tilefilter
# This file is part of the MapProxy project.
# Copyright (C) 2010, 2011 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from mapproxy.tilefilter import tile_watermark_placement
def test_tile_watermark_placement():
    from nose.tools import eq_
    eq_(tile_watermark_placement((0, 0, 0)), 'c')
    eq_(tile_watermark_placement((1, 0, 0)), 'c')
    eq_(tile_watermark_placement((0, 1, 0)), 'b')
    eq_(tile_watermark_placement((1, 1, 0)), 'b')
    
    eq_(tile_watermark_placement((0, 0, 0), True), None)
    eq_(tile_watermark_placement((1, 0, 0), True), 'c')
    eq_(tile_watermark_placement((2, 0, 0), True), None)

    eq_(tile_watermark_placement((0, 1, 0), True), 'c')
    eq_(tile_watermark_placement((1, 1, 0), True), None)
    eq_(tile_watermark_placement((2, 1, 0), True), 'c')

########NEW FILE########
__FILENAME__ = test_timeutils
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from datetime import datetime
from mapproxy.util.times import parse_httpdate, format_httpdate, timestamp
from nose.tools import eq_, raises

class TestHTTPDate(object):
    def test_parse_httpdate(self):
        for date in (
            'Fri, 13 Feb 2009 23:31:30 GMT',
            'Friday, 13-Feb-09 23:31:30 GMT',
            'Fri Feb 13 23:31:30 2009',
            ):
            eq_(parse_httpdate(date), 1234567890)

    def test_parse_invalid(self):
        for date in (
            None,
            'foobar',
            '4823764923',
            'Fri, 13 Foo 2009 23:31:30 GMT'
            ):
            eq_(parse_httpdate(date), None)

    def test_format_httpdate(self):
        eq_(format_httpdate(datetime.fromtimestamp(1234567890)),
            'Fri, 13 Feb 2009 23:31:30 GMT')
        eq_(format_httpdate(1234567890),
            'Fri, 13 Feb 2009 23:31:30 GMT')

    @raises(AssertionError)
    def test_format_invalid(self):
        format_httpdate('foobar')

def test_timestamp():
    eq_(timestamp(1234567890), 1234567890)
    eq_(timestamp(datetime.fromtimestamp(1234567890)), 1234567890)

########NEW FILE########
__FILENAME__ = test_utils
# This file is part of the MapProxy project.
# Copyright (C) 2010-2013 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import os
import glob
import sys
import shutil
import tempfile
import threading
import multiprocessing
import random
import time
from mapproxy.util.lock import (
    FileLock,
    SemLock,
    cleanup_lockdir,
    LockTimeout,
)
from mapproxy.util.fs import (
    _force_rename_dir,
    swap_dir,
    cleanup_directory,
    write_atomic,
)
from mapproxy.util.times import timestamp_before
from mapproxy.test.helper import Mocker

from nose.tools import eq_

is_win = sys.platform == 'win32'

class TestFileLock(Mocker):
    def setup(self):
        Mocker.setup(self)
        self.lock_dir = tempfile.mkdtemp()
        self.lock_file = os.path.join(self.lock_dir, 'lock.lck')
    def teardown(self):
        shutil.rmtree(self.lock_dir)
        Mocker.teardown(self)
    def test_file_lock_timeout(self):
        lock = self._create_lock()
        assert_locked(self.lock_file)
        lock # prevent lint warnings

    def test_file_lock(self):
        # Test a lock that becomes free during a waiting lock() call.
        class Lock(threading.Thread):
            def __init__(self, lock_file):
                threading.Thread.__init__(self)
                self.lock_file = lock_file
                self.lock = FileLock(self.lock_file)
            def run(self):
                self.lock.lock()
                time.sleep(0.2)
                self.lock.unlock()

        lock_thread = Lock(self.lock_file)
        start_time = time.time()
        lock_thread.start()

        # wait until thread got the locked
        while not lock_thread.lock._locked:
            time.sleep(0.001)

        # one lock that times out
        assert_locked(self.lock_file)

        # one lock that will get it after some time
        l = FileLock(self.lock_file, timeout=0.3, step=0.001)
        l.lock()

        locked_for = time.time() - start_time
        assert locked_for - 0.2 <=0.1, 'locking took to long?! (rerun if not sure)'

        #cleanup
        l.unlock()
        lock_thread.join()

    def test_lock_cleanup(self):
        old_lock_file = os.path.join(self.lock_dir, 'lock_old.lck')
        l = FileLock(old_lock_file)
        l.lock()
        l.unlock()
        mtime = os.stat(old_lock_file).st_mtime
        mtime -= 7*60
        os.utime(old_lock_file, (mtime, mtime))

        l = self._create_lock()
        l.unlock()
        assert os.path.exists(old_lock_file)
        assert os.path.exists(self.lock_file)
        cleanup_lockdir(self.lock_dir)

        assert not os.path.exists(old_lock_file)
        assert os.path.exists(self.lock_file)

    def test_concurrent_access(self):
        count_file = os.path.join(self.lock_dir, 'count.txt')
        with open(count_file, 'wb') as f:
            f.write('0')

        def count_up():
            with FileLock(self.lock_file, timeout=60):
                with open(count_file, 'r+b') as f:
                    counter = int(f.read().strip())
                    f.seek(0)
                    f.write(str(counter+1))

        def do_it():
            for x in range(20):
                time.sleep(0.002)
                count_up()
        threads = [threading.Thread(target=do_it) for _ in range(20)]
        [t.start() for t in threads]
        [t.join() for t in threads]

        with open(count_file, 'r+b') as f:
            counter = int(f.read().strip())

        assert counter == 400, counter

    def test_remove_on_unlock(self):
        l = FileLock(self.lock_file, remove_on_unlock=True)
        l.lock()
        assert os.path.exists(self.lock_file)
        l.unlock()
        assert not os.path.exists(self.lock_file)

        l.lock()
        assert os.path.exists(self.lock_file)
        os.remove(self.lock_file)
        assert not os.path.exists(self.lock_file)
        # ignore removed lock
        l.unlock()
        assert not os.path.exists(self.lock_file)


    def _create_lock(self):
        lock = FileLock(self.lock_file)
        lock.lock()
        return lock

def assert_locked(lock_file, timeout=0.02, step=0.001):
    assert os.path.exists(lock_file)
    l = FileLock(lock_file, timeout=timeout, step=step)
    try:
        l.lock()
        assert False, 'file was not locked'
    except LockTimeout:
        pass


class TestSemLock(object):
    def setup(self):
        self.lock_dir = tempfile.mkdtemp()
        self.lock_file = os.path.join(self.lock_dir, 'lock.lck')
    def teardown(self):
        shutil.rmtree(self.lock_dir)

    def count_lockfiles(self):
        return len(glob.glob(self.lock_file + '*'))

    def test_single(self):
        locks = [SemLock(self.lock_file, 1, timeout=0.01) for _ in range(2)]
        locks[0].lock()
        try:
            locks[1].lock()
        except LockTimeout:
            pass
        else:
            assert False, 'expected LockTimeout'


    def test_creating(self):
        locks = [SemLock(self.lock_file, 2) for _ in range(3)]

        eq_(self.count_lockfiles(), 0)
        locks[0].lock()
        eq_(self.count_lockfiles(), 1)
        locks[1].lock()
        eq_(self.count_lockfiles(), 2)
        assert os.path.exists(locks[0]._lock._path)
        assert os.path.exists(locks[1]._lock._path)
        locks[0].unlock()
        locks[2].lock()
        locks[2].unlock()
        locks[1].unlock()

    def test_timeout(self):
        locks = [SemLock(self.lock_file, 2, timeout=0.1) for _ in range(3)]

        eq_(self.count_lockfiles(), 0)
        locks[0].lock()
        eq_(self.count_lockfiles(), 1)
        locks[1].lock()
        eq_(self.count_lockfiles(), 2)
        try:
            locks[2].lock()
        except LockTimeout:
            pass
        else:
            assert False, 'expected LockTimeout'
        locks[0].unlock()
        locks[2].unlock()

    def test_load(self):
        locks = [SemLock(self.lock_file, 8, timeout=1) for _ in range(20)]

        new_locks = random.sample([l for l in locks if not l._locked], 5)
        for l in new_locks:
            l.lock()

        for _ in range(20):
            old_locks = random.sample([l for l in locks if l._locked], 3)
            for l in old_locks:
                l.unlock()
            eq_(len([l for l in locks if l._locked]), 2)
            eq_(len([l for l in locks if not l._locked]), 18)

            new_locks = random.sample([l for l in locks if not l._locked], 3)
            for l in new_locks:
                l.lock()

            eq_(len([l for l in locks if l._locked]), 5)
            eq_(len([l for l in locks if not l._locked]), 15)

        assert self.count_lockfiles() == 8


class DirTest(object):
    def setup(self):
        self.tmpdir = tempfile.mkdtemp()
    def teardown(self):
        if os.path.exists(self.tmpdir):
            shutil.rmtree(self.tmpdir)
    def mkdir(self, name):
        dirname = os.path.join(self.tmpdir, name)
        os.mkdir(dirname)
        self.mkfile(name, dirname=dirname)
        return dirname
    def mkfile(self, name, dirname=None):
        if dirname is None:
            dirname = self.mkdir(name)
        filename = os.path.join(dirname, name + '.txt')
        open(filename, 'w').close()
        return filename


class TestForceRenameDir(DirTest):
    def test_rename(self):
        src_dir = self.mkdir('bar')
        dst_dir = os.path.join(self.tmpdir, 'baz')
        _force_rename_dir(src_dir, dst_dir)
        assert os.path.exists(dst_dir)
        assert os.path.exists(os.path.join(dst_dir, 'bar.txt'))
        assert not os.path.exists(src_dir)
    def test_rename_overwrite(self):
        src_dir = self.mkdir('bar')
        dst_dir = self.mkdir('baz')
        _force_rename_dir(src_dir, dst_dir)
        assert os.path.exists(dst_dir)
        assert os.path.exists(os.path.join(dst_dir, 'bar.txt'))
        assert not os.path.exists(src_dir)


class TestSwapDir(DirTest):
    def test_swap_dir(self):
        src_dir = self.mkdir('bar')
        dst_dir = os.path.join(self.tmpdir, 'baz')

        swap_dir(src_dir, dst_dir)
        assert os.path.exists(dst_dir)
        assert os.path.exists(os.path.join(dst_dir, 'bar.txt'))
        assert not os.path.exists(src_dir)

    def test_swap_dir_w_old(self):
        src_dir = self.mkdir('bar')
        dst_dir = self.mkdir('baz')

        swap_dir(src_dir, dst_dir)
        assert os.path.exists(dst_dir)
        assert os.path.exists(os.path.join(dst_dir, 'bar.txt'))
        assert not os.path.exists(src_dir)

    def test_swap_dir_keep_old(self):
        src_dir = self.mkdir('bar')
        dst_dir = self.mkdir('baz')

        swap_dir(src_dir, dst_dir, keep_old=True, backup_ext='.bak')
        assert os.path.exists(dst_dir)
        assert os.path.exists(os.path.join(dst_dir, 'bar.txt'))
        assert os.path.exists(dst_dir + '.bak')
        assert os.path.exists(os.path.join(dst_dir + '.bak', 'baz.txt'))


class TestCleanupDirectory(DirTest):
    def test_no_remove(self):
        dirs = [self.mkdir('dir'+str(n)) for n in range(10)]
        for d in dirs:
            assert os.path.exists(d), d
        cleanup_directory(self.tmpdir, timestamp_before(minutes=1))
        for d in dirs:
            assert os.path.exists(d), d

    def test_file_handler(self):
        files = []
        file_handler_calls = []
        def file_handler(filename):
            file_handler_calls.append(filename)
        new_date = timestamp_before(weeks=1)
        for n in range(10):
            fname = 'foo'+str(n)
            filename = self.mkfile(fname)
            os.utime(filename, (new_date, new_date))
            files.append(filename)

        for filename in files:
            assert os.path.exists(filename), filename
        cleanup_directory(self.tmpdir, timestamp_before(), file_handler=file_handler)
        for filename in files:
            assert os.path.exists(filename), filename

        assert set(files) == set(file_handler_calls)

    def test_no_directory(self):
        cleanup_directory(os.path.join(self.tmpdir, 'invalid'), timestamp_before())
        # nothing should happen

    def test_remove_all(self):
        files = []
        new_date = timestamp_before(weeks=1)
        for n in range(10):
            fname = 'foo'+str(n)
            filename = self.mkfile(fname)
            os.utime(filename, (new_date, new_date))
            files.append(filename)

        for filename in files:
            assert os.path.exists(filename), filename
        cleanup_directory(self.tmpdir, timestamp_before())
        for filename in files:
            assert not os.path.exists(filename), filename
            assert not os.path.exists(os.path.dirname(filename)), filename


    def test_remove_empty_dirs(self):
        os.makedirs(os.path.join(self.tmpdir, 'foo', 'bar', 'baz'))
        cleanup_directory(self.tmpdir, timestamp_before(minutes=-1))
        assert not os.path.exists(os.path.join(self.tmpdir, 'foo'))

    def test_remove_some(self):
        files = []
        new_date = timestamp_before(weeks=1)
        for n in range(10):
            fname = 'foo'+str(n)
            filename = self.mkfile(fname)
            if n % 2 == 0:
                os.utime(filename, (new_date, new_date))
            files.append(filename)

        for filename in files:
            assert os.path.exists(filename), filename
        cleanup_directory(self.tmpdir, timestamp_before())
        for filename in files[::2]:
            assert not os.path.exists(filename), filename
            assert not os.path.exists(os.path.dirname(filename)), filename
        for filename in files[1::2]:
            assert os.path.exists(filename), filename

def write_atomic_data((i, filename)):
    data = str(i) + '\n' + 'x' * 10000
    write_atomic(filename, data)
    time.sleep(0.001)

class TestWriteAtomic(object):
    def setup(self):
        self.dirname = tempfile.mkdtemp()

    def teardown(self):
        if self.dirname:
            shutil.rmtree(self.dirname)

    def test_concurrent_write(self):
        filename = os.path.join(self.dirname, 'tmpfile')

        num_writes = 800
        concurrent_writes = 8

        p = multiprocessing.Pool(concurrent_writes)
        p.map(write_atomic_data, ((i, filename) for i in xrange(num_writes)))
        p.close()
        p.join()

        assert os.path.exists(filename)
        last_i =  int(open(filename).readline())
        assert last_i > (num_writes / 2), ("file should contain content from "
            "later writes, got content from write %d" % (last_i + 1)
        )
        os.unlink(filename)
        assert os.listdir(self.dirname) == []

    def test_not_a_file(self):
        # check that expected errors are not hidden
        filename = os.path.join(self.dirname, 'tmpfile')
        os.mkdir(filename)

        try:
            write_atomic(filename, '12345')
        except OSError:
            pass
        else:
            assert False, 'expected exception'

########NEW FILE########
__FILENAME__ = test_util_conf_utils
# -:- encoding: utf-8 -:-
# This file is part of the MapProxy project.
# Copyright (C) 2013 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from mapproxy.script.conf.utils import update_config

from copy import deepcopy
from nose.tools import eq_


class TestUpdateConfig(object):
    def test_empty(self):
        a = {'a': 'foo', 'b': 42}
        b = {}
        eq_(update_config(deepcopy(a), b), a)

    def test_add(self):
        a = {'a': 'foo', 'b': 42}
        b = {'c': [1, 2, 3]}
        eq_(update_config(a, b),
            {'a': 'foo', 'b': 42, 'c': [1, 2, 3]})

    def test_mod(self):
        a = {'a': 'foo', 'b': 42, 'c': {}}
        b = {'a': [1, 2, 3], 'c': 1}
        eq_(update_config(a, b),
            {'b': 42, 'a': [1, 2, 3], 'c': 1})

    def test_nested_add_mod(self):
        a = {'a': 'foo', 'b': {'ba': 42, 'bb': {}}}
        b = {'b': {'bb': {'bba': 1}, 'bc': [1, 2, 3]}}
        eq_(update_config(a, b),
            {'a': 'foo', 'b': {'ba': 42, 'bb': {'bba': 1}, 'bc': [1, 2, 3]}})

    def test_add_all(self):
        a = {'a': 'foo', 'b': {'ba': 42, 'bb': {}}}
        b = {'__all__': {'ba': 1}}
        eq_(update_config(a, b),
            {'a': {'ba': 1}, 'b': {'ba': 1, 'bb': {}}})

    def test_extend(self):
        a = {'a': 'foo', 'b': ['ba']}
        b = {'b__extend__': ['bb', 'bc']}
        eq_(update_config(a, b),
            {'a': 'foo', 'b': ['ba', 'bb', 'bc']})

    def test_prefix_wildcard(self):
        a = {'test_foo': 'foo', 'test_bar': 'ba', 'test2_foo': 'test2', 'nounderfoo': 1}
        b = {'____foo': 42}
        eq_(update_config(a, b),
            {'test_foo': 42, 'test_bar': 'ba', 'test2_foo': 42, 'nounderfoo': 1})

    def test_suffix_wildcard(self):
        a = {'test_foo': 'foo', 'test_bar': 'ba', 'test2_foo': 'test2', 'nounderfoo': 1}
        b = {'test____': 42}
        eq_(update_config(a, b),
            {'test_foo': 42, 'test_bar': 42, 'test2_foo': 'test2', 'nounderfoo': 1})

########NEW FILE########
__FILENAME__ = test_wms_capabilities
# This file is part of the MapProxy project.
# Copyright (C) 2014 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from mapproxy.service.wms import limit_srs_extents
from mapproxy.layer import DefaultMapExtent, MapExtent
from mapproxy.srs import SRS

from nose.tools import eq_

class TestLimitSRSExtents(object):
    def test_defaults(self):
        eq_(
            limit_srs_extents({}, ['EPSG:4326', 'EPSG:3857']),
            {
                'EPSG:4326': DefaultMapExtent(),
                'EPSG:3857': DefaultMapExtent(),
            }
        )
    def test_unsupported(self):
        eq_(
            limit_srs_extents({'EPSG:9999': DefaultMapExtent()},
                ['EPSG:4326', 'EPSG:3857']),
            {}
        )
    def test_limited_unsupported(self):
        eq_(
            limit_srs_extents({'EPSG:9999': DefaultMapExtent(), 'EPSG:4326': MapExtent([0, 0, 10, 10], SRS(4326))},
                ['EPSG:4326', 'EPSG:3857']),
            {'EPSG:4326': MapExtent([0, 0, 10, 10], SRS(4326)),}
        )

########NEW FILE########
__FILENAME__ = test_yaml
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import tempfile

from mapproxy.util.yaml import load_yaml, load_yaml_file, YAMLError
from nose.tools import eq_


class TestLoadYAMLFile(object):
    def setup(self):
        self.tmp_files = []

    def teardown(self):
        for f in self.tmp_files:
            os.unlink(f)

    def yaml_file(self, content):
        fd, fname = tempfile.mkstemp()
        f = os.fdopen(fd, 'w')
        f.write(content)
        self.tmp_files.append(fname)
        return fname

    def test_load_yaml_file(self):
        f = self.yaml_file("hello:\n - 1\n - 2")
        doc = load_yaml_file(open(f))
        eq_(doc, {'hello': [1, 2]})

    def test_load_yaml_file_filename(self):
        f = self.yaml_file("hello:\n - 1\n - 2")
        assert isinstance(f, basestring)
        doc = load_yaml_file(f)
        eq_(doc, {'hello': [1, 2]})

    def test_load_yaml(self):
        doc = load_yaml("hello:\n - 1\n - 2")
        eq_(doc, {'hello': [1, 2]})

    def test_load_yaml_with_tabs(self):
        try:
            f = self.yaml_file("hello:\n\t- world")
            load_yaml_file(f)
        except YAMLError, ex:
            assert 'line 2' in str(ex)
        else:
            assert False, 'expected YAMLError'

########NEW FILE########
__FILENAME__ = tilefilter
# This file is part of the MapProxy project.
# Copyright (C) 2010, 2011 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Filter for tiles (watermark, etc.)
"""

from mapproxy.image.message import WatermarkImage

def create_watermark_filter(conf, context, **kw):
    text = conf['watermark'].get('text', '')
    opacity = conf['watermark'].get('opacity')
    font_size = conf['watermark'].get('font_size')
    spacing = conf['watermark'].get('spacing')
    font_color = conf['watermark'].get('color')
    if spacing not in ('wide', None):
        raise ValueError('unsupported watermark spacing: %r' % spacing)
    if text != '':
        return watermark_filter(text, opacity=opacity, font_size=font_size,
                                spacing=spacing, font_color=font_color)

def watermark_filter(text, opacity=None, spacing=None, font_size=None, font_color=None):
    """
    Returns a tile filter that adds a watermark to the tiles.
    :param text: watermark text
    """
    def _watermark_filter(tile):
        placement = tile_watermark_placement(tile.coord, spacing == 'wide')
        wimg = WatermarkImage(text, image_opts=tile.source.image_opts,
            placement=placement, opacity=opacity, font_size=font_size,
            font_color=font_color)
        tile.source = wimg.draw(img=tile.source, in_place=False)
        return tile
    return _watermark_filter

def tile_watermark_placement(coord, double_spacing=False):
    if not double_spacing:
        if coord[1] % 2 == 0:
            return 'c'
        else:
            return 'b'
    
    if coord[1] % 2 != coord[0] % 2:
        return 'c'

    return None


########NEW FILE########
__FILENAME__ = async
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

MAX_MAP_ASYNC_THREADS = 20

import Queue
import sys
import threading

try:
    import eventlet
    import eventlet.greenpool
    import eventlet.tpool
    import eventlet.patcher
    _has_eventlet = True

    import eventlet.debug
    eventlet.debug.hub_exceptions(False)

except ImportError:
    _has_eventlet = False

from mapproxy.config import base_config
from mapproxy.config import local_base_config

import logging
log_system = logging.getLogger('mapproxy.system')

class AsyncResult(object):
    def __init__(self, result=None, exception=None):
        self.result = result
        self.exception = exception

    def __repr__(self):
        return "<AsyncResult result='%s' exception='%s'>" % (
            self.result, self.exception)


def _result_iter(results, use_result_objects=False):
    for result in results:
        if use_result_objects:
            exception = None
            if (isinstance(result, tuple) and len(result) == 3 and
                isinstance(result[1], Exception)):
                exception = result
                result = None
            yield AsyncResult(result, exception)
        else:
            yield result

class EventletPool(object):
    def __init__(self, size=100):
        self.size = size
        self.base_config = base_config()

    def shutdown(self, force=False):
        # there is not way to stop a GreenPool
        pass

    def map(self, func, *args, **kw):
        return list(self.imap(func, *args, **kw))

    def imap(self, func, *args, **kw):
        use_result_objects = kw.get('use_result_objects', False)
        def call(*args):
            with local_base_config(self.base_config):
                try:
                    return func(*args)
                except Exception:
                    if use_result_objects:
                        return sys.exc_info()
                    else:
                        raise
        if len(args[0]) == 1:
            eventlet.sleep()
            return _result_iter([call(*zip(*args)[0])], use_result_objects)
        pool = eventlet.greenpool.GreenPool(self.size)
        return _result_iter(pool.imap(call, *args), use_result_objects)

    def starmap(self, func, args, **kw):
        use_result_objects = kw.get('use_result_objects', False)
        def call(*args):
            with local_base_config(self.base_config):
                try:
                    return func(*args)
                except Exception:
                    if use_result_objects:
                        return sys.exc_info()
                    else:
                        raise
        if len(args) == 1:
            eventlet.sleep()
            return _result_iter([call(*args[0])], use_result_objects)
        pool = eventlet.greenpool.GreenPool(self.size)
        return _result_iter(pool.starmap(call, args), use_result_objects)

    def starcall(self, args, **kw):
        use_result_objects = kw.get('use_result_objects', False)
        def call(func, *args):
            with local_base_config(self.base_config):
                try:
                    return func(*args)
                except Exception:
                    if use_result_objects:
                        return sys.exc_info()
                    else:
                        raise
        if len(args) == 1:
            eventlet.sleep()
            return _result_iter([call(args[0][0], *args[0][1:])], use_result_objects)
        pool = eventlet.greenpool.GreenPool(self.size)
        return _result_iter(pool.starmap(call, args), use_result_objects)


class ThreadWorker(threading.Thread):
    def __init__(self, task_queue, result_queue):
        threading.Thread.__init__(self)
        self.task_queue = task_queue
        self.result_queue = result_queue
        self.base_config = base_config()
    def run(self):
        with local_base_config(self.base_config):
            while True:
                task = self.task_queue.get()
                if task is None:
                    self.task_queue.task_done()
                    break
                exec_id, func, args = task
                try:
                    result = func(*args)
                except Exception:
                    result = sys.exc_info()
                self.result_queue.put((exec_id, result))
                self.task_queue.task_done()


def _consume_queue(queue):
    """
    Get all items from queue.
    """
    while not queue.empty():
        try:
            queue.get(block=False)
            queue.task_done()
        except Queue.Empty:
            pass


class ThreadPool(object):
    def __init__(self, size=4):
        self.pool_size = size
        self.task_queue = Queue.Queue()
        self.result_queue = Queue.Queue()
        self.pool = None
    def map_each(self, func_args, raise_exceptions):
        """
        args should be a list of function arg tuples.
        map_each calls each function with the given arg.
        """
        if self.pool_size < 2:
            for func, arg in func_args:
                try:
                    yield func(*arg)
                except Exception:
                    yield sys.exc_info()
            raise StopIteration()

        self.pool = self._init_pool()

        i = 0
        for i, (func, arg) in enumerate(func_args):
            self.task_queue.put((i, func, arg))

        results = {}

        next_result = 0
        for value in self._get_results(next_result, results, raise_exceptions):
            yield value
            next_result += 1

        self.task_queue.join()
        for value in self._get_results(next_result, results, raise_exceptions):
            yield value
            next_result += 1

        self.shutdown()

    def _single_call(self, func, args, use_result_objects):
        try:
            result = func(*args)
        except Exception:
            if not use_result_objects:
                raise
            result = sys.exc_info()
        return _result_iter([result], use_result_objects)

    def map(self, func, *args, **kw):
        return list(self.imap(func, *args, **kw))

    def imap(self, func, *args, **kw):
        use_result_objects = kw.get('use_result_objects', False)
        if len(args[0]) == 1:
            return self._single_call(func, zip(*args)[0], use_result_objects)
        return _result_iter(self.map_each([(func, arg) for arg in zip(*args)], raise_exceptions=not use_result_objects),
                            use_result_objects)

    def starmap(self, func, args, **kw):
        use_result_objects = kw.get('use_result_objects', False)
        if len(args[0]) == 1:
            return self._single_call(func, args[0], use_result_objects)

        return _result_iter(self.map_each([(func, arg) for arg in args], raise_exceptions=not use_result_objects),
                            use_result_objects)

    def starcall(self, args, **kw):
        def call(func, *args):
            return func(*args)
        return self.starmap(call, args, **kw)

    def _get_results(self, next_result, results, raise_exceptions):
        for i, value in self._fetch_results(raise_exceptions):
            if i == next_result:
                yield value
                next_result += 1
                while next_result in results:
                    yield results.pop(next_result)
                    next_result += 1
            else:
                results[i] = value

    def _fetch_results(self, raise_exceptions):
        while not self.task_queue.empty() or not self.result_queue.empty():
            task_result = self.result_queue.get()
            if (raise_exceptions and isinstance(task_result[1], tuple) and
                len(task_result[1]) == 3 and
                isinstance(task_result[1][1], Exception)):
                self.shutdown(force=True)
                exc_class, exc, tb = task_result[1]
                raise exc_class, exc, tb
            yield task_result

    def shutdown(self, force=False):
        """
        Send shutdown sentinel to all executor threads. If `force` is True,
        clean task_queue and result_queue.
        """
        if force:
            _consume_queue(self.task_queue)
            _consume_queue(self.result_queue)
        for _ in range(self.pool_size):
            self.task_queue.put(None)

    def _init_pool(self):
        if self.pool_size < 2:
            return []
        pool = []
        for _ in range(self.pool_size):
            t = ThreadWorker(self.task_queue, self.result_queue)
            t.daemon = True
            t.start()
            pool.append(t)
        return pool


def imap_async_eventlet(func, *args):
    pool = EventletPool()
    return pool.imap(func, *args)

def imap_async_threaded(func, *args):
    pool = ThreadPool(min(len(args[0]), MAX_MAP_ASYNC_THREADS))
    return pool.imap(func, *args)

def starmap_async_eventlet(func, args):
    pool = EventletPool()
    return pool.starmap(func, args)

def starmap_async_threaded(func, args):
    pool = ThreadPool(min(len(args[0]), MAX_MAP_ASYNC_THREADS))
    return pool.starmap(func, args)

def starcall_async_eventlet(args):
    pool = EventletPool()
    return pool.starcall(args)

def starcall_async_threaded(args):
    pool = ThreadPool(min(len(args[0]), MAX_MAP_ASYNC_THREADS))
    return pool.starcall(args)


def run_non_blocking_eventlet(func, args, kw={}):
    return eventlet.tpool.execute(func, *args, **kw)

def run_non_blocking_threaded(func, args, kw={}):
    return func(*args, **kw)


def import_module(module):
    """
    Import ``module``. Import patched version if eventlet is used.
    """
    if uses_eventlet:
        return eventlet.import_patched(module)
    else:
        return __import__(module)

uses_eventlet = False

# socket should be monkey patched when MapProxy runs inside eventlet
if _has_eventlet and eventlet.patcher.is_monkey_patched('socket'):
    uses_eventlet = True
    log_system.info('using eventlet for asynchronous operations')
    imap = imap_async_eventlet
    starmap = starmap_async_eventlet
    starcall = starcall_async_eventlet
    Pool = EventletPool
    run_non_blocking = run_non_blocking_eventlet
else:
    imap = imap_async_threaded
    starmap = starmap_async_threaded
    starcall = starcall_async_threaded
    Pool = ThreadPool
    run_non_blocking = run_non_blocking_threaded

########NEW FILE########
__FILENAME__ = collections
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import absolute_import
from collections import deque
from itertools import islice

class LRU(object):
    """
    Least Recently Used dictionary.
    
    Stores `size` key-value pairs. Removes last used key-value
    when dict is full.
    
    
    This LRU was developed for sizes <1000.
    Set new: O(1)
    Get/Set existing: O(1) newest to O(n) for oldest entry
    Contains: O(1)
    """
    def __init__(self, size=100):
        self.size = size
        self.values = {}
        self.last_used = deque()
    
    def get(self, key, default=None):
        if key not in self.values:
            return default
        else:
            return self[key]
    
    def __repr__(self):
        last_values = []
        for k in islice(self.last_used, 10):
            last_values.append((k, self.values[k]))
        
        return '<LRU size=%d values=%s%s>' % (
            self.size, repr(last_values)[:-1],
            ', ...]' if len(self)>10 else ']')
    
    def __getitem__(self, key):
        result = self.values[key]
        try:
            self.last_used.remove(key)
        except ValueError:
            pass
        self.last_used.appendleft(key)
        return result
    
    def __setitem__(self, key, value):
        if key in self.values:
            try:
                self.last_used.remove(key)
            except ValueError:
                pass
        self.last_used.appendleft(key)
        self.values[key] = value
        
        while len(self.values) > self.size:
            del self.values[self.last_used.pop()]
    
    def __len__(self):
        return len(self.values)
    
    def __delitem__(self, key):
        if key in self.values:
            try:
                self.last_used.remove(key)
            except ValueError:
                pass
        del self.values[key]
    
    def __contains__(self, key):
        return key in self.values


class ImmutableDictList(object):
    """
    A dictionary where each item can also be accessed by the
    integer index of the initial position.
    
    >>> d = ImmutableDictList([('foo', 23), ('bar', 24)])
    >>> d['bar']
    24
    >>> d[0], d[1]
    (23, 24)
    """
    def __init__(self, items):
        self._names = []
        self._values = {}
        for name, value in items:
            self._values[name] = value
            self._names.append(name)
    
    def __getitem__(self, name):
        if isinstance(name, basestring):
            return self._values[name]
        else:
            return self._values[self._names[name]]
    
    def __contains__(self, name):
        try:
            self[name]
            return True
        except KeyError:
            return False
    
    def __len__(self):
        return len(self._values)
    
    def __str__(self):
        values = []
        for name in self._names:
            values.append('%s: %s' % (name, self._values[name]))
        return '[%s]' % (', '.join(values),)
    
    def iteritems(self):
        for idx in self._names:
            yield idx, self._values[idx]

########NEW FILE########
__FILENAME__ = coverage
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement

import operator
import threading

from mapproxy.grid import bbox_intersects, bbox_contains
from mapproxy.util.py import cached_property
from mapproxy.util.geom import (
    require_geom_support,
    load_polygon_lines,
    transform_geometry,
    bbox_polygon,
)
from mapproxy.srs import SRS

import logging
log_config = logging.getLogger('mapproxy.config.coverage')

try:
    import shapely.geometry
    import shapely.prepared
except ImportError:
    # missing Shapely is handled by require_geom_support
    pass

def coverage(geom, srs):
    if isinstance(geom, (list, tuple)):
        return BBOXCoverage(geom, srs)
    else:
        return GeomCoverage(geom, srs)

def load_limited_to(limited_to):
    require_geom_support()
    srs = SRS(limited_to['srs'])
    geom = limited_to['geometry']

    if not hasattr(geom, 'type'): # not a Shapely geometry
        if isinstance(geom, (list, tuple)):
            geom = bbox_polygon(geom)
        else:
            polygons = load_polygon_lines(geom.split('\n'))
            if len(polygons) == 1:
                geom = polygons[0]
            else:
                geom = shapely.geometry.MultiPolygon(polygons)

    return GeomCoverage(geom, srs, clip=True)

class MultiCoverage(object):
    clip = False
    """Aggregates multiple coverages"""
    def __init__(self, coverages):
        self.coverages = coverages
        self.bbox = self.extent.bbox

    @cached_property
    def extent(self):
        return reduce(operator.add, [c.extent for c in self.coverages])

    def intersects(self, bbox, srs):
        return any(c.intersects(bbox, srs) for c in self.coverages)

    def contains(self, bbox, srs):
        return any(c.contains(bbox, srs) for c in self.coverages)

    def transform_to(self, srs):
        return MultiCoverage([c.transform_to(srs) for c in self.coverages])

    def __eq__(self, other):
        if not isinstance(other, MultiCoverage):
            return NotImplemented

        if self.bbox != other.bbox:
            return False

        if len(self.coverages) != len(other.coverages):
            return False

        for a, b in zip(self.coverages, other.coverages):
            if a != b:
                return False

        return True

    def __ne__(self, other):
        if not isinstance(other, MultiCoverage):
            return NotImplemented
        return not self.__eq__(other)

    def __repr__(self):
        return '<MultiCoverage %r: %r>' % (self.extent.llbbox, self.coverages)

class BBOXCoverage(object):
    clip = False
    def __init__(self, bbox, srs):
        self.bbox = bbox
        self.srs = srs
        self.geom = None

    @property
    def extent(self):
        from mapproxy.layer import MapExtent

        return MapExtent(self.bbox, self.srs)

    def _bbox_in_coverage_srs(self, bbox, srs):
        if srs != self.srs:
            bbox = srs.transform_bbox_to(self.srs, bbox)
        return bbox

    def intersects(self, bbox, srs):
        bbox = self._bbox_in_coverage_srs(bbox, srs)
        return bbox_intersects(self.bbox, bbox)

    def intersection(self, bbox, srs):
        bbox = self._bbox_in_coverage_srs(bbox, srs)
        intersection = (
            max(self.bbox[0], bbox[0]),
            max(self.bbox[1], bbox[1]),
            min(self.bbox[2], bbox[2]),
            min(self.bbox[3], bbox[3]),
        )

        if intersection[0] >= intersection[2] or intersection[1] >= intersection[3]:
            return None
        return BBOXCoverage(intersection, self.srs)

    def contains(self, bbox, srs):
        bbox = self._bbox_in_coverage_srs(bbox, srs)
        return bbox_contains(self.bbox, bbox)

    def transform_to(self, srs):
        if srs == self.srs:
            return self

        bbox = self.srs.transform_bbox_to(srs, self.bbox)
        return BBOXCoverage(bbox, srs)

    def __eq__(self, other):
        if not isinstance(other, BBOXCoverage):
            return NotImplemented

        if self.srs != other.srs:
            return False

        if self.bbox != other.bbox:
            return False

        return True

    def __ne__(self, other):
        if not isinstance(other, BBOXCoverage):
            return NotImplemented
        return not self.__eq__(other)

    def __repr__(self):
        return '<BBOXCoverage %r/%r>' % (self.extent.llbbox, self.bbox)


class GeomCoverage(object):
    def __init__(self, geom, srs, clip=False):
        self.geom = geom
        self.bbox = geom.bounds
        self.srs = srs
        self.clip = clip
        self._prep_lock = threading.Lock()
        self._prepared_geom = None
        self._prepared_counter = 0
        self._prepared_max = 10000

    @property
    def extent(self):
        from mapproxy.layer import MapExtent
        return MapExtent(self.bbox, self.srs)

    @property
    def prepared_geom(self):
        # GEOS internal data structure for prepared geometries grows over time,
        # recreate to limit memory consumption
        if not self._prepared_geom or self._prepared_counter > self._prepared_max:
            self._prepared_geom = shapely.prepared.prep(self.geom)
            self._prepared_counter = 0
        self._prepared_counter += 1
        return self._prepared_geom

    def _geom_in_coverage_srs(self, geom, srs):
        if isinstance(geom, shapely.geometry.base.BaseGeometry):
            if srs != self.srs:
                geom = transform_geometry(srs, self.srs, geom)
        elif len(geom) == 2:
            if srs != self.srs:
                geom = srs.transform_to(self.srs, geom)
            geom = shapely.geometry.Point(geom)
        else:
            if srs != self.srs:
                geom = srs.transform_bbox_to(self.srs, geom)
            geom = bbox_polygon(geom)
        return geom

    def transform_to(self, srs):
        if srs == self.srs:
            return self

        geom = transform_geometry(self.srs, srs, self.geom)
        return GeomCoverage(geom, srs)

    def intersects(self, bbox, srs):
        bbox = self._geom_in_coverage_srs(bbox, srs)
        with self._prep_lock:
            return self.prepared_geom.intersects(bbox)

    def intersection(self, bbox, srs):
        bbox = self._geom_in_coverage_srs(bbox, srs)
        return GeomCoverage(self.geom.intersection(bbox), self.srs)

    def contains(self, bbox, srs):
        bbox = self._geom_in_coverage_srs(bbox, srs)
        with self._prep_lock:
            return self.prepared_geom.contains(bbox)

    def __eq__(self, other):
        if not isinstance(other, GeomCoverage):
            return NotImplemented

        if self.srs != other.srs:
            return False

        if self.bbox != other.bbox:
            return False

        if not self.geom.equals(other.geom):
            return False

        return True

    def __ne__(self, other):
        if not isinstance(other, GeomCoverage):
            return NotImplemented
        return not self.__eq__(other)

    def __repr__(self):
        return '<GeomCoverage %r: %r>' % (self.extent.llbbox, self.geom)
########NEW FILE########
__FILENAME__ = spec
# Copyright (c) 2011, Oliver Tonnhofer <olt@omniscale.de>
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

class required(str):
    """
    Mark a dictionary key as required.
    """
    pass

class anything(object):
    """
    Wildcard key or value for dictionaries.

    >>> from .validator import validate
    >>> validate({anything(): 1}, {'foo': 2, 'bar': 49})
    """
    def compare_type(self, data):
        return True

class recursive(object):
    """
    Recursive types.
    
    >>> from .validator import validate
    >>> spec = recursive({'foo': recursive()})
    >>> validate(spec, {'foo': {'foo': {'foo':{}}}})
    """
    def __init__(self, spec=None):
        self.spec = spec
    def compare_type(self, data):
        return isinstance(data, type(self.spec))

class one_of(object):
    """
    One of the given types.

    >>> from .validator import validate
    >>> validate(one_of(str(), number()), 'foo')
    >>> validate(one_of(str(), number()), 32)
    """
    def __init__(self, *specs):
        self.specs = specs

# typo, backwards compatibility
one_off = one_of

def combined(*dicts):
    """
    Combine multiple dicts.
    
    >>> (combined({'a': 'foo'}, {'b': 'bar'})
    ...  == {'a': 'foo', 'b': 'bar'})
    True
    """
    result = {}
    for d in dicts:
        result.update(d)
    return result

class number(object):
    """
    Any number.

    >>> from .validator import validate
    >>> validate(number(), 1)
    >>> validate(number(), -32.0)
    >>> validate(number(), 99999999999999L)
    """
    def compare_type(self, data):
        # True/False are also instances of int, exclude them
        return isinstance(data, (float, int, long)) and not isinstance(data, bool)

class type_spec(object):
    def __init__(self, type_key, specs):
        self.type_key = type_key
        self.specs = specs

        for v in specs.itervalues():
            if not isinstance(v, dict):
                raise ValueError('%s requires dict subspecs', self.__class__)
            if self.type_key not in v:
                v[self.type_key] = str()

    def subspec(self, data, context):
        if self.type_key not in data:
            raise ValueError("'%s' not in %s" % (self.type_key, context.current_pos))
        key = data[self.type_key]

        if key not in self.specs:
            raise ValueError("unknown %s value '%s' in %s" % (self.type_key, key, context.current_pos))
        return self.specs[key]

########NEW FILE########
__FILENAME__ = test_validator
# -:- encoding: utf8 -:-
# Copyright (c) 2011, Oliver Tonnhofer <olt@omniscale.de>
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from __future__ import absolute_import

import unittest

from ..validator import validate, ValidationError, SpecError
from ..spec import required, one_of, number, recursive, type_spec, anything


def raises(exception):
    def wrapper(f):
        def _wrapper(self):
            try:
                f(self)
            except exception:
                pass
            else:
                raise AssertionError('expected exception %s', exception)
    return wrapper

class TestSimpleDict(unittest.TestCase):
    def test_validate_simple_dict(self):
        spec = {'hello': 1, 'world': True}
        validate(spec, {'hello': 34, 'world': False})

    @raises(ValidationError)
    def test_invalid_key(self):
        spec = {'world': True}
        validate(spec, {'world_foo': False})

    def test_empty_data(self):
        spec = {'world': 1}
        validate(spec, {})

    @raises(ValidationError)
    def test_invalid_value(self):
        spec = {'world': 1}
        validate(spec, {'world_foo': False})

    @raises(ValidationError)
    def test_missing_required_key(self):
        spec = {required('world'): 1}
        validate(spec, {})
    
    def test_valid_one_of(self):
        spec = {'hello': one_of(1, bool())}
        validate(spec, {'hello': 129})
        validate(spec, {'hello': True})
    
    @raises(ValidationError)
    def test_invalid_one_of(self):
        spec = {'hello': one_of(1, False)}
        validate(spec, {'hello': []})

    def test_instances_and_types(self):
        spec = {'str()': str(), 'basestring': basestring, 'int': int, 'int()': int()}
        validate(spec, {'str()': 'str', 'basestring': u'', 'int': 1, 'int()': 1})


class TestLists(unittest.TestCase):
    def test_list(self):
        spec = [1]
        validate(spec, [1, 2, 3, 4, -9])

    def test_empty_list(self):
        spec = [1]
        validate(spec, [])
    
    @raises(ValidationError)
    def test_invalid_item(self):
        spec = [1]
        validate(spec, [1, 'hello'])

class TestNumber(unittest.TestCase):
    def check_valid(self, spec, data):
        validate(spec, data)
    
    def test_numbers(self):
        spec = number()
        for i in (0, 1, 23e999, int(10e20), 23.1, -0.0000000001):
            yield self.check_valid, spec, i

class TestNested(unittest.TestCase):
    def check_valid(self, spec, data):
        validate(spec, data)
    
    @raises(ValidationError)
    def check_invalid(self, spec, data):
        validate(spec, data)
        
    def test_dict(self):
        spec = {
            'globals': {
                'image': {
                    'format': {
                        'png': {
                            'mode': 'RGB',
                        }
                    },
                },
                'cache': {
                    'base_dir': '/path/to/foo'
                }
            }
        }
        
        yield self.check_valid, spec, {'globals': {'image': {'format': {'png': {'mode': 'P'}}}}}
        yield self.check_valid, spec, {'globals': {'image': {'format': {'png': {'mode': 'P'}}},
                                                   'cache': {'base_dir': '/somewhere'}}}
        yield self.check_invalid, spec, {'globals': {'image': {'foo': {'png': {'mode': 'P'}}}}}
        yield self.check_invalid, spec, {'globals': {'image': {'png': {'png': {'mode': 1}}}}}

class TestRecursive(unittest.TestCase):
    def test(self):
        spec = recursive({'hello': str(), 'more': recursive()})
        validate(spec, {'hello': 'world', 'more': {'hello': 'foo', 'more': {'more': {}}}})

    def test_multiple(self):
        spec = {'a': recursive({'hello': str(), 'more': recursive()}), 'b': recursive({'foo': recursive()})}
        validate(spec, {'b': {'foo': {'foo': {}}}})
        validate(spec, {'a': {'hello': 'world', 'more': {'hello': 'foo', 'more': {'more': {}}}}})
        validate(spec, {'b': {'foo': {'foo': {}}},
                        'a': {'hello': 'world', 'more': {'hello': 'foo', 'more': {'more': {}}}}})
    @raises(SpecError)
    def test_without_spec(self):
        spec = {'a': recursive()}
        validate(spec, {'a': {'a': {}}})

class TestTypeSpec(unittest.TestCase):
    def test(self):
        spec = type_spec('type', {'foo': {'alpha': str()}, 'bar': {'one': 1, 'two': str()}})
        validate(spec, {'type': 'foo', 'alpha': 'yes'})
        validate(spec, {'type': 'bar', 'one': 2})

class TestErrors(unittest.TestCase):
    def test_invalid_types(self):
        spec = {'str': str, 'str()': str(), 'basestring': basestring, '1': 1, 'int': int}
        try:
            validate(spec, {'str': 1, 'str()': 1, 'basestring': 1, '1': 'a', 'int': 'int'})
        except ValidationError, ex:
            ex.errors.sort()
            assert ex.errors[0] == "'a' in 1 not of type int"
            assert ex.errors[1] == "'int' in int not of type int"
            assert ex.errors[2] == '1 in basestring not of type basestring'
            assert ex.errors[3] == '1 in str not of type str'
            assert ex.errors[4] == '1 in str() not of type str'
        else:
            assert False

    def test_invalid_key(self):
        spec = {'world': {'europe': {}}}
        try:
            validate(spec, {'world': {'europe': {'germany': 1}}})
        except ValidationError, ex:
            assert 'world.europe' in str(ex)
        else:
            assert False

    def test_invalid_list_item(self):
        spec = {'numbers': [number()]}
        try:
            validate(spec, {'numbers': [1, 2, 3, 'foo']})
        except ValidationError, ex:
            assert 'numbers[3] not of type number' in str(ex), str(ex)
        else:
            assert False

    def test_multiple_invalid_list_items(self):
        spec = {'numbers': [number()]}
        try:
            validate(spec, {'numbers': [1, True, 3, 'foo']})
        except ValidationError, ex:
            assert '2 validation errors' in str(ex), str(ex)
            assert 'numbers[1] not of type number' in ex.errors[0]
            assert 'numbers[3] not of type number' in ex.errors[1]
        else:
            assert False

    def test_error_in_non_string_key(self):
        spec = {1: bool()}
        try:
            validate(spec, {1: 'not a bool'})
        except ValidationError, ex:
            assert "'not a bool' in 1 not of type bool" in ex.errors[0]
        else:
            assert False
    
    def test_error_in_non_string_key_with_anything_key_spec(self):
        spec = {anything(): bool()}
        try:
            validate(spec, {1: 'not a bool'})
        except ValidationError, ex:
            assert "'not a bool' in 1 not of type bool" in ex.errors[0]
        else:
            assert False

def test_one_of_with_custom_types():
    # test for fixed validation of one_of specs with values that are
    # not lists or dicts (e.g. recursive)
    spec = one_of([str], recursive({required('foo'): basestring}))
    validate(spec, ['foo', 'bar'])
    validate(spec, {'foo': 'bar'})
    try:
        validate(spec, {'nofoo': 'bar'})
    except ValidationError, ex:
        assert "missing 'foo'" in ex.errors[0]
    else:
        assert False

if __name__ == '__main__':
    unittest.main()


########NEW FILE########
__FILENAME__ = validator
# Copyright (c) 2011, Oliver Tonnhofer <olt@omniscale.de>
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from __future__ import with_statement

import re
from contextlib import contextmanager

from .spec import required, one_of, anything, recursive

class Context(object):
    def __init__(self):
        self.recurse_spec = None
        self.obj_pos = []
    
    def push(self, spec):
        self.obj_pos.append(spec)
    
    def pop(self):
        return self.obj_pos.pop()
    
    @contextmanager
    def pos(self, spec):
        self.push(spec)
        yield
        self.pop()
    
    @property
    def current_pos(self):
        return ''.join(self.obj_pos).lstrip('.') or '.'

def validate(spec, data):
    """
    Validate `data` against `spec`.
    """
    return Validator(spec).validate(data)

class ValidationError(TypeError):
    def __init__(self, msg, errors=None, informal_only=False):
        TypeError.__init__(self, msg)
        self.informal_only = informal_only
        self.errors = errors or []

class SpecError(TypeError):
    pass

class Validator(object):
    def __init__(self, spec, fail_fast=False):
        """
        :params fail_fast: True if it should raise on the first error
        """
        self.context = Context()
        self.complete_spec = spec
        self.raise_first_error = fail_fast
        self.errors = False
        self.messages = []
        
    def validate(self, data):
        self._validate_part(self.complete_spec, data)
        
        if self.messages:
            if len(self.messages) == 1:
                raise ValidationError(self.messages[0], self.messages, informal_only=not self.errors)
            else:
                raise ValidationError('found %d validation errors.' % len(self.messages), self.messages,
                    informal_only=not self.errors)

    def _validate_part(self, spec, data):
        if hasattr(spec, 'subspec'):
            try:
                spec = spec.subspec(data, self.context)
            except ValueError, ex:
                return self._handle_error(str(ex))

        if isinstance(spec, recursive):
            if spec.spec:
                self.context.recurse_spec = spec.spec
                self._validate_part(spec.spec, data)
                self.context.recurse_spec = None
                return
            else:
                spec = self.context.recurse_spec
                if spec is None:
                    raise SpecError('found recursive() outside recursive spec')

        if isinstance(spec, anything):
            return

        if data is None:
            data = {}

        if isinstance(spec, one_of):
            # check if at least one spec type matches
            for subspec in spec.specs:
                if type_matches(subspec, data):
                    self._validate_part(subspec, data)
                    return
            else:
                return self._handle_error("%r in %s not of any type %s" %
                    (data, self.context.current_pos, ', '.join(map(type_str, spec.specs))))
        elif not type_matches(spec, data):
            return self._handle_error("%r in %s not of type %s" %
                (data, self.context.current_pos, type_str(spec)))
    
        # recurse in dicts and lists
        if isinstance(spec, dict):
            self._validate_dict(spec, data)
        elif isinstance(spec, list):
            self._validate_list(spec, data)

    def _validate_dict(self, spec, data):
        accept_any_key = False
        any_key_spec = None
        for k in spec.iterkeys():
            if isinstance(k, required):
                if k not in data:
                    self._handle_error("missing '%s' not in %s" %
                        (k, self.context.current_pos))
            if isinstance(k, anything):
                accept_any_key = True
                any_key_spec = spec[k]

        for k, v in data.iteritems():
            if accept_any_key:
                with self.context.pos('.' + str(k)):
                    self._validate_part(any_key_spec, v)

            else:
                if k not in spec:
                    self._handle_error("unknown '%s' in %s" %
                        (k, self.context.current_pos), info_only=True)
                    continue
                with self.context.pos('.' + str(k)):
                    self._validate_part(spec[k], v)

    def _validate_list(self, spec, data):
        if not len(spec) == 1:
            raise SpecError('lists support only one type, got: %s' % spec)
        for i, v in enumerate(data):
            with self.context.pos('[%d]' % i):
                self._validate_part(spec[0], v)
    
    def _handle_error(self, msg, info_only=False):
        if not info_only:
            self.errors = True
        if self.raise_first_error and not info_only:
            raise ValidationError(msg)
        self.messages.append(msg)

def type_str(spec):
    if not isinstance(spec, type):
        spec = type(spec)

    match = re.match("<type '(\w+)'>", str(spec))
    if match:
        return match.group(1)

    match = re.match("<class '([\w._]+)'>", str(spec))
    if match:
        return match.group(1).split('.')[-1]

    return str(type)

def type_matches(spec, data):
    if hasattr(spec, 'compare_type'):
        return spec.compare_type(data)
    if isinstance(spec, type):
        spec_type = spec
    else:
        spec_type = type(spec)
    return isinstance(data, spec_type)


########NEW FILE########
__FILENAME__ = itertools
# missing izip_longest function for Python 2.5 compatibility
# http://docs.python.org/library/itertools.html#itertools.izip_longest
# Copyright 2001-2012 Python Software Foundation; All Rights Reserved

from __future__ import absolute_import
import itertools

if hasattr(itertools, 'izip_longest'):
    izip_longest = itertools.izip_longest
else:
    class ZipExhausted(Exception):
        pass

    def izip_longest(*args, **kwds):
        # izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-
        fillvalue = kwds.get('fillvalue')
        counter = [len(args) - 1]
        def sentinel():
            if not counter[0]:
                raise ZipExhausted
            counter[0] -= 1
            yield fillvalue
        fillers = itertools.repeat(fillvalue)
        iterators = [itertools.chain(it, sentinel(), fillers) for it in args]
        try:
            while iterators:
                yield tuple(i.next() for i in iterators)
        except ZipExhausted:
            pass
########NEW FILE########
__FILENAME__ = local
# -*- coding: utf-8 -*-
"""
This module implements context-local objects.

This is a partial version of werkzeug/local.py containing only Local and
StackLocal.

Last update: 2011-03-15 9ada59c958b2edbb9739fb55a6b32ef4a97dac07

:copyright: (c) 2010 by the Werkzeug Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""
try:
    from greenlet import getcurrent as get_current_greenlet
except ImportError: # pragma: no cover
    try:
        from py.magic import greenlet
        get_current_greenlet = greenlet.getcurrent
        del greenlet
    except Exception:
        # catch all, py.* fails with so many different errors.
        get_current_greenlet = int
try:
    from thread import get_ident as get_current_thread, allocate_lock
except ImportError: # pragma: no cover
    from dummy_thread import get_ident as get_current_thread, allocate_lock


# get the best ident function.  if greenlets are not installed we can
# safely just use the builtin thread function and save a python methodcall
# and the cost of calculating a hash.
if get_current_greenlet is int: # pragma: no cover
    get_ident = get_current_thread
else:
    get_ident = lambda: (get_current_thread(), get_current_greenlet())


def release_local(local):
    """Releases the contents of the local for the current context.
    This makes it possible to use locals without a manager.

    Example::

        >>> loc = Local()
        >>> loc.foo = 42
        >>> release_local(loc)
        >>> hasattr(loc, 'foo')
        False

    With this function one can release :class:`Local` objects as well
    as :class:`StackLocal` objects.  However it is not possible to
    release data held by proxies that way, one always has to retain
    a reference to the underlying local object in order to be able
    to release it.

    .. versionadded:: 0.6.1
    """
    local.__release_local__()


class Local(object):
    __slots__ = ('__storage__', '__lock__', '__ident_func__')

    def __init__(self):
        object.__setattr__(self, '__storage__', {})
        object.__setattr__(self, '__lock__', allocate_lock())
        object.__setattr__(self, '__ident_func__', get_ident)

    def __iter__(self):
        return self.__storage__.iteritems()

    def __call__(self, proxy):
        """Create a proxy for a name."""
        return LocalProxy(self, proxy)

    def __release_local__(self):
        self.__storage__.pop(self.__ident_func__(), None)

    def __getattr__(self, name):
        try:
            return self.__storage__[self.__ident_func__()][name]
        except KeyError:
            raise AttributeError(name)

    def __setattr__(self, name, value):
        ident = self.__ident_func__()
        self.__lock__.acquire()
        try:
            storage = self.__storage__
            if ident in storage:
                storage[ident][name] = value
            else:
                storage[ident] = {name: value}
        finally:
            self.__lock__.release()

    def __delattr__(self, name):
        try:
            del self.__storage__[self.__ident_func__()][name]
        except KeyError:
            raise AttributeError(name)


class LocalStack(object):
    """This class works similar to a :class:`Local` but keeps a stack
    of objects instead.  This is best explained with an example::

        >>> ls = LocalStack()
        >>> ls.push(42)
        [42]
        >>> ls.top
        42
        >>> ls.push(23)
        [42, 23]
        >>> ls.top
        23
        >>> ls.pop()
        23
        >>> ls.top
        42

    They can be force released by using a :class:`LocalManager` or with
    the :func:`release_local` function but the correct way is to pop the
    item from the stack after using.  When the stack is empty it will
    no longer be bound to the current context (and as such released).

    By calling the stack without arguments it returns a proxy that resolves to
    the topmost item on the stack.

    .. versionadded:: 0.6.1
    """

    def __init__(self):
        self._local = Local()
        self._lock = allocate_lock()

    def __release_local__(self):
        self._local.__release_local__()

    def _get__ident_func__(self):
        return self._local.__ident_func__
    def _set__ident_func__(self, value):
        object.__setattr__(self._local, '__ident_func__', value)
    __ident_func__ = property(_get__ident_func__, _set__ident_func__)
    del _get__ident_func__, _set__ident_func__

    def __call__(self):
        def _lookup():
            rv = self.top
            if rv is None:
                raise RuntimeError('object unbound')
            return rv
        return LocalProxy(_lookup)

    def push(self, obj):
        """Pushes a new item to the stack"""
        self._lock.acquire()
        try:
            rv = getattr(self._local, 'stack', None)
            if rv is None:
                self._local.stack = rv = []
            rv.append(obj)
            return rv
        finally:
            self._lock.release()

    def pop(self):
        """Removes the topmost item from the stack, will return the
        old value or `None` if the stack was already empty.
        """
        self._lock.acquire()
        try:
            stack = getattr(self._local, 'stack', None)
            if stack is None:
                return None
            elif len(stack) == 1:
                release_local(self._local)
                return stack[-1]
            else:
                return stack.pop()
        finally:
            self._lock.release()

    @property
    def top(self):
        """The topmost item on the stack.  If the stack is empty,
        `None` is returned.
        """
        try:
            return self._local.stack[-1]
        except (AttributeError, IndexError):
            return None


########NEW FILE########
__FILENAME__ = lockfile
##############################################################################
#
# This is a modified version of zc.lockfile 1.0.0
# (http://pypi.python.org/pypi/zc.lockfile/1.0.0)
#
# Copyright (c) 2001, 2002 Zope Corporation and Contributors.
# All Rights Reserved.
#
# ==== Changelog ====
# 2010-04-01 - Commented out logging. <olt@omniscale.de>
#
# ==== License ====
#
# This software is subject to the provisions of the Zope Public License,
# Version 2.1 (ZPL).
#
# Zope Public License (ZPL) Version 2.1
#
# A copyright notice accompanies this license document that identifies the
# copyright holders.
#
# This license has been certified as open source. It has also been designated as
# GPL compatible by the Free Software Foundation (FSF).
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# - Redistributions in source code must retain the accompanying copyright
#   notice, this list of conditions, and the following disclaimer.
#
# - Redistributions in binary form must reproduce the accompanying copyright
#   notice, this list of conditions, and the following disclaimer in the
#   documentation and/or other materials provided with the distribution.
#
# - Names of the copyright holders must not be used to endorse or promote
#   products derived from this software without prior written permission from
#   the copyright holders.
#
# - The right to distribute this software or to use it for any purpose does not
#   give you the right to use Servicemarks (sm) or Trademarks (tm) of the
#   copyright holders. Use of them is covered by separate agreement with the
#   copyright holders.
#
# - If any files are modified, you must cause the modified files to carry
#   prominent notices stating that you changed the files and the date of any
#   change.
#
# Disclaimer
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY EXPRESSED
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
# EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
##############################################################################

import os
# import logging
# logger = logging.getLogger("zc.lockfile")

class LockError(Exception):
    """Couldn't get a lock
    """

try:
    import fcntl
except ImportError:
    try:
        import msvcrt
    except ImportError:
        def _lock_file(file):
            raise TypeError('No file-locking support on this platform')
        def _unlock_file(file):
            raise TypeError('No file-locking support on this platform')

    else:
        # Windows
        def _lock_file(file):
            # Lock just the first byte
            try:
                msvcrt.locking(file.fileno(), msvcrt.LK_NBLCK, 1)
            except IOError:
                raise LockError("Couldn't lock %r" % file.name)

        def _unlock_file(file):
            try:
                file.seek(0)
                msvcrt.locking(file.fileno(), msvcrt.LK_UNLCK, 1)
            except IOError:
                raise LockError("Couldn't unlock %r" % file.name)

else:
    # Unix
    _flags = fcntl.LOCK_EX | fcntl.LOCK_NB

    def _lock_file(file):
        try:
            fcntl.flock(file.fileno(), _flags)
        except IOError:
            raise LockError("Couldn't lock %r" % file.name)


    def _unlock_file(file):
        # File is automatically unlocked on close
        pass


class LockFile:

    _fp = None

    def __init__(self, path):
        self._path = path
        fp = open(path, 'w+')

        try:
            _lock_file(fp)
        except Exception, ex:
            try:
                fp.close()
            except Exception:
                pass
            raise ex

        self._fp = fp
        fp.write(" %s\n" % os.getpid())
        fp.truncate()
        fp.flush()

    def close(self):
        if self._fp is not None:
            _unlock_file(self._fp)
            self._fp.close()
            self._fp = None

########NEW FILE########
__FILENAME__ = odict
# -*- coding: utf-8 -*-
"""
    odict
    ~~~~~

    This module is an example implementation of an ordered dict for the
    collections module.  It's not written for performance (it actually
    performs pretty bad) but to show how the API works.


    Questions and Answers
    =====================

    Why would anyone need ordered dicts?

        Dicts in python are unordered which means that the order of items when
        iterating over dicts is undefined.  As a matter of fact it is most of
        the time useless and differs from implementation to implementation.

        Many developers stumble upon that problem sooner or later when
        comparing the output of doctests which often does not match the order
        the developer thought it would.

        Also XML systems such as Genshi have their problems with unordered
        dicts as the input and output ordering of tag attributes is often
        mixed up because the ordering is lost when converting the data into
        a dict.  Switching to lists is often not possible because the
        complexity of a lookup is too high.

        Another very common case is metaprogramming.  The default namespace
        of a class in python is a dict.  With Python 3 it becomes possible
        to replace it with a different object which could be an ordered dict.
        Django is already doing something similar with a hack that assigns
        numbers to some descriptors initialized in the class body of a
        specific subclass to restore the ordering after class creation.

        When porting code from programming languages such as PHP and Ruby
        where the item-order in a dict is guaranteed it's also a great help
        to have an equivalent data structure in Python to ease the transition.

    Where are new keys added?

        At the end.  This behavior is consistent with Ruby 1.9 Hashmaps
        and PHP Arrays.  It also matches what common ordered dict
        implementations do currently.

    What happens if an existing key is reassigned?

        The key is *not* moved.  This is consitent with existing
        implementations and can be changed by a subclass very easily::

            class movingodict(odict):
                def __setitem__(self, key, value):
                    self.pop(key, None)
                    odict.__setitem__(self, key, value)

        Moving keys to the end of a ordered dict on reassignment is not
        very useful for most applications.

    Does it mean the dict keys are sorted by a sort expression?

        That's not the case.  The odict only guarantees that there is an order
        and that newly inserted keys are inserted at the end of the dict.  If
        you want to sort it you can do so, but newly added keys are again added
        at the end of the dict.

    I initializes the odict with a dict literal but the keys are not
    ordered like they should!

        Dict literals in Python generate dict objects and as such the order of
        their items is not guaranteed.  Before they are passed to the odict
        constructor they are already unordered.

    What happens if keys appear multiple times in the list passed to the
    constructor?

        The same as for the dict.  The latter item overrides the former.  This
        has the side-effect that the position of the first key is used because
        the key is actually overwritten:

        >>> odict([('a', 1), ('b', 2), ('a', 3)])
        odict.odict([('a', 3), ('b', 2)])

        This behavor is consistent with existing implementation in Python
        and the PHP array and the hashmap in Ruby 1.9.

    This odict doesn't scale!

        Yes it doesn't.  The delitem operation is O(n).  This is file is a
        mockup of a real odict that could be implemented for collections
        based on an linked list.

    Why is there no .insert()?

        There are few situations where you really want to insert a key at
        an specified index.  To now make the API too complex the proposed
        solution for this situation is creating a list of items, manipulating
        that and converting it back into an odict:

        >>> d = odict([('a', 42), ('b', 23), ('c', 19)])
        >>> l = d.items()
        >>> l.insert(1, ('x', 0))
        >>> odict(l)
        odict.odict([('a', 42), ('x', 0), ('b', 23), ('c', 19)])

    :copyright: (c) 2008 by Armin Ronacher and PEP 273 authors.
    :license: modified BSD license.
"""
from __future__ import absolute_import
from itertools import izip, imap
from copy import deepcopy

missing = object()


class odict(dict):
    """
    Ordered dict example implementation.

    This is the proposed interface for a an ordered dict as proposed on the
    Python mailinglist (proposal_).

    It's a dict subclass and provides some list functions.  The implementation
    of this class is inspired by the implementation of Babel but incorporates
    some ideas from the `ordereddict`_ and Django's ordered dict.

    The constructor and `update()` both accept iterables of tuples as well as
    mappings:

    >>> d = odict([('a', 'b'), ('c', 'd')])
    >>> d.update({'foo': 'bar'})
    >>> d
    odict.odict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])

    Keep in mind that when updating from dict-literals the order is not
    preserved as these dicts are unsorted!

    You can copy an odict like a dict by using the constructor, `copy.copy`
    or the `copy` method and make deep copies with `copy.deepcopy`:

    >>> from copy import copy, deepcopy
    >>> copy(d)
    odict.odict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])
    >>> d.copy()
    odict.odict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])
    >>> odict(d)
    odict.odict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])
    >>> d['spam'] = []
    >>> d2 = deepcopy(d)
    >>> d2['spam'].append('eggs')
    >>> d
    odict.odict([('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', [])])
    >>> d2
    odict.odict([('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', ['eggs'])])

    All iteration methods as well as `keys`, `values` and `items` return
    the values ordered by the the time the key-value pair is inserted:

    >>> d.keys()
    ['a', 'c', 'foo', 'spam']
    >>> d.values()
    ['b', 'd', 'bar', []]
    >>> d.items()
    [('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', [])]
    >>> list(d.iterkeys())
    ['a', 'c', 'foo', 'spam']
    >>> list(d.itervalues())
    ['b', 'd', 'bar', []]
    >>> list(d.iteritems())
    [('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', [])]

    Index based lookup is supported too by `byindex` which returns the
    key/value pair for an index:

    >>> d.byindex(2)
    ('foo', 'bar')

    You can reverse the odict as well:

    >>> d.reverse()
    >>> d
    odict.odict([('spam', []), ('foo', 'bar'), ('c', 'd'), ('a', 'b')])

    And sort it like a list:

    >>> d.sort(key=lambda x: x[0].lower())
    >>> d
    odict.odict([('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', [])])

    .. _proposal: http://thread.gmane.org/gmane.comp.python.devel/95316
    .. _ordereddict: http://www.xs4all.nl/~anthon/Python/ordereddict/
    """

    def __init__(self, *args, **kwargs):
        dict.__init__(self)
        self._keys = []
        self.update(*args, **kwargs)

    def __delitem__(self, key):
        dict.__delitem__(self, key)
        self._keys.remove(key)

    def __setitem__(self, key, item):
        if key not in self:
            self._keys.append(key)
        dict.__setitem__(self, key, item)

    def __deepcopy__(self, memo=None):
        if memo is None:
            memo = {}
        d = memo.get(id(self), missing)
        if d is not missing:
            return d
        memo[id(self)] = d = self.__class__()
        dict.__init__(d, deepcopy(self.items(), memo))
        d._keys = self._keys[:]
        return d

    def __getstate__(self):
        return {'items': dict(self), 'keys': self._keys}

    def __setstate__(self, d):
        self._keys = d['keys']
        dict.update(d['items'])

    def __reversed__(self):
        return reversed(self._keys)

    def __eq__(self, other):
        if isinstance(other, odict):
            if not dict.__eq__(self, other):
                return False
            return self.items() == other.items()
        return dict.__eq__(self, other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __cmp__(self, other):
        if isinstance(other, odict):
            return cmp(self.items(), other.items())
        elif isinstance(other, dict):
            return dict.__cmp__(self, other)
        return NotImplemented

    @classmethod
    def fromkeys(cls, iterable, default=None):
        return cls((key, default) for key in iterable)

    def clear(self):
        del self._keys[:]
        dict.clear(self)

    def copy(self):
        return self.__class__(self)

    def items(self):
        return zip(self._keys, self.values())

    def iteritems(self):
        return izip(self._keys, self.itervalues())

    def keys(self):
        return self._keys[:]

    def iterkeys(self):
        return iter(self._keys)

    def pop(self, key, default=missing):
        if default is missing:
            return dict.pop(self, key)
        elif key not in self:
            return default
        self._keys.remove(key)
        return dict.pop(self, key, default)

    def popitem(self, key):
        self._keys.remove(key)
        return dict.popitem(key)

    def setdefault(self, key, default=None):
        if key not in self:
            self._keys.append(key)
        dict.setdefault(self, key, default)

    def update(self, *args, **kwargs):
        sources = []
        if len(args) == 1:
            if hasattr(args[0], 'iteritems'):
                sources.append(args[0].iteritems())
            else:
                sources.append(iter(args[0]))
        elif args:
            raise TypeError('expected at most one positional argument')
        if kwargs:
            sources.append(kwargs.iteritems())
        for iterable in sources:
            for key, val in iterable:
                self[key] = val

    def values(self):
        return map(self.get, self._keys)

    def itervalues(self):
        return imap(self.get, self._keys)

    def index(self, item):
        return self._keys.index(item)

    def byindex(self, item):
        key = self._keys[item]
        return (key, dict.__getitem__(self, key))

    def reverse(self):
        self._keys.reverse()

    def sort(self, *args, **kwargs):
        self._keys.sort(*args, **kwargs)

    def __repr__(self):
        return 'odict.odict(%r)' % self.items()

    __copy__ = copy
    __iter__ = iterkeys


if __name__ == '__main__':
    import doctest
    doctest.testmod()
########NEW FILE########
__FILENAME__ = serving
# -*- coding: utf-8 -*-
"""
This module implements .

This is a version of werkzeug/serving.py with other Werkzeug dependencies
removed (_log).

Last update: 2011-03-15 9ada59c958b2edbb9739fb55a6b32ef4a97dac07

:copyright: (c) 2010 by the Werkzeug Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.
"""
import os
import socket
import sys
import time
import thread
import subprocess
from urllib import unquote
from SocketServer import ThreadingMixIn, ForkingMixIn
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler

import mapproxy
# import werkzeug
# from werkzeug._internal import _log
# from werkzeug.exceptions import InternalServerError

def _log(type, message, *args):
    if args:
        message = message % args
    sys.stderr.write('[%s] %s\n' % (type, message.rstrip()))
    sys.stderr.flush()

class WSGIRequestHandler(BaseHTTPRequestHandler, object):
    """A request handler that implements WSGI dispatching."""

    @property
    def server_version(self):
        return 'MapProxy/' + mapproxy.version.__version__ + ' (Werkzeug based)'

    def make_environ(self):
        if '?' in self.path:
            path_info, query = self.path.split('?', 1)
        else:
            path_info = self.path
            query = ''
        url_scheme = self.server.ssl_context is None and 'http' or 'https'
        environ = {
            'wsgi.version':         (1, 0),
            'wsgi.url_scheme':      url_scheme,
            'wsgi.input':           self.rfile,
            'wsgi.errors':          sys.stderr,
            'wsgi.multithread':     self.server.multithread,
            'wsgi.multiprocess':    self.server.multiprocess,
            'wsgi.run_once':        False,
            'SERVER_SOFTWARE':      self.server_version,
            'REQUEST_METHOD':       self.command,
            'SCRIPT_NAME':          '',
            'PATH_INFO':            unquote(path_info),
            'QUERY_STRING':         query,
            'CONTENT_TYPE':         self.headers.get('Content-Type', ''),
            'CONTENT_LENGTH':       self.headers.get('Content-Length', ''),
            'REMOTE_ADDR':          self.client_address[0],
            'REMOTE_PORT':          self.client_address[1],
            'SERVER_NAME':          self.server.server_address[0],
            'SERVER_PORT':          str(self.server.server_address[1]),
            'SERVER_PROTOCOL':      self.request_version
        }

        for key, value in self.headers.items():
            key = 'HTTP_' + key.upper().replace('-', '_')
            if key not in ('HTTP_CONTENT_TYPE', 'HTTP_CONTENT_LENGTH'):
                environ[key] = value

        return environ

    def run_wsgi(self):
        app = self.server.app
        environ = self.make_environ()
        headers_set = []
        headers_sent = []

        def write(data):
            assert headers_set, 'write() before start_response'
            if not headers_sent:
                status, response_headers = headers_sent[:] = headers_set
                code, msg = status.split(None, 1)
                self.send_response(int(code), msg)
                header_keys = set()
                for key, value in response_headers:
                    self.send_header(key, value)
                    key = key.lower()
                    header_keys.add(key)
                if 'content-length' not in header_keys:
                    self.close_connection = True
                    self.send_header('Connection', 'close')
                if 'server' not in header_keys:
                    self.send_header('Server', self.version_string())
                if 'date' not in header_keys:
                    self.send_header('Date', self.date_time_string())
                self.end_headers()

            assert type(data) is str, 'applications must write bytes'
            self.wfile.write(data)
            self.wfile.flush()

        def start_response(status, response_headers, exc_info=None):
            if exc_info:
                try:
                    if headers_sent:
                        raise exc_info[0], exc_info[1], exc_info[2]
                finally:
                    exc_info = None
            elif headers_set:
                raise AssertionError('Headers already set')
            headers_set[:] = [status, response_headers]
            return write

        def execute(app):
            application_iter = app(environ, start_response)
            try:
                for data in application_iter:
                    write(data)
                # make sure the headers are sent
                if not headers_sent:
                    write('')
            finally:
                if hasattr(application_iter, 'close'):
                    application_iter.close()
                application_iter = None

        try:
            execute(app)
        except (socket.error, socket.timeout), e:
            self.connection_dropped(e, environ)
        except Exception:
            if self.server.passthrough_errors:
                raise
            from werkzeug.debug.tbtools import get_current_traceback
            traceback = get_current_traceback(ignore_system_exceptions=True)
            try:
                # if we haven't yet sent the headers but they are set
                # we roll back to be able to set them again.
                if not headers_sent:
                    del headers_set[:]
                execute(InternalServerError())
            except Exception:
                pass
            self.server.log('error', 'Error on request:\n%s',
                            traceback.plaintext)

    def handle(self):
        """Handles a request ignoring dropped connections."""
        try:
            return BaseHTTPRequestHandler.handle(self)
        except (socket.error, socket.timeout), e:
            self.connection_dropped(e)
        except Exception:
            if self.server.ssl_context is None or not is_ssl_error():
                raise

    def connection_dropped(self, error, environ=None):
        """Called if the connection was closed by the client.  By default
        nothing happens.
        """

    def handle_one_request(self):
        """Handle a single HTTP request."""
        self.raw_requestline = self.rfile.readline()
        if not self.raw_requestline:
            self.close_connection = 1
        elif self.parse_request():
            return self.run_wsgi()

    def send_response(self, code, message=None):
        """Send the response header and log the response code."""
        self.log_request(code)
        if message is None:
            message = code in self.responses and self.responses[code][0] or ''
        if self.request_version != 'HTTP/0.9':
            self.wfile.write("%s %d %s\r\n" %
                             (self.protocol_version, code, message))

    def version_string(self):
        return BaseHTTPRequestHandler.version_string(self).strip()

    def address_string(self):
        return self.client_address[0]

    def log_request(self, code='-', size='-'):
        self.log('info', '"%s" %s %s', self.requestline, code, size)

    def log_error(self, *args):
        self.log('error', *args)

    def log_message(self, format, *args):
        self.log('info', format, *args)

    def log(self, type, message, *args):
        _log(type, '%s - - [%s] %s\n' % (self.address_string(),
                                         self.log_date_time_string(),
                                         message % args))


#: backwards compatible name if someone is subclassing it
BaseRequestHandler = WSGIRequestHandler


def generate_adhoc_ssl_context():
    """Generates an adhoc SSL context for the development server."""
    from random import random
    from OpenSSL import crypto, SSL

    cert = crypto.X509()
    cert.set_serial_number(int(random() * sys.maxint))
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(60 * 60 * 24 * 365)

    subject = cert.get_subject()
    subject.CN = '*'
    subject.O = 'Dummy Certificate'

    issuer = cert.get_issuer()
    issuer.CN = 'Untrusted Authority'
    issuer.O = 'Self-Signed'

    pkey = crypto.PKey()
    pkey.generate_key(crypto.TYPE_RSA, 768)
    cert.set_pubkey(pkey)
    cert.sign(pkey, 'md5')

    ctx = SSL.Context(SSL.SSLv23_METHOD)
    ctx.use_privatekey(pkey)
    ctx.use_certificate(cert)

    return ctx


def is_ssl_error(error=None):
    """Checks if the given error (or the current one) is an SSL error."""
    if error is None:
        error = sys.exc_info()[1]
    from OpenSSL import SSL
    return isinstance(error, SSL.Error)


class _SSLConnectionFix(object):
    """Wrapper around SSL connection to provide a working makefile()."""

    def __init__(self, con):
        self._con = con

    def makefile(self, mode, bufsize):
        return socket._fileobject(self._con, mode, bufsize)

    def __getattr__(self, attrib):
        return getattr(self._con, attrib)


def select_ip_version(host, port):
    """Returns AF_INET4 or AF_INET6 depending on where to connect to."""
    # disabled due to problems with current ipv6 implementations
    # and various operating systems.  Probably this code also is
    # not supposed to work, but I can't come up with any other
    # ways to implement this.
    ##try:
    ##    info = socket.getaddrinfo(host, port, socket.AF_UNSPEC,
    ##                              socket.SOCK_STREAM, 0,
    ##                              socket.AI_PASSIVE)
    ##    if info:
    ##        return info[0][0]
    ##except socket.gaierror:
    ##    pass
    if ':' in host and hasattr(socket, 'AF_INET6'):
        return socket.AF_INET6
    return socket.AF_INET


class BaseWSGIServer(HTTPServer, object):
    """Simple single-threaded, single-process WSGI server."""
    multithread = False
    multiprocess = False
    request_queue_size = 128

    def __init__(self, host, port, app, handler=None,
                 passthrough_errors=False, ssl_context=None):
        if handler is None:
            handler = WSGIRequestHandler
        self.address_family = select_ip_version(host, port)
        HTTPServer.__init__(self, (host, int(port)), handler)
        self.app = app
        self.passthrough_errors = passthrough_errors

        if ssl_context is not None:
            try:
                from OpenSSL import tsafe
            except ImportError:
                raise TypeError('SSL is not available if the OpenSSL '
                                'library is not installed.')
            if ssl_context == 'adhoc':
                ssl_context = generate_adhoc_ssl_context()
            self.socket = tsafe.Connection(ssl_context, self.socket)
            self.ssl_context = ssl_context
        else:
            self.ssl_context = None

    def log(self, type, message, *args):
        _log(type, message, *args)

    def serve_forever(self):
        try:
            HTTPServer.serve_forever(self)
        except KeyboardInterrupt:
            pass

    def handle_error(self, request, client_address):
        if self.passthrough_errors:
            raise
        else:
            return HTTPServer.handle_error(self, request, client_address)

    def get_request(self):
        con, info = self.socket.accept()
        if self.ssl_context is not None:
            con = _SSLConnectionFix(con)
        return con, info


class ThreadedWSGIServer(ThreadingMixIn, BaseWSGIServer):
    """A WSGI server that does threading."""
    multithread = True


class ForkingWSGIServer(ForkingMixIn, BaseWSGIServer):
    """A WSGI server that does forking."""
    multiprocess = True

    def __init__(self, host, port, app, processes=40, handler=None,
                 passthrough_errors=False, ssl_context=None):
        BaseWSGIServer.__init__(self, host, port, app, handler,
                                passthrough_errors, ssl_context)
        self.max_children = processes


def make_server(host, port, app=None, threaded=False, processes=1,
                request_handler=None, passthrough_errors=False,
                ssl_context=None):
    """Create a new server instance that is either threaded, or forks
    or just processes one request after another.
    """
    if threaded and processes > 1:
        raise ValueError("cannot have a multithreaded and "
                         "multi process server.")
    elif threaded:
        return ThreadedWSGIServer(host, port, app, request_handler,
                                  passthrough_errors, ssl_context)
    elif processes > 1:
        return ForkingWSGIServer(host, port, app, processes, request_handler,
                                 passthrough_errors, ssl_context)
    else:
        return BaseWSGIServer(host, port, app, request_handler,
                              passthrough_errors, ssl_context)


def reloader_loop(extra_files=None, interval=1):
    """When this function is run from the main thread, it will force other
    threads to exit when any modules currently loaded change.

    Copyright notice.  This function is based on the autoreload.py from
    the CherryPy trac which originated from WSGIKit which is now dead.

    :param extra_files: a list of additional files it should watch.
    """
    def iter_module_files():
        for module in sys.modules.values():
            filename = getattr(module, '__file__', None)
            if filename:
                old = None
                while not os.path.isfile(filename):
                    old = filename
                    filename = os.path.dirname(filename)
                    if filename == old:
                        break
                else:
                    if filename[-4:] in ('.pyc', '.pyo'):
                        filename = filename[:-1]
                    yield filename

    fnames = []
    fnames.extend(iter_module_files())
    fnames.extend(extra_files or ())

    reloader(fnames, interval=interval)

def _reloader_stat_loop(fnames, interval=1):
    mtimes = {}
    while 1:
        for filename in fnames:
            try:
                mtime = os.stat(filename).st_mtime
            except OSError:
                continue

            old_time = mtimes.get(filename)
            if old_time is None:
                mtimes[filename] = mtime
                continue
            elif mtime > old_time:
                _log('info', ' * Detected change in %r, reloading' % filename)
                sys.exit(3)
        time.sleep(interval)

def _reloader_inotify(fnames, interval=None):
    #: Mutated by inotify loop when changes occur.
    changed = [False]

    # Setup inotify watches
    import pyinotify
    from pyinotify import WatchManager, EventsCodes, Notifier
    wm = WatchManager()
    mask = "IN_DELETE_SELF IN_MOVE_SELF IN_MODIFY IN_ATTRIB".split()
    try:
        # pyinotify 0.7
        mask = reduce(lambda m, a: m | getattr(EventsCodes, a), mask, 0)
    except AttributeError:
        # pyinotify 0.8 and up
        mask = reduce(lambda m, a: m | getattr(pyinotify, a), mask, 0)

    def signal_changed(event):
        if changed[0]:
            return
        _log('info', ' * Detected change in %r, reloading' % event.path)
        changed[:] = [True]

    for fname in fnames:
        wm.add_watch(fname, mask, signal_changed)

    # ... And now we wait...
    notif = Notifier(wm)
    try:
        while not changed[0]:
            notif.process_events()
            if notif.check_events(timeout=interval):
                notif.read_events()
            # TODO Set timeout to something small and check parent liveliness
    finally:
        notif.stop()
    sys.exit(3)

# Decide which reloader to use
try:
    __import__("pyinotify")   # Pyflakes-avoidant
except ImportError:
    reloader = _reloader_stat_loop
    reloader_name = "stat() polling"
else:
    reloader = _reloader_inotify
    reloader_name = "inotify events"


def restart_with_reloader():
    """Spawn a new Python interpreter with the same arguments as this one,
    but running the reloader thread.
    """
    while 1:
        _log('info', ' * Restarting with reloader: %s', reloader_name)
        args = [sys.executable] + sys.argv
        new_environ = os.environ.copy()
        new_environ['WERKZEUG_RUN_MAIN'] = 'true'

        # a weird bug on windows. sometimes unicode strings end up in the
        # environment and subprocess.call does not like this, encode them
        # to latin1 and continue.
        if os.name == 'nt':
            for key, value in new_environ.iteritems():
                if isinstance(value, unicode):
                    new_environ[key] = value.encode('iso-8859-1')

        exit_code = subprocess.call(args, env=new_environ)
        if exit_code != 3:
            return exit_code


def run_with_reloader(main_func, extra_files=None, interval=1):
    """Run the given function in an independent python interpreter."""
    if os.environ.get('WERKZEUG_RUN_MAIN') == 'true':
        thread.start_new_thread(main_func, ())
        try:
            reloader_loop(extra_files, interval)
        except KeyboardInterrupt:
            return
    try:
        sys.exit(restart_with_reloader())
    except KeyboardInterrupt:
        pass


def run_simple(hostname, port, application, use_reloader=False,
               use_debugger=False, use_evalex=True,
               extra_files=None, reloader_interval=1, threaded=False,
               processes=1, request_handler=None, static_files=None,
               passthrough_errors=False, ssl_context=None):
    """Start an application using wsgiref and with an optional reloader.  This
    wraps `wsgiref` to fix the wrong default reporting of the multithreaded
    WSGI variable and adds optional multithreading and fork support.

    .. versionadded:: 0.5
       `static_files` was added to simplify serving of static files as well
       as `passthrough_errors`.

    .. versionadded:: 0.6
       support for SSL was added.

    :param hostname: The host for the application.  eg: ``'localhost'``
    :param port: The port for the server.  eg: ``8080``
    :param application: the WSGI application to execute
    :param use_reloader: should the server automatically restart the python
                         process if modules were changed?
    :param use_debugger: should the werkzeug debugging system be used?
    :param use_evalex: should the exception evaluation feature be enabled?
    :param extra_files: a list of files the reloader should watch
                        additionally to the modules.  For example configuration
                        files.
    :param reloader_interval: the interval for the reloader in seconds.
    :param threaded: should the process handle each request in a separate
                     thread?
    :param processes: number of processes to spawn.
    :param request_handler: optional parameter that can be used to replace
                            the default one.  You can use this to replace it
                            with a different
                            :class:`~BaseHTTPServer.BaseHTTPRequestHandler`
                            subclass.
    :param static_files: a dict of paths for static files.  This works exactly
                         like :class:`SharedDataMiddleware`, it's actually
                         just wrapping the application in that middleware before
                         serving.
    :param passthrough_errors: set this to `True` to disable the error catching.
                               This means that the server will die on errors but
                               it can be useful to hook debuggers in (pdb etc.)
    :param ssl_context: an SSL context for the connection. Either an OpenSSL
                        context, the string ``'adhoc'`` if the server should
                        automatically create one, or `None` to disable SSL
                        (which is the default).
    """
    if use_debugger:
        from werkzeug.debug import DebuggedApplication
        application = DebuggedApplication(application, use_evalex)
    if static_files:
        from werkzeug.wsgi import SharedDataMiddleware
        application = SharedDataMiddleware(application, static_files)

    def inner():
        make_server(hostname, port, application, threaded,
                    processes, request_handler,
                    passthrough_errors, ssl_context).serve_forever()

    if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':
        display_hostname = hostname != '*' and hostname or 'localhost'
        if ':' in display_hostname:
            display_hostname = '[%s]' % display_hostname
        _log('info', ' * Running on %s://%s:%d/', ssl_context is None
             and 'http' or 'https', display_hostname, port)
    if use_reloader:
        # Create and destroy a socket so that any exceptions are raised before
        # we spawn a separate Python interpreter and lose this ability.
        test_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        test_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        test_socket.bind((hostname, port))
        test_socket.close()
        run_with_reloader(inner, extra_files, reloader_interval)
    else:
        inner()

########NEW FILE########
__FILENAME__ = compat3
import sys

__all__ = ['b', 'basestring_', 'bytes', 'next', 'is_unicode']

if sys.version < "3":
    b = bytes = str
    basestring_ = basestring
else:

    def b(s):
        if isinstance(s, str):
            return s.encode('latin1')
        return bytes(s)
    basestring_ = (bytes, str)
    bytes = bytes
text = str

if sys.version < "3":

    def next(obj):
        return obj.next()
else:
    next = next

if sys.version < "3":

    def is_unicode(obj):
        return isinstance(obj, unicode)
else:

    def is_unicode(obj):
        return isinstance(obj, str)


def coerce_text(v):
    if not isinstance(v, basestring_):
        if sys.version < "3":
            attr = '__unicode__'
        else:
            attr = '__str__'
        if hasattr(v, attr):
            return unicode(v)
        else:
            return bytes(v)
    return v

########NEW FILE########
__FILENAME__ = _looper
"""
Helper for looping over sequences, particular in templates.

Often in a loop in a template it's handy to know what's next up,
previously up, if this is the first or last item in the sequence, etc.
These can be awkward to manage in a normal Python loop, but using the
looper you can get a better sense of the context.  Use like::

    >>> for loop, item in looper(['a', 'b', 'c']):
    ...     print loop.number, item
    ...     if not loop.last:
    ...         print '---'
    1 a
    ---
    2 b
    ---
    3 c

"""

import sys
from mapproxy.util.ext.tempita.compat3 import basestring_

__all__ = ['looper']


class looper(object):
    """
    Helper for looping (particularly in templates)

    Use this like::

        for loop, item in looper(seq):
            if loop.first:
                ...
    """

    def __init__(self, seq):
        self.seq = seq

    def __iter__(self):
        return looper_iter(self.seq)

    def __repr__(self):
        return '<%s for %r>' % (
            self.__class__.__name__, self.seq)


class looper_iter(object):

    def __init__(self, seq):
        self.seq = list(seq)
        self.pos = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.pos >= len(self.seq):
            raise StopIteration
        result = loop_pos(self.seq, self.pos), self.seq[self.pos]
        self.pos += 1
        return result

    if sys.version < "3":
        next = __next__


class loop_pos(object):

    def __init__(self, seq, pos):
        self.seq = seq
        self.pos = pos

    def __repr__(self):
        return '<loop pos=%r at %r>' % (
            self.seq[self.pos], self.pos)

    def index(self):
        return self.pos
    index = property(index)

    def number(self):
        return self.pos + 1
    number = property(number)

    def item(self):
        return self.seq[self.pos]
    item = property(item)

    def __next__(self):
        try:
            return self.seq[self.pos + 1]
        except IndexError:
            return None
    __next__ = property(__next__)

    if sys.version < "3":
        next = __next__

    def previous(self):
        if self.pos == 0:
            return None
        return self.seq[self.pos - 1]
    previous = property(previous)

    def odd(self):
        return not self.pos % 2
    odd = property(odd)

    def even(self):
        return self.pos % 2
    even = property(even)

    def first(self):
        return self.pos == 0
    first = property(first)

    def last(self):
        return self.pos == len(self.seq) - 1
    last = property(last)

    def length(self):
        return len(self.seq)
    length = property(length)

    def first_group(self, getter=None):
        """
        Returns true if this item is the start of a new group,
        where groups mean that some attribute has changed.  The getter
        can be None (the item itself changes), an attribute name like
        ``'.attr'``, a function, or a dict key or list index.
        """
        if self.first:
            return True
        return self._compare_group(self.item, self.previous, getter)

    def last_group(self, getter=None):
        """
        Returns true if this item is the end of a new group,
        where groups mean that some attribute has changed.  The getter
        can be None (the item itself changes), an attribute name like
        ``'.attr'``, a function, or a dict key or list index.
        """
        if self.last:
            return True
        return self._compare_group(self.item, self.__next__, getter)

    def _compare_group(self, item, other, getter):
        if getter is None:
            return item != other
        elif (isinstance(getter, basestring_)
              and getter.startswith('.')):
            getter = getter[1:]
            if getter.endswith('()'):
                getter = getter[:-2]
                return getattr(item, getter)() != getattr(other, getter)()
            else:
                return getattr(item, getter) != getattr(other, getter)
        elif hasattr(getter, '__call__'):
            return getter(item) != getter(other)
        else:
            return item[getter] != other[getter]

########NEW FILE########
__FILENAME__ = parse
import math

from .util import resolve_ns

from xml.etree import ElementTree as etree


class WMSCapabilities(object):
    _default_namespace = None
    _namespaces = {
        'xlink': 'http://www.w3.org/1999/xlink',
    }

    version = None


    def __init__(self, tree):
        self.tree = tree
        self._layer_tree = None

    def resolve_ns(self, xpath):
        return resolve_ns(xpath, self._namespaces, self._default_namespace)

    def findtext(self, tree, xpath):
        return tree.findtext(self.resolve_ns(xpath))

    def find(self, tree, xpath):
        return tree.find(self.resolve_ns(xpath))

    def findall(self, tree, xpath):
        return tree.findall(self.resolve_ns(xpath))

    def attrib(self, elem, name):
        return elem.attrib[self.resolve_ns(name)]

    def metadata(self):
        md = dict(
            name = self.findtext(self.tree, 'Service/Name'),
            title = self.findtext(self.tree, 'Service/Title'),
            abstract = self.findtext(self.tree, 'Service/Abstract'),
            fees = self.findtext(self.tree, 'Service/Fees'),
            access_constraints = self.findtext(self.tree, 'Service/AccessConstraints'),
        )
        elem = self.find(self.tree, 'Service/OnlineResource')
        if elem is not None:
            md['online_resource'] = self.attrib(elem, 'xlink:href')

        md['contact'] = self.parse_contact()
        return md

    def parse_contact(self):
        elem = self.find(self.tree, 'Service/ContactInformation')
        md = dict(
            person = self.findtext(elem, 'ContactPersonPrimary/ContactPerson'),
            organization = self.findtext(elem, 'ContactPersonPrimary/ContactOrganization'),
            position = self.findtext(elem, 'ContactPosition'),

            address = self.findtext(elem, 'ContactAddress/Address'),
            city = self.findtext(elem, 'ContactAddress/City'),
            postcode = self.findtext(elem, 'ContactAddress/PostCode'),
            country = self.findtext(elem, 'ContactAddress/Country'),
            phone = self.findtext(elem, 'ContactVoiceTelephone'),
            fax = self.findtext(elem, 'ContactFacsimileTelephone'),
            email = self.findtext(elem, 'ContactElectronicMailAddress'),
        )

        return md


    def layers(self):
        if not self._layer_tree:
            root_layer = self.find(self.tree, 'Capability/Layer')
            self._layer_tree = self.parse_layer(root_layer, None)

        return self._layer_tree

    def layers_list(self):
        layers = []
        def append_layer(layer):
            if layer.get('name'):
                layers.append(layer)
            for child_layer in layer.get('layers', []):
                append_layer(child_layer)

        append_layer(self.layers())
        return layers

    def requests(self):
        requests_elem = self.find(self.tree, 'Capability/Request')
        resources = {}
        resource = self.find(requests_elem, 'GetMap/DCPType/HTTP/Get/OnlineResource')
        if resource != None:
            resources['GetMap'] = self.attrib(resource, 'xlink:href')
        return resources

    def parse_layer(self, layer_elem, parent_layer):
        child_layers = []
        layer = self.parse_layer_data(layer_elem, parent_layer or {})
        child_layer_elems = self.findall(layer_elem, 'Layer')

        for child_elem in child_layer_elems:
            child_layers.append(self.parse_layer(child_elem, layer))

        layer['layers'] = child_layers
        return layer

    def parse_layer_data(self, elem, parent_layer):
        layer = dict(
            queryable=elem.attrib.get('queryable') == '1',
            opaque=elem.attrib.get('opaque') == '1',
            title=self.findtext(elem, 'Title'),
            abstract=self.findtext(elem, 'Abstract'),
            name=self.findtext(elem, 'Name'),
        )

        layer['srs'] = self.layer_srs(elem, parent_layer)
        layer['res_hint'] = self.layer_res_hint(elem, parent_layer)
        layer['llbbox'] = self.layer_llbbox(elem, parent_layer)
        layer['bbox_srs'] = self.layer_bbox_srs(elem, parent_layer)
        layer['url'] = self.requests()['GetMap']
        layer['legend'] = self.layer_legend(elem)

        return layer

    def layer_legend(self, elem):
        style_elems = self.findall(elem, 'Style')
        legend_elem = None
        # we don't support styles, but will use the
        # LegendURL for the default style
        for elem in style_elems:
            if self.findtext(elem, 'Name') in ('default', ''):
                legend_elem = self.find(elem, 'LegendURL')
                break

        if legend_elem is None:
            return

        legend = {}
        legend_url = self.find(legend_elem, 'OnlineResource')
        legend['url'] = self.attrib(legend_url, 'xlink:href')
        return legend

    def layer_res_hint(self, elem, parent_layer):
        elem = self.find(elem, 'ScaleHint')
        if elem is None:
            return parent_layer.get('res_hint')
        # ScaleHints are the diagonal pixel resolutions
        # NOTE: max is not the maximum resolution, but the max
        # value, so it's actualy the min_res
        min_res = elem.attrib.get('max')
        max_res = elem.attrib.get('min')

        if min_res:
            min_res = math.sqrt(float(min_res) ** 2 / 2.0)
        if max_res:
            max_res = math.sqrt(float(max_res) ** 2 / 2.0)

        return min_res, max_res

class WMS111Capabilities(WMSCapabilities):
    version = '1.1.1'

    def layer_llbbox(self, elem, parent_layer):
        llbbox_elem = self.find(elem, 'LatLonBoundingBox')
        llbbox = None
        if llbbox_elem is not None:
            llbbox = (
                llbbox_elem.attrib['minx'],
                llbbox_elem.attrib['miny'],
                llbbox_elem.attrib['maxx'],
                llbbox_elem.attrib['maxy']
            )
            llbbox = map(float, llbbox)
        elif parent_layer and 'llbbox' in parent_layer:
            llbbox = parent_layer['llbbox']
        return llbbox

    def layer_srs(self, elem, parent_layer=None):
        srs_elements = self.findall(elem, 'SRS')
        srs_codes = set()

        for srs in srs_elements:
            srs = srs.text.strip().upper()
            if ' ' in srs:
                # handle multiple codes in one SRS tag (WMS 1.1.1 7.1.4.5.5)
                srs_codes.update(srs.split())
            else:
                srs_codes.add(srs)

        # unique srs-codes in either srs or parent_layer['srs']
        inherited_srs = parent_layer.get('srs', set()) if parent_layer else set()
        return srs_codes | inherited_srs

    def layer_bbox_srs(self, elem, parent_layer=None):
        bbox_srs = {}

        bbox_srs_elems = self.findall(elem, 'BoundingBox')
        if len(bbox_srs_elems) > 0:
            for bbox_srs_elem in bbox_srs_elems:
                srs = bbox_srs_elem.attrib['SRS']
                bbox = (
                    bbox_srs_elem.attrib['minx'],
                    bbox_srs_elem.attrib['miny'],
                    bbox_srs_elem.attrib['maxx'],
                    bbox_srs_elem.attrib['maxy']
                )
                bbox = map(float, bbox)
                bbox_srs[srs] = bbox
        elif parent_layer:
            bbox_srs = parent_layer['bbox_srs']

        return bbox_srs


class WMS130Capabilities(WMSCapabilities):
    version = '1.3.0'
    _default_namespace = 'http://www.opengis.net/wms'
    _ns = {
        'sld': "http://www.opengis.net/sld",
        'xlink': "http://www.w3.org/1999/xlink",
    }

    def layer_llbbox(self, elem, parent_layer):
        llbbox_elem = self.find(elem, 'EX_GeographicBoundingBox')
        llbbox = None
        if llbbox_elem is not None:
            llbbox = (
                self.find(llbbox_elem, 'westBoundLongitude').text,
                self.find(llbbox_elem, 'southBoundLatitude').text,
                self.find(llbbox_elem, 'eastBoundLongitude').text,
                self.find(llbbox_elem, 'northBoundLatitude').text
            )
            llbbox = map(float, llbbox)
        elif parent_layer and 'llbbox' in parent_layer:
            llbbox = parent_layer['llbbox']

        return llbbox

    def layer_srs(self, elem, parent_layer=None):
        srs_elements = self.findall(elem, 'CRS')
        srs_codes = set([srs.text.strip().upper() for srs in srs_elements])
        # unique srs-codes in either srs or parent_layer['srs']
        inherited_srs = parent_layer.get('srs', set()) if parent_layer else set()
        return srs_codes | inherited_srs

    def layer_bbox_srs(self, elem, parent_layer=None):
        bbox_srs = {}

        bbox_srs_elems = self.findall(elem, 'BoundingBox')
        if len(bbox_srs_elems) > 0:
            for bbox_srs_elem in bbox_srs_elems:
                srs = bbox_srs_elem.attrib['CRS']
                bbox = (
                    bbox_srs_elem.attrib['minx'],
                    bbox_srs_elem.attrib['miny'],
                    bbox_srs_elem.attrib['maxx'],
                    bbox_srs_elem.attrib['maxy']
                )
                bbox = map(float, bbox)
                bbox_srs[srs] = bbox
        elif parent_layer:
            bbox_srs = parent_layer['bbox_srs']

        return bbox_srs

def yaml_sources(cap):
    sources = {}
    for layer in cap.layers():
        layer_name = layer['name'] + '_wms'
        req = dict(url='http://example', layers=layer['name'])
        if not layer['opaque']:
            req['transparent'] = True


        sources[layer_name] = dict(
            type='wms',
            req=req
        )

    import yaml
    print yaml.dump(dict(sources=sources), default_flow_style=False)


def parse_capabilities(fileobj):
    if isinstance(fileobj, basestring):
        fileobj = open(fileobj)
    tree = etree.parse(fileobj)
    # TODO: remove break pointer
    root_tag = tree.getroot().tag
    if root_tag == 'WMT_MS_Capabilities':
        return WMS111Capabilities(tree)
    elif root_tag == '{http://www.opengis.net/wms}WMS_Capabilities':
        return WMS130Capabilities(tree)
    else:
        raise ValueError('unknown start tag in capabilities: ' + root_tag)

if __name__ == '__main__':
    import sys
    cap = parse_capabilities(sys.argv[1])
    yaml_sources(cap)
########NEW FILE########
__FILENAME__ = test_parse
import os

from ..parse import parse_capabilities

from nose.tools import eq_

def local_filename(filename):
    return os.path.join(os.path.dirname(__file__), filename)


class TestWMS111(object):
    def test_parse_metadata(self):
        cap = parse_capabilities(local_filename('wms-omniscale-111.xml'))
        md = cap.metadata()
        eq_(md['name'], 'OGC:WMS')
        eq_(md['title'], 'Omniscale OpenStreetMap WMS')
        eq_(md['access_constraints'], 'This service is intended for private and evaluation use only. The data is licensed as Creative Commons Attribution-Share Alike 2.0 (http://creativecommons.org/licenses/by-sa/2.0/)')
        eq_(md['fees'], 'none')
        eq_(md['online_resource'], 'http://omniscale.de/')
        eq_(md['abstract'], 'Omniscale OpenStreetMap WMS (powered by MapProxy)')


        eq_(md['contact']['person'], 'Oliver Tonnhofer')
        eq_(md['contact']['organization'], 'Omniscale')
        eq_(md['contact']['position'], 'Technical Director')
        eq_(md['contact']['address'], 'Nadorster Str. 60')
        eq_(md['contact']['city'], 'Oldenburg')
        eq_(md['contact']['postcode'], '26123')
        eq_(md['contact']['country'], 'Germany')
        eq_(md['contact']['phone'], '+49(0)441-9392774-0')
        eq_(md['contact']['fax'], '+49(0)441-9392774-9')
        eq_(md['contact']['email'], 'osm@omniscale.de')


    def test_parse_layer(self):
        cap = parse_capabilities(local_filename('wms-omniscale-111.xml'))
        lyrs = cap.layers_list()
        eq_(len(lyrs), 2)
        eq_(lyrs[0]['llbbox'], [-180.0, -85.0511287798, 180.0, 85.0511287798])
        eq_(lyrs[0]['srs'],
            set(['EPSG:4326', 'EPSG:4258', 'CRS:84', 'EPSG:900913', 'EPSG:31466',
                'EPSG:31467', 'EPSG:31468', 'EPSG:25831', 'EPSG:25832',
                'EPSG:25833', 'EPSG:3857',
            ])
        )
        eq_(len(lyrs[0]['bbox_srs']), 1)
        eq_(lyrs[0]['bbox_srs']['EPSG:4326'], [-180.0, -85.0511287798, 180.0, 85.0511287798])


    def test_parse_layer_2(self):
        cap = parse_capabilities(local_filename('wms-large-111.xml'))
        lyrs = cap.layers_list()
        eq_(len(lyrs), 46)
        eq_(lyrs[0]['llbbox'], [-10.4, 35.7, 43.0, 74.1])
        eq_(lyrs[0]['srs'],
            set(['EPSG:31467', 'EPSG:31466', 'EPSG:31465', 'EPSG:31464',
                'EPSG:31463', 'EPSG:31462', 'EPSG:4326', 'EPSG:31469', 'EPSG:31468',
                'EPSG:31257', 'EPSG:31287', 'EPSG:31286', 'EPSG:31285', 'EPSG:31284',
                'EPSG:31258', 'EPSG:31259', 'EPSG:31492', 'EPSG:31493', 'EPSG:25833',
                'EPSG:25832', 'EPSG:31494', 'EPSG:31495', 'EPSG:28992',
            ])
        )
        eq_(lyrs[1]['name'], 'Grenzen')
        eq_(lyrs[1]['legend']['url'],
            "http://example.org/service?SERVICE=WMS&version=1.1.1&service=WMS&request=GetLegendGraphic&layer=Grenzen&format=image/png&STYLE=default"
        )

class TestWMS130(object):
    def test_parse_metadata(self):
        cap = parse_capabilities(local_filename('wms-omniscale-130.xml'))
        md = cap.metadata()
        eq_(md['name'], 'WMS')
        eq_(md['title'], 'Omniscale OpenStreetMap WMS')

        req = cap.requests()
        eq_(req['GetMap'], 'http://osm.omniscale.net/proxy/service?')

    def test_parse_layer(self):
        cap = parse_capabilities(local_filename('wms-omniscale-130.xml'))
        lyrs = cap.layers_list()
        eq_(len(lyrs), 2)
        eq_(lyrs[0]['llbbox'], [-180.0, -85.0511287798, 180.0, 85.0511287798])
        eq_(lyrs[0]['srs'],
            set(['EPSG:4326', 'EPSG:4258', 'CRS:84', 'EPSG:900913', 'EPSG:31466',
                'EPSG:31467', 'EPSG:31468', 'EPSG:25831', 'EPSG:25832',
                'EPSG:25833', 'EPSG:3857',
            ])
        )
        eq_(len(lyrs[0]['bbox_srs']), 4)
        eq_(set(lyrs[0]['bbox_srs'].keys()), set(['CRS:84', 'EPSG:900913', 'EPSG:4326', 'EPSG:3857']))
        eq_(lyrs[0]['bbox_srs']['EPSG:3857'], [-20037508.3428, -20037508.3428, 20037508.3428, 20037508.3428])


class TestLargeWMSCapabilities(object):
    def test_parse_metadata(self):
        cap = parse_capabilities(local_filename('wms_nasa_cap.xml'))
        md = cap.metadata()
        eq_(md['name'], 'OGC:WMS')
        eq_(md['title'], 'JPL Global Imagery Service')

    def test_parse_layer(self):
        cap = parse_capabilities(local_filename('wms_nasa_cap.xml'))
        lyrs = cap.layers_list()
        eq_(len(lyrs), 15)
        eq_(len(lyrs[0]['bbox_srs']), 0)

########NEW FILE########
__FILENAME__ = test_util
from ..util import resolve_ns

from nose.tools import eq_

def test_resolve_ns():
    eq_(resolve_ns('/bar/bar', {}, None),
        '/bar/bar')

    eq_(resolve_ns('/bar/bar', {}, 'http://foo'),
        '/{http://foo}bar/{http://foo}bar')

    eq_(resolve_ns('/bar/xlink:bar', {'xlink': 'http://www.w3.org/1999/xlink'}, 'http://foo'),
        '/{http://foo}bar/{http://www.w3.org/1999/xlink}bar')

    eq_(resolve_ns('bar/xlink:bar', {'xlink': 'http://www.w3.org/1999/xlink'}, 'http://foo'),
        '{http://foo}bar/{http://www.w3.org/1999/xlink}bar')

########NEW FILE########
__FILENAME__ = util
import re

xpath_elem = re.compile('(^|/)([^/]+:)?([^/]+)')


def resolve_ns(xpath, namespaces, default=None):
    """
    Resolve namespaces in xpath to absolute URL as required by etree.
    """
    def repl(match):
        ns = match.group(2)
        if ns:
            abs_ns = namespaces.get(ns[:-1], default)
        else:
            abs_ns = default

        if not abs_ns:
            return '%s%s' % (match.group(1), match.group(3))
        else:
            return '%s{%s}%s' % (match.group(1), abs_ns, match.group(3))

    return xpath_elem.sub(repl, xpath)

########NEW FILE########
__FILENAME__ = fs
# This file is part of the MapProxy project.
# Copyright (C) 2010-2013 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
File system related utility functions.
"""
from __future__ import with_statement, absolute_import
import time
import os
import sys
import random
import errno
import shutil

def swap_dir(src_dir, dst_dir, keep_old=False, backup_ext='.tmp'):
    """
    Rename `src_dir` to `dst_dir`. The `dst_dir` is first renamed to
    `dst_dir` + `backup_ext` to keep the interruption short.
    Then the `src_dir` is renamed. If `keep_old` is False, the old content
    of `dst_dir` will be removed.
    """
    tmp_dir = dst_dir + backup_ext
    if os.path.exists(dst_dir):
        os.rename(dst_dir, tmp_dir)

    _force_rename_dir(src_dir, dst_dir)

    if os.path.exists(tmp_dir) and not keep_old:
        shutil.rmtree(tmp_dir)

def _force_rename_dir(src_dir, dst_dir):
    """
    Rename `src_dir` to `dst_dir`. If `dst_dir` exists, it will be removed.
    """
    # someone might recreate the directory between rmtree and rename,
    # so we try to remove it until we can rename our new directory
    rename_tries = 0
    while rename_tries < 10:
        try:
            os.rename(src_dir, dst_dir)
        except OSError, ex:
            if ex.errno == errno.ENOTEMPTY or ex.errno == errno.EEXIST:
                if rename_tries > 0:
                    time.sleep(2**rename_tries / 100.0) # from 10ms to 5s
                rename_tries += 1
                shutil.rmtree(dst_dir)
            else:
                raise
        else:
            break # on success

def cleanup_directory(directory, before_timestamp, remove_empty_dirs=True,
                      file_handler=None):
    if file_handler is None:
        if before_timestamp == 0 and remove_empty_dirs == True and os.path.exists(directory):
            shutil.rmtree(directory, ignore_errors=True)
            return

        file_handler = os.remove

    if os.path.exists(directory):
        for dirpath, dirnames, filenames in os.walk(directory, topdown=False):
            if not filenames:
                if (remove_empty_dirs and not os.listdir(dirpath)
                    and dirpath != directory):
                    os.rmdir(dirpath)
                continue
            for filename in filenames:
                filename = os.path.join(dirpath, filename)
                try:
                    if before_timestamp == 0:
                        file_handler(filename)
                    if os.lstat(filename).st_mtime < before_timestamp:
                        file_handler(filename)
                except OSError, ex:
                    if ex.errno != errno.ENOENT: raise

            if remove_empty_dirs:
                remove_dir_if_emtpy(dirpath)

        if remove_empty_dirs:
            remove_dir_if_emtpy(directory)

def remove_dir_if_emtpy(directory):
    try:
        os.rmdir(directory)
    except OSError, ex:
        if ex.errno != errno.ENOENT and ex.errno != errno.ENOTEMPTY: raise

def ensure_directory(file_name):
    """
    Create directory if it does not exist, else do nothing.
    """
    dir_name = os.path.dirname(file_name)
    if not os.path.exists(dir_name):
        try:
            os.makedirs(dir_name)
        except OSError, e:
            if e.errno != errno.EEXIST:
                raise e

def write_atomic(filename, data):
    """
    write_atomic writes `data` to a random file in filename's directory
    first and renames that file to the target filename afterwards.
    Rename is atomic on all POSIX platforms.

    Falls back to normal write on Windows.
    """
    if not sys.platform.startswith('win'):
        # write to random filename to prevent concurrent writes in cases
        # where file locking does not work (network fs)
        path_tmp = filename + '.tmp-' + str(random.randint(0, 99999999))
        try:
            fd = os.open(path_tmp, os.O_EXCL | os.O_CREAT | os.O_WRONLY)
            with os.fdopen(fd, 'wb') as f:
                f.write(data)
            os.rename(path_tmp, filename)
        except OSError, ex:
            try:
                os.unlink(path_tmp)
            except OSError:
                pass
            raise ex
    else:
        with open(filename, 'wb') as f:
            f.write(data)

########NEW FILE########
__FILENAME__ = geom
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import division, with_statement

import os
import codecs
from functools import partial
from contextlib import closing

import logging
log_config = logging.getLogger('mapproxy.config.coverage')

try:
    import shapely.wkt
    import shapely.geometry
    import shapely.ops
    import shapely.prepared
    geom_support = True
except ImportError:
    geom_support = False

def require_geom_support():
    if not geom_support:
        raise ImportError('Shapely required for geometry support')


def load_datasource(datasource, where=None):
    """
    Loads polygons from WKT text files or OGR datasources.

    Returns a list of Shapely Polygons.
    """
    # check if it is a  wkt file
    if os.path.exists(os.path.abspath(datasource)):
        with open(os.path.abspath(datasource), 'r') as fp:
            data = fp.read(50)
        if data.lower().lstrip().startswith(('polygon', 'multipolygon')):
            return load_polygons(datasource)

    # otherwise pass to OGR
    return load_ogr_datasource(datasource, where=where)

def load_ogr_datasource(datasource, where=None):
    """
    Loads polygons from any OGR datasource.

    Returns a list of Shapely Polygons.
    """
    from mapproxy.util.ogr import OGRShapeReader

    polygons = []
    with closing(OGRShapeReader(datasource)) as reader:
        for wkt in reader.wkts(where):
            geom = shapely.wkt.loads(wkt)
            if geom.type == 'Polygon':
                polygons.append(geom)
            elif geom.type == 'MultiPolygon':
                for p in geom:
                    polygons.append(p)
            else:
                log_config.warn('skipping %s geometry from %s: not a Polygon/MultiPolygon',
                    geom.type, datasource)

    return polygons

def load_polygons(geom_files):
    """
    Loads WKT polygons from one or more text files.

    Returns a list of Shapely Polygons.
    """
    polygons = []
    if isinstance(geom_files, basestring):
        geom_files = [geom_files]

    for geom_file in geom_files:
        # open with utf-8-sig encoding to get rid of UTF8 BOM from MS Notepad
        with codecs.open(geom_file, encoding='utf-8-sig') as f:
            polygons.extend(load_polygon_lines(f, source=geom_files))

    return polygons

def load_polygon_lines(line_iter, source='<string>'):
    polygons = []
    for line in line_iter:
        if not line.strip():
            continue
        geom = shapely.wkt.loads(line)
        if geom.type == 'Polygon':
            polygons.append(geom)
        elif geom.type == 'MultiPolygon':
            for p in geom:
                polygons.append(p)
        else:
            log_config.warn('ignoring non-polygon geometry (%s) from %s',
                geom.type, source)

    return polygons

def build_multipolygon(polygons, simplify=False):
    if not polygons:
        p = shapely.geometry.Polygon()
        return p.bounds, p

    if len(polygons) == 1:
        geom = polygons[0]
        if simplify:
            geom = simplify_geom(geom)
        return geom.bounds, geom

    mp = shapely.geometry.MultiPolygon(polygons)

    if simplify:
        mp = simplify_geom(mp)

    # eliminate any self-intersections
    mp = shapely.ops.cascaded_union(mp)

    return mp.bounds, mp

def simplify_geom(geom):
    bounds = geom.bounds
    w, h = bounds[2] - bounds[0], bounds[3] - bounds[1]
    tolerance = min((w/1e6, h/1e6))
    return geom.simplify(tolerance, preserve_topology=True)

def bbox_polygon(bbox):
    """
    Create Polygon that covers the given bbox.
    """
    return shapely.geometry.Polygon((
        (bbox[0], bbox[1]),
        (bbox[2], bbox[1]),
        (bbox[2], bbox[3]),
        (bbox[0], bbox[3]),
        ))

def transform_geometry(from_srs, to_srs, geometry):
    transf = partial(transform_xy, from_srs, to_srs)

    if geometry.type == 'Polygon':
        return transform_polygon(transf, geometry)

    if geometry.type == 'MultiPolygon':
        return transform_multipolygon(transf, geometry)

    raise ValueError('cannot transform %s' % geometry.type)

def transform_polygon(transf, polygon):
    ext = transf(polygon.exterior.xy)
    ints = [transf(ring.xy) for ring in polygon.interiors]
    return shapely.geometry.Polygon(ext, ints)

def transform_multipolygon(transf, multipolygon):
    transformed_polygons = []
    for polygon in multipolygon:
        transformed_polygons.append(transform_polygon(transf, polygon))
    return shapely.geometry.MultiPolygon(transformed_polygons)

def transform_xy(from_srs, to_srs, xy):
    return list(from_srs.transform_to(to_srs, zip(*xy)))

def flatten_to_polygons(geometry):
    """
    Return a list of all polygons of this (multi)`geometry`.
    """
    if geometry.type == 'Polygon':
        return [geometry]

    if geometry.type == 'MultiPolygon':
        return list(geometry)

    if hasattr(geometry, 'geoms'):
        # GeometryCollection or MultiLineString? return list of all polygons
        geoms = []
        for part in geometry.geoms:
            if part.type == 'Polygon':
                geoms.append(part)

        if geoms:
            return geoms

    return []



########NEW FILE########
__FILENAME__ = lib
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
ctypes utilities.
"""

import sys
import os

from ctypes import CDLL
from ctypes.util import find_library as _find_library


default_locations = dict(
    darwin=dict(
        paths = ['/opt/local/lib'],
        exts = ['.dylib'],
    ),
    win32=dict(
        paths = [os.path.dirname(os.__file__) + '/../../../DLLs'],
        exts = ['.dll']
    ),
    other=dict(
        paths = [], # MAPPROXY_LIB_PATH will add paths here
        exts = ['.so']
    ),
)

additional_lib_path = os.environ.get('MAPPROXY_LIB_PATH')
if additional_lib_path:
    additional_lib_path = additional_lib_path.split(os.pathsep)
    additional_lib_path.reverse()
    for locs in default_locations.values():
        for path in additional_lib_path:
            locs['paths'].insert(0, path)

def load_library(lib_names, locations_conf=default_locations):
    """
    Load the `lib_name` library with ctypes.
    If ctypes.util.find_library does not find the library,
    different path and filename extensions will be tried.
    
    Retruns the loaded library or None.
    """
    if isinstance(lib_names, basestring):
        lib_names = [lib_names]
    
    for lib_name in lib_names:
        lib = load_library_(lib_name, locations_conf)
        if lib is not None: return lib

def load_library_(lib_name, locations_conf=default_locations):
    lib_path = find_library(lib_name)
    
    if lib_path:
        return CDLL(lib_path)
    
    if sys.platform in locations_conf:
        paths = locations_conf[sys.platform]['paths']
        exts = locations_conf[sys.platform]['exts']
        lib_path = find_library(lib_name, paths, exts)
    else:
        paths = locations_conf['other']['paths']
        exts = locations_conf['other']['exts']
        lib_path = find_library(lib_name, paths, exts)
    
    if lib_path:
        return CDLL(lib_path)
        

def find_library(lib_name, paths=None, exts=None):
    """
    Search for library in all permutations of `paths` and `exts`.
    If nothing is found None is returned.
    """
    if not paths or not exts:
        lib = _find_library(lib_name)
        if lib is None and lib_name.startswith('lib'):
            lib = _find_library(lib_name[3:])
        return lib
    
    for lib_name in [lib_name] + ([lib_name[3:]] if lib_name.startswith('lib') else []):
        for path in paths:
            for ext in exts:
                lib_path = os.path.join(path, lib_name + ext)
                if os.path.exists(lib_path):
                    return lib_path
    
    return None

if __name__ == '__main__':
    print load_library(sys.argv[1])

########NEW FILE########
__FILENAME__ = lock
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from mapproxy.util.ext.lockfile import LockFile
from mapproxy.platform.lock import LockTimeout, FileLock, LockError, cleanup_lockdir

__all__ = ['LockTimeout', 'FileLock', 'LockError', 'cleanup_lockdir', 'SemLock']

import random

class SemLock(FileLock):
    """
    File-lock-based counting semaphore (i.e. this lock can be locked n-times).
    """
    def __init__(self, lock_file, n, timeout=60.0, step=0.01):
        FileLock.__init__(self, lock_file, timeout=timeout, step=step)
        self.n = n
    
    def _try_lock(self):
        tries = 0
        i = random.randint(0, self.n-1)
        while True:
            tries += 1
            try:
                return LockFile(self.lock_file + str(i))
            except LockError:
                if tries >= self.n:
                    raise
            i = (i+1) % self.n

class DummyLock(object):
    def __enter__(self):
        pass
    def __exit__(self, _exc_type, _exc_value, _traceback):
        pass
    def lock(self):
        pass
    def unlock(self):
        pass

########NEW FILE########
__FILENAME__ = ogr
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import sys
from mapproxy.util.lib import load_library
import ctypes
from ctypes import c_void_p, c_char_p, c_int

def init_libgdal():
    libgdal = load_library(['libgdal', 'libgdal1', 'gdal110', 'gdal19', 'gdal18', 'gdal17'])

    if not libgdal: return

    libgdal.OGROpen.argtypes = [c_char_p, c_int, c_void_p]
    libgdal.OGROpen.restype = c_void_p

    # CPLGetLastErrorMsg is not part of the official and gets
    # name mangled on Windows builds. try to support _Foo@0
    # mangling, otherwise print no detailed errors
    if not hasattr(libgdal, 'CPLGetLastErrorMsg') and hasattr(libgdal, '_CPLGetLastErrorMsg@0'):
        libgdal.CPLGetLastErrorMsg = getattr(libgdal, '_CPLGetLastErrorMsg@0')

    if hasattr(libgdal, 'CPLGetLastErrorMsg'):
        libgdal.CPLGetLastErrorMsg.argtypes	= []
        libgdal.CPLGetLastErrorMsg.restype = c_char_p
    else:
        libgdal.CPLGetLastErrorMsg = None

    libgdal.OGR_DS_GetLayer.argtypes = [c_void_p, c_int]
    libgdal.OGR_DS_GetLayer.restype = c_void_p

    libgdal.OGR_FD_GetName.argtypes = [c_void_p]
    libgdal.OGR_FD_GetName.restype = c_char_p

    libgdal.OGR_L_GetLayerDefn.argtypes = [c_void_p]
    libgdal.OGR_L_GetLayerDefn.restype = c_void_p

    libgdal.OGR_DS_Destroy.argtypes = [c_void_p]

    libgdal.OGR_DS_ExecuteSQL.argtypes = [c_void_p, c_char_p, c_void_p, c_char_p]
    libgdal.OGR_DS_ExecuteSQL.restype = c_void_p
    libgdal.OGR_DS_ReleaseResultSet.argtypes = [c_void_p, c_void_p]

    libgdal.OGR_L_ResetReading.argtypes = [c_void_p]
    libgdal.OGR_L_GetNextFeature.argtypes = [c_void_p]
    libgdal.OGR_L_GetNextFeature.restype = c_void_p

    libgdal.OGR_F_Destroy.argtypes = [c_void_p]

    libgdal.OGR_F_GetGeometryRef.argtypes = [c_void_p]
    libgdal.OGR_F_GetGeometryRef.restype = c_void_p

    libgdal.OGR_G_ExportToWkt.argtypes = [c_void_p, ctypes.POINTER(c_char_p)]
    libgdal.OGR_G_ExportToWkt.restype = c_void_p

    libgdal.VSIFree.argtypes = [c_void_p]

    libgdal.OGRRegisterAll()

    return libgdal

class OGRShapeReaderError(Exception):
    pass

class CtypesOGRShapeReader(object):
    def __init__(self, datasource):
        self.datasource = datasource
        self._ds = None

    def open(self):
        if self._ds: return
        self._ds = libgdal.OGROpen(self.datasource, False, None)
        if self._ds is None:
            msg = None
            if libgdal.CPLGetLastErrorMsg:
                msg = libgdal.CPLGetLastErrorMsg()
            if not msg:
                msg = 'failed to open %s' % self.datasource
            raise OGRShapeReaderError(msg)

    def wkts(self, where=None):
        if not self._ds: self.open()

        if where:
            if not where.lower().startswith('select'):
                layer = libgdal.OGR_DS_GetLayer(self._ds, 0)
                layer_def = libgdal.OGR_L_GetLayerDefn(layer)
                name = libgdal.OGR_FD_GetName(layer_def)
                where = 'select * from %s where %s' % (name, where)
            layer = libgdal.OGR_DS_ExecuteSQL(self._ds, where, None, None)
        else:
            layer = libgdal.OGR_DS_GetLayer(self._ds, 0)
        if layer is None:
            msg = None
            if libgdal.CPLGetLastErrorMsg:
                msg = libgdal.CPLGetLastErrorMsg()
            raise OGRShapeReaderError(msg)

        libgdal.OGR_L_ResetReading(layer)
        while True:
            feature = libgdal.OGR_L_GetNextFeature(layer)
            if feature is None:
                break
            geom = libgdal.OGR_F_GetGeometryRef(feature)
            res = c_char_p()
            libgdal.OGR_G_ExportToWkt(geom, ctypes.byref(res))
            yield res.value
            libgdal.VSIFree(res)
            libgdal.OGR_F_Destroy(feature)

        if where:
            libgdal.OGR_DS_ReleaseResultSet(self._ds, layer)

    def close(self):
        if self._ds:
            libgdal.OGR_DS_Destroy(self._ds)
            self._ds = None

    def __del__(self):
        self.close()


class OSGeoOGRShapeReader(object):
    def __init__(self, datasource):
        self.datasource = datasource
        self._ds = None

    def open(self):
        if self._ds: return
        self._ds = ogr.Open(self.datasource, False)
        if self._ds is None:
            msg = gdal.GetLastErrorMsg()
            if not msg:
                msg = 'failed to open %s' % self.datasource
            raise OGRShapeReaderError(msg)

    def wkts(self, where=None):
        if not self._ds: self.open()

        if where:
            if not where.lower().startswith('select'):
                layer = self._ds.GetLayerByIndex(0)
                name = layer.GetName()
                where = 'select * from %s where %s' % (name, where)
            layer = self._ds.ExecuteSQL(where)
        else:
            layer = self._ds.GetLayerByIndex(0)
        if layer is None:
            msg = gdal.GetLastErrorMsg()
            raise OGRShapeReaderError(msg)

        layer.ResetReading()
        while True:
            feature = layer.GetNextFeature()
            if feature is None:
                break
            geom = feature.geometry()
            yield geom.ExportToWkt()

    def close(self):
        if self._ds:
            self._ds = None


ogr = gdal = None
def try_osgeoogr_import():
    global ogr, gdal
    try:
        from osgeo import ogr; ogr
        from osgeo import gdal; gdal
    except ImportError:
        return
    return OSGeoOGRShapeReader

libgdal = None
def try_libogr_import():
    global libgdal
    libgdal = init_libgdal()
    if libgdal is not None:
        return CtypesOGRShapeReader

ogr_imports = []
if 'MAPPROXY_USE_OSGEOOGR' in os.environ:
    ogr_imports = [try_osgeoogr_import]

if 'MAPPROXY_USE_LIBOGR' in os.environ:
    ogr_imports = [try_libogr_import]

if not ogr_imports:
    if sys.platform == 'win32':
        # prefer osgeo.ogr on windows
        ogr_imports = [try_osgeoogr_import, try_libogr_import]
    else:
        ogr_imports = [try_libogr_import, try_osgeoogr_import]

for try_import in ogr_imports:
    res = try_import()
    if res:
        OGRShapeReader = res
        break
else:
    raise ImportError('could not find osgeo.ogr package or libgdal')


if __name__ == '__main__':
    import sys
    reader = OGRShapeReader(sys.argv[1])
    where = None
    if len(sys.argv) == 3:
        where = sys.argv[2]
    for wkt in reader.wkts(where):
        print wkt

########NEW FILE########
__FILENAME__ = py
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Python related helper functions.
"""
from __future__ import with_statement
from functools import wraps

def reraise_exception(new_exc, exc_info):
    """
    Reraise exception (`new_exc`) with the given `exc_info`.
    """
    _exc_class, _exc, tb = exc_info
    raise new_exc.__class__, new_exc, tb

class cached_property(object):
    """A decorator that converts a function into a lazy property. The
    function wrapped is called the first time to retrieve the result
    and than that calculated result is used the next time you access
    the value::

        class Foo(object):

            @cached_property
            def foo(self):
                # calculate something important here
                return 42
    """

    def __init__(self, func, name=None, doc=None):
        self.func = func
        self.__name__ = name or func.__name__
        self.__doc__ = doc or func.__doc__

    def __get__(self, obj, type=None):
        if obj is None:
            return self
        value = self.func(obj)
        setattr(obj, self.__name__, value)
        return value

def memoize(func):
    @wraps(func)
    def wrapper(self, *args):
        if not hasattr(self, '__memoize_cache'):
            self.__memoize_cache = {}
        cache = self.__memoize_cache.setdefault(func, {})
        if args not in cache:
            cache[args] = func(self, *args)
        return cache[args]
    return wrapper

def replace_instancemethod(old_method, new_method):
    """
    Replace an instance method.

    >>> class Foo(object):
    ...    val = 'bar'
    ...    def bar(self):
    ...        return self.val
    >>> f = Foo()
    >>> f.bar()
    'bar'
    >>> replace_instancemethod(f.bar, lambda self: 'foo' + self.val)
    >>> f.bar()
    'foobar'
    """
    cls = old_method.im_class
    obj = old_method.im_self
    name = old_method.im_func.func_name
    instancemethod = type(old_method)
    setattr(obj, name, instancemethod(new_method, obj, cls))


########NEW FILE########
__FILENAME__ = times
# This file is part of the MapProxy project.
# Copyright (C) 2010-213 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from __future__ import absolute_import

"""
Date and time utilities.
"""
from time import mktime
import datetime
import calendar
from email.utils import parsedate
from wsgiref.handlers import format_date_time

def parse_httpdate(date):
    date = parsedate(date)
    if date is None:
        return None
    if date[0] < 1970:
        date = (date[0] + 2000,) +date[1:]
    return calendar.timegm(date)

def timestamp(date):
    if isinstance(date, datetime.datetime):
        date = mktime(date.timetuple())
    assert isinstance(date, (float, int, long))
    return date

def format_httpdate(date):
    date = timestamp(date)
    return format_date_time(date)


def timestamp_before(weeks=0, days=0, hours=0, minutes=0, seconds=0):
    """
    >>> import time as time_
    >>> time_.time() - timestamp_before(minutes=1) - 60 <= 1
    True
    >>> time_.time() - timestamp_before(days=1, minutes=2) - 86520 <= 1
    True
    >>> time_.time() - timestamp_before(hours=2) - 7200 <= 1
    True
    """
    delta = datetime.timedelta(weeks=weeks, days=days, hours=hours, minutes=minutes, seconds=seconds)
    before = datetime.datetime.now() - delta
    return mktime(before.timetuple())

def timestamp_from_isodate(isodate):
    """
    >>> ts = timestamp_from_isodate('2009-06-09T10:57:00')
    >>> # we don't know which timezone the test will run
    >>> (1244537820.0 - 14 * 3600) < ts < (1244537820.0 + 14 * 3600)
    True
    >>> timestamp_from_isodate('2009-06-09T10:57') #doctest: +ELLIPSIS
    Traceback (most recent call last):
    ...
    ValueError: ...
    """
    if isinstance(isodate, datetime.datetime):
        date = isodate
    else:
        date = datetime.datetime.strptime(isodate, "%Y-%m-%dT%H:%M:%S")
    return mktime(date.timetuple())
########NEW FILE########
__FILENAME__ = wsgi
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
WSGI utils
"""

def lighttpd_root_fix_filter_factory(global_conf):
    return LighttpdCGIRootFix

class LighttpdCGIRootFix(object):
    """Wrap the application in this middleware if you are using lighttpd
    with FastCGI or CGI and the application is mounted on the URL root.

    :param app: the WSGI application
    """

    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        script_name = environ.get('SCRIPT_NAME', '')
        path_info = environ.get('PATH_INFO', '')
        if path_info == script_name:
            environ['PATH_INFO'] = path_info
        else:
            environ['PATH_INFO'] = script_name + path_info
        environ['SCRIPT_NAME'] = ''
        return self.app(environ, start_response)

########NEW FILE########
__FILENAME__ = yaml
# This file is part of the MapProxy project.
# Copyright (C) 2011 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement, absolute_import
import yaml


class YAMLError(Exception):
    pass

def load_yaml_file(file_or_filename):
    """
    Load yaml from file object or filename.
    """
    if isinstance(file_or_filename, basestring):
        with open(file_or_filename) as f:
            return load_yaml(f)
    return load_yaml(file_or_filename)

def load_yaml(doc):
    """
    Load yaml from file object or string.
    """
    try:
        if getattr(yaml, '__with_libyaml__', False):
            try:
                return yaml.load(doc, Loader=yaml.CLoader)
            except AttributeError:
                # handle cases where __with_libyaml__ is True but
                # CLoader doesn't work (missing .dispose())
                return yaml.load(doc)
        return yaml.load(doc)
    except (yaml.scanner.ScannerError, yaml.parser.ParserError), ex:
        raise YAMLError(str(ex))


########NEW FILE########
__FILENAME__ = version
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pkg_resources

def version_string():
    """
    Return the current version number of MapProxy.
    """
    try:
        return pkg_resources.working_set.by_key['mapproxy'].version
    except KeyError:
        return 'unknown_version'

__version__ = version = version_string()

if __name__ == '__main__':
    print __version__
########NEW FILE########
__FILENAME__ = wsgiapp
# This file is part of the MapProxy project.
# Copyright (C) 2010 Omniscale <http://omniscale.de>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
The WSGI application.
"""
from __future__ import with_statement
import re
import os
import sys
import time
import threading
import warnings

from mapproxy.request import Request
from mapproxy.response import Response
from mapproxy.config import local_base_config
from mapproxy.config.loader import load_configuration, ConfigurationError

import logging
log = logging.getLogger('mapproxy.config')
log_wsgiapp = logging.getLogger('mapproxy.wsgiapp')

def app_factory(global_options, mapproxy_conf, **local_options):
    """
    Paster app_factory.
    """
    conf = global_options.copy()
    conf.update(local_options)
    log_conf = conf.get('log_conf', None)
    reload_files = conf.get('reload_files', None)
    if reload_files is not None:
        init_paster_reload_files(reload_files)

    init_logging_system(log_conf, os.path.dirname(mapproxy_conf))

    return make_wsgi_app(mapproxy_conf)

def init_paster_reload_files(reload_files):
    file_patterns = reload_files.split('\n')
    file_patterns.append(os.path.join(os.path.dirname(__file__), 'defaults.yaml'))
    init_paster_file_watcher(file_patterns)

def init_paster_file_watcher(file_patterns):
    from glob import glob
    for pattern in file_patterns:
        files = glob(pattern)
        _add_files_to_paster_file_watcher(files)

def _add_files_to_paster_file_watcher(files):
    import paste.reloader
    for file in files:
        paste.reloader.watch_file(file)

def init_logging_system(log_conf, base_dir):
    import logging.config
    try:
        import cloghandler # adds CRFHandler to log handlers
        cloghandler.ConcurrentRotatingFileHandler #disable pyflakes warning
    except ImportError:
        pass
    if log_conf:
        if not os.path.exists(log_conf):
            print >>sys.stderr, 'ERROR: log configuration %s not found.' % log_conf
            return
        logging.config.fileConfig(log_conf, dict(here=base_dir))

def init_null_logging():
    import logging
    class NullHandler(logging.Handler):
        def emit(self, record):
            pass
    logging.getLogger().addHandler(NullHandler())

def make_wsgi_app(services_conf=None, debug=False, ignore_config_warnings=True, reloader=False):
    """
    Create a MapProxyApp with the given services conf.

    :param services_conf: the file name of the mapproxy.yaml configuration
    :param reloader: reload mapproxy.yaml when it changed
    """

    if sys.version_info[0] == 2 and sys.version_info[1] == 5:
        warnings.warn('Support for Python 2.5 is deprecated since 1.7.0 and will be dropped with 1.8.0', FutureWarning)

    if reloader:
        make_app = lambda: make_wsgi_app(services_conf=services_conf, debug=debug,
            reloader=False)
        return ReloaderApp(services_conf, make_app)

    try:
        conf = load_configuration(mapproxy_conf=services_conf, ignore_warnings=ignore_config_warnings)
        services = conf.configured_services()
    except ConfigurationError, e:
        log.fatal(e)
        raise

    config_files = conf.config_files()

    app = MapProxyApp(services, conf.base_config)
    if debug:
        app = wrap_wsgi_debug(app, conf)

    app.config_files = config_files
    return app

class ReloaderApp(object):
    def __init__(self, timestamp_file, make_app_func):
        self.timestamp_file = timestamp_file
        self.make_app_func = make_app_func
        self.app = make_app_func()
        self._app_init_lock = threading.Lock()

    def _needs_reload(self):
        for conf_file, timestamp in self.app.config_files.iteritems():
            m_time = os.path.getmtime(conf_file)
            if m_time > timestamp:
                return True
        return False

    def __call__(self, environ, start_response):
        if self._needs_reload():
            with self._app_init_lock:
                if self._needs_reload():
                    try:
                        self.app = self.make_app_func()
                    except ConfigurationError:
                        pass
                    self.last_reload = time.time()

        return self.app(environ, start_response)

def wrap_wsgi_debug(app, conf):
    conf.base_config.debug_mode = True
    try:
        from werkzeug.debug import DebuggedApplication
        app = DebuggedApplication(app, evalex=True)
    except ImportError:
        try:
            from paste.evalexception.middleware import EvalException
            app = EvalException(app)
        except ImportError:
            print 'Error: Install Werkzeug or Paste for browser-based debugging.'

    return app

class MapProxyApp(object):
    """
    The MapProxy WSGI application.
    """
    handler_path_re = re.compile('^/(\w+)')
    def __init__(self, services, base_config):
        self.handlers = {}
        self.base_config = base_config
        for service in services:
            for name in service.names:
                self.handlers[name] = service

    def __call__(self, environ, start_response):
        resp = None
        req = Request(environ)

        with local_base_config(self.base_config):
            match = self.handler_path_re.match(req.path)
            if match:
                handler_name = match.group(1)
                if handler_name in self.handlers:
                    try:
                        resp = self.handlers[handler_name].handle(req)
                    except Exception, ex:
                        if self.base_config.debug_mode:
                            raise
                        else:
                            log_wsgiapp.fatal('fatal error in %s for %s %s',
                                handler_name, environ.get('PATH_INFO'), environ.get('QUERY_STRING'), exc_info=True)
                            import traceback
                            traceback.print_exc(file=environ['wsgi.errors'])
                            resp = Response('internal error', status=500)
            if resp is None:
                if req.path in ('', '/'):
                    resp = self.welcome_response(req.script_url)
                else:
                    resp = Response('not found', mimetype='text/plain', status=404)
            return resp(environ, start_response)

    def welcome_response(self, script_url):
        import mapproxy.version
        html = "<html><body><h1>Welcome to MapProxy %s</h1>" % mapproxy.version.version
        if 'demo' in self.handlers:
            html += '<p>See all configured layers and services at: <a href="%s/demo/">demo</a>' % (script_url, )
        return Response(html, mimetype='text/html')

########NEW FILE########
__FILENAME__ = release
try:
    from nose.plugins.skip import SkipTest
    import sys
    if 'nosetest' in ''.join(sys.argv):
        raise SkipTest()
except ImportError:
    pass

import scriptine
from scriptine import path
from scriptine.shell import backtick_, sh

PACKAGE_NAME = 'MapProxy'
REMOTE_DOC_LOCATION = 'omniscale.de:domains/mapproxy.org/docs'
REMOTE_REL_LOCATION = 'omniscale.de:domains/mapproxy.org/static/rel'

VERSION_FILES = [
    ('setup.py', 'version="###"'),
    ('doc/conf.py', "version = '##'"),
    ('doc/conf.py', "release = '###'"),
]

def version_command():
    print version()

def prepare_command(tag=""):
    sh('python setup.py egg_info -D -b "%s"' % tag)

def version():
    package_name = PACKAGE_NAME
    version = backtick_('grep Version: %(package_name)s.egg-info/PKG-INFO' % locals())
    version = version.split(':')[-1].strip()
    return version

def clean_all_command():
    path('build/').rmtree(ignore_errors=True)
    for pyc in path.cwd().walkfiles('*.pyc'):
        pyc.remove()

def bump_version_command(version):
    short_version = '.'.join(version.split('.')[:2])
    for filename, replace in VERSION_FILES:
        if '###' in replace:
            search_for = replace.replace('###', '[^\'"]+')
            replace_with = replace.replace('###', version)
        else:
            search_for = replace.replace('##', '[^\'"]+')
            replace_with = replace.replace('##', short_version)

        search_for = search_for.replace('"', '\\"')
        replace_with = replace_with.replace('"', '\\"')
        sh('''perl -p -i -e "s/%(search_for)s/%(replace_with)s/" %(filename)s ''' % locals())

    prepare_command()

def build_docs_command():
    sh('python setup.py build_sphinx')
    ver = version()
    package_name = PACKAGE_NAME
    sh("tar -c -v -z -C build/sphinx/ -f dist/%(package_name)s-docs-%(ver)s.tar.gz -s "
       "'/^html/%(package_name)s-docs-%(ver)s/' html"
        % locals())

def upload_docs_command():
    ver = version()
    remote_doc_location = REMOTE_DOC_LOCATION
    sh('rsync -a -v -P -z build/sphinx/html/ %(remote_doc_location)s/%(ver)s' % locals())

def build_sdist_command():
    sh('python setup.py egg_info -b "" -D sdist')

def upload_sdist_command():
    sh('python setup.py egg_info -b "" -D sdist')
    ver = version()
    remote_rel_location = REMOTE_REL_LOCATION
    sh('scp dist/MapProxy-%(ver)s.* %(remote_rel_location)s' % locals())

def upload_final_sdist_command():
    sh('python setup.py egg_info -b "" -D sdist upload')

def register_command():
    sh('python setup.py egg_info -b "" -D register')

def link_latest_command(ver=None):
    if ver is None:
        ver = version()
    host, path = REMOTE_DOC_LOCATION.split(':')
    sh('ssh %(host)s "cd %(path)s && rm latest && ln -s %(ver)s latest"' % locals())


def update_deb_command():
    import email.utils
    import time
    changelog_entry_template = """mapproxy (%(version)s) unstable; urgency=low

  * New upstream release.

 -- %(user)s <%(email)s>  %(time)s

"""
    with open('debian/changelog') as f:
        old_changelog = f.read()

    changelog = changelog_entry_template % {
        'version': version(),
        'user': backtick_('git config --get user.name').strip(),
        'email': backtick_('git config --get user.email').strip(),
        'time': email.utils.formatdate(time.time(), True),
    }
    changelog += old_changelog
    with open('debian/changelog', 'w') as f:
        f.write(changelog)

if __name__ == '__main__':
    scriptine.run()

########NEW FILE########
