__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# MongoKit documentation build configuration file, created by
# sphinx-quickstart on Sat Sep 26 17:03:11 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.coverage', 'sphinxtogithub']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.txt'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'MongoKit'
copyright = u'2009-2012, Nicolas Clairon'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.8'
# The full version, including alpha/beta/rc tags.
release = '0.8.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'sphinxdoc'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = False

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'MongoKitdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'MongoKit.tex', u'MongoKit Documentation',
   u'Namlook', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True
#html_theme = "agogo"
#html_theme_path = ["_theme"]

########NEW FILE########
__FILENAME__ = auth
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from mongokit import Document
import hashlib
import os


class User(Document):
    structure = {
        "_id": unicode,
        "user": {
            "login": unicode,
            "password": unicode,  # TODO validator
            "email": unicode,
        }
    }
    required_fields = ['user.password', 'user.email']  # what if openid ? password is None

    def set_login(self, login):
        self['_id'] = login
        self['user']['login'] = login

    def get_login(self):
        return self['_id']

    def del_login(self):
        self['_id'] = None
        self['user']['login'] = None

    login = property(get_login, set_login, del_login)

    def set_password(self, password):
        """ Hash password on the fly """
        if isinstance(password, unicode):
            password = password.encode('utf-8')
        password_salt = hashlib.sha1(os.urandom(60)).hexdigest()
        crypt = hashlib.sha1(password + password_salt).hexdigest()
        self['user']['password'] = unicode(password_salt + crypt, 'utf-8')

    def get_password(self):
        """ Return the password hashed """
        return self['user']['password']

    def del_password(self):
        self['user']['password'] = None

    password = property(get_password, set_password, del_password)

    def verify_password(self, password):
        """ Check the password against existing credentials  """
        if isinstance(password, unicode):
            password = password.encode('utf-8')
        password_salt = self['user']['password'][:40]
        crypt_pass = hashlib.sha1(password + password_salt).hexdigest()
        if crypt_pass == self['user']['password'][40:]:
            return True
        else:
            return False

    def get_email(self):
        return self['user']['email']

    def set_email(self, email):
        # TODO check if it's a well formatted email
        self['user']['email'] = email

    def del_email(self):
        self['user']['email'] = None

    email = property(get_email, set_email, del_email)

    def save(self, *args, **kwargs):
        assert self['_id'] == self['user']['login']
        super(User, self).save(*args, **kwargs)

########NEW FILE########
__FILENAME__ = collection
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from pymongo.collection import Collection as PymongoCollection
from mongo_exceptions import MultipleResultsFound
from cursor import Cursor

from warnings import warn


class Collection(PymongoCollection):

    def __init__(self, *args, **kwargs):
        self._documents = {}
        self._collections = {}
        super(Collection, self).__init__(*args, **kwargs)
        self._registered_documents = self.database.connection._registered_documents

    def __getattr__(self, key):
        if key in self._registered_documents:
            if not key in self._documents:
                self._documents[key] = self._registered_documents[key](collection=self)
                if hasattr(self._documents[key], "i18n") and self._documents[key].i18n:
                    # It seems that if we want i18n, we have to call twice the constructor.
                    # Why on earth ? I don't know and I don't have the time to investigate yet.
                    self._documents[key]()
                if self._documents[key].indexes:
                    warn('%s: Be careful, index generation is not automatic anymore.'
                         'You have to generate your index youself' % self._documents[key]._obj_class.__name__,
                         DeprecationWarning)
                #self._documents[key].generate_index(self)
            return self._documents[key]
        else:
            newkey = u"%s.%s" % (self.name, key)
            if not newkey in self._collections:
                self._collections[newkey] = Collection(self.database, newkey)
            return self._collections[newkey]

    def __call__(self, *args, **kwargs):
        if "." not in self.__name:
            raise TypeError("'Collection' object is not callable. If you "
                            "meant to call the '%s' method on a 'Database' "
                            "object it is failing because no such method "
                            "exists." %
                            self.__name)
        name = self.__name.split(".")[-1]
        raise TypeError("'Collection' object is not callable. "
                        "If you meant to call the '%s' method on a 'Collection' "
                        "object it is failing because no such method exists.\n"
                        "If '%s' is a Document then you may have forgotten to "
                        "register it to the connection." % (name, name))

    def find(self, *args, **kwargs):
        if not 'slave_okay' in kwargs and hasattr(self, 'slave_okay'):
            kwargs['slave_okay'] = self.slave_okay
        if not 'read_preference' in kwargs and hasattr(self, 'read_preference'):
            kwargs['read_preference'] = self.read_preference
        if not 'tag_sets' in kwargs and hasattr(self, 'tag_sets'):
            kwargs['tag_sets'] = self.tag_sets
        if not 'secondary_acceptable_latency_ms' in kwargs and\
                hasattr(self, 'secondary_acceptable_latency_ms'):
            kwargs['secondary_acceptable_latency_ms'] = (
                self.secondary_acceptable_latency_ms
            )
        return Cursor(self, *args, **kwargs)
    find.__doc__ = PymongoCollection.find.__doc__ + """
        added by mongokit::
            - `wrap` (optional): a class object used to wrap
            documents in the query result
    """

    def find_and_modify(self, *args, **kwargs):
        obj_class = kwargs.pop('wrap', None)
        doc = super(Collection, self).find_and_modify(*args, **kwargs)
        if doc and obj_class:
            return self.collection[obj_class.__name__](doc)
        return doc
    find_and_modify.__doc__ = PymongoCollection.find_and_modify.__doc__ + """
        added by mongokit::
             - `wrap` (optional): a class object used to wrap
             documents in the query result
     """

    def get_from_id(self, id):
        """
        return the document which has the id
        """
        return self.find_one({"_id": id})

    def one(self, *args, **kwargs):
        bson_obj = self.find(*args, **kwargs)
        count = bson_obj.count()
        if count > 1:
            raise MultipleResultsFound("%s results found" % count)
        elif count == 1:
            return bson_obj.next()

    def find_random(self):
        """
        return one random document from the collection
        """
        import random
        max = self.count()
        if max:
            num = random.randint(0, max-1)
            return self.find().skip(num).next()

    def find_fulltext(self, search, **kwargs):
        """
        Executes a full-text search. Additional parameters may be passed as keyword arguments.
        """
        return self.database.command("text", self.name, search=search, **kwargs)

########NEW FILE########
__FILENAME__ = connection
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

try:
    from pymongo import MongoClient as PymongoConnection
    from pymongo import MongoReplicaSetClient as PymongoReplicaSetConnection
except ImportError:
    from pymongo import Connection as PymongoConnection
from database import Database


class CallableMixin(object):
    """
    brings the callable method to a Document. usefull for the connection's
    register method
    """
    def __call__(self, doc=None, gen_skel=True, lang='en', fallback_lang='en'):
        return self._obj_class(
            doc=doc,
            gen_skel=gen_skel,
            collection=self.collection,
            lang=lang,
            fallback_lang=fallback_lang
        )

_iterables = (list, tuple, set, frozenset)


class MongoKitConnection(object):

    def __init__(self, *args, **kwargs):
        self._databases = {}
        self._registered_documents = {}

    def register(self, obj_list):
        decorator = None
        if not isinstance(obj_list, _iterables):
            # we assume that the user used this as a decorator
            # using @register syntax or using conn.register(SomeDoc)
            # we stock the class object in order to return it later
            decorator = obj_list
            obj_list = [obj_list]
        # cleanup
        for dbname, db in self._databases.items():
            for colname, col in db._collections.items():
                for docname, doc in col._documents.items():
                    del col._documents[docname]
                for obj_name in [obj.__name__ for obj in obj_list]:
                    if obj_name in col._registered_documents:
                        del col._registered_documents[obj_name]
        # register
        for obj in obj_list:
            CallableDocument = type(
                "Callable%s" % obj.__name__,
                (obj, CallableMixin),
                {"_obj_class": obj, "__repr__": object.__repr__}
            )
            self._registered_documents[obj.__name__] = CallableDocument
        # if the class object is stored, it means the user used a decorator and
        # we must return the class object
        if decorator is not None:
            return decorator

    def __getattr__(self, key):
        if key in self._registered_documents:
            document = self._registered_documents[key]
            try:
                return getattr(self[document.__database__][document.__collection__], key)
            except AttributeError:
                raise AttributeError("%s: __collection__ attribute not found. "
                                     "You cannot specify the `__database__` attribute without "
                                     "the `__collection__` attribute" % key)
        else:
            if key not in self._databases:
                self._databases[key] = Database(self, key)
            return self._databases[key]


class Connection(MongoKitConnection, PymongoConnection):
    def __init__(self, *args, **kwargs):
        # Specifying that it should run both the inits
        MongoKitConnection.__init__(self, *args, **kwargs)
        PymongoConnection.__init__(self, *args, **kwargs)


class ReplicaSetConnection(MongoKitConnection, PymongoReplicaSetConnection):
    def __init__(self, *args, **kwargs):
        # Specifying that it should run both the inits
        MongoKitConnection.__init__(self, *args, **kwargs)
        PymongoReplicaSetConnection.__init__(self, *args, **kwargs)

MongoClient = Connection
MongoReplicaSetClient = ReplicaSetConnection

########NEW FILE########
__FILENAME__ = cursor
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from pymongo.cursor import Cursor as PymongoCursor
from collections import deque


class Cursor(PymongoCursor):
    def __init__(self, *args, **kwargs):
        self.__wrap = None
        if kwargs:
            self.__wrap = kwargs.pop('wrap', None)
        super(Cursor, self).__init__(*args, **kwargs)

    def next(self):
        if self._Cursor__empty:
            raise StopIteration
        if len(self.__data) or self._refresh():
            if isinstance(self._Cursor__data, deque):
                item = self._Cursor__data.popleft()
            else:
                item = self._Cursor__data.pop(0)

            return self.__manipulate_item(item)

        else:
            raise StopIteration

    def __getitem__(self, index):
        # This will be a cursor if `index` is a slice
        item_or_cursor = super(Cursor, self).__getitem__(index)

        if isinstance(item_or_cursor, dict):
            return self.__manipulate_item(item_or_cursor)
        else:
            return item_or_cursor

    def __manipulate_item(self, item):
        if self._Cursor__manipulate:
            db = self._Cursor__collection.database
            son = db._fix_outgoing(item, self._Cursor__collection)
        else:
            son = item
        if self.__wrap is not None:
            if self.__wrap.type_field in son:
                return getattr(self._Cursor__collection,
                               son[self.__wrap.type_field])(son)
            return self.__wrap(son, collection=self._Cursor__collection)
        else:
            return son

########NEW FILE########
__FILENAME__ = database
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from pymongo.database import Database as PymongoDatabase
from bson.dbref import DBRef
from mongokit.document import Document
from collection import Collection


class Database(PymongoDatabase):

    def __init__(self, *args, **kwargs):
        self._collections = {}
        super(Database, self).__init__(*args, **kwargs)

    def __getattr__(self, key):
        if key in self.connection._registered_documents:
            document = self.connection._registered_documents[key]
            return getattr(self[document.__collection__], key)
        else:
            if not key in self._collections:
                self._collections[key] = Collection(self, key)
            return self._collections[key]

    def dereference(self, dbref, model=None):
        if model is None:
            return super(Database, self).dereference(dbref)
        if not isinstance(dbref, DBRef):
            raise TypeError("first argument must be a DBRef")
        if dbref.database is not None and dbref.database != self.name:
            raise ValueError("trying to dereference a DBRef that points to "
                             "another database (%r not %r)" % (dbref.database, self._Database__name))
        if not issubclass(model, Document):
            raise TypeError("second argument must be a Document")
        return getattr(self[dbref.collection], model.__name__).one({'_id': dbref.id})

########NEW FILE########
__FILENAME__ = document
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from mongokit import SchemaDocument, AutoReferenceError
from mongokit.mongo_exceptions import *
from mongokit.schema_document import (
    STRUCTURE_KEYWORDS,
    CustomType,
    SchemaTypeError,
    SchemaProperties,
    StructureError)
from mongokit.helpers import (
    totimestamp,
    fromtimestamp,
    DotedDict)
from mongokit.grid import *
import pymongo
from bson import BSON
from bson.binary import Binary
from bson.code import Code
from bson.dbref import DBRef
from bson.objectid import ObjectId
import re
from copy import deepcopy
from uuid import UUID, uuid4
import logging
import datetime

STRUCTURE_KEYWORDS += ['_id', '_ns', '_revision', '_version']

log = logging.getLogger(__name__)


class DocumentProperties(SchemaProperties):
    def __new__(cls, name, bases, attrs):
        for base in bases:
            parent = base.__mro__[0]
            if hasattr(parent, 'structure'):
                if parent.structure is not None:
                    #parent = parent()
                    if parent.indexes:
                        if 'indexes' not in attrs:
                            attrs['indexes'] = []
                        for index in attrs['indexes']+parent.indexes:
                            if index not in attrs['indexes']:
                                attrs['indexes'].append(index)
        return SchemaProperties.__new__(cls, name, bases, attrs)

    @classmethod
    def _validate_descriptors(cls, attrs):
        SchemaProperties._validate_descriptors(attrs)
        # validate index descriptor
        if attrs.get('migration_handler') and attrs.get('use_schemaless'):
            raise OptionConflictError('You cannot set a migration_handler with use_schemaless set to True')
        if attrs.get('indexes'):
            for index in attrs['indexes']:
                if index.get('check', True):
                    if 'fields' not in index:
                        raise BadIndexError(
                            "'fields' key must be specify in indexes")
                    for key, value in index.iteritems():
                        if key == "fields":
                            if isinstance(value, basestring):
                                if value not in attrs['_namespaces'] and value not in STRUCTURE_KEYWORDS:
                                    raise ValueError(
                                        "Error in indexes: can't find %s in structure" % value)
                            elif isinstance(value, tuple):
                                if len(value) != 2:
                                    raise BadIndexError(
                                        "Error in indexes: a tuple must contain "
                                        "only two value : the field name and the direction")
                                if not (isinstance(value[1], int) or isinstance(value[1], basestring)):
                                    raise BadIndexError(
                                        "Error in %s, the direction must be int or basestring "
                                        "(got %s instead)" % (value[0], type(value[1])))
                                if not isinstance(value[0], basestring):
                                    raise BadIndexError(
                                        "Error in %s, the field name must be string "
                                        "(got %s instead)" % (value[0], type(value[0])))
                                if value[0] not in attrs['_namespaces'] and value[0] not in STRUCTURE_KEYWORDS:
                                    raise ValueError(
                                        "Error in indexes: can't find %s in structure" % value[0])
                                if not value[1] in [pymongo.DESCENDING, pymongo.ASCENDING, pymongo.OFF, pymongo.ALL,
                                                    pymongo.GEO2D, pymongo.GEOHAYSTACK, pymongo.GEOSPHERE,
                                                    pymongo.HASHED, "text"]:
                                    raise BadIndexError(
                                        "index direction must be INDEX_DESCENDING, INDEX_ASCENDING, "
                                        "INDEX_OFF, INDEX_ALL, INDEX_GEO2D, INDEX_GEOHAYSTACK, "
                                        "or INDEX_GEOSPHERE. Got %s" % value[1])  # Omit text because it's still beta
                            elif isinstance(value, list):
                                for val in value:
                                    if isinstance(val, tuple):
                                        field, direction = val
                                        if field not in attrs['_namespaces'] and field not in STRUCTURE_KEYWORDS:
                                            raise ValueError(
                                                "Error in indexes: can't find %s in structure" % field)
                                        if not direction in [pymongo.DESCENDING, pymongo.ASCENDING, pymongo.OFF,
                                                             pymongo.ALL, pymongo.GEO2D, pymongo.GEOHAYSTACK,
                                                             pymongo.GEOSPHERE, "text"]:
                                            raise BadIndexError(
                                                "index direction must be INDEX_DESCENDING, INDEX_ASCENDING, INDEX_OFF, "
                                                "INDEX_ALL, INDEX_GEO2D, INDEX_GEOHAYSTACK, or INDEX_GEOSPHERE."
                                                " Got %s" % direction)  # Omit text because it's still beta
                                    else:
                                        if val not in attrs['_namespaces'] and val not in STRUCTURE_KEYWORDS:
                                            raise ValueError("Error in indexes: can't find %s in structure" % val)
                            else:
                                raise BadIndexError("fields must be a string, a tuple or a list of tuple "
                                                    "(got %s instead)" % type(value))
                        elif key == "ttl":
                            assert isinstance(value, int)


class Document(SchemaDocument):

    __metaclass__ = DocumentProperties

    type_field = '_type'

    atomic_save = False  # XXX Deprecated
    skip_validation = False
    use_autorefs = False
    force_autorefs_current_db = False
    indexes = []
    gridfs = []
    migration_handler = None

    authorized_types = SchemaDocument.authorized_types + [
        Binary,
        ObjectId,
        DBRef,
        Code,
        UUID,
        type(re.compile("")),
    ]

    def __init__(self, doc=None, gen_skel=True, collection=None, lang='en', fallback_lang='en'):
        self._authorized_types = self.authorized_types[:]
        # If using autorefs, we need another authorized
        if self.use_autorefs:
            self._authorized_types += [Document, SchemaProperties]
        super(Document, self).__init__(doc=doc, gen_skel=gen_skel, gen_auth_types=False,
                                       lang=lang, fallback_lang=fallback_lang)
        if self.type_field in self:
            self[self.type_field] = unicode(self.__class__.__name__)
        # collection
        self.collection = collection
        if collection:
            self.db = collection.database
            self.connection = self.db.connection
            # indexing all embed doc if any (autorefs feature)
            self._dbrefs = {}
            if self.use_autorefs and collection:
                self._make_reference(self, self.structure)
            # gridfs
            if self.gridfs:
                self.fs = FS(self)
        else:
            self.fs = None
        if self.migration_handler:
            self.skip_validation = False
            self._migration = self.migration_handler(self.__class__)
            if self.get('_id'):
                Document.validate(self, auto_migrate=True)
        if self.atomic_save is True:
            raise DeprecationWarning('atomic_save is not supported anymore. Please update you code')

    def migrate(self, safe=True, _process_to_bson=True):
        """
        migrate the document following the migration_handler rules

        safe : if True perform a safe update (see pymongo documentation for more details
        """
        self._migrate(safe=safe)

    def _migrate(self, safe=True, process_to_bson=True):
        if process_to_bson:
            self._process_custom_type('bson', self, self.structure)
        self._migration.migrate(self, safe=safe)
        # reload
        old_doc = self.collection.get_from_id(self['_id'])
        if not old_doc:
            raise OperationFailure('Can not reload an unsaved document.'
                                   ' %s is not found in the database' % self['_id'])
        else:
            self.update(DotedDict(old_doc))
        self._process_custom_type('python', self, self.structure)

    def _get_size_limit(self):
        server_version = tuple(self.connection.server_info()['version'].split("."))
        mongo_1_8 = tuple("1.8.0".split("."))

        if server_version < mongo_1_8:
            return (3999999, '4MB')
        else:
            return (15999999, '16MB')

    def validate(self, auto_migrate=False):
        if self.use_autorefs:
            if not auto_migrate:
                # don't make reference if auto_migrate is True because this
                # mean validate was called from __init__ and no collection is
                # found when validating at __init__ with autorefs
                self._make_reference(self, self.structure)
        size = self.get_size()
        (size_limit, size_limit_str) = self._get_size_limit()

        if size > size_limit:
            raise MaxDocumentSizeError("The document size is too big, documents "
                                       "lower than %s is allowed (got %s bytes)" % (size_limit_str, size))
        if auto_migrate:
            error = None
            try:
                super(Document, self).validate()
            except StructureError, e:
                error = e
            except KeyError, e:
                error = e
            except SchemaTypeError, e:
                error = e
            if error:
                if not self.migration_handler:
                    raise StructureError(str(error))
                else:
                    # if we are here that's becose super.validate failed
                    # but it has processed custom type to bson.
                    self._migrate(process_to_bson=False)
        else:
            super(Document, self).validate()

    def get_size(self):
        """
        return the size of the underlying bson object
        """
        try:
            size = len(BSON.encode(self))
        except:
            self._process_custom_type('bson', self, self.structure)
            size = len(BSON.encode(self))
            self._process_custom_type('python', self, self.structure)
        return size

    def find(self, *args, **kwargs):
        """
        Query the database.

        The `spec` argument is a prototype document that all results must
        match. For example if self si called MyDoc:

        >>> mydocs = db.test.MyDoc.find({"hello": "world"})

        only matches documents that have a key "hello" with value "world".
        Matches can have other keys *in addition* to "hello". The `fields`
        argument is used to specify a subset of fields that should be included
        in the result documents. By limiting results to a certain subset of
        fields you can cut down on network traffic and decoding time.

        `mydocs` is a cursor which yield MyDoc object instances.

        See pymongo's documentation for more details on arguments.
        """
        return self.collection.find(wrap=self._obj_class, *args, **kwargs)

    def find_and_modify(self, *args, **kwargs):
        """
        Update and return an object.
        """
        return self.collection.find_and_modify(wrap=self._obj_class, *args, **kwargs)

    def find_one(self, *args, **kwargs):
        """
        Get the first object found from the database.

        See pymongo's documentation for more details on arguments.
        """
        return self.collection.find_one(wrap=self._obj_class, *args, **kwargs)

    def one(self, *args, **kwargs):
        """
        `one()` act like `find()` but will raise a
        `mongokit.MultipleResultsFound` exception if there is more than one
        result.

        If no document is found, `one()` returns `None`
        """
        bson_obj = self.find(*args, **kwargs)
        count = bson_obj.count()
        if count > 1:
            raise MultipleResultsFound("%s results found" % count)
        elif count == 1:
            try:
                doc = bson_obj.next()
            except StopIteration:
                doc = None
            return doc

    def find_random(self):
        """
        return one random document from the collection
        """
        import random
        max = self.collection.count()
        if max:
            num = random.randint(0, max-1)
            return self.find().skip(num).next()

    def find_fulltext(self, search, **kwargs):
        """
        Executes a full-text search. Additional parameters may be passed as keyword arguments.
        """
        rv = self.collection.database.command("text", self.collection.name, search=search, **kwargs)
        if 'results' in rv:
            for res in rv['results']:
                res['obj'] = self._obj_class(res['obj'])
        return rv

    def get_from_id(self, id):
        """
        return the document which has the id
        """
        return self.find_one({"_id": id})

    def fetch(self, spec=None, *args, **kwargs):
        """
        return all document which match the structure of the object
        `fetch()` takes the same arguments than the the pymongo.collection.find method.

        The query is launch against the db and collection of the object.
        """
        if spec is None:
            spec = {}
        for key in self.structure:
            if key in spec:
                if isinstance(spec[key], dict):
                    spec[key].update({'$exists': True})
            else:
                spec[key] = {'$exists': True}
        return self.find(spec, *args, **kwargs)

    def fetch_one(self, *args, **kwargs):
        """
        return one document which match the structure of the object
        `fetch_one()` takes the same arguments than the the pymongo.collection.find method.

        If multiple documents are found, raise a MultipleResultsFound exception.
        If no document is found, return None

        The query is launch against the db and collection of the object.
        """
        bson_obj = self.fetch(*args, **kwargs)
        count = bson_obj.count()
        if count > 1:
            raise MultipleResultsFound("%s results found" % count)
        elif count == 1:
            return bson_obj.next()

    def reload(self):
        """
        allow to refresh the document, so after using update(), it could reload
        its value from the database.

        Be careful : reload() will erase all unsaved values.

        If no _id is set in the document, a KeyError is raised.
        """
        self._process_custom_type('bson', self, self.structure)
        old_doc = self.collection.get_from_id(self['_id'])
        if not old_doc:
            raise OperationFailure('Can not reload an unsaved document.'
                                   ' %s is not found in the database' % self['_id'])
        else:
            self.update(DotedDict(old_doc))
        self._process_custom_type('python', self, self.structure)

    def get_dbref(self):
        """
        return a pymongo DBRef instance related to the document
        """
        assert '_id' in self, "You must specify an '_id' for using this method"
        return DBRef(database=self.db.name, collection=self.collection.name, id=self['_id'])

    def save(self, uuid=False, validate=None, safe=True, *args, **kwargs):
        """
        save the document into the db.

        if uuid is True, a uuid4 will be automatically generated
        else, the bson.ObjectId will be used.

        If validate is True, the `validate` method will be called before
        saving. Not that the `validate` method will be called *before* the
        uuid is generated.

        `save()` follow the pymongo.collection.save arguments
        """
        if validate is True or (validate is None and self.skip_validation is False):
            self.validate(auto_migrate=False)
        else:
            if self.use_autorefs:
                self._make_reference(self, self.structure)
        if '_id' not in self:
            if uuid:
                self['_id'] = unicode("%s-%s" % (self.__class__.__name__, uuid4()))
        self._process_custom_type('bson', self, self.structure)
        self.collection.save(self, safe=safe, *args, **kwargs)
        self._process_custom_type('python', self, self.structure)

    def delete(self):
        """
        delete the document from the collection from his _id.
        """
        self.collection.remove({'_id': self['_id']})

    @classmethod
    def generate_index(cls, collection):
        """generate indexes from ``indexes`` class-attribute

        supports additional index-creation-keywords supported by pymongos ``ensure_index``.
        """
        # creating index if needed
        for index in deepcopy(cls.indexes):
            unique = False
            if 'unique' in index:
                unique = index.pop('unique')
            ttl = 300
            if 'ttl' in index:
                ttl = index.pop('ttl')

            given_fields = index.pop("fields", list())

            if isinstance(given_fields, tuple):
                fields = [given_fields]
            elif isinstance(given_fields, basestring):
                fields = [(given_fields, 1)]
            else:
                fields = []
                for field in given_fields:
                    if isinstance(field, basestring):
                        field = (field, 1)
                    fields.append(field)
            log.debug('Creating index for %s' % str(given_fields))
            collection.ensure_index(fields, unique=unique, ttl=ttl, **index)

    def to_json_type(self):
        """
        convert all document field into json type
        and return the new converted object
        """
        def _convert_to_json(struct, doc):
            """
            convert all datetime to a timestamp from epoch
            """
            if struct is not None:
                for key in struct:
                    if isinstance(struct[key], datetime.datetime):
                        struct[key] = totimestamp(struct[key])
                    elif isinstance(struct[key], ObjectId):
                        #struct[key] = str(struct[key])
                        struct[key] = {'$oid': str(struct[key])}
                    elif isinstance(struct[key], dict):
                        _convert_to_json(struct[key], doc)
                    elif isinstance(struct[key], list) and len(struct[key]):
                        if isinstance(struct[key][0], dict):
                            for obj in struct[key]:
                                _convert_to_json(obj, doc)
                        elif isinstance(struct[key][0], datetime.datetime):
                            struct[key] = [totimestamp(obj) for obj in struct[key]]
                        elif isinstance(struct[key][0], ObjectId):
                            #struct[key] = [str(obj) for obj in struct[key]]
                            struct[key] = [{'$oid': str(obj)} for obj in struct[key]]
        # we don't want to touch our document so we create another object
        self._process_custom_type('bson', self, self.structure)
        obj = deepcopy(self)
        self._process_custom_type('python', self, self.structure)
        _convert_to_json(obj, obj)
        if '_id' in obj:
            if isinstance(obj['_id'], ObjectId):
                obj['_id'] = {'$oid': str(obj['_id'])}
        return obj

    def to_json(self):
        """
        convert the document into a json string and return it
        """
        def _convert_to_python(doc, struct):
            for key in struct:
                if isinstance(struct[key], dict):
                    if doc:  # we don't need to process an empty doc
                        if key in doc:  # we don't care about missing fields
                            _convert_to_python(doc[key], struct[key])
                elif type(struct[key]) is list:
                    if struct[key]:
                        if isinstance(struct[key][0], R):
                            l_objs = []
                            for obj in doc[key]:
                                obj['_collection'] = self.collection.name
                                obj['_database'] = self.db.name
                                l_objs.append(obj)
                            doc[key] = l_objs
                        elif isinstance(struct[key][0], dict):
                            if doc[key]:
                                for obj in doc[key]:
                                    _convert_to_python(obj, struct[key][0])
                else:
                    if isinstance(struct[key], R) and doc[key] is not None:
                        doc[key]['_collection'] = self.collection.name
                        doc[key]['_database'] = self.db.name
        try:
            from json import dumps
        except ImportError:
            from anyjson import serialize as dumps
        except ImportError:
            raise ImportError("can't import anyjson. Please install it before continuing.")
        obj = self.to_json_type()
        _convert_to_python(obj, self.structure)
        return unicode(dumps(obj))

    def from_json(self, json):
        """
        convert a json string and return a SchemaDocument
        """
        def _convert_to_python(doc, struct, path="", root_path=""):
            for key in struct:
                if type(key) is type:
                    new_key = '$%s' % key.__name__
                else:
                    new_key = key
                new_path = ".".join([path, new_key]).strip('.')
                if isinstance(struct[key], dict):
                    if doc:  # we don't need to process an empty doc
                        if key in doc:  # we don't care about missing fields
                            _convert_to_python(doc[key], struct[key], new_path, root_path)
                elif type(struct[key]) is list:
                    if struct[key]:
                        if struct[key][0] is datetime.datetime:
                            l_objs = []
                            for obj in doc[key]:
                                obj = fromtimestamp(obj)
                                l_objs.append(obj)
                            doc[key] = l_objs
                        elif isinstance(struct[key][0], R):
                            l_objs = []
                            for obj in doc[key]:
                                db = obj.get('_database') or obj.get('$db')
                                col = obj.get('_collection') or obj.get('$ref')
                                if '_id' in obj:
                                    id_ref = '_id'
                                    if '$oid' in obj['_id']:
                                        obj['_id'] = ObjectId(obj['_id']['$oid'])
                                elif '$id' in obj:
                                    id_ref = '$id'
                                obj_class = struct[key][0]._doc
                                _id = obj[id_ref]
                                obj = getattr(self.connection[db][col], obj_class.__name__).one({'_id': _id})
                                #obj = struct[key][0]._doc(obj, collection=self.connection[db][col]).get_dbref()
                                l_objs.append(obj)
                            doc[key] = l_objs
                        elif isinstance(struct[key][0], dict):
                            if doc[key]:
                                for obj in doc[key]:
                                    _convert_to_python(obj, struct[key][0], new_path, root_path)
                elif struct[key] is datetime.datetime and doc[key] is not None:
                    doc[key] = fromtimestamp(doc[key])
                elif (isinstance(struct[key], R) or isinstance(struct[key],
                                                               DocumentProperties)) and doc[key] is not None:
                    db = doc[key].get('_database') or doc[key].get('$db')
                    col = doc[key].get('_collection') or doc[key].get('$ref')
                    if '_id' in doc[key]:
                        id_ref = '_id'
                    elif '$id' in doc[key]:
                        id_ref = '$id'
                    if '$oid' in doc[key][id_ref]:
                        doc[key][id_ref] = ObjectId(doc[key][id_ref]['$oid'])
                    if isinstance(struct[key], R):
                        obj_class = struct[key]._doc
                    else:
                        obj_class = struct[key]
                    #_id = obj_class(doc[key], collection=self.connection[db][col])[id_ref]
                    _id = doc[key][id_ref]
                    doc[key] = getattr(self.connection[db][col], obj_class.__name__).one({'_id': _id})
        try:
            from json import loads
        except ImportError:
            from anyjson import deserialize as loads
        except ImportError:
            raise ImportError("can't import anyjson. Please install it before continuing.")
        obj = loads(json)
        _convert_to_python(obj, self.structure)
        if '_id' in obj:
            if '$oid' in obj['_id']:
                obj['_id'] = ObjectId(obj['_id']['$oid'])
        return self._obj_class(obj, collection=self.collection)

    #
    # End of public API
    #

    def __hash__(self):
        if '_id' in self:
            value = self['_id']
            return value.__hash__()
        else:
            raise TypeError("A Document is not hashable if it is not saved. Save the document before hashing it")

    def __deepcopy__(self, memo={}):
        obj = self.__class__(doc=deepcopy(dict(self), memo), gen_skel=False, collection=self.collection)
        obj.__dict__ = self.__dict__.copy()
        return obj

    def __getattribute__(self, key):
        if key in ['collection', 'db', 'connection']:
            if self.__dict__.get(key) is None:
                raise ConnectionError('No collection found')
        return super(Document, self).__getattribute__(key)

    def _make_reference(self, doc, struct, path=""):
        """
        * wrap all MongoDocument with the CustomType "R()"
        * create the list of Reference in self._dbrefs
        * track the embed doc changes and save it when self.save() is called
        """
        for key in struct:
            new_key = key
            new_path = ".".join([path, new_key]).strip('.')
            #
            # if the value is a dict, we have a another structure to validate
            #
            if isinstance(struct[key], SchemaProperties) or isinstance(struct[key], R):
                # if struct[key] is a MongoDocument, so we have to convert it into the
                # CustomType : R
                if not isinstance(struct[key], R):
                    db_name = None
                    if self.force_autorefs_current_db:
                        db_name = self.db.name
                    struct[key] = R(struct[key], self.connection, db_name)
                # if we have DBRef into the document we have to call
                # _process_custom_type another time.
                if isinstance(doc[key], DBRef):
                    # XXX check this
                    if doc[key].database:
                        db = doc[key].database
                    else:
                        db = self.db.name
                    col = doc[key].collection
                    _id = doc[key].id
                    obj_class = struct[key]._doc
                    doc[key] = getattr(self.connection[db][col], obj_class.__name__).one({'_id': _id})
                    #doc._process_custom_type('python', doc, doc.structure)
                # be sure that we have an instance of MongoDocument
                if not isinstance(doc[key], struct[key]._doc) and doc[key] is not None:
                    self._raise_exception(SchemaTypeError, new_path, "%s must be an instance of %s not %s" % (
                        new_path, struct[key]._doc.__name__, type(doc[key]).__name__))
                # validate the embed doc
                if not self.skip_validation and doc[key] is not None:
                    doc[key].validate()
                # if we didn't index the embed obj yet, well, we do it
                if new_path not in self._dbrefs:
                    if doc[key]:
                        self._dbrefs[new_path] = deepcopy(dict(doc[key]))
                    else:
                        self._dbrefs[new_path] = None
                else:
                    # if the embed doc indexed was None but not the new embed one,
                    # we update the index
                    if self._dbrefs[new_path] is None and doc[key] is not None:
                        doc[key].save()
                        self._dbrefs[new_path] = doc[key]
                    # if the embed obj is already indexed, we check is the
                    # one we get has not changed. If so, we save the embed
                    # obj and update the reference
                    elif self._dbrefs[new_path] != doc[key] and doc[key] is not None:
                        doc[key].save()
                        self._dbrefs[new_path].update(doc[key])
            elif isinstance(struct[key], dict):
                #
                # if the dict is still empty into the document we build
                # it with None values
                #
                if len(struct[key]) and \
                        not [i for i in struct[key].keys() if type(i) is type]:
                    if key in doc:
                        self._make_reference(doc[key], struct[key], new_path)
                else:  # case {unicode:int}
                    pass
            elif isinstance(struct[key], list) and len(struct[key]):
                if isinstance(struct[key][0], SchemaProperties) or isinstance(struct[key][0], R):
                    if not isinstance(struct[key][0], R):
                        db_name = None
                        if self.force_autorefs_current_db:
                            db_name = self.db.name
                        struct[key][0] = R(struct[key][0], self.connection, db_name)
                    l_objs = []
                    for no, obj in enumerate(doc[key]):
                        if isinstance(obj, DBRef):
                            obj = getattr(self.connection[obj.database][obj.collection],
                                          struct[key][0]._doc.__name__).get_from_id(obj.id)
                        if not isinstance(obj, struct[key][0]._doc) and obj is not None:
                            self._raise_exception(SchemaTypeError, new_path, "%s must be an instance of Document "
                                                                             "not %s" % (new_path, type(obj).__name__))
                        full_new_path = "%s.%s" % (new_path, no)
                        # validate the embed doc
                        if not self.skip_validation:
                            obj.validate()
                        # if we didn't index the embed obj yet, well, we do it
                        if full_new_path not in self._dbrefs:
                            self._dbrefs[full_new_path] = obj
                        else:
                            # if the embed obj is already indexed, we check is the
                            # one we get has not changed. If so, we save the embed
                            # obj and update the reference
                            if self._dbrefs[full_new_path]['_id'] == obj['_id'] and self._dbrefs[full_new_path] != obj:
                                obj.save()
                                self._dbrefs[full_new_path].update(obj)
                        l_objs.append(obj)
                        doc[key] = l_objs
                elif isinstance(struct[key][0], dict):
                    for no, obj in enumerate(doc[key]):
                        self._make_reference(obj, struct[key][0], "%s.%s" % (new_path, no))


class R(CustomType):
    """ CustomType to deal with autorefs documents """
    mongo_type = DBRef
    python_type = Document

    def __init__(self, doc, connection, fallback_database=None):
        super(R, self).__init__()
        self._doc = doc
        self._fallback_database = fallback_database
        self.connection = connection

    def to_bson(self, value):
        if value is not None:
            return DBRef(database=value.db.name, collection=value.collection.name, id=value['_id'])

    def to_python(self, value):
        if value is not None:
            if not isinstance(value, DBRef):
                if '$ref' not in value:
                    value = value.get_dbref()
                else:
                    value = DBRef(database=value.get('$db'), collection=value['$ref'], id=value['$id'])
            if value.database:
                database = value.database
            else:
                database = self._fallback_database
            if database is None:
                raise RuntimeError("It appears that you try to use autorefs. I found a DBRef without"
                                   " database specified.\n If you do want to use the current database, you"
                                   " have to add the attribute `force_autorefs_current_db` as True. Please see the doc"
                                   " for more details.\n The DBRef without database is : %s " % value)
            col = self.connection[database][value.collection]
            doc = col.find_one({'_id': value.id})
            if doc is None:
                raise AutoReferenceError('Something wrong append. You probably change'
                                         ' your object when passing it as a value to an autorefs enable document.\n'
                                         'A document with id "%s" is not saved in the database "%s" but was giving as'
                                         ' a reference to a %s document' % (value.id, database, self._doc.__name__))
            return self._doc(doc, collection=col)

########NEW FILE########
__FILENAME__ = grid
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from gridfs import GridFS, NoFile, GridOut
from pymongo import ASCENDING, DESCENDING

#try:
#    from magic import Magic
#except:
#    Magic = None


class FS(GridFS):
    def __init__(self, obj):
        self._obj = obj
        super(FS, self).__init__(obj.db)
        if not isinstance(self, FSContainer):
            for container in obj.gridfs.get('containers', []):
                self.__dict__[container] = FSContainer(container, obj)
        #self._fs = GridFS(self._obj.db)
        #if Magic:
        #    self._magic = Magic(mime=True)

    def _get_spec(self, **kwargs):
        if not self._obj.get('_id'):
            raise RuntimeError('This document is not saved, no files should be attached')
        spec = {'docid': self._obj['_id']}
        spec.update(kwargs)
        return spec

    def __getitem__(self, key):
        if not self._obj.get('_id'):
            raise RuntimeError('This document is not saved, no files should be attached')
        return self.get_last_version(key).read()

    def __setitem__(self, key, value):
        content_type = None
        #if value and Magic:
        #    content_type = self._magic.from_buffer(value)
        spec = self._get_spec(filename=key, content_type=content_type)
        try:
            self.put(value, **spec)
        except TypeError:
            raise TypeError("GridFS value mus be string not %s" % type(value))

    def __getattr__(self, key):
        if not key.startswith('_'):
            if key not in self._obj.gridfs.get('containers', []) and key in self._obj.gridfs.get('files', []):
                return self[key]
        return super(FS, self).__getattribute__(key)

    def __setattr__(self, key, value):
        if not key.startswith('_'):
            if key not in self._obj.gridfs.get('containers', []) and key in self._obj.gridfs.get('files', []):
                self[key] = value
        else:
            super(FS, self).__setattr__(key, value)

    def __delitem__(self, key):
        self._GridFS__files.remove(self._get_spec(filename=key))

    def __delattr__(self, key):
        if not key.startswith('_'):
            del self[key]
        else:
            super(FS, self).__delattr__(key)

    def __iter__(self):
        if self._obj.get('_id'):
            for metafile in self._GridFS__files.find(self._get_spec()):
                yield self.get(metafile['_id'])

    def __repr__(self):
        return "<%s of object '%s'>" % (self.__class__.__name__, self._obj.__class__.__name__)

    def new_file(self, filename):
        return super(FS, self).new_file(**self._get_spec(filename=filename))

    def put(self, data, **kwargs):
        return super(FS, self).put(data, **self._get_spec(**kwargs))

    def get_version(self, filename, version=-1, **kwargs):
        """Get a file from GridFS by ``"filename"`` or metadata fields.

        Returns a version of the file in GridFS whose filename matches
        `filename` and whose metadata fields match the supplied keyword
        arguments, as an instance of :class:`~gridfs.grid_file.GridOut`.

        Version numbering is a convenience atop the GridFS API provided
        by MongoDB. If more than one file matches the query (either by
        `filename` alone, by metadata fields, or by a combination of
        both), then version ``-1`` will be the most recently uploaded
        matching file, ``-2`` the second most recently
        uploaded, etc. Version ``0`` will be the first version
        uploaded, ``1`` the second version, etc. So if three versions
        have been uploaded, then version ``0`` is the same as version
        ``-3``, version ``1`` is the same as version ``-2``, and
        version ``2`` is the same as version ``-1``.

        Raises :class:`~gridfs.errors.NoFile` if no such version of
        that file exists.

        An index on ``{filename: 1, uploadDate: -1}`` will
        automatically be created when this method is called the first
        time.

        :Parameters:
          - `filename`: ``"filename"`` of the file to get, or `None`
          - `version` (optional): version of the file to get (defaults
            to -1, the most recent version uploaded)
          - `**kwargs` (optional): find files by custom metadata.

        .. versionchanged:: 1.11
           `filename` defaults to None;
        .. versionadded:: 1.11
           Accept keyword arguments to find files by custom metadata.
        .. versionadded:: 1.9
        """
        # This is took from pymongo source. We need to go a little deeper here
        self._GridFS__files.ensure_index([("filename", ASCENDING),
                                          ("uploadDate", DESCENDING)])
        ########## Begin of MongoKit hack ##########
        cursor = self._GridFS__files.find(self._get_spec(filename=filename, **kwargs))
        ########## end of MongoKit hack ############
        if version < 0:
            skip = abs(version) - 1
            cursor.limit(-1).skip(skip).sort("uploadDate", DESCENDING)
        else:
            cursor.limit(-1).skip(version).sort("uploadDate", ASCENDING)
        try:
            grid_file = cursor.next()
            return GridOut(self._GridFS__collection, grid_file["_id"])
        except StopIteration:
            raise NoFile("no version %d for filename %r" % (version, filename))


class FSContainer(FS):
    def __init__(self, container_name, obj):
        self._container_name = container_name
        super(FSContainer, self).__init__(obj)

    def _get_spec(self, **kwargs):
        if not self._obj.get('_id'):
            raise RuntimeError('This document is not saved, no files should be attached')
        spec = {'container': self._container_name, 'docid': self._obj['_id']}
        spec.update(kwargs)
        return spec

    def __repr__(self):
        return "<%s (%s) of object '%s'>" % (self.__class__.__name__,
                                             self._container_name, self._obj.__class__.__name__)

########NEW FILE########
__FILENAME__ = helpers
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import datetime
import logging
log = logging.getLogger(__name__)


def totimestamp(value):
    """
    convert a datetime into a float since epoch
    """
    import calendar
    return int(calendar.timegm(value.timetuple()) * 1000 + value.microsecond / 1000)


def fromtimestamp(epoch_date):
    """
    convert a float since epoch to a datetime object
    """
    seconds = float(epoch_date) / 1000.0
    return datetime.datetime.utcfromtimestamp(seconds)

from copy import deepcopy


class i18nDotedDict(dict):
    """
    Dot notation dictionary access with i18n support
    """
    def __init__(self, dic, doc):
        super(i18nDotedDict, self).__init__(dic)
        self._doc = doc

    def __setattr__(self, key, value):
        from mongokit.schema_document import i18n
        if key in self:
            if isinstance(self[key], i18n):
                self[key][self._doc._current_lang] = value
            else:
                self[key] = value
        else:
            dict.__setattr__(self, key, value)

    def __getattr__(self, key):
        from mongokit.schema_document import i18n
        if key in self:
            if isinstance(self[key], i18n):
                if self._doc._current_lang not in self[key]:
                    return self[key].get(self._doc._fallback_lang)
                return self[key][self._doc._current_lang]
            return self[key]
        else:
            return super(i18nDotedDict, self).__getattribute__(key)

    def __deepcopy__(self, memo={}):
        obj = dict(self)
        return deepcopy(obj, memo)

    def __getstate__(self):
        return self.__dict__

    def __setstate__(self, d):
        self.__dict__.update(d)


class DotedDict(dict):
    """
    Dot notation dictionary access
    """
    def __init__(self, doc=None, warning=False):
        self._dot_notation_warning = warning
        if doc is None:
            doc = {}
        super(DotedDict, self).__init__(doc)
        self.__dotify_dict(self)

    def __dotify_dict(self, doc):
        for k, v in doc.iteritems():
            if isinstance(v, dict):
                doc[k] = DotedDict(v)
                self.__dotify_dict(v)

    def __setattr__(self, key, value):
        if key in self:
            self[key] = value
        else:
            # Check for '_' should be first, coz we want to set protected attrs in __init__ without recursion, i.e. _dot_notation_warning
            if not key.startswith('_') and self._dot_notation_warning and\
               key not in ['db', 'collection', 'versioning_collection', 'connection', 'fs']:
                log.warning("dot notation: %s was not found in structure. Add it as attribute instead" % key)
            dict.__setattr__(self, key, value)

    def __getattr__(self, key):
        if key in self:
            return self[key]
        else:
            # kindof bulletproof
            if key.startswith('_'):
                return super(DotedDict, self).__getattribute__(key)
            else:
                raise AttributeError('Not such attribute {0}'.format(key))

    def __deepcopy__(self, memo={}):
        obj = dict(self)
        return deepcopy(obj, memo)

    def __getstate__(self):
        return self.__dict__

    def __setstate__(self, d):
        self.__dict__.update(d)


class EvalException(Exception):
    pass


class DotExpandedDict(dict):
    """
    A special dictionary constructor that takes a dictionary in which the keys
    may contain dots to specify inner dictionaries. It's confusing, but this
    example should make sense.

    >>> d = DotExpandedDict({'person.1.firstname': ['Simon'], \
          'person.1.lastname': ['Willison'], \
          'person.2.firstname': ['Adrian'], \
          'person.2.lastname': ['Holovaty']})
    >>> d
    {'person': {'1': {'lastname': ['Willison'], 'firstname': ['Simon']},
    '2': {'lastname': ['Holovaty'], 'firstname': ['Adrian']}}}
    >>> d['person']
    {'1': {'lastname': ['Willison'], 'firstname': ['Simon']}, '2': {'lastname': ['Holovaty'], 'firstname': ['Adrian']}}
    >>> d['person']['1']
    {'lastname': ['Willison'], 'firstname': ['Simon']}

    # Gotcha: Results are unpredictable if the dots are "uneven":
    >>> DotExpandedDict({'c.1': 2, 'c.2': 3, 'c': 1})
    {'c': 1}
    """
    # code taken from Django source code http://code.djangoproject.com/
    def __init__(self, key_to_list_mapping):
        for k, v in key_to_list_mapping.items():
            current = self
            bits = k.split('.')
            for bit in bits[:-1]:
                if bit.startswith('$'):
                    try:
                        bit = eval(bit[1:])
                    except:
                        raise EvalException('%s is not a python type' % bit[:1])
                current = current.setdefault(bit, {})
            # Now assign value to current position
            last_bit = bits[-1]
            if last_bit.startswith('$'):
                try:
                    last_bit = eval(last_bit[1:])
                except:
                    raise EvalException('%s is not a python type' % last_bit)
            try:
                current[last_bit] = v
            except TypeError:  # Special-case if current isn't a dict.
                current = {last_bit: v}


class DotCollapsedDict(dict):
    """
    A special dictionary constructor that take a dict and provides
    a dot collapsed dict:

    >>> DotCollapsedDict({'a':{'b':{'c':{'d':3}, 'e':5}, "g":2}, 'f':6})
    {'a.b.c.d': 3, 'a.b.e': 5, 'a.g': 2, 'f': 6}

    >>> DotCollapsedDict({'bla':{'foo':{unicode:{"bla":3}}, 'bar':'egg'}})
    {'bla.foo.$unicode.bla': 3, 'bla.bar': "egg"}

    >>> DotCollapsedDict({'bla':{'foo':{unicode:{"bla":3}}, 'bar':'egg'}}, remove_under_type=True)
    {'bla.foo':{}, 'bla.bar':unicode}

    >>> dic = {'bar':{'foo':3}, 'bla':{'g':2, 'h':3}}
    >>> DotCollapsedDict(dic, reference={'bar.foo':None, 'bla':{'g':None, 'h':None}})
    {'bar.foo':3, 'bla':{'g':2, 'h':3}}

    """
    def __init__(self, passed_dict, remove_under_type=False, reference=None):
        self._remove_under_type = remove_under_type
        assert isinstance(passed_dict, dict), "you must pass a dict instance"
        final_dict = {}
        self._reference = reference
        self._make_dotation(passed_dict, final_dict)
        self.update(final_dict)

    def _make_dotation(self, d, final_dict, key=""):
        for k, v in d.iteritems():
            if isinstance(k, type):
                k = "$%s" % k.__name__
            if isinstance(v, dict) and v != {}:
                if key:
                    _key = "%s.%s" % (key, k)
                else:
                    _key = k
                if self._reference and _key in self._reference:
                    final_dict[_key] = v
                if self._remove_under_type:
                    if [1 for i in v.keys() if isinstance(i, type)]:
                        v = v.__class__()
                        if not key:
                            final_dict[k] = v
                        else:
                            final_dict["%s.%s" % (key, k)] = v
                    else:
                        self._make_dotation(v, final_dict, _key)
                else:
                    self._make_dotation(v, final_dict, _key)
            else:
                if not key:
                    final_dict[k] = v
                else:
                    if not self._reference:
                        final_dict["%s.%s" % (key, k)] = v
                    elif "%s.%s" % (key, k) in self._reference:
                        final_dict["%s.%s" % (key, k)] = v
                    #else:
                    #    final_dict[key] = {k: v}
                    #    print "+++", {k:v}

########NEW FILE########
__FILENAME__ = master_slave_connection
"""
Master-Slave integration with for MongoKit
Andreas Jung, info@zopyx.com
(same license as Mongokit)
"""

from pymongo.master_slave_connection import MasterSlaveConnection as PymongoMasterSlaveConnection
try:
    from pymongo import MongoClient as PymongoConnection
except ImportError:
    from pymongo import Connection as PymongoConnection

from mongokit.connection import MongoKitConnection


class MasterSlaveConnection(MongoKitConnection, PymongoMasterSlaveConnection):
    """ Master-Slave support for MongoKit """

    def __init__(self, master, slaves=[]):
        """ The MasterSlaveConnection is a wrapper around the
            pymongo.master_slave_connection implementation. The constructor accepts
            the connection parameter for the master MongoDB server and a non-empty
            list of connection parameters for one or more slaves.  The connection
            parameters are expressed as a dictionary where the keys match the
            signature of the constructor of a standard
            pymongo.connection.Connection instance ('host', 'port' etc.). For the
            'slaves' it is not necessary to specify the 'slave_okay' parameter
            (will be added internally automatically).

            The purpose of the MasterSlaveConnection is to hide a master-slave
            setup with one master and several slave servers. The slave
            server(s) will be used for read and write will be made to the
            master (and re-synced to the slave automatically as part of the
            master-slave setup).
        """

        # Run both inits. MongoKitConnection specific one. Then the Pymongo one at the end
        MongoKitConnection.__init__(self)

        # I am the master
        if not isinstance(master, dict):
            raise TypeError('"master" must be a dict  containing pymongo.Connection parameters')
        master_connection = PymongoConnection(**master)

        # You are my dirty slaves
        if not slaves:
            raise ValueError('You must specify at least one slave connection')

        slave_connections = list()
        for slave in slaves:
            if not isinstance(slave, dict):
                raise TypeError('"slaves" must be list of dicts containing pymongo.Connection parameters')
            slave['slave_okay'] = True
            slave_connections.append(PymongoConnection(**slave))

        # Specifying that it should use the pymongo init
        PymongoMasterSlaveConnection.__init__(self, master_connection, slave_connections)

########NEW FILE########
__FILENAME__ = migration
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from mongokit.helpers import DotCollapsedDict
from mongokit.mongo_exceptions import *


class DocumentMigration(object):

    def __init__(self, doc_class):
        self.doc_class = doc_class
        self.target = None
        self.update = None
        self.doc = None
        self.collection = None

    def clean(self):
        self.target = None
        self.update = None
        self.doc = None
        self.collection = None
        self.status = False

    def validate_update(self, update_query):
        structure = DotCollapsedDict(self.doc_class.structure)
        for op, fields in update_query.iteritems():
            for field in fields:
                if op != '$unset' and op != '$rename':
                    if field not in structure:
                        raise UpdateQueryError("'%s' not found in %s's structure" % (
                            field, self.doc_class.__name__))

    def migrate(self, doc, safe=True):
        """migrate the doc through all migration process"""
        method_names = sorted([i for i in dir(self) if i.startswith('migration')])
        for method_name in method_names:
            self.clean()
            self.doc = doc
            getattr(self, method_name)()
            if self.target and self.update:
                if '_id' in doc:
                    self.target['_id'] = doc['_id']
                doc.collection.update(self.target, self.update, multi=False, safe=safe)
                # reload
                try:
                    doc.update(doc.collection.get_from_id(doc['_id']))
                except:
                    raise OperationFailure('Can not reload an unsaved document. '
                                           '%s is not found in the database' % doc['_id'])
                # self.reload()

    def migrate_all(self, collection, safe=True):
        method_names = sorted([i for i in dir(self) if i.startswith('allmigration')])
        for method_name in method_names:
            self.clean()
            self.collection = collection
            getattr(self, method_name)()
            if self.target and self.update:
                self.validate_update(self.update)
                collection.update(self.target, self.update, multi=True, safe=safe)
                status = collection.database.last_status()
                if not status.get('updatedExisting', 1):
                    print "%s : %s >>> deprecated" % (self.__class__.__name__, method_name)

    def get_deprecated(self, collection):
        method_names = sorted([i for i in dir(self) if i.startswith('migration') or i.startswith('allmigration')])
        deprecated = []
        active = []
        for method_name in method_names:
            self.clean()
            self.status = True
            getattr(self, method_name)()
            if not collection.find(self.target).count():
                deprecated.append(method_name)
            else:
                active.append(method_name)
        return {'deprecated': deprecated, 'active': active}

########NEW FILE########
__FILENAME__ = mongo_exceptions
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from bson import InvalidDocument

try:
    from pymongo.connection import OperationFailure
except ImportError:
    from pymongo.errors import OperationFailure


class ConnectionError(Exception):
    pass


class MongoAuthException(Exception):
    pass


class MultipleResultsFound(Exception):
    pass


class BadIndexError(Exception):
    pass


class AutoReferenceError(Exception):
    pass


class MaxDocumentSizeError(Exception):
    pass


class OptionConflictError(Exception):
    pass


class UpdateQueryError(Exception):
    pass

########NEW FILE########
__FILENAME__ = operators
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2010, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


class SchemaOperator(object):
    repr = None

    def __init__(self, *args):
        assert self.repr is not None
        self._operands = list(args)

    def __repr__(self):
        return str(self)

    def __iter__(self):
        for operand in self._operands:
            yield operand

    def __eq__(self, other):
        return type(self) == type(other) and self._operands == other._operands

    def validate(self, value):
        raise NotImplementedError


class OR(SchemaOperator):
    repr = 'or'

    def __init__(self, *args):
        super(OR, self).__init__(*args)

    def __str__(self):
        repr = ' %s ' % self.repr
        return '<'+repr.join([i.__name__ for i in self._operands]) + '>'

    def validate(self, value):
        if type(value) in self._operands:
            return True
        return False


class NOT(SchemaOperator):
    repr = 'not'

    def __init__(self, *args):
        super(NOT, self).__init__(*args)

    def __str__(self):
        repr = ', %s ' % self.repr
        return '<not '+repr.join([i.__name__ for i in self._operands]) + '>'

    def validate(self, value):
        if type(value) in self._operands:
            return False
        return True


class IS(SchemaOperator):
    repr = 'is'

    def __init__(self, *args):
        super(IS, self).__init__(*args)

    def __str__(self):
        representation = ' or %s ' % self.repr
        return '<is '+representation.join([repr(i) for i in self._operands]) + '>'

    def validate(self, value):
        if value in self._operands:
            for op in self._operands:
                if value == op and isinstance(value, type(op)):
                    return True
        return False

########NEW FILE########
__FILENAME__ = paginator
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import re

DEFAULT_LIMIT = 10


class Paginator(object):
    """ Provides pagination on a Cursor object

    Keyword arguments:
    cursor -- Cursor of a returned query
    page   -- The page number requested
    limit  -- The number of items per page

    Properties:
    items        -- Returns the paginated Cursor object
    is_paginated -- Boolean value determining if the cursor has multiple pages
    start_index  -- int index of the first item on the requested page
    end_index    -- int index of the last item on the requested page
    current_page -- int index of the last item on the requested page
    previous_page-- int index of the last item on the requested page
    next_page    -- int index of the last item on the requested page
    has_next     -- True or False if the Cursor has a next page
    has_previous -- True or False if the Cursor has a previous page
    page_range   -- list of page numbers
    num_pages    -- int of the number of pages
    count        -- int total number of items on the cursor
    """

    def __init__(self, cursor, page=1, limit=DEFAULT_LIMIT):
        self._cursor = cursor
        self._count = self._cursor.count() if cursor else 0
        self._limit = limit
        self._page = int(page)
        self._set_page(self._page)

    @property
    def items(self):
        return self._cursor

    @property
    def is_paginated(self):
        return self.num_pages > 1

    @property
    def start_index(self):
        if self._page == 1:
            return 1
        if self._limit == 1:
            return self._page
        return ((self._page-1) * self._limit) + 1

    @property
    def end_index(self):
        if self._limit == 1:
            return self._page

        if self._page == 1:
            return self._count if self._count < self._limit else self._limit

        calc_end = (self._page * self._limit)
        return calc_end if calc_end < self._count else self._count

    @property
    def current_page(self):
        return self._page

    @property
    def previous_page(self):
        return self._page - 1

    @property
    def next_page(self):
        return self._page + 1

    @property
    def has_next(self):
        return self.end_index < self._count

    @property
    def has_previous(self):
        return self.start_index - self._limit >= 0

    @property
    def page_range(self):
        return [p for p in xrange(1, self.num_pages+1)]

    @property
    def num_pages(self):
        if self._count <= 0:
            return 0
        if self._count <= self._limit:
            return 1

        pages_f = self._count / float(self._limit)
        pages_i = int(pages_f)

        return (pages_i + 1) if pages_f > pages_i else pages_i

    @property
    def count(self):
        return self._count

    def _set_page(self, page_num):
        if self._page > 1:
            self._cursor.skip(self.start_index - 1)

        if self._cursor:
            self._cursor.limit(self._limit)

########NEW FILE########
__FILENAME__ = schema_document
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import bson
import datetime
import re
import logging
from copy import deepcopy

log = logging.getLogger(__name__)

from operators import SchemaOperator, IS
from helpers import *

__all__ = [
    'AuthorizedTypeError',
    'BadKeyError',
    'CustomType',
    'DefaultFieldTypeError',
    'DotCollapsedDict',
    'DotedDict',
    'DotExpandedDict',
    'DuplicateDefaultValueError',
    'DuplicateRequiredError',
    'EvalException',
    'fromtimestamp',
    'i18n',
    'i18nError',
    'ModifierOperatorError',
    'RequireFieldError',
    'SchemaDocument',
    'SchemaDocumentError',
    'SchemaProperties',
    'SchemaTypeError',
    'Set',
    'StructureError',
    'totimestamp',
    'ValidationError',
]


class CustomType(object):
    init_type = None
    mongo_type = None
    python_type = None

    def __init__(self):
        if self.mongo_type is None:
            raise TypeError("`mongo_type` property must be specify in %s" %
                            self.__class__.__name__)
        if self.python_type is None:
            raise TypeError("`python_type` property must be specify in %s" %
                            self.__class__.__name__)

    def to_bson(self, value):
        """convert type to a mongodb type"""
        raise NotImplementedError

    def to_python(self, value):
        """convert type to a mongodb type"""
        raise NotImplementedError

    def validate(self, value, path):
        """
        This method is optional. It add a validation layer.
        This method is been called in Document.validate()

        value: the value of the field
        path: the field name (ie, 'foo' or 'foo.bar' if nested)
        """
        pass


# field wich does not need to be declared into the structure
STRUCTURE_KEYWORDS = []


class SchemaDocumentError(Exception):
    pass


class RequireFieldError(SchemaDocumentError):
    pass


class StructureError(SchemaDocumentError):
    pass


class BadKeyError(SchemaDocumentError):
    pass


class AuthorizedTypeError(SchemaDocumentError):
    pass


class ValidationError(SchemaDocumentError):
    pass


class DuplicateRequiredError(SchemaDocumentError):
    pass


class DuplicateDefaultValueError(SchemaDocumentError):
    pass


class ModifierOperatorError(SchemaDocumentError):
    pass


class SchemaTypeError(SchemaDocumentError):
    pass


class DefaultFieldTypeError(SchemaDocumentError):
    pass


class i18nError(SchemaDocumentError):
    pass


class SchemaProperties(type):
    def __new__(cls, name, bases, attrs):
        attrs['_protected_field_names'] = set(
            ['_protected_field_names', '_namespaces', '_required_namespace'])
        for base in bases:
            parent = base.__mro__[0]
            if hasattr(parent, 'structure'):
                if parent.structure is not None:
                    #parent = parent()
                    if parent.structure:
                        if 'structure' not in attrs and parent.structure:
                            attrs['structure'] = parent.structure.copy()
                        else:
                            obj_structure = attrs.get('structure', {}).copy()
                            attrs['structure'] = parent.structure.copy()
                            attrs['structure'].update(obj_structure)
                    if parent.required_fields:
                        attrs['required_fields'] = list(set(
                            attrs.get('required_fields', [])+parent.required_fields))
                    if parent.default_values:
                        obj_default_values = attrs.get('default_values', {}).copy()
                        attrs['default_values'] = parent.default_values.copy()
                        attrs['default_values'].update(obj_default_values)
                    if parent.validators:
                        obj_validators = attrs.get('validators', {}).copy()
                        attrs['validators'] = parent.validators.copy()
                        attrs['validators'].update(obj_validators)
                    if parent.i18n:
                        attrs['i18n'] = list(set(
                            attrs.get('i18n', [])+parent.i18n))
                if attrs.get('authorized_types'):
                    attrs['authorized_types'] = list(set(parent.authorized_types).union(set(attrs['authorized_types'])))
        for mro in bases[0].__mro__:
            attrs['_protected_field_names'] = attrs['_protected_field_names'].union(list(mro.__dict__))
        attrs['_protected_field_names'] = list(attrs['_protected_field_names'])
        if attrs.get('structure') and name not in \
                ["SchemaDocument", "Document", "VersionedDocument", "RevisionDocument"]:
            base = bases[0]
            if not attrs.get('authorized_types'):
                attrs['authorized_types'] = base.authorized_types
            base._validate_structure(attrs['structure'], name, attrs.get('authorized_types'))
            attrs['_namespaces'] = list(base._SchemaDocument__walk_dict(attrs['structure']))
            if [1 for i in attrs['_namespaces'] if type(i) is type]:
                raise DeprecationError("%s: types are not allowed as structure key anymore" % name)
            cls._validate_descriptors(attrs)
            ## building required fields namespace
            attrs['_required_namespace'] = set([])
            for rf in attrs.get('required_fields', []):
                splited_rf = rf.split('.')
                for index in range(len(splited_rf)):
                    attrs['_required_namespace'].add(".".join(splited_rf[:index+1]))
            attrs['_collapsed_struct'] = DotCollapsedDict(attrs['structure'], remove_under_type=True)
        elif attrs.get('structure') is not None and name not in \
                ["SchemaDocument", "Document", "VersionedDocument", "RevisionDocument"]:
            attrs['_collapsed_struct'] = {}
        attrs['_i18n_namespace'] = []
        if attrs.get('i18n'):
            attrs['_i18n_namespace'] = set(['.'.join(i.split('.')[:-1]) for i in attrs['i18n']])
        return type.__new__(cls, name, bases, attrs)

    @classmethod
    def _validate_descriptors(cls, attrs):
        # TODO i18n validator
        for dv in attrs.get('default_values', {}):
            if not dv in attrs['_namespaces']:
                raise ValueError("Error in default_values: can't find %s in structure" % dv)
        for required in attrs.get('required_fields', []):
            if required not in attrs['_namespaces']:
                raise ValueError("Error in required_fields: can't find %s in structure" % required)
        for validator in attrs.get('validators', {}):
            if validator not in attrs['_namespaces']:
                raise ValueError("Error in validators: can't find %s in structure" % validator)
        # required_field
        if attrs.get('required_fields'):
            if len(attrs['required_fields']) != len(set(attrs['required_fields'])):
                raise DuplicateRequiredError("duplicate required_fields : %s" % attrs['required_fields'])
        # i18n
        if attrs.get('i18n'):
            if len(attrs['i18n']) != len(set(attrs['i18n'])):
                raise DuplicateI18nError("duplicated i18n : %s" % attrs['i18n'])
            for i18n in attrs['i18n']:
                if i18n not in attrs['_namespaces']:
                    raise ValueError("Error in i18n: can't find %s in structure" % i18n)


class SchemaDocument(dict):
    """
    A SchemaDocument is dictionary with a building structured schema
    The validate method will check that the document match the underling
    structure. A structure must be specify in each SchemaDocument.

    >>> class TestDoc(SchemaDocument):
    ...     structure = {
    ...         "foo":unicode,
    ...         "bar":int,
    ...         "nested":{
    ...            "bla":float}}

    `unicode`, `int`, `float` are python types listed in `mongokit.authorized_types`.

    >>> doc = TestDoc()
    >>> doc
    {'foo': None, 'bar': None, 'nested': {'bla': None}}

    A SchemaDocument works just like dict:

    >>> doc['bar'] = 3
    >>> doc['foo'] = "test"

    We can describe fields as required with the required attribute:

    >>> TestDoc.required_fields = ['bar', 'nested.bla']
    >>> doc = TestDoc()
    >>> doc['bar'] = 2

    Validation is made with the `validate()` method:

    >>> doc.validate()  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
    ...
    RequireFieldError: nested.bla is required


    Default values can be set by using the attribute default_values :

    >>> TestDoc.default_values = {"bar":3, "nested.bla":2.0}
    >>> doc = TestDoc()
    >>> doc
    {'foo': None, 'bar': 3, 'nested': {'bla': 2.0}}
    >>> doc.validate()

    Validators can be added in order to validate some values :

    >>> TestDoc.validators = {"bar":lambda x: x>0, "nested.bla": lambda x: x<0}
    >>> doc = TestDoc()
    >>> doc['bar'] = 3
    >>> doc['nested']['bla'] = 2.0
    >>> doc.validate()
    Traceback (most recent call last):
    ...
    ValidationError: nested.bla does not pass the validator <lambda>

    If you want to use the dot notation (ala json), you must set the
    `use_dot_notation` attribute to True:

    >>> class TestDotNotation(SchemaDocument):
    ...     structure = {
    ...         "foo":{ "bar":unicode}
    ...     }
    ...     use_dot_notation=True

    >>> doc = TestDotNotation()
    >>> doc.foo.bar = u"bla"
    >>> doc
    {"foo":{"bar":u"bla}}
    """
    __metaclass__ = SchemaProperties

    structure = None
    required_fields = []
    default_values = {}
    validators = {}
    i18n = []
    raise_validation_errors = True

    skip_validation = False

    # if you want to have all schemaless benefits (default False but should change)
    # warning, if use_schemaless is True, Migration features can not be used.
    use_schemaless = False

    # If you want to use the dot notation, set this to True:
    use_dot_notation = False
    dot_notation_warning = False

    authorized_types = [
        type(None),
        bool,
        int,
        long,
        float,
        unicode,
        basestring,
        list,
        dict,
        datetime.datetime,
        bson.binary.Binary,
        CustomType,
    ]

    def __init__(self, doc=None, gen_skel=True, gen_auth_types=True, validate=True, lang='en', fallback_lang='en'):
        """
        doc : a dictionary
        gen_skel : if True, generate automatically the skeleton of the doc
            filled with NoneType each time validate() is called. Note that
            if doc is not {}, gen_skel is always False. If gen_skel is False,
            default_values cannot be filled.
        gen_auth_types: if True, generate automatically the self.authorized_types
            attribute from self.authorized_types
        """
        if self.structure is None:
            self.structure = {}
        self._current_lang = lang
        self._fallback_lang = fallback_lang
        self.validation_errors = {}
        # init
        if doc:
            for k, v in doc.iteritems():
                self[k] = v
            gen_skel = False
        if gen_skel:
            self.generate_skeleton()
            if self.default_values:
                self._set_default_fields(self, self.structure)
        else:
            self._process_custom_type('python', self, self.structure)
        if self.use_dot_notation:
            self.__generate_doted_dict(self, self.structure)
        if self.i18n:
            self._make_i18n()

    def generate_skeleton(self):
        """
        validate and generate the skeleton of the document
        from the structure (unknown values are set to None)
        """
        self.__generate_skeleton(self, self.structure)

    def validate(self):
        """
        validate the document.

        This method will verify if :
          * the doc follow the structure,
          * all required fields are filled

        Additionally, this method will process all
        validators.

        """
        if self.validators:
            self._process_validators(self, self.structure)
        self._process_custom_type('bson', self, self.structure)
        self._validate_doc(self, self.structure)
        self._process_custom_type('python', self, self.structure)
        if self.required_fields:
            self._validate_required(self, self.structure)

    def __setattr__(self, key, value):
        if key not in self._protected_field_names and self.use_dot_notation and key in self:
            if isinstance(self.structure[key], i18n):
                self[key][self._current_lang] = value
            else:
                self[key] = value
        else:
            if self.dot_notation_warning and not key.startswith('_') and key not in \
                    ['db', 'collection', 'versioning_collection', 'connection', 'fs']:
                log.warning("dot notation: %s was not found in structure. Add it as attribute instead" % key)
            dict.__setattr__(self, key, value)

    def __getattr__(self, key):
        if key not in self._protected_field_names and self.use_dot_notation and key in self:
            if isinstance(self[key], i18n):
                if self._current_lang not in self[key]:
                    return self[key].get(self._fallback_lang)
                return self[key][self._current_lang]
            return self[key]
        else:
            return dict.__getattribute__(self, key)

    #
    # Public API end
    #

    @classmethod
    def __walk_dict(cls, dic):
        # thanks jean_b for the patch
        for key, value in dic.items():
            if isinstance(value, dict) and len(value):
                if type(key) is type:
                    yield '$%s' % key.__name__
                else:
                    yield key
                for child_key in cls.__walk_dict(value):
                    if type(key) is type:
                        new_key = "$%s" % key.__name__
                    else:
                        new_key = key
                    #if type(child_key) is type:
                    #    new_child_key = "$%s" % child_key.__name__
                    #else:
                    if type(child_key) is not type:
                        new_child_key = child_key
                    yield '%s.%s' % (new_key, new_child_key)
            elif type(key) is type:
                yield '$%s' % key.__name__
#            elif isinstance(value, list) and len(value):
#                if isinstance(value[0], dict):
#                    for child_key in cls.__walk_dict(value[0]):
#                        #if type(key) is type:
#                        #    new_key = "$%s" % key.__name__
#                        #else:
#                        if type(key) is not type:
#                            new_key = key
#                        #if type(child_key) is type:
#                        #    new_child_key = "$%s" % child_key.__name__
#                        #else:
#                        if type(child_key) is not type:
#                            new_child_key = child_key
#                        yield '%s.%s' % (new_key, new_child_key)
#                else:
#                    if type(key) is not type:
#                        yield key
#                    #else:
#                    #    yield ""
            else:
                if type(key) is not type:
                    yield key
                #else:
                #    yield ""

    @classmethod
    def _validate_structure(cls, structure, name, authorized_types):
        """
        validate if all fields in self.structure are in authorized types.
        """
        ##############
        def __validate_structure(struct, name,  authorized):
            if type(struct) is type:
                if struct not in authorized_types:
                    if struct not in authorized_types:
                        raise StructureError("%s: %s is not an authorized type" % (name, struct))
            elif isinstance(struct, dict):
                for key in struct:
                    if isinstance(key, basestring):
                        if "." in key:
                            raise BadKeyError("%s: %s must not contain '.'" % (name, key))
                        if key.startswith('$'):
                            raise BadKeyError("%s: %s must not start with '$'" % (name, key))
                    elif type(key) is type:
                        if not key in authorized_types:
                            raise AuthorizedTypeError("%s: %s is not an authorized type" % (name, key))
                    else:
                        raise StructureError("%s: %s must be a basestring or a type" % (name, key))
                    if struct[key] is None:
                        pass
                    elif isinstance(struct[key], dict):
                        __validate_structure(struct[key], name, authorized_types)
                    elif isinstance(struct[key], list):
                        __validate_structure(struct[key], name, authorized_types)
                    elif isinstance(struct[key], tuple):
                        __validate_structure(struct[key], name, authorized_types)
                    elif isinstance(struct[key], CustomType):
                        __validate_structure(struct[key].mongo_type, name, authorized_types)
                    elif isinstance(struct[key], SchemaProperties):
                        pass
                    elif isinstance(struct[key], SchemaOperator):
                        __validate_structure(struct[key], name, authorized_types)
                    elif hasattr(struct[key], 'structure'):
                        __validate_structure(struct[key], name, authorized_types)
                    elif struct[key] not in authorized_types:
                        ok = False
                        for auth_type in authorized_types:
                            if struct[key] is None:
                                ok = True
                            else:
                                try:
                                    if isinstance(struct[key], auth_type) or issubclass(struct[key], auth_type):
                                        ok = True
                                except TypeError:
                                    raise TypeError("%s: %s is not a type" % (name, struct[key]))
                        if not ok:
                            raise StructureError(
                                "%s: %s is not an authorized type" % (name, struct[key]))
            elif isinstance(struct, list) or isinstance(struct, tuple):
                for item in struct:
                    __validate_structure(item, name, authorized_types)
            elif isinstance(struct, SchemaOperator):
                if isinstance(struct, IS):
                    for operand in struct:
                        if type(operand) not in authorized_types:
                            raise StructureError("%s: %s in %s is not an authorized type (%s found)" % (
                                name, operand, struct, type(operand).__name__))
                else:
                    for operand in struct:
                        if operand not in authorized_types:
                            raise StructureError("%s: %s in %s is not an authorized type (%s found)" % (
                                name, operand, struct, type(operand).__name__))
            elif isinstance(struct, SchemaProperties):
                pass
            else:
                ok = False
                for auth_type in authorized_types:
                    if isinstance(struct, auth_type):
                        ok = True
                if not ok:
                    raise StructureError("%s: %s is not an authorized_types" % (name, struct))
        #################
        if structure is None:
            raise StructureError("%s.structure must not be None" % name)
        if not isinstance(structure, dict):
            raise StructureError("%s.structure must be a dict instance" % name)
        __validate_structure(structure, name, authorized_types)

    def _raise_exception(self, exception, field, message):
        if self.raise_validation_errors:
            raise exception(message)
        else:
            if not field in self.validation_errors:
                self.validation_errors[field] = []
            self.validation_errors[field].append(exception(message))

    def _validate_doc(self, doc, struct, path=""):
        """
        check if doc field types match the doc field structure
        """
        if type(struct) is type or struct is None:
            if struct is None:
                if type(doc) not in self.authorized_types:
                    self._raise_exception(AuthorizedTypeError, type(doc).__name__,
                                          "%s is not an authorized types" % type(doc).__name__)
            elif not isinstance(doc, struct) and doc is not None:
                self._raise_exception(SchemaTypeError, path,
                                      "%s must be an instance of %s not %s" % (
                                          path, struct.__name__, type(doc).__name__))
        elif isinstance(struct, CustomType):
            if not isinstance(doc, struct.mongo_type) and doc is not None:
                self._raise_exception(SchemaTypeError, path,
                                      "%s must be an instance of %s not %s" % (
                                          path, struct.mongo_type.__name__, type(doc).__name__))
            struct.validate(doc, path=path)
        elif isinstance(struct, SchemaOperator):
            if not struct.validate(doc) and doc is not None:
                if isinstance(struct, IS):
                    self._raise_exception(SchemaTypeError, path,
                                          "%s must be in %s not %s" % (path, struct._operands, doc))
                else:
                    self._raise_exception(SchemaTypeError, path,
                                          "%s must be an instance of %s not %s" % (path, struct, type(doc).__name__))
        elif isinstance(struct, dict):
            if not isinstance(doc, type(struct)):
                self._raise_exception(SchemaTypeError, path,
                                      "%s must be an instance of %s not %s" % (
                                          path, type(struct).__name__, type(doc).__name__))
            struct_length = len(struct) if not '_id' in struct else len(struct) - 1
            if len(doc) != struct_length:
                struct_doc_diff = list(set(struct).difference(set(doc)))
                if struct_doc_diff:
                    for field in struct_doc_diff:
                        if (type(field) is not type) and (not self.use_schemaless):
                            self._raise_exception(StructureError, None,
                                                  "missed fields %s in %s" % (struct_doc_diff, type(doc).__name__))
                else:
                    struct_struct_diff = list(set(doc).difference(set(struct)))
                    bad_fields = [s for s in struct_struct_diff if s not in STRUCTURE_KEYWORDS]
                    if bad_fields and not self.use_schemaless:
                        self._raise_exception(StructureError, None,
                                              "unknown fields %s in %s" % (bad_fields, type(doc).__name__))
            for key in struct:
                if type(key) is type:
                    new_key = "$%s" % key.__name__
                else:
                    new_key = key
                new_path = ".".join([path, new_key]).strip('.')
                if new_key.split('.')[-1].startswith("$"):
                    for doc_key in doc:
                        if not isinstance(doc_key, key):
                            self._raise_exception(SchemaTypeError, path,
                                                  "key of %s must be an instance of %s not %s" % (
                                                      path, key.__name__, type(doc_key).__name__))
                        self._validate_doc(doc[doc_key], struct[key], new_path)
                else:
                    if key in doc:
                        self._validate_doc(doc[key], struct[key],  new_path)
        elif isinstance(struct, list):
            if not isinstance(doc, list) and not isinstance(doc, tuple):
                self._raise_exception(SchemaTypeError, path,
                                      "%s must be an instance of list not %s" % (path, type(doc).__name__))
            if not len(struct):
                struct = None
            else:
                struct = struct[0]
            for obj in doc:
                self._validate_doc(obj, struct, path)
        elif isinstance(struct, tuple):
            if not isinstance(doc, list) and not isinstance(doc, tuple):
                self._raise_exception(SchemaTypeError, path,
                                      "%s must be an instance of list not %s" % (
                                          path, type(doc).__name__))
            if len(doc) != len(struct):
                self._raise_exception(SchemaTypeError, path, "%s must have %s items not %s" % (
                    path, len(struct), len(doc)))
            for i in range(len(struct)):
                self._validate_doc(doc[i], struct[i], path)

    def _process_validators(self, doc, struct, path=""):
        doted_struct = DotCollapsedDict(self.structure)
        doted_doc = DotCollapsedDict(doc)
        for key, validators in self.validators.iteritems():
            if key in doted_doc and doted_doc[key] is not None:
                if not hasattr(validators, "__iter__"):
                    validators = [validators]
                for validator in validators:
                    try:
                        if not validator(doted_doc[key]):
                            raise ValidationError("%s does not pass the validator " + validator.__name__)
                    except Exception, e:
                        self._raise_exception(ValidationError, key,
                                              unicode(e) % key)

    def _process_custom_type(self, target, doc, struct, path="", root_path=""):
        for key in struct:
            if type(key) is type:
                new_key = "$%s" % key.__name__
            else:
                new_key = key
            new_path = ".".join([path, new_key]).strip('.')
            #
            # if the value is a dict, we have a another structure to validate
            #
            #
            # It is not a dict nor a list but a simple key:value
            #
            if isinstance(struct[key], CustomType):
                if target == 'bson':
                    if key in doc:
                        if struct[key].python_type is not None:
                            if not isinstance(doc[key], struct[key].python_type) and doc[key] is not None:
                                self._raise_exception(SchemaTypeError, new_path,
                                                      "%s must be an instance of %s not %s" % (
                                                          new_path, struct[key].python_type.__name__,
                                                          type(doc[key]).__name__))
                        doc[key] = struct[key].to_bson(doc[key])
                else:
                    if key in doc:
                        doc[key] = struct[key].to_python(doc[key])
            elif isinstance(struct[key], dict):
                if doc:  # we don't need to process an empty doc
                    if type(key) is type:
                        for doc_key in doc:  # process type's key such {unicode:int}...
                            self._process_custom_type(target, doc[doc_key], struct[key], new_path, root_path)
                    else:
                        if key in doc:  # we don't care about missing fields
                            self._process_custom_type(target, doc[key], struct[key], new_path, root_path)
            #
            # If the struct is a list, we have to validate all values into it
            #
            elif type(struct[key]) is list:
                #
                # check if the list must not be null
                #
                if struct[key]:
                    l_objs = []
                    if isinstance(struct[key][0], CustomType):
                        for obj in doc[key]:
                            if target == 'bson':
                                if struct[key][0].python_type is not None:
                                    if not isinstance(obj, struct[key][0].python_type) and obj is not None:
                                        self._raise_exception(SchemaTypeError, new_path,
                                                              "%s must be an instance of %s not %s" % (
                                                                  new_path, struct[key][0].python_type.__name__,
                                                                  type(obj).__name__))
                                obj = struct[key][0].to_bson(obj)
                            else:
                                obj = struct[key][0].to_python(obj)
                            l_objs.append(obj)
                        doc[key] = l_objs
                    elif isinstance(struct[key][0], dict):
                        if doc.get(key):
                            for obj in doc[key]:
                                self._process_custom_type(target, obj, struct[key][0], new_path, root_path)

    def _set_default_fields(self, doc, struct, path=""):
        # TODO check this out, this method must be restructured
        for key in struct:
            new_key = key
            new_path = ".".join([path, new_key]).strip('.')
            #
            # default_values :
            # if the value is None, check if a default value exist.
            # if exists, and it is a function then call it otherwise,
            # juste feed it
            #
            if type(key) is not type:
                if doc[key] is None and new_path in self.default_values:
                    new_value = self.default_values[new_path]
                    if callable(new_value):
                        new_value = new_value()
                    elif isinstance(new_value, dict):
                        new_value = deepcopy(new_value)
                    elif isinstance(new_value, list):
                        new_value = new_value[:]
                    if isinstance(struct[key], CustomType):
                        if not isinstance(new_value, struct[key].python_type):
                            self._raise_exception(DefaultFieldTypeError, new_path,
                                                  "%s must be an instance of %s not %s" % (
                                                      new_path, struct[key].python_type.__name__,
                                                      type(new_value).__name__))
                    doc[key] = new_value
            #
            # if the value is a dict, we have a another structure to validate
            #
            if isinstance(struct[key], dict) and new_path not in self.i18n:
                #
                # if the dict is still empty into the document we build
                # it with None values
                #
                if len(struct[key]) and not [i for i in struct[key].keys() if type(i) is type]:
                    self._set_default_fields(doc[key], struct[key], new_path)
                else:
                    if new_path in self.default_values:
                        new_value = self.default_values[new_path]
                        if callable(new_value):
                            new_value = new_value()
                        elif isinstance(new_value, dict):
                            new_value = deepcopy(new_value)
                        elif isinstance(new_value, list):
                            new_value = new_value[:]
                        doc[key] = new_value
            elif isinstance(struct[key], list):
                if new_path in self.default_values:
                    for new_value in self.default_values[new_path]:
                        if callable(new_value):
                            new_value = new_value()
                        elif isinstance(new_value, dict):
                            new_value = deepcopy(new_value)
                        elif isinstance(new_value, list):
                            new_value = new_value[:]
                        if isinstance(struct[key][0], CustomType):
                            if not isinstance(new_value, struct[key][0].python_type):
                                self._raise_exception(DefaultFieldTypeError, new_path,
                                                      "%s must be an instance of %s not %s" % (
                                                          new_path, struct[key][0].python_type.__name__,
                                                          type(new_value).__name__))
                        doc[key].append(new_value)
            else:  # what else
                if new_path in self.default_values:
                    new_value = self.default_values[new_path]
                    if callable(new_value):
                        new_value = new_value()
                    elif isinstance(new_value, dict):
                        new_value = deepcopy(new_value)
                    elif isinstance(new_value, list):
                        new_value = new_value[:]
                    if new_path in self.i18n:
                        doc[key] = i18n(
                            field_type=struct[key],
                            field_name=key
                        )
                        doc[key].update(new_value)
                    else:
                        doc[key] = new_value

    def _validate_required(self, doc, struct, path="", root_path=""):
        doted_struct = DotCollapsedDict(self.structure)
        doted_doc = DotCollapsedDict(doc, reference=doted_struct)
        for req in self.required_fields:
            if doted_doc.get(req) is None and doted_struct.get(req) is not dict:
                if not isinstance(doted_struct.get(req), CustomType):
                    self._raise_exception(RequireFieldError, req, "%s is required" % req)
                elif isinstance(doted_struct.get(req), CustomType) and doted_struct[req].mongo_type is not dict:
                    self._raise_exception(RequireFieldError, req, "%s is required" % req)
            elif doted_doc.get(req) == []:
                self._raise_exception(RequireFieldError, req, "%s is required" % req)
            elif doted_doc.get(req) == {}:
                self._raise_exception(RequireFieldError, req, "%s is required" % req)

    def __generate_skeleton(self, doc, struct, path=""):
        for key in struct:
            if type(key) is type:
                new_key = "$%s" % key.__name__
            else:
                new_key = key
            new_path = ".".join([path, new_key]).strip('.')
            #
            # Automatique generate the skeleton with NoneType
            #
            if type(key) is not type and key not in doc:
                if isinstance(struct[key], dict):
                    if type(struct[key]) is dict and self.use_dot_notation:
                        if new_path in self._i18n_namespace:
                            doc[key] = i18nDotedDict(doc.get(key, {}), self)
                        else:
                            doc[key] = DotedDict(doc.get(key, {}), warning=self.dot_notation_warning)
                    else:
                        if callable(struct[key]):
                            doc[key] = struct[key]()
                        else:
                            doc[key] = type(struct[key])()
                elif struct[key] is dict:
                    doc[key] = {}
                elif isinstance(struct[key], list):
                    doc[key] = type(struct[key])()
                elif isinstance(struct[key], CustomType):
                    if struct[key].init_type is not None:
                        doc[key] = struct[key].init_type()
                    else:
                        doc[key] = None
                elif struct[key] is list:
                    doc[key] = []
                elif isinstance(struct[key], tuple):
                    doc[key] = [None for i in range(len(struct[key]))]
                else:
                    doc[key] = None
            #
            # if the value is a dict, we have a another structure to validate
            #
            if isinstance(struct[key], dict) and type(key) is not type:
                self.__generate_skeleton(doc[key], struct[key], new_path)

    def __generate_doted_dict(self, doc, struct, path=""):
        for key in struct:
            #
            # Automatique generate the skeleton with NoneType
            #
            if type(key) is type:
                new_key = "$%s" % key.__name__
            else:
                new_key = key
            new_path = ".".join([path, new_key]).strip('.')
            if type(key) is not type:  # and key not in doc:
                if isinstance(struct[key], dict):
                    if type(struct[key]) is dict:
                        if new_path in self._i18n_namespace:
                            doc[key] = i18nDotedDict(doc.get(key, {}), self)
                        else:
                            doc[key] = DotedDict(doc.get(key, {}), warning=self.dot_notation_warning)
            #
            # if the value is a dict, we have a another structure to validate
            #
            if isinstance(struct[key], dict) and type(key) is not type:
                self.__generate_doted_dict(doc[key], struct[key], new_path)

    def _make_i18n(self):
        doted_dict = DotCollapsedDict(self.structure)
        for field in self.i18n:
            if field not in doted_dict:
                self._raise_exception(ValidationError, field,
                                      "%s not found in structure" % field)
            if not isinstance(doted_dict[field], i18n):
                doted_dict[field] = i18n(
                    field_type=doted_dict[field],
                    field_name=field
                )
        self.structure.update(DotExpandedDict(doted_dict))

    def set_lang(self, lang):
        self._current_lang = lang

    def get_lang(self):
        return self._current_lang


class i18n(dict, CustomType):
    """ CustomType to deal with i18n """
    mongo_type = list

    def __init__(self, field_type=None, field_name=None):
        super(i18n, self).__init__()
        self.python_type = self.__class__
        self._field_type = field_type
        self._field_name = field_name

    def __call__(self):
        return i18n(self._field_type, self._field_name)

    def to_bson(self, value):
        if value is not None:
            for l, v in value.iteritems():
                if isinstance(v, list) and isinstance(self._field_type, list):
                    for i in v:
                        if not isinstance(i, self._field_type[0]):
                            raise SchemaTypeError("%s (%s) must be an instance of %s not %s" % (
                                self._field_name, l, self._field_type[0], type(i).__name__))
                else:
                    if not isinstance(v, self._field_type):
                        raise SchemaTypeError("%s (%s) must be an instance of %s not %s" % (
                                              self._field_name, l, self._field_type, type(v).__name__))
            return [{'lang': l, 'value': v} for l, v in value.iteritems()]

    def to_python(self, value):
        if value is not None:
            i18n_dict = self.__class__(self._field_type)
            for i in value:
                i18n_dict[i['lang']] = i['value']
            return i18n_dict


class Set(CustomType):
    """ SET custom type to handle python set() type """
    init_type = set
    mongo_type = list
    python_type = set

    def __init__(self, structure_type=None):
        super(Set, self).__init__()
        self._structure_type = structure_type

    def to_bson(self, value):
        if value is not None:
            return list(value)

    def to_python(self, value):
        if value is not None:
            return set(value)

    def validate(self, value, path):
        if value is not None and self._structure_type is not None:
            for val in value:
                if not isinstance(val, self._structure_type):
                    raise ValueError('%s must be an instance of %s not %s' %
                                     (path, self._structure_type.__name__, type(val).__name__))

########NEW FILE########
__FILENAME__ = versioned_document
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from mongokit import *
from mongo_exceptions import *


class RevisionDocument(Document):
    structure = {
        "id": unicode,
        "revision": int,
        "doc": dict
    }


class VersionedDocument(Document):
    """
    This object implement a vesionnized mongo document
    """

    def __init__(self, doc=None, *args, **kwargs):
        super(VersionedDocument, self).__init__(doc=doc, *args, **kwargs)
        if kwargs.get('collection', None):
            self.versioning_collection = self.db["versioned_%s" % self.collection.name]
            self.versioning_collection.ensure_index([('id', 1), ('revision', 1)], unique=True)
            self.versioning_collection.database.connection.register([self.__class__, RevisionDocument])

    def save(self, versioning=True, *args, **kwargs):
        if versioning:
            if '_revision' in self:
                self.pop('_revision')
                self['_revision'] = self.get_last_revision_id()
            else:
                self['_revision'] = 0
            self['_revision'] += 1
            super(VersionedDocument, self).save(*args, **kwargs)
            versionned_doc = RevisionDocument({"id": unicode(self['_id']), "revision": self['_revision']},
                                              collection=self.versioning_collection)
            versionned_doc['doc'] = dict(self)
            versionned_doc.save()
        else:
            super(VersionedDocument, self).save(*args, **kwargs)
        return self

    def delete(self, versioning=False, *args, **kwargs):
        """
        if versioning is True delete revisions documents as well
        """
        if versioning:
            self.versioning_collection.remove({'id': self['_id']})
        super(VersionedDocument, self).delete(*args, **kwargs)

    def remove(self, query, versioning=False, *args, **kwargs):
        """
        if versioning is True, remove all revisions documents as well.
        Be careful when using this method. If your query match tons of
        documents, this might be very very slow.
        """
        if versioning:
            id_lists = [i['_id'] for i in self.collection.find(query, fields=['_id'])]
            self.versioning_collection.remove({'id': {'$in': id_lists}})
        self.collection.remove(spec_or_id=query, *args, **kwargs)

    def get_revision(self, revision_number):
        doc = self.versioning_collection.RevisionDocument.find_one(
            {"id": self['_id'], 'revision': revision_number})
        if doc:
            return self.__class__(doc['doc'], collection=self.collection)

    def get_revisions(self):
        versionned_docs = self.versioning_collection.find({"id": self['_id']})
        for verdoc in versionned_docs:
            yield self.__class__(verdoc['doc'], collection=self.collection)

    def get_last_revision_id(self):
        last_doc = self.versioning_collection.find({'id': unicode(self['_id'])}).sort('revision', -1).next()
        if last_doc:
            return last_doc['revision']

########NEW FILE########
__FILENAME__ = test_api
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest

from mongokit import *
from bson.objectid import ObjectId
from pymongo import ReadPreference


class ApiTestCase(unittest.TestCase):
    def setUp(self):
        self.connection = Connection()
        self.col = self.connection['test']['mongokit']

    def tearDown(self):
        self.connection.drop_database('test')
        self.connection.drop_database('othertest')

    def test_save(self):
        class MyDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam":[],
            }
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc["bla"]["foo"] = u"bar"
        mydoc["bla"]["bar"] = 42
        mydoc.save()
        assert isinstance(mydoc['_id'], ObjectId)

        saved_doc = self.col.find_one({"bla.bar":42})
        for key, value in mydoc.iteritems():
            assert saved_doc[key] == value

        mydoc = self.col.MyDoc()
        mydoc["bla"]["foo"] = u"bar"
        mydoc["bla"]["bar"] = 43
        mydoc.save(uuid=True)
        assert isinstance(mydoc['_id'], unicode)
        assert mydoc['_id'].startswith("MyDoc"), id

        saved_doc = self.col.find_one({"bla.bar":43})
        for key, value in mydoc.iteritems():
            assert saved_doc[key] == value

    def test_save_without_collection(self):
        class MyDoc(Document):
            structure = {
                "foo":int,
            }
        self.connection.register([MyDoc])
        mydoc = MyDoc()
        mydoc["foo"] = 1
        self.assertRaises(ConnectionError, mydoc.save)

    def test_delete(self):
        class MyDoc(Document):
            structure = {
                "foo":int,
            }
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc['_id'] = 'foo'
        mydoc["foo"] = 1
        mydoc.save()
        assert self.col.MyDoc.find().count() == 1
        mydoc = self.col.MyDoc.get_from_id('foo')
        assert mydoc['foo'] == 1
        mydoc.delete()
        assert self.col.MyDoc.find().count() == 0

    def test_generate_skeleton(self):
        class A(SchemaDocument):
            structure = {
                "a":{"foo":int},
                "bar":unicode
            }
        a = A(gen_skel=False)
        assert a == {}
        a.generate_skeleton()
        assert a == {"a":{"foo":None}, "bar":None}, a

    def test_generate_skeleton2(self):
        class A(SchemaDocument):
            structure = {
                "a":{"foo":[int]},
                "bar":{unicode:{"egg":int}}
            }
        a = A(gen_skel=False)
        assert a == {}
        a.generate_skeleton()
        assert a == {"a":{"foo":[]}, "bar":{}}, a

    def test_generate_skeleton3(self):
        class A(SchemaDocument):
            structure = {
                "a":{"foo":[int], "spam":{"bla":unicode}},
                "bar":{unicode:{"egg":int}}
            }
        a = A(gen_skel=False)
        assert a == {}
        a.generate_skeleton()
        assert a == {"a":{"foo":[], "spam":{"bla":None}}, "bar":{}}, a

    def test_get_from_id(self):
        class MyDoc(Document):
            structure = {
                "foo":int,
            }
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc["_id"] = "bar"
        mydoc["foo"] = 3
        mydoc.save()
        fetched_doc = self.col.MyDoc.get_from_id("bar")
        assert mydoc == fetched_doc
        assert callable(fetched_doc) is False
        assert isinstance(fetched_doc, MyDoc)
        raw_doc = self.col.get_from_id('bar')
        assert mydoc == raw_doc
        assert not isinstance(raw_doc, MyDoc)

    def test_find(self):
        class MyDoc(Document):
            structure = {
                "foo":int,
                "bar":{"bla":int},
            }
        self.connection.register([MyDoc])
        for i in range(10):
            mydoc = self.col.MyDoc()
            mydoc["foo"] = i
            mydoc["bar"]['bla'] = i
            mydoc.save()
        for i in self.col.MyDoc.find({"foo":{"$gt":4}}):
            assert isinstance(i, MyDoc), (i, type(i))
        docs_list = [i["foo"] for i in self.col.MyDoc.find({"foo":{"$gt":4}})]
        assert docs_list == [5,6,7,8,9]
        # using limit/count
        assert self.col.MyDoc.find().count() == 10, self.col.MyDoc.find().count()
        assert self.col.MyDoc.find().limit(1).count() == 10, self.col.MyDoc.find().limit(1).count()
        assert self.col.MyDoc.find().where('this.foo').count() == 9 #{'foo':0} is not taken
        assert self.col.MyDoc.find().where('this.bar.bla').count() == 9 #{'foo':0} is not taken
        assert self.col.MyDoc.find().hint([('foo', 1)])
        assert [i['foo'] for i in self.col.MyDoc.find().sort('foo', -1)] == [9,8,7,6,5,4,3,2,1,0]
        allPlans = self.col.MyDoc.find().explain()['allPlans']
        self.assertEqual(
            allPlans,
            [
                {
                    u'cursor': u'BasicCursor',
                    u'indexBounds': {},
                    u'nscannedObjects': 10,
                    u'nscanned': 10,
                    u'n': 10,
                },
            ],
        )
        next_doc =  self.col.MyDoc.find().sort('foo',1).next()
        assert callable(next_doc) is False
        assert isinstance(next_doc, MyDoc)
        assert next_doc['foo'] == 0
        assert len(list(self.col.MyDoc.find().skip(3))) == 7, len(list(self.col.MyDoc.find().skip(3)))
        from mongokit.cursor import Cursor
        assert isinstance(self.col.MyDoc.find().skip(3), Cursor)

    def test_find_one(self):
        class MyDoc(Document):
            structure = {
                "foo":int
            }
        self.connection.register([MyDoc])
        assert self.col.MyDoc.find_one() is None
        mydoc = self.col.MyDoc()
        mydoc['foo'] = 0
        mydoc.save()
        mydoc = self.col.MyDoc.find_one()
        assert mydoc["foo"] == 0
        assert isinstance(mydoc, MyDoc)
        for i in range(10):
            mydoc = self.col.MyDoc()
            mydoc["foo"] = i
            mydoc.save()
        one_doc = self.col.MyDoc.find_one()
        assert callable(one_doc) is False
        raw_mydoc = self.col.find_one()
        assert one_doc == raw_mydoc

    def test_find_and_modify_query_fails(self):
        class MyDoc(Document):
            structure = {
                "baz":int
            }
        self.connection.register([MyDoc])
        assert self.col.MyDoc.find_and_modify(query={"baz": 1}, update={"$set": {"baz": 2}}) is None

    def test_find_and_modify_query_succeeds(self):
        class MyDoc(Document):
            structure = {
                "baz":int
            }
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc["baz"] = 1
        mydoc.save()

        mydoc = self.col.MyDoc.find_and_modify(query={"baz": 1}, update={"$set": {"baz": 2}}, new=True)
        assert isinstance(mydoc, MyDoc)
        self.assertEquals(2, mydoc["baz"])

    def test_one(self):
        class MyDoc(Document):
            structure = {
                "foo":int
            }
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc['foo'] = 0
        mydoc.save()
        raw_mydoc = self.col.one()
        mydoc = self.col.MyDoc.one()
        assert callable(mydoc) is False
        assert mydoc == raw_mydoc
        assert mydoc["foo"] == 0
        assert isinstance(mydoc, MyDoc)
        for i in range(10):
            mydoc = self.col.MyDoc()
            mydoc["foo"] = i
            mydoc.save()
        self.assertRaises(MultipleResultsFound, self.col.MyDoc.one)
        self.assertRaises(MultipleResultsFound, self.col.one)

    def test_find_random(self):
        class MyDoc(Document):
            structure = {
                "foo":int
            }
        self.connection.register([MyDoc])
        assert self.col.find_random() is None
        assert self.col.MyDoc.find_random() is None
        for i in range(50):
            mydoc = self.col.MyDoc()
            mydoc["foo"] = i
            mydoc.save()
        raw_mydoc = self.col.find_random()
        mydoc = self.col.MyDoc.find_random()
        assert callable(mydoc) is False
        assert isinstance(mydoc, MyDoc)
        assert mydoc != raw_mydoc, (mydoc, raw_mydoc)

    def test_fetch(self):
        class DocA(Document):
            structure = {
                "doc_a":{'foo':int},
            }
        self.connection.register([DocA])
        class DocB(Document):
            structure = {
                "doc_b":{"bar":int},
            }
        self.connection.register([DocB])
        # creating DocA
        for i in range(10):
            mydoc = self.col.DocA()
            mydoc['doc_a']["foo"] = i
            mydoc.save()
        # creating DocB
        for i in range(5):
            mydoc = self.col.DocB()
            mydoc['doc_b']["bar"] = i
            mydoc.save()

        # all get all documents present in the collection (ie: 15 here)
        assert self.col.DocA.find().count() == 15

        # fetch get only the corresponding documents:
        assert self.col.DocA.fetch().count() == 10, self.col.DocA.fetch().count()
        assert self.col.DocB.fetch().count() == 5
        index = 0
        for doc in self.col.DocA.fetch():
            assert doc == {'_id':doc['_id'], 'doc_a':{'foo':index}}, doc
            assert callable(doc) is False
            index += 1

        #assert DocA.fetch().limit(12).count() == 10, DocA.fetch().limit(1).count() # ???
        assert self.col.DocA.fetch().where('this.doc_a.foo > 3').count() == 6

    def test_fetch_with_query(self):
        class DocA(Document):
            structure = {
                "bar":unicode,
                "doc_a":{'foo':int},
            }
        class DocB(Document):
            structure = {
                "bar":unicode,
                "doc_b":{"bar":int},
            }
        self.connection.register([DocA, DocB])

        # creating DocA
        for i in range(10):
            mydoc = self.col.DocA()
            if i % 2 == 0:
                mydoc['bar'] = u"spam"
            else:
                mydoc['bar'] = u"egg"
            mydoc['doc_a']["foo"] = i
            mydoc.save()
        # creating DocB
        for i in range(5):
            mydoc = self.col.DocB()
            if i % 2 == 0:
                mydoc['bar'] = u"spam"
            else:
                mydoc['bar'] = u"egg"
            mydoc['doc_b']["bar"] = i
            mydoc.save()

        # all get all documents present in the collection (ie: 15 here)
        assert self.col.DocA.find().count() == 15
        assert self.col.DocA.fetch().count() == 10, self.col.DocA.fetch().count()
        assert self.col.DocB.fetch().count() == 5

        assert self.col.DocA.fetch({'bar':'spam'}).count() == 5
        assert self.col.DocB.fetch({'bar':'spam'}).count() == 3

    def test_fetch_inheritance(self):
        class Doc(Document):
            structure = {
                "doc":{'bla':int},
            }
        class DocA(Doc):
            structure = {
                "doc_a":{'foo':int},
            }
        class DocB(DocA):
            structure = {
                "doc_b":{"bar":int},
            }
        self.connection.register([Doc, DocA, DocB])
        # creating DocA
        for i in range(10):
            mydoc = self.col.DocA()
            mydoc['doc']["bla"] = i+1
            mydoc['doc_a']["foo"] = i
            mydoc.save()
        # creating DocB
        for i in range(5):
            mydoc = self.col.DocB()
            mydoc['doc']["bla"] = i+1
            mydoc['doc_a']["foo"] = i
            mydoc['doc_b']["bar"] = i+2
            mydoc.save()

        # all get all documents present in the collection (ie: 15 here)
        assert self.col.DocA.find().count() == 15

        # fetch get only the corresponding documents:
        # DocB is a subclass of DocA and have all fields of DocA so
        # we get all doc here
        assert self.col.DocA.fetch().count() == 15, self.col.DocA.fetch().count()
        # but only the DocB as DocA does not have a 'doc_a' field
        assert self.col.DocB.fetch().count() == 5
        index = 0
        for doc in self.col.DocB.fetch():
            assert doc == {'_id':doc['_id'], 'doc_a':{'foo':index}, 'doc':{'bla':index+1}, "doc_b":{'bar':index+2}}, (doc, index)
            index += 1

        #assert DocA.fetch().limit(12).count() == 10, DocA.fetch().limit(1).count() # ???
        assert self.col.DocA.fetch().where('this.doc_a.foo > 3').count() == 7

    def test_fetch_one(self):
        class DocA(Document):
            structure = {
                "doc_a":{'foo':int},
            }
        class DocB(DocA):
            structure = {
                "doc_b":{"bar":int},
            }
        self.connection.register([DocA, DocB])

        # creating DocA
        mydoc = self.col.DocA()
        mydoc['doc_a']["foo"] = 1
        mydoc.save()
        # creating DocB
        mydoc = self.col.DocB()
        mydoc['doc_b']["bar"] = 2
        mydoc.save()

        docb = self.col.DocB.fetch_one()
        assert callable(docb) is False
        assert docb
        assert isinstance(docb, DocB)
        self.assertRaises(MultipleResultsFound, self.col.DocA.fetch_one)

    def test_query_with_passing_collection(self):
        class MyDoc(Document):
            structure = {
                'foo':int,
            }
        self.connection.register([MyDoc])

        mongokit = self.connection.test.mongokit

        # boostraping
        for i in range(10):
            mydoc = mongokit.MyDoc()
            mydoc['_id'] = unicode(i)
            mydoc['foo'] = i
            mydoc.save()

        # get_from_id
        fetched_doc = mongokit.MyDoc.get_from_id('4')
        assert fetched_doc.collection == mongokit

        # all
        fetched_docs = mongokit.MyDoc.find({'foo':{'$gt':2}})
        assert fetched_docs.count() == 7
        for doc in fetched_docs:
            assert doc.collection == mongokit

        # one
        doc = mongokit.MyDoc.fetch_one({'foo':2})
        assert doc.collection == mongokit

        # fetch
        fetched_docs = mongokit.MyDoc.fetch({'foo':{'$gt':2}})
        assert fetched_docs.count() == 7
        for doc in fetched_docs:
            assert doc.collection == mongokit

        # fetch_one
        doc = mongokit.MyDoc.fetch_one({'foo':2})
        assert doc.collection == mongokit

    def test_skip_validation(self):
        class DocA(Document):
            structure = {
                "doc_a":{'foo':int},
            }
        self.connection.register([DocA])

        # creating DocA
        mydoc = self.col.DocA()
        mydoc['doc_a']["foo"] = u'bar'
        assertion = False
        try:
            mydoc.save()
        except SchemaTypeError:
            assertion = True
        assert assertion
        mydoc.save(validate=False)

        DocA.skip_validation = True

        # creating DocA
        mydoc = self.col.DocA()
        mydoc['doc_a']["foo"] = u'foo'
        self.assertRaises(SchemaTypeError, mydoc.save, validate=True)
        mydoc.save()


    def test_connection(self):
        class DocA(Document):
            structure = {
                "doc_a":{'foo':int},
            }
        self.connection.register([DocA])
        assertion = True
        try:
            DocA.connection
        except AttributeError:
            assertion = True
        assert assertion
        try:
            DocA.db
        except AttributeError:
            assertion = True
        assert assertion
        try:
            DocA.collection
        except AttributeError:
            assertion = True
        assert assertion

        assert self.col.DocA.connection == Connection("localhost", 27017)
        assert self.col.DocA.collection == Connection("localhost", 27017)['test']['mongokit']
        assert self.col.DocA.db == Connection("localhost", 27017)['test']

    def test_all_with_dynamic_collection(self):
        class Section(Document):
            structure = {"section":int}
        self.connection.register([Section])

        s = self.connection.test.section.Section()
        s['section'] = 1
        s.save()

        s = self.connection.test.section.Section()
        s['section'] = 2
        s.save()

        s = self.connection.test.other_section.Section()
        s['section'] = 1
        s.save()

        s = self.connection.test.other_section.Section()
        s['section'] = 2
        s.save()


        sect_col = self.connection.test.section
        sects = [s.collection.name == 'section' and s.db.name == 'test' for s in sect_col.Section.find({})]
        assert len(sects) == 2, len(sects)
        assert any(sects)
        sects = [s.collection.name == 'section' and s.db.name == 'test' for s in sect_col.Section.fetch()]
        assert len(sects) == 2
        assert any(sects)

        sect_col = self.connection.test.other_section
        sects = [s.collection.name == 'other_section' and s.db.name == 'test' for s in sect_col.Section.find({})]
        assert len(sects) == 2
        assert any(sects)
        sects = [s.collection.name == 'other_section' and s.db.name == 'test' for s in sect_col.Section.fetch()]
        assert len(sects) == 2
        assert any(sects)

    def test_get_collection_with_connection(self):
        class Section(Document):
            structure = {"section":int}
        connection = Connection('localhost')
        connection.register([Section])
        col = connection.test.mongokit
        assert col.database.connection == col.Section.connection
        assert col.database.name == 'test' == col.Section.db.name
        assert col.name == 'mongokit' == col.Section.collection.name

    def test_get_size(self):
        class MyDoc(Document):
            structure = {
                "doc":{"foo":int, "bla":unicode},
            }
        self.connection.register([MyDoc])

        mydoc = self.col.MyDoc()
        mydoc['doc']['foo'] = 3
        mydoc['doc']['bla'] = u'bla bla'
        assert mydoc.get_size() == 41, mydoc.get_size()

        mydoc['doc']['bla'] = u'bla bla'+'b'*12
        assert mydoc.get_size() == 41+12

        mydoc.validate()

        mydoc['doc']['bla'] = u'b'*40000000
        self.assertRaises(MaxDocumentSizeError, mydoc.validate)

    def test_get_with_no_wrap(self):
        class MyDoc(Document):
            structure = {"foo":int}
        self.connection.register([MyDoc])

        for i in xrange(2000):
            mydoc = self.col.MyDoc()
            mydoc['foo'] = i
            mydoc.save()

        import time
        start = time.time()
        wrapped_mydocs = [i for i in self.col.MyDoc.find()]
        end = time.time()
        wrap_time = end-start

        start = time.time()
        mydocs = [i for i in self.col.find().sort('foo', -1)]
        end = time.time()
        no_wrap_time = end-start

        assert no_wrap_time < wrap_time

        assert isinstance(wrapped_mydocs[0], MyDoc)
        assert not isinstance(mydocs[0], MyDoc), type(mydocs[0])
        assert [i['foo'] for i in mydocs] == list(reversed(range(2000))), [i['foo'] for i in mydocs]
        assert mydocs[0]['foo'] == 1999, mydocs[0]['foo']

        assert not isinstance(self.col.find().sort('foo', -1).next(), MyDoc)

    def test_get_dbref(self):
        class MyDoc(Document):
            structure = {"foo":int}
        self.connection.register([MyDoc])

        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'1'
        mydoc['foo'] = 1
        mydoc.save()

        mydoc = self.connection.test.othercol.MyDoc()
        mydoc['_id'] = u'2'
        mydoc['foo'] = 2
        mydoc.save()

        mydoc = self.connection.othertest.mongokit.MyDoc()
        mydoc['_id'] = u'3'
        mydoc['foo'] = 3
        mydoc.save()

        mydoc = self.col.MyDoc.find_one({'foo':1})
        assert mydoc.get_dbref(), DBRef(u'mongokit', u'1', u'test')

        mydoc = self.connection.test.othercol.MyDoc.find_one({'foo':2})
        assert mydoc.get_dbref() == DBRef(u'othercol', u'2', u'test')

        mydoc = self.connection.othertest.mongokit.MyDoc.find_one({'foo':3})
        assert mydoc.get_dbref() == DBRef(u'mongokit', u'3', u'othertest')

    def test__hash__(self):
        class MyDoc(Document):
            structure = {"foo":int}
        self.connection.register([MyDoc])

        mydoc = self.col.MyDoc()
        mydoc['foo'] = 1
        self.assertRaises(TypeError, hash, mydoc)

        mydoc.save()
        hash(mydoc)

    def test_non_callable(self):
        class MyDoc(Document):
            structure = {"foo":int}
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        self.assertRaises(TypeError, mydoc)
        assert callable(mydoc) is False


    def test_bad_call(self):
        class MyDoc(Document):
            structure = {"foo":int}
        self.assertRaises(TypeError, self.connection.test.col.MyDoc)
        self.connection.register([MyDoc])
        self.connection.test.col.MyDoc()
        self.assertRaises(TypeError, self.connection.test.col.Bla)
        self.assertRaises(TypeError, self.connection.test.Bla)


    def test_fetched_dot_notation(self):
        class MyDoc(Document):
            use_dot_notation = True
            structure = {
                "foo":int,
                "bar":{"egg":unicode},
                "toto":{"spam":{"bla":int}}
            }

        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc.foo = 3
        mydoc.bar.egg = u'bla'
        mydoc.toto.spam.bla = 7
        mydoc.save()
        fetched_doc = self.col.MyDoc.find_one()
        assert fetched_doc.foo == 3, fetched_doc.foo
        assert fetched_doc.bar.egg == "bla", fetched_doc.bar.egg
        self.assertEqual(fetched_doc.toto.spam.bla, 7)


    def test_validate_doc_with_field_added_after_save(self):
        class Doc(Document):
           structure = {
               "foo": unicode,
           }
        self.connection.register([Doc])

        doc = self.col.Doc()
        doc['foo'] = u"bla"
        doc.save()
        doc['bar'] = 2
        self.assertRaises(StructureError, doc.validate)

    def test_distinct(self):
        class Doc(Document):
            structure = {
                "foo": unicode,
                "bla": int
            }
        self.connection.register([Doc])

        for i in range(15):
            if i % 2 == 0:
                foo = u"blo"
            else:
                foo = u"bla"
            doc = self.col.Doc(doc={'foo':foo, 'bla':i})
            doc.save()
        assert self.col.find().distinct('foo') == ['blo', 'bla']
        assert self.col.find().distinct('bla') == range(15)

    def test_explain(self):
        class MyDoc(Document):
            structure = {
                "foo":int,
                "bar":{"bla":int},
            }
        self.connection.register([MyDoc])
        for i in range(10):
            mydoc = self.col.MyDoc()
            mydoc["foo"] = i
            mydoc["bar"]['bla'] = i
            mydoc.save()
        explain1 = self.col.MyDoc.find({"foo":{"$gt":4}}).explain()
        explain2 = self.col.find({'foo':{'gt':4}}).explain()
        explain1.pop('n')
        explain2.pop('n')
        explain1['allPlans'][0].pop('n')
        explain2['allPlans'][0].pop('n')
        self.assertEqual(explain1, explain2)

    def test_with_long(self):
        class Doc(Document):
            structure = {
                "foo":OR(int, long),
                "bar":unicode,
            }
        self.connection.register([Doc])
        doc = self.col.Doc()
        doc['foo'] = 12L
        doc.save()
        fetch_doc = self.col.Doc.find_one()
        fetch_doc['bar'] = u'egg'
        fetch_doc.save()

    def test_skip_validation_with_required_field(self):
        class Task(Document):
            structure = {
                'extra' : unicode,
            }
            required_fields = ['extra']
            skip_validation = True
        self.connection.register([Task])
        task = self.col.Task()
        task['extra'] = u'foo'
        task.validate()

    def test_passing_collection_in_argument(self):
        class MyDoc(Document):
            structure = {
                'foo':unicode
            }
        doc = MyDoc(collection=self.col)
        doc['foo'] = u'bla'
        doc.save()

    def test_reload(self):
        class MyDoc(Document):
            structure = {
                'foo':{
                    'bar':unicode,
                    'eggs':{'spam':int},
                },
                'bla':unicode
            }
        self.connection.register([MyDoc])

        doc = self.col.MyDoc()
        self.assertRaises(KeyError, doc.reload)
        doc['_id'] = 3
        doc['foo']['bar'] = u'mybar'
        doc['foo']['eggs']['spam'] = 4
        doc['bla'] = u'ble'
        self.assertRaises(OperationFailure, doc.reload)
        doc.save()

        doc['bla'] = u'bli'

        self.col.update({'_id':doc['_id']}, {'$set':{'foo.eggs.spam':2}})

        doc.reload()
        assert doc == {'_id': 3, 'foo': {u'eggs': {u'spam': 2}, u'bar': u'mybar'}, 'bla': u'ble'}

    def test_rewind(self):
        class MyDoc(Document):
            structure = {
                'foo':int,
            }
        self.connection.register([MyDoc])

        for i in range(10):
            doc = self.col.MyDoc()
            doc['foo'] = i
            doc.save()

        cur = self.col.MyDoc.find()
        for i in cur:
            assert isinstance(i, MyDoc), type(MyDoc)
        try:
            cur.next()
        except StopIteration:
            pass
        cur.rewind()
        for i in cur:
            assert isinstance(i, MyDoc), type(MyDoc)
        for i in cur.rewind():
            assert isinstance(i, MyDoc), type(MyDoc)


    def test_decorator(self):
        @self.connection.register
        class MyDoc(Document):
            structure = {
                'foo':int,
            }

        mydoc = self.col.MyDoc()
        mydoc['foo'] = 3
        mydoc.save()

        raw_doc = self.col.MyDoc.find_one()
        self.assertEqual(raw_doc['foo'], 3)
        assert isinstance(raw_doc, MyDoc)


    def test_collection_name_filled(self):

        @self.connection.register
        class MyDoc(Document):
            __collection__ = 'mydoc'
            structure = {
                'foo':int,
            }

        mydoc = self.connection.test.MyDoc()
        mydoc['foo'] = 3
        mydoc.save()
        self.assertEqual(mydoc.collection.name, 'mydoc')

        raw_doc = self.connection.test.MyDoc.find_one()
        self.assertEqual(self.col.MyDoc.find_one(), None)
        self.assertEqual(raw_doc['foo'], 3)
        self.assertEqual(raw_doc, mydoc)
        assert isinstance(raw_doc, MyDoc)

        mydoc = self.col.MyDoc()
        mydoc['foo'] = 3
        mydoc.save()
        self.assertEqual(mydoc.collection.name, 'mongokit')

        raw_doc = self.col.MyDoc.find_one()
        self.assertEqual(raw_doc['foo'], 3)
        self.assertEqual(raw_doc, mydoc)
        assert isinstance(raw_doc, MyDoc)

    def test_database_name_filled(self):

        failed = False
        @self.connection.register
        class MyDoc(Document):
            __database__ = 'mydoc'
            structure = {
                'foo':int,
            }
        try:
            doc = self.connection.MyDoc()
        except AttributeError, e:
            failed = True
            self.assertEqual(str(e), 'MyDoc: __collection__ attribute not '
              'found. You cannot specify the `__database__` attribute '
              'without the `__collection__` attribute')
        self.assertEqual(failed, True)

        @self.connection.register
        class MyDoc(Document):
            __database__ = 'test'
            __collection__ = 'mydoc'
            structure = {
                'foo':int,
            }

        # test directly from a connection
        mydoc = self.connection.MyDoc()
        mydoc['foo'] = 3
        mydoc.save()
        self.assertEqual(mydoc.collection.name, 'mydoc')
        self.assertEqual(mydoc.collection.database.name, 'test')
        self.assertEqual(self.col.MyDoc.find_one(), None)

        raw_doc = self.connection.MyDoc.find_one()
        self.assertEqual(raw_doc['foo'], 3)
        self.assertEqual(raw_doc, mydoc)
        assert isinstance(raw_doc, MyDoc)

        # test directly from a database
        mydoc = self.connection.othertest.MyDoc()
        mydoc['foo'] = 3
        mydoc.save()
        self.assertEqual(mydoc.collection.name, 'mydoc')
        self.assertEqual(mydoc.collection.database.name, 'othertest')
        self.assertEqual(self.col.MyDoc.find_one(), None)

        raw_doc = self.connection.othertest.MyDoc.find_one()
        self.assertEqual(raw_doc['foo'], 3)
        self.assertEqual(raw_doc, mydoc)
        assert isinstance(raw_doc, MyDoc)

        # and still can use it via a collection
        mydoc = self.col.MyDoc()
        mydoc['foo'] = 3
        mydoc.save()
        self.assertEqual(mydoc.collection.name, 'mongokit')
        self.assertEqual(mydoc.collection.database.name, 'test')

        raw_doc = self.col.MyDoc.find_one()
        self.assertEqual(raw_doc['foo'], 3)
        self.assertEqual(raw_doc, mydoc)
        assert isinstance(raw_doc, MyDoc)


    def test_no_collection_in_virtual_document(self):
        @self.connection.register
        class Root(Document):
            __database__ = "test"

        @self.connection.register
        class DocA(Root):
           __collection__ = "doca"
           structure = {'title':unicode}

        doc = self.connection.DocA()
        doc['title'] = u'foo'
        doc.save()

        self.assertEqual(self.connection.test.doca.find_one(), doc)


    def test_basestring_type(self):
        @self.connection.register
        class DocA(Document):
           __database__ = 'test'
           __collection__ = "doca"
           structure = {'title':unicode}

        doc = self.connection.DocA()
        doc['title'] = 'foo'
        failed = False
        try:
            doc.save()
        except SchemaTypeError, e:
            self.assertEqual(str(e), "title must be an instance of unicode not str")
            failed = True
        self.assertEqual(failed, True)

        @self.connection.register
        class DocA(Document):
           __database__ = 'test'
           __collection__ = "doca"
           authorized_types = Document.authorized_types+[str]
           structure = {'title':str}

        doc = self.connection.DocA()
        doc['title'] = u'foo'
        failed = False
        try:
            doc.save()
        except SchemaTypeError, e:
            self.assertEqual(str(e), "title must be an instance of str not unicode")
            failed = True
        self.assertEqual(failed, True)


        @self.connection.register
        class DocA(Document):
           __database__ = 'test'
           __collection__ = "doca"
           structure = {'title':basestring}

        doc = self.connection.DocA()
        doc['title'] = u'foo'
        doc.save()
        doc['title'] = 'foo'
        doc.save()

        self.assertEqual(self.connection.test.doca.find_one(), doc)

    def test_float_and_int_types(self):
        @self.connection.register
        class DocA(Document):
           __database__ = 'test'
           __collection__ = "doca"
           structure = {'foo':int}

        doc = self.connection.DocA()
        doc['foo'] = 3.0
        failed = False
        try:
            doc.save()
        except SchemaTypeError, e:
            self.assertEqual(str(e), "foo must be an instance of int not float")
            failed = True
        self.assertEqual(failed, True)

        @self.connection.register
        class DocA(Document):
           __database__ = 'test'
           __collection__ = "doca"
           authorized_types = Document.authorized_types+[str]
           structure = {'foo':float}

        doc = self.connection.DocA()
        doc['foo'] = 2
        failed = False
        try:
            doc.save()
        except SchemaTypeError, e:
            self.assertEqual(str(e), "foo must be an instance of float not int")
            failed = True
        self.assertEqual(failed, True)


        @self.connection.register
        class DocA(Document):
           __database__ = 'test'
           __collection__ = "doca"
           structure = {'foo':OR(int, float)}

        doc = self.connection.DocA()
        doc['foo'] = 3
        doc.save()
        doc['foo'] = 2.0
        doc.save()

        self.assertEqual(self.connection.test.doca.find_one(), doc)

    def test_cursor_slicing(self):
        @self.connection.register
        class DocA(Document):
            structure = {'foo':int}

        for i in range(10):
            doc = self.col.DocA()
            doc['foo'] = i
            doc.save()

        self.assertEqual(isinstance(self.col.DocA.find()[0], DocA), True)
        self.assertEqual(isinstance(self.col.DocA.find()[3], DocA), True)
        self.assertEqual(isinstance(self.col.DocA.find()[3:], self.col.DocA.find().__class__), True)

    def test_unwrapped_cursor(self):
        self.assertEqual(self.col.count(), 0)

        doc_id = self.col.save({}, safe=True)
        self.assertEqual(self.col.count(), 1)

        try:
            self.col.find(_id=doc_id)[0]

        except TypeError:
            self.fail("Cursor.__getitem__ raised TypeError unexpectedly!")

    def test_pass_connection_arguments_to_cursor(self):
        class MyDoc(Document):
            structure = {
                "foo":int,
                "bar":{"bla":int},
            }
        con = Connection(read_preference=ReadPreference.SECONDARY_PREFERRED,
            secondary_acceptable_latency_ms=16)
        con.register([MyDoc])
        col = con['test']['mongokit']
        assert col.MyDoc.find()._Cursor__read_preference == ReadPreference.SECONDARY_PREFERRED
        assert col.MyDoc.find()._Cursor__secondary_acceptable_latency_ms == 16
        con.close()

########NEW FILE########
__FILENAME__ = test_auth
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest

from mongokit import *
from mongokit.auth import User
from bson.objectid import ObjectId

import logging
logging.basicConfig()

class AuthTestCase(unittest.TestCase):
    def setUp(self):
        self.connection = Connection()
        self.col = self.connection['test']['mongokit']
        
    def tearDown(self):
        self.connection['test'].drop_collection('mongokit')
        self.connection['test'].drop_collection('versionned_mongokit')

    def test_password_validation(self):
        class SimpleUser(User): pass
        self.connection.register([SimpleUser])

        user = self.col.SimpleUser()
        user.login = u"user"
        self.assertRaises(RequireFieldError, user.validate)
        user.password = "myp4$$ord"

        assert user.verify_password("bla") == False
        assert user.verify_password("myp4$$ord") == True
        assert len(user.password) == len(user['user']['password']) == 80
        
        del user.password
        assert user.password is None
        assert user['user']['password'] is None
    
    def test_create_user(self):
        class SimpleUser(User): pass
        self.connection.register([SimpleUser])

        user = self.col.SimpleUser()
        user.login = u"user"
        user.email = u"user@foo.bar"
        user.password = u"u$ser_p4$$w0rd"
        print "", user
        user.save()

        saved_user = self.col.SimpleUser.get_from_id('user')
        assert saved_user.verify_password("bad") == False
        assert saved_user.verify_password(u"u$ser_p4$$w0rd") == True

        assert user.login == u"user"
        assert user['_id'] == u'user'
        assert user['user']['login'] == u'user'
        del user.login
        assert user['_id'] is None
        assert user['user']['login'] is None
        assert user.login is None

        assert user.email == user['user']['email'] == u'user@foo.bar'
        del user.email
        assert user['user']['email'] is None
        assert user.email is None

    def test_overload_user(self):
        class SimpleUser(User):
            structure = {
                "auth":{
                    "session_id":unicode,
                },
                "profil":{
                    "name":unicode,
                }
            }
        self.connection.register([SimpleUser])

        user = self.col.SimpleUser()
        user.login = u"user"
        user.email = u"user@foo.bar"
        user.password = "u$ser_p4$$w0rd"
        user.save()

        saved_user = self.col.SimpleUser.get_from_id('user')
        assert saved_user.verify_password("bad") == False
        assert saved_user.verify_password("u$ser_p4$$w0rd") == True



########NEW FILE########
__FILENAME__ = test_autoref
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest
import logging

logging.basicConfig(level=logging.DEBUG)

from mongokit import *
from bson.objectid import ObjectId

class AutoRefTestCase(unittest.TestCase):
    """Tests AutoRef case"""
    def setUp(self):
        self.connection = Connection()
        self.col = self.connection['test']['mongokit']
        
    def tearDown(self):
        self.connection.drop_database('test')
        self.connection.drop_database('test2')

    def test_simple_autoref(self):
        class DocA(Document):
            structure = {
                "a":{'foo':int},
            }
        self.connection.register([DocA])

        doca = self.col.DocA()
        doca['_id'] = 'doca'
        doca['a']['foo'] = 3
        doca.save()

        class DocB(Document):
            structure = {
                "b":{"doc_a":DocA},
            }
            use_autorefs = True
        self.connection.register([DocB])

        docb = self.col.DocB()
        # the structure is automaticly filled by the corresponding structure
        assert docb == {'b': {'doc_a':None}}, docb
        #docb.validate()
        docb['_id'] = 'docb'
        docb['b']['doc_a'] = 4
        self.assertRaises(SchemaTypeError, docb.validate)
        docb['b']['doc_a'] = doca
        assert docb == {'b': {'doc_a': {'a': {'foo': 3}, '_id': 'doca'}}, '_id': 'docb'}
        docb.save()
        saved_docb = self.col.find_one({'_id':'docb'})
        _docb = self.col.DocB.get_from_id('docb')
        assert saved_docb['b']['doc_a'] == DBRef(database='test', collection='mongokit', id='doca'), saved_docb['b']['doc_a']

        docb_list = list(self.col.DocB.fetch())
        assert len(docb_list) == 1
        new_docb = docb_list[0]
        assert isinstance(new_docb['b']['doc_a'], DocA), new_docb['b']['doc_a'].__class__
        assert docb == {'b': {'doc_a': {'a': {'foo': 3}, '_id': 'doca'}}, '_id': 'docb'}, docb
        assert docb['b']['doc_a']['a']['foo'] == 3
        docb['b']['doc_a']['a']['foo'] = 4
        docb.save()
        assert docb['b']['doc_a']['a']['foo'] == 4, docb
        assert self.col.DocA.fetch().next()['a']['foo'] == 4
        assert doca['a']['foo'] == 4, doca['a']['foo']
        saved_docb = self.col.DocB.collection.find_one({'_id':'docb'})
        assert saved_docb['b']['doc_a'] == DBRef(database='test', collection='mongokit', id='doca'), saved_docb['b']['doc_a']
        assert self.col.DocB.fetch_one() == docb
        assert self.col.DocB.find_one({'_id':'docb'}) == docb

    def test_simple_autoref2(self):
        class Embed(Document):
            structure = {
                'foo': dict,
                'bar': int,
            }

        class Doc(Document):
            structure = {
                'embed':Embed,
                'eggs': unicode,
            }
            use_autorefs = True
        self.connection.register([Embed, Doc])

        embed = self.col.Embed()
        embed['foo'] = {'hello':u'monde'}
        embed['bar'] = 3
        embed.save()

        doc = self.col.Doc()
        doc['embed'] = embed
        doc['eggs'] = u'arf'
        doc.save()

        assert doc == {'embed': {u'_id': embed['_id'], u'bar': 3, u'foo': {u'hello': u'monde'}}, '_id': doc['_id'], 'eggs': u'arf'}, doc

        doc = self.col.Doc.fetch_one()
        doc['embed']['foo']['hello'] = u'World'
        doc.save()

        assert doc == {'embed': {u'_id': embed['_id'], u'bar': 3, u'foo': {u'hello': u'World'}}, '_id': doc['_id'], 'eggs': u'arf'}, doc
        assert self.col.Embed.fetch_one() == {u'_id': embed['_id'], u'bar': 3, u'foo': {u'hello': u'World'}}

    def test_autoref_with_default_values(self):
        class DocA(Document):
            structure = {
                "a":{'foo':int},
                "abis":{'bar':int},
            }
        self.connection.register([DocA])
        doca = self.col.DocA()
        doca['_id'] = 'doca'
        doca['a']['foo'] = 2
        doca.save()

        class DocB(Document):
            structure = {
                "b":{"doc_a":DocA},
            }
            use_autorefs = True
            default_values = {'b.doc_a':doca}
        self.connection.register([DocB])

        docb = self.col.DocB()
        assert docb == {'b': {'doc_a': {'a': {'foo': 2}, 'abis': {'bar': None}, '_id': 'doca'}}}, docb
        docb.save()

    def test_autoref_with_required_fields(self):
        class DocA(Document):
            structure = {
                "a":{'foo':int},
                "abis":{'bar':int},
            }
            required_fields = ['a.foo']
        self.connection.register([DocA])

        doca = self.col.DocA()
        doca['_id'] = 'doca'
        doca['a']['foo'] = 2
        doca.save()

        class DocB(Document):
            db_name = "test"
            collection_name = "mongokit"
            structure = {
                "b":{"doc_a":DocA},
            }
            use_autorefs = True
        self.connection.register([DocB])

        docb = self.col.DocB()
        docb['b']['doc_a'] = doca
        assert docb == {'b': {'doc_a': {'a': {'foo': 2}, 'abis': {'bar': None}, '_id': 'doca'}}}, docb
        docb['_id'] = 'docb'
        docb['b']['doc_a']['a']['foo'] = None 
        self.assertRaises(RequireFieldError, docb.validate)
        docb['b']['doc_a']['a']['foo'] = 4 
        docb.save()
    
        docb['b']['doc_a'] = None
        docb.save()

    def test_badautoref(self):
        """Test autoref enabled, but embed the wrong kind of document.
        Assert that it tells us it's a bad embed.
        """
        class EmbedDoc(Document):
            structure = {
                "spam": unicode
            }
        self.connection.register([EmbedDoc])
        embed = self.col.EmbedDoc()
        embed["spam"] = u"eggs"
        embed.save()
        assert embed

        class EmbedOtherDoc(Document):
            structure = {
                "ham": unicode
            }
        self.connection.register([EmbedOtherDoc])
        embedOther = self.connection.test.embed_other.EmbedOtherDoc()
        embedOther["ham"] = u"eggs"
        embedOther.save()
        assert embedOther

        class MyDoc(Document):
            use_autorefs = True
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam": EmbedDoc,
            }
            use_autorefs = True
        self.connection.register([MyDoc])
        mydoc = self.connection.test.autoref.MyDoc()
        mydoc["bla"]["foo"] = u"bar"
        mydoc["bla"]["bar"] = 42
        mydoc["spam"] = embedOther
        
        self.assertRaises(SchemaTypeError, mydoc.save) 
  
    def test_badautoref_not_enabled(self):
        # Test that, if autoref is disabled
        # adding a Document to the structure act
        # like a regular dict

        class EmbedDoc(Document):
            structure = {
                "spam": unicode
            }
        self.connection.register([EmbedDoc])
        embed = self.connection.test['autoref.embed'].EmbedDoc()
        embed["spam"] = u"eggs"
        embed.save()
        assert embed

        class MyDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam": EmbedDoc,
            }
        self.connection.register([MyDoc])
        doc = self.col.MyDoc()
        self.assertEqual(doc, {'bla': {'foo': None, 'bar': None}, 'spam': None})

    def test_subclass(self):
        # Test autoref enabled, but embed a subclass.
        # e.g. if we say EmbedDoc, a subclass of EmbedDoc 
        # is also valid.
        
        class EmbedDoc(Document):
            structure = {
                "spam": unicode
            }
        self.connection.register([EmbedDoc])
        embed = self.connection.test['autoref.embed'].EmbedDoc()
        embed["spam"] = u"eggs"
        embed.save()

        class EmbedOtherDoc(EmbedDoc):
            structure = {
                "ham": unicode
            }
        self.connection.register([EmbedOtherDoc])
        embedOther = self.connection.test['autoref.embed_other'].EmbedOtherDoc()
        embedOther["ham"] = u"eggs"
        embedOther.save()
        assert embedOther

        class MyDoc(Document):
            use_autorefs = True
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam": EmbedDoc,
            }
        self.connection.register([MyDoc])
        mydoc = self.connection.test.autoref.MyDoc()
        mydoc["bla"]["foo"] = u"bar"
        mydoc["bla"]["bar"] = 42
        mydoc["spam"] = embedOther
        
        mydoc.save()
        assert mydoc['spam'].collection.name == "autoref.embed_other"
        assert mydoc['spam'] == embedOther

    def test_autoref_in_list(self):
        class DocA(Document):
            structure = {
                "a":{'foo':int},
            }
        self.connection.register([DocA])

        doca = self.col.DocA()
        doca['_id'] = 'doca'
        doca['a']['foo'] = 3
        doca.save()

        doca2 = self.col.DocA()
        doca2['_id'] = 'doca2'
        doca2['a']['foo'] = 5
        doca2.save()

        class DocB(Document):
            structure = {
                "b":{"doc_a":[DocA]},
            }
            use_autorefs = True
        self.connection.register([DocB])

        docb = self.col.DocB()
        # the structure is automatically filled by the corresponding structure
        assert docb == {'b': {'doc_a':[]}}, docb
        docb.validate()
        docb['_id'] = 'docb'
        docb['b']['doc_a'].append(u'bla')
        self.assertRaises(SchemaTypeError, docb.validate)
        docb['b']['doc_a'] = []
        docb['b']['doc_a'].append(doca)
        assert docb == {'b': {'doc_a': [{'a': {'foo': 3}, '_id': 'doca'}]}, '_id': 'docb'}
        docb.save()
        assert isinstance(docb.collection.find_one({'_id':'docb'})['b']['doc_a'][0], DBRef), type(docb.collection.find_one({'_id':'docb'})['b']['doc_a'][0])

        assert docb == {'b': {'doc_a': [{'a': {'foo': 3}, '_id': 'doca'}]}, '_id': 'docb'}
        assert docb['b']['doc_a'][0]['a']['foo'] == 3
        docb['b']['doc_a'][0]['a']['foo'] = 4
        docb.save()
        assert docb['b']['doc_a'][0]['a']['foo'] == 4, docb['b']['doc_a'][0]['a']['foo']
        assert doca['a']['foo'] == 4, doca['a']['foo']

        docb['b']['doc_a'].append(doca2)
        assert docb == {'b': {'doc_a': [{'a': {'foo': 4}, '_id': 'doca'}, {'a': {'foo': 5}, '_id': 'doca2'}]}, '_id': 'docb'}
        docb.validate()
    
    def test_autoref_retrieval(self):
        class DocA(Document):
            structure = {
                "a":{'foo':int},
            }
        self.connection.register([DocA])

        doca = self.col.DocA()
        doca['_id'] = 'doca'
        doca['a']['foo'] = 3
        doca.save()

        class DocB(Document):
            structure = {
                "b":{
                    "doc_a":DocA,
                    "deep": {"doc_a_deep":DocA}, 
                    "deeper": {"doc_a_deeper":DocA,
                               "inner":{"doc_a_deepest":DocA}}
                },
                
            }
            use_autorefs = True
        self.connection.register([DocB])

        docb = self.col.DocB()
        # the structure is automatically filled by the corresponding structure
        docb['_id'] = 'docb'
        docb['b']['doc_a'] = doca
    
        # create a few deeper  docas
        deep = self.col.DocA()
        #deep['_id'] = 'deep' 
        deep['a']['foo'] = 5
        deep.save()
        docb['b']['deep']['doc_a_deep'] = deep
        deeper = self.col.DocA()
        deeper['_id'] = 'deeper'
        deeper['a']['foo'] = 8
        deeper.save()
        docb['b']['deeper']['doc_a_deeper'] = deeper
        deepest = self.col.DocA()
        deepest['_id'] = 'deepest'
        #deepest['_id'] = 'deeper'
        deepest['a']['foo'] = 18
        deepest.save()
        docb['b']['deeper']['inner']['doc_a_deepest'] = deepest

        docb.save()

        # now, does retrieval function as expected?
        test_doc = self.col.DocB.get_from_id(docb['_id'])
        assert isinstance(test_doc['b']['doc_a'], DocA), type(test_doc['b']['doc_a'])
        assert test_doc['b']['doc_a']['a']['foo'] == 3
        assert isinstance(test_doc['b']['deep']['doc_a_deep'], DocA)
        assert test_doc['b']['deep']['doc_a_deep']['a']['foo'] == 5
        assert isinstance(test_doc['b']['deeper']['doc_a_deeper'], DocA)
        assert test_doc['b']['deeper']['doc_a_deeper']['a']['foo'] == 8, test_doc
        assert isinstance(test_doc['b']['deeper']['inner']['doc_a_deepest'], DocA)
        assert test_doc['b']['deeper']['inner']['doc_a_deepest']['a']['foo'] == 18

    def test_autoref_with_same_embed_id(self):
        class DocA(Document):
            structure = {
                "a":{'foo':int},
            }
        self.connection.register([DocA])

        doca = self.col.DocA()
        doca['_id'] = 'doca'
        doca['a']['foo'] = 3
        doca.save()

        class DocB(Document):
            structure = {
                "b":{
                    "doc_a":DocA,
                    "deep": {"doc_a_deep":DocA}, 
                },
                
            }
            use_autorefs = True
        self.connection.register([DocB])

        docb = self.col.DocB()
        docb['_id'] = 'docb'
        docb['b']['doc_a'] = doca
        # create a few deeper  docas
        deep = self.col.DocA()
        deep['_id'] = 'doca' # XXX same id of doca, this will be erased by doca when saving docb
        deep['a']['foo'] = 5
        deep.save()
        docb['b']['deep']['doc_a_deep'] = deep

        docb.save()

        test_doc = self.col.DocB.get_from_id(docb['_id'])
        assert test_doc['b']['doc_a']['a']['foo'] == 3, test_doc['b']['doc_a']['a']
        assert test_doc['b']['deep']['doc_a_deep']['a']['foo'] == 3, test_doc['b']['deep']['doc_a_deep']['a']['foo']

    def test_autorefs_embed_in_list_with_bad_reference(self):
        class User(Document):
            structure = {'name':unicode}
        self.connection.register([User])

        class Group(Document):
            use_autorefs = True
            structure = {
                   'name':unicode,
                   'members':[User], #users
               }
        self.connection.register([User, Group])

        user = self.col.User()
        user['_id'] = u'fixe'
        user['name'] = u'fixe'
        user.save()

        user2 = self.col.User()
        user['_id'] = u'namlook'
        user2['name'] = u'namlook'
        user2.save()

        group = self.col.Group()
        group['members'].append(user)
        self.assertRaises(AutoReferenceError, group.save)

    def test_autorefs_with_dynamic_collection(self):
        class DocA(Document):
            structure = {'a':unicode}

        class DocB(Document):
            structure = {'b':DocA}
            use_autorefs = True
        self.connection.register([DocA, DocB])

        doca = self.connection.test.doca.DocA()
        doca['a'] = u'bla'
        doca.save()

        docb = self.connection.test.docb.DocB()
        docb['b'] = doca
        docb.save()

        assert docb['b']['a'] == 'bla'
        assert docb['b'].collection.name == "doca"

        doca2 = self.connection.test.doca2.DocA()
        doca2['a'] = u'foo'
        doca2.save()

        docb2 = self.connection.test.docb.DocB()
        docb2['b'] = doca2
        docb2.save()

        assert docb2['b']['a'] == 'foo' 
        assert docb2['b'].collection.name == 'doca2'
        assert docb2.collection.name == 'docb'

        assert list(self.connection.test.docb.DocB.fetch()) == [docb, docb2]
        
    def test_autorefs_with_dynamic_db(self):
        class DocA(Document):
            structure = {'a':unicode}

        class DocB(Document):
            structure = {'b':DocA}
            use_autorefs = True
        self.connection.register([DocA, DocB])

        doca = self.connection.dba.mongokit.DocA()
        doca['a'] = u'bla'
        doca.save()

        docb = self.connection.dbb.mongokit.DocB()
        docb['b'] = doca
        docb.save()

        assert docb['b']['a'] == 'bla'
        docb = self.connection.dbb.mongokit.DocB.get_from_id(docb['_id'])
        assert isinstance(docb['b'], DocA)

    def test_autoref_without_validation(self):
        class DocA(Document):
            structure = {
                "a":{'foo':int},
            }
        self.connection.register([DocA])

        doca = self.col.DocA()
        doca['_id'] = 'doca'
        doca['a']['foo'] = 3
        doca.save()

        class DocB(Document):
            structure = {
                "b":{"doc_a":DocA},
            }
            use_autorefs = True
            skip_validation = True
        self.connection.register([DocB])

        docb = self.col.DocB()
        docb['_id'] = 'docb'
        docb['b']['doc_a'] = doca
        docb.save()

    def test_autoref_updated(self):
        class DocA(Document):
            structure = {
                "a":{'foo':int},
            }
        self.connection.register([DocA])

        doca = self.col.DocA()
        doca['_id'] = 'doca'
        doca['a']['foo'] = 3
        doca.save()

        doca2 = self.col.DocA()
        doca2['_id'] = 'doca2'
        doca2['a']['foo'] = 6
        doca2.save()

        class DocB(Document):
            structure = {
                "b":{"doc_a":[DocA]},
            }
            use_autorefs = True
        self.connection.register([DocB])

        docb = self.col.DocB()
        docb['_id'] = 'docb'
        docb.save()
        assert docb ==  {'b': {'doc_a': []}, '_id': 'docb'}
        docb['b']['doc_a'] = [doca, doca2]
        docb.save()
        assert docb == {'b': {'doc_a': [{u'a': {u'foo': 3}, u'_id': u'doca'}, {u'a': {u'foo': 6}, u'_id': u'doca2'}]}, '_id': 'docb'}
        docb['b']['doc_a'].pop(0)
        docb.save()
        assert docb == {'b': {'doc_a': [{u'a': {u'foo': 6}, u'_id': u'doca2'}]}, '_id': 'docb'}
        fetched_docb = self.col.DocB.get_from_id('docb')
        assert fetched_docb == {u'_id': u'docb', u'b': {u'doc_a': [{u'a': {u'foo': 6}, u'_id': u'doca2'}]}}

        docb = self.col.DocB()
        docb['_id'] = 'docb'
        docb.save()
        assert docb ==  {'b': {'doc_a': []}, '_id': 'docb'}
        docb['b']['doc_a'] = [doca, doca2]
        docb.save()
        assert docb == {'b': {'doc_a': [{u'a': {u'foo': 3}, u'_id': u'doca'}, {u'a': {u'foo': 6}, u'_id': u'doca2'}]}, '_id': 'docb'}, docb
        docb['b']['doc_a'].pop(0)
        docb['b']['doc_a'].append(doca)
        docb.save()
        assert docb == {'b': {'doc_a': [{u'a': {u'foo': 6}, u'_id': u'doca2'}, {u'a': {u'foo': 3}, u'_id': u'doca'}]}, '_id': 'docb'}, docb
        fetched_docb = self.col.DocB.get_from_id('docb')
        assert fetched_docb == {u'_id': u'docb', u'b': {u'doc_a': [{u'a': {u'foo': 6}, u'_id': u'doca2'}, {u'a': {u'foo': 3}, u'_id': u'doca'}]}}

    def test_autoref_updated_with_default_values(self):
        class DocA(Document):
            structure = {
                "a":{'foo':int},
                   "abis":{'bar':int},
                }
            default_values = {'a.foo':2}
            required_fields = ['abis.bar']

        self.connection.register([DocA])
        doca = self.col.DocA()
        doca['_id'] = 'doca'
        doca['abis']['bar'] = 3
        doca.save()

        class DocB(Document):
            structure = {
                "b":{"doc_a":DocA},
            }
            use_autorefs = True

        self.connection.register([DocB])
        docb = self.col.DocB()
        docb['_id'] = 'docb'
        docb['b']['doc_a'] = doca
        assert docb == {'b': {'doc_a': {'a': {'foo': 2}, 'abis': {'bar': 3}, '_id': 'doca'}}, '_id': 'docb'}, docb
        docb['b']['doc_a']['a']['foo'] = 4
        docb.save()
        assert docb == {'b': {'doc_a': {'a': {'foo': 4}, 'abis': {'bar': 3}, '_id': 'doca'}}, '_id': 'docb'}, docb
        assert doca['a']['foo'] == 4

    def test_autoref_with_None(self):
        class RootDocument(Document):
           use_dot_notation=True
           use_autorefs = True
           structure = {}

        class User(RootDocument):
           collection_name = "users"
           structure = {
               "email": unicode,
               "password": unicode,
           }
           required_fields = [ "email", "password" ]
           indexes = [
               { "fields": "email",
                 "unique": True,
               },
           ]
        self.connection.register([User])
        User = self.col.User
        u = User()
        u['email'] = u'....'
        u['password'] = u'....'
        u.save()
        assert u['_id'] != None
    
        class ExampleSession(RootDocument):
           #collection_name = "sessions"
           use_autorefs = True
           structure   = {
               "user": User,
               "token": unicode,
           }
        # raise an assertion because User is a CallableUser, not User
        self.connection.register([ExampleSession])
        ex = self.col.ExampleSession()
        self.assertRaises(SchemaTypeError, ex.validate)

    def test_autoref_without_database_specified(self):
        class EmbedDoc(Document):
            use_dot_notation = True
            structure = {
               "foo": unicode,
            }

        class Doc(Document):
           use_dot_notation=True
           use_autorefs = True
           force_autorefs_current_db = True
           __database__ = "test"
           __collection__ = "mongokit"
           structure = {
               "embed": EmbedDoc,
           }
        self.connection.register([EmbedDoc, Doc])

        embed = self.connection.test.embed_docs.EmbedDoc()
        embed['foo'] = u'bar'
        embed.save()

        raw_doc = {'embed':DBRef(
            collection=self.connection.test.embed_docs.name,
            id=embed['_id'])
        }
        self.connection.test.mongokit.insert(raw_doc)
        doc = self.connection.Doc.find_one({'_id':raw_doc['_id']})
        assert isinstance(doc.embed, EmbedDoc)
        self.assertTrue(doc.embed.foo, u"bar")

    def test_recreate_and_reregister_class_with_reference(self):
        class CompanyDocument(Document):
            collection_name = "test_companies"
            use_autorefs = True
            use_dot_notation = True
            structure = {
                "name": unicode,
            }

        class UserDocument(Document):
            collection_name = "test_users"
            use_autorefs = True
            use_dot_notation = True
            structure = {
                "email": unicode,
                "company": CompanyDocument,
            }

        class SessionDocument(Document):
            collection_name = "test_sessions"
            use_autorefs = True
            use_dot_notation = True
            structure = {
                "token": unicode,
                "owner": UserDocument,
            }
        self.connection.register([CompanyDocument, UserDocument, SessionDocument])

        company = self.col.database[CompanyDocument.collection_name].CompanyDocument()
        company.name = u"Company"
        company.save()

        company_owner = self.col.database[UserDocument.collection_name].UserDocument()
        company_owner.email = u"manager@test.com"
        company_owner.company = company
        company_owner.save()

        s = self.col.database[SessionDocument.collection_name].SessionDocument()
        s.token = u'asddadsad'
        s.owner = company_owner
        s.save()

        sbis= self.col.database[SessionDocument.collection_name].SessionDocument.find_one({"token": u"asddadsad" })
        assert sbis == s, sbis

        class CompanyDocument(Document):
            collection_name = "test_companies"
            use_autorefs = True
            structure = {
                "name": unicode,
            }

        class UserDocument(Document):
            collection_name = "test_users"
            use_autorefs = True
            structure = {
                "email": unicode,
                "company": CompanyDocument,
            }

        class SessionDocument(Document):
            collection_name = "test_sessions"
            use_autorefs = True
            structure = {
                "token": unicode,
                "owner": UserDocument,
            }
        self.connection.register([CompanyDocument, UserDocument, SessionDocument])

        sbis= self.col.database[SessionDocument.collection_name].SessionDocument.find_one({"token": u"asddadsad" })
        assert sbis == s, sbis


    def test_nested_autorefs(self):
        class DocA(Document):
            structure = {
                'name':unicode,
              }
            use_autorefs = True

        class DocB(Document):
            structure = {
                'name': unicode,
                'doca' : DocA,
            }
            use_autorefs = True

        class DocC(Document):
            structure = {
                'name': unicode,
                'docb': DocB,
                'doca': DocA,
            }
            use_autorefs = True

        class DocD(Document):
            structure = {
                'name': unicode,
                'docc': DocC,
            }
            use_autorefs = True
        self.connection.register([DocA, DocB, DocC, DocD])

        doca = self.col.DocA()
        doca['name'] = u'Test A'
        doca.save()

        docb = self.col.DocB()
        docb['name'] = u'Test B'
        docb['doca'] = doca
        docb.save()

        docc = self.col.DocC()
        docc['name'] = u'Test C'
        docc['docb'] = docb
        docc['doca'] = doca
        docc.save()

        docd = self.col.DocD()
        docd['name'] = u'Test D'
        docd['docc'] = docc
        docd.save()

        doca = self.col.DocA.find_one({'name': 'Test A'})
        docb = self.col.DocB.find_one({'name': 'Test B'})
        docc = self.col.DocC.find_one({'name': 'Test C'})
        docd = self.col.DocD.find_one({'name': 'Test D'})


    def test_nested_autoref_in_list_and_dict(self):
        class DocA(Document):
            structure = {
                'name':unicode,
              }
            use_autorefs = True


        class DocB(Document):
            structure = {
                'name': unicode,
                'test': [{
                    'something' : unicode,
                    'doca' : DocA,
                }]
            }
            use_autorefs = True

        self.connection.register([DocA, DocB])

        doca = self.col.DocA()
        doca['name'] = u'Test A'
        doca.save()

        docc = self.col.DocA()
        docc['name'] = u'Test C'
        docc.save()

        docb = self.col.DocB()
        docb['name'] = u'Test B'
        docb['test'].append({u'something': u'foo', 'doca': doca})
        docb['test'].append({u'something': u'foo', 'doca': docc})
        docb.save()

        raw_docb = self.col.find_one({'name':'Test B'})
        assert isinstance(raw_docb['test'][0]['doca'], DBRef), raw_docb['test'][0]

    def test_dereference(self):

        class DocA(Document):
            structure = {
                'name':unicode,
              }
            use_autorefs = True

        self.connection.register([DocA])

        doca = self.col.DocA()
        doca['name'] = u'Test A'
        doca.save()

        docb = self.connection.test2.mongokit.DocA()
        docb['name'] = u'Test B'
        docb.save()

        dbref = doca.get_dbref()

        self.assertRaises(TypeError, self.connection.test.dereference, 1)
        self.assertRaises(ValueError, self.connection.test.dereference, docb.get_dbref(), DocA)
        assert self.connection.test.dereference(dbref) == {'_id':doca['_id'], 'name': 'Test A'}
        assert isinstance(self.connection.test.dereference(dbref), dict)
        assert self.connection.test.dereference(dbref, DocA) == {'_id':doca['_id'], 'name': 'Test A'}
        assert isinstance(self.connection.test.dereference(dbref, DocA), DocA)

    def test_autorefs_with_list(self):
        class VDocument(Document):
            db_name = 'MyDB'
            use_dot_notation = True
            use_autorefs = True
            skip_validation = True

            def __init__(self, *args, **kwargs):
                super(VDocument, self).__init__(*args, **kwargs)

            def save(self, *args, **kwargs):
                kwargs.update({'validate':True})
                return super(VDocument, self).save(*args, **kwargs)

        class H(VDocument):
            structure = {'name':[ObjectId], 'blah':[unicode], 'foo': [{'x':unicode}]}
        self.connection.register([H, VDocument])

        h = self.col.H()
        obj_id = ObjectId()
        h.name.append(obj_id)
        h.blah.append(u'some string')
        h.foo.append({'x':u'hey'})
        h.save()
        assert h == {'blah': [u'some string'], 'foo': [{'x': u'hey'}], 'name': [obj_id], '_id': h['_id']}

    def test_autorefs_with_list2(self):
        class DocA(Document):
            structure = {'name':unicode}

        class DocB(Document):
            structure = {
                'docs':[{
                    'doca': [DocA],
                    'inc':int,
                }],
            }
            use_autorefs = True

        self.connection.register([DocA, DocB])

        doca = self.col.DocA()
        doca['_id'] = u'doca'
        doca['name'] = u"foo"
        doca.save()

        self.col.insert(
          {'_id': 'docb', 'docs':[
            {
              'doca':[DBRef(database='test', collection='mongokit', id='doca')],
              'inc':2,
            },
          ]
        })
        assert self.col.DocB.find_one({'_id':'docb'}) == {u'docs': [{u'doca': [{u'_id': u'doca', u'name': u'foo'}], u'inc': 2}], u'_id': u'docb'}

    def test_autorefs_with_required(self):
        import datetime
        import uuid

        @self.connection.register
        class User(Document):
           structure = {
             'email': unicode,
           }

        @self.connection.register
        class Event(Document):
           structure = {
             'user': User,
             'title': unicode,
           }
           required_fields = ['user', 'title']
           use_autorefs = True

        user = self.connection.test.users.User()
        user.save()
        event = self.connection.test.events.Event()
        event['user'] = user
        event['title'] = u"Test"
        event.validate()
        event.save()


########NEW FILE########
__FILENAME__ = test_custom_types
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest

from mongokit import *

class CustomTypesTestCase(unittest.TestCase):
    def setUp(self):
        self.connection = Connection()
        self.col = self.connection['test']['mongokit']
        
    def tearDown(self):
        self.connection['test'].drop_collection('mongokit')
        self.connection['test'].drop_collection('test')

    def test_custom_type(self):
        import datetime

        class CustomDate(CustomType):
            mongo_type = unicode
            python_type = datetime.datetime
            def to_bson(self, value):
                """convert type to a mongodb type"""
                return unicode(datetime.datetime.strftime(value,'%y-%m-%d'))
            def to_python(self, value):
                """convert type to a python object"""
                if value is not None:
                    return datetime.datetime.strptime(value, '%y-%m-%d')
                
        class Foo(Document):
            structure = {
                "date": CustomDate(),
            }
            default_values = {'date':datetime.datetime(2008, 6, 7)}
        self.connection.register([Foo])
            
        foo = self.col.Foo()
        foo['_id'] = 1
        foo['date'] = datetime.datetime(2003,2,1)
        foo.save()
        saved_foo =  foo.collection.find({'_id':1}).next()
        assert saved_foo == {u'date': u'03-02-01', u'_id': 1}
        foo.save()

        foo2 = self.col.Foo()
        foo2['_id'] = 2
        foo2.save()
        foo2.save()
        assert foo['date'] == datetime.datetime(2003,2,1), foo['date']
        foo = self.col.Foo.get_from_id(1)
        assert foo['date'] == datetime.datetime(2003,2,1), foo['date']
        saved_foo =  foo.collection.find({'_id':1}).next()
        assert saved_foo['date'] == CustomDate().to_bson(datetime.datetime(2003,2,1)), saved_foo['date']
        foo2 = self.col.Foo.get_from_id(2)
        assert foo2['date'] == datetime.datetime(2008,6,7), foo2

    def test_custom_type2(self):
        import datetime

        class CustomPrice(CustomType):
            mongo_type = float
            python_type = basestring
            def to_bson(self, value):
                return float(value)
            def to_python(self, value):
                return str(value)

        class Receipt(Document):
            use_dot_notation = True
            structure = {
                'price': CustomPrice(),
            }
        self.connection.register([Receipt])
          
        r = self.connection.test.test.Receipt()
        r['_id'] = 'bla'
        r['price'] =  '9.99'
        r.save()
        r_saved = r.collection.find_one({'_id':'bla'})
        assert r_saved == {u'_id': u'bla', u'price': 9.9900000000000002}


    def test_instance_type(self):
        from bson.dbref import DBRef
        from bson.objectid import ObjectId
        class Bla(ObjectId):pass
        class Ble(DBRef):pass
        class MyDoc(Document):
            structure = { "foo":ObjectId }
        self.connection.register([MyDoc])
        doc = self.col.MyDoc()
        doc['foo'] = Ble("bla", "ble", "bli")
        self.assertRaises(SchemaTypeError, doc.validate)
        doc['foo'] = Bla()
        doc.validate()

    def test_custom_type_nested(self):
        import datetime
        class CustomDate(CustomType):
            mongo_type = unicode
            python_type = datetime.datetime
            def to_bson(self, value):
                """convert type to a mongodb type"""
                return unicode(datetime.datetime.strftime(value,'%y-%m-%d'))
            def to_python(self, value):
                """convert type to a python object"""
                if value is not None:
                    return datetime.datetime.strptime(value, '%y-%m-%d')
                
        class Foo(Document):
            structure = {
                'foo':{'date': CustomDate()},
            }
            default_values = {'foo.date':datetime.datetime(2008, 6, 7)}
        self.connection.register([Foo])
            
        foo = self.col.Foo()
        foo['_id'] = 1
        foo['foo']['date'] = datetime.datetime(2003,2,1)
        foo.save()
        foo.save()

        foo2 = self.col.Foo()
        foo2['_id'] = 2
        foo2.save()
        assert foo['foo']['date'] == datetime.datetime(2003,2,1), foo['foo']['date']
        foo = self.col.Foo.get_from_id(1)
        assert foo['foo']['date'] == datetime.datetime(2003,2,1)
        saved_foo =  foo.collection.find({'_id':1}).next()
        assert saved_foo['foo']['date'] == CustomDate().to_bson(datetime.datetime(2003,2,1)), foo['foo']['date']
        foo2 = self.col.Foo.get_from_id(2)
        assert foo2['foo']['date'] == datetime.datetime(2008,6,7), foo2

    def test_custom_type_nested_in_list(self):
        import datetime
        class CustomDate(CustomType):
            mongo_type = unicode
            python_type = datetime.datetime
            def to_bson(self, value):
                """convert type to a mongodb type"""
                return unicode(datetime.datetime.strftime(value,'%y-%m-%d'))
            def to_python(self, value):
                """convert type to a python object"""
                if value is not None:
                    return datetime.datetime.strptime(value, '%y-%m-%d')
                
        class Foo(Document):
            structure = {
                'foo':{'date': [CustomDate()]},
            }
            default_values = {'foo.date':[datetime.datetime(2008, 6, 7)]}
        self.connection.register([Foo])
            
        foo = self.col.Foo()
        foo['_id'] = 1
        foo['foo']['date'].append(datetime.datetime(2003,2,1))
        foo.save()
        foo.save()

        foo1 = self.col.Foo()
        foo1['_id'] = 1
        foo1['foo']['date'].append(1)
        self.assertRaises(SchemaTypeError, foo1.save)

        foo2 = self.col.Foo()
        print foo2
        foo2['_id'] = 2
        foo2.save()
        print id(foo['foo']['date']), id(foo2['foo']['date'])

        assert foo == {'foo': {'date': [datetime.datetime(2008, 6, 7, 0, 0), datetime.datetime(2003, 2, 1, 0, 0)]}, '_id': 1}
        foo = self.col.Foo.get_from_id(1)
        assert foo == {u'_id': 1, u'foo': {u'date': [datetime.datetime(2008, 6, 7, 0, 0), datetime.datetime(2003, 2, 1, 0, 0)]}}
        saved_foo =  foo.collection.find({'_id':1}).next()
        assert saved_foo == {u'_id': 1, u'foo': {u'date': [u'08-06-07', u'03-02-01']}}
        foo2 = self.col.Foo.get_from_id(2)
        assert foo2['foo']['date'] == [datetime.datetime(2008,6,7)], foo2

    def test_bad_custom_types(self):
        import datetime
        class CustomDate(CustomType):
            def to_bson(self, value):
                """convert type to a mongodb type"""
                return unicode(datetime.datetime.strftime(value,'%y-%m-%d'))
            def to_python(self, value):
                """convert type to a python object"""
                if value is not None:
                    return datetime.datetime.strptime(value, '%y-%m-%d')
        self.assertRaises(TypeError, CustomDate)

        class CustomDate(CustomType):
            mongo_type = unicode
        self.assertRaises(TypeError, CustomDate)

        class CustomDate(CustomType):
            mongo_type = unicode
            python_type = int
        self.assertRaises(NotImplementedError, CustomDate().to_bson, "bla")
        self.assertRaises(NotImplementedError, CustomDate().to_python, "bla")

    def test_bad_custom_type_bad_python_type(self):
        import datetime

        class CustomDate(CustomType):
            mongo_type = unicode
            python_type = basestring
            def to_bson(self, value):
                """convert type to a mongodb type"""
                return unicode(datetime.datetime.strftime(value,'%y-%m-%d'))
            def to_python(self, value):
                """convert type to a python object"""
                if value is not None:
                    return datetime.datetime.strptime(value, '%y-%m-%d')
                
        class Foo(Document):
            structure = {
                "date": CustomDate(),
            }
            default_values = {'date':datetime.datetime(2008, 6, 7)}
        #self.assertRaises(DefaultFieldTypeError, self.connection.register, [Foo])
        self.connection.register([Foo])
        failed = False
        try:
            self.col.Foo()
        except DefaultFieldTypeError, e:
            failed = True
            self.assertEqual(str(e), 'date must be an instance of basestring not datetime')
 
    def test_custom_type_bad_python(self):
        import datetime

        class CustomDate(CustomType):
            mongo_type = unicode
            python_type = str
            def to_bson(self, value):
                """convert type to a mongodb type"""
                return unicode(datetime.datetime.strftime(value,'%y-%m-%d'))
            def to_python(self, value):
                """convert type to a python object"""
                if value is not None:
                    return datetime.datetime.strptime(value, '%y-%m-%d')
                
        class Foo(Document):
            structure = {
                "date": CustomDate(),
            }
            default_values = {'date':datetime.datetime(2008, 6, 7)}
        self.connection.register([Foo])
        failed = False
        try:
            self.col.Foo()
        except DefaultFieldTypeError, e:
            failed = True
            self.assertEqual(str(e),
              'date must be an instance of str not datetime')

        class CustomDate(CustomType):
            mongo_type = unicode
            python_type = datetime.datetime
            def to_bson(self, value):
                """convert type to a mongodb type"""
                return unicode(datetime.datetime.strftime(value,'%y-%m-%d'))
            def to_python(self, value):
                """convert type to a python object"""
                if value is not None:
                    return datetime.datetime.strptime(value, '%y-%m-%d')
                
        class Foo(Document):
            structure = {
                "date": CustomDate(),
            }
            default_values = {'date':(2008, 6, 7)}
        self.connection.register([Foo])
        failed = False
        try:
            self.col.Foo()
        except DefaultFieldTypeError, e:
            failed = True
            self.assertEqual(str(e),
              'date must be an instance of datetime not tuple')

        class Foo(Document):
            structure = {
                "date": [CustomDate()],
            }
            default_values = {'date':[(2008, 6, 7)]}
        self.connection.register([Foo])
        failed = False
        try:
            self.col.Foo()
        except DefaultFieldTypeError, e:
            failed = True
            self.assertEqual(str(e),
              'date must be an instance of datetime not tuple')

        class CustomDate(CustomType):
            mongo_type = int
            python_type = datetime.datetime
            def to_bson(self, value):
                """convert type to a mongodb type"""
                return unicode(datetime.datetime.strftime(value,'%y-%m-%d'))
            def to_python(self, value):
                """convert type to a python object"""
                if value is not None:
                    return datetime.datetime.strptime(value, '%y-%m-%d')

        class Foo(Document):
            structure = {
                "date": CustomDate(),
            }
        self.connection.register([Foo])
        foo = self.col.Foo()
        foo['_id'] = 2
        foo['date'] = datetime.datetime(2003,2,1)
        self.assertRaises(SchemaTypeError, foo.save)

    def test_custom_type_nested_list(self):
        import datetime

        class CustomPrice(CustomType):
            mongo_type = float
            python_type = str
            def to_bson(self, value):
                return float(value)
            def to_python(self, value):
                return str(value)

        class Receipt(Document):
            use_dot_notation = True
            structure = {
                'products': [
                      {
                        'sku': unicode,
                        'qty': int,
                        'price': CustomPrice(),
                      }
                ]
            }
        self.connection.register([Receipt])
          
        r = self.connection.test.test.Receipt()
        r['_id'] = 'bla'
        r.products = []
        r.products.append({ 'sku': u'X-25A5F58B-61', 'qty': 1, 'price': '9.99' })
        r.products.append({ 'sku': u'Z-25A5F58B-62', 'qty': 2, 'price': '2.99' })
        r.save()
        r_saved = r.collection.find_one({'_id':'bla'})
        assert r_saved == {u'_id': u'bla', u'products': [{u'sku': u'X-25A5F58B-61', u'price': 9.9900000000000002, u'qty': 1}, {u'sku': u'Z-25A5F58B-62', u'price': 2.9900000000000002, u'qty': 2}]}

    def test_custom_type_list(self):
        import datetime

        class CustomPrice(CustomType):
            mongo_type = float
            python_type = basestring
            def to_bson(self, value):
                return float(value)
            def to_python(self, value):
                return str(value)

        class Receipt(Document):
            structure = {
                'foo': CustomPrice(),
                'price': [CustomPrice()],
                'bar':{'spam':CustomPrice()},
            }
        self.connection.register([Receipt])
          
        r = self.connection.test.test.Receipt()
        r['_id'] = 'bla'
        r['foo'] = '2.23'
        r['price'].append('9.99')
        r['price'].append('2.99')
        r['bar']['spam'] = '3.33'
        r.save()
        r_saved = r.collection.find_one({'_id':'bla'})
        assert r_saved == {u'price': [9.9900000000000002, 2.9900000000000002], u'_id': u'bla', u'bar': {u'spam': 3.3300000000000001}, u'foo': 2.23}

    def test_custom_type_not_serializable(self):
        from decimal import Decimal
        class DecimalType(CustomType):
           mongo_type = unicode
           python_type = Decimal

           def to_bson(self, value):
               """convert type to a mongodb type"""
               if value is not None:
                   return unicode(value)

           def to_python(self, value):
               """convert type to a python object"""
               if value is not None:
                   return Decimal(value)

        class MyDocument(Document):
           structure = {'amount': DecimalType()}
        self.connection.register([MyDocument])
        document = self.col.MyDocument()
        document['amount'] = Decimal(u'100.00')
        document.validate()

    def test_required_custom_type_mongotype_dict(self):
        class CustomObject(CustomType):
            mongo_type = dict
            python_type = float
            def to_bson(self, value):
                return {'f':unicode(value)}
            def to_python(self, value):
                return float(value['f'])

        class MyDocument(Document):
           structure = {'amount': CustomObject()}
           required_fields = ['amount']
           indexes = [{'fields':['amount.f'], 'check':False}]
           validators = {'amount':lambda x: x > 3.0}

        self.connection.register([MyDocument])

        document = self.col.MyDocument()
        document['_id'] = u'test'
        document['amount'] = 1.00
        self.assertRaises(ValidationError, document.validate)
        document['amount'] = 100.00
        document.save()
        assert self.col.find_one() == {u'amount': {u'f': u'100.0'}, u'_id': u'test'}, self.col.find_one()
        assert self.col.MyDocument.find_one() == {u'amount': 100.00, u'_id': u'test'}, self.col.MyDocument.find_one()
 
    def test_custom_type_mongotype_dict_index_not_checked(self):
        class CustomObject(CustomType):
            mongo_type = dict
            python_type = float
            def to_bson(self, value):
                return {'f':unicode(value)}
            def to_python(self, value):
                return float(value['f'])

        failed = False
        try:
            class MyDocument(Document):
               structure = {'amount': CustomObject()}
               required_fields = ['amount']
               indexes = [{'fields':['amount.f']}]
        except ValueError, e:
            self.assertEqual(str(e), "Error in indexes: can't find amount.f in structure")
            failed = True
        self.assertEqual(failed, True)

    def test_missing_custom_types(self):
        import datetime
        class CustomDate(CustomType):
            mongo_type = unicode
            python_type = datetime.datetime
            def to_bson(self, value):
                """convert type to a mongodb type"""
                return unicode(datetime.datetime.strftime(value,'%y-%m-%d'))
            def to_python(self, value):
                """convert type to a python object"""
                if value is not None:
                    return datetime.datetime.strptime(value, '%y-%m-%d')
                
        class Foo(Document):
            structure = {
                "date": CustomDate(),
            }
            default_values = {'date':datetime.datetime(2008, 6, 7)}
        self.connection.register([Foo])
            
        # insert a foo document without this field
        self.col.insert({'_id': 1})

        foo = self.col.Foo.get_from_id(1)
        foo['_id'] = 1
        foo['date'] = datetime.datetime(2003,2,1)
        foo.save()

########NEW FILE########
__FILENAME__ = test_descriptors
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest

from mongokit import *

class DescriptorsTestCase(unittest.TestCase):
    def setUp(self):
        self.connection = Connection()
        self.col = self.connection['test']['mongokit']

    def tearDown(self):
        self.connection.drop_database('test')

    def test_duplicate_required(self):
        failed = False
        try:
            class MyDoc(Document):
                structure = {"foo":unicode}
                required_fields = ["foo", "foo"]
        except DuplicateRequiredError, e:
            self.assertEqual(str(e), "duplicate required_fields : ['foo', 'foo']")
            failed = True
        self.assertEqual(failed, True)

    def test_flat_required(self):
        class MyDoc(Document):
            structure = {
                "foo":unicode,
            }
            required_fields = ["foo"]
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        self.assertRaises(RequireFieldError, mydoc.validate )
        mydoc['foo'] = u'bla'
        mydoc.validate()

    def test_nested_required(self):
        class MyDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                },
            }
            required_fields = ["bla.foo"]
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        self.assertRaises(RequireFieldError, mydoc.validate )
        mydoc['bla']['foo'] = u'bla'
        mydoc.validate()

    def test_list_required(self):
        class MyDoc(Document):
            structure = {
                "foo":[]
            }
            required_fields = ["foo"]
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        self.assertRaises(RequireFieldError, mydoc.validate )
        mydoc['foo'] = [1,2,3]
        mydoc.validate()

    def test_dict_required2(self):
        class MyDoc(Document):
            structure = {
                "foo":dict
            }
            required_fields = ["foo"]
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        self.assertRaises(RequireFieldError, mydoc.validate )
        mydoc['foo'] = {u"3":[u'bla']}
        mydoc.validate()

    def test_dict_required(self):
        class MyDoc(Document):
            structure = {
                "foo":{}
            }
            required_fields = ["foo"]
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        self.assertRaises(RequireFieldError, mydoc.validate )
        mydoc['foo'] = {u'bar':u'bla'}
        self.assertRaises(StructureError, mydoc.validate )

    def test_dict_nested_required(self):
        class MyDoc(Document):
            structure = {
                "foo":{unicode:{"bar":int}}
            }
            required_fields = ["foo.$unicode.bar"]
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        self.assertRaises(RequireFieldError, mydoc.validate )

    def test_default_values(self):
        class MyDoc(Document):
            structure = {
                "foo":int,
                "bla":unicode,
            }
            default_values = {"foo":42}
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        assert mydoc["foo"] == 42
        assert mydoc == {'foo':42, 'bla':None}, mydoc

    def test_default_values_nested(self):
        class MyDoc(Document):
            structure = {
                "bar":{
                    "foo":int,
                    "bla":unicode,
                }
            }
            default_values = {"bar.foo":42}
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        assert mydoc['bar']["foo"] == 42
        assert mydoc == {'bar':{'foo':42, 'bla':None}}, mydoc

    def test_default_values_nested_inheritance(self):
        import datetime
        class Core(Document):
            structure = {
                "core":{
                    "creation_date":datetime.datetime,
                }
            }
            default_values = {
                "core.creation_date": datetime.datetime(2010, 1, 1),
            }

        class MyDoc(Core):
            structure = {
                "bar":{
                    "foo":int,
                    "bla":unicode,
                }
            }
            default_values = {"bar.foo":42}

        class MyDoc2(MyDoc):
            structure = {
                "mydoc2":{
                    "toto":int
                }
            }
        self.connection.register([MyDoc2])
        mydoc = self.col.MyDoc2()
        assert mydoc['bar']["foo"] == 42
        assert mydoc == {'mydoc2': {'toto': None}, 'core': {'creation_date': datetime.datetime(2010, 1, 1, 0, 0)}, 'bar': {'foo': 42, 'bla': None}}

    def test_default_values_from_function(self):
        import time
        class MyDoc(Document):
            structure = {
                "foo":float
            }
            default_values = {"foo":time.time}
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc.validate()

    def test_default_values_from_function2(self):
        import time
        class Doc( Document ):
            structure = {
                "doc":{
                    "creation_date":float,
                    "updated_date": float,
                }
            }
            default_values = {
                "doc.creation_date": time.time,
                "doc.updated_date": time.time
            }
        doc = Doc()
        assert isinstance(doc['doc']['creation_date'], float), doc['doc']['creation_date']
        assert isinstance(doc['doc']['updated_date'], float)

    def test_default_values_from_function_nested(self):
        import time
        class MyDoc(Document):
            structure = {
                "foo":{"bar":float}
            }
            default_values = {"foo.bar":time.time}
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc.validate()
        assert mydoc['foo']['bar'] > 0

    def _test_default_values_from_function_througt_types(self):
        # XXX TODO
#        class MyDoc(Document):
#            structure = {
#                "foo":{int:float}
#            }
#            default_values = {"foo.$int":time.time}
#        mydoc = MyDoc()
#        mydoc.validate()
#        # can't go through types, because no values
#        assert mydoc['foo'] == {}

        # but
        import time
        class MyDoc(Document):
            structure = {
                "foo":{int:float}
            }
            default_values = {"foo":{3:time.time}}
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc.validate()
        assert mydoc['foo'][3] > 0

    def test_default_list_values(self):
        class MyDoc(Document):
            structure = {
                "foo":[int]
            }
            default_values = {"foo":[42,3]}
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        assert mydoc["foo"] == [42,3]
        mydoc['foo'] = [1,2,3]
        mydoc.save()
        mydoc = self.col.MyDoc()
        assert mydoc['foo'] == [42,3]

    def test_default_list_values_empty(self):
        class MyDoc(Document):
            structure = {
                "foo":list
            }
            default_values = {"foo":[3]}
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        assert mydoc["foo"] == [3]
        mydoc['foo'].append(2)
        mydoc.save()
        mydoc = self.col.MyDoc()
        assert mydoc['foo'] == [3], mydoc


    def test_default_list_values_with_callable(self):
        def get_truth():
            return 42
        class MyDoc(Document):
            structure = {
                "foo":[int]
            }
            default_values = {"foo":[get_truth,3]}
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        assert mydoc["foo"] == [42,3]
        mydoc.validate()


    def test_default_list_nested_values(self):
        class MyDoc(Document):
            structure = {
                "foo":{
                    "bar":[int]
                }
            }
            default_values = {"foo.bar":[42,3]}
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        assert mydoc["foo"]["bar"] == [42,3]

    def test_default_dict_values(self):
        class MyDoc(Document):
            structure = {
                "foo":dict
            }
            default_values = {"foo":{"bar":42}}
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        assert mydoc["foo"] == {"bar":42}, mydoc
        mydoc['foo'] = {'bar':1}
        mydoc.save()
        mydoc = self.col.MyDoc()
        assert mydoc["foo"] == {"bar":42}, mydoc

    def test_default_dict_values_empty(self):
        class MyDoc(Document):
            structure = {
                "foo":dict
            }
            default_values = {"foo":{}}
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        print id(mydoc.structure['foo']), id(mydoc['foo']), id(mydoc.default_values['foo'])
        assert mydoc["foo"] == {}, mydoc
        mydoc['foo'][u'bar'] = 1
        mydoc.save()
        mydoc2 = self.col.MyDoc()
        print id(mydoc2.structure['foo']), id(mydoc2['foo']), id(mydoc2.default_values['foo'])
        assert mydoc2["foo"] == {}, mydoc

        class MyDoc(Document):
            structure = {
                "foo":{unicode:int}
            }
            default_values = {"foo":{}}
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        assert mydoc["foo"] == {}, mydoc
        mydoc['foo'][u'bar'] = 1
        mydoc.save()
        mydoc2 = self.col.MyDoc()
        assert mydoc2["foo"] == {}, mydoc


    def test_default_dict_values_with_callable(self):
        def get_truth():
            return {'bar':42}
        class MyDoc(Document):
            structure = {
                "foo":{}
            }
            default_values = {"foo":get_truth}
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        assert mydoc["foo"] == {"bar":42}, mydoc

    def test_default_dict_checked_values(self):
        class MyDoc(Document):
            structure = {
                "foo":{unicode:int}
            }
            default_values = {"foo":{u"bar":42}}
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        assert mydoc["foo"] == {"bar":42}, mydoc

    def test_default_dict_nested_checked_values(self):
        class MyDoc(Document):
            structure = {
                "foo":{unicode:{"bla":int, "ble":unicode}}
            }
            default_values = {"foo":{u"bar":{"bla":42, "ble":u"arf"}}}
        mydoc = MyDoc()
        assert mydoc["foo"] == {u"bar":{"bla":42, "ble":u"arf"}}, mydoc

    def test_default_values_with_dict_in_list(self):
        @self.connection.register
        class MyDoc(Document):
            structure = {
                'bar': [{'foo':unicode}]
            }
            default_values = {
                'bar': [{'foo': u'bla'}]
            }
        doc = self.col.MyDoc()
        assert doc['bar'] == [{'foo': u'bla'}]

    def test_validators(self):
        class MyDoc(Document):
            structure = {
                "foo":unicode,
                "bar":{
                    "bla":int
                }
            }
            validators = {
                "foo":lambda x: x.startswith("http://"),
                "bar.bla": lambda x: x > 5
            }
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc["foo"] = u"google.com"
        self.assertRaises(ValidationError, mydoc.validate)
        mydoc["foo"] = u"http://google.com"
        mydoc.validate()
        mydoc['bar']['bla'] = 2
        self.assertRaises(ValidationError, mydoc.validate)
        mydoc['bar']['bla'] = 42
        mydoc.validate()

    def test_validators_througt_types(self):
        class MyDoc(Document):
            structure = {
                "bar":{
                    int:{"bla":int}
                }
            }
            validators = {
                "bar.$int.bla": lambda x: x > 5
            }
        mydoc = MyDoc()
        mydoc['bar'].update({3:{'bla': 15}})
        self.assertRaises(InvalidDocument, mydoc.validate)

    def test_multiple_validators(self):
        class MyDoc(Document):
            structure = {
                "foo":unicode,
            }
            validators = {
                "foo":[lambda x: x.startswith("http://"),lambda x: x.endswith(".com")],
            }
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc["foo"] = u"google.com"
        self.assertRaises(ValidationError, mydoc.validate)
        mydoc["foo"] = u"http://google.fr"
        self.assertRaises(ValidationError, mydoc.validate)
        mydoc["foo"] = u"http://google.com"
        mydoc.validate()

    def test_validators_with_custom_validation_message(self):
        class MinLengthValidator(object):
            def __init__(self, min_length):
                self.min_length = min_length

            def __call__(self, value):
                if len(value) >= self.min_length:
                    return True
                else:
                    raise Exception('%s must be atleast ' + str(self.min_length) + ' characters long.')

        class Client(Document):
            structure = {
              'first_name': unicode
            }
            validators = {
              'first_name': MinLengthValidator(2)
            }
        self.connection.register([Client])
        client = self.col.Client()
        client['first_name'] = u'Georges'
        client.validate()
        client['first_name'] = u'J'
        self.assertRaises(Exception, client.validate)
        message = ""
        try:
            client.validate()
        except Exception, e:
            message = unicode(e)
        assert message == "first_name must be atleast 2 characters long.", message

    def test_complexe_validation(self):
        class MyDoc(Document):
            structure = {
                "foo":unicode,
                "bar":{
                    "bla":int
                }
            }
            def validate(self):
                if self['bar']['bla']:
                    self['foo'] = unicode(self['bar']['bla'])
                else:
                    self['foo'] = None
                super(MyDoc, self).validate()

        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc['bar']['bla'] = 4
        assert mydoc['foo'] is None
        mydoc.validate()
        assert mydoc['foo'] == "4", mydoc['foo']
        mydoc['bar']['bla'] = None
        mydoc.validate()
        assert mydoc['foo'] is None

    def test_complexe_validation2(self):

        class MyDoc(Document):
            structure = {
                "foo":unicode,
                "bar":{"bla":unicode}
            }
            default_values = {"bar.bla":3}
            def validate(self):
                self["bar"]["bla"] = unicode(self["bar"]["bla"])
                self["foo"] = unicode(self["foo"])
                super(MyDoc, self).validate()

        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc['foo'] = 4
        mydoc.validate()
        assert mydoc['foo'] == "4", mydoc['foo']
        assert mydoc["bar"]["bla"] == "3", mydoc

    def test_complexe_validation3(self):
        class MyDoc(Document):
            structure = {
                "foo":unicode,
                "bar":{
                    "bla":int
                },
                "ble":unicode,
            }
            def validate(self):
                if self['bar']['bla'] is not None:
                    self['foo'] = unicode(self['bar']['bla'])
                else:
                    self['foo'] = None
                self["ble"] = self["foo"]
                super(MyDoc, self).validate()

        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc['bar']['bla'] = 4
        assert mydoc['foo'] is None
        mydoc.validate()
        assert mydoc['foo'] == "4"
        assert mydoc["ble"] == "4"
        mydoc['bar']['bla'] = None
        mydoc.validate()
        assert mydoc['foo'] is None
        assert mydoc['ble'] is None

    def test_bad_default_values(self):
        failed = False
        try:
            class MyDoc(Document):
                structure = {
                    "foo":{"bar":int},
                }
                default_values = {"foo.bla":2}
        except ValueError, e:
            failed = True
            self.assertEqual(str(e), "Error in default_values: can't find foo.bla in structure")
        self.assertEqual(failed, True)

    def test_bad_validators(self):
        failed = False
        try:
            class MyDoc(Document):
                structure = {
                    "foo":{"bar":int},
                }
                validators = {"foo.bla":lambda x:x}
        except ValueError, e:
            failed = True
            self.assertEqual(str(e), "Error in validators: can't find foo.bla in structure")
        self.assertEqual(failed, True)

    def test_bad_required(self):
        failed = False
        try:
            class MyDoc(Document):
                db_name = "test"
                collection_name = "mongokit"
                structure = {
                    "profil":{
                        "screen_name":unicode,
                        "age":int
                    }
                }
                required_fields = ['profil.screen_nam']
        except ValueError, e:
            failed = True
            self.assertEqual(str(e), "Error in required_fields: can't find profil.screen_nam in structure")
        self.assertEqual(failed, True)

    def test_nested_structure2(self):
        class MyDoc(Document):
            db_name = "test"
            collection_name = "mongokit"
            structure = {
                unicode:{int:int}
            }

        mydoc = MyDoc()
        assert mydoc._namespaces == ['$unicode', '$unicode.$int']


########NEW FILE########
__FILENAME__ = test_ext_mongodb_auth
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest
import logging

logging.basicConfig(level=logging.DEBUG)

from mongokit import *
from bson.objectid import ObjectId

admin_created = False

class _ExtMongoDBAuthTestCase(unittest.TestCase):
    """Tests MongoDB Authentication.
    To prevent possibly screwing someone's DB, does NOT confirm "strict"
    authentication.  E.g. doesn't create a root password.
    Simply checks if, when a login & pass is added to a DB, you can auth
    with it in the case of proper configuration.
    """
    def setUp(self):
        # if no admin user is defined, create one
        import md5
        self.connection = Connection()
        if not self.connection.admin.system.users.find().count():
            username = "theadmin"
            self.connection.test.system.users.insert({"user": username, "pwd": md5.new(username + ":mongo:" + "anadminpassword").hexdigest()})
            #CONNECTION.admin.eval('db.addUser("theadmin", "anadminpassword")')
            admin_created = True
        self.db = CONNECTION['test']
        # Toss in a user
        username = "theadmin"
        self.connection.test.system.users.insert({"user": username, "pwd": md5.new(username + ":mongo:" + "bar").hexdigest()})
        self.collection = self.db['mongokit_auth']
        
    def tearDown(self):
        if admin_created:
            self.connection.admin.system.users.remove({})
        self.connection.test.system.users.remove({"user": "foo"})
        self.connection.test.drop_collection('mongokit_auth')

    def test_auth(self):
        class MyDoc(Document):
            db_username = "foo"
            db_password = "bar"
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam":[],
            }
        self.connection.register([MyDoc])
        mydoc = self.connection.test.mongokit_auth.MyDoc()
        mydoc["bla"]["foo"] = u"bar"
        mydoc["bla"]["bar"] = 42
        id = mydoc.save()
        assert isinstance(id['_id'], ObjectId)

        saved_doc = self.collection.find_one({"bla.bar":42})
        for key, value in mydoc.iteritems():
            assert saved_doc[key] == value

        mydoc = self.connection.test.mongokit_auth.MyDoc()
        mydoc["bla"]["foo"] = u"bar"
        mydoc["bla"]["bar"] = 43
        id = mydoc.save(uuid=False)
        assert isinstance(id['_id'], ObjectId)

        saved_doc = self.collection.find_one({"bla.bar":43})
        for key, value in mydoc.iteritems():
            assert saved_doc[key] == value
        self.db.logout()

    def _test_badauth_no_admin(self):
        # XXX WARNING : uncommented this test will remove the root password of the mongodb instance !!!!
        CONNECTION.admin.system.users.remove({})
        class MyDoc(Document):
            db_name = "test"
            db_username = "foo"
            db_password = "bar"
            collection_name = "mongokit_auth"
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam":[],
            }
        mydoc = MyDoc()
        mydoc["bla"]["foo"] = u"bar"
        mydoc["bla"]["bar"] = 42
        self.assertRaises(MongoAuthException, mydoc.save)
        self.db.logout()

    def test_badauth(self):
        crash = False
        try:
            class MyDoc(Document):
                db_username = "foo"
                db_password = "spam"
                structure = {
                    "bla":{
                        "foo":unicode,
                        "bar":int,
                    },
                    "spam":[],
                }
            self.connection.register([MyDoc])
        except MongoAuthException:
            crash = True
        assert crash

 


########NEW FILE########
__FILENAME__ = test_gridfs
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest

from mongokit import *
from bson.objectid import ObjectId
from gridfs import NoFile


class GridFSTestCase(unittest.TestCase):
    def setUp(self):
        self.connection = Connection()
        self.col = self.connection['test']['mongokit']

    def tearDown(self):
        self.connection.drop_database('test')

    def test_simple_gridfs(self):
        class Doc(Document):
            structure = {
                'title':unicode,
            }
            gridfs = {'files': ['source']}
        self.connection.register([Doc])
        doc = self.col.Doc()
        doc['title'] = u'Hello'
        doc.save()

        assertion = False
        try:
            assert doc.fs.source is None
        except NoFile:
            assertion = True
        assert assertion

        assertion = False
        try:
            print doc.fs.not_a_file
        except AttributeError:
            assertion = True
        assert assertion
        doc.fs.source = "Hello World !"
        assert doc.fs.source == u"Hello World !", doc.fs.source

        doc = self.col.Doc.find_one({'title':'Hello'})
        assert doc.fs.source == u"Hello World !"

        f = doc.fs.get_last_version('source')
        assert f.name == 'source'

        del doc.fs.source

        assertion = False
        try:
            assert doc.fs.source is None
        except NoFile:
            assertion = True
        assert assertion

        doc.fs.source = "bla"
        assert [i.name for i in doc.fs] == ['source'], [i.name for i in doc.fs]

    def test_gridfs_without_saving(self):
        class Doc(Document):
            structure = {
                'title':unicode,
            }
            gridfs = {'files': ['source']}
        self.connection.register([Doc])
        doc = self.col.Doc()
        doc['title'] = u'Hello'
        assertion = False
        try:
            doc.fs.source = "Hello World !"
        except RuntimeError:
            assertion = True
        assert assertion
        doc.save()
        doc.fs.source = 'Hello world !'

    def test_gridfs_bad_type(self):
        class Doc(Document):
            structure = {
                'title':unicode,
            }
            gridfs = {'files': ['source']}
        self.connection.register([Doc])
        doc = self.col.Doc()
        doc['title'] = u'Hello'
        doc.save()
        assertion = False
        try:
            doc.fs.source = 3
        except TypeError:
            assertion = True
        assert assertion
        assertion = False
        try:
            doc.fs.source = u"Hello World !"
        except TypeError:
            assertion = True
        assert assertion

    def test_gridfs_with_container(self):
        class Doc(Document):
            structure = {
                'title':unicode,
            }
            gridfs = {
                'files': ['source'],
                'containers': ['images']
            }

        self.connection.register([Doc])
        doc = self.col.Doc()
        doc['title'] = u'Hello'
        doc.save()

        doc.fs.source = "Hello World !"
        assert doc.fs.source == "Hello World !"

        assertion = False
        try:
            doc.fs.images['first.jpg'] = 3
        except TypeError:
            assertion = True
        assert assertion

        doc.fs.images['first.jpg'] = "My first image"
        doc.fs.images['second.jpg'] = "My second image"

        assert doc.fs.images['first.jpg'] == 'My first image', doc.fs.images['first.jpg']
        assert doc.fs.images['second.jpg'] == 'My second image'

        doc.fs.images['first.jpg'] = "My very first image"
        assert doc.fs.images['first.jpg'] == 'My very first image', doc.fs.images['first.jpg']

        del doc.fs.images['first.jpg']

        assertion = False
        try:
            doc.fs.images['first.jpg']
        except NoFile:
            assertion = True
        assert assertion

    def test_gridfs_list(self):
        class Doc(Document):
            structure = {
                'title':unicode,
            }
            gridfs = {'files': ['foo', 'bla'], 'containers':['attachments']}
        self.connection.register([Doc])
        doc = self.col.Doc()
        doc['title'] = u'Hello'
        doc.save()

        doc.fs.foo = "Hello World !"
        doc.fs.bla = "Salut !"
        assert [i.name for i in doc.fs] == ['foo', 'bla'], [i.name for i in doc.fs]
        doc.fs.attachments['eggs.txt'] = "Ola !"
        doc.fs.attachments['spam.txt'] = "Saluton !"
        assert [(i.container, i.name) for i in doc.fs.attachments] == [('attachments', 'eggs.txt'), ('attachments', 'spam.txt')], [(i.container, i.name) for i in doc.fs.attachments]
        assert [i.name for i in doc.fs] == [u'foo', u'bla', u'eggs.txt', u'spam.txt'], [(i.container, i.name) for i in doc.fs]


    def test_gridfs_new_file(self):
        class Doc(Document):
            structure = {
                'title':unicode,
            }
            gridfs = {'files': ['foo', 'bla'], 'containers':['attachments']}
        self.connection.register([Doc])
        doc = self.col.Doc()
        doc['title'] = u'Hello'
        doc.save()

        doc.fs.foo = "Hello World !"
        f = doc.fs.new_file("bla")
        f.write('Salut !')
        f.close()
        assert doc.fs.bla == "Salut !"
        assert doc.fs.foo == "Hello World !"

        f = doc.fs.attachments.new_file('test')
        f.write('this is a test')
        f.close()
        assert doc.fs.attachments['test'] == 'this is a test'

        doc = self.col.Doc.find_one()
        assert doc.fs.bla == "Salut !"
        assert doc.fs.foo == "Hello World !"
        assert doc.fs.attachments['test'] == 'this is a test', doc.fs.attachments['test']
        assert doc.fs.attachments.get_last_version('test').read() == 'this is a test'


    def test_pymongo_compatibility(self):
        class Doc(Document):
            structure = {
                'title':unicode,
            }
            gridfs = {'files': ['source', 'foo'], 'containers':['attachments']}
        self.connection.register([Doc])
        doc = self.col.Doc()
        doc['title'] = u'Hello'
        doc.save()
        id = doc.fs.put("Hello World", filename="source")
        assert doc.fs.get(id).read() == 'Hello World'
        assert doc.fs.get_last_version("source").name == 'source'
        assert doc.fs.get_last_version("source").read() == 'Hello World'
        f = doc.fs.new_file("source")
        f.write("New Hello World!")
        f.close()
        assert doc.fs.source == 'New Hello World!', doc.fs.source
        new_id = doc.fs.get_last_version("source")._id
        doc.fs.delete(new_id)
        assert doc.fs.source == 'Hello World', doc.fs.source


########NEW FILE########
__FILENAME__ = test_helpers
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest

from mongokit import *
from mongokit.schema_document import DotExpandedDict

class HelpersTestCase(unittest.TestCase):
        
    def test_DotExpandedDict(self):
        d = DotExpandedDict({'a.$int.c.d': 3, 'a.$int.e': 5, '_id': u'user', 'a.g': 2, 'f': 6})
        assert d == {'_id': u'user', 'a':{int:{'c':{'d':3}, 'e':5}, "g":2}, 'f':6}, d

        d = DotExpandedDict({'foo.bla.$unicode': [unicode], 'foo.bar': {}})
        assert d == {'foo': {'bar': {}, 'bla': {unicode: [unicode]}}}, d

        self.assertRaises(EvalException, DotExpandedDict, {'foo.bla.$arf': [unicode], 'foo.bar': {}})

        d = DotExpandedDict({'person.1.firstname': ['Simon'],
          'person.1.lastname': ['Willison'],
          'person.2.firstname': ['Adrian'], 
          'person.2.lastname': ['Holovaty']}) 
        assert d == {'person': {'1': {'lastname': ['Willison'], 'firstname': ['Simon']}, '2': {'lastname': ['Holovaty'], 'firstname': ['Adrian']}}} 
        assert d['person'] == {'1': {'lastname': ['Willison'], 'firstname': ['Simon']}, '2': {'lastname': ['Holovaty'], 'firstname': ['Adrian']}} 
        assert d['person']['1'] == {'lastname': ['Willison'], 'firstname': ['Simon']} 
        # Gotcha: Results are unpredictable if the dots are "uneven": 
        assert DotExpandedDict({'c.1': 2, 'c.2': 3, 'c': 1}) == {'c': 1} 

    def test_DotCollapsedDict(self):
        dic = {'foo':{}}
        d = DotCollapsedDict(dic)
        assert d == {'foo':{}}, d

        dic = {'bar':{'foo':{}}}
        d = DotCollapsedDict(dic)
        assert d == {'bar.foo':{}}, d

        dic = {'_id': u'user', 'a':3, 'e':5, "g":2, 'f':6}
        d = DotCollapsedDict(dic)
        assert d == {'_id': u'user', 'a':3, 'e':5, "g":2, 'f':6}, d

        dic = {'_id': u'user', 'a':{'b':{'c':{'d':3}, 'e':5}, "g":2}, 'f':6}
        d = DotCollapsedDict(dic)
        assert d == {'a.b.c.d': 3, '_id': u'user', 'a.b.e': 5, 'a.g': 2, 'f': 6}, d

        dic = {'_id': u'user', 'a':{'b':1, 'd':3, 'e':5}, 'f':6}
        d = DotCollapsedDict(dic)
        assert d == {'_id': u'user', 'a.b': 1, 'a.d': 3, 'a.e': 5, 'f': 6}, d

        dic = {'_id': u'user', 'a':{'b':1, 'd':3, 'e':{'g':5, 'h':0}}, 'f':6}
        d = DotCollapsedDict(dic)
        assert d == {'a.d': 3, 'a.e.h': 0, 'a.b': 1, 'f': 6, 'a.e.g': 5, '_id': u'user'}, d

    def test_DotCollapsedDict_with_reference(self):
        dic = {'foo':{}}
        d = DotCollapsedDict(dic, reference={'foo':{}})
        assert d == {'foo':{}}, d

        dic = {'bar':{'foo':{}}}
        d = DotCollapsedDict(dic, reference={'bar':{'foo':{}}})
        assert d == {'bar':{'foo':{}}}, d

        dic = {'bar':{'foo':3}, 'bla':{'g':2, 'h':3}}
        d = DotCollapsedDict(dic, reference={'bar.foo':None, 'bla':{'g':None, 'h':None}})
        assert d == {'bar.foo':3, 'bla':{'g':2, 'h':3}}, d

#        # XXX TODO
#        dic = {'bar':{'foo':3, 'bla':2}}
#        d = DotCollapsedDict(dic, reference={'bar.foo':None, 'bar':{'bla':None}})
#        assert d == {'bar.foo':3, 'bar':{'bla':2}}, d

        dic = {'_id': u'user', 'a':3, 'e':5, "g":2, 'f':6}
        d = DotCollapsedDict(dic,  reference=dic)
        assert d == {'_id': u'user', 'a':3, 'e':5, "g":2, 'f':6}, d

        dic = {'_id': u'user', 'a':{'b':1, 'd':3, 'e':{'g':5, 'h':0}}, 'f':6}
        d = DotCollapsedDict(dic, reference={'_id':None, 'a.b':1, 'a.d':3, 'a.e':{'g':5, 'h':0}, 'a.f':6})
        assert d == {'a.d': 3, 'a.b': 1, 'f': 6, 'a.e':{'g': 5, 'h':0}, '_id': u'user'}, d

        dic = {'_id': u'user', 'a':{'b':{'c':{'d':3}, 'e':5}, "g":2}, 'f':6}
        d = DotCollapsedDict(dic, reference={'_id':None, 'a.b':{'c':{'d':3}, 'e':5}, 'a.g':2, 'f':6})
        assert d == {'_id': u'user', 'a.b':{'c': {'d': 3}, 'e':5}, 'a.g': 2, 'f': 6}, d

    def test_DotCollapsedDict_with_remove_under_type(self):
        dic = {'_id': u'user', 'a':{int:{'c':{'d':3}, 'e':5}, "g":2}, 'f':6}
        d = DotCollapsedDict(dic, remove_under_type=True)
        assert d == {'a': {}, '_id': u'user', 'f': 6}, d

        dic = {'bla':{'foo':{unicode:{"bla":int}}, 'bar':unicode}}
        d = DotCollapsedDict(dic, remove_under_type=True)
        assert d == {'bla.foo':{}, 'bla.bar':unicode}, d

        dic = {'bla':{'foo':{unicode:[unicode]}, 'bar':"egg"}}
        d = DotCollapsedDict(dic, remove_under_type=True)
        assert d == {'bla.foo':{}, 'bla.bar':"egg"}, d

    def test_DotCollapsedDict_with_type(self):
        dic = {'_id': u'user', 'a':{int:{'c':{'d':3}, 'e':5}, "g":2}, 'f':6}
        d = DotCollapsedDict(dic)
        assert d == {'a.$int.c.d': 3, 'a.$int.e': 5, '_id': u'user', 'a.g': 2, 'f': 6}, d

        dic = {'bla':{'foo':{unicode:{"bla":3}}, 'bar':'egg'}}
        d = DotCollapsedDict(dic)
        assert d == {'bla.foo.$unicode.bla': 3, 'bla.bar': "egg"}, d

        dic = {'bla':{'foo':{unicode:['egg']}, 'bar':"egg"}}
        d = DotCollapsedDict(dic)
        assert d == {'bla.foo.$unicode': ['egg'], 'bla.bar': 'egg'}, d

########NEW FILE########
__FILENAME__ = test_i18n
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest

from mongokit import *
from bson.objectid import ObjectId
from mongokit.helpers import i18nDotedDict


class i18nTestCase(unittest.TestCase):
    def setUp(self):
        self.connection = Connection()
        self.col = self.connection['test']['mongokit']
        
    def tearDown(self):
        self.connection.drop_database('test')
        self.connection.drop_database('othertest')

    def test_simple_i18n(self):
        class Doc(Document):
            structure = {
                'title':unicode,
            }
            i18n = ['title']
        self.connection.register([Doc])
        doc = self.col.Doc()
        doc['title']['en'] = u'Hello'
        doc['title']['fr'] = u"Salut"
        doc.save()

        assert doc == {'_id':doc['_id'], 'title':{'en':'Hello', 'fr':'Salut'}}, doc
        doc = self.col.Doc.find_random()
        assert doc['title'] == {'en':'Hello', 'fr':'Salut'}
        assert doc == {'_id':doc['_id'], 'title':{'en':'Hello', 'fr':'Salut'}}, doc

    def test_simple_i18n_with_int(self):
        class Doc(Document):
            structure = {
                'title':int,
            }
            i18n = ['title']
        self.connection.register([Doc])
        doc = self.col.Doc()
        doc['title']['en'] = 3
        doc['title']['fr'] = 10
        doc.save()

        assert doc == {'_id':doc['_id'], 'title':{'en': 3, 'fr': 10}}, doc
        doc = self.col.Doc.find_random()
        assert doc['title'] == {'en':3, 'fr':10}
        assert doc == {'_id':doc['_id'], 'title':{'en':3, 'fr':10}}, doc

    def test_i18n_with_dot_notation(self):
        class Doc(Document):
            use_dot_notation = True
            structure = {
                'title':int,
            }
            i18n = ['title']
        self.connection.register([Doc])
        doc = self.col.Doc()
        doc['title']['en'] = 3
        doc['title']['fr'] = 10
        doc.save()

        assert doc == {'_id':doc['_id'], 'title':{'en': 3, 'fr': 10}}, doc
        doc = self.col.Doc.find_random()
        assert doc['title'] == {'en':3, 'fr':10}
        doc.set_lang('fr')
        assert doc.title == 10, doc.title
        doc.set_lang('en')
        assert doc.title == 3
        doc.set_lang('es')
        doc.title = 4
        assert doc == {'_id':doc['_id'], u'title': {u'fr': 10, u'en': 3, 'es': 4}}

    def test_i18n_with_list(self):
        class Doc(Document):
            use_dot_notation = True
            structure = {
                "title":[unicode]
            }
            i18n = ['title']
        self.connection.register([Doc])
        
        doc = self.col.Doc()
        doc.title = [u'Hello', u'Hi']
        doc.set_lang('fr')
        doc.title = [u'Bonjour', u'Salut']
        doc.save()

        assert doc.title == ['Bonjour', 'Salut']
        doc.set_lang('en')
        assert doc.title == ['Hello', 'Hi']
        doc.title.append(1)
        self.assertRaises(SchemaTypeError, doc.save)

    def test_i18n_nested_dict(self):
        class Doc(Document):
            structure = {
                'title':{
                    'foo':unicode,
                    'bar':{'bla':int},
                    'egg':int,
                }
            }
            i18n = ['title.foo', 'title.bar.bla']
        self.connection.register([Doc])
        doc = self.col.Doc()
        doc['title']['foo']['fr'] = u'Salut'
        doc['title']['bar']['bla']['fr'] = 3
        doc['title']['egg'] = 4
        doc['title']['foo']['en'] = u"Hello"
        doc['title']['bar']['bla']['en'] = 2
        assert doc == {'title': {'foo': {'fr': u'Salut', 'en': u'Hello'}, 'bar': {'bla': {'fr': 3, 'en': 2}}, 'egg':4}}, doc
        doc.save()

        raw_doc = self.col.find_one({'_id':doc['_id']})
        assert raw_doc == {'_id':doc['_id'],
          u'title': {u'foo': [{u'lang': u'fr', u'value': u'Salut'}, {u'lang': u'en', u'value': u'Hello'}],
          u'bar': {u'bla': [{u'lang': u'fr', u'value': 3}, {u'lang': u'en', u'value': 2}]}, 'egg':4}
        }, raw_doc
        fetched_doc = self.col.Doc.find_one({'_id':doc['_id']})
        assert fetched_doc['title']['foo']['en'] == 'Hello'
        assert fetched_doc['title']['foo']['fr'] == 'Salut'

    def test_i18n_nested_dict_dot_notation(self):
        class Doc(Document):
            use_dot_notation = True
            structure = {
                'toto':{'titi':{'tata':int}},
                'title':{
                    'foo':unicode,
                    'bar':{'bla':int},
                    'egg':int,
                }
            }
            i18n = ['title.foo', 'title.bar.bla']
        self.connection.register([Doc])
        doc = self.col.Doc(lang='fr')
        assert isinstance(doc.toto, DotedDict), type(doc.toto)
        assert isinstance(doc.toto.titi, DotedDict), type(doc.toto.titi)
        assert isinstance(doc.title, i18nDotedDict), type(doc.title)
        assert isinstance(doc.title.bar, i18nDotedDict), type(doc.title.bar)
        assert doc.title.foo is None, type(doc.title.foo)
        doc.get_lang() == 'fr'
        doc.title.foo = u'Salut'
        doc.title.bar.bla = 3
        doc.title.egg = 4
        doc.set_lang('en')
        doc.title.foo = u"Hello"
        doc.title.bar.bla = 2
        doc.save()

        self.assertEqual(doc.toto, {'titi': {'tata': None}})
        self.assertEqual(doc.title, {
            'egg': 4,
            'foo': {'fr': u'Salut', 'en': u'Hello'},
            'bar': {'bla': {'fr': 3, 'en': 2}}
        })
        doc.validate()
        doc.set_lang('fr')
        self.assertEqual(doc.toto, {'titi': {'tata': None}})
        self.assertEqual(doc.title, {
            'egg': 4,
            'foo': {'fr': u'Salut', 'en': u'Hello'},
            'bar': {'bla': {'fr': 3, 'en': 2}}
        })
        self.assertEqual(doc.title.foo, u"Salut")
        self.assertEqual(doc.title.bar.bla, 3)
        doc.save()

        raw_doc = self.col.find_one({'_id':doc['_id']})
        self.assertEqual(raw_doc, {'_id':doc['_id'],
          u'toto': {u'titi': {u'tata': None}},
          u'title': {
              u'foo':[
                  {u'lang': u'fr', u'value': u'Salut'},
                  {u'lang': u'en', u'value': u'Hello'}
                ],
              u'bar': {u'bla': [
                  {u'lang': u'fr', u'value': 3},
                  {u'lang': u'en', u'value': 2}
                ]},
              'egg':4}
        })
        fetched_doc = self.col.Doc.find_one({'_id':doc['_id']})
        assert isinstance(fetched_doc.toto, DotedDict), type(fetched_doc.toto)
        assert isinstance(fetched_doc.toto.titi, DotedDict), type(fetched_doc.toto.titi)
        assert isinstance(fetched_doc.title, i18nDotedDict), type(fetched_doc.title)
        assert isinstance(fetched_doc.title.bar, i18nDotedDict), type(fetched_doc.title.bar)
        self.assertEqual(fetched_doc.get_lang(), 'en')
        self.assertEqual(fetched_doc.title.foo, 'Hello')
        fetched_doc.set_lang('fr')
        assert fetched_doc.title.foo == 'Salut'

    def test_i18n_dot_notation_missing(self):
        class MyDoc(Document):
            use_dot_notation = True
            structure = {
                "existent": unicode,
                'exists': {
                    'subexists': unicode
                }
            }
            i18n = ["existent", "exists.subexists"]
        # We register it, and not use directly coz i18n is fucking broken
        # (see https://github.com/namlook/mongokit/pull/170)
        # TODO: remove this when fix would be applied in upstream
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc(lang='en')
        mydoc.existent = u"31337"
        mydoc.exists.subexists = u"31337"
        self.assertTrue(isinstance(mydoc, MyDoc), 'MyDoc is MyDoc')
        self.assertTrue(isinstance(mydoc.exists, i18nDotedDict), 'Field inside MyDoc is i18nDotedDict')

        self.assertEqual(mydoc.existent, u"31337", 'Getting existent value from dotted')
        self.assertEqual(mydoc.exists.subexists, u"31337", 'Getting existent value from dotted')
        self.assertRaises(AttributeError, lambda: mydoc.not_existent)
        self.assertRaises(AttributeError, lambda: mydoc.exists.not_subexists)

    def test_i18n_fallback(self):
        class Doc(Document):
            use_dot_notation = True
            structure = {
                'title':{
                    'foo':unicode,
                },
                'bar':int,
            }
            i18n = ['title.foo', 'bar']
        self.connection.register([Doc])
        doc = self.col.Doc()
        doc.get_lang() == 'en'
        doc.title.foo = u"Hello"
        doc.bar = 3
        doc.save()
        doc.set_lang('fr')
        assert doc.title.foo == 'Hello'
        assert doc.bar == 3
        doc.title.foo = u'Salut'
        doc.bar = 4
        assert doc.title.foo == 'Salut'
        assert doc.bar == 4
        doc.get_lang() == 'fr'
        
    def test_i18n_bad_type(self):
        class Doc(Document):
            structure = {
                'title':unicode,
            }
            i18n = ['title']
        self.connection.register([Doc])
        doc = self.col.Doc()
        doc['title']['en'] = u'Hello'
        doc['title']['fr'] = 3
        self.assertRaises(SchemaTypeError, doc.save)

    def test_bad_i18n(self):
        failed = False
        try:
            class Doc(Document):
                structure = {
                    'title':unicode,
                }
                i18n = ['title', 'bla']
        except ValueError, e:
            self.assertEqual(str(e), "Error in i18n: can't find bla in structure")
            failed = True
        self.assertEqual(failed, True)

        class Doc(Document):
            use_dot_notation = True
            structure = {
                'title':unicode,
            }
            i18n = ['title']
        self.connection.register([Doc])
        doc = self.col.Doc()
        doc['title']['en'] = u'Hello'
        doc['title'] = u"Salut"
        self.assertRaises(SchemaTypeError, doc.save)
        doc['title'] = i18n()
        doc['title']['en'] = u'Hello'
        doc['title']['fr'] = u"Salut"
        doc.save()
        doc = self.col.Doc.find_random()
        assert doc['title'] == {'en':'Hello', 'fr':'Salut'}

    def test_i18n_inheritance(self):
        class A(Document):
            structure = {
                'a':{
                    'title':unicode,
                }
            }
            i18n = ['a.title']

        class B(A):
            structure = {
                'b':{
                    'title':unicode,
                }
            }
            i18n = ['b.title']


        class C(Document):
            structure = {
                'c':{
                    'title':unicode,
                }
            }
            i18n = ['c.title']

        class D(B, C):
            structure = {
                'd':{
                    'title':unicode,
                }
            }

        self.connection.register([D])
        doc = self.col.D()
        assert doc.i18n == ['a.title', 'c.title', 'b.title'], doc.i18n
        doc['a']['title']['en'] = u'Hello'
        doc['b']['title']['fr'] = u"Salut"
        doc['c']['title']['fr'] = u"Salut"
        assert doc == {'a': {'title': {'en': u'Hello'}}, 'c': {'title': {'fr': u'Salut'}}, 'b': {'title': {'fr': u'Salut'}}, 'd': {'title': None}}

    def test_i18n_default_values(self):
        class Doc(Document):
            use_dot_notation = True
            structure = {
                'title':int,
                'foo':{'bar':unicode},
            }
            i18n = ['title', 'foo.bar']
            default_values = {'title':{'en':3, 'fr':4}, 'foo.bar': {'en':u'bla', 'fr': u'ble'}}
        self.connection.register([Doc])
        doc = self.col.Doc()
        assert doc == {'foo': {'bar': {'fr': u'ble', 'en': u'bla'}}, 'title': {'fr': 4, 'en': 3}}
        doc.save()

    def test_unicode_type_as_key(self):
        class MyDoc(Document):
            structure = {
                "foo":{
                    "bar": unicode,
                    "bla":{
                        unicode:[unicode],
                    },
                },
            }
            i18n = ['foo.bar']
        self.connection.register([MyDoc])
        doc = self.col.MyDoc()
        doc['foo']['bla'][u'spam'] = [u'eggs']
        doc['foo']['bar']['fr'] = u'bla'
        doc.save()



########NEW FILE########
__FILENAME__ = test_index
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest

from mongokit import Connection, Document, OperationFailure, BadIndexError, INDEX_GEO2D, INDEX_ASCENDING, INDEX_DESCENDING

class IndexTestCase(unittest.TestCase):
    def setUp(self):
        self.connection = Connection()
        self.col = self.connection['test']['mongokit']

    def tearDown(self):
        self.connection['test'].drop_collection('mongokit')
        self.connection = None

    def test_index_basic(self):
        class Movie(Document):
            structure = {
                'standard':unicode,
                'other':{
                    'deep':unicode,
                },
                'notindexed':unicode,
            }

            indexes = [
                {
                    'fields':['standard','other.deep'],
                    'unique':True,
                },
            ]
        self.connection.register([Movie])
        movie = self.col.Movie()
        self.col.Movie.generate_index(self.col.Movie.collection)
        movie['standard'] = u'test'
        movie['other']['deep'] = u'testdeep'
        movie['notindexed'] = u'notthere'
        movie.save()

        db = self.connection.test
        item = db['system.indexes'].find_one({'ns':'test.mongokit', 'name': 'standard_1_other.deep_1', 'unique':True})
        assert item is not None, 'No Index Found'

        movie = self.col.Movie()
        movie['standard'] = u'test'
        movie['other']['deep'] = u'testdeep'
        self.assertRaises(OperationFailure, movie.save)

    def test_index_single_without_generation(self):
        class Movie(Document):
            structure = {
                'standard':unicode,
            }

            indexes = [
                {
                    'fields':'standard',
                    'unique':True,
                },
            ]
        self.connection.register([Movie])
        movie = self.col.Movie()
        movie['standard'] = u'test'
        movie.save()

        db = self.connection.test
        item = db['system.indexes'].find_one({'ns':'test.mongokit', 'name':'standard_1', 'unique':True, 'key':{'standard':1}})

        assert item is None, 'Index is found'

    def test_index_single(self):
        class Movie(Document):
            structure = {
                'standard':unicode,
            }

            indexes = [
                {
                    'fields':'standard',
                    'unique':True,
                },
            ]
        self.connection.register([Movie])
        self.col.Movie.generate_index(self.col.Movie.collection)
        movie = self.col.Movie()
        movie['standard'] = u'test'
        movie.save()

        db = self.connection.test
        item = db['system.indexes'].find_one({'ns':'test.mongokit', 'name':'standard_1', 'unique':True, 'key':{'standard':1}})

        assert item is not None, 'No Index Found'

    def test_index_multi(self):
        class Movie(Document):
            structure = {
                'standard':unicode,
                'other':{
                    'deep':unicode,
                },
                'notindexed':unicode,
                'alsoindexed':unicode,
            }

            indexes = [
                {
                    'fields':'standard',
                    'unique':True,
                },
                {
                    'fields':['alsoindexed', 'other.deep'],
                    'unique':True,
                },
            ]
        self.connection.register([Movie])
        self.col.Movie.generate_index(self.col.Movie.collection)
        movie = self.col.Movie()
        movie['standard'] = u'test'
        movie.save()

        db = self.connection.test
        item = db['system.indexes'].find_one({'ns':'test.mongokit', 'name':'standard_1', 'unique':True, 'key':{'standard':1}})
        index2 = db['system.indexes'].find_one({'ns':'test.mongokit', 'name': 'alsoindexed_1_other.deep_1', 'unique':True})

        assert item is not None, 'No Index Found'
        assert index2 is not None, 'Index not found'

        movie = self.col.Movie()
        movie['standard'] = u'test'
        self.assertRaises(OperationFailure, movie.save)

    def test_index_multi2(self):
        class Movie(Document):
            structure = {
                'standard':unicode,
                'other':{
                    'deep':unicode,
                },
                'notindexed':unicode,
                'alsoindexed':unicode,
            }

            indexes = [
                {
                    'fields':'standard',
                    'unique':True,
                },
                {
                    'fields':['other.deep'],
                    'unique':True,
                },
            ]
        self.connection.register([Movie])
        self.col.Movie.generate_index(self.col.Movie.collection)
        movie = self.col.Movie()
        movie['standard'] = u'test'
        movie['other']['deep'] = u'foo'
        movie.save()

        db = self.connection.test
        item = db['system.indexes'].find_one({'ns':'test.mongokit', 'name':'standard_1', 'unique':True, 'key':{'standard':1}})
        index2 = db['system.indexes'].find_one({'ns':'test.mongokit', 'name': 'other.deep_1', 'unique':True})

        assert item is not None, 'No Index Found'
        assert index2 is not None, 'Index not found'

        movie = self.col.Movie()
        movie['standard'] = u'test'
        self.assertRaises(OperationFailure, movie.save)

        movie = self.col.Movie()
        movie['other']['deep'] = u'foo'
        self.assertRaises(OperationFailure, movie.save)

    def test_index_direction(self):
        class Movie(Document):
            structure = {
                'standard':unicode,
                'other':{
                    'deep':unicode,
                },
                'notindexed':unicode,
                'alsoindexed':unicode,
            }

            indexes = [
                {
                    'fields':('standard',INDEX_DESCENDING),
                    'unique':True,
                },
                {
                    'fields':[('alsoindexed',INDEX_ASCENDING), ('other.deep',INDEX_DESCENDING)],
                    'unique':True,
                },
            ]
        self.connection.register([Movie])
        self.col.Movie.generate_index(self.col.Movie.collection)
        movie = self.col.Movie()
        movie['standard'] = u'test'
        movie.save()

        db = self.connection.test
        index1 = db['system.indexes'].find_one({'ns':'test.mongokit', 'name':'standard_-1', 'unique':True})
        index2 = db['system.indexes'].find_one({'ns':'test.mongokit', 'name': 'alsoindexed_1_other.deep_-1', 'unique':True})

        assert index1 is not None, 'No Index Found'
        assert index2 is not None, 'Index not found'

    def test_index_direction_GEO2D(self):
        class Movie(Document):
            structure = {
                'standard':unicode,
                'other':{
                    'deep':unicode,
                },
                'notindexed':unicode,
                'alsoindexed':unicode,
            }

            indexes = [
                {
                    'fields':('standard',INDEX_GEO2D),
                    'unique':True,
                },
                {
                    'fields':[('alsoindexed',INDEX_GEO2D), ('other.deep',INDEX_DESCENDING)],
                    'unique':True,
                },
            ]
        self.connection.register([Movie])
        self.col.Movie.generate_index(self.col.Movie.collection)
        movie = self.col.Movie()
        movie['standard'] = u'test'
        movie.save()

        db = self.connection.test
        index1 = db['system.indexes'].find_one({'ns':'test.mongokit', 'name':'standard_2d', 'unique':True})
        index2 = db['system.indexes'].find_one({'ns':'test.mongokit', 'name': 'alsoindexed_2d_other.deep_-1', 'unique':True})

        assert index1 is not None, 'No Index Found'
        assert index2 is not None, 'Index not found'

    def test_bad_index_descriptor(self):
        failed = False
        try:
            class Movie(Document):
                structure = {'standard':unicode}
                indexes = [{'unique':True}]
        except BadIndexError, e:
            self.assertEqual(str(e), "'fields' key must be specify in indexes")
            failed = True
        self.assertEqual(failed, True)

        failed = False
        try:
            class Movie(Document):
                structure = {
                    'standard':unicode,
                }
                indexes = [
                    {
                        'fields':('standard',INDEX_DESCENDING),
                        'uniq':True,
                    },
                ]
        except BadIndexError, e:
            self.assertEqual(str(e), "uniq is unknown key for indexes")
            failed = True
        #self.assertEqual(failed, True)

        failed = False
        try:
            class Movie(Document):
                structure = {
                    'standard':unicode,
                }
                indexes = [
                    {
                        'fields':'std',
                    },
                ]
        except ValueError, e:
            self.assertEqual(str(e), "Error in indexes: can't find std in structure")
            failed = True
        self.assertEqual(failed, True)

        failed = False
        try:
            class Movie(Document):
                structure = {
                    'standard':unicode,
                }
                indexes = [
                    {
                        'fields':{'standard':1},
                    },
                ]
        except BadIndexError, e:
            self.assertEqual(str(e), "fields must be a string, a tuple or a list of tuple (got <type 'dict'> instead)")
            failed = True
        self.assertEqual(failed, True)

        failed = False
        try:
            class Movie(Document):
                structure = {
                    'standard':unicode,
                }
                indexes = [
                    {
                        'fields':('standard',1, "blah"),
                    },
                ]
        except BadIndexError, e:
            self.assertEqual(str(e), "Error in indexes: a tuple must contain only two value : the field name and the direction")
            failed = True
        self.assertEqual(failed, True)

        failed = False
        try:
            class Movie(Document):
                structure = {
                    'standard':unicode,
                }
                indexes = [
                    {
                        'fields':('standard',"2"),
                    },
                ]
        except BadIndexError, e:
            self.assertEqual(str(e), "index direction must be INDEX_DESCENDING, INDEX_ASCENDING, INDEX_OFF, INDEX_ALL, INDEX_GEO2D, INDEX_GEOHAYSTACK, or INDEX_GEOSPHERE. Got 2")
            failed = True
        self.assertEqual(failed, True)

        failed = False
        try:
            class Movie(Document):
                structure = {
                    'standard':unicode,
                }
                indexes = [
                    {
                        'fields':(3,1),
                    },
                ]
        except BadIndexError, e:
            self.assertEqual(str(e), "Error in 3, the field name must be string (got <type 'int'> instead)")
            failed = True
        self.assertEqual(failed, True)

        failed = False
        try:
            class Movie(Document):
                structure = {
                    'standard':unicode,
                }
                indexes = [
                    {
                        'fields':("blah",1),
                    },
                ]
        except ValueError, e:
            self.assertEqual(str(e), "Error in indexes: can't find blah in structure")
            failed = True
        self.assertEqual(failed, True)

        failed = False
        try:
            class Movie(Document):
                structure = {
                    'standard':unicode,
                }
                indexes = [
                    {
                        'fields':[('standard',1), ('bla',1)],
                    },
                ]
        except ValueError, e:
            self.assertEqual(str(e), "Error in indexes: can't find bla in structure")
            failed = True
        self.assertEqual(failed, True)

        failed = False
        try:
            class Movie(Document):
                structure = {
                    'standard':unicode,
                }
                indexes = [
                    {
                        'fields':[('standard',3)],
                    },
                ]
        except BadIndexError, e:
            self.assertEqual(str(e), "index direction must be INDEX_DESCENDING, INDEX_ASCENDING, INDEX_OFF, INDEX_ALL, INDEX_GEO2D, INDEX_GEOHAYSTACK, or INDEX_GEOSPHERE. Got 3")
            failed = True
        self.assertEqual(failed, True)

        failed = False
        try:
            class Movie(Document):
                structure = {
                    'standard':unicode,
                }
                indexes = [
                    {
                        'fields':['std'],
                    },
                ]
        except ValueError, e:
            self.assertEqual(str(e), "Error in indexes: can't find std in structure")
            failed = True
        self.assertEqual(failed, True)

    def test_index_ttl(self):
        class Movie(Document):
            structure = {
                'standard':unicode,
            }

            indexes = [
                {
                    'fields':'standard',
                    'unique':True,
                    'ttl': 86400
                },
        # If indexes are still broken validation will choke on the ttl
            ]
        self.connection.register([Movie])
        self.col.Movie.generate_index(self.col)
        movie = self.col.Movie()
        movie['standard'] = u'test'
        movie.save()

        db = self.connection.test
        item = db['system.indexes'].find_one({'ns':'test.mongokit', 'name':'standard_1', 'unique':True, 'key':{'standard':1}})

        assert item is not None, 'No Index Found'

    def test_index_simple_inheritance(self):
        class DocA(Document):
            structure = {
                'standard':unicode,
            }

            indexes = [
                {
                    'fields':'standard',
                    'unique':True,
                },
            ]

        class DocB(DocA):
            structure = {
                'docb':unicode,
            }

        self.connection.register([DocA, DocB])
        self.col.DocB.generate_index(self.col)
        docb = self.col.DocB()
        docb['standard'] = u'test'
        docb['docb'] = u'foo'
        docb.save()

        db = self.connection.test
        item = db['system.indexes'].find_one({'ns':'test.mongokit', 'name':'standard_1', 'unique':True, 'key':{'standard':1}})

        assert item is not None, 'No Index Found'

    def test_index_inheritance(self):
        class DocA(Document):
            structure = {
                'standard':unicode,
            }

            indexes = [
                {
                    'fields':'standard',
                    'unique':True,
                },
            ]

        class DocB(DocA):
            structure = {
                'docb':unicode,
            }
            indexes = [
                {
                    'fields':'docb',
                    'unique':True,
                },
            ]
        self.connection.register([DocA, DocB])
        self.col.DocB.generate_index(self.col.DocB.collection)


        docb = self.col.DocB()
        docb['standard'] = u'test'
        docb['docb'] = u'foo'
        docb.save()

        db = self.connection.test
        item = db['system.indexes'].find_one({'ns':'test.mongokit', 'name':'standard_1', 'unique':True, 'key':{'standard':1}})
        item = db['system.indexes'].find_one({'ns':'test.mongokit', 'name':'docb_1', 'unique':True, 'key':{'docb':1}})

        assert item is not None, 'No Index Found'


    def test_index_real_world(self):
        import datetime
        class MyDoc(Document):
            structure = {
                "mydoc":{
                    "creation_date":datetime.datetime,
                }
            }
            indexes = [{'fields':[('mydoc.creation_date',-1), ('_id',1)]}]
        self.connection.register([MyDoc])

        date = datetime.datetime.utcnow()

        mydoc = self.col.MyDoc()
        mydoc['mydoc']['creation_date'] = date
        mydoc['_id'] = u'aaa'
        mydoc.save()


        mydoc3 = self.col.MyDoc()
        mydoc3['mydoc']['creation_date'] = date
        mydoc3['_id'] = u'bbb'
        mydoc3.save()

        import time
        time.sleep(1)
        date2 = datetime.datetime.utcnow()

        mydoc2 = self.col.MyDoc()
        mydoc2['mydoc']['creation_date'] = date2
        mydoc2['_id'] = u'aa'
        mydoc2.save()

        time.sleep(1)
        date3 = datetime.datetime.utcnow()

        mydoc4 = self.col.MyDoc()
        mydoc4['mydoc']['creation_date'] = date3
        mydoc4['_id'] = u'ccc'
        mydoc4.save()

        self.col.ensure_index([('mydoc.creation_date',-1), ('_id',1)])
        results = [i['_id'] for i in self.col.MyDoc.fetch().sort([('mydoc.creation_date',-1),('_id',1)])]
        assert results == ['ccc', 'aa', 'aaa', 'bbb'], results

    def test_index_pymongo(self):
        import datetime
        date = datetime.datetime.utcnow()
        import pymongo
        collection = pymongo.Connection()['test']['test_index']

        mydoc = {'mydoc':{'creation_date':date}, '_id':u'aaa'}
        collection.insert(mydoc)

        mydoc2 = {'mydoc':{'creation_date':date}, '_id':u'bbb'}
        collection.insert(mydoc2)

        import time
        time.sleep(1)
        date2 = datetime.datetime.utcnow()

        mydoc3 = {'mydoc':{'creation_date':date2}, '_id':u'aa'}
        collection.insert(mydoc3)

        time.sleep(1)
        date3 = datetime.datetime.utcnow()

        mydoc4 = {'mydoc':{'creation_date':date3}, '_id':u'ccc'}
        collection.insert(mydoc4)

        collection.ensure_index([('mydoc.creation_date',-1), ('_id',1)])
        #print list(collection.database.system.indexes.find())

        results = [i['_id'] for i in collection.find().sort([('mydoc.creation_date',-1),('_id',1)])]
        print results
        assert results  == [u'ccc', u'aa', u'aaa', u'bbb'], results

    def test_index_inheritance2(self):
        class A(Document):
            structure = {
                'a':{
                    'title':unicode,
                }
            }
            indexes = [{'fields':'a.title'}]

        class B(A):
            structure = {
                'b':{
                    'title':unicode,
                }
            }
            indexes = [{'fields':'b.title'}]


        class C(Document):
            structure = {
                'c':{
                    'title':unicode,
                }
            }
            indexes = [{'fields':'c.title'}]

        class D(B, C):
            structure = {
                'd':{
                    'title':unicode,
                }
            }

        self.connection.register([D])
        doc = self.col.D()
        assert doc.indexes == [{'fields': 'b.title'}, {'fields': 'a.title'}, {'fields': 'c.title'}]

    def test_index_with_default_direction(self):
        class MyDoc(Document):
            structure = {
                'foo': unicode,
                'bar': int
            }
            indexes = [
                {'fields': ['foo', ('bar', -1)]},
            ]
        self.connection.register([MyDoc])
        self.col.MyDoc.generate_index(self.col)
        for i in range(10):
           doc = self.col.MyDoc()
           doc['foo'] = unicode(i)
           doc['bar'] = i
           doc.save()
        assert self.col.database.system.indexes.find_one({'name': 'foo_1_bar_-1'})

    def test_index_with_check(self):
        @self.connection.register
        class MyDoc(Document):
            structure = {
                'foo': dict,
                'bar': int
            }
            indexes = [
                    {'fields': ['foo.title'], 'check':False},
            ]
        self.col.MyDoc.generate_index(self.col)
        for i in range(10):
           doc = self.col.MyDoc()
           doc['foo']['title'] = unicode(i)
           doc['bar'] = i
           doc.save()
        assert self.col.database.system.indexes.find_one({'name': 'foo.title_1'})

    def test_index_with_check_is_true(self):
        @self.connection.register
        class MyDoc(Document):
            structure = {
                'foo': unicode,
                'bar': int
            }
            indexes = [
                    {'fields': ['foo'], 'check':True},
            ]
        self.col.MyDoc.generate_index(self.col)
        for i in range(10):
           doc = self.col.MyDoc()
           doc['foo'] = unicode(i)
           doc['bar'] = i
           doc.save()
        assert self.col.database.system.indexes.find_one({'name': 'foo_1'})

    def test_index_with_additional_keywords(self):
        @self.connection.register
        class KWDoc(Document):
            structure = {
                'foo': unicode,
            }
            indexes = [
                {
                    'fields':[
                        "foo"
                    ],
                    'dropDups':True,
                    'name':'additional_kws',
                }
            ]
        self.col.KWDoc.generate_index(self.col)
        index = self.col.database.system.indexes.find_one({'name': 'additional_kws'})
        assert index["name"] == u'additional_kws'
        assert index["dropDups"] is True

########NEW FILE########
__FILENAME__ = test_inheritance
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest

from mongokit import *

class InheritanceTestCase(unittest.TestCase):
    def setUp(self):
        self.collection = Connection()['test']['mongokit']
        
    def tearDown(self):
        Connection()['test'].drop_collection('mongokit')

    def test_simple_inheritance(self):
        class A(SchemaDocument):
            structure = {
                "a":{"foo":int}
            }

        class B(A):
            structure = {
                "b":{"bar":unicode}
            }

        assert B() == {"a":{"foo":None}, "b":{"bar":None}}, B()

    def test_simple_inheritance_without_child_structure(self):
        class A(SchemaDocument):
            structure = {
                "a":{"foo":int}
            }

        class B(A):
            pass    # no structure defined for B

        b = B()
        b.structure['secret'] = int
        assert 'secret' in b.structure
        assert 'secret' not in A.structure
 
    def test_required_inheritance(self):
        class A(SchemaDocument):
            structure = {
                "a":{"foo":int}
            }
            required_fields = ["a.foo"]

        class B(A):
            structure = {
                "b":{"bar":unicode}
            }

        b = B()
        self.assertRaises(RequireFieldError, b.validate)
        b['a']['foo'] = 4
        b.validate()
 
    def test_default_values_inheritance(self):
        class A(SchemaDocument):
            structure = {
                "a":{"foo":int}
            }
            default_values = {"a.foo":3}

        class B(A):
            structure = {
                "b":{"bar":unicode}
            }

        assert B() == {"a":{"foo":3}, "b":{"bar":None}}
 
        class C(A):
            structure = {
                "c":{"spam":unicode}
            }
            default_values = {"a.foo":5}

        assert C() == {"a":{"foo":5}, "c":{"spam":None}}, C()

    def test_default_values_inheritance_with_function(self):
        from datetime import datetime
        class A(SchemaDocument):
            structure = {
                "a":{"foo":datetime}
            }
            default_values = {"a.foo":datetime.utcnow}

        class B(A):
            structure = {
                "b":{"bar":unicode}
            }

        assert isinstance(B()['a']['foo'], datetime)
 
        class C(A):
            structure = {
                "c":{"spam":unicode}
            }
            default_values = {"a.foo":datetime(2008,8,8)}

        assert C() == {"a":{"foo":datetime(2008, 8, 8)}, "c":{"spam":None}}, C()


    def test_validators_inheritance(self):
        class A(SchemaDocument):
            structure = {
                "a":{"foo":int}
            }
            validators = {"a.foo":lambda x: x>1}

        class B(A):
            structure = {
                "b":{"bar":unicode}
            }

        b = B()
        b["a"]["foo"] = 0
        self.assertRaises(ValidationError, b.validate)
        b["a"]["foo"] = 3
        b.validate()

        class C(A):
            validators = {"a.foo":lambda x: x<1}

        class D(C):
            pass

        d = D()
        d["a"]["foo"] = 4
        self.assertRaises(ValidationError, d.validate)
        d["a"]["foo"] = -3
        d.validate()

    def test_complexe_validation_inheritance(self):
        class A(SchemaDocument):
            structure = {
                "foo":unicode,
            }
            def validate(self):
                self["foo"] = unicode(self["foo"])
                super(A, self).validate()

        class B(A):
            structure = {
                "bar":{"bla":unicode}
            }
            default_values = {"bar.bla":3}
            def validate(self):
                self["bar"]["bla"] = unicode(self["bar"]["bla"])
                super(B, self).validate()

        b = B()
        b['foo'] = 4
        b.validate()
        assert b['foo'] == "4"
        assert b["bar"]["bla"] == "3", b

 
    def test_complete_inheritance(self):
        class A(SchemaDocument):
            structure = {
                "a":{"foo":int}
            }
            default_values = {"a.foo":3}

        class B(A):
            structure = {
                "b":{"bar":unicode}
            }
            required_fields = ['b.bar']
            default_values = {"a.foo":5}

        b =  B()
        assert b == {"a":{"foo":5}, "b":{"bar":None}}
        self.assertRaises(RequireFieldError, b.validate)
 
        class C(B):
            structure = {
                "c":{"spam":unicode}
            }

        c =  C()
        assert c == {"a":{"foo":5}, "b":{"bar":None}, "c":{"spam":None}}, C()
        self.assertRaises(RequireFieldError, c.validate)
        c["b"]["bar"] = u"bla"
        c.validate()

    def test_polymorphism(self):
        class A(SchemaDocument):
            structure = {
                "a":{"foo":int}
            }
            default_values = {"a.foo":3}

        class B(SchemaDocument):
            structure = {
                "b":{"bar":unicode}
            }
            required_fields = ['b.bar']

        b =  B()
        assert b == {"b":{"bar":None}}
        self.assertRaises(RequireFieldError, b.validate)
 
        class C(A,B):
            structure = {
                "c":{"spam":unicode}
            }
            default_values = {"a.foo":5}

        c =  C()
        assert c == {"a":{"foo":5}, "b":{"bar":None}, "c":{"spam":None}}, C()
        self.assertRaises(RequireFieldError, c.validate)
        c["b"]["bar"] = u"bla"
        c.validate()
   
    def test_simple_manual_inheritance(self):
        class A(SchemaDocument):
            auto_inheritance = False
            structure = {
                "a":{"foo":int}
            }

        class B(A):
            structure = {
                "b":{"bar":unicode}
            }
            structure.update(A.structure)

        assert B() == {"a":{"foo":None}, "b":{"bar":None}}
 
    def test_required_manual_inheritance(self):
        class A(SchemaDocument):
            auto_inheritance = False
            structure = {
                "a":{"foo":int}
            }
            required_fields = ["a.foo"]

        class B(A):
            structure = {
                "b":{"bar":unicode}
            }
            structure.update(A.structure)
            required_fields = A.required_fields

        b = B()
        self.assertRaises(RequireFieldError, b.validate)
        b['a']['foo'] = 4
        b.validate()
 
    def test_default_values_manual_inheritance(self):
        class A(SchemaDocument):
            auto_inheritance = False
            structure = {
                "a":{"foo":int}
            }
            default_values = {"a.foo":3}

        class B(A):
            structure = {
                "b":{"bar":unicode}
            }
            structure.update(A.structure)
            default_values = A.default_values

        assert B() == {"a":{"foo":3}, "b":{"bar":None}}
 
        class C(A):
            structure = {
                "c":{"spam":unicode}
            }
            structure.update(A.structure)
            default_values = A.default_values
            default_values.update({"a.foo":5})

        assert C() == {"a":{"foo":5}, "c":{"spam":None}}, C()
  


########NEW FILE########
__FILENAME__ = test_inherited_queries
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest

from mongokit import Document, Connection

class InheritedQueriesTestCase(unittest.TestCase):
    def setUp(self):
        self.connection = Connection(safe=True)
        self.col = self.connection['test']['mongolite']
        
    def tearDown(self):
        self.connection.drop_database('test')

    def test_use_inherited_queries(self):
        @self.connection.register
        class A(Document):
            __database__ = 'test'
            __collection__ = 'mongolite'
            structure = {
                '_type': unicode,
                'a':{
                    'foo': int,
                    'bar': unicode,
                }
            }

        @self.connection.register
        class B(A):
            structure = {
                'b': {
                    'eggs': float,
                }
            }

        doc_a = self.connection.A()
        self.assertEqual(doc_a['_type'], 'A')
        doc_a['a']['foo'] = 3
        doc_a['a']['bar'] = u'Hello World'
        doc_a.save()

        doc_b = self.connection.B()
        self.assertEqual(doc_b['_type'], 'B')
        doc_b['a']['foo'] = 42
        doc_b['a']['bar'] = u'bye bye'
        doc_b['b']['eggs'] = 3.14
        doc_b.save()

        self.assertTrue(isinstance(self.connection.A.find_one({'_id':doc_b['_id']}), B))
        self.assertTrue(isinstance(self.connection.A.find({'_id':doc_b['_id']}).next(), B))
        self.assertTrue(isinstance(self.connection.A.find({'_id':doc_b['_id']})[0], B))

    def test_inherited_queries_without___collection__(self):
        @self.connection.register
        class A(Document):
            structure = {
                '_type': unicode,
                'a':{
                    'foo': int,
                    'bar': unicode,
                }
            }

        @self.connection.register
        class B(A):
            structure = {
                'b': {
                    'eggs': float,
                }
            }

        doc_a = self.col.A()
        self.assertEqual(doc_a['_type'], 'A')
        doc_a['a']['foo'] = 3
        doc_a['a']['bar'] = u'Hello World'
        doc_a.save()

        doc_b = self.col.B()
        self.assertEqual(doc_b['_type'], 'B')
        doc_b['a']['foo'] = 42
        doc_b['a']['bar'] = u'bye bye'
        doc_b['b']['eggs'] = 3.14
        doc_b.save()

        self.assertTrue(isinstance(self.col.A.find_one({'_id':doc_b['_id']}), B))
        self.assertTrue(isinstance(self.col.A.find({'_id':doc_b['_id']}).next(), B))
        self.assertTrue(isinstance(self.col.A.find({'_id':doc_b['_id']})[0], B))

    def test_type_field_is_None(self):
        @self.connection.register
        class A(Document):
            type_field = None
            structure = {
                '_type': unicode,
                'a':{
                    'foo': int,
                    'bar': unicode,
                }
            }

        @self.connection.register
        class B(A):
            structure = {
                'b': {
                    'eggs': float,
                }
            }

        doc_a = self.col.A()
        self.assertEqual(doc_a['_type'], None)
        doc_a['a']['foo'] = 3
        doc_a['a']['bar'] = u'Hello World'
        doc_a.save()

        doc_b = self.col.B()
        self.assertEqual(doc_b['_type'], None)
        doc_b['a']['foo'] = 42
        doc_b['a']['bar'] = u'bye bye'
        doc_b['b']['eggs'] = 3.14
        doc_b.save()

        self.assertTrue(isinstance(self.col.A.find_one({'_id':doc_b['_id']}), A))
        self.assertTrue(isinstance(self.col.A.find({'_id':doc_b['_id']}).next(), A))
        self.assertFalse(isinstance(self.col.A.find_one({'_id':doc_b['_id']}), B))
        self.assertFalse(isinstance(self.col.A.find({'_id':doc_b['_id']}).next(), B))

    def test_no__type(self):
        @self.connection.register
        class A(Document):
            structure = {
                'a':{
                    'foo': int,
                    'bar': unicode,
                }
            }

        @self.connection.register
        class B(A):
            structure = {
                'b': {
                    'eggs': float,
                }
            }

        doc_a = self.col.A()
        self.assertTrue('_type' not in doc_a)
        doc_a['a']['foo'] = 3
        doc_a['a']['bar'] = u'Hello World'
        doc_a.save()

        doc_b = self.col.B()
        self.assertTrue('_type' not in doc_b)
        doc_b['a']['foo'] = 42
        doc_b['a']['bar'] = u'bye bye'
        doc_b['b']['eggs'] = 3.14
        doc_b.save()

        self.assertTrue(isinstance(self.col.A.find_one({'_id':doc_b['_id']}), A))
        self.assertTrue(isinstance(self.col.A.find({'_id':doc_b['_id']}).next(), A))
        self.assertFalse(isinstance(self.col.A.find_one({'_id':doc_b['_id']}), B))
        self.assertFalse(isinstance(self.col.A.find({'_id':doc_b['_id']}).next(), B))

    def test_change_type_field(self):
        @self.connection.register
        class A(Document):
            type_field = '_t'
            structure = {
                '_type': unicode,
                '_t': unicode,
                'a':{
                    'foo': int,
                    'bar': unicode,
                }
            }

        @self.connection.register
        class B(A):
            structure = {
                'b': {
                    'eggs': float,
                }
            }

        doc_a = self.col.A()
        self.assertEqual(doc_a['_type'], None)
        self.assertEqual(doc_a['_t'], 'A')
        doc_a['a']['foo'] = 3
        doc_a['a']['bar'] = u'Hello World'
        doc_a.save()

        doc_b = self.col.B()
        self.assertEqual(doc_b['_type'], None)
        self.assertEqual(doc_b['_t'], 'B')
        doc_b['a']['foo'] = 42
        doc_b['a']['bar'] = u'bye bye'
        doc_b['b']['eggs'] = 3.14
        doc_b.save()

        self.assertTrue(isinstance(self.col.A.find_one({'_id':doc_b['_id']}), A))
        self.assertTrue(isinstance(self.col.A.find({'_id':doc_b['_id']}).next(), A))
        self.assertTrue(isinstance(self.col.A.find_one({'_id':doc_b['_id']}), B))
        self.assertTrue(isinstance(self.col.A.find({'_id':doc_b['_id']}).next(), B))



########NEW FILE########
__FILENAME__ = test_json
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest

from mongokit import *
from bson.objectid import ObjectId
import datetime


class JsonTestCase(unittest.TestCase):
    def setUp(self):
        self.connection = Connection()
        self.col = self.connection['test']['mongokit']

    def tearDown(self):
        self.connection['test'].drop_collection('mongokit')
        self.connection['test'].drop_collection('versionned_mongokit')

    def test_simple_to_json(self):
        class MyDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                    "egg":datetime.datetime,
                },
                "spam":[],
            }
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc'
        mydoc["bla"]["foo"] = u"bar"
        mydoc["bla"]["bar"] = 42
        mydoc['bla']['egg'] = datetime.datetime(2010, 1, 1)
        mydoc['spam'] = range(10)
        mydoc.save()
        import json
        
        assert  json.loads(mydoc.to_json()) == json.loads('{"_id": "mydoc", "bla": {"egg": 1262304000000, "foo": "bar", "bar": 42}, "spam": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}'), mydoc.to_json()
        assert  mydoc.to_json_type() == {'_id': 'mydoc', 'bla': {'egg': 1262304000000, 'foo': u'bar', 'bar': 42}, 'spam': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}, mydoc.to_json_type()

        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc2'
        mydoc["bla"]["foo"] = u"bar"
        mydoc["bla"]["bar"] = 42
        mydoc['spam'] = [datetime.datetime(2000, 1, 1), datetime.datetime(2008, 8, 8)]
        mydoc.save()
        assert json.loads(mydoc.to_json()) == json.loads('{"_id": "mydoc2", "bla": {"egg": null, "foo": "bar", "bar": 42}, "spam": [946684800000, 1218153600000]}'), mydoc.to_json()
        assert mydoc.to_json_type() == {'_id': 'mydoc2', 'bla': {'egg': None, 'foo': u'bar', 'bar': 42}, 'spam': [946684800000, 1218153600000]}, mydoc.to_json_type()

    def test_simple_to_json_with_oid(self):
        class MyDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam":[],
            }
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc["bla"]["foo"] = u"bar"
        mydoc["bla"]["bar"] = 42
        mydoc['spam'] = range(10)
        mydoc.save()
        assert  isinstance(mydoc.to_json_type()['_id']['$oid'], basestring), type(mydoc.to_json_type()['_id'])
        assert isinstance(mydoc.to_json(), unicode)
 
    def test_simple_to_json_with_oid_in_list(self):
        class A(Document):
            structure = {
                "foo":unicode,
            }
        class B(Document):
            structure = {
                'bar':[ObjectId],
                'egg':{
                    'nested':ObjectId,
                }
            }
 
        self.connection.register([A, B])
        a = self.col.A()
        a["foo"] = u"bar"
        a.save()
        assert  isinstance(a.to_json_type()['_id']['$oid'], basestring), type(a.to_json_type()['_id'])
        a.to_json()
        b = self.col.B()
        b['bar'] = [a['_id']]
        b['egg']['nested'] = a['_id']
        b.save()
        print b.to_json_type()
        assert  isinstance(b.to_json_type()['_id']['$oid'], basestring), b.to_json_type()
        assert  isinstance(b.to_json_type()['egg']['nested']['$oid'], basestring), b.to_json_type()
        assert  isinstance(b.to_json_type()['bar'][0]['$oid'], basestring), b.to_json_type()
        assert  isinstance(b.to_json_type()['egg']['nested']['$oid'], basestring), b.to_json_type()
        assert "ObjectId" not in b.to_json()
 
    def test_simple_to_json_with_no_id(self):
        class MyDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam":[],
            }
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc["bla"]["foo"] = u"bar"
        mydoc["bla"]["bar"] = 42
        mydoc['spam'] = range(10)
        assert  "_id" not in mydoc.to_json_type()
        assert mydoc.to_json() == '{"bla": {"foo": "bar", "bar": 42}, "spam": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}'
 
    def test_to_json_custom_type(self):
        class CustomDegree(CustomType):
            mongo_type = int
            python_type = basestring
            def to_bson(self, value):
                if value is not None:
                    return int(value.replace('C', ''))
            def to_python(self, value):
                if value is not None:
                    return str(value)+"C"
 
        class MyDoc(Document):
            structure = {
                "doc":{
                    "foo":CustomDegree(),
                },
            }
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc'
        mydoc['doc']['foo'] = '3C'
        mydoc.save()
        self.assertEqual(
            self.col.MyDoc.collection.find_one({'_id': 'mydoc'}),
            {"doc": {"foo": 3}, "_id": "mydoc"}
        )
        self.assertEqual(
            mydoc.to_json(),
            '{"doc": {"foo": "3C"}, "_id": "mydoc"}',
        )
        self.assertEqual(mydoc.to_json_type(), {"doc": {"foo": "3C"}, "_id": "mydoc"})
 
    def test_to_json_embeded_doc(self):
        class EmbedDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam":[],
            }
        class MyDoc(Document):
            structure = {
                "doc":{
                    "embed":EmbedDoc,
                },
            }
            use_autorefs = True
        self.connection.register([MyDoc, EmbedDoc])
        embed = self.col.EmbedDoc()
        embed['_id'] = u'embed'
        embed["bla"]["foo"] = u"bar"
        embed["bla"]["bar"] = 42
        embed['spam'] = range(10)
        embed.save()
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc'
        mydoc['doc']['embed'] = embed
        mydoc.save()
        assert mydoc.to_json() == '{"doc": {"embed": {"_collection": "mongokit", "_database": "test", "_id": "embed", "bla": {"foo": "bar", "bar": 42}, "spam": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}}, "_id": "mydoc"}'
        assert mydoc.to_json_type() == {"doc": {"embed": {"_id": "embed", "bla": {"foo": "bar", "bar": 42}, "spam": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}}, "_id": "mydoc"}
 
    def test_to_json_embeded_doc_with_oid(self):
        class EmbedDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam":[],
            }
        class MyDoc(Document):
            structure = {
                "doc":{
                    "embed":EmbedDoc,
                },
            }
            use_autorefs = True
        self.connection.register([MyDoc, EmbedDoc])
        embed = self.col.EmbedDoc()
        embed["bla"]["foo"] = u"bar"
        embed["bla"]["bar"] = 42
        embed['spam'] = range(10)
        embed.save()
        mydoc = self.col.MyDoc()
        mydoc['doc']['embed'] = embed
        mydoc.save()
        assert isinstance(mydoc.to_json_type()['doc']['embed']['_id']['$oid'], basestring)
        assert mydoc.to_json() == '{"doc": {"embed": {"_collection": "mongokit", "_database": "test", "_id": {"$oid": "%s"}, "bla": {"foo": "bar", "bar": 42}, "spam": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}}, "_id": {"$oid": "%s"}}' % (
          embed['_id'], mydoc['_id']), mydoc.to_json()
 
    def test_to_json_with_None_embeded_doc(self):
        class EmbedDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam":[],
            }
        class MyDoc(Document):
            structure = {
                "doc":{
                    "embed":EmbedDoc,
                },
            }
            use_autorefs = True
        self.connection.register([MyDoc, EmbedDoc])
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc'
        mydoc.save()
        assert mydoc.to_json() == '{"doc": {"embed": null}, "_id": "mydoc"}'
        assert mydoc.to_json_type() == {'doc': {'embed': None}, '_id': 'mydoc'}, mydoc.to_json_type()
 
    def test_to_json_with_dict_in_list(self):
        class MyDoc(Document):
            structure = {
                "foo":[{'bar':unicode, 'egg':int}],
            }
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc'
        mydoc["foo"] = [{'bar':u'bla', 'egg':3}, {'bar':u'bli', 'egg':4}]
        mydoc.save()
        assert  mydoc.to_json() == '{"foo": [{"bar": "bla", "egg": 3}, {"bar": "bli", "egg": 4}], "_id": "mydoc"}', mydoc.to_json()
        assert  mydoc.to_json_type() == {'foo': [{'bar': u'bla', 'egg': 3}, {'bar': u'bli', 'egg': 4}], '_id': 'mydoc'}
 
 
    def test_simple_from_json(self):
        class MyDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam":[],
            }
        self.connection.register([MyDoc])
        json = '{"_id": "mydoc", "bla": {"foo": "bar", "bar": 42}, "spam": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}'
        mydoc = self.col.MyDoc.from_json(json)
        assert mydoc == {'_id': 'mydoc', 'bla': {'foo': 'bar', 'bar': 42}, 'spam': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}
        assert mydoc.collection == self.col
 
    def test_simple_from_json2(self):
        class MyDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                    "egg":datetime.datetime,
                },
                "spam":[datetime.datetime],
            }
        self.connection.register([MyDoc])
        json = '{"_id": "mydoc2", "bla": {"foo": "bar", "bar": 42, "egg":946684800000}, "spam": [946684800000, 1218153600000]}'
        mydoc = self.col.MyDoc.from_json(json)
        assert mydoc == {'_id': 'mydoc2', 'bla': {'foo': 'bar', 'bar': 42, "egg":datetime.datetime(2000, 1, 1, 0, 0)}, 'spam': [datetime.datetime(2000, 1, 1, 0, 0), datetime.datetime(2008, 8, 8, 0, 0)]}, mydoc
        assert mydoc.collection == self.col
 
    def test_from_json_embeded_doc(self):
        class EmbedDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam":[],
            }
        class MyDoc(Document):
            structure = {
                "doc":{
                    "embed":EmbedDoc,
                },
            }
            use_autorefs = True
        self.connection.register([MyDoc, EmbedDoc])
 
        embed = self.col.EmbedDoc()
        embed['_id'] = u"embed"
        embed["bla"] = {"foo": u"bar", "bar": 42}
        embed["spam"] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        embed.save()
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc'
        mydoc['doc']['embed'] = embed
        mydoc.save()
        json = mydoc.to_json()
        assert json == '{"doc": {"embed": {"_collection": "mongokit", "_database": "test", "_id": "embed", "bla": {"foo": "bar", "bar": 42}, "spam": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}}, "_id": "mydoc"}', json
        mydoc = self.col.MyDoc.from_json(json)
        assert mydoc == {'doc': {'embed': {u'_id': u'embed', u'bla': {u'foo': u'bar', u'bar': 42}, u'spam': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}}, '_id': u'mydoc'}, mydoc
        assert isinstance(mydoc['doc']['embed'], EmbedDoc)
 
    def test_from_json_embeded_doc_with_oid(self):
        class EmbedDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam":[],
            }
        class MyDoc(Document):
            structure = {
                "doc":{
                    "embed":EmbedDoc,
                },
            }
            use_autorefs = True
        self.connection.register([MyDoc, EmbedDoc])
 
        embed = self.col.EmbedDoc()
        embed["bla"] = {"foo": u"bar", "bar": 42}
        embed["spam"] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        embed.save()
        mydoc = self.col.MyDoc()
        mydoc['doc']['embed'] = embed
        mydoc.save()
        json = mydoc.to_json()
        assert json == '{"doc": {"embed": {"_collection": "mongokit", "_database": "test", "_id": {"$oid": "%s"}, "bla": {"foo": "bar", "bar": 42}, "spam": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}}, "_id": {"$oid": "%s"}}' %(
          embed['_id'], mydoc['_id']), json
        doc = self.col.MyDoc.from_json(json)
        assert doc == {'doc': {'embed': {u'_id': embed['_id'], u'bla': {u'foo': u'bar', u'bar': 42}, u'spam': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}}, '_id': mydoc['_id']}, doc
        assert isinstance(doc['doc']['embed'], EmbedDoc)
 
 
    def test_from_json_with_None_embeded_doc(self):
        class EmbedDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam":[],
            }
        class MyDoc(Document):
            structure = {
                "doc":{
                    "embed":EmbedDoc,
                },
            }
            use_autorefs = True
        self.connection.register([MyDoc, EmbedDoc])
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc'
        mydoc.save()
        json= mydoc.to_json()
        assert json == '{"doc": {"embed": null}, "_id": "mydoc"}'
        doc = self.col.MyDoc.from_json(json)
        assert doc == {'doc': {'embed': None}, '_id': 'mydoc'}
 
    def test_from_json_embeded_doc_in_list(self):
        class EmbedDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam":[],
            }
        class MyDoc(Document):
            structure = {
                "doc":{
                    "embed":[EmbedDoc],
                },
            }
            use_autorefs = True
        self.connection.register([MyDoc, EmbedDoc])
        embed = self.col.EmbedDoc()
        embed['_id'] = u"embed"
        embed["bla"] = {"foo": u"bar", "bar": 42}
        embed["spam"] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        embed.save()
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc'
        mydoc['doc']['embed'] = [embed]
        mydoc.save()
        json = mydoc.to_json()
        assert json == '{"doc": {"embed": [{"_collection": "mongokit", "_database": "test", "_id": "embed", "bla": {"foo": "bar", "bar": 42}, "spam": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}]}, "_id": "mydoc"}'
        mydoc = self.col.MyDoc.from_json(json)
        assert mydoc == {'doc': {'embed': [{u'_id': u'embed', u'bla': {u'foo': u'bar', u'bar': 42}, u'spam': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}]}, '_id': u'mydoc'}, mydoc
        assert isinstance(mydoc['doc']['embed'][0], EmbedDoc)
 
    def test_from_json_embeded_doc_in_list_with_oid(self):
        class EmbedDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam":[],
            }
        class MyDoc(Document):
            structure = {
                "doc":{
                    "embed":[EmbedDoc],
                },
            }
            use_autorefs = True
        self.connection.register([MyDoc, EmbedDoc])
        embed = self.col.EmbedDoc()
        embed["bla"] = {"foo": u"bar", "bar": 42}
        embed["spam"] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        embed.save()
        mydoc = self.col.MyDoc()
        mydoc['doc']['embed'] = [embed]
        mydoc.save()
        json = mydoc.to_json()
        assert json == '{"doc": {"embed": [{"_collection": "mongokit", "_database": "test", "_id": {"$oid": "%s"}, "bla": {"foo": "bar", "bar": 42}, "spam": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}]}, "_id": {"$oid": "%s"}}' %(
          embed['_id'], mydoc['_id']), json
        doc = self.col.MyDoc.from_json(json)
        assert doc == {'doc': {'embed': [{u'_id': embed['_id'], u'bla': {u'foo': u'bar', u'bar': 42}, u'spam': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}]}, '_id': mydoc['_id']}, doc
        assert isinstance(doc['doc']['embed'][0], EmbedDoc)
 
    def test_from_json_with_no_embeded_doc_in_list(self):
        class EmbedDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam":[],
            }
        class MyDoc(Document):
            structure = {
                "doc":{
                    "embed":[EmbedDoc],
                },
            }
            use_autorefs = True
        self.connection.register([MyDoc, EmbedDoc])
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc'
        mydoc.save()
        json = mydoc.to_json()
        assert json == '{"doc": {"embed": []}, "_id": "mydoc"}'
        mydoc = self.col.MyDoc.from_json(json)
        assert mydoc == {'doc': {'embed': []}, '_id': 'mydoc'}
 
    def test_from_json_dict_in_list(self):
        class MyDoc(Document):
            structure = {
                "doc":{
                    "embed":[{"foo":unicode, "bar":int}],
                },
            }
            use_autorefs = True
        self.connection.register([MyDoc])
        json = '{"doc": {"embed": [{"foo": "bar", "bar": 42}]}, "_id": "mydoc"}'
        mydoc = self.col.MyDoc.from_json(json)
        assert mydoc == {'doc': {'embed': [{'foo': 'bar', 'bar': 42}]}, '_id': 'mydoc'}, mydoc
 
    def test_from_json_unicode(self):
        class MyDoc(Document):
            structure = {
                "doc":{
                    "name":unicode
                },
                "foo": unicode,
            }
            use_autorefs = True
        self.connection.register([MyDoc])
 
        mydoc = self.col.MyDoc()
        mydoc['doc']['name'] = u'bla'
        mydoc['foo'] = u'bar'
        json = mydoc.to_json()
        mydoc2 = self.col.MyDoc.from_json(json)
        assert isinstance(mydoc['doc']['name'], unicode)
        assert isinstance(mydoc['foo'], unicode)
        assert isinstance(mydoc2['doc']['name'], unicode)
        assert isinstance(mydoc2['foo'], unicode)
 
    def test_simple_to_json_from_cursor(self):
        class MyDoc(Document):
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                },
                "spam":[],
            }
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc'
        mydoc["bla"]["foo"] = u"bar"
        mydoc["bla"]["bar"] = 42
        mydoc['spam'] = range(10)
        mydoc.save()
        json = mydoc.to_json()
        assert json == '{"_id": "mydoc", "bla": {"foo": "bar", "bar": 42}, "spam": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}'
 
        mydoc2 = self.col.MyDoc()
        mydoc2['_id'] = u'mydoc2'
        mydoc2["bla"]["foo"] = u"bla"
        mydoc2["bla"]["bar"] = 32
        mydoc2['spam'] = [datetime.datetime(2000, 1, 1), datetime.datetime(2008, 8, 8)]
        mydoc2.save()
        json2 = mydoc2.to_json()
 
        assert [i.to_json() for i in self.col.MyDoc.fetch()] == [json, json2]
 
    def test_anyjson_import_error(self):
        import sys
        newpathlist = sys.path
        sys.path = []
        class MyDoc(Document):
            structure = {
                "foo":int,
            }
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc'
        mydoc["foo"] = 4
        mydoc.save()
        self.assertRaises(ImportError, mydoc.to_json)
        self.assertRaises(ImportError, self.col.MyDoc.from_json, '{"_id":"mydoc", "foo":4}')
        sys.path = newpathlist
        del newpathlist
 
    def test_to_json_with_dot_notation(self):
        class MyDoc(Document):
            use_dot_notation = True
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                    "egg":datetime.datetime,
                },
                "spam":[],
            }
        self.connection.register([MyDoc])
 
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc'
        mydoc["bla"]["foo"] = u"bar"
        mydoc["bla"]["bar"] = 42
        mydoc['bla']['egg'] = datetime.datetime(2010, 1, 1)
        mydoc['spam'] = range(10)
        mydoc.save()
        import json
        self.assertEqual(json.loads(mydoc.to_json()),
          json.loads('{"_id": "mydoc", "bla": {"bar": 42, "foo": "bar", "egg": 1262304000000}, "spam": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}'))
        self.assertEqual(mydoc.to_json_type(),
          {'_id': 'mydoc', 'bla': {'egg': 1262304000000, 'foo': u'bar', 'bar': 42}, 'spam': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]})
 
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc'
        mydoc.bla.foo = u"bar"
        mydoc.bla.bar = 42
        mydoc.bla.egg = datetime.datetime(2010, 1, 1)
        mydoc.spam = range(10)
        mydoc.save()
        self.assertEqual(json.loads(mydoc.to_json()),
          json.loads('{"_id": "mydoc", "bla": {"bar": 42, "foo": "bar", "egg": 1262304000000}, "spam": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}'))
        self.assertEqual(mydoc.to_json_type(),
          {'_id': 'mydoc', 'bla': {'egg': 1262304000000, 'foo': u'bar', 'bar': 42}, 'spam': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]})
 
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc2'
        mydoc.bla.foo = u"bar"
        mydoc.bla.bar = 42
        mydoc.spam = [datetime.datetime(2000, 1, 1), datetime.datetime(2008, 8, 8)]
        mydoc.save()
        self.assertEqual(json.loads(mydoc.to_json()),
          json.loads('{"_id": "mydoc2", "bla": {"bar": 42, "foo": "bar", "egg": null}, "spam": [946684800000, 1218153600000]}'))
        self.assertEqual(mydoc.to_json_type(),
          {'_id': 'mydoc2', 'bla': {'egg': None, 'foo': u'bar', 'bar': 42}, 'spam': [946684800000, 1218153600000]})
 
    def test_to_json_with_i18n_and_dot_notation(self):
        class MyDoc(Document):
            use_dot_notation = True
            structure = {
                "bla":{
                    "foo":unicode,
                    "bar":int,
                    "egg":datetime.datetime,
                },
                "spam":[],
            }
            i18n = ['bla.foo']
        self.connection.register([MyDoc])
 
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc'
        mydoc.bla.foo = u"bar"
        mydoc.bla.bar = 42
        mydoc.bla.egg = datetime.datetime(2010, 1, 1)
        mydoc.spam = range(10)
        mydoc.set_lang('fr')
        mydoc.bla.foo = u"arf"
        mydoc.save()
        import json
        self.assertEqual(mydoc.to_json_type(),
          {'_id': 'mydoc', 'bla': {'bar': 42, 'foo': {'fr': u'arf', 'en': u'bar'}, 'egg': 1262304000000}, 'spam': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]})
        self.assertEqual(json.loads(mydoc.to_json()),
          json.loads('{"_id": "mydoc", "bla": {"egg": 1262304000000, "foo": {"fr": "arf", "en": "bar"}, "bar": 42}, "spam": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}'))
 
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc2'
        mydoc.bla.foo = u"bar"
        mydoc.bla.bar = 42
        mydoc.spam = [datetime.datetime(2000, 1, 1), datetime.datetime(2008, 8, 8)]
        mydoc.save()
        self.assertEqual(mydoc.to_json_type(),
          {'_id': 'mydoc2', 'bla': {'bar': 42, 'foo': {'en': u'bar'}, 'egg': None}, 'spam': [946684800000, 1218153600000]})
        self.assertEqual(json.loads(mydoc.to_json()),
          json.loads('{"_id": "mydoc2", "bla": {"egg": null, "foo": {"en": "bar"}, "bar": 42}, "spam": [946684800000, 1218153600000]}'))
 
 
    def test_from_json_with_list(self):
        class MyDoc(Document):
            structure = {
                'foo': {'bar': [unicode]}
            }
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'mydoc'
        mydoc['foo']['bar'] = [u'a', u'b', u'c']
        mydoc.save()
        json = u'{"_id": "mydoc", "foo":{"bar":["a", "b", "c"]}}'
        doc_from_json = self.col.MyDoc.from_json(json)
        doc_from_json.save()
        assert doc_from_json == mydoc
 
    def test_from_json_with_ref(self):
        class A(Document):
            structure = {
                'foo': unicode
            }
        class B(Document):
            structure = {
                'bar': int,
                'a': A,
            }
            use_autorefs = True
        self.connection.register([A, B])
        a = self.col.A()
        a['_id'] = u'a'
        a['foo'] = u'a'
        a.save()
 
        json = '{"_id": "b", "bar":1, "a":{"$id": "a", "$ref": "%s", "$db": "%s"}}' % (self.col.name, self.col.database.name)
        print json
        b = self.col.B.from_json(json)
        b.save()
        assert isinstance(b['a'], A), type(b['a'])
 
    def test_from_json_with_ref_in_list(self):
        class A(Document):
            structure = {
                'foo': unicode
            }
        class B(Document):
            structure = {
                'bar': int,
                'a': [A],
            }
            use_autorefs = True
        self.connection.register([A, B])
        a = self.col.A()
        a['_id'] = u'a'
        a['foo'] = u'a'
        a.save()
 
        json = '{"_id": "b", "bar":1, "a":[{"$id": "a", "$ref": "%s", "$db": "%s"}]}' % (self.col.name, self.col.database.name)
        b = self.col.B.from_json(json)
        b.save()
        assert isinstance(b['a'][0], A), type(b['a'][0])
 
    def test_from_json_with_type_as_key(self):
        class MyDoc(Document):
            structure = {
                'foo': {unicode:[unicode]}
            }
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc['_id'] = u'a'
        mydoc['foo'][u'bar'] = [u'bla', u'ble']
 
        json = '{"_id": "a", "foo": {"bar":["bla", "ble"]}}'
        mydoc_from_json = self.col.MyDoc.from_json(json)
        assert mydoc == mydoc_from_json, (mydoc, mydoc_from_json)
 
 
    def test_from_json_with_null_date(self):
        class MyDoc(Document):
            structure = {
                'date': datetime.datetime,
                'date_in_list': [datetime.datetime],
            }
        self.connection.register([MyDoc])
 
        json = '{"_id": "a", "date": null, "date_in_list":[]}'
        mydoc_from_json = self.col.MyDoc.from_json(json)
        assert mydoc_from_json['_id'] == 'a'
        assert mydoc_from_json['date'] is None
        assert mydoc_from_json['date_in_list'] == []

########NEW FILE########
__FILENAME__ = test_mapreduce
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest

from mongokit import *

class MapReduceTestCase(unittest.TestCase):
    def setUp(self):
        self.connection = Connection()
        self.col = self.connection['test']['mongokit']
        
    def tearDown(self):
        self.connection.drop_database('test')

    def test_simple_mapreduce(self):
        class MyDoc(Document):
            structure = {
                'user_id': int,
            }
        self.connection.register([MyDoc])

        for i in range(20):
            self.col.MyDoc({'user_id':i}).save()

        class MapDoc(Document):
            """
            document which handle result of map/reduce
            """
            structure = {
                'value':float,
            }
        self.connection.register([MapDoc])   

        m = 'function() { emit(this.user_id, 1); }'
        r = 'function(k,vals) { return 1; }'
        mapcol = self.col.map_reduce(m,r,"testresults")
        mapdoc = mapcol.MapDoc.find_one()
        assert mapdoc == {u'_id': 0.0, u'value': 1.0}, mapdoc
        assert isinstance(mapdoc, MapDoc)

########NEW FILE########
__FILENAME__ = test_migration
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest

from mongokit import *
from bson.objectid import ObjectId
from datetime import datetime


class MigrationTestCase(unittest.TestCase):
    def setUp(self):
        self.connection = Connection()
        self.col = self.connection['test']['mongokit']

        # create initial blog post class
        class BlogPost(Document):
            structure = {
                'author':unicode,
                "blog_post":{
                    "title": unicode,
                    "created_at": datetime,
                    "body": unicode,
                }
            }
            default_values = {'blog_post.created_at':datetime(2010, 1, 1)}
        self.connection.register([BlogPost])

        # creating some blog posts
        for i in range(10):
            blog_post = self.col.BlogPost()
            blog_post['blog_post']['title'] = u'hello %s' % i
            blog_post['blog_post']['body'] = u'I the post number %s' % i
            blog_post.save()
       
    def tearDown(self):
        self.connection.drop_database('test')
        self.connection.drop_database('othertest')

    def test_simple_doc_migration(self):
        class BlogPost(Document):
            structure = {
                "author":unicode,
                "blog_post":{
                    "title": unicode,
                    "created_at": datetime,
                    "body": unicode,
                    "tags":  [unicode],
                }
            }
        self.connection.register([BlogPost])
        bp =  self.col.BlogPost.find_one()
        self.assertRaises(StructureError, bp.validate)

        # creating blog post migration
        class BlogPostMigration(DocumentMigration):
            def migration01_add_tags(self):
                self.target = {'blog_post':{'$exists':True}}
                self.update = {'$set':{'blog_post.tags':[]}}

        # migrate a blog post
        migration = BlogPostMigration(BlogPost)
        migration.migrate(bp)
        bp = self.col.BlogPost.get_from_id(bp['_id'])
        bp.validate()

    def test_simple_all_migration(self):
        class BlogPost(Document):
            structure = {
                "author":unicode,
                "blog_post":{
                    "title": unicode,
                    "created_at": datetime,
                    "body": unicode,
                    "tags":  [unicode],
                }
            }
        self.connection.register([BlogPost])
        bp =  self.col.BlogPost.find_one()
        self.assertRaises(StructureError, bp.validate)
        # creating blog post migration
        class BlogPostMigration(DocumentMigration):
            def allmigration01_add_tags(self):
                self.target = {'blog_post':{'$exists':True}, 'blog_post.tags':{'$exists':False}}
                self.update = {'$set':{'blog_post.tags':[]}}
        # migrate all blog posts
        migration = BlogPostMigration(BlogPost)
        assert migration.get_deprecated(self.col) == {'active': ['allmigration01_add_tags'], 'deprecated': []}
        migration.migrate_all(self.col)
        assert migration.get_deprecated(self.col) == {'active': [], 'deprecated': ['allmigration01_add_tags']}
        bp =  self.col.BlogPost.find_one()
        bp.validate()

    def test_simple_all_migration_with_unset(self):
        class BlogPost(Document):
            structure = {
                "author":unicode,
                "blog_post":{
                    "title": unicode,
                    "created_at": datetime,
                    "body": unicode,
                    "tags":  [unicode],
                }
            }
        self.connection.register([BlogPost])
        bp =  self.col.BlogPost.find_one()

        # creating blog post migration
        class BlogPostMigration(DocumentMigration):
            def allmigration01_remove_tags(self):
                self.target = {'blog_post.tags':{'$exists':True}}
                self.update = {'$unset':{'blog_post.tags':[]}}
 		
        # redfine class to drop the tags field
        class BlogPost(Document):
            structure = {
                "author":unicode,
                "blog_post":{
                    "title": unicode,
                    "created_at": datetime,
                    "body": unicode,
                }
            }
        self.connection.register([BlogPost])
        migration = BlogPostMigration(BlogPost)

        # migration should pass as we're unsetting from structure
        migration.migrate_all(self.col)

    def test_simple_all_migration_with_bad_update(self):
        class BlogPost(Document):
            structure = {
                "author": unicode,
                "blog_post":{
                    "title": unicode,
                    "created_at": datetime,
                    "body": unicode,
                    "tags":  [unicode],
                }
            }
        self.connection.register([BlogPost])
        bp =  self.col.BlogPost.find_one()
        self.assertRaises(StructureError, bp.validate)

        # creating blog post migration
        class BlogPostMigration(DocumentMigration):
            def allmigration01_add_tags(self):
                self.target = {'blog_post':{'$exists':True}}
                self.update = {'$set':{'tags':[]}}
        migration = BlogPostMigration(BlogPost)
        self.assertRaises(UpdateQueryError, migration.migrate_all, self.col)
        
    def test_lazy_migration(self):
        # creating blog post migration
        class BlogPostMigration(DocumentMigration):
            def migration01__add_tags(self):
                self.target = {'blog_post':{'$exists':True}}
                self.update = {'$set':{'blog_post.tags':[]}}
            def migration02__rename_create_at_to_creation_date(self):
                self.target = {'blog_post.created_at':{'$exists':True}}
                self.update = {
                  '$set':{'blog_post.creation_date': self.doc['blog_post']['created_at']},
                  '$unset':{'blog_post.created_at':1}
                }
        # update blog post class
        class BlogPost(Document):
            structure = {
                "author":unicode,
                "blog_post":{
                    "title": unicode,
                    "creation_date": datetime,
                    "body": unicode,
                    "tags": [unicode],
                }
            }
            migration_handler = BlogPostMigration
        self.connection.register([BlogPost])

        # fetching a blog post
        bp = self.col.BlogPost.find_one()
        # the field 'tags' has been added automatically
        assert 'tags' in bp['blog_post']
        assert 'created_at' not in bp['blog_post']
        assert bp['blog_post']['creation_date'] == datetime(2010, 1, 1)

        # via lazzy migration, the following line don't raise errors
        bp['blog_post']['title'] = u'Hello big World'
        bp.save()
        assert bp['blog_post']['title'] == 'Hello big World', bp['blog_post']

    def test_lazy_migration_with_skip_validation(self):
        # creating blog post migration
        class BlogPostMigration(DocumentMigration):
            def migration01__add_tags(self):
                self.target = {'blog_post':{'$exists':True}}
                self.update = {'$set':{'blog_post.tags':[]}}
            def migration02__rename_create_at_to_creation_date(self):
                self.target = {'blog_post.created_at':{'$exists':True}}
                self.update = {
                  '$set':{'blog_post.creation_date': self.doc['blog_post']['created_at']},
                  '$unset':{'blog_post.created_at':1}
                }
        # update blog post class
        class BlogPost(Document):
            skip_validation = True
            structure = {
                "author":unicode,
                "blog_post":{
                    "title": unicode,
                    "creation_date": datetime,
                    "body": unicode,
                    "tags": [unicode],
                }
            }
            migration_handler = BlogPostMigration
        self.connection.register([BlogPost])

        # fetching a blog post
        bp = self.col.BlogPost.find_one()
        # the field 'tags' has been added automatically
        assert 'tags' in bp['blog_post']
        assert 'created_at' not in bp['blog_post']
        assert bp['blog_post']['creation_date'] == datetime(2010, 1, 1)

        # via lazzy migration, the following line don't raise errors
        bp.save()

    def test_lazy_migration_with_autorefs(self):
        # creating blog post migration
        class BlogPostMigration(DocumentMigration):
            def migration01__add_tags(self):
                self.target = {'blog_post':{'$exists':True}}
                self.update = {'$set':{'blog_post.tags':[]}}
            def migration02__rename_create_at_to_creation_date(self):
                if 'created_at' in self.doc['blog_post']:
                    self.target = {'blog_post.created_at':{'$exists':True}}
                    self.update = {
                      '$set':{'blog_post.creation_date': self.doc['blog_post']['created_at']},
                      '$unset':{'blog_post.created_at':1}
                    }
        # update blog post class
        class BlogPost(Document):
            structure = {
                "author":unicode,
                "blog_post":{
                    "title": unicode,
                    "creation_date": datetime,
                    "body": unicode,
                    "tags": [unicode],
                }
            }
            migration_handler = BlogPostMigration
        self.connection.register([BlogPost])

        class A(Document):
            structure = {
                "a":{'blogpost':BlogPost},
            }
            use_autorefs = True
        self.connection.register([A])

        for doc in self.col.BlogPost.find():
            a = self.col.A()
            a['a']['blogpost'] = doc
            a.save()
            assert 'creation_date' in a['a']['blogpost']['blog_post'], a

        class AMigration(DocumentMigration):
            def migration01__add_bar(self):
                self.target = {'a':{'$exists':True}, 'a.bar':{'$exists':False}}
                self.update = {'$set':{'a.bar':None}}
        class A(Document):
            structure = {
                "a":{'blogpost':BlogPost, 'bar':int},
            }
            use_autorefs = True
            migration_handler = AMigration
        self.connection.register([A])
        
        a = self.col.A.fetch().next()
        assert 'bar' in a['a'], a
        assert 'creation_date' in a['a']['blogpost']['blog_post'], a
        a.validate()
        assert 'bar' in a['a'], a

    def test_lazy_migration_with_dynamic_type(self):
        # creating blog post migration
        class BlogPostMigration(DocumentMigration):
            def migration01__add_tags(self):
                self.target = {'blog_post':{'$exists':True}}
                self.update = {'$set':{'blog_post.tags':[]}}
            def migration02__rename_create_at_to_creation_date(self):
                if 'created_at' in self.doc['blog_post']:
                    self.target = {'blog_post.created_at':{'$exists':True}}
                    self.update = {
                      '$set':{'blog_post.creation_date': self.doc['blog_post']['created_at']},
                      '$unset':{'blog_post.created_at':1}
                    }
            def migration03__change_title_structure(self):
                self.target = {'blog_post.title':{'$exists':True, '$type':2}}
                self.update = {'$set':{'blog_post.title':{'lang':u'fr', 'value':self.doc['blog_post']['title']}}}
                #self.update = {'$set':{'blog_post.title':1}}

            def migration04__change_tags_structure(self):
                self.target = {'blog_post.tags':{'$exists':True}}
                self.update = {'$set':{'blog_post.tags':[{'foo': self.doc['blog_post']['title']}]}}

        # update blog post class
        class BlogPost(Document):
            structure = {
                "author":unicode,
                "blog_post":{
                    "title": {'lang':unicode, 'value':unicode},
                    "creation_date": datetime,
                    "body": unicode,
                    "tags": [{'foo':unicode}],
                }
            }
            migration_handler = BlogPostMigration

            def validate(self, auto_migrate=False):
                assert self['body']
                super(BlogPost, self).validate(auto_migrate)

        self.connection.register([BlogPost])

        doc = self.col.BlogPost.find_one({'blog_post.title':'hello 0'})
        self.assertEqual(doc, {u'blog_post': {u'body': u'I the post number 0',
          u'title': {u'lang': u'fr', u'value': u'hello 0'},
          u'tags': [{u'foo': {u'lang': u'fr', u'value': u'hello 0'}}],
          u'creation_date': datetime(2010, 1, 1, 0, 0)}, u'author': None,
          u'_id': doc['_id']})

    def test_migration_with_schemaless(self):
        # creating blog post migration
        class BlogPostMigration(DocumentMigration):
            def migration01__add_tags(self):
                self.target = {'blog_post':{'$exists':True}}
                self.update = {'$set':{'blog_post.tags':[]}}

        # update blog post class
        failed = False
        try:
            class BlogPost(Document):
                structure = {
                    "author":unicode,
                    "blog_post":{
                        "title": unicode,
                        "creation_date": datetime,
                        "body": unicode,
                        "tags": [unicode],
                    }
                }
                use_schemaless = True
                migration_handler = BlogPostMigration
        except OptionConflictError, e:
            self.assertEqual('You cannot set a migration_handler with use_schemaless set to True', str(e))
            failed = True
        self.assertEqual(failed, True)

########NEW FILE########
__FILENAME__ = test_schemaless
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest

from mongokit import *
import datetime


class SchemaLessTestCase(unittest.TestCase):

    def setUp(self):
        self.connection = Connection()
        self.col = self.connection['test']['mongokit']
        
    def tearDown(self):
        self.connection.drop_database('test')
        self.connection.drop_database('othertest')

    def test_simple_schemaless(self):
        @self.connection.register
        class MyDoc(Document):
            use_schemaless = True
            structure = {
                'foo': unicode,
                'bar': int,
            }

        doc = self.col.MyDoc()
        self.assertEqual('foo' in doc, True)
        self.assertEqual('bar' in doc, True)
        self.assertEqual('egg' in doc, False)
        doc['foo'] = u'bla'
        doc['bar'] = 3
        doc['egg'] = 9
        doc.save()
        
        doc = self.col.find_one()
        self.assertEqual('foo' in doc, True)
        self.assertEqual('bar' in doc, True)
        self.assertEqual('egg' in doc, True)

        doc = self.col.MyDoc.find_one()
        self.assertEqual('foo' in doc, True)
        self.assertEqual('bar' in doc, True)
        self.assertEqual('egg' in doc, True)
        doc['foo'] = 2
        self.assertRaises(SchemaTypeError, doc.save)
        doc.pop('foo')
        doc.pop('bar')
        doc.save()
        doc = self.col.MyDoc.find_one()
        self.assertEqual(doc.keys(), ['_id', 'egg'])

        doc = self.col.MyDoc({'_id':1, 'foo':u'bla'})
        doc.save()
        

    def test_schemaless_with_required(self):
        @self.connection.register
        class MyDoc(Document):
            use_schemaless = True
            structure = {
                'foo': unicode,
                'bar': int,
            }
            required_fields = ['foo']

        doc = self.col.MyDoc()
        self.assertEqual('foo' in doc, True)
        self.assertEqual('bar' in doc, True)
        self.assertEqual('egg' in doc, False)
        doc['foo'] = u'bla'
        doc['bar'] = 3
        doc['egg'] = 9
        doc.save()
        
        doc = self.col.MyDoc()
        doc.pop('foo')
        doc['bar'] = 3
        doc['egg'] = 9
        self.assertRaises(RequireFieldError, doc.save)
        
        doc = self.col.find_one()
        doc.pop('foo')
        self.col.save(doc)

        doc = self.col.MyDoc.find_one()
        self.assertEqual('foo' in doc, False)
        self.assertEqual('bar' in doc, True)
        self.assertEqual('egg' in doc, True)
        doc['bar'] = 2
        self.assertRaises(RequireFieldError, doc.save)
        doc['foo'] = u'arf'
        doc.save()

    def test_schemaless_no_structure(self):
        @self.connection.register
        class MyDoc(Document):
            use_schemaless = True

        doc = self.col.MyDoc()
        self.assertEqual('foo' in doc, False)
        self.assertEqual('bar' in doc, False)
        doc['_id'] = u'foo'
        doc['foo'] = u'bla'
        doc['bar'] = 3
        doc.save()
        
        doc = self.col.find_one()
        self.assertEqual('foo' in doc, True)
        self.assertEqual('bar' in doc, True)

        doc = self.col.MyDoc.find_one()
        self.assertEqual('foo' in doc, True)
        self.assertEqual('bar' in doc, True)
        self.assertEqual(doc, {'_id': 'foo', 'foo':'bla', 'bar':3})

    def test_schemaless_scenario2(self):
        @self.connection.register
        class User(Document):
            __collection__ = 'mongokit'
            __database__ = 'test'
            use_schemaless = True
            structure = {
                'name': unicode,
                'password': unicode,
                'last_name': unicode,
                'first_name': unicode,
                'email': unicode,
                'last_login': datetime.datetime,
            }
            use_dot_notation = True

        self.connection.User.collection.save({'name': u'namlook', 'password': u'test', 'email': u'n@c.com'})

        found_attribute = self.connection.User.find_one({'name':'namlook'})
        found_attribute.last_login = datetime.datetime.utcnow()
        found_attribute.save()

########NEW FILE########
__FILENAME__ = test_structure
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest

from mongokit import *

class StructureTestCase(unittest.TestCase):
    def setUp(self):
        self.connection = Connection()
        self.col = self.connection['test']['mongokit']
        
    def tearDown(self):
        self.connection['test'].drop_collection('mongokit')

    def test_no_structure(self):
        failed = False
        try:
            class MyDoc(SchemaDocument): pass
        except StructureError:
            failed = True
        self.assertEqual(failed, False)

    def test_empty_structure(self):
        class MyDoc(SchemaDocument):
            structure = {}
        assert MyDoc() == {}

    def test_structure_not_dict(self):
        failed = False
        try:
            class MyDoc(SchemaDocument):
                structure = 3
        except StructureError:
            failed = True
        self.assertEqual(failed, True)

    def test_load_with_dict(self):
        doc = {"foo":1, "bla":{"bar":u"spam"}}
        class MyDoc(SchemaDocument):
            structure = {"foo":int, "bla":{"bar":unicode}}
        mydoc = MyDoc(doc)
        assert mydoc == doc
        mydoc.validate()
        
    def test_simple_structure(self):
        class MyDoc(SchemaDocument):
            structure = {
                "foo":unicode,
                "bar":int
            }
        assert MyDoc() == {"foo":None, "bar":None}

    def test_missed_field(self):
        doc = {"foo":u"arf"}
        class MyDoc(SchemaDocument):
            structure = {
                "foo":unicode,
                "bar":{"bla":int}
            }
        mydoc = MyDoc(doc)
        self.assertRaises(StructureError, mydoc.validate)

    def test_unknown_field(self):
        class MyDoc(SchemaDocument):
            structure = {
                "foo":unicode,
            }
        mydoc = MyDoc()
        mydoc["bar"] = 4
        self.assertRaises(StructureError, mydoc.validate)

    def test_None(self):
        class MyDoc(SchemaDocument):
            structure = {
                "foo":None,
                "bar":{
                    "bla":None
                }
            }
        mydoc = MyDoc()
        mydoc['foo'] = u'bla'
        mydoc.validate()
        mydoc['foo'] = 3
        mydoc['bar']['bla'] = 2
        mydoc.validate()
        mydoc['foo'] = 'arf'
        self.assertRaises(AuthorizedTypeError, mydoc.validate)

    def test_big_nested_structure(self):
        class MyDoc(SchemaDocument):
            structure = {
                "1":{
                    "2":{
                        "3":{
                            "4":{
                                "5":{
                                    "6":{
                                        "7":int,
                                        "8":{
                                            unicode:{int:int}
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        mydoc = MyDoc()
        assert mydoc._namespaces == ['1', '1.2', '1.2.3', '1.2.3.4', '1.2.3.4.5', '1.2.3.4.5.6', '1.2.3.4.5.6.8', '1.2.3.4.5.6.8.$unicode', '1.2.3.4.5.6.8.$unicode.$int', '1.2.3.4.5.6.7']
        mydoc['1']['2']['3']['4']['5']['6']['7'] = 8
        mydoc['1']['2']['3']['4']['5']['6']['8'] = {u"bla":{3:u"bla"}}
        self.assertRaises(SchemaTypeError,  mydoc.validate)
        mydoc['1']['2']['3']['4']['5']['6']['8'] = {9:{3:10}}
        self.assertRaises(SchemaTypeError,  mydoc.validate)
        mydoc['1']['2']['3']['4']['5']['6']['8'] = {u"bla":{3:4}}
        mydoc.validate()
 
    def test_big_nested_structure_mongo_document(self):
        class MyDoc(Document):
            structure = {
                "1":{
                    "2":{
                        "3":{
                            "4":{
                                "5":{
                                    "6":{
                                        "7":int,
                                        "8":{
                                            unicode:{unicode:int}
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        assert mydoc._namespaces == ['1', '1.2', '1.2.3', '1.2.3.4', '1.2.3.4.5', '1.2.3.4.5.6', '1.2.3.4.5.6.8', '1.2.3.4.5.6.8.$unicode', '1.2.3.4.5.6.8.$unicode.$unicode', '1.2.3.4.5.6.7']
        mydoc['1']['2']['3']['4']['5']['6']['7'] = 8
        mydoc['1']['2']['3']['4']['5']['6']['8'] = {u"bla":{"3":u"bla"}}
        self.assertRaises(SchemaTypeError,  mydoc.validate)
        mydoc['1']['2']['3']['4']['5']['6']['8'] = {"9":{"3":10}}
        self.assertRaises(SchemaTypeError,  mydoc.validate)
        mydoc['1']['2']['3']['4']['5']['6']['8'] = {u"bla":{u"3":4}}
        mydoc.validate()
            
    def test_dot_notation(self):
        class MyDoc(SchemaDocument):
            use_dot_notation = True
            structure = {
                "foo":int,
                "bar":unicode
            }

        mydoc = MyDoc()
        mydoc.foo = "3"
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc.foo = 3
        assert mydoc['foo'] == 3
        assert mydoc == {'foo':3, 'bar':None}
        mydoc.validate()
        mydoc.bar = u"bar"
        assert mydoc == {'foo':3, 'bar':'bar'}
        mydoc.validate()

    def test_dot_notation_missing(self):
        class MyDoc(SchemaDocument):
            use_dot_notation = True
            structure = {
                "existent": unicode,
                "exists": {
                    'subexists': unicode
                }
            }
        mydoc = MyDoc()
        mydoc.existent = u"31337"
        mydoc.exists.subexists = u"31337"

        self.assertTrue(isinstance(mydoc, MyDoc), 'MyDoc is MyDoc')
        self.assertTrue(isinstance(mydoc.exists, DotedDict), 'MyDoc contains DotedDict')

        self.assertEqual(mydoc.existent, u"31337", 'Getting existent value from dotted')
        self.assertEqual(mydoc.exists.subexists, u"31337", 'Getting existent value from dotted')
        self.assertRaises(AttributeError, lambda: mydoc.not_existent)
        self.assertRaises(AttributeError, lambda: mydoc.exists.not_subexists)


    def test_dot_notation_nested(self):
        class MyDoc(SchemaDocument):
            use_dot_notation = True
            structure = {
                "foo":{
                    "bar":unicode
                }
            }

        mydoc = MyDoc()
        mydoc.foo.bar = 3
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc.foo.bar = u"bar"
        assert mydoc.foo.bar == u'bar'
        mydoc.foo.bla = 2
        assert mydoc.foo.bla == 2
        assert mydoc['foo'] == {"bar":"bar"}, mydoc
        assert mydoc['foo']['bar'] == 'bar'
        assert mydoc == {'foo':{'bar':'bar'}}
        mydoc.validate()

    def test_document_dot_notation_nested(self):
        class MyDoc(Document):
            use_dot_notation = True
            structure = {
                "foo":{
                    "bar":unicode
                }
            }
        self.connection.register([MyDoc])

        mydoc = self.col.MyDoc()
        mydoc.foo.bar = u"bar"
        self.assertEqual(mydoc.foo.bar, u'bar')
        mydoc.foo.bla = 2
        assert isinstance(mydoc.foo, DotedDict), type(mydoc.foo)
        self.assertEqual(mydoc.foo.bla,  2)
        self.assertEqual(mydoc['foo'], {"bar":"bar"})
        self.assertEqual(mydoc['foo']['bar'], 'bar')
        self.assertEqual(mydoc, {'foo':{'bar':'bar'}})
        mydoc.save()

        fetched_doc = self.col.MyDoc.find_one()
        assert isinstance(fetched_doc.foo, DotedDict), type(fetched_doc.foo)
        self.assertEqual(fetched_doc.foo.bar, "bar")


    def test_dot_notation_field_not_in_structure(self):
        class MyDoc(SchemaDocument):
            use_dot_notation = True
            structure = {
                "foo":{
                    "bar":unicode,
                },
                "spam":int,
            }

        import logging
        logging.basicConfig()
        mydoc = MyDoc()
        mydoc.eggs = 4
        assert mydoc == {'foo':{'bar':None}, 'spam':None}
        assert mydoc.eggs == 4
        try:
            mydoc.not_found
        except AttributeError, e:
            print str(e)
        mydoc.foo.eggs = 4
        assert mydoc == {'foo':{'bar':None}, 'spam':None}, mydoc
        mydoc.validate()


    def test_field_changed(self):
        class MyDoc(Document):
            structure = {
                'foo':int,
                'bar':unicode,
            }
        self.connection.register([MyDoc])
        
        doc = self.col.MyDoc()
        doc['foo'] = 3
        doc.save()

        class MyDoc(Document):
            structure = {
                'foo':int,
                'arf': unicode,
            }
        self.connection.register([MyDoc])
        
        fetched_doc = self.col.MyDoc.find_one()
        self.assertRaises(StructureError, fetched_doc.validate)
        fetched_doc['foo'] = 2
        fetched_doc.save(validate=False)

        fetched_doc = self.col.MyDoc.find_one()
        self.assertRaises(StructureError, fetched_doc.validate)


    def test_exception_bad_structure(self):
        import datetime
        failed = False
        try:
            class MyDoc(SchemaDocument):
                structure = {
                    'topic': unicode,
                    'when': datetime.datetime.utcnow,
                }
        except TypeError, e:
            assert str(e).startswith("MyDoc: <built-in method utcnow of type object at "), str(e)
            assert str(e).endswith("is not a type")
            failed = True
        self.assertEqual(failed, True)


########NEW FILE########
__FILENAME__ = test_types
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest

from mongokit.schema_document import *
from mongokit import Document, Connection

class TypesTestCase(unittest.TestCase):

    def setUp(self):
        self.connection = Connection()
        self.col = self.connection['test']['mongokit']

    def tearDown(self):
        self.connection.drop_database('test')


    def test_authorized_type(self):
       for auth_type in SchemaDocument.authorized_types:
            if auth_type is dict:
                auth_type = {}
            class MyDoc(SchemaDocument):
                structure = { "foo":auth_type }
            if type(auth_type) is dict:
                assert MyDoc() == {"foo":{}}, MyDoc()
            elif auth_type is list:
                assert MyDoc() == {"foo":[]}
            else:
                assert MyDoc() == {"foo":None}, auth_type

    def test_not_authorized_type(self):
        for unauth_type in [set]:
            failed = False
            try:
                class MyDoc(SchemaDocument):
                    structure = { "foo":[unauth_type] }
            except StructureError, e:
                self.assertEqual(str(e), "MyDoc: %s is not an authorized type" % unauth_type)
                failed = True
            self.assertEqual(failed, True)
            failed = False
            try:
                class MyDoc(SchemaDocument):
                    structure = { "foo":(unauth_type) }
            except StructureError, e:
                self.assertEqual(str(e), "MyDoc: %s is not an authorized type" % unauth_type)
                failed = True
            self.assertEqual(failed, True)
            failed = False
            try:
                class MyDoc2(SchemaDocument):
                    structure = { 'foo':[{int:unauth_type }]}
            except StructureError, e:
                self.assertEqual(str(e), "MyDoc2: %s is not an authorized type" % unauth_type)
                failed = True
            self.assertEqual(failed, True)
            failed = False
            try:
                class MyDoc3(SchemaDocument):
                    structure = { 'foo':[{unauth_type:int }]}
            except AuthorizedTypeError, e:
                self.assertEqual(str(e), "MyDoc3: %s is not an authorized type" % unauth_type)
                failed = True
            self.assertEqual(failed, True)

        failed = False
        try:
            class MyDoc4(SchemaDocument):
                structure = {1:unicode}
        except StructureError, e:
            self.assertEqual(str(e), "MyDoc4: 1 must be a basestring or a type")
            failed = True
        self.assertEqual(failed, True)


    def test_type_from_functions(self):
        from datetime import datetime
        class MyDoc(SchemaDocument):
            structure = {
                "foo":datetime,
            }
        assert MyDoc() == {"foo":None}, MyDoc()
        mydoc = MyDoc()
        mydoc['foo'] = datetime.now()
        mydoc.validate()

    def test_non_typed_list(self):
        class MyDoc(SchemaDocument):
            structure = {
                "foo":[]
            }
        mydoc = MyDoc()
        mydoc.validate()
        assert mydoc['foo'] == []
        mydoc['foo'] = [u"bla", 23]
        mydoc.validate()
        mydoc['foo'] = [set([1,2]), "bla"]
        self.assertRaises(AuthorizedTypeError, mydoc.validate)
        mydoc['foo'] = u"bla"
        self.assertRaises(SchemaTypeError, mydoc.validate)

#        class MyDoc(SchemaDocument):
#            structure = {
#                "foo":list
#            }
#        mydoc = MyDoc()
#        mydoc.validate()
#        assert mydoc['foo'] == []
#        mydoc['foo'] = [u"bla", 23]
#        mydoc.validate()
#        mydoc['foo'] = [set([1,2]), "bla"]
#        self.assertRaises(AuthorizedTypeError, mydoc.validate)

    def test_typed_list(self):
        class MyDoc(SchemaDocument):
            structure = {
                "foo":[int]
            }
        mydoc = MyDoc()
        mydoc.validate()
        assert mydoc['foo'] == []
        mydoc['foo'] = [1,2,3]
        mydoc.validate()
        mydoc['foo'] = [u"bla"]
        self.assertRaises(SchemaTypeError, mydoc.validate)

    def test_typed_list_with_dict(self):
        class MyDoc(SchemaDocument):
            structure = {
                "foo":[{unicode:int}]
            }
        mydoc = MyDoc()
        mydoc['foo'] = [{u"bla":1},{u"ble":2}]
        mydoc.validate()
        mydoc['foo'] = [{u"bla":u"bar"}]
        self.assertRaises(SchemaTypeError, mydoc.validate)

    def test_typed_list_with_list(self):
        class MyDoc(SchemaDocument):
            structure = {
                "foo":[[unicode]]
            }
        mydoc = MyDoc()
        mydoc['foo'] = [[u"bla",u"blu"],[u"ble",u"bli"]]
        mydoc.validate()
        mydoc['foo'] = [[u"bla",1]]
        self.assertRaises(SchemaTypeError, mydoc.validate)

    def test_typed_tuple(self):
        class MyDoc(SchemaDocument):
            structure = {
                "foo":(int, unicode, float)
            }
        mydoc = MyDoc()
        mydoc.validate()
        assert mydoc['foo'] == [None, None, None]
        mydoc['foo'] = [u"bla", 1, 4.0]
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['foo'] = [1, u"bla"]
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['foo'] = u"bla"
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['foo'] = [1,u'bar',3.2]
        mydoc.validate()
        mydoc['foo'] = [None, u"bla", 3.1]
        mydoc.validate()
        mydoc['foo'][0] = 50
        mydoc.validate()

    def test_nested_typed_tuple(self):
        class MyDoc(SchemaDocument):
            structure = {
                "foo":{'bar':(int, unicode, float)}
            }
        mydoc = MyDoc()
        mydoc.validate()
        assert mydoc['foo']['bar'] == [None, None, None]
        mydoc['foo']['bar'] = [u"bla", 1, 4.0]
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['foo']['bar'] = [1, u"bla"]
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['foo']['bar'] = [1,u'bar',3.2]
        mydoc.validate()
        mydoc['foo']['bar'] = [None, u"bla", 3.1]
        mydoc.validate()
        mydoc['foo']['bar'][0] = 50
        mydoc.validate()

    def test_saving_tuple(self):
        class MyDoc(Document):
            structure = { 'foo': (int, unicode, float) }
        self.connection.register([MyDoc])

        mydoc = self.col.MyDoc()
        assert mydoc == {'foo': [None, None, None]}, mydoc
        mydoc['foo'] = (1, u'a', 1.1) # note that this will be converted to list
        assert mydoc == {'foo': (1, u'a', 1.1000000000000001)}, mydoc
        mydoc.save()
        mydoc = self.col.find_one()

        class MyDoc(Document):
            structure = {'foo':[unicode]}
        self.connection.register([])
        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc['foo'] = (u'bla', u'bli', u'blu', u'bly')
        mydoc.save()
        mydoc = self.col.get_from_id(mydoc['_id'])


    def test_nested_typed_tuple_in_list(self):
        class MyDoc(SchemaDocument):
            structure = {
                "foo":{'bar':[(int, unicode, float)]}
            }
        mydoc = MyDoc()
        mydoc.validate()
        assert mydoc == {'foo': {'bar': []}}
        mydoc['foo']['bar'].append([u"bla", 1, 4.0])
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['foo']['bar'] = []
        mydoc['foo']['bar'].append([1, u"bla"])
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['foo']['bar'] = []
        mydoc['foo']['bar'].append([1,u'bar',3.2])
        mydoc.validate()
        mydoc['foo']['bar'].append([None, u"bla", 3.1])
        mydoc.validate()
        mydoc['foo']['bar'][1][0] = 50
        mydoc.validate()

    def test_dict_unicode_typed_list(self):
        class MyDoc(SchemaDocument):
            structure = {
                "foo":{unicode:[int]}
            }
        mydoc = MyDoc()
        mydoc['foo'] = {u"bar":[1,2,3]}
        mydoc.validate()
        mydoc['foo'] = {u"bar":[u"bla"]}
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['foo'] = {3:[1,2,3]}
        self.assertRaises(SchemaTypeError, mydoc.validate)

    def test_with_custom_object(self):
        class MyDict(dict):
            pass
        class MyDoc(SchemaDocument):
            structure = {
                "foo":{unicode:int}
            }
        mydoc = MyDoc()
        mydict = MyDict()
        mydict[u"foo"] = 3
        mydoc["foo"] = mydict
        mydoc.validate()

    def test_custom_object_as_type(self):
        class MyDict(dict):
            pass
        class MyDoc(SchemaDocument):
            structure = {
                "foo":MyDict({unicode:int})
            }
        mydoc = MyDoc()
        mydict = MyDict()
        mydict[u"foo"] = 3
        mydoc["foo"] = mydict
        mydoc.validate()
        mydoc['foo'] = {u"foo":"7"}
        self.assertRaises(SchemaTypeError, mydoc.validate)

        class MyInt(int):
            pass
        class MyDoc(SchemaDocument):
            structure = {
                "foo":MyInt,
            }
        mydoc = MyDoc()
        mydoc["foo"] = MyInt(3)
        mydoc.validate()
        mydoc['foo'] = 3
        self.assertRaises(SchemaTypeError, mydoc.validate)

    def test_list_instead_of_dict(self):
        class MyDoc(SchemaDocument):
            structure = {
                "foo":{unicode:[unicode]}
            }
        mydoc = MyDoc()
        mydoc['foo'] = [u'bla']
        self.assertRaises(SchemaTypeError, mydoc.validate)

    def _test_big_nested_example(self):
        # XXX TODO
        class MyDoc(SchemaDocument):
            structure = {
                "foo":{unicode:[int], u"bar":{"spam":{int:[unicode]}}},
                "bla":{"blo":{"bli":[{"arf":unicode}]}},
            }
        mydoc = MyDoc()
        mydoc['foo'].update({u"bir":[1,2,3]})
        mydoc['foo'][u'bar'][u'spam'] = {1:[u'bla', u'ble'], 3:[u'foo', u'bar']}
        mydoc.validate()
        mydoc['bla']['blo']['bli'] = [{u"bar":[u"bla"]}]
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['bla']['blo']['bli'] = [{u"arf":[1]}]
        self.assertRaises(SchemaTypeError, mydoc.validate)


    def test_adding_custom_type(self):
        class MyDoc(SchemaDocument):
            structure = {
                "foo":str,
            }
            authorized_types = SchemaDocument.authorized_types + [str]
        mydoc = MyDoc()

    def test_schema_operator(self):
        from mongokit.operators import SchemaOperator
        class OP(SchemaOperator):
            repr = "op"
        op = OP()
        self.assertRaises(NotImplementedError, op.validate, "bla")


    def test_or_operator(self):
        from mongokit import OR
        assert repr(OR(unicode, str)) == "<unicode or str>"

        failed = False
        try:
            class BadMyDoc(SchemaDocument):
                structure = {"bla":OR(unicode,str)}
        except StructureError, e:
            self.assertEqual(str(e), "BadMyDoc: <type 'str'> in <unicode or str> is not an authorized type (type found)")
            failed = True
        self.assertEqual(failed, True)

        from datetime import datetime
        class MyDoc(SchemaDocument):
            structure = {
                "foo":OR(unicode,int),
                "bar":OR(unicode, datetime)
            }

        mydoc = MyDoc()
        assert str(mydoc.structure['foo']) == '<unicode or int>'
        assert str(mydoc.structure['bar']) == '<unicode or datetime>'
        assert mydoc == {'foo': None, 'bar': None}
        mydoc['foo'] = 3.0
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['foo'] = u"foo"
        mydoc.validate()
        mydoc['foo'] = 3
        mydoc.validate()
        mydoc['foo'] = 'bar'
        self.assertRaises(SchemaTypeError, mydoc.validate)

        mydoc['foo'] = datetime.now()
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['foo'] = u"foo"
        mydoc['bar'] = datetime.now()
        mydoc.validate()
        mydoc['bar'] = u"today"
        mydoc.validate()
        mydoc['bar'] = 25
        self.assertRaises(SchemaTypeError, mydoc.validate)

    def test_not_operator(self):
        from mongokit import NOT
        failed = False
        try:
            class BadMyDoc(SchemaDocument):
                structure = {"bla":NOT(unicode,str)}
        except StructureError, e:
            self.assertEqual(str(e), "BadMyDoc: <type 'str'> in <not unicode, not str> is not an authorized type (type found)")
            failed = True
        self.assertEqual(failed, True)

        from datetime import datetime
        class MyDoc(SchemaDocument):
            structure = {
                "foo":NOT(unicode,int),
                "bar":NOT(datetime)
            }

        mydoc = MyDoc()
        assert str(mydoc.structure['foo']) == '<not unicode, not int>', str(mydoc.structure['foo'])
        assert str(mydoc.structure['bar']) == '<not datetime>'
        assert mydoc == {'foo': None, 'bar': None}
        assert mydoc['foo'] is None
        assert mydoc['bar'] is None
        mydoc['foo'] = 3
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['foo'] = u"foo"
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['foo'] = 3.0
        mydoc.validate()
        mydoc['foo'] = datetime.now()
        mydoc.validate()

        mydoc['bar'] = datetime.now()
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['bar'] = u"today"
        mydoc.validate()
        mydoc['bar'] = 25
        mydoc.validate()

    def test_is_operator(self):
        from mongokit import IS
        failed = False
        try:
            class BadMyDoc(SchemaDocument):
                structure = {"bla":IS('bla',3)}
        except StructureError, e:
            self.assertEqual(str(e), "BadMyDoc: bla in <is 'bla' or is 3> is not an authorized type (str found)")
            failed = True
        self.assertEqual(failed, True)

        from datetime import datetime
        class MyDoc(SchemaDocument):
            structure = {
                "foo":IS(u'spam',u'eggs'),
                "bar":IS(u'3', 3)
            }

        mydoc = MyDoc()
        assert str(mydoc.structure['foo']) == "<is u'spam' or is u'eggs'>"
        assert str(mydoc.structure['bar']) == "<is u'3' or is 3>"
        assert mydoc == {'foo': None, 'bar': None}
        assert mydoc['foo'] is None
        assert mydoc['bar'] is None
        mydoc['foo'] = 3
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['foo'] = u"bla"
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['foo'] = datetime.now()
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['foo'] = u"spam"
        mydoc.validate()
        mydoc['foo'] = u"eggs"
        mydoc.validate()

        mydoc['bar'] = datetime.now()
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['bar'] = u"today"
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['bar'] = 'foo'
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['bar'] = 3
        mydoc.validate()
        mydoc['bar'] = u"3"
        mydoc.validate()

    def test_subclassed_type(self):
        """
        accept all subclass of supported type
        """
        class CustomFloat(float):
            def __init__(self, float):
                self = float + 2
        class MyDoc(SchemaDocument):
            structure = {
                "foo":float,
            }
        mydoc = MyDoc()
        mydoc['foo'] = CustomFloat(4)
        mydoc.validate()


    def test_set_type(self):
        from mongokit import Set
        class MyDoc(Document):
            structure = {
                "tags":Set(int),
            }

        self.connection.register([MyDoc])
        mydoc = self.col.MyDoc()
        mydoc['tags'] = set(["1","1","2","3","4"])
        self.assertRaises(ValueError, mydoc.validate)
        mydoc['tags'] = set([1,1,2,3,4])
        mydoc.save()

        doc = self.col.MyDoc.find_one()
        assert doc['tags'] == set([1,2,3,4]), doc['tags']

    def test_set_type2(self):
        class MyDoc(Document):
                structure = {
                        'title':unicode,
                        'category':Set(unicode)
                }
                required_fields=['title']
        self.connection.register([MyDoc])
        doc = self.col.MyDoc()
        print doc # {'category': set([]), 'title': None}
        assert isinstance(doc['category'], set)
        try:
                doc.validate()
        except RequireFieldError as e:
                print e # title is required

        print doc # {'category': [], 'title': None}
        assert isinstance(doc['category'], set)
        doc['title']=u'hello'
        doc.validate()

    def test_int_type(self):
        @self.connection.register
        class MyDoc(Document):
            structure = {
                "foo":int,
            }

        mydoc = self.col.MyDoc()
        mydoc['foo'] = ''
        self.assertRaises(SchemaTypeError, mydoc.validate)
        mydoc['foo'] = 10
        mydoc.save()

    def test_uuid_type(self):
        import uuid
        @self.connection.register
        class MyDoc(Document):
            structure = {
                'uuid': uuid.UUID,
            }
        uid = uuid.uuid4()
        obj = self.col.MyDoc()
        obj['uuid'] = uid
        obj.save()

        assert isinstance(self.col.MyDoc.find_one()['uuid'], uuid.UUID)

    def test_binary_with_str_type(self):
        import bson
        @self.connection.register
        class MyDoc(Document):
            structure = {
                'my_binary': basestring,
            }
        obj = self.col.MyDoc()
        # non-utf8 string
        non_utf8 = "\xFF\xFE\xFF";
        obj['my_binary'] = non_utf8

        self.assertRaises(bson.errors.InvalidStringData, obj.validate)

    def test_binary_with_unicode_type(self):
        import bson
        @self.connection.register
        class MyDoc(Document):
            structure = {
                'my_binary': unicode,
            }
        obj = self.col.MyDoc()
        # non-utf8 string
        non_utf8 = "\xFF\xFE\xFF";
        obj['my_binary'] = non_utf8

        self.assertRaises(bson.errors.InvalidStringData, obj.validate)

    def test_binary_with_binary_type(self):
        import bson
        @self.connection.register
        class MyDoc(Document):
            structure = {
                'my_binary': bson.binary.Binary,
            }
        obj = self.col.MyDoc()
        # non-utf8 string
        non_utf8 = "\xFF\xFE\xFF";
        bin_obj = bson.binary.Binary(non_utf8)
        obj['my_binary'] = bin_obj
        obj.save()

        self.assertEquals(self.col.MyDoc.find_one()['my_binary'], bin_obj)

########NEW FILE########
__FILENAME__ = test_versioned
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2009-2011, Nicolas Clairon
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the University of California, Berkeley nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import unittest

from mongokit import *

class VersionedTestCase(unittest.TestCase):
    def setUp(self):
        self.connection = Connection()
        self.col = self.connection['test']['mongokit']
        
    def tearDown(self):
        self.connection['test'].drop_collection('mongokit')
        self.connection['test'].drop_collection('versioned_mongokit')
        self.connection['test'].drop_collection('versioned_mongokit2')
        self.connection['versioned_test'].drop_collection('versioned_mongokit')

    def test_save_versioning(self):
        class MyDoc(Document):
            structure = {
                "bla" : unicode,
            }
        self.connection.register([MyDoc])

        doc = self.col.MyDoc()
        doc['bla'] =  u"bli"
        doc.save()
        assert "_revision" not in doc
        doc.delete()

        class MyVersionedDoc(VersionedDocument):
            structure = {
                "foo" : unicode,
            }
        self.connection.register([MyVersionedDoc])
 
        versioned_doc = self.col.MyVersionedDoc()
        versioned_doc['_id'] = "mydoc"
        versioned_doc['foo'] = u'bla'
        versioned_doc.save()

        docs = list(self.col.find())
        assert len(docs) == 1

        ver_doc = list(self.connection.test.versioned_mongokit.find())
        assert len(ver_doc) == 1
        assert ver_doc[0]['id'] == 'mydoc'
        assert ver_doc[0]['revision'] == 1
        assert ver_doc[0]['doc'] == {u'_revision': 1, u'foo': u'bla', u'_id': u'mydoc'}

        assert versioned_doc['_revision'] == 1
        assert versioned_doc.get_last_revision_id() == 1
        assert versioned_doc.get_revision(1) == {'foo':'bla', "_revision":1, "_id":"mydoc"}
        versioned_doc['foo'] = u'bar'
        versioned_doc.save()

        ver_doc = list(self.connection.test.versioned_mongokit.find())
        assert len(ver_doc) == 2
        assert ver_doc[0]['id'] == 'mydoc'
        assert ver_doc[0]['revision'] == 1
        assert ver_doc[0]['doc'] == {u'_revision': 1, u'foo': u'bla', u'_id': u'mydoc'}
        assert ver_doc[1]['id'] == 'mydoc'
        assert ver_doc[1]['revision'] == 2
        assert ver_doc[1]['doc'] == {u'_revision': 2, u'foo': u'bar', u'_id': u'mydoc'}

        assert versioned_doc['_revision'] == 2
        assert versioned_doc.get_last_revision_id() == 2
        assert versioned_doc['foo'] == 'bar'
        assert versioned_doc.get_revision(2) == {'foo':'bar', "_revision":2, "_id":"mydoc"}, versioned_doc.get_revision(2)
        old_doc = versioned_doc.get_revision(1)
        print old_doc, type(old_doc)
        old_doc.save()
        assert old_doc['_revision'] == 3

        versioned_doc = self.connection.test.mongokit.MyVersionedDoc.get_from_id(versioned_doc['_id'])
        assert len(list(versioned_doc.get_revisions())) == 3, len(list(versioned_doc.get_revisions()))

    def test_save_without_versionning(self):
        class MyVersionedDoc(VersionedDocument):
            structure = {
                "foo" : unicode,
            }
        self.connection.register([MyVersionedDoc])
 
        versioned_doc = self.col.MyVersionedDoc()
        versioned_doc['_id'] = "mydoc"
        versioned_doc['foo'] = u'bla'
        versioned_doc.save(versioning=False)
        assert self.col.MyVersionedDoc.versioning_collection.find().count() == 0
        assert self.col.find().count() == 1


    def test_save_versioning_without_id(self):
        class MyVersionedDoc(VersionedDocument):
            structure = {
                "foo" : unicode,
            }
        self.connection.register([MyVersionedDoc])
 
        versioned_doc = self.col.MyVersionedDoc()
        versioned_doc['foo'] = u'bla'
        versioned_doc.save()

        ver_doc = list(self.connection.test.versioned_mongokit.find())
        assert len(ver_doc) == 1
        assert 'doc' in ver_doc[0]
        assert 'revision' in ver_doc[0], ver_doc[0]

        ver_doc = list(self.col.find())
        assert len(ver_doc) == 1
        assert 'doc' not in ver_doc[0]
        assert '_revision' in ver_doc[0]

    def _test_bad_versioning(self):
        class MyVersionedDoc(VersionedDocument):
            structure = {
                "foo" : unicode,
            }
 
        self.connection.register([MyVersionedDoc])
        self.assertRaises(ValidationError, MyVersionedDoc)

    def test_delete_versioning(self):
        class MyVersionedDoc(VersionedDocument):
            structure = {
                "foo" : unicode,
            }
        self.connection.register([MyVersionedDoc])
 
        versioned_doc = self.col.MyVersionedDoc()
        versioned_doc['_id'] = "mydoc"
        versioned_doc['foo'] = u'bla'
        versioned_doc.save()
        assert self.col.MyVersionedDoc.versioning_collection.find().count() == 1
        versioned_doc['foo'] = u'bar'
        versioned_doc.save()
        assert self.col.MyVersionedDoc.versioning_collection.find().count() == 2
        versioned_doc.delete(versioning=True)
        assert self.col.MyVersionedDoc.versioning_collection.find().count() == 0
        assert self.col.MyVersionedDoc.find().count() == 0

        versioned_doc = self.col.MyVersionedDoc()
        versioned_doc['_id'] = "mydoc"
        versioned_doc['foo'] = u'bla'
        versioned_doc.save()
        assert self.col.MyVersionedDoc.versioning_collection.find().count() == 1
        versioned_doc['foo'] = u'bar'
        versioned_doc.save()
        assert self.col.MyVersionedDoc.versioning_collection.find().count() == 2
        versioned_doc.delete()
        assert self.col.MyVersionedDoc.versioning_collection.find().count() == 2
        assert self.col.MyVersionedDoc.find().count() == 0

    def test_remove_versioning(self):
        class MyVersionedDoc(VersionedDocument):
            structure = {
                "foo" : unicode,
            }
        self.connection.register([MyVersionedDoc])
 
        versioned_doc = self.col.MyVersionedDoc()
        versioned_doc['_id'] = "mydoc"
        versioned_doc['foo'] = u'bla'
        versioned_doc.save()
        versioned_doc2 = self.col.MyVersionedDoc()
        versioned_doc2['_id'] = "mydoc2"
        versioned_doc2['foo'] = u'bla'
        versioned_doc2.save()
        versioned_doc3 = self.col.MyVersionedDoc()
        versioned_doc3['_id'] = "mydoc3"
        versioned_doc3['foo'] = u'bla'
        versioned_doc3.save()

        versioned_doc['foo'] = u'bar'
        versioned_doc.save()
        versioned_doc2['foo'] = u'bar'
        versioned_doc2.save()
        versioned_doc3['foo'] = u'bar'
        versioned_doc3.save()

        count =  self.col.MyVersionedDoc.versioning_collection.find().count()
        assert count == 6, count
        count =  self.col.MyVersionedDoc.collection.find().count()
        assert count == 3, count

        versioned_doc.remove({'foo':'bar'}, versioning=True)

        count =  self.col.MyVersionedDoc.versioning_collection.find().count()
        assert count == 0, count
        count =  self.col.MyVersionedDoc.collection.find().count()
        assert count == 0, count

    def _test_versioning_with_dynamic_db(self):
        class MyVersionedDoc(VersionedDocument):
            structure = {
                "foo" : unicode,
            }
        self.connection.register([MyVersionedDoc])
 
        versioned_doc = self.col.MyVersionedDoc()
        versioned_doc['_id'] = "mydoc"
        versioned_doc['foo'] = u'bla'
        versioned_doc.save()

        ver_doc = list(self.connection.test.versioned_mongokit.find())
        assert len(ver_doc) == 1
        assert ver_doc[0]['id'] == 'mydoc'
        assert ver_doc[0]['revision'] == 1
        assert ver_doc[0]['doc'] == {u'_revision': 1, u'foo': u'bla', u'_id': u'mydoc'}

        ver_mongokit2 = list(CONNECTION['versioned_test']['versioned_mongokit'].find())
        assert len(ver_mongokit2) == 0, len(ver_mongokit2)

        versioned_doc2 = MyVersionedDoc(versioning_db_name="versioned_test")
        versioned_doc2['_id'] = "mydoc2"
        versioned_doc2['foo'] = u'bla'
        versioned_doc2.save()

        ver_mongokit = list(CONNECTION['test']['versioned_mongokit'].find())
        assert len(ver_mongokit) == 1, len(ver_mongokit)

        ver_doc = list(CONNECTION['versioned_test']['versioned_mongokit'].find())
        assert len(ver_doc) == 1
        assert ver_doc[0]['id'] == 'mydoc2'
        assert ver_doc[0]['revision'] == 1
        assert ver_doc[0]['doc'] == {u'_revision': 1, u'foo': u'bla', u'_id': u'mydoc2'}

        versioned_doc['foo'] = u'bar'
        versioned_doc.save()

        ver_doc = list(CONNECTION['test']['versioned_mongokit'].find())
        assert len(ver_doc) == 2
        ver_doc = list(CONNECTION['versioned_test']['versioned_mongokit'].find())
        assert len(ver_doc) == 1

    def _test_versioning_with_dynamic_collection(self):
        class MyVersionedDoc(VersionedDocument):
            structure = {
                "foo" : unicode,
            }
            versioning_collection_name = "versioned_mongokit"
 
        versioned_doc = MyVersionedDoc()
        versioned_doc['_id'] = "mydoc"
        versioned_doc['foo'] = u'bla'
        versioned_doc.save()

        ver_doc = list(CONNECTION['test']['versioned_mongokit'].find())
        assert len(ver_doc) == 1
        assert ver_doc[0]['id'] == 'mydoc'
        assert ver_doc[0]['revision'] == 1
        assert ver_doc[0]['doc'] == {u'_revision': 1, u'foo': u'bla', u'_id': u'mydoc'}

        ver_mongokit2 = list(CONNECTION['test']['versioned_mongokit2'].find())
        assert len(ver_mongokit2) == 0

        versioned_doc2 = MyVersionedDoc(versioning_collection_name="versioned_mongokit2")
        versioned_doc2['_id'] = "mydoc2"
        versioned_doc2['foo'] = u'bla'
        versioned_doc2.save()

        ver_mongokit = list(CONNECTION['test']['versioned_mongokit'].find())
        assert len(ver_mongokit) == 1, len(ver_mongokit)

        ver_doc = list(CONNECTION['test']['versioned_mongokit2'].find())
        assert len(ver_doc) == 1
        assert ver_doc[0]['id'] == 'mydoc2'
        assert ver_doc[0]['revision'] == 1
        assert ver_doc[0]['doc'] == {u'_revision': 1, u'foo': u'bla', u'_id': u'mydoc2'}

        versioned_doc['foo'] = u'bar'
        versioned_doc.save()

        ver_doc = list(CONNECTION['test']['versioned_mongokit'].find())
        assert len(ver_doc) == 2
        ver_doc = list(CONNECTION['test']['versioned_mongokit2'].find())
        assert len(ver_doc) == 1

    def test_versioning_without_versioning_collection_name(self):
        test_passed = False
        try:
            class Group(VersionedDocument):
                use_autorefs = True
                structure = {
                       'name':unicode,
                       'members':[User], #users
                   }
        except:
            test_passed = True
        assert test_passed

    def test_resave_versioned_doc_with_objectId(self):
        """
        1. Create a simple VersionedDocument using the defaults, thus using the
        built-in objectID.
        2. save to the database
        3. change the VersionedDocument contents (leave _id unchanged)
        4. resave to the database
            4a. the save action will search for the get_last_revision_id
            4b. add +1 to the _revision attribute
            4c. save the revised document, save the old document in the
                versioned_* collection

        4a BREAKS!

            self['_revision'] = self.get_last_revision_id()
        File "...\mongokit\versioned_document.py", line 100, in get_last_revision_id
            {'id':self['_id']}).sort('revision', -1).next()
        File "...\mongokit\cursor.py", line 44, in next
            raise StopIteration
        """
        class MyVersionedDoc(VersionedDocument):
            structure = {
                "foo" : unicode,
                }

        self.connection.register([MyVersionedDoc])

        versioned_doc = self.col.MyVersionedDoc()
        versioned_doc['foo'] = u'bla'
        versioned_doc.save()

        docs = list(self.col.find())
        assert len(docs) == 1

        versioned_doc['foo'] = u'Some Other bla'
        versioned_doc.save()

        print(versioned_doc)

    def test_resave_versioned_doc_with_UUID(self):
        """
        Simple versioning test, a bit different than the test_save_versionning

        """
        class MyVersionedUUIDDoc(VersionedDocument):
            structure = {
                "foo" : unicode,
                }
            def save(self, versioning=True, uuid=True, *args, **kwargs):
                """ Ensure that the save is performed using uuid=True """
                return super(MyVersionedUUIDDoc, self).save(versioning, uuid, *args, **kwargs)

        self.connection.register([MyVersionedUUIDDoc])

        versioned_doc = self.col.MyVersionedUUIDDoc()
        versioned_doc['foo'] = u'bla'
        versioned_doc.save()

        docs = list(self.col.find())
        assert len(docs) == 1

        versioned_doc['foo'] = u'Some Other bla'
        versioned_doc.save()

        # search for the versioned_doc in the database and compare id's
        ver_doc = list(self.connection.test.mongokit.find())
        assert len(ver_doc) == 1
        assert ver_doc[0]['_revision'] == 2
        assert ver_doc[0]['foo'] == u'Some Other bla'
        assert ver_doc[0]['_id'][:18] == u'MyVersionedUUIDDoc'
        assert ver_doc[0]['_id'] == versioned_doc['_id']

########NEW FILE########
