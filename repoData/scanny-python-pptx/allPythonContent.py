__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# python-pptx documentation build configuration file, created by
# sphinx-quickstart on Thu Nov 29 13:59:35 2012.
#
# This file is execfile()d with the current directory set to its containing
# dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

from pptx import __version__


# -- General configuration --------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',
    'sphinx.ext.inheritance_diagram',
    'sphinx.ext.intersphinx',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.ifconfig',
    'sphinx.ext.viewcode'
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'python-pptx'
copyright = u'2012, 2013, Steve Canny'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = __version__
# The full version, including alpha/beta/rc tags.
release = __version__

# A string of reStructuredText that will be included at the end of every source
# file that is read. This is the right place to add substitutions that should
# be available in every file.
rst_epilog = """
.. |Adjustment| replace:: :class:`Adjustment`

.. |AdjustmentCollection| replace:: :class:`AdjustmentCollection`

.. |BaseFileSystem| replace:: :class:`BaseFileSystem`

.. |BaseLength| replace:: :class:`.BaseLength`

.. |BaseShape| replace:: :class:`BaseShape`

.. |_Cell| replace:: :class:`_Cell`

.. |Collection| replace:: :class:`Collection`

.. |ColorFormat| replace:: :class:`ColorFormat`

.. |_Column| replace:: :class:`_Column`

.. |_ColumnCollection| replace:: :class:`_ColumnCollection`

.. |CoreProperties| replace:: :class:`CoreProperties`

.. |datetime| replace:: :class:`datetime.datetime`

.. |DirectoryFileSystem| replace:: :class:`DirectoryFileSystem`

.. |Emu| replace:: :class:`.Emu`

.. |False| replace:: :class:`False`

.. |FileSystem| replace:: :class:`FileSystem`

.. |FillFormat| replace:: :class:`.FillFormat`

.. |float| replace:: :class:`float`

.. |_Font| replace:: :class:`_Font`

.. |GraphicFrame| replace:: :class:`.GraphicFrame`

.. |_Hyperlink| replace:: :class:`_Hyperlink`

.. |int| replace:: :class:`int`

.. |KeyError| replace:: :exc:`KeyError`

.. |list| replace:: :class:`list`

.. |_LayoutPlaceholders| replace:: :class:`_LayoutPlaceholders`

.. |_LayoutShapeTree| replace:: :class:`_LayoutShapeTree`

.. |LineFormat| replace:: :class:`.LineFormat`

.. |_MasterPlaceholders| replace:: :class:`_MasterPlaceholders`

.. |_MasterShapeTree| replace:: :class:`_MasterShapeTree`

.. |None| replace:: :class:`None`

.. |NotImplementedError| replace:: :exc:`NotImplementedError`

.. |OpcPackage| replace:: :class:`.OpcPackage`

.. |Package| replace:: :class:`Package`

.. |PackURI| replace:: :class:`.PackURI`

.. |_Paragraph| replace:: :class:`_Paragraph`

.. |Part| replace:: :class:`Part`

.. |PartTypeSpec| replace:: :class:`PartTypeSpec`

.. |Picture| replace:: :class:`.Picture`

.. |pp| replace:: ``python-pptx``

.. |Presentation| replace:: :class:`~pptx.Presentation`

.. |_Relationship| replace:: :class:`._Relationship`

.. |RelationshipCollection| replace:: :class:`RelationshipCollection`

.. |RGBColor| replace:: :class:`.RGBColor`

.. |_Row| replace:: :class:`_Row`

.. |_RowCollection| replace:: :class:`_RowCollection`

.. |_Run| replace:: :class:`_Run`

.. |Shape| replace:: :class:`.Shape`

.. |ShapeCollection| replace:: :class:`.ShapeCollection`

.. |ShapeTree| replace:: :class:`.ShapeTree`

.. |Slide| replace:: :class:`Slide`

.. |SlideCollection| replace:: :class:`.SlideCollection`

.. |SlideLayout| replace:: :class:`.SlideLayout`

.. |SlideMaster| replace:: :class:`.SlideMaster`

.. |_SlidePlaceholders| replace:: :class:`._SlidePlaceholders`

.. |_SlideShapeTree| replace:: :class:`._SlideShapeTree`

.. |str| replace:: :class:`str`

.. |Table| replace:: :class:`Table`

.. |TextFrame| replace:: :class:`.TextFrame`

.. |True| replace:: :class:`True`

.. |ValueError| replace:: :exc:`ValueError`

.. |ZipFileSystem| replace:: :class:`ZipFileSystem`
"""

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['.build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'armstrong'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
# html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['.themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    '**': ['localtoc.html', 'relations.html', 'sidebarlinks.html',
           'searchbox.html']
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'python-pptxdoc'


# -- Options for LaTeX output -----------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    #'papersize': 'letterpaper',

    # The font size ('10pt', '11pt' or '12pt').
    #'pointsize': '10pt',

    # Additional stuff for the LaTeX preamble.
    #'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author,
#  documentclass [howto/manual]).
latex_documents = [
    ('index', 'python-pptx.tex', u'python-pptx Documentation',
     u'Steve Canny', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output -----------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'python-pptx', u'python-pptx Documentation',
     [u'Steve Canny'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ---------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    ('index', 'python-pptx', u'python-pptx Documentation',
     u'Steve Canny', 'python-pptx', 'One line description of project.',
     'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = environment
# -*- coding: utf-8 -*-
#
# environment.py
#
# Copyright (C) 2013 Steve Canny scanny@cisco.com
#
# This module is part of python-pptx and is released under the MIT License:
# http://www.opensource.org/licenses/mit-license.php

"""
Used by behave to set testing environment before and after running acceptance
tests.
"""

import os

scratch_dir = os.path.abspath(
    os.path.join(os.path.split(__file__)[0], '_scratch')
)


def before_all(context):
    if not os.path.isdir(scratch_dir):
        os.mkdir(scratch_dir)

########NEW FILE########
__FILENAME__ = coreprops
# encoding: utf-8

"""
Gherkin step implementations for core properties-related features.
"""

from __future__ import absolute_import

from datetime import datetime, timedelta

from behave import given, when, then
from hamcrest import assert_that, is_, less_than

from pptx import Presentation

from .helpers import saved_pptx_path, no_core_props_pptx_path


# given ===================================================

@given('I have a reference to the core properties of a presentation')
def step_given_ref_to_core_doc_props(context):
    context.prs = Presentation()
    context.core_properties = context.prs.core_properties


# when ====================================================

@when('I open a presentation having no core properties part')
def step_when_open_presentation_with_no_core_props_part(context):
    context.prs = Presentation(no_core_props_pptx_path)


@when("I set the core properties to valid values")
def step_when_set_core_doc_props_to_valid_values(context):
    context.propvals = (
        ('author', 'Creator'),
        ('category', 'Category'),
        ('comments', 'Description'),
        ('content_status', 'Content Status'),
        ('created', datetime(2013, 6, 15, 12, 34, 56)),
        ('identifier', 'Identifier'),
        ('keywords', 'key; word; keyword'),
        ('language', 'Language'),
        ('last_modified_by', 'Last Modified By'),
        ('last_printed', datetime(2013, 6, 15, 12, 34, 56)),
        ('modified', datetime(2013, 6, 15, 12, 34, 56)),
        ('revision', 9),
        ('subject', 'Subject'),
        ('title', 'Title'),
        ('version', 'Version'),
    )
    for name, value in context.propvals:
        setattr(context.prs.core_properties, name, value)


# then ====================================================

@then('a core properties part with default values is added')
def step_then_a_core_props_part_with_def_vals_is_added(context):
    core_props = context.prs.core_properties
    assert_that(core_props.title, is_('PowerPoint Presentation'))
    assert_that(core_props.last_modified_by, is_('python-pptx'))
    assert_that(core_props.revision, is_(1))
    # core_props.modified only stores time with seconds resolution, so
    # comparison needs to be a little loose (within two seconds)
    modified_timedelta = datetime.utcnow() - core_props.modified
    max_expected_timedelta = timedelta(seconds=2)
    assert_that(modified_timedelta, less_than(max_expected_timedelta))


@then('the core properties of the presentation have the values I set')
def step_then_core_props_have_values_previously_set(context):
    core_props = Presentation(saved_pptx_path).core_properties
    for name, value in context.propvals:
        reason = "for core property '%s'" % name
        assert_that(getattr(core_props, name), is_(value), reason)

########NEW FILE########
__FILENAME__ = font
# encoding: utf-8

"""
Step implementations for run property (font)-related features
"""

from __future__ import absolute_import

from behave import given, then

from pptx import Presentation

from .helpers import test_pptx


# given ===================================================

@given('a font')
def given_a_font(context):
    prs = Presentation(test_pptx('txt-font-props'))
    slide = prs.slides[1]
    textbox = slide.shapes[0]
    run = textbox.textframe.paragraphs[0].runs[0]
    context.font = run.font


@given('a font having {applied_size}')
def given_a_font_having_applied_size(context, applied_size):
    shape_idx = {
        'no directly applied size':        0,
        'a directly applied size of 42pt': 1,
    }[applied_size]
    prs = Presentation(test_pptx('txt-font-props'))
    slide = prs.slides[1]
    textbox = slide.shapes[shape_idx]
    run = textbox.textframe.paragraphs[0].runs[0]
    context.font = run.font


# then ===================================================

@then('the font size property value is {value_str}')
def then_the_font_size_property_value_is_value(context, value_str):
    expected_value = {
        '42.0 points': 42.0,
        'None':        None,
    }[value_str]
    font = context.font
    value = font.size if font.size is None else font.size.pt
    assert value == expected_value, (
        'expected %s, got %s' % (expected_value, value)
    )

########NEW FILE########
__FILENAME__ = font_color
# encoding: utf-8

"""
Gherkin step implementations for font color features
"""

from __future__ import absolute_import, print_function, unicode_literals

from behave import given, then, when

from pptx import Presentation
from pptx.dml.color import RGBColor
from pptx.enum.dml import MSO_COLOR_TYPE, MSO_THEME_COLOR

from .helpers import test_pptx


font_color_pptx_path = test_pptx('font-color')


# given ===================================================

@given('a font with {color_type} color')
def step_given_font_with_color_type(context, color_type):
    context.textbox_idx = {
        'no':      0,
        'an RGB':  1,
        'a theme': 2
    }[color_type]
    context.prs = Presentation(font_color_pptx_path)
    textbox = context.prs.slides[0].shapes[context.textbox_idx]
    context.font = textbox.textframe.paragraphs[0].runs[0].font


@given('a font with a color brightness setting of {setting}')
def step_font_with_color_brightness(context, setting):
    textbox_idx = {
        'no brightness adjustment': 2,
        '25% darker': 3,
        '40% lighter': 4,
    }[setting]
    context.prs = Presentation(font_color_pptx_path)
    textbox = context.prs.slides[0].shapes[textbox_idx]
    context.font = textbox.textframe.paragraphs[0].runs[0].font


# when ====================================================

@when('I set the font color brightness to {value}')
def step_set_font_color_brightness(context, value):
    context.font.color.brightness = float(value)


@when('I set the font {color_type} value')
def step_set_font_color_value(context, color_type):
    if color_type == 'RGB':
        context.font.color.rgb = RGBColor(0x12, 0x34, 0x56)
    elif color_type == 'theme color':
        context.font.color.theme_color = MSO_THEME_COLOR.DARK_1


# then ====================================================

@then('its color value matches its RGB color')
def step_color_value_matches_RGB_color(context):
    assert context.font.color.rgb == RGBColor(255, 102, 0)


@then('its color value matches its theme color')
def step_color_value_matches_theme_color(context):
    assert context.font.color.theme_color == MSO_THEME_COLOR.ACCENT_1


@then("the font's color type is {color_type}")
def step_then_font_color_type_is_value(context, color_type):
    expected_value = {
        'None':        None,
        'RGB':         MSO_COLOR_TYPE.RGB,
        'theme color': MSO_COLOR_TYPE.SCHEME,
    }[color_type]
    textbox = context.prs.slides[0].shapes[context.textbox_idx]
    font = textbox.textframe.paragraphs[0].runs[0].font
    assert font.color.type == expected_value


@then('its color brightness value is {value}')
def step_color_brightness_value_matches(context, value):
    assert context.font.color.brightness == float(value)


@then("the font's {color_type} value matches the value I set")
def step_color_type_value_matches(context, color_type):
    textbox = context.prs.slides[0].shapes[context.textbox_idx]
    font = textbox.textframe.paragraphs[0].runs[0].font
    if color_type == 'RGB':
        assert font.color.rgb == RGBColor(0x12, 0x34, 0x56)
    else:
        assert font.color.theme_color == MSO_THEME_COLOR.DARK_1


@then("the font's color brightness is {value}")
def step_color_brightness_matches(context, value):
    textbox = context.prs.slides[0].shapes[context.textbox_idx]
    font = textbox.textframe.paragraphs[0].runs[0].font
    assert font.color.brightness == float(value)

########NEW FILE########
__FILENAME__ = helpers
# encoding: utf-8

"""
Helper methods and variables for acceptance tests.
"""

import os


def absjoin(*paths):
    return os.path.abspath(os.path.join(*paths))

thisdir = os.path.split(__file__)[0]
scratch_dir = absjoin(thisdir, '../_scratch')
# legacy acceptance test pptx files are in unit test file dir
test_file_dir = absjoin(thisdir, '../../tests/test_files')
# new ones should go here instead, others should be moved over
test_pptx_dir = absjoin(thisdir, 'test_files')

# legacy test pptx files ---------------
no_core_props_pptx_path = absjoin(test_file_dir, 'no-core-props.pptx')
test_image_path = absjoin(test_file_dir, 'python-powered.png')

# scratch test pptx file ---------------
saved_pptx_path = absjoin(scratch_dir, 'test_out.pptx')

test_text = "python-pptx was here!"


def cls_qname(obj):
    module_name = obj.__module__
    cls_name = obj.__class__.__name__
    qname = '%s.%s' % (module_name, cls_name)
    return qname


def test_pptx(name):
    """
    Return the absolute path to test .pptx file with root name *name*.
    """
    return absjoin(thisdir, 'test_files', '%s.pptx' % name)

########NEW FILE########
__FILENAME__ = line
# encoding: utf-8

"""
Step implementations for line format features
"""

from __future__ import absolute_import, print_function, unicode_literals

from behave import given, then, when

from pptx import Presentation
from pptx.dml.color import RGBColor
from pptx.enum.dml import MSO_COLOR_TYPE, MSO_FILL_TYPE, MSO_THEME_COLOR
from pptx.util import Pt

from .helpers import test_pptx


# given ===================================================

@given('a line of {line_width} width')
def given_a_line_of_width(context, line_width):
    shape_idx = {
        'no explicit': 0,
        '1 pt':        1,
    }[line_width]
    prs = Presentation(test_pptx('shp-line-props'))
    shape = prs.slides[2].shapes[shape_idx]
    context.line = shape.line


@given('a line with {color_type} color')
def given_a_line_with_color_type_color(context, color_type):
    shape_idx = {
        'no':      0,
        'an RGB':  1,
        'a theme': 2
    }[color_type]
    prs = Presentation(test_pptx('shp-line-props'))
    shape = prs.slides[1].shapes[shape_idx]
    context.line = shape.line


@given('an autoshape outline having {outline_type}')
def given_autoshape_outline_having_outline_type(context, outline_type):
    shape_idx = {
        'an inherited outline format': 0,
        'no outline':                  1,
        'a solid outline':             2,
    }[outline_type]
    prs = Presentation(test_pptx('shp-line-props'))
    autoshape = prs.slides[0].shapes[shape_idx]
    context.line = autoshape.line


# when ====================================================

@when('I set the line {color_type} value')
def when_I_set_the_line_color_value(context, color_type):
    if color_type == 'RGB':
        context.line.color.rgb = RGBColor(0x12, 0x34, 0x56)
    elif color_type == 'theme color':
        context.line.color.theme_color = MSO_THEME_COLOR.DARK_1


@when('I set the line width to {line_width}')
def when_I_set_the_line_width_to_value(context, line_width):
    value = {
        'None':    None,
        '1 pt':    Pt(1),
        '2.34 pt': Pt(2.34),
    }[line_width]
    context.line.width = value


@when('I set the line fill type to {line_fill_type}')
def when_I_set_the_line_fill_type_to_line_fill_type(context, line_fill_type):
    line = context.line
    if line_fill_type == 'solid':
        line.fill.solid()
    elif line_fill_type == 'background':
        line.fill.background()


# then ====================================================

@then('the line fill type is {fill_type}')
def then_the_line_file_type_is_fill_type(context, fill_type):
    expected_fill_type = {
        'None':                      None,
        'MSO_FILL_TYPE.BACKGROUND':  MSO_FILL_TYPE.BACKGROUND,
        'MSO_FILL_TYPE.SOLID':       MSO_FILL_TYPE.SOLID,
    }[fill_type]
    line = context.line
    fill_type = line.fill.type
    assert fill_type == expected_fill_type, (
        "expected '%s', got '%s'" % (expected_fill_type, fill_type)
    )


@then("the line's color type is {color_type}")
def then_the_line_color_type_is_value(context, color_type):
    expected_value = {
        'None':        None,
        'RGB':         MSO_COLOR_TYPE.RGB,
        'theme color': MSO_COLOR_TYPE.SCHEME,
    }[color_type]
    line = context.line
    assert line.color.type == expected_value


@then("the line's {color_type} value matches the new value")
def then_the_line_color_type_value_matches(context, color_type):
    line = context.line
    if color_type == 'RGB':
        assert line.color.rgb == RGBColor(0x12, 0x34, 0x56)
    else:
        assert line.color.theme_color == MSO_THEME_COLOR.DARK_1


@then("the reported line width is {line_width}")
def then_the_reported_line_width_is_value(context, line_width):
    expected_value = {
        'None':    None,
        '1 pt':    Pt(1),
        '2.34 pt': Pt(2.34),
    }[line_width]
    line = context.line
    assert line.width == expected_value

########NEW FILE########
__FILENAME__ = picture
# encoding: utf-8

"""
Gherkin step implementations for picture-related features.
"""

from __future__ import absolute_import

from StringIO import StringIO

from behave import given, when, then
from hamcrest import assert_that, has_item

from pptx import Presentation
from pptx.package import Package
from pptx.util import Inches

from .helpers import saved_pptx_path, test_image_path, test_pptx


# given ===================================================

@given('a picture of known position and size')
def given_a_picture_of_known_position_and_size(context):
    prs = Presentation(test_pptx('shp-pos-and-size'))
    context.picture = prs.slides[1].shapes[0]


# when ====================================================

@when("I add a picture stream to the slide's shape collection")
def step_when_add_picture_stream(context):
    shapes = context.sld.shapes
    x, y = (Inches(1.25), Inches(1.25))
    with open(test_image_path) as f:
        stream = StringIO(f.read())
    shapes.add_picture(stream, x, y)


@when("I add a picture to the slide's shape collection")
def step_when_add_picture(context):
    shapes = context.sld.shapes
    x, y = (Inches(1.25), Inches(1.25))
    shapes.add_picture(test_image_path, x, y)


# then ====================================================

@then('the image is saved in the pptx file')
def step_then_img_saved_in_pptx_file(context):
    pkg = Package().open(saved_pptx_path)
    partnames = [part.partname for part in pkg.parts]
    assert_that(partnames, has_item('/ppt/media/image1.png'))


@then('the picture appears in the slide')
def step_then_picture_appears_in_slide(context):
    prs = Presentation(saved_pptx_path)
    sld = prs.slides[0]
    shapes = sld.shapes
    classnames = [sp.__class__.__name__ for sp in shapes]
    assert_that(classnames, has_item('Picture'))

########NEW FILE########
__FILENAME__ = placeholder
# encoding: utf-8

"""
Gherkin step implementations for placeholder-related features.
"""

from __future__ import absolute_import

from behave import given, when, then
from hamcrest import assert_that, equal_to, is_

from pptx import Presentation

from .helpers import saved_pptx_path, test_pptx, test_text


# given ===================================================

@given('a bullet body placeholder')
def given_a_bullet_body_placeholder(context):
    context.prs = Presentation()
    slide_layout = context.prs.slide_layouts[1]
    context.sld = context.prs.slides.add_slide(slide_layout)
    context.body = context.sld.shapes.placeholders[1]


@given('a layout placeholder having directly set position and size')
def given_layout_placeholder_with_directly_set_pos_and_size(context):
    prs = Presentation(test_pptx('ph-inherit-props'))
    context.placeholder = prs.slide_layouts[0].placeholders[1]


@given('a layout placeholder having no direct position or size settings')
def given_layout_placeholder_with_no_direct_pos_or_size_settings(context):
    prs = Presentation(test_pptx('ph-inherit-props'))
    context.placeholder = prs.slide_layouts[0].placeholders[0]


@given('a master placeholder')
def given_a_master_placeholder(context):
    prs = Presentation(test_pptx('ph-inherit-props'))
    context.master_placeholder = prs.slide_master.placeholders[1]


@given('a slide placeholder having directly set position and size')
def given_slide_placeholder_with_directly_set_pos_and_size(context):
    prs = Presentation(test_pptx('ph-inherit-props'))
    context.placeholder = prs.slides[0].placeholders[1]


@given('a slide placeholder having no direct position or size settings')
def given_slide_placeholder_with_no_direct_pos_or_size_settings(context):
    prs = Presentation(test_pptx('ph-inherit-props'))
    context.placeholder = prs.slides[0].placeholders[0]


# when ====================================================

@when('I indent the first paragraph')
def step_when_indent_first_paragraph(context):
    context.body.textframe.paragraphs[0].level = 1


@when("I set the title text of the slide")
def step_when_set_slide_title_text(context):
    context.sld.shapes.title.text = test_text


# then ====================================================

@then('I can get the placeholder dimensions')
def then_I_can_get_the_placeholder_dimensions(context):
    placeholder = context.master_placeholder
    assert placeholder.width == 6923112, 'got %d' % placeholder.width
    assert placeholder.height == 3484984, 'got %d' % placeholder.height


@then('I can get the placeholder position')
def then_I_can_get_the_placeholder_position(context):
    placeholder = context.master_placeholder
    assert placeholder.left == 1110444, 'got %d' % placeholder.left
    assert placeholder.top == 1686508, 'got %d' % placeholder.top


@then('I get the direct settings when I query position and size')
def then_I_get_direct_settings_when_query_pos_and_size(context):
    placeholder = context.placeholder
    assert placeholder.left == 468312, 'got %s' % placeholder.left
    assert placeholder.top == 1700212, 'got %s' % placeholder.top
    assert placeholder.width == 8208143, 'got %s' % placeholder.width
    assert placeholder.height == 4537099, 'got %s' % placeholder.height


@then('I get inherited settings when I query position and size')
def then_I_get_inherited_settings_when_I_query_position_and_size(context):
    placeholder = context.placeholder
    assert placeholder.left == 457200, 'got %s' % placeholder.left
    assert placeholder.top == 274638, 'got %s' % placeholder.top
    assert placeholder.width == 8229600, 'got %s' % placeholder.width
    assert placeholder.height == 1143000, 'got %s' % placeholder.height


@then('the paragraph is indented')
def then_paragraph_is_indented(context):
    prs = Presentation(saved_pptx_path)
    sld = prs.slides[0]
    body = sld.shapes.placeholders[1]
    p = body.textframe.paragraphs[0]
    assert_that(p.level, is_(equal_to(1)))


@then('the text appears in the title placeholder')
def step_then_text_appears_in_title_placeholder(context):
    prs = Presentation(saved_pptx_path)
    title_shape = prs.slides[0].shapes.title
    title_text = title_shape.textframe.paragraphs[0].runs[0].text
    assert_that(title_text, is_(equal_to(test_text)))

########NEW FILE########
__FILENAME__ = presentation
# encoding: utf-8

"""
Gherkin step implementations for presentation-level features.
"""

from __future__ import absolute_import

import os

from behave import given, when, then
from hamcrest import assert_that, is_, is_not, greater_than
from StringIO import StringIO

from pptx import Presentation
from pptx.opc.constants import RELATIONSHIP_TYPE as RT
from pptx.parts.presentation import _SlideMasters
from pptx.parts.slidemaster import SlideMaster

from .helpers import saved_pptx_path, test_pptx


# given ===================================================

@given('a clean working directory')
def given_clean_working_dir(context):
    if os.path.isfile(saved_pptx_path):
        os.remove(saved_pptx_path)


@given('a presentation')
def given_a_presentation(context):
    context.presentation = Presentation(test_pptx('prs-properties'))


@given('a presentation having two slide masters')
def given_presentation_having_two_masters(context):
    context.presentation = Presentation(test_pptx('prs-slide-masters'))


@given('a presentation with external relationships')
def given_prs_with_ext_rels(context):
    context.prs = Presentation(test_pptx('ext-rels'))


@given('a slide master collection containing two masters')
def given_slide_master_collection_containing_two_masters(context):
    prs = Presentation(test_pptx('prs-slide-masters'))
    context.slide_masters = prs.slide_masters


@given('an empty presentation')
def given_an_empty_presentation(context):
    context.prs = Presentation()


@given('an initialized pptx environment')
def given_initialized_pptx_env(context):
    pass


# when ====================================================

@when('I change the slide width and height')
def when_change_slide_width_and_height(context):
    presentation = context.presentation
    presentation.slide_width = 100000
    presentation.slide_height = 200000


@when('I construct a Presentation instance with no path argument')
def when_construct_default_prs(context):
    context.prs = Presentation()


@when('I open a basic PowerPoint presentation')
def when_open_basic_pptx(context):
    context.prs = Presentation(test_pptx('test'))


@when('I open a presentation contained in a stream')
def when_open_presentation_stream(context):
    with open(test_pptx('test')) as f:
        stream = StringIO(f.read())
    context.prs = Presentation(stream)
    stream.close()


@when('I save and reload the presentation')
def when_save_and_reload_prs(context):
    if os.path.isfile(saved_pptx_path):
        os.remove(saved_pptx_path)
    context.prs.save(saved_pptx_path)
    context.prs = Presentation(saved_pptx_path)


@when('I save that stream to a file')
def when_save_stream_to_a_file(context):
    if os.path.isfile(saved_pptx_path):
        os.remove(saved_pptx_path)
    context.stream.seek(0)
    with open(saved_pptx_path, 'wb') as f:
        f.write(context.stream.read())


@when('I save the presentation')
def when_save_presentation(context):
    if os.path.isfile(saved_pptx_path):
        os.remove(saved_pptx_path)
    context.prs.save(saved_pptx_path)


@when('I save the presentation to a stream')
def when_save_presentation_to_stream(context):
    context.stream = StringIO()
    context.prs.save(context.stream)


# then ====================================================

@then('I can access a slide master by index')
def then_can_access_slide_master_by_index(context):
    slide_masters = context.slide_masters
    for idx in range(2):
        slide_master = slide_masters[idx]
        assert isinstance(slide_master, SlideMaster)


@then('I can access the slide master collection of the presentation')
def then_can_access_slide_masters_of_presentation(context):
    presentation = context.presentation
    slide_masters = presentation.slide_masters
    msg = 'Presentation.slide_masters not instance of _SlideMasters'
    assert isinstance(slide_masters, _SlideMasters), msg


@then('I can iterate over the slide masters')
def then_can_iterate_over_the_slide_masters(context):
    slide_masters = context.slide_masters
    actual_count = 0
    for slide_master in slide_masters:
        actual_count += 1
        assert isinstance(slide_master, SlideMaster)
    assert actual_count == 2


@then('I receive a presentation based on the default template')
def then_receive_prs_based_on_def_tmpl(context):
    prs = context.prs
    assert_that(prs, is_not(None))
    slide_masters = prs.slide_masters
    assert_that(slide_masters, is_not(None))
    assert_that(len(slide_masters), is_(1))
    slide_layouts = slide_masters[0].slide_layouts
    assert_that(slide_layouts, is_not(None))
    assert_that(len(slide_layouts), is_(11))


@then('its slide height matches its known value')
def then_slide_height_matches_known_value(context):
    presentation = context.presentation
    assert presentation.slide_height == 6858000


@then('its slide width matches its known value')
def then_slide_width_matches_known_value(context):
    presentation = context.presentation
    assert presentation.slide_width == 9144000


@then('I see the pptx file in the working directory')
def then_see_pptx_file_in_working_dir(context):
    assert_that(os.path.isfile(saved_pptx_path))
    minimum = 30000
    actual = os.path.getsize(saved_pptx_path)
    assert_that(actual, is_(greater_than(minimum)))


@then('the external relationships are still there')
def then_ext_rels_are_preserved(context):
    prs = context.prs
    sld = prs.slides[0]
    rel = sld._rels['rId2']
    assert rel.is_external
    assert rel.reltype == RT.HYPERLINK
    assert rel.target_ref == 'https://github.com/scanny/python-pptx'


@then('the length of the slide master collection is 2')
def then_len_of_slide_master_collection_is_2(context):
    presentation = context.presentation
    slide_masters = presentation.slide_masters
    assert len(slide_masters) == 2, (
        'expected len(slide_masters) of 2, got %s' % len(slide_masters)
    )


@then('the slide height matches the new value')
def then_slide_height_matches_new_value(context):
    presentation = context.presentation
    assert presentation.slide_height == 200000


@then('the slide width matches the new value')
def then_slide_width_matches_new_value(context):
    presentation = context.presentation
    assert presentation.slide_width == 100000

########NEW FILE########
__FILENAME__ = shape
# encoding: utf-8

"""
Gherkin step implementations for shape-related features.
"""

from __future__ import absolute_import, print_function

from behave import given, when, then

from pptx import Presentation
from pptx.dml.color import RGBColor
from pptx.enum.dml import MSO_FILL, MSO_THEME_COLOR
from pptx.enum.shapes import MSO_SHAPE, MSO_SHAPE_TYPE
from pptx.util import Inches

from .helpers import cls_qname, saved_pptx_path, test_pptx, test_text


# given ===================================================

@given('a connector')
def given_a_connector(context):
    prs = Presentation(test_pptx('shp-common-props'))
    sld = prs.slides[0]
    context.shape = sld.shapes[4]


@given('a group shape')
def given_a_group_shape(context):
    prs = Presentation(test_pptx('shp-common-props'))
    sld = prs.slides[0]
    context.shape = sld.shapes[3]


@given('a picture')
def given_a_picture(context):
    prs = Presentation(test_pptx('shp-common-props'))
    sld = prs.slides[0]
    context.shape = sld.shapes[1]


@given('a shape')
def given_a_shape(context):
    prs = Presentation(test_pptx('shp-common-props'))
    sld = prs.slides[0]
    context.shape = sld.shapes[0]


@given('a table')
def given_a_table(context):
    prs = Presentation(test_pptx('shp-common-props'))
    sld = prs.slides[0]
    context.shape = sld.shapes[2]


@given('a {shape_type} on a slide')
def given_a_shape_on_a_slide(context, shape_type):
    shape_idx = {
        'shape':       0,
        'picture':     1,
        'table':       2,
        'group shape': 3,
        'connector':   4,
    }[shape_type]
    prs = Presentation(test_pptx('shp-common-props'))
    sld = prs.slides[0]
    context.shape = sld.shapes[shape_idx]
    context.slide = sld


@given('a shape of known position and size')
def given_a_shape_of_known_position_and_size(context):
    prs = Presentation(test_pptx('shp-pos-and-size'))
    context.shape = prs.slides[0].shapes[0]


@given('an autoshape')
def given_an_autoshape(context):
    prs = Presentation()
    blank_slide_layout = prs.slide_layouts[6]
    shapes = prs.slides.add_slide(blank_slide_layout).shapes
    x = y = cx = cy = 914400
    context.shape = shapes.add_shape(MSO_SHAPE.ROUNDED_RECTANGLE, x, y, cx, cy)


@given('I have a reference to a chevron shape')
def given_ref_to_chevron_shape(context):
    context.prs = Presentation()
    blank_slide_layout = context.prs.slide_layouts[6]
    shapes = context.prs.slides.add_slide(blank_slide_layout).shapes
    x = y = cx = cy = 914400
    context.chevron_shape = shapes.add_shape(MSO_SHAPE.CHEVRON, x, y, cx, cy)


# when ====================================================

@when("I add a text box to the slide's shape collection")
def when_add_text_box(context):
    shapes = context.sld.shapes
    x, y = (Inches(1.00), Inches(2.00))
    cx, cy = (Inches(3.00), Inches(1.00))
    sp = shapes.add_textbox(x, y, cx, cy)
    sp.text = test_text


@when("I add an auto shape to the slide's shape collection")
def when_add_auto_shape(context):
    shapes = context.sld.shapes
    x, y = (Inches(1.00), Inches(2.00))
    cx, cy = (Inches(3.00), Inches(4.00))
    sp = shapes.add_shape(MSO_SHAPE.ROUNDED_RECTANGLE, x, y, cx, cy)
    sp.text = test_text


@when("I change the left and top of the {shape_type}")
def when_I_change_the_position_of_the_shape(context, shape_type):
    left, top = {
        'shape':        (692696, 1339552),
        'picture':     (1835696, 2711152),
        'table':       (2978696, 4082752),
        'group shape': (4121696, 5454352),
        'connector':   (5264696, 6825952),
    }[shape_type]
    shape = context.shape
    shape.left = left
    shape.top = top


@when("I change the width and height of the {shape_type}")
def when_I_change_the_size_of_the_shape(context, shape_type):
    width, height = {
        'shape':        (692696, 1339552),
        'picture':     (1835696, 2711152),
        'table':       (2978696, 4082752),
        'group shape': (4121696, 5454352),
        'connector':   (5264696, 6825952),
    }[shape_type]
    shape = context.shape
    shape.width = width
    shape.height = height


@when("I set the fill type to background")
def when_set_fill_type_to_background(context):
    context.shape.fill.background()


@when("I set the fill type to solid")
def when_set_fill_type_to_solid(context):
    context.shape.fill.solid()


@when("I set the first adjustment value to 0.15")
def when_set_first_adjustment_value(context):
    context.chevron_shape.adjustments[0] = 0.15


@when("I set the foreground color brightness to 0.5")
def when_set_fore_color_brightness_to_value(context):
    context.shape.fill.fore_color.brightness = 0.5


@when("I set the foreground color to a theme color")
def when_set_fore_color_to_theme_color(context):
    context.shape.fill.fore_color.theme_color = MSO_THEME_COLOR.ACCENT_6


@when("I set the foreground color to an RGB value")
def when_set_fore_color_to_RGB_value(context):
    context.shape.fill.fore_color.rgb = RGBColor(0x12, 0x34, 0x56)


# then ====================================================

@then('the auto shape appears in the slide')
def then_auto_shape_appears_in_slide(context):
    prs = Presentation(saved_pptx_path)
    sp = prs.slides[0].shapes[0]
    sp_text = sp.textframe.paragraphs[0].runs[0].text
    assert sp.shape_type == MSO_SHAPE_TYPE.AUTO_SHAPE
    assert sp.auto_shape_type == MSO_SHAPE.ROUNDED_RECTANGLE
    assert sp_text == test_text


@then('the chevron shape appears with a less acute arrow head')
def then_chevron_shape_appears_with_less_acute_arrow_head(context):
    chevron = Presentation(saved_pptx_path).slides[0].shapes[0]
    assert chevron.adjustments[0] == 0.15


@then('the fill type of the shape is background')
def then_fill_type_is_background(context):
    assert context.shape.fill.type == MSO_FILL.BACKGROUND


@then('the foreground color brightness of the shape is 0.5')
def then_fore_color_brightness_is_value(context):
    assert context.shape.fill.fore_color.brightness == 0.5


@then('the foreground color of the shape is the RGB value I set')
def then_fore_color_is_RGB_value_I_set(context):
    assert context.shape.fill.fore_color.rgb == RGBColor(0x12, 0x34, 0x56)


@then('the foreground color of the shape is the theme color I set')
def then_fore_color_is_theme_color_I_set(context):
    fore_color = context.shape.fill.fore_color
    assert fore_color.theme_color == MSO_THEME_COLOR.ACCENT_6


@then('I can access the line format of the shape')
def then_I_can_access_the_line_format_of_the_shape(context):
    shape = context.shape
    line_format = shape.line
    line_format_cls_name = cls_qname(line_format)
    expected_cls_name = 'pptx.dml.line.LineFormat'
    assert line_format_cls_name == expected_cls_name, (
        "expected '%s', got '%s'" % (expected_cls_name, line_format_cls_name)
    )


@then('I can access the slide from the shape')
def then_I_can_access_the_slide_from_the_shape(context):
    assert context.shape.part is context.slide


@then('I can determine the shape {has_textframe_status}')
def then_the_shape_has_textframe_status(context, has_textframe_status):
    has_textframe = {
        'has a text frame':  True,
        'has no text frame': False,
    }[has_textframe_status]
    assert context.shape.has_textframe is has_textframe


@then('I can get the id of the {shape_type}')
def then_I_can_get_the_id_of_the_shape(context, shape_type):
    expected_id = {
        'shape':        2,
        'picture':      3,
        'table':        4,
        'group shape':  9,
        'connector':   11,
    }[shape_type]
    assert context.shape.id == expected_id


@then('I can get the name of the {shape_type}')
def then_I_can_get_the_name_of_the_shape(context, shape_type):
    expected_name = {
        'shape':       'Rounded Rectangle 1',
        'picture':     'Picture 2',
        'table':       'Table 3',
        'group shape': 'Group 8',
        'connector':   'Elbow Connector 10',
    }[shape_type]
    shape = context.shape
    msg = "expected shape name '%s', got '%s'" % (shape.name, expected_name)
    assert shape.name == expected_name, msg


@then('the left and top of the {shape_type} match their new values')
def then_left_and_top_of_shape_match_new_values(context, shape_type):
    expected_left, expected_top = {
        'shape':        (692696, 1339552),
        'picture':     (1835696, 2711152),
        'table':       (2978696, 4082752),
        'group shape': (4121696, 5454352),
        'connector':   (5264696, 6825952),
    }[shape_type]
    shape = context.shape
    assert shape.left == expected_left, 'got left: %s' % shape.left
    assert shape.top == expected_top, 'got top: %s' % shape.top


@then('the left and top of the {shape_type} match their known values')
def then_left_and_top_of_shape_match_known_values(context, shape_type):
    expected_left, expected_top = {
        'shape':       (1339552,  692696),
        'picture':     (2711152, 1835696),
        'table':       (4082752, 2978696),
        'group shape': (5454352, 4121696),
        'connector':   (6825952, 5264696),
    }[shape_type]
    shape = context.shape
    assert shape.left == expected_left, 'got left: %s' % shape.left
    assert shape.top == expected_top, 'got top: %s' % shape.top


@then('the width and height of the {shape_type} match their known values')
def then_width_and_height_of_shape_match_known_values(context, shape_type):
    expected_width, expected_height = {
        'shape':       (928192, 914400),
        'picture':     (914400, 945232),
        'table':       (993304, 914400),
        'group shape': (914400, 914400),
        'connector':   (986408, 828600),
    }[shape_type]
    shape = context.shape
    assert shape.width == expected_width, 'got width: %s' % shape.width
    assert shape.height == expected_height, 'got height: %s' % shape.height


@then('the width and height of the {shape_type} match their new values')
def then_width_and_height_of_shape_match_new_values(context, shape_type):
    expected_width, expected_height = {
        'shape':        (692696, 1339552),
        'picture':     (1835696, 2711152),
        'table':       (2978696, 4082752),
        'group shape': (4121696, 5454352),
        'connector':   (5264696, 6825952),
    }[shape_type]
    shape = context.shape
    assert shape.width == expected_width, 'got width: %s' % shape.width
    assert shape.height == expected_height, 'got height: %s' % shape.height


@then('the text box appears in the slide')
def then_text_box_appears_in_slide(context):
    prs = Presentation(saved_pptx_path)
    textbox = prs.slides[0].shapes[0]
    textbox_text = textbox.textframe.paragraphs[0].runs[0].text
    assert textbox_text == test_text

########NEW FILE########
__FILENAME__ = slide
# encoding: utf-8

"""
Gherkin step implementations for slide-related features.
"""

from __future__ import absolute_import

from behave import given, when, then
from hamcrest import assert_that, equal_to, is_

from pptx import Presentation
from pptx.parts.slide import (
    _SlidePlaceholder, _SlidePlaceholders, _SlideShapeTree
)
from pptx.shapes.picture import Picture
from pptx.shapes.shape import BaseShape

from .helpers import saved_pptx_path, test_pptx


# given ===================================================

@given('a blank slide')
def given_a_blank_slide(context):
    context.prs = Presentation()
    slide_layout = context.prs.slide_layouts[6]
    context.sld = context.prs.slides.add_slide(slide_layout)


@given('a slide')
def given_a_slide(context):
    context.prs = Presentation()
    slide_layout = context.prs.slide_layouts[0]
    context.sld = context.prs.slides.add_slide(slide_layout)


@given('a slide having three shapes')
def given_a_slide_having_three_shapes(context):
    presentation = Presentation(test_pptx('sld-access-shapes'))
    context.slide = presentation.slides[0]


@given('a slide having two placeholders')
def given_a_slide_having_two_placeholders(context):
    prs = Presentation(test_pptx('sld-access-shapes'))
    context.slide = prs.slides[0]


@given('a slide placeholder collection')
def given_a_slide_placeholder_collection(context):
    prs = Presentation(test_pptx('sld-access-shapes'))
    context.slide_placeholders = prs.slides[0].placeholders


@given('a slide shape collection')
def given_a_slide_shape_collection(context):
    presentation = Presentation(test_pptx('sld-access-shapes'))
    context.shapes = presentation.slides[0].shapes


# when ====================================================

@when('I add a slide based on a layout')
def when_I_add_a_slide_based_on_a_layout(context):
    slide_layout = context.prs.slide_masters[0].slide_layouts[0]
    context.prs.slides.add_slide(slide_layout)


# then ====================================================

@then('each slide shape is of the appropriate type')
def then_each_slide_shape_is_of_the_appropriate_type(context):
    shapes = context.shapes
    expected_types = [_SlidePlaceholder, _SlidePlaceholder, Picture]
    for idx, shape in enumerate(shapes):
        assert type(shape) == expected_types[idx], (
            "got \'%s\'" % type(shape).__name__
        )


@then('I can access a shape by index')
def then_can_access_shape_by_index(context):
    shapes = context.shapes
    for idx in range(2):
        shape = shapes[idx]
        assert isinstance(shape, BaseShape)


@then('I can access a slide placeholder by index')
def then_can_access_slide_placeholder_by_index(context):
    slide_placeholders = context.slide_placeholders
    for idx in range(2):
        slide_placeholder = slide_placeholders[idx]
        assert isinstance(slide_placeholder, _SlidePlaceholder)


@then('I can access the placeholder collection of the slide')
def then_can_access_placeholder_collection_of_slide(context):
    slide = context.slide
    slide_placeholders = slide.placeholders
    msg = 'Slide.placeholders not instance of _SlidePlaceholders'
    assert isinstance(slide_placeholders, _SlidePlaceholders), msg


@then('I can access the shape collection of the slide')
def then_can_access_shapes_of_slide(context):
    slide = context.slide
    shapes = slide.shapes
    msg = 'Slide.shapes not instance of _SlideShapeTree'
    assert isinstance(shapes, _SlideShapeTree), msg


@then('I can access the title placeholder')
def then_I_can_access_the_title_placeholder(context):
    shapes = context.shapes
    title_placeholder = shapes.title
    assert title_placeholder.element is shapes[0].element
    assert title_placeholder.id == 4


@then('I can iterate over the shapes')
def then_can_iterate_over_the_shapes(context):
    shapes = context.shapes
    actual_count = 0
    for shape in shapes:
        actual_count += 1
        assert isinstance(shape, BaseShape)
    assert actual_count == 3


@then('I can iterate over the slide placeholders')
def then_can_iterate_over_the_slide_placeholders(context):
    slide_placeholders = context.slide_placeholders
    actual_count = 0
    for slide_placeholder in slide_placeholders:
        actual_count += 1
        assert isinstance(slide_placeholder, _SlidePlaceholder)
    assert actual_count == 2


@then('the length of the shape collection is 3')
def then_len_of_shape_collection_is_3(context):
    slide = context.slide
    shapes = slide.shapes
    assert len(shapes) == 3, (
        'expected len(shapes) of 3, got %s' % len(shapes)
    )


@then('the length of the slide placeholder collection is 2')
def then_len_of_placeholder_collection_is_2(context):
    slide = context.slide
    slide_placeholders = slide.placeholders
    assert len(slide_placeholders) == 2, (
        'expected len(slide_placeholders) of 2, got %s' %
        len(slide_placeholders)
    )


@then('the pptx file contains a single slide')
def then_pptx_file_contains_single_slide(context):
    context.prs = prs = Presentation(saved_pptx_path)
    assert_that(len(prs.slides), is_(equal_to(1)))


@then('the index of each shape matches its position in the sequence')
def then_index_of_each_shape_matches_its_position_in_the_sequence(context):
    shapes = context.shapes
    for idx, shape in enumerate(shapes):
        assert idx == shapes.index(shape), (
            "index doesn't match for idx == %s" % idx
        )


@then('the layout has been applied to the slide')
def then_the_layout_has_been_applied_to_the_slide(context):
    prs = context.prs
    shapes = prs.slides[0].shapes
    assert len(shapes) == 2
    assert shapes[0].name == 'Title 1'
    assert shapes[1].name == 'Subtitle 2'

########NEW FILE########
__FILENAME__ = slidelayout
# encoding: utf-8

"""
Step implementations for slide layout-related features
"""

from __future__ import absolute_import

from behave import given, then

from pptx import Presentation
from pptx.parts.slidelayout import (
    _LayoutPlaceholder, _LayoutPlaceholders, _LayoutShapeTree
)
from pptx.shapes.picture import Picture
from pptx.shapes.shape import BaseShape

from .helpers import test_pptx


SHAPE_COUNT = 3


# given ===================================================

@given('a layout placeholder collection')
def given_layout_placeholder_collection(context):
    prs = Presentation(test_pptx('lyt-shapes'))
    context.layout_placeholders = prs.slide_layouts[0].placeholders


@given('a layout shape collection')
def given_layout_shape_collection(context):
    prs = Presentation(test_pptx('lyt-shapes'))
    context.layout_shapes = prs.slide_layouts[0].shapes


@given('a slide layout having three shapes')
def given_slide_layout_having_three_shapes(context):
    prs = Presentation(test_pptx('lyt-shapes'))
    context.slide_layout = prs.slide_layouts[0]


@given('a slide layout having two placeholders')
def given_layout_having_two_placeholders(context):
    prs = Presentation(test_pptx('lyt-shapes'))
    context.slide_layout = prs.slide_layouts[0]


# then ====================================================

@then('each shape is of the appropriate type')
def then_each_shape_is_of_appropriate_type(context):
    layout_shapes = context.layout_shapes
    expected_types = [_LayoutPlaceholder, _LayoutPlaceholder, Picture]
    for idx, layout_shape in enumerate(layout_shapes):
        assert type(layout_shape) == expected_types[idx], (
            "got \'%s\'" % type(layout_shape).__name__
        )


@then('I can access a layout placeholder by idx value')
def then_can_access_layout_placeholder_by_idx_value(context):
    layout_placeholders = context.layout_placeholders
    title_placeholder = layout_placeholders.get(idx=0)
    body_placeholder = layout_placeholders.get(idx=10)
    assert title_placeholder._element is layout_placeholders[0]._element
    assert body_placeholder._element is layout_placeholders[1]._element


@then('I can access a layout placeholder by index')
def then_can_access_layout_placeholder_by_index(context):
    layout_placeholders = context.layout_placeholders
    for idx in range(2):
        layout_placeholder = layout_placeholders[idx]
        assert isinstance(layout_placeholder, _LayoutPlaceholder)


@then('I can access a layout shape by index')
def then_can_access_layout_shape_by_index(context):
    layout_shapes = context.layout_shapes
    for idx in range(SHAPE_COUNT):
        layout_shape = layout_shapes[idx]
        assert isinstance(layout_shape, BaseShape)


@then('I can access the placeholder collection of the slide layout')
def then_can_access_placeholder_collection_of_slide_layout(context):
    slide_layout = context.slide_layout
    layout_placeholders = slide_layout.placeholders
    msg = 'SlideLayout.placeholders not instance of _LayoutPlaceholders'
    assert isinstance(layout_placeholders, _LayoutPlaceholders), msg


@then('I can access the shape collection of the slide layout')
def then_can_access_shape_collection_of_slide_layout(context):
    slide_layout = context.slide_layout
    layout_shapes = slide_layout.shapes
    msg = 'SlideLayout.shapes not instance of _LayoutShapeTree'
    assert isinstance(layout_shapes, _LayoutShapeTree), msg


@then('I can iterate over the layout placeholders')
def then_can_iterate_over_the_layout_placeholders(context):
    layout_placeholders = context.layout_placeholders
    actual_count = 0
    for layout_placeholder in layout_placeholders:
        actual_count += 1
        assert isinstance(layout_placeholder, _LayoutPlaceholder)
    assert actual_count == 2


@then('I can iterate over the layout shapes')
def then_can_iterate_over_the_layout_shapes(context):
    layout_shapes = context.layout_shapes
    actual_count = 0
    for layout_shape in layout_shapes:
        actual_count += 1
        assert isinstance(layout_shape, BaseShape)
    assert actual_count == SHAPE_COUNT


@then('the length of the layout placeholder collection is 2')
def then_len_of_placeholder_collection_is_2(context):
    slide_layout = context.slide_layout
    layout_placeholders = slide_layout.placeholders
    assert len(layout_placeholders) == 2, (
        'expected len(layout_placeholders) of 2, got %s' %
        len(layout_placeholders)
    )


@then('the length of the layout shape collection counts all its shapes')
def then_len_of_layout_shape_collection_counts_all_its_shapes(context):
    slide_layout = context.slide_layout
    layout_shapes = slide_layout.shapes
    assert len(layout_shapes) == SHAPE_COUNT, (
        'expected len(layout_shapes) of %d, got %s' %
        (SHAPE_COUNT, len(layout_shapes))
    )

########NEW FILE########
__FILENAME__ = slidemaster
# encoding: utf-8

"""
Step implementations for slide master-related features
"""

from __future__ import absolute_import

from behave import given, then

from pptx import Presentation
from pptx.parts.slidelayout import SlideLayout
from pptx.parts.slidemaster import (
    _MasterPlaceholder, _MasterPlaceholders, _MasterShapeTree, _SlideLayouts
)
from pptx.shapes.shape import BaseShape

from .helpers import test_pptx


# given ===================================================

@given('a master placeholder collection')
def given_master_placeholder_collection(context):
    prs = Presentation(test_pptx('mst-placeholders'))
    context.master_placeholders = prs.slide_master.placeholders


@given('a master shape collection containing two shapes')
def given_master_shape_collection_containing_two_shapes(context):
    prs = Presentation(test_pptx('mst-shapes'))
    context.master_shapes = prs.slide_master.shapes


@given('a slide master having two placeholders')
def given_master_having_two_placeholders(context):
    prs = Presentation(test_pptx('mst-placeholders'))
    context.slide_master = prs.slide_master


@given('a slide master having two shapes')
def given_slide_master_having_two_shapes(context):
    prs = Presentation(test_pptx('mst-shapes'))
    context.slide_master = prs.slide_master


@given('a slide master having two slide layouts')
def given_slide_master_having_two_layouts(context):
    prs = Presentation(test_pptx('mst-slide-layouts'))
    context.slide_master = prs.slide_master


@given('a slide layout collection containing two layouts')
def given_slide_layout_collection_containing_two_layouts(context):
    prs = Presentation(test_pptx('mst-slide-layouts'))
    context.slide_layouts = prs.slide_master.slide_layouts


# then ====================================================

@then('I can access a master placeholder by index')
def then_can_access_master_placeholder_by_index(context):
    master_placeholders = context.master_placeholders
    for idx in range(2):
        master_placeholder = master_placeholders[idx]
        assert isinstance(master_placeholder, _MasterPlaceholder)


@then('I can access a master placeholder by type')
def then_can_access_master_placeholder_by_type(context):
    master_placeholders = context.master_placeholders
    title_placeholder = master_placeholders.get('title')
    body_placeholder = master_placeholders.get('body')
    assert title_placeholder._element is master_placeholders[0]._element
    assert body_placeholder._element is master_placeholders[1]._element


@then('I can access a master shape by index')
def then_can_access_master_shape_by_index(context):
    master_shapes = context.master_shapes
    for idx in range(2):
        master_shape = master_shapes[idx]
        assert isinstance(master_shape, BaseShape)


@then('I can access a slide layout by index')
def then_can_access_slide_layout_by_index(context):
    slide_layouts = context.slide_layouts
    for idx in range(2):
        slide_layout = slide_layouts[idx]
        assert isinstance(slide_layout, SlideLayout)


@then('I can access the placeholder collection of the slide master')
def then_can_access_placeholder_collection_of_slide_master(context):
    slide_master = context.slide_master
    master_placeholders = slide_master.placeholders
    msg = 'SlideMaster.placeholders not instance of _MasterPlaceholders'
    assert isinstance(master_placeholders, _MasterPlaceholders), msg


@then('I can access the shape collection of the slide master')
def then_can_access_shape_collection_of_slide_master(context):
    slide_master = context.slide_master
    master_shapes = slide_master.shapes
    msg = 'SlideMaster.shapes not instance of _MasterShapeTree'
    assert isinstance(master_shapes, _MasterShapeTree), msg


@then('I can access the slide layouts of the slide master')
def then_can_access_slide_layouts_of_slide_master(context):
    slide_master = context.slide_master
    slide_layouts = slide_master.slide_layouts
    msg = 'SlideMaster.slide_layouts not instance of _SlideLayouts'
    assert isinstance(slide_layouts, _SlideLayouts), msg


@then('I can iterate over the master placeholders')
def then_can_iterate_over_the_master_placeholders(context):
    master_placeholders = context.master_placeholders
    actual_count = 0
    for master_placeholder in master_placeholders:
        actual_count += 1
        assert isinstance(master_placeholder, _MasterPlaceholder)
    assert actual_count == 2


@then('I can iterate over the master shapes')
def then_can_iterate_over_the_master_shapes(context):
    master_shapes = context.master_shapes
    actual_count = 0
    for master_shape in master_shapes:
        actual_count += 1
        assert isinstance(master_shape, BaseShape)
    assert actual_count == 2


@then('I can iterate over the slide layouts')
def then_can_iterate_over_the_slide_layouts(context):
    slide_layouts = context.slide_layouts
    actual_count = 0
    for slide_layout in slide_layouts:
        actual_count += 1
        assert isinstance(slide_layout, SlideLayout)
    assert actual_count == 2


@then('the length of the master shape collection is 2')
def then_len_of_master_shape_collection_is_2(context):
    slide_master = context.slide_master
    master_shapes = slide_master.shapes
    assert len(master_shapes) == 2, (
        'expected len(master_shapes) of 2, got %s' % len(master_shapes)
    )


@then('the length of the master placeholder collection is 2')
def then_len_of_placeholder_collection_is_2(context):
    slide_master = context.slide_master
    master_placeholders = slide_master.placeholders
    assert len(master_placeholders) == 2, (
        'expected len(master_placeholders) of 2, got %s' %
        len(master_placeholders)
    )


@then('the length of the slide layout collection is 2')
def then_len_of_slide_layout_collection_is_2(context):
    slide_master = context.slide_master
    slide_layouts = slide_master.slide_layouts
    assert len(slide_layouts) == 2, (
        'expected len(slide_layouts) of 2, got %s' % len(slide_layouts)
    )

########NEW FILE########
__FILENAME__ = table
# encoding: utf-8

"""
Gherkin step implementations for table-related features.
"""

from __future__ import absolute_import

from behave import given, when, then
from hamcrest import assert_that, equal_to, has_item, is_

from pptx import Presentation
from pptx.dml.color import RGBColor
from pptx.enum.text import MSO_ANCHOR
from pptx.util import Inches

from .helpers import saved_pptx_path


# given ===================================================


@given('a 2x2 table')
def given_a_table(context):
    context.prs = Presentation()
    slide_layout = context.prs.slide_layouts[6]
    sld = context.prs.slides.add_slide(slide_layout)
    shapes = sld.shapes
    x, y = (Inches(1.00), Inches(2.00))
    cx, cy = (Inches(3.00), Inches(1.00))
    context.tbl = shapes.add_table(2, 2, x, y, cx, cy)
    context.shape = context.tbl


@given('a table cell')
def given_a_table_cell(context):
    context.prs = Presentation()
    slide_layout = context.prs.slide_layouts[6]
    sld = context.prs.slides.add_slide(slide_layout)
    length = 1000
    tbl = sld.shapes.add_table(2, 2, length, length, length, length)
    context.cell = tbl.cell(0, 0)


# when ====================================================


@when("I add a table to the slide's shape collection")
def when_add_table(context):
    shapes = context.sld.shapes
    x, y = (Inches(1.00), Inches(2.00))
    cx, cy = (Inches(3.00), Inches(1.00))
    shapes.add_table(2, 2, x, y, cx, cy)


@when("I set the cell fill foreground color to an RGB value")
def when_set_cell_fore_color_to_RGB_value(context):
    context.cell.fill.fore_color.rgb = RGBColor(0x23, 0x45, 0x67)


@when("I set the cell fill type to solid")
def when_set_cell_fill_type_to_solid(context):
    context.cell.fill.solid()


@when("I set the cell margins")
def when_set_cell_margins(context):
    context.cell.margin_top = 1000
    context.cell.margin_right = 2000
    context.cell.margin_bottom = 3000
    context.cell.margin_left = 4000


@when("I set the cell vertical anchor to middle")
def when_set_cell_vertical_anchor_to_middle(context):
    context.cell.vertical_anchor = MSO_ANCHOR.MIDDLE


@when("I set the first_col property to True")
def when_set_first_col_property_to_true(context):
    context.tbl.first_col = True


@when("I set the first_row property to True")
def when_set_first_row_property_to_true(context):
    context.tbl.first_row = True


@when("I set the horz_banding property to True")
def when_set_horz_banding_property_to_true(context):
    context.tbl.horz_banding = True


@when("I set the last_col property to True")
def when_set_last_col_property_to_true(context):
    context.tbl.last_col = True


@when("I set the last_row property to True")
def when_set_last_row_property_to_true(context):
    context.tbl.last_row = True


@when("I set the text of the first cell")
def when_set_text_of_first_cell(context):
    context.tbl.cell(0, 0).text = 'test text'


@when("I set the vert_banding property to True")
def when_set_vert_banding_property_to_true(context):
    context.tbl.vert_banding = True


@when("I set the width of the table's columns")
def when_set_table_column_widths(context):
    context.tbl.columns[0].width = Inches(1.50)
    context.tbl.columns[1].width = Inches(3.00)


# then ====================================================


@then('the cell contents are inset by the margins')
def then_cell_contents_are_inset_by_the_margins(context):
    prs = Presentation(saved_pptx_path)
    table = prs.slides[0].shapes[0]
    cell = table.cell(0, 0)
    assert_that(cell.margin_top, is_(equal_to(1000)))
    assert_that(cell.margin_right, is_(equal_to(2000)))
    assert_that(cell.margin_bottom, is_(equal_to(3000)))
    assert_that(cell.margin_left, is_(equal_to(4000)))


@then('the cell contents are vertically centered')
def then_cell_contents_are_vertically_centered(context):
    prs = Presentation(saved_pptx_path)
    table = prs.slides[0].shapes[0]
    cell = table.cell(0, 0)
    assert_that(cell.vertical_anchor, is_(equal_to(MSO_ANCHOR.MIDDLE)))


@then('the columns of the table have alternating shading')
def then_columns_of_table_have_alternating_shading(context):
    tbl = Presentation(saved_pptx_path).slides[0].shapes[0]
    assert_that(tbl.vert_banding, is_(True))


@then('the first column of the table has special formatting')
def then_first_column_of_table_has_special_formatting(context):
    tbl = Presentation(saved_pptx_path).slides[0].shapes[0]
    assert_that(tbl.first_col, is_(True))


@then('the first row of the table has special formatting')
def then_first_row_of_table_has_special_formatting(context):
    tbl = Presentation(saved_pptx_path).slides[0].shapes[0]
    assert_that(tbl.first_row, is_(True))


@then('the foreground color of the cell is the RGB value I set')
def then_cell_fore_color_is_RGB_value_I_set(context):
    assert context.cell.fill.fore_color.rgb == RGBColor(0x23, 0x45, 0x67)


@then('the last column of the table has special formatting')
def then_last_column_of_table_has_special_formatting(context):
    tbl = Presentation(saved_pptx_path).slides[0].shapes[0]
    assert_that(tbl.last_col, is_(True))


@then('the last row of the table has special formatting')
def then_last_row_of_table_has_special_formatting(context):
    tbl = Presentation(saved_pptx_path).slides[0].shapes[0]
    assert_that(tbl.last_row, is_(True))


@then('the rows of the table have alternating shading')
def then_rows_of_table_have_alternating_shading(context):
    tbl = Presentation(saved_pptx_path).slides[0].shapes[0]
    assert_that(tbl.horz_banding, is_(True))


@then('the table appears in the slide')
def then_table_appears_in_slide(context):
    prs = Presentation(saved_pptx_path)
    sld = prs.slides[0]
    shapes = sld.shapes
    _classnames = [sp.__class__.__name__ for sp in shapes]
    assert_that(_classnames, has_item('Table'))


@then('the table appears with the new column widths')
def then_table_appears_with_new_col_widths(context):
    prs = Presentation(saved_pptx_path)
    sld = prs.slides[0]
    tbl = sld.shapes[0]
    assert_that(tbl.columns[0].width, is_(equal_to(Inches(1.50))))
    assert_that(tbl.columns[1].width, is_(equal_to(Inches(3.00))))


@then('the text appears in the first cell of the table')
def then_text_appears_in_first_cell_of_table(context):
    prs = Presentation(saved_pptx_path)
    sld = prs.slides[0]
    tbl = sld.shapes[0]
    text = tbl.cell(0, 0).textframe.paragraphs[0].runs[0].text
    assert_that(text, is_(equal_to('test text')))

########NEW FILE########
__FILENAME__ = text
# encoding: utf-8

"""
Gherkin step implementations for text-related features.
"""

from __future__ import absolute_import

import os

from behave import given, when, then

from hamcrest import assert_that, equal_to, is_

from pptx import Presentation
from pptx.enum.text import PP_ALIGN
from pptx.util import Inches

from .helpers import saved_pptx_path, test_pptx


# given ===================================================

@given('a paragraph')
def given_a_paragraph(context):
    context.prs = Presentation()
    blank_slide_layout = context.prs.slide_layouts[6]
    slide = context.prs.slides.add_slide(blank_slide_layout)
    length = Inches(2.00)
    textbox = slide.shapes.add_textbox(length, length, length, length)
    context.p = textbox.textframe.paragraphs[0]


@given('a run with italics set {setting}')
def given_run_with_italics_set_to_setting(context, setting):
    run_idx = {'on': 0, 'off': 1, 'to None': 2}[setting]
    context.prs = Presentation(test_pptx('txt-font-props'))
    runs = context.prs.slides[0].shapes[0].textframe.paragraphs[0].runs
    context.run = runs[run_idx]


@given('a text run')
def given_a_text_run(context):
    prs = Presentation()
    blank_slide_layout = prs.slide_layouts[6]
    slide = prs.slides.add_slide(blank_slide_layout)
    textbox = slide.shapes.add_textbox(0, 0, 0, 0)
    p = textbox.textframe.paragraphs[0]
    context.r = p.add_run()


@given('a text run in a table cell')
def given_a_text_run_in_a_table_cell(context):
    prs = Presentation()
    blank_slide_layout = prs.slide_layouts[6]
    slide = prs.slides.add_slide(blank_slide_layout)
    table = slide.shapes.add_table(1, 1, 0, 0, 0, 0)
    cell = table.cell(0, 0)
    p = cell.textframe.paragraphs[0]
    context.r = p.add_run()


@given('a text run having a hyperlink')
def given_a_text_run_having_a_hyperlink(context):
    prs = Presentation()
    blank_slide_layout = prs.slide_layouts[6]
    slide = prs.slides.add_slide(blank_slide_layout)
    textbox = slide.shapes.add_textbox(0, 0, 0, 0)
    p = textbox.textframe.paragraphs[0]
    r = p.add_run()
    r.hyperlink.address = 'http://foo/bar'
    context.r = r


# when ====================================================

@when('I assign a typeface name to the font')
def when_assign_typeface_name_to_font(context):
    context.font.name = 'Verdana'


@when('I reload the presentation')
def when_reload_presentation(context):
    if os.path.isfile(saved_pptx_path):
        os.remove(saved_pptx_path)
    context.prs.save(saved_pptx_path)
    context.prs = Presentation(saved_pptx_path)


@when('I set the {side} margin to {inches}"')
def when_set_margin_to_value(context, side, inches):
    emu = Inches(float(inches))
    if side == 'left':
        context.textframe.margin_left = emu
    elif side == 'top':
        context.textframe.margin_top = emu
    elif side == 'right':
        context.textframe.margin_right = emu
    elif side == 'bottom':
        context.textframe.margin_bottom = emu


@when('I indent the paragraph')
def when_indent_first_paragraph(context):
    context.p.level = 1


@when("I set italics {setting}")
def when_set_italics_to_setting(context, setting):
    new_italics_value = {'on': True, 'off': False, 'to None': None}[setting]
    context.run.font.italic = new_italics_value


@when('I set the hyperlink address')
def when_set_hyperlink_address(context):
    context.run_text = 'python-pptx @ GitHub'
    context.address = 'https://github.com/scanny/python-pptx'

    r = context.r
    r.text = context.run_text
    hlink = r.hyperlink
    hlink.address = context.address


@when('I set the hyperlink address to None')
def when_set_hyperlink_address_to_None(context):
    context.r.hyperlink.address = None


@when("I set the paragraph alignment to centered")
def when_set_paragraph_alignment_to_centered(context):
    context.p.alignment = PP_ALIGN.CENTER


# then ====================================================

@then('the font name matches the typeface I set')
def then_font_name_matches_typeface_I_set(context):
    assert context.font.name == 'Verdana'


@then('the paragraph is aligned centered')
def then_paragraph_is_aligned_centered(context):
    p = context.prs.slides[0].shapes[0].textframe.paragraphs[0]
    assert_that(p.alignment, is_(equal_to(PP_ALIGN.CENTER)))


@then('the paragraph is indented to the second level')
def then_paragraph_indented_to_second_level(context):
    p = context.prs.slides[0].shapes[0].textframe.paragraphs[0]
    assert_that(p.level, is_(equal_to(1)))


@then("the run that had italics set {initial} now has it set {setting}")
def then_run_now_has_italics_set_to_setting(context, initial, setting):
    run_idx = {'on': 0, 'off': 1, 'to None': 2}[initial]
    run = (
        context.prs
               .slides[0]
               .shapes[0]
               .textframe
               .paragraphs[0]
               .runs[run_idx]
    )
    expected_val = {'on': True, 'off': False, 'to None': None}[setting]
    assert run.font.italic == expected_val


@then('the text of the run is a hyperlink')
def then_text_of_run_is_hyperlink(context):
    r = context.r
    hlink = r.hyperlink
    assert r.text == context.run_text
    assert hlink.address == context.address


@then('the text run is not a hyperlink')
def then_text_run_is_not_a_hyperlink(context):
    hlink = context.r.hyperlink
    assert hlink.address is None

########NEW FILE########
__FILENAME__ = textframe
# encoding: utf-8

"""
Step implementations for textframe-related features
"""

from __future__ import absolute_import

from behave import given, then, when

from pptx import Presentation
from pptx.enum.text import MSO_AUTO_SIZE
from pptx.util import Inches

from .helpers import test_pptx


# given ===================================================

@given('a textframe')
def given_a_textframe(context):
    context.prs = Presentation()
    blank_slide_layout = context.prs.slide_layouts[6]
    slide = context.prs.slides.add_slide(blank_slide_layout)
    length = Inches(2.00)
    textbox = slide.shapes.add_textbox(length, length, length, length)
    context.textframe = textbox.textframe


@given('a textframe having auto-size set to {setting}')
def given_a_textframe_having_auto_size_set_to_setting(context, setting):
    shape_idx = {
        'None':              0,
        'no auto-size':      1,
        'fit shape to text': 2,
        'fit text to shape': 3,
    }[setting]
    prs = Presentation(test_pptx('txt-textframe-props'))
    shape = prs.slides[0].shapes[shape_idx]
    context.textframe = shape.textframe


# when ====================================================

@when("I set textframe.auto_size to {setting}")
def when_set_textframe_auto_size(context, setting):
    textframe = context.textframe
    textframe.auto_size = {
        'None': None,
        'MSO_AUTO_SIZE.NONE': MSO_AUTO_SIZE.NONE,
        'MSO_AUTO_SIZE.SHAPE_TO_FIT_TEXT': MSO_AUTO_SIZE.SHAPE_TO_FIT_TEXT,
        'MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE': MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE,
    }[setting]


@when("I set the textframe word wrap {setting}")
def when_set_textframe_word_wrap(context, setting):
    bool_val = {'on': True, 'off': False, 'to None': None}
    context.textframe.word_wrap = bool_val[setting]


# then ====================================================

@then('textframe.auto_size is {value}')
def then_textframe_autosize_is_value(context, value):
    expected_value = {
        'None': None,
        'MSO_AUTO_SIZE.NONE': MSO_AUTO_SIZE.NONE,
        'MSO_AUTO_SIZE.SHAPE_TO_FIT_TEXT': MSO_AUTO_SIZE.SHAPE_TO_FIT_TEXT,
        'MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE': MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE,
    }[value]
    textframe = context.textframe
    assert textframe.auto_size == expected_value, (
        'got %s' % textframe.auto_size
    )


@then('the textframe\'s {side} margin is {inches}"')
def then_textframe_margin_is_value(context, side, inches):
    textframe = context.prs.slides[0].shapes[0].textframe
    emu = Inches(float(inches))
    if side == 'left':
        assert textframe.margin_left == emu
    elif side == 'top':
        assert textframe.margin_top == emu
    elif side == 'right':
        assert textframe.margin_right == emu
    elif side == 'bottom':
        assert textframe.margin_bottom == emu


@then('the textframe word wrap is set {setting}')
def then_textframe_word_wrap_is_setting(context, setting):
    expected_value = {
        'on': True, 'off': False, 'to None': None
    }[setting]
    textframe = context.prs.slides[0].shapes[0].textframe
    assert textframe.word_wrap is expected_value

########NEW FILE########
__FILENAME__ = gen_oxml_classes
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# gen_oxml_classes.py
#

"""
Generate class definitions for Open XML elements based on set of declarative
properties.
"""

import sys
from string import Template

class ElementDef(object):
    """
    Schema-related definition of an Open XML element
    """
    instances = []

    def __init__(self, tag, classname):
        self.instances.append(self)
        self.tag = tag
        tagparts = tag.split(':')
        self.nsprefix = tagparts[0]
        self.tagname = tagparts[1]
        self.classname = classname
        self.children = []
        self.attributes = []

    def __getitem__(self, key):
        return self.__getattribute__(key)

    def add_child(self, tag, cardinality='?'):
        self.children.append(ChildDef(self, tag, cardinality))

    def add_attribute(self, name, required=False, default=None):
        self.attributes.append(AttributeDef(self, name, required, default))

    def add_attributes(self, *names):
        for name in names:
            self.attributes.append(AttributeDef(self, name, False, None))

    @property
    def indent(self):
        indent_len = 12 - len(self.tagname)
        if indent_len < 0:
            indent_len = 0
        return ' ' * indent_len

    @property
    def max_attr_name_len(self):
        return max([len(attr.name) for attr in self.attributes])

    @property
    def max_child_tagname_len(self):
        return max([len(child.tagname) for child in self.children])

    @property
    def optional_children(self):
        return [child for child in self.children if not child.is_required]

    @property
    def required_attributes(self):
        return [attr for attr in self.attributes if attr.is_required]

    @property
    def required_children(self):
        return [child for child in self.children if child.is_required]


class AttributeDef(object):
    """
    Attribute definition
    """
    def __init__(self, element, name, required, default):
        self.element = element
        self.name = name
        self.required = required
        self.default = default
        self.varname = name.replace(':', '_')

    def __getitem__(self, key):
        return self.__getattribute__(key)

    @property
    def padding(self):
        return ' ' * (self.element.max_attr_name_len - len(self.name))

    @property
    def indent(self):
        return ' ' * self.element.max_attr_name_len

    @property
    def is_required(self):
        return self.required


class ChildDef(object):
    """
    Child element definition
    """
    def __init__(self, element, tag, cardinality):
        self.element = element
        self.tag = tag
        self.cardinality = cardinality
        if not ':' in tag:
            tmpl = "missing namespace prefix in tag: '%s'"
            raise ValueError(tmpl % tag)
        tagparts = tag.split(':')
        self.nsprefix = tagparts[0]
        self.tagname = tagparts[1]

    def __getitem__(self, key):
        return self.__getattribute__(key)

    @property
    def indent(self):
        indent_len = self.element.max_child_tagname_len - len(self.tagname)
        return ' ' * indent_len

    @property
    def is_required(self):
        return self.cardinality in '1+'


# ============================================================================
# Code templates
# ============================================================================

class tmpl(object):
    attr_accessor = Template("    $varname$padding = property(lambda self: se"
        "lf.get('$name'),\n$indent                lambda self, value: self.se"
        "t('$name', value))\n")

    class_def_head = Template('''class $classname(ElementBase):\n    """<$n'''
        '''sprefix:$tagname> custom element class"""\n''')

    class_mapping = Template("        , '$tagname'$indent : $classname\n\n")

    ns_attr_accessor = Template(
        "    $varname$padding = property(lambda self: self.get(_qtag('$name')"
        "),\n$indent                lambda self, value: self.set(_qtag('$name"
        "'), value))\n")

    ns_reqd_attribute_constructor = Template("        _required_attribute(sel"
        "f, _qtag('$name'), default='$default')\n")

    optional_child_accessor = Template("    $tagname$indent = property(lambda"
        " self: _get_child_or_append(self, '$tag'))\n")

    reqd_attr_constructor = Template("        _required_attribute(self, '$nam"
        "e', default='$default')\n")

    reqd_child_accessor = Template("    $tagname$indent = property(lambda sel"
        "f: _child(self, '$tag'))\n")

    reqd_child_constructor = Template("        _required_child(self, '$tag')"
        "\n")


# ============================================================================
# binding specs
# ============================================================================

# sldMaster = ElementDef('p:sldMaster', 'CT_SlideMaster')
# sldMaster.add_child('p:cSld'          , cardinality='1')
# sldMaster.add_child('p:clrMap'        , cardinality='1')
# sldMaster.add_child('p:sldLayoutIdLst', cardinality='?')
# sldMaster.add_child('p:transition'    , cardinality='?')
# sldMaster.add_child('p:timing'        , cardinality='?')
# sldMaster.add_child('p:hf'            , cardinality='?')
# sldMaster.add_child('p:txStyles'      , cardinality='?')
# sldMaster.add_child('p:extLst'        , cardinality='?')
# sldMaster.add_attributes('preserve')



def class_template(element):
    out = ''
    out += tmpl.class_mapping.substitute(element)
    out += tmpl.class_def_head.substitute(element)
    if element.required_children or element.required_attributes:
        out += '    def _init(self):\n'
        for child in element.required_children:
            out += tmpl.reqd_child_constructor.substitute(child)
        for attribute in element.required_attributes:
            if ':' in attribute.name:
                out += tmpl.ns_reqd_attr_constructor.substitute(attribute)
            else:
                out += tmpl.reqd_attr_constructor.substitute(attribute)
        out += '\n'
    if element.children:
        out += '    # child accessors -----------------\n'
        for child in element.required_children:
            out += tmpl.reqd_child_accessor.substitute(child)
        for child in element.optional_children:
            out += tmpl.optional_child_accessor.substitute(child)
        out += '\n'
    if element.attributes:
        out += '    # attribute accessors -------------\n'
        for attribute in element.attributes:
            if ':' in attribute.name:
                out += tmpl.ns_attr_accessor.substitute(attribute)
            else:
                out += tmpl.attr_accessor.substitute(attribute)
        out += '\n'
    out += '\n'
    return out



elements = ElementDef.instances

out = '\n'
for element in elements:
    out += class_template(element)

print out

sys.exit()


# ============================================================================
# Element definitions
# ============================================================================

# blip = ElementDef('a:blip', 'CT_Blip')
# blip.add_child('a:alphaBiLevel' , cardinality='?')
# blip.add_child('a:alphaCeiling' , cardinality='?')
# blip.add_child('a:alphaFloor'   , cardinality='?')
# blip.add_child('a:alphaInv'     , cardinality='?')
# blip.add_child('a:alphaMod'     , cardinality='?')
# blip.add_child('a:alphaModFix'  , cardinality='?')
# blip.add_child('a:alphaRepl'    , cardinality='?')
# blip.add_child('a:biLevel'      , cardinality='?')
# blip.add_child('a:blur'         , cardinality='?')
# blip.add_child('a:clrChange'    , cardinality='?')
# blip.add_child('a:clrRepl'      , cardinality='?')
# blip.add_child('a:duotone'      , cardinality='?')
# blip.add_child('a:fillOverlay'  , cardinality='?')
# blip.add_child('a:grayscl'      , cardinality='?')
# blip.add_child('a:hsl'          , cardinality='?')
# blip.add_child('a:lum'          , cardinality='?')
# blip.add_child('a:tint'         , cardinality='?')
# blip.add_child('a:extLst'       , cardinality='?')
# blip.add_attributes('r_embed', 'r_link', 'cstate')

# blipFill = ElementDef('p:blipFill', 'CT_BlipFillProperties')
# blipFill.add_child('a:blip'    , cardinality='?')
# blipFill.add_child('a:srcRect' , cardinality='?')
# blipFill.add_child('a:tile'    , cardinality='?')
# blipFill.add_child('a:stretch' , cardinality='?')
# blipFill.add_attributes('dpi', 'rotWithShape')

# bodyPr = ElementDef('a:bodyPr', 'CT_TextBodyProperties')
# bodyPr.add_child('a:spAutoFit', cardinality='?')
# bodyPr.add_attribute('wrap')
# bodyPr.add_attribute('rtlCol')
# bodyPr.add_attribute('anchor')
# bodyPr.add_attribute('anchorCtr')

# cNvPr = ElementDef('p:cNvPr', 'CT_NonVisualDrawingProps')
# cNvPr.add_child('a:hlinkClick' , cardinality='?')
# cNvPr.add_child('a:hlinkHover' , cardinality='?')
# cNvPr.add_child('a:extLst'     , cardinality='?')
# cNvPr.add_attribute('id', required=True, default='0')
# cNvPr.add_attribute('name', required=True, default='Unnamed')
# cNvPr.add_attributes('descr', 'hidden', 'title')

# cNvSpPr = ElementDef('p:cNvSpPr', 'CT_NonVisualDrawingShapeProps')
# cNvSpPr.add_child('a:spLocks', cardinality='?')
# cNvSpPr.add_child('a:extLst' , cardinality='?')
# cNvSpPr.add_attributes('txBox')

# cSld = ElementDef('p:cSld', 'CT_CommonSlideData')
# cSld.add_child('p:bg'         , cardinality='?')
# cSld.add_child('p:spTree'     , cardinality='1')
# cSld.add_child('p:custDataLst', cardinality='?')
# cSld.add_child('p:controls'   , cardinality='?')
# cSld.add_child('p:extLst'     , cardinality='?')
# cSld.add_attributes('name')

# defRPr = ElementDef('a:defRPr', 'CT_TextCharacterProperties')
# defRPr.add_child('a:ln'            , cardinality='?')
# defRPr.add_child('a:noFill'        , cardinality='?')
# defRPr.add_child('a:solidFill'     , cardinality='?')
# defRPr.add_child('a:gradFill'      , cardinality='?')
# defRPr.add_child('a:blipFill'      , cardinality='?')
# defRPr.add_child('a:pattFill'      , cardinality='?')
# defRPr.add_child('a:grpFill'       , cardinality='?')
# defRPr.add_child('a:effectLst'     , cardinality='?')
# defRPr.add_child('a:effectDag'     , cardinality='?')
# defRPr.add_child('a:highlight'     , cardinality='?')
# defRPr.add_child('a:uLnTx'         , cardinality='?')
# defRPr.add_child('a:uLn'           , cardinality='?')
# defRPr.add_child('a:uFillTx'       , cardinality='?')
# defRPr.add_child('a:uFill'         , cardinality='?')
# defRPr.add_child('a:latin'         , cardinality='?')
# defRPr.add_child('a:ea'            , cardinality='?')
# defRPr.add_child('a:cs'            , cardinality='?')
# defRPr.add_child('a:sym'           , cardinality='?')
# defRPr.add_child('a:hlinkClick'    , cardinality='?')
# defRPr.add_child('a:hlinkMouseOver', cardinality='?')
# defRPr.add_child('a:rtl'           , cardinality='?')
# defRPr.add_child('a:extLst'        , cardinality='?')
# defRPr.add_attributes('kumimoji', 'lang', 'altLang', 'sz', 'b', 'i', 'u',
#     'strike', 'kern', 'cap', 'spc', 'normalizeH', 'baseline', 'noProof',
#     'dirty', 'err', 'smtClean', 'smtId', 'bmk')

# nvGrpSpPr = ElementDef('p:nvGrpSpPr', 'CT_GroupShapeNonVisual')
# nvGrpSpPr.add_child('p:cNvPr'     , cardinality='1')
# nvGrpSpPr.add_child('p:cNvGrpSpPr', cardinality='1')
# nvGrpSpPr.add_child('p:nvPr'      , cardinality='1')

# nvPicPr = ElementDef('p:nvPicPr', 'CT_PictureNonVisual')
# nvPicPr.add_child('p:cNvPr'    , cardinality='1')
# nvPicPr.add_child('p:cNvPicPr' , cardinality='1')
# nvPicPr.add_child('p:nvPr'     , cardinality='1')

# nvPr = ElementDef('p:nvPr', 'CT_ApplicationNonVisualDrawingProps')
# nvPr.add_child('p:ph'           , cardinality='?')
# nvPr.add_child('p:audioCd'      , cardinality='?')
# nvPr.add_child('p:wavAudioFile' , cardinality='?')
# nvPr.add_child('p:audioFile'    , cardinality='?')
# nvPr.add_child('p:videoFile'    , cardinality='?')
# nvPr.add_child('p:quickTimeFile', cardinality='?')
# nvPr.add_child('p:custDataLst'  , cardinality='?')
# nvPr.add_child('p:extLst'       , cardinality='?')
# nvPr.add_attributes('isPhoto', 'userDrawn')

# nvSpPr = ElementDef('p:nvSpPr', 'CT_ShapeNonVisual')
# nvSpPr.add_child('p:cNvPr'  , cardinality='1')
# nvSpPr.add_child('p:cNvSpPr', cardinality='1')
# nvSpPr.add_child('p:nvPr'   , cardinality='1')

# off = ElementDef('a:off', 'CT_Point2D')
# off.add_attribute('x', required=True, default='0')
# off.add_attribute('y', required=True, default='0')

# p = ElementDef('a:p', 'CT_TextParagraph')
# p.add_child('a:pPr' , cardinality='?')
# p.add_child('a:r'   , cardinality='*')
# p.add_child('a:br'  , cardinality='*')
# p.add_child('a:fld' , cardinality='*')
# p.add_child('a:endParaRPr', cardinality='?')

# ph = ElementDef('p:ph', 'CT_Placeholder')
# ph.add_child('p:extLst', cardinality='?')
# ph.add_attributes('type', 'orient', 'sz', 'idx', 'hasCustomPrompt')

# pic = ElementDef('p:pic', 'CT_Picture')
# pic.add_child('p:nvPicPr'  , cardinality='1')
# pic.add_child('p:blipFill' , cardinality='1')
# pic.add_child('p:spPr'     , cardinality='1')
# pic.add_child('p:style'    , cardinality='?')
# pic.add_child('p:extLst'   , cardinality='?')

# pPr = ElementDef('a:pPr', 'CT_TextParagraphProperties')
# pPr.add_child('a:lnSpc'    , cardinality='?')
# pPr.add_child('a:spcBef'   , cardinality='?')
# pPr.add_child('a:spcAft'   , cardinality='?')
# pPr.add_child('a:buClrTx'  , cardinality='?')
# pPr.add_child('a:buClr'    , cardinality='?')
# pPr.add_child('a:buSzTx'   , cardinality='?')
# pPr.add_child('a:buSzPct'  , cardinality='?')
# pPr.add_child('a:buSzPts'  , cardinality='?')
# pPr.add_child('a:buFontTx' , cardinality='?')
# pPr.add_child('a:buFont'   , cardinality='?')
# pPr.add_child('a:buNone'   , cardinality='?')
# pPr.add_child('a:buAutoNum', cardinality='?')
# pPr.add_child('a:buChar'   , cardinality='?')
# pPr.add_child('a:buBlip'   , cardinality='?')
# pPr.add_child('a:tabLst'   , cardinality='?')
# pPr.add_child('a:defRPr'   , cardinality='?')
# pPr.add_child('a:extLst'   , cardinality='?')
# pPr.add_attributes('marL', 'marR', 'lvl', 'indent', 'algn', 'defTabSz',
#     'rtl', 'eaLnBrk', 'fontAlgn', 'latinLnBrk', 'hangingPunct')

# presentation = ElementDef('p:presentation', 'CT_Presentation')
# presentation.add_child('p:sldMasterIdLst'    , cardinality='?')
# presentation.add_child('p:notesMasterIdLst'  , cardinality='?')
# presentation.add_child('p:handoutMasterIdLst', cardinality='?')
# presentation.add_child('p:sldIdLst'          , cardinality='?')
# presentation.add_child('p:sldSz'             , cardinality='?')
# presentation.add_child('p:notesSz'           , cardinality='1')
# presentation.add_child('p:smartTags'         , cardinality='?')
# presentation.add_child('p:embeddedFontLst'   , cardinality='?')
# presentation.add_child('p:custShowLst'       , cardinality='?')
# presentation.add_child('p:photoAlbum'        , cardinality='?')
# presentation.add_child('p:custDataLst'       , cardinality='?')
# presentation.add_child('p:kinsoku'           , cardinality='?')
# presentation.add_child('p:defaultTextStyle'  , cardinality='?')
# presentation.add_child('p:modifyVerifier'    , cardinality='?')
# presentation.add_child('p:extLst'            , cardinality='?')
# presentation.add_attributes('serverZoom', 'firstSlideNum',
#     'showSpecialPlsOnTitleSld', 'rtl', 'removePersonalInfoOnSave',
#     'compatMode', 'strictFirstAndLastChars', 'embedTrueTypeFonts',
#     'saveSubsetFonts', 'autoCompressPictures', 'bookmarkIdSeed',
#     'conformance')

# rPr = ElementDef('a:rPr', 'CT_TextCharacterProperties')
# rPr.add_child('a:ln', cardinality='?')
# rPr.add_attribute('sz')
# rPr.add_attribute('b')
# rPr.add_attribute('i')
# rPr.add_attribute('u')
# rPr.add_attribute('strike')
# rPr.add_attribute('kern')
# rPr.add_attribute('cap')
# rPr.add_attribute('spc')
# rPr.add_attribute('baseline')

# sld = ElementDef('p:sld', 'CT_Slide')
# sld.add_child('p:cSld'       , cardinality='1')
# sld.add_child('p:clrMapOvr'  , cardinality='?')
# sld.add_child('p:transition' , cardinality='?')
# sld.add_child('p:timing'     , cardinality='?')
# sld.add_child('p:extLst'     , cardinality='?')
# sld.add_attributes('showMasterSp', 'showMasterPhAnim', 'show')

# sldId = ElementDef('p:sldId', 'CT_SlideIdListEntry')
# sldId.add_child('p:extLst', cardinality='?')
# sldId.add_attribute('id', required=True, default='')
# sldId.add_attribute('r:id', required=True, default='')

# sldIdLst = ElementDef('p:sldIdLst', 'CT_SlideIdList')
# sldIdLst.add_child('p:sldId', cardinality='*')

# sldLayout = ElementDef('p:sldLayout', 'CT_SlideLayout')
# sldLayout.add_child('p:cSld'      , cardinality='1')
# sldLayout.add_child('p:clrMapOvr' , cardinality='?')
# sldLayout.add_child('p:transition', cardinality='?')
# sldLayout.add_child('p:timing'    , cardinality='?')
# sldLayout.add_child('p:hf'        , cardinality='?')
# sldLayout.add_child('p:extLst'    , cardinality='?')
# sldLayout.add_attributes('showMasterSp', 'showMasterPhAnim', 'matchingName', 'type', 'preserve', 'userDrawn')

# spLocks = ElementDef('a:spLocks', 'CT_ShapeLocking')
# spLocks.add_child('a:extLst', cardinality='?')
# spLocks.add_attributes('noGrp', 'noSelect', 'noRot', 'noChangeAspect',
#     'noMove', 'noResize', 'noEditPoints', 'noAdjustHandles',
#     'noChangeArrowheads', 'noChangeShapeType', 'noTextEdit')

# spPr = ElementDef('p:spPr', 'CT_ShapeProperties')
# spPr.add_child('a:xfrm'      , cardinality='?')
# spPr.add_child('a:custGeom'  , cardinality='?')
# spPr.add_child('a:prstGeom'  , cardinality='?')
# spPr.add_child('a:noFill'    , cardinality='?')
# spPr.add_child('a:solidFill' , cardinality='?')
# spPr.add_child('a:gradFill'  , cardinality='?')
# spPr.add_child('a:blipFill'  , cardinality='?')
# spPr.add_child('a:pattFill'  , cardinality='?')
# spPr.add_child('a:grpFill'   , cardinality='?')
# spPr.add_child('a:ln'        , cardinality='?')
# spPr.add_child('a:effectLst' , cardinality='?')
# spPr.add_child('a:effectDag' , cardinality='?')
# spPr.add_child('a:scene3d'   , cardinality='?')
# spPr.add_child('a:sp3d'      , cardinality='?')
# spPr.add_child('a:extLst'    , cardinality='?')
# spPr.add_attribute('bwMode')

# spTree = ElementDef('p:spTree', 'CT_GroupShape')
# spTree.add_child('p:nvGrpSpPr'   , cardinality='1')
# spTree.add_child('p:grpSpPr'     , cardinality='1')
# spTree.add_child('p:sp'          , cardinality='?')
# spTree.add_child('p:grpSp'       , cardinality='?')
# spTree.add_child('p:graphicFrame', cardinality='?')
# spTree.add_child('p:cxnSp'       , cardinality='?')
# spTree.add_child('p:pic'         , cardinality='?')
# spTree.add_child('p:contentPart' , cardinality='?')
# spTree.add_child('p:extLst'      , cardinality='?')

# stretch = ElementDef('a:stretch', 'CT_StretchInfoProperties')
# stretch.add_child('a:fillRect' , cardinality='?')

# txBody = ElementDef('p:txBody', 'CT_TextBody')
# txBody.add_child('a:bodyPr'   , cardinality='1')
# txBody.add_child('a:lstStyle' , cardinality='?')
# txBody.add_child('a:p'        , cardinality='+')


########NEW FILE########
__FILENAME__ = main
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# lxml Custom Element Classes
#

"""
Experimental code to explore lxml custom Element classes
"""

import sys

from lxml import etree

nsmap =\
    { 'a': 'http://schemas.openxmlformats.org/drawingml/2006/main'
    , 'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
    , 'p': 'http://schemas.openxmlformats.org/presentationml/2006/main'
    }

etree.register_namespace('a', nsmap['a'])
etree.register_namespace('p', nsmap['p'])

def _Element(tag, nsmap=None):
    if nsmap:
        element = parser.makeelement(_qtag(tag), nsmap=nsmap)
    else:
        element = parser.makeelement(_qtag(tag))
    return element

def _child(element, child_tagname):
    """
    Return direct child of *element* having *child_tagname* or :class:`None`
    if no such child element is present.
    """
    xpath = './%s' % child_tagname
    matching_children = element.xpath(xpath, namespaces=nsmap)
    return matching_children[0] if len(matching_children) else None

def _child_list(element, child_tagname):
    """
    Return list containing the direct children of *element* having
    *child_tagname*.
    """
    xpath = './%s' % child_tagname
    return element.xpath(xpath, namespaces=nsmap)

def _get_child_or_append(element, tag):
    child = _child(element, tag)
    if child is None:
        child = _Element(tag)
        element.append(child)
    return child

def _get_child_or_first(element, tag):
    child = _child(element, tag)
    if child is None:
        child = _Element(tag)
        element.insert(0, child)
    return child

def _get_child_or_insert(element, tag, idx):
    child = _child(element, tag)
    if child is None:
        child = _Element(tag)
        element.insert(idx, child)
    return child

def _nsmap(*prefixes):
    """
    Return a dict containing the subset namespace prefix mappings specified by
    *prefixes*. Any number of namespace prefixes can be supplied, e.g.
    namespaces('a', 'r', 'p').
    """
    namespaces = {}
    for prefix in prefixes:
        namespaces[prefix] = nsmap[prefix]
    return namespaces

def _qtag(tag):
    prefix, tagroot = tag.split(':')
    uri = nsmap[prefix]
    return '{%s}%s' % (uri, tagroot)

def _required_attribute(element, name, default):
    """
    Add attribute with default value to element if it doesn't already exist.
    """
    if element.get(name) is None:
        element.set(name, default)

def _required_child(parent, tag):
    """
    Add child element with *tag* to *parent* if it doesn't already exist.
    """
    if _child(parent, tag) is None:
        parent.append(_Element(tag))


# ============================================================================
# Custom element classes
# ============================================================================

class ElementBase(etree.ElementBase):
    """Provides the base element interface for custom element classes"""
    pass

class CT_NonVisualDrawingProps(ElementBase):
    """<p:cNvPr>"""
    # attributes ----------------------
    id   = property(lambda self: self.get('id'),
                    lambda self, value: self.set('id', str(value)))
    name = property(lambda self: self.get('name'),
                    lambda self, value: self.set('name', value))


class CT_NonVisualDrawingShapeProps(ElementBase):
    """<p:cNvSpPr>"""
    # attributes ----------------------
    txBox = property(lambda self: self.get('txBox'),
                     lambda self, value: self.set('txBox', value))


class CT_Point2D(ElementBase):
    """<a:off>"""
    def _init(self):
        _required_attribute(self, 'x', default='0')
        _required_attribute(self, 'y', default='0')

    # attribute accessors -------------
    x = property(lambda self: self.get('x'),
                 lambda self, value: self.set('x', value))
    y = property(lambda self: self.get('y'),
                 lambda self, value: self.set('y', value))


class CT_PositiveSize2D(ElementBase):
    """<a:ext>"""
    def _init(self):
        _required_attribute(self, 'cx', default='0')
        _required_attribute(self, 'cy', default='0')

    # attribute accessors -------------
    cx = property(lambda self: self.get('cx'),
                  lambda self, value: self.set('cx', value))
    cy = property(lambda self: self.get('cy'),
                  lambda self, value: self.set('cy', value))


class CT_PresetGeometry2D(ElementBase):
    """<a:prstGeom>"""
    # attributes ----------------------
    prst = property(lambda self: self.get('prst'),
                    lambda self, value: self.set('prst', value))
    # child accessors -----------------
    avLst = property(lambda self: _get_child_or_append(self, 'a:avLst'))


class CT_RegularTextRun(ElementBase):
    """<a:r> custom element class"""
    def _init(self):
        _required_child(self, 'a:t')

    # child accessors -----------------
    t   = property(lambda self: _child(self, 'a:t'))
    rPr = property(lambda self: _get_child_or_first(self, 'a:rPr'))


class CT_Shape(ElementBase):
    """<p:sp> Custom element class"""
    def _init(self):
        _required_child(self, 'p:nvSpPr')
        _required_child(self, 'p:spPr')

    # children ------------------------
    nvSpPr = property(lambda self: _child(self, 'p:nvSpPr'))
    spPr   = property(lambda self: _child(self, 'p:spPr'))
    txBody = property(lambda self: _get_child_or_append(self, 'p:txBody'))

    # convenience accessors
    id   = property(lambda self: self.nvSpPr.cNvPr.id)
    name = property(lambda self: self.nvSpPr.cNvPr.name)


class CT_ShapeNonVisual(ElementBase):
    """<p:nvSpPr>"""
    def _init(self):
        _required_child(self, 'p:cNvPr')
        _required_child(self, 'p:cNvSpPr')
        _required_child(self, 'p:nvPr')

    # child accessors -----------------
    cNvPr   = property(lambda self: _child(self, 'p:cNvPr'))
    cNvSpPr = property(lambda self: _child(self, 'p:cNvSpPr'))


class CT_ShapeProperties(ElementBase):
    """<p:spPr>"""
    # child accessors -----------------
    xfrm     = property(lambda self: _get_child_or_append(self, 'a:xfrm'))
    prstGeom = property(lambda self: _get_child_or_append(self, 'a:prstGeom'))
    noFill   = property(lambda self: _get_child_or_append(self, 'a:noFill'))


class CT_TextBody(ElementBase):
    """<p:txBody> custom element class"""
    def _init(self):
        _required_child(self, 'p:bodyPr')
        _required_child(self, 'a:p')

    # child accessors -----------------
    bodyPr   = property(lambda self: _child(self, 'p:bodyPr'))
    p        = property(lambda self: _child_list(self, 'a:p'))
    lstStyle = property(lambda self: _get_child_or_insert(self, 'a:lstStyle', 1))


class CT_TextBodyProperties(ElementBase):
    """<a:bodyPr> custom element class"""
    # child accessors -----------------
    spAutoFit = property(lambda self: _get_child_or_append(self, 'a:spAutoFit'))

    # attribute accessors -------------
    wrap      = property(lambda self: self.get('wrap'),
                         lambda self, value: self.set('wrap', value))
    rtlCol    = property(lambda self: self.get('rtlCol'),
                         lambda self, value: self.set('rtlCol', value))
    anchor    = property(lambda self: self.get('anchor'),
                         lambda self, value: self.set('anchor', value))
    anchorCtr = property(lambda self: self.get('anchorCtr'),
                         lambda self, value: self.set('anchorCtr', value))


class CT_TextCharacterProperties(ElementBase):
    """<a:rPr> custom element class"""
    # child accessors -----------------
    ln = property(lambda self: _get_child_or_append(self, 'a:ln'))

    # attribute accessors -------------
    sz       = property(lambda self: self.get('sz'),
                        lambda self, value: self.set('sz', value))
    b        = property(lambda self: self.get('b'),
                        lambda self, value: self.set('b', value))
    i        = property(lambda self: self.get('i'),
                        lambda self, value: self.set('i', value))
    u        = property(lambda self: self.get('u'),
                        lambda self, value: self.set('u', value))
    strike   = property(lambda self: self.get('strike'),
                        lambda self, value: self.set('strike', value))
    kern     = property(lambda self: self.get('kern'),
                        lambda self, value: self.set('kern', value))
    cap      = property(lambda self: self.get('cap'),
                        lambda self, value: self.set('cap', value))
    spc      = property(lambda self: self.get('spc'),
                        lambda self, value: self.set('spc', value))
    baseline = property(lambda self: self.get('baseline'),
                        lambda self, value: self.set('baseline', value))


class CT_TextParagraph(ElementBase):
    """<a:p> custom element class"""
    # child accessors -----------------
    pPr        = property(lambda self: _get_child_or_append(self, 'a:pPr'))
    r          = property(lambda self: _get_child_or_append(self, 'a:r'))
    br         = property(lambda self: _get_child_or_append(self, 'a:br'))
    fld        = property(lambda self: _get_child_or_append(self, 'a:fld'))
    endParaRPr = property(lambda self: _get_child_or_append(self, 'a:endParaRPr'))


class CT_Transform2D(ElementBase):
    """<a:xfrm>"""
    # child accessors -----------------
    off = property(lambda self: _get_child_or_append(self, 'a:off'))
    ext = property(lambda self: _get_child_or_append(self, 'a:ext'))


class ElementClassLookup(etree.CustomElementClassLookup):
    cls_map =\
        { 'bodyPr'   : CT_TextBodyProperties
        , 'cNvPr'    : CT_NonVisualDrawingProps
        , 'cNvSpPr'  : CT_NonVisualDrawingShapeProps
        , 'ext'      : CT_PositiveSize2D
        , 'nvSpPr'   : CT_ShapeNonVisual
        , 'off'      : CT_Point2D
        , 'p'        : CT_TextParagraph
        , 'prstGeom' : CT_PresetGeometry2D
        , 'r'        : CT_RegularTextRun
        , 'rPr'      : CT_TextCharacterProperties
        , 'sp'       : CT_Shape
        , 'spPr'     : CT_ShapeProperties
        , 'txBody'   : CT_TextBody
        , 'xfrm'     : CT_Transform2D
        }

    def lookup(self, node_type, document, namespace, name):
        if name in self.cls_map:
            return self.cls_map[name]
        return None


parser = etree.XMLParser()
parser.set_element_class_lookup(ElementClassLookup())


# ============================================================================
# construct from scratch
# ============================================================================

sp = _Element('p:sp', nsmap=_nsmap('p', 'a'))
sp.nvSpPr.cNvPr.id = 7
sp.nvSpPr.cNvPr.name = 'TextBox 6'
sp.nvSpPr.cNvSpPr.txBox = '1'

sp.spPr.xfrm.off.x  = '5580112'
sp.spPr.xfrm.off.y  = '2924944'
sp.spPr.xfrm.ext.cx = '1005403'
sp.spPr.xfrm.ext.cy =  '369332'

sp.spPr.prstGeom.prst = 'rect'
sp.spPr.prstGeom.avLst

sp.spPr.noFill

sp.txBody
sp.txBody.bodyPr.wrap = 'none'
sp.txBody.bodyPr.rtlCol = '0'
sp.txBody.bodyPr.spAutoFit

sp.txBody.lstStyle

sp.txBody.p[0].r.rPr.sz = "2400"
sp.txBody.p[0].r.rPr.b  = "1"
sp.txBody.p[0].r.t.text = "Test text"


# print XML
print "\n%s" % etree.tostring(sp, pretty_print=True)

sys.exit()


# ============================================================================
# parse from XML string
# ============================================================================

xml = """\
<p:sp xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main">
  <p:nvSpPr>
    <p:cNvPr id="7" name="TextBox 6"/>
    <p:cNvSpPr txBox="1"/>
    <p:nvPr/>
  </p:nvSpPr>
</p:sp>
"""

# <p:sp xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"
# xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
# xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main">

#   <p:spPr>
#     <a:xfrm>
#       <a:off x="5580112" y="2924944"/>
#       <a:ext cx="1005403" cy="369332"/>
#     </a:xfrm>
#     <a:prstGeom prst="rect">
#       <a:avLst/>
#     </a:prstGeom>
#     <a:noFill/>
#   </p:spPr>
#   <p:txBody>
#     <a:bodyPr wrap="none" rtlCol="0">
#       <a:spAutoFit/>
#     </a:bodyPr>
#     <a:lstStyle/>
#     <a:p>
#       <a:r>
#         <a:rPr lang="en-US" dirty="0" smtClean="0"/>
#         <a:t>Test text</a:t>
#       </a:r>
#     </a:p>
#   </p:txBody>


sp = etree.XML(xml, parser)

# print "repr(sp) => %r" % sp
# print "type(sp) => %s" % type(sp)
print "sp.id    => %s" % sp.id
print "sp.name  => %s" % sp.name
print "len(sp)  => %d" % len(sp)
print
print "sp.nvSpPr => %s" % type(sp.nvSpPr)
print "sp.nvSpPr.cNvPr.id => %s" % sp.nvSpPr.cNvPr.id
print "sp.nvSpPr.cNvPr.name => %s" % sp.nvSpPr.cNvPr.name
sp.nvSpPr.cNvPr.name = 'New Name 99'
print "sp.nvSpPr.cNvPr.name => %s" % sp.nvSpPr.cNvPr.name
print
print "________\n\n%s" % etree.tostring(sp)

sys.exit()


# ============================================================================
# Direct use of inheriting class
# ============================================================================

sp = CT_Shape()

print sp
print sp.id
print len(sp)
print etree.tostring(sp)



########NEW FILE########
__FILENAME__ = objectify_lab
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# objectify_lab.py
#

"""
Experimental code to trial lxml.objectify as possible replacement for most
oxml custom element classes.
"""

from lxml import etree
from lxml import objectify
from lxml.objectify import Element, SubElement

# ============================================================================
# utility items
# ============================================================================

nsmap =\
    { 'a': 'http://schemas.openxmlformats.org/drawingml/2006/main'
    , 'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
    , 'p': 'http://schemas.openxmlformats.org/presentationml/2006/main'
    }

def nsdecls(*prefixes):
    return ' '.join(['xmlns:%s="%s"' % (pfx, nsmap[pfx]) for pfx in prefixes])

def pfxdtag(tag):
    """
    Return short-form prefixed tag from fully qualified (Clark notation)
    tagname.
    """
    uri, tagroot = tag[1:].split('}')
    prefix = reverse_nsmap[uri]
    return '%s:%s' % (prefix, tagroot)

def qn(tag):
    """
    qn is short for *qualified name*. Return fully qualified (Clark notation)
    tagname corresponding to short-form prefixed tagname *tag*.
    """
    prefix, tagroot = tag.split(':')
    uri = nsmap[prefix]
    return '{%s}%s' % (uri, tagroot)

def new(tag, **extra):
    return Element(qn(tag), **extra)

def sub_elm(parent, tag, **extra):
    return SubElement(parent, qn(tag), **extra)

# ============================================================================
# generate XML for Table shape
# ============================================================================

def empty_cell():
    tc = new('a:tc')
    tc.txBody = new('a:txBody')
    tc.txBody.bodyPr = new('a:bodyPr')
    tc.txBody.lstStyle = new('a:lstStyle')
    tc.txBody.p = new('a:p')
    tc.tcPr = new('a:tcPr')
    return tc


graphicFrame_tmpl = """
    <p:graphicFrame %s>
      <p:nvGraphicFramePr>
        <p:cNvPr id="%s" name="%s"/>
        <p:cNvGraphicFramePr>
          <a:graphicFrameLocks noGrp="1"/>
        </p:cNvGraphicFramePr>
        <p:nvPr/>
      </p:nvGraphicFramePr>
      <p:xfrm>
        <a:off x="%s" y="%s"/>
        <a:ext cx="%s" cy="%s"/>
      </p:xfrm>
      <a:graphic>
        <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/table">
          <a:tbl>
            <a:tblPr firstRow="1" bandRow="1">
              <a:tableStyleId>{5C22544A-7EE6-4342-B048-85BDC9FD1C3A}</a:tableStyleId>
            </a:tblPr>
            <a:tblGrid/>
          </a:tbl>
        </a:graphicData>
      </a:graphic>
    </p:graphicFrame>""" % (nsdecls('p', 'a'),
                            '%d', '%s', '%d', '%d', '%d', '%d')

sp_id = 2
name  = 'Table 1'
x     = 1524000
y     = 1397000
cx    = 6096000
cy    = 741680
rows  = 2
cols  = 2

rowheight = '370840'
colwidth  = '3048000'


graphicFrame_xml = graphicFrame_tmpl % (sp_id, name, x, y, cx, cy)

graphicFrame = objectify.fromstring(graphicFrame_xml)

tbl = graphicFrame[qn('a:graphic')].graphicData.tbl

for row in range(rows):
    # tr = sub_elm(tbl, 'a:tr', h=rowheight)
    tr = new('a:tr', h=rowheight)
    for col in range(cols):
        sub_elm(tbl.tblGrid, 'a:gridCol', w=colwidth)
        tr.append(empty_cell())
    tbl.append(tr)


objectify.deannotate(graphicFrame, cleanup_namespaces=True)
print etree.tostring(graphicFrame, pretty_print = True)



# ============================================================================
# early experiments with objectivy
# ============================================================================

# def tagname(tag):
#     tag_parts = tag.split('}')
#     return tag_parts[1]
# 
# def print_subtree(elm, indent=0):
#     indent_spaces = indent * ' '
#     print '%s%s' % (indent_spaces, tagname(elm.tag))
#     for child in elm.iterchildren():
#         print_subtree(child, indent+2)
# 
# tree = objectify.parse('slide1.xml')
# sld = tree.getroot()
# # print_subtree(sld)
# # print tagname(sld.cSld.spTree.tag)



########NEW FILE########
__FILENAME__ = parse_xsd
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# parse_xsd.py
#

"""
Experimental code to parse XML Schema files for XML object binding classes
"""

import os
import sys

from lxml import etree

thisdir, thisfilename = os.path.split(__file__)

nsmap = {
    'xsd': 'http://www.w3.org/2001/XMLSchema',
    'p':   'http://purl.oclc.org/ooxml/presentationml/main',
    'a':   'http://purl.oclc.org/ooxml/drawingml/main',
    'r':   'http://purl.oclc.org/ooxml/officeDocument/relationships',
    's':   'http://purl.oclc.org/ooxml/officeDocument/sharedTypes',
}

reverse_nsmap = {uri: prefix for prefix, uri in nsmap.items()}


def pfxdtag(tag):
    """
    Return short-form prefixed tag from fully qualified (Clark notation)
    tagname.
    """
    uri, tagroot = tag[1:].split('}')
    prefix = reverse_nsmap[uri]
    return '%s:%s' % (prefix, tagroot)


def qtag(tag):
    """
    Return fully qualified (Clark notation) tagname corresponding to
    short-form prefixed tagname *tag*.
    """
    prefix, tagroot = tag.split(':')
    uri = nsmap[prefix]
    return '{%s}%s' % (uri, tagroot)


# ============================================================================
# XSD Classes
# ============================================================================

class XsdTree(object):
    """
    Wrapper for ElementTree of a .xsd file
    """
    def __init__(self, xsd_tree, nsprefix):
        super(XsdTree, self).__init__()
        self._tree = xsd_tree
        self.nsprefix = nsprefix

    def xpath(self, xpath):
        return self._tree.xpath(xpath, namespaces=nsmap)


class TypeGraph(object):
    """
    Container for graph of XSD types
    """
    def __init__(self, xsd_trees):
        super(TypeGraph, self).__init__()
        self.__xsd_trees = [XsdTree(tree, nspfx) for tree, nspfx in xsd_trees]
        self.types = {}
        self.elements = {}

    def add_element(self, element):
        """Add *element* to elements dictionary, keyed by name"""
        self.elements[element.tag] = element

    def get_complexType(self, typename):
        """Return complex type element with name *typename*"""
        if typename.startswith('a:'):
            typename = typename[2:]
        xpath = "./xsd:complexType[@name='%s']" % typename
        for xsd in self.__xsd_trees:
            elms = xsd.xpath(xpath)
            if len(elms):
                return elms[0], xsd.nsprefix
        raise KeyError("no complexType named '%s' found" % typename)

    def getdef(self, defname, tag='*'):
        """Return definition element with name *defname*"""
        if defname.startswith('a:'):
            defname = defname[2:]
        for xsd in self.__xsd_trees:
            xpath = "./%s[@name='%s']" % (tag, defname)
            elements = xsd.xpath(xpath)
            if elements:
                return elements[0]
        raise KeyError("no definition named '%s' found" % defname)

    def load_schema(self, xsd_root, nsprefix):
        for elm in xsd_root:
            tag = pfxdtag(elm.tag)
            if tag in ('xsd:import', 'xsd:simpleType', 'xsd:group',
                       'xsd:attributeGroup'):
                continue
            elif tag == 'xsd:complexType':
                ct = ComplexType(self, elm, nsprefix)
                self.types[ct.name] = ct
            elif tag == 'xsd:element':
                # if <xsd:element> has a 'ref' attribute, it is a reference
                # to a global xsd:element
                ref = elm.get('ref')
                if ref is not None:
                    elm = self.getdef(ref, tag='xsd:element')
                self.add_element(Element(elm, nsprefix))
            else:
                raise TypeError("don't know how to process %s" % tag)

    def load_subgraph(self, typename, visited=None):
        complexType_elm, nsprefix = self.get_complexType(typename)
        # take care to avoid infinite recursion by only visting each type once
        visited = [] if visited is None else visited
        if typename in visited:
            return
        visited.append(typename)
        # add type to graph
        complexType = ComplexType(self, complexType_elm, nsprefix)
        self.types[complexType.name] = complexType
        # recurse on subgraph of type
        for element in complexType.elements:
            if element.typename in ('xsd:string'):
                continue
            self.load_subgraph(element.typename, visited)


class ComplexType(object):
    """
    <xsd:complexType> object
    """
    def __init__(self, type_graph, complexType_elm, nsprefix):
        super(ComplexType, self).__init__()
        self.type_graph = type_graph
        self.nsprefix = nsprefix
        self.name = complexType_elm.get('name')
        self.elements = []
        self.attributes = []

        for child_elm in complexType_elm:
            tag = pfxdtag(child_elm.tag)
            if tag == 'xsd:sequence':
                self.__process_sequence(child_elm)
            elif tag == 'xsd:choice':
                self.__expand_choice(child_elm)
            elif tag == 'xsd:group':
                ref = child_elm.get('ref')
                if ref is not None:  # reference to separate group
                    child_elm = self.type_graph.getdef(ref)
                self.__expand_group(child_elm)
            elif tag == 'xsd:attribute':
                self.attributes.append(Attribute(child_elm))
            elif tag == 'xsd:attributeGroup':
                # e.g. ``<xsd:attributeGroup ref="AG_Locking"/>``
                ref = child_elm.get('ref')
                if ref is not None:  # reference to separate group
                    child_elm = self.type_graph.getdef(ref)
                self.__expand_attributeGroup(child_elm)
            else:
                xml = etree.tostring(child_elm)
                raise TypeError("don't know how to process %s" % xml)

    def __str__(self):
        s = '%s' % self.name
        for element in self.elements:
            s += '\n  %s' % element
        for attribute in self.attributes:
            s += '\n  %s' % attribute
        return s

    def add_element(self, element):
        """
        Add an element to this ComplexType and also append it to element dict
        of parent type graph.
        """
        self.elements.append(element)
        self.type_graph.add_element(element)

    @property
    def element_def(self):
        """
        blipFill = ElementDef('p:blipFill', 'CT_BlipFillProperties')
        blipFill.add_child('a:blip', cardinality='?')
        blipFill.add_attributes('dpi', 'rotWithShape')
        """
        s = ("%s = ElementDef('%s', '%s')\n" %
             (self.name, self.name, self.name))
        for element in self.elements:
            s += ("%s.add_child('%s', cardinality='%s')\n" %
                  (self.name, element.name, element.cardinality))
        # for attribute in self.attributes:
        #     s += '\n  %s' % attribute
        return s

    @property
    def max_tagname_len(self):
        """Return length of longest child element tagname"""
        return max([len(e.name) for e in self.elements])

    @property
    def optional_attributes(self):
        """Return list of optional attributes for this type"""
        return [a for a in self.attributes if not a.is_required]

    @property
    def required_attributes(self):
        """Return list of required attributes for this type"""
        return [a for a in self.attributes if a.is_required]

    def __expand_attributeGroup(self, attrgrp_elm):
        for child_elm in attrgrp_elm:
            tag = pfxdtag(child_elm.tag)
            if tag == 'xsd:attribute':
                self.attributes.append(Attribute(child_elm))
            else:
                tmpl = "don't know how to process %s in %s"
                raise TypeError(tmpl % (tag, 'xsd:attributeGroup'))

    def __expand_choice(self, choice_elm):
        for child_elm in choice_elm:
            tag = pfxdtag(child_elm.tag)
            if tag == 'xsd:element':
                element = Element(child_elm, self.nsprefix)
                element.minOccurs = '0'
                self.add_element(element)
            else:
                tmpl = "don't know how to process %s in %s"
                raise TypeError(tmpl % (tag, 'xsd:attributeGroup'))

    def __expand_group(self, group_elm):
        for child_elm in group_elm:
            tag = pfxdtag(child_elm.tag)
            if tag == 'xsd:sequence':
                self.__process_sequence(child_elm)
            elif tag == 'xsd:choice':
                self.__expand_choice(child_elm)
            else:
                print etree.tostring(child_elm)
                tmpl = "don't know how to process %s in %s"
                raise TypeError(tmpl % (tag, 'xsd:group'))

    def __process_sequence(self, seq_elm):
        for child_elm in seq_elm:
            tag = pfxdtag(child_elm.tag)
            if tag == 'xsd:element':
                ref = child_elm.get('ref')
                if ref is not None:  # reference to global xsd:element
                    child_elm = self.type_graph.getdef(ref, tag='xsd:element')
                self.add_element(Element(child_elm, self.nsprefix))
            elif tag == 'xsd:group':
                ref = child_elm.get('ref')
                if ref is not None:  # reference to separate group
                    child_elm = self.type_graph.getdef(ref)
                self.__expand_group(child_elm)
            elif tag == 'xsd:choice':
                self.__expand_choice(child_elm)
            # ignore xsd:any elements, just placeholders for schema expansion
            elif tag in ('xsd:any'):
                continue
            else:
                xml = etree.tostring(child_elm)
                raise TypeError("don't know how to process %s" % xml)


class Attribute(object):
    """
    <xsd:attribute> object
    """
    def __init__(self, attribute_elm):
        super(Attribute, self).__init__()
        self.name = attribute_elm.get('name')
        self.type = attribute_elm.get('type')
        self.use = attribute_elm.get('use', 'optional')
        self.default = attribute_elm.get('default')
        self.ref = attribute_elm.get('ref')
        self.form = attribute_elm.get('form')
        if self.form is not None:
            raise TypeError('found xsd:attribute with form="%s"' % self.form)
        # don't care about details other than name, ref gives that
        if self.name is None:
            self.name = self.ref

    def __str__(self):
        cardinality = '?' if self.use == 'optional' else '1'
        default = (' default="%s"' % self.default) if self.default else ''
        tmpl = 'xsd:attribute %s %s%s'
        return tmpl % (cardinality, self.name, default)

    @property
    def is_required(self):
        return self.use == 'required'


class Element(object):
    """
    <xsd:element> object
    """
    def __init__(self, element_elm, nsprefix):
        super(Element, self).__init__()
        self.nsprefix = nsprefix
        self.name = element_elm.get('name')
        self.tag = '%s:%s' % (self.nsprefix, self.name)
        self.typename = element_elm.get('type')
        if self.typename.startswith('a:'):
            self.typename = self.typename[2:]
        self.default = element_elm.get('default')
        self.form = element_elm.get('form')
        self.minOccurs = element_elm.get('minOccurs', '1')
        self.maxOccurs = element_elm.get('maxOccurs', '1')
        if self.form is not None:
            raise TypeError('found xsd:element with form="%s"' % self.form)

    def __str__(self):
        tmpl = 'xsd:element %s %s   %s%s'
        default = (' default="%s"' % self.default) if self.default else ''
        return tmpl % (self.cardinality, self.name, self.typename, default)

    @property
    def cardinality(self):
        if self.minOccurs == '0':
            cardinality = '?' if self.maxOccurs == '1' else '*'
        elif self.minOccurs == '1':
            cardinality = '1' if self.maxOccurs == '1' else '+'
        else:
            cardinality = '{%s:%s}' % (self.minOccurs, self.maxOccurs)
        return cardinality


def element_defs(tags):
    def _padding(type, element):
        return ' ' * (type.max_tagname_len - len(element.name))

    s = ''
    for tag in tags:
        element = tg.elements[tag]
        # no def needed for built-in types
        if element.typename in ('xsd:string'):
            continue
        try:
            type = tg.types[element.typename]
        except KeyError:
            continue

        # e.g. blipFill = ElementDef('p:blipFill', 'CT_BlipFillProperties')
        s += ("\n%s = ElementDef('%s', '%s')\n" %
              (element.name, element.tag, element.typename))

        # e.g. blipFill.add_child('a:blip', cardinality='?')
        for child in type.elements:
            s += ("%s.add_child('%s'%s, cardinality='%s')\n" %
                  (element.name, child.tag, _padding(type, child),
                   child.cardinality))

        # e.g. ext.add_attribute('x', required=True, default="0")
        for a in type.required_attributes:
            default = a.default if a.default else ''
            s += ("%s.add_attribute('%s', required=True, default='%s')\n" %
                  (element.name, a.name, default))

        # e.g. xfrm.add_attributes('rot', 'flipH', 'flipV')
        if type.optional_attributes:
            params = "', '".join([a.name for a in type.optional_attributes])
            s += "%s.add_attributes('%s')\n" % (element.name, params)

    return s


# ============================================================================
# main
# ============================================================================

pml = etree.parse(os.path.join(thisdir, 'xsd', 'pml.xsd')).getroot()
dml = etree.parse(os.path.join(thisdir, 'xsd', 'dml-main.xsd')).getroot()
sst = etree.parse(os.path.join(thisdir, 'xsd',
                               'shared-commonSimpleTypes.xsd')).getroot()

# xpath = "./xsd:complexType[@name='CT_Shape']"
# ct_shape = pml.xpath(xpath, namespaces=nsmap)[0]

tg = TypeGraph([(pml, 'p'), (dml, 'a'), (sst, 's')])

# tg.load_subgraph('CT_Shape')
# tg.load_subgraph('CT_Slide')
tg.load_schema(pml, 'p')
tg.load_schema(dml, 'a')
tg.load_schema(sst, 's')

# for typename in sorted(tg.types.keys()):
#     print typename
#     # print tg.types[typename]

# print '\n%d distinct types' % len(tg.types)

tags = sorted(tg.elements.keys())

# for tag in tags:
#     print(tag)
#
# print '\n%d distinct tags' % len(tags)

print element_defs(tags)

# tg.load_schema(pml, 'p')
# tg.load_schema(dml, 'a')

# tags = ['p:blipFill', 'p:pic', 'a:blip']
# tags = ['a:off', 'a:ext', 'p:blipFill', 'p:pic', 'a:blip']

# print element_defs(tags)

# BACKLOG: detect namespace prefix automatically from xsd root element

sys.exit()

########NEW FILE########
__FILENAME__ = validate
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# validate.py
#

"""
Experimental code to validate XML against an XML Schema
"""

import os
import sys

from lxml import etree

# # re-zip tweaked version of expanded package into a .pptx file
# $ cd test  # 'test' is the expanded package directory
# $ zip -rD -FS ../test-tweaked.pptx .

# ============================================================================
# Code templates
# ============================================================================

# xmlschema_doc = etree.parse('xsd/pml.xsd')
# xmlschema = etree.XMLSchema(xmlschema_doc)

# test_path = '../../../ar-fy-plans/test/ppt/slides'
#
# xmlschema = etree.XMLSchema(etree.parse('xsd/pml.xsd'))
#
# slide_path = os.path.join(test_path, 'slide1.xml')
# slide = etree.parse(slide_path)
# xmlschema.assert_(slide)
#
# sys.exit()
#
# for idx in range(1, 29):
#     slideLayout_path = os.path.join(test_path, 'slideLayout%d.xml' % idx)
#     sldLayout = etree.parse(slideLayout_path)
#     xmlschema.assert_(sldLayout)
#
# sys.exit()


test_path = '../../../ar-fy-plans/test/ppt/slideLayouts'

xmlschema = etree.XMLSchema(etree.parse('xsd/pml.xsd'))  # more compact form

for idx in range(1, 29):
    print 'slideLayout%d.xml' % idx
    slideLayout_path = os.path.join(test_path, 'slideLayout%d.xml' % idx)
    sldLayout = etree.parse(slideLayout_path)
    xmlschema.assert_(sldLayout)

sys.exit()


# assemble the necessary items
xmlschema = etree.XMLSchema(etree.parse('xsd/pml.xsd'))  # more compact form
test_path = '../../../ar-fy-plans/test/ppt/slides'
slide_path = os.path.join(test_path, 'slide1.xml')
sld = etree.parse(slide_path)  # should be ElementTree, not Element

# get valid True/False, no message
valid = xmlschema.validate(sld)
# print "valid => %s" % valid

# print out validation log for messages
# if not valid:
#     log = xmlschema.error_log
#     print type(log)
#     print(log.last_error)

# if not valid:
for e in xmlschema.error_log:
    print('%s:%s %s %s' % (e.filename, e.line, e.level_name, e.message))

# # raise an exception with validation error message if doesn't validate
# xmlschema.assertValid(sld)
# xmlschema.assert_(sld)  # bit shorter error message

sys.exit()

########NEW FILE########
__FILENAME__ = api
# encoding: utf-8

"""
Directly exposed API classes, Presentation for now. Provides some syntactic
sugar for interacting with the pptx.presentation.Package graph and also
provides some insulation so not so many classes in the other modules need to
be named as internal (leading underscore).
"""

from __future__ import absolute_import, print_function, unicode_literals

from warnings import warn

from pptx.package import Package


class Presentation(object):
    """
    Return a |Presentation| instance loaded from *file_*, where *file_* can
    be either a path to a ``.pptx`` file (a string) or a file-like object.
    If *file_* is missing or ``None``, load the built-in default presentation
    template.
    """
    def __init__(self, pkg_file=None):
        super(Presentation, self).__init__()
        self._package = Package.open(pkg_file)
        self._presentation = self._package.presentation

    @property
    def core_properties(self):
        """
        Instance of |CoreProperties| holding the read/write Dublin Core
        document properties for this presentation.
        """
        return self._package.core_properties

    @property
    def slide_layouts(self):
        """
        Sequence of |SlideLayout| instances belonging to the first
        |SlideMaster| of this presentation.
        """
        return self._presentation.slide_masters[0].slide_layouts

    @property
    def slidelayouts(self):
        """
        Deprecated. Use ``.slide_layouts`` property instead.
        """
        msg = (
            'Presentation.slidelayouts property is deprecated. Use .slide_la'
            'youts instead.'
        )
        warn(msg, UserWarning, stacklevel=2)
        return self.slide_layouts

    @property
    def slide_master(self):
        """
        First |SlideMaster| object belonging to this presentation. Typically,
        presentations have only a single slide master. This property provides
        simpler access in that common case.
        """
        return self._presentation.slide_masters[0]

    @property
    def slidemaster(self):
        """
        Deprecated. Use ``.slide_master`` property instead.
        """
        msg = (
            'Presentation.slidemaster property is deprecated. Use .slide_m'
            'aster instead.'
        )
        warn(msg, UserWarning, stacklevel=2)
        return self.slide_masters

    @property
    def slide_masters(self):
        """
        List of |SlideMaster| objects belonging to this presentation.
        """
        return self._presentation.slide_masters

    @property
    def slidemasters(self):
        """
        Deprecated. Use ``.slide_masters`` property instead.
        """
        msg = (
            'Presentation.slidemasters property is deprecated. Use .slide_'
            'masters instead.'
        )
        warn(msg, UserWarning, stacklevel=2)
        return self.slide_masters

    @property
    def slide_height(self):
        """
        Height of slides in this presentation, in English Metric Units (EMU)
        """
        return self._presentation.slide_height

    @slide_height.setter
    def slide_height(self, height):
        self._presentation.slide_height = height

    @property
    def slide_width(self):
        """
        Width of slides in this presentation, in English Metric Units (EMU)
        """
        return self._presentation.slide_width

    @slide_width.setter
    def slide_width(self, width):
        self._presentation.slide_width = width

    @property
    def slides(self):
        """
        |SlideCollection| object containing the slides in this
        presentation.
        """
        return self._presentation.slides

    def save(self, file):
        """
        Save this presentation to *file*, where *file* can be either a path to
        a file (a string) or a file-like object.
        """
        return self._package.save(file)

########NEW FILE########
__FILENAME__ = color
# encoding: utf-8

"""
DrawingML objects related to color, ColorFormat being the most prominent.
"""

from __future__ import absolute_import, print_function, unicode_literals

from types import NoneType

from ..enum.dml import MSO_COLOR_TYPE, MSO_THEME_COLOR
from ..oxml.dml.color import (
    CT_HslColor, CT_PresetColor, CT_SchemeColor, CT_ScRgbColor, CT_SRgbColor,
    CT_SystemColor
)


class ColorFormat(object):
    """
    Provides access to color settings such as RGB color, theme color, and
    luminance adjustments.
    """
    def __init__(self, eg_colorchoice_parent, color):
        super(ColorFormat, self).__init__()
        self._xFill = eg_colorchoice_parent
        self._color = color

    @property
    def brightness(self):
        """
        Read/write float value between -1.0 and 1.0 indicating the brightness
        adjustment for this color, e.g. -0.25 is 25% darker and 0.4 is 40%
        lighter. 0 means no brightness adjustment.
        """
        return self._color.brightness

    @brightness.setter
    def brightness(self, value):
        self._validate_brightness_value(value)
        self._color.brightness = value

    @classmethod
    def from_colorchoice_parent(cls, eg_colorchoice_parent):
        xClr = eg_colorchoice_parent.eg_colorchoice
        color = _Color(xClr)
        color_format = cls(eg_colorchoice_parent, color)
        return color_format

    @property
    def rgb(self):
        """
        |RGBColor| value of this color, or None if no RGB color is explicitly
        defined for this font. Setting this value to an |RGBColor| instance
        causes its type to change to MSO_COLOR_TYPE.RGB. If the color was a
        theme color with a brightness adjustment, the brightness adjustment
        is removed when changing it to an RGB color.
        """
        return self._color.rgb

    @rgb.setter
    def rgb(self, rgb):
        if not isinstance(rgb, RGBColor):
            raise ValueError('assigned value must be type RGBColor')
        # change to rgb color format if not already
        if not isinstance(self._color, _SRgbColor):
            srgbClr = self._xFill.get_or_change_to_srgbClr()
            self._color = _SRgbColor(srgbClr)
        # call _SRgbColor instance to do the setting
        self._color.rgb = rgb

    @property
    def theme_color(self):
        """
        Theme color value of this color, one of those defined in the
        MSO_THEME_COLOR enumeration, e.g. MSO_THEME_COLOR.ACCENT_1. Raises
        AttributeError on access if the color is not type
        ``MSO_COLOR_TYPE.SCHEME``. Assigning a value in ``MSO_THEME_COLOR``
        causes the color's type to change to ``MSO_COLOR_TYPE.SCHEME``.
        """
        return self._color.theme_color

    @theme_color.setter
    def theme_color(self, mso_theme_color_idx):
        # change to theme color format if not already
        if not isinstance(self._color, _SchemeColor):
            schemeClr = self._xFill.get_or_change_to_schemeClr()
            self._color = _SchemeColor(schemeClr)
        self._color.theme_color = mso_theme_color_idx

    @property
    def type(self):
        """
        Read-only. A value from :ref:`MsoColorType`, either RGB or SCHEME,
        corresponding to the way this color is defined, or None if no color
        is defined at the level of this font.
        """
        return self._color.color_type

    def _validate_brightness_value(self, value):
        if value < -1.0 or value > 1.0:
            raise ValueError('brightness must be number in range -1.0 to 1.0')
        if isinstance(self._color, _NoneColor):
            msg = (
                "can't set brightness when color.type is None. Set color.rgb"
                " or .theme_color first."
            )
            raise ValueError(msg)


class _Color(object):
    """
    Object factory for color object of the appropriate type, also the base
    class for all color type classes such as SRgbColor.
    """
    def __new__(cls, xClr):
        subcls_map = {
            NoneType:       _NoneColor,
            CT_HslColor:    _HslColor,
            CT_PresetColor: _PrstColor,
            CT_SchemeColor: _SchemeColor,
            CT_ScRgbColor:  _ScRgbColor,
            CT_SRgbColor:   _SRgbColor,
            CT_SystemColor: _SysColor,
        }
        color_cls = subcls_map[type(xClr)]
        return super(_Color, cls).__new__(color_cls)

    def __init__(self, xClr):
        super(_Color, self).__init__(xClr)
        self._xClr = xClr

    @property
    def brightness(self):
        lumMod, lumOff = self._xClr.lumMod, self._xClr.lumOff
        # a tint is lighter, a shade is darker
        # only tints have lumOff child
        if lumOff is not None:
            val = lumOff.val
            brightness = float(val) / 100000
            return brightness
        # which leaves shades, if lumMod is present
        if lumMod is not None:
            val = lumMod.val
            brightness = -1.0 + float(val)/100000
            return brightness
        # there's no brightness adjustment if no lum{Mod|Off} elements
        return 0

    @brightness.setter
    def brightness(self, value):
        if value > 0:
            self._tint(value)
        elif value < 0:
            self._shade(value)
        else:
            self._xClr.clear_lum()

    @property
    def color_type(self):  # pragma: no cover
        tmpl = ".color_type property must be implemented on %s"
        raise NotImplementedError(tmpl % self.__class__.__name__)

    @property
    def rgb(self):
        """
        Raises TypeError on access unless overridden by subclass.
        """
        tmpl = "no .rgb property on color type '%s'"
        raise AttributeError(tmpl % self.__class__.__name__)

    @property
    def theme_color(self):
        """
        Raises TypeError on access unless overridden by subclass.
        """
        return MSO_THEME_COLOR.NOT_THEME_COLOR

    def _shade(self, value):
        lumMod_val = 100000 - int(abs(value) * 100000)
        color_elm = self._xClr.clear_lum()
        color_elm.add_lumMod(lumMod_val)

    def _tint(self, value):
        lumOff_val = int(value * 100000)
        lumMod_val = 100000 - lumOff_val
        color_elm = self._xClr.clear_lum()
        color_elm.add_lumMod(lumMod_val)
        color_elm.add_lumOff(lumOff_val)


class _HslColor(_Color):

    @property
    def color_type(self):
        return MSO_COLOR_TYPE.HSL


class _NoneColor(_Color):

    @property
    def color_type(self):
        return None

    @property
    def theme_color(self):
        """
        Raise TypeError on attempt to access .theme_color when no color
        choice is present.
        """
        tmpl = "no .theme_color property on color type '%s'"
        raise AttributeError(tmpl % self.__class__.__name__)


class _PrstColor(_Color):

    @property
    def color_type(self):
        return MSO_COLOR_TYPE.PRESET


class _SchemeColor(_Color):

    def __init__(self, schemeClr):
        super(_SchemeColor, self).__init__(schemeClr)
        self._schemeClr = schemeClr

    @property
    def color_type(self):
        return MSO_COLOR_TYPE.SCHEME

    @property
    def theme_color(self):
        """
        Theme color value of this color, one of those defined in the
        MSO_THEME_COLOR enumeration, e.g. MSO_THEME_COLOR.ACCENT_1. None if
        no theme color is explicitly defined for this font. Setting this to a
        value in MSO_THEME_COLOR causes the color's type to change to
        ``MSO_COLOR_TYPE.SCHEME``.
        """
        return self._schemeClr.val

    @theme_color.setter
    def theme_color(self, mso_theme_color_idx):
        self._schemeClr.val = mso_theme_color_idx


class _ScRgbColor(_Color):

    @property
    def color_type(self):
        return MSO_COLOR_TYPE.SCRGB


class _SRgbColor(_Color):

    def __init__(self, srgbClr):
        super(_SRgbColor, self).__init__(srgbClr)
        self._srgbClr = srgbClr

    @property
    def color_type(self):
        return MSO_COLOR_TYPE.RGB

    @property
    def rgb(self):
        """
        |RGBColor| value of this color, corresponding to the value in the
        required ``val`` attribute of the ``<a:srgbColr>`` element.
        """
        return RGBColor.from_string(self._srgbClr.val)

    @rgb.setter
    def rgb(self, rgb):
        self._srgbClr.val = str(rgb)


class _SysColor(_Color):

    @property
    def color_type(self):
        return MSO_COLOR_TYPE.SYSTEM


class RGBColor(tuple):
    """
    Immutable value object defining a particular RGB color.
    """
    def __new__(cls, r, g, b):
        msg = 'RGBColor() takes three integer values 0-255'
        for val in (r, g, b):
            if not isinstance(val, int) or val < 0 or val > 255:
                raise ValueError(msg)
        return super(RGBColor, cls).__new__(cls, (r, g, b))

    def __str__(self):
        """
        Return a hex string rgb value, like '3C2F80'
        """
        return '%02X%02X%02X' % self

    @classmethod
    def from_string(cls, rgb_hex_str):
        """
        Return a new instance from an RGB color hex string like ``'3C2F80'``.
        """
        r = int(rgb_hex_str[:2], 16)
        g = int(rgb_hex_str[2:4], 16)
        b = int(rgb_hex_str[4:], 16)
        return cls(r, g, b)

########NEW FILE########
__FILENAME__ = fill
# encoding: utf-8

"""
DrawingML objects related to fill, FillFormat being the top-most.
"""

from __future__ import absolute_import, print_function, unicode_literals

from ..enum.dml import MSO_FILL
from ..oxml.dml.fill import (
    CT_BlipFillProperties, CT_GradientFillProperties, CT_GroupFillProperties,
    CT_NoFillProperties, CT_PatternFillProperties,
    CT_SolidColorFillProperties,
)
from pptx.util import lazyproperty

from .color import ColorFormat


class FillFormat(object):
    """
    Provides access to the current fill properties object and provides
    methods to change the fill type.
    """
    def __init__(self, eg_fill_properties_parent, fill_obj):
        super(FillFormat, self).__init__()
        self._xPr = eg_fill_properties_parent
        self._fill = fill_obj

    def background(self):
        """
        Sets the fill type to noFill, i.e. transparent.
        """
        noFill = self._xPr.get_or_change_to_noFill()
        self._fill = _NoFill(noFill)

    @property
    def fore_color(self):
        """
        Return a |ColorFormat| instance representing the foreground color of
        this fill.
        """
        return self._fill.fore_color

    @classmethod
    def from_fill_parent(cls, eg_fill_properties_parent):
        """
        Return a |FillFormat| instance initialized to the settings contained
        in *eg_fill_properties_parent*, which must be an element having
        EG_FillProperties in its schema sequence.
        """
        fill_elm = eg_fill_properties_parent.fill_element
        fill = _Fill(fill_elm)
        fill_format = cls(eg_fill_properties_parent, fill)
        return fill_format

    def solid(self):
        """
        Sets the fill type to solid, i.e. a solid color. Note that calling
        this method does not set a color or by itself cause the shape to
        appear with a solid color fill; rather it enables subsequent
        assignments to properties like fore_color to set the color.
        """
        solidFill = self._xPr.get_or_change_to_solidFill()
        self._fill = _SolidFill(solidFill)

    @property
    def type(self):
        """
        Return a value from the :ref:`MsoFillType` enumeration corresponding
        to the type of this fill.
        """
        return self._fill.type


class _Fill(object):
    """
    Object factory for fill object of class matching fill element, such as
    _SolidFill for ``<a:solidFill>``; also serves as the base class for all
    fill classes
    """
    def __new__(cls, xFill):
        if xFill is None:
            fill_cls = _NoneFill
        elif isinstance(xFill, CT_BlipFillProperties):
            fill_cls = _BlipFill
        elif isinstance(xFill, CT_GradientFillProperties):
            fill_cls = _GradFill
        elif isinstance(xFill, CT_GroupFillProperties):
            fill_cls = _GrpFill
        elif isinstance(xFill, CT_NoFillProperties):
            fill_cls = _NoFill
        elif isinstance(xFill, CT_PatternFillProperties):
            fill_cls = _PattFill
        elif isinstance(xFill, CT_SolidColorFillProperties):
            fill_cls = _SolidFill
        else:
            fill_cls = _Fill
        return super(_Fill, cls).__new__(fill_cls)

    @property
    def fore_color(self):
        """
        Raise NotImplementedError for all fill types that are still skeleton
        subclasses.
        """
        tmpl = ".fore_color property not implemented yet for %s"
        raise NotImplementedError(tmpl % self.__class__.__name__)

    @property
    def type(self):  # pragma: no cover
        tmpl = ".type property must be implemented on %s"
        raise NotImplementedError(tmpl % self.__class__.__name__)


class _BlipFill(_Fill):

    @property
    def fore_color(self):
        """
        Raise TypeError with message explaining why this doesn't make sense.
        """
        tmpl = "a picture fill has no foreground color"
        raise TypeError(tmpl)

    @property
    def type(self):
        return MSO_FILL.PICTURE


class _GradFill(_Fill):

    @property
    def type(self):
        return MSO_FILL.GRADIENT


class _GrpFill(_Fill):

    @property
    def fore_color(self):
        """
        Raise TypeError with message explaining why this doesn't make sense.
        """
        tmpl = "a group fill has no foreground color"
        raise TypeError(tmpl)

    @property
    def type(self):
        return MSO_FILL.GROUP


class _NoFill(_Fill):

    @property
    def fore_color(self):
        """
        Raise TypeError with message explaining why this doesn't make sense.
        """
        tmpl = "a transparent (background) fill has no foreground color"
        raise TypeError(tmpl)

    @property
    def type(self):
        return MSO_FILL.BACKGROUND


class _NoneFill(_Fill):

    @property
    def fore_color(self):
        """
        Raise TypeError with message explaining why this doesn't make sense.
        """
        tmpl = "can't set .fore_color on no fill, call .solid() first"
        raise TypeError(tmpl)

    @property
    def type(self):
        return None


class _PattFill(_Fill):

    @property
    def type(self):
        return MSO_FILL.PATTERNED


class _SolidFill(_Fill):
    """
    Provides access to fill properties such as color for solid fills.
    """
    def __init__(self, solidFill):
        super(_SolidFill, self).__init__()
        self._solidFill = solidFill

    @lazyproperty
    def fore_color(self):
        return ColorFormat.from_colorchoice_parent(self._solidFill)

    @property
    def type(self):
        return MSO_FILL.SOLID

########NEW FILE########
__FILENAME__ = line
# encoding: utf-8

"""
DrawingML objects related to line formatting
"""

from __future__ import absolute_import, print_function, unicode_literals

from ..enum.dml import MSO_FILL
from .fill import FillFormat
from ..util import lazyproperty


class LineFormat(object):
    """
    Provides access to line properties such as line color, style, and width.
    Typically accessed via the ``.line`` property of a shape such as |Shape|
    or |Picture|.
    """
    def __init__(self, parent):
        super(LineFormat, self).__init__()
        self._parent = parent

    @lazyproperty
    def color(self):
        """
        The |ColorFormat| instance that provides access to the color settings
        for this line. Essentially a shortcut for ``line.fill.fore_color``.
        As a side-effect, accessing this property causes the line fill type
        to be set to ``MSO_FILL.SOLID``. If this sounds risky for your use
        case, use ``line.fill.type`` to non-destructively discover the
        existing fill type.
        """
        if self.fill.type != MSO_FILL.SOLID:
            self.fill.solid()
        return self.fill.fore_color

    @lazyproperty
    def fill(self):
        """
        |FillFormat| instance for this line, providing access to fill
        properties such as foreground color.
        """
        ln = self._get_or_add_ln()
        return FillFormat.from_fill_parent(ln)

    @property
    def width(self):
        """
        The width of the line expressed as an integer number of :ref:`English
        Metric Units <EMU>`. The returned value is an instance of
        |BaseLength|, a value class having properties such as `.inches`,
        `.cm`, and `.pt` for converting the value into convenient units.
        """
        ln = self._ln
        if ln is None:
            return None
        return ln.w

    @width.setter
    def width(self, emu):
        ln = self._get_or_add_ln()
        ln.w = emu

    def _get_or_add_ln(self):
        """
        Return the ``<a:ln>`` element containing the line format properties
        in the XML.
        """
        return self._parent.get_or_add_ln()

    @property
    def _ln(self):
        return self._parent.ln

########NEW FILE########
__FILENAME__ = base
# encoding: utf-8

"""
Base classes and other objects used by enumerations
"""

from __future__ import absolute_import, print_function

import sys
import textwrap


def alias(*aliases):
    """
    Decorating a class with @alias('FOO', 'BAR', ..) allows the class to
    be referenced by each of the names provided as arguments.
    """
    def decorator(cls):
        # alias must be set in globals from caller's frame
        caller = sys._getframe(1)
        globals_dict = caller.f_globals
        for alias in aliases:
            globals_dict[alias] = cls
        return cls
    return decorator


class _DocsPageFormatter(object):
    """
    Formats a RestructuredText documention page (string) for the enumeration
    class parts passed to the constructor. An immutable one-shot service
    object.
    """
    def __init__(self, clsname, clsdict):
        self._clsname = clsname
        self._clsdict = clsdict

    @property
    def page_str(self):
        """
        The RestructuredText documentation page for the enumeration. This is
        the only API member for the class.
        """
        tmpl = '.. _%s:\n\n%s\n\n%s\n\n----\n\n%s'
        components = (
            self._ms_name, self._page_title, self._intro_text,
            self._member_defs
        )
        return tmpl % components

    @property
    def _intro_text(self):
        """
        The docstring of the enumeration, formatted for use at the top of the
        documentation page
        """
        try:
            cls_docstring = self._clsdict['__doc__']
        except KeyError:
            cls_docstring = ''
        return textwrap.dedent(cls_docstring).strip()

    def _member_def(self, member):
        """
        Return an individual member definition formatted as an RST glossary
        entry, wrapped to fit within 78 columns.
        """
        member_docstring = textwrap.dedent(member.docstring).strip()
        member_docstring = textwrap.fill(
            member_docstring, width=78, initial_indent=' '*4,
            subsequent_indent=' '*4
        )
        return '%s\n%s\n' % (member.name, member_docstring)

    @property
    def _member_defs(self):
        """
        A single string containing the aggregated member definitions section
        of the documentation page
        """
        members = self._clsdict['__members__']
        member_defs = [
            self._member_def(member) for member in members
            if member.name is not None
        ]
        return '\n'.join(member_defs)

    @property
    def _ms_name(self):
        """
        The Microsoft API name for this enumeration
        """
        return self._clsdict['__ms_name__']

    @property
    def _page_title(self):
        """
        The title for the documentation page, formatted as code (surrounded
        in double-backtics) and underlined with '=' characters
        """
        title_underscore = '=' * (len(self._clsname)+4)
        return '``%s``\n%s' % (self._clsname, title_underscore)


class MetaEnumeration(type):
    """
    The metaclass for Enumeration and its subclasses. Adds a name for each
    named member and compiles state needed by the enumeration class to
    respond to other attribute gets
    """
    def __new__(meta, clsname, bases, clsdict):
        meta._add_enum_members(clsdict)
        meta._collect_valid_settings(clsdict)
        meta._generate_docs_page(clsname, clsdict)
        return type.__new__(meta, clsname, bases, clsdict)

    @classmethod
    def _add_enum_members(meta, clsdict):
        """
        Dispatch ``.add_to_enum()`` call to each member so it can do its
        thing to properly add itself to the enumeration class. This
        delegation allows member sub-classes to add specialized behaviors.
        """
        enum_members = clsdict['__members__']
        for member in enum_members:
            member.add_to_enum(clsdict)

    @classmethod
    def _collect_valid_settings(meta, clsdict):
        """
        Return a sequence containing the enumeration values that are valid
        assignment values. Return-only values are excluded.
        """
        enum_members = clsdict['__members__']
        valid_settings = []
        for member in enum_members:
            valid_settings.extend(member.valid_settings)
        clsdict['_valid_settings'] = valid_settings

    @classmethod
    def _generate_docs_page(meta, clsname, clsdict):
        """
        Return the RST documentation page for the enumeration.
        """
        clsdict['__docs_rst__'] = (
            _DocsPageFormatter(clsname, clsdict).page_str
        )


class Enumeration(object):
    """
    Base class for all enumerations, used directly for enumerations requiring
    only basic behavior.
    """
    __metaclass__ = MetaEnumeration
    __members__ = ()
    __ms_name__ = ''

    @classmethod
    def is_valid_setting(cls, value):
        """
        Return |True| if *value* is an assignable value, |False| if it is
        a return value-only member or not a member value.
        """
        return value in cls._valid_settings


class XmlEnumeration(Enumeration):
    """
    Provides ``to_xml()`` and ``from_xml()`` methods in addition to base
    enumeration features
    """
    __members__ = ()
    __ms_name__ = ''

    @classmethod
    def from_xml(cls, xml_val):
        """
        Return the enumeration member corresponding to the XML value
        *xml_val*.
        """
        return cls._xml_to_member[xml_val]

    @classmethod
    def to_xml(cls, enum_val):
        """
        Return the XML value of the enumeration value *enum_val*.
        """
        return cls._member_to_xml[enum_val]


class EnumMember(object):
    """
    Used in the enumeration class definition to define a member value and its
    mappings
    """
    def __init__(self, name, value, docstring):
        self._name = name
        if isinstance(value, int):
            value = EnumValue(name, value, docstring)
        self._value = value
        self._docstring = docstring

    def add_to_enum(self, clsdict):
        """
        Add a name to *clsdict* for this member.
        """
        self.register_name(clsdict)

    @property
    def docstring(self):
        """
        The description of this member
        """
        return self._docstring

    @property
    def name(self):
        """
        The distinguishing name of this member within the enumeration class,
        e.g. 'MIDDLE' for MSO_VERTICAL_ANCHOR.MIDDLE, if this is a named
        member. Otherwise the primitive value such as |None|, |True| or
        |False|.
        """
        return self._name

    def register_name(self, clsdict):
        """
        Add a member name to the class dict *clsdict* containing the value of
        this member object. Where the name of this object is None, do
        nothing; this allows out-of-band values to be defined without adding
        a name to the class dict.
        """
        if self.name is None:
            return
        clsdict[self.name] = self.value

    @property
    def valid_settings(self):
        """
        A sequence containing the values valid for assignment for this
        member. May be zero, one, or more in number.
        """
        return (self._value,)

    @property
    def value(self):
        """
        The enumeration value for this member, often an instance of
        EnumValue, but may be a primitive value such as |None|.
        """
        return self._value


class EnumValue(int):
    """
    A named enumeration value, providing __str__ and __doc__ string values
    for its symbolic name and description, respectively. Subclasses int, so
    behaves as a regular int unless the strings are asked for.
    """
    def __new__(cls, member_name, int_value, docstring):
        return super(EnumValue, cls).__new__(cls, int_value)

    def __init__(self, member_name, int_value, docstring):
        super(EnumValue, self).__init__()
        self._member_name = member_name
        self._docstring = docstring

    @property
    def __doc__(self):
        """
        The description of this enumeration member
        """
        return self._docstring.strip()

    def __str__(self):
        """
        The symbolic name and string value of this member, e.g. 'MIDDLE (3)'
        """
        return "%s (%d)" % (self._member_name, self)


class ReturnValueOnlyEnumMember(EnumMember):
    """
    Used to define a member of an enumeration that is only valid as a query
    result and is not valid as a setting, e.g. MSO_VERTICAL_ANCHOR.MIXED (-2)
    """
    @property
    def valid_settings(self):
        """
        No settings are valid for a return-only value.
        """
        return ()


class XmlMappedEnumMember(EnumMember):
    """
    Used to define a member whose value maps to an XML attribute value.
    """
    def __init__(self, name, value, xml_value, docstring):
        super(XmlMappedEnumMember, self).__init__(name, value, docstring)
        self._xml_value = xml_value

    def add_to_enum(self, clsdict):
        """
        Compile XML mappings in addition to base add behavior.
        """
        super(XmlMappedEnumMember, self).add_to_enum(clsdict)
        self.register_xml_mapping(clsdict)

    def register_xml_mapping(self, clsdict):
        """
        Add XML mappings to the enumeration class state for this member.
        """
        member_to_xml = self._get_or_add_member_to_xml(clsdict)
        member_to_xml[self.value] = self.xml_value
        xml_to_member = self._get_or_add_xml_to_member(clsdict)
        xml_to_member[self.xml_value] = self.value

    @property
    def xml_value(self):
        """
        The XML attribute value that corresponds to this enumeration value
        """
        return self._xml_value

    @staticmethod
    def _get_or_add_member_to_xml(clsdict):
        """
        Add the enum -> xml value mapping to the enumeration class state
        """
        if '_member_to_xml' not in clsdict:
            clsdict['_member_to_xml'] = dict()
        return clsdict['_member_to_xml']

    @staticmethod
    def _get_or_add_xml_to_member(clsdict):
        """
        Add the xml -> enum value mapping to the enumeration class state
        """
        if '_xml_to_member' not in clsdict:
            clsdict['_xml_to_member'] = dict()
        return clsdict['_xml_to_member']

########NEW FILE########
__FILENAME__ = dml
# encoding: utf-8

"""
Enumerations used by DrawingML objects
"""

from __future__ import absolute_import

from .base import (
    alias, Enumeration, EnumMember, ReturnValueOnlyEnumMember,
    XmlEnumeration, XmlMappedEnumMember
)


class MSO_COLOR_TYPE(Enumeration):
    """
    Specifies the color specification scheme

    Example::

        from pptx.enum.dml import MSO_COLOR_TYPE

        assert shape.fill.fore_color.type == MSO_COLOR_TYPE.SCHEME
    """

    __ms_name__ = 'MsoColorType'

    __url__ = (
        'http://msdn.microsoft.com/en-us/library/office/ff864912(v=office.15'
        ').aspx'
    )

    __members__ = (
        EnumMember(
            'RGB', 1, 'Color is specified by an |RGBColor| value'
        ),
        EnumMember(
            'SCHEME', 2, 'Color is one of the preset theme colors'
        ),
        EnumMember(
            'HSL', 101, """
            Color is specified using Hue, Saturation, and Luminosity values
            """
        ),
        EnumMember(
            'PRESET', 102, """
            Color is specified using a named built-in color
            """
        ),
        EnumMember(
            'SCRGB', 103, """
            Color is an scRGB color, a wide color gamut RGB color space
            """
        ),
        EnumMember(
            'SYSTEM', 104, """
            Color is one specified by the operating system, such as the
            window background color.
            """
        ),
    )


@alias('MSO_FILL')
class MSO_FILL_TYPE(Enumeration):
    """
    Specifies the type of bitmap used for the fill of a shape.

    Alias: ``MSO_FILL``

    Example::

        from pptx.enum.dml import MSO_FILL

        assert shape.fill.type == MSO_FILL.SOLID
    """

    __ms_name__ = 'MsoFillType'

    __url__ = 'http://msdn.microsoft.com/EN-US/library/office/ff861408.aspx'

    __members__ = (
        EnumMember(
            'BACKGROUND', 5, """
            The shape is transparent, such that whatever is behind the shape
            shows through. Often this is the slide background, but if
            a visible shape is behind, that will show through.
            """
        ),
        EnumMember(
            'GRADIENT', 3, 'Shape is filled with a gradient'
        ),
        EnumMember(
            'GROUP', 101, 'Shape is part of a group and should inherit the '
            'fill properties of the group.'
        ),
        EnumMember(
            'PATTERNED', 2, 'Shape is filled with a pattern'
        ),
        EnumMember(
            'PICTURE', 6, 'Shape is filled with a bitmapped image'
        ),
        EnumMember(
            'SOLID', 1, 'Shape is filled with a solid color'
        ),
        EnumMember(
            'TEXTURED', 4, 'Shape is filled with a texture'
        ),
    )


@alias('MSO_THEME_COLOR')
class MSO_THEME_COLOR_INDEX(XmlEnumeration):
    """
    Indicates the Office theme color, one of those shown in the color gallery
    on the formatting ribbon.

    Alias: ``MSO_THEME_COLOR``

    Example::

        from pptx.enum.dml import MSO_THEME_COLOR

        shape.fill.solid()
        shape.fill.fore_color.theme_color == MSO_THEME_COLOR.ACCENT_1
    """

    __ms_name__ = 'MsoThemeColorIndex'

    __url__ = (
        'http://msdn.microsoft.com/en-us/library/office/ff860782(v=office.15'
        ').aspx'
    )

    __members__ = (
        EnumMember(
            'NOT_THEME_COLOR', 0, 'Indicates the color is not a theme color.'
        ),
        XmlMappedEnumMember(
            'ACCENT_1', 5, 'accent1', 'Specifies the Accent 1 theme color.'
        ),
        XmlMappedEnumMember(
            'ACCENT_2', 6, 'accent2', 'Specifies the Accent 2 theme color.'
        ),
        XmlMappedEnumMember(
            'ACCENT_3', 7, 'accent3', 'Specifies the Accent 3 theme color.'
        ),
        XmlMappedEnumMember(
            'ACCENT_4', 8, 'accent4', 'Specifies the Accent 4 theme color.'
        ),
        XmlMappedEnumMember(
            'ACCENT_5', 9, 'accent5', 'Specifies the Accent 5 theme color.'
        ),
        XmlMappedEnumMember(
            'ACCENT_6', 10, 'accent6', 'Specifies the Accent 6 theme color.'
        ),
        XmlMappedEnumMember(
            'BACKGROUND_1', 14, 'bg1', 'Specifies the Background 1 theme '
            'color.'
        ),
        XmlMappedEnumMember(
            'BACKGROUND_2', 16, 'bg2', 'Specifies the Background 2 theme '
            'color.'
        ),
        XmlMappedEnumMember(
            'DARK_1', 1, 'dk1', 'Specifies the Dark 1 theme color.'
        ),
        XmlMappedEnumMember(
            'DARK_2', 3, 'dk2', 'Specifies the Dark 2 theme color.'
        ),
        XmlMappedEnumMember(
            'FOLLOWED_HYPERLINK', 12, 'folHlink', 'Specifies the theme color'
            ' for a clicked hyperlink.'
        ),
        XmlMappedEnumMember(
            'HYPERLINK', 11, 'hlink', 'Specifies the theme color for a hyper'
            'link.'
        ),
        XmlMappedEnumMember(
            'LIGHT_1', 2, 'lt1', 'Specifies the Light 1 theme color.'
        ),
        XmlMappedEnumMember(
            'LIGHT_2', 4, 'lt2', 'Specifies the Light 2 theme color.'
        ),
        XmlMappedEnumMember(
            'TEXT_1', 13, 'tx1', 'Specifies the Text 1 theme color.'
        ),
        XmlMappedEnumMember(
            'TEXT_2', 15, 'tx2', 'Specifies the Text 2 theme color.'
        ),
        ReturnValueOnlyEnumMember(
            'MIXED', -2, 'Indicates multiple theme colors are used, such as '
            'in a group shape.'
        ),
    )

########NEW FILE########
__FILENAME__ = shapes
# encoding: utf-8

"""
Enumerations used by shapes and related objects
"""

from __future__ import absolute_import

from .base import (
    alias, Enumeration, EnumMember, ReturnValueOnlyEnumMember,
    XmlEnumeration, XmlMappedEnumMember
)


@alias('MSO_SHAPE')
class MSO_AUTO_SHAPE_TYPE(XmlEnumeration):
    """
    Specifies a type of AutoShape, e.g. DOWN_ARROW

    Alias: ``MSO_SHAPE``

    Example::

        from pptx.enum.shapes import MSO_SHAPE
        from pptx.util import Inches

        left = top = width = height = Inches(1.0)
        slide.shapes.add_shape(
            MSO_SHAPE.ROUNDED_RECTANGLE, left, top, width, height
        )
    """

    __ms_name__ = 'MsoAutoShapeType'

    __url__ = (
        'http://msdn.microsoft.com/en-us/library/office/ff862770(v=office.15'
        ').aspx'
    )

    __members__ = (
        XmlMappedEnumMember(
            'ACTION_BUTTON_BACK_OR_PREVIOUS', 129,
            'actionButtonBackPrevious', 'Back or Previous button. Supports '
            'mouse-click and mouse-over actions'
        ),
        XmlMappedEnumMember(
            'ACTION_BUTTON_BEGINNING', 131, 'actionButtonBeginning',
            'Beginning button. Supports mouse-click and mouse-over actions'
        ),
        XmlMappedEnumMember(
            'ACTION_BUTTON_CUSTOM', 125, 'actionButtonBlank',
            'Button with no default picture or text. Supports mouse-click an'
            'd mouse-over actions'
        ),
        XmlMappedEnumMember(
            'ACTION_BUTTON_DOCUMENT', 134, 'actionButtonDocument',
            'Document button. Supports mouse-click and mouse-over actions'
        ),
        XmlMappedEnumMember(
            'ACTION_BUTTON_END', 132, 'actionButtonEnd',
            'End button. Supports mouse-click and mouse-over actions'
        ),
        XmlMappedEnumMember(
            'ACTION_BUTTON_FORWARD_OR_NEXT', 130, 'actionButtonForwardNext',
            'Forward or Next button. Supports mouse-click and mouse-over act'
            'ions'
        ),
        XmlMappedEnumMember(
            'ACTION_BUTTON_HELP', 127, 'actionButtonHelp',
            'Help button. Supports mouse-click and mouse-over actions'
        ),
        XmlMappedEnumMember(
            'ACTION_BUTTON_HOME', 126, 'actionButtonHome',
            'Home button. Supports mouse-click and mouse-over actions'
        ),
        XmlMappedEnumMember(
            'ACTION_BUTTON_INFORMATION', 128, 'actionButtonInformation',
            'Information button. Supports mouse-click and mouse-over actions'
        ),
        XmlMappedEnumMember(
            'ACTION_BUTTON_MOVIE', 136, 'actionButtonMovie',
            'Movie button. Supports mouse-click and mouse-over actions'
        ),
        XmlMappedEnumMember(
            'ACTION_BUTTON_RETURN', 133, 'actionButtonReturn',
            'Return button. Supports mouse-click and mouse-over actions'
        ),
        XmlMappedEnumMember(
            'ACTION_BUTTON_SOUND', 135, 'actionButtonSound',
            'Sound button. Supports mouse-click and mouse-over actions'
        ),
        XmlMappedEnumMember(
            'ARC', 25, 'arc', 'Arc'
        ),
        XmlMappedEnumMember(
            'BALLOON', 137, 'wedgeRoundRectCallout',
            'Rounded Rectangular Callout'
        ),
        XmlMappedEnumMember(
            'BENT_ARROW', 41, 'bentArrow',
            'Block arrow that follows a curved 90-degree angle'
        ),
        XmlMappedEnumMember(
            'BENT_UP_ARROW', 44, 'bentUpArrow',
            'Block arrow that follows a sharp 90-degree angle. Points up by '
            'default'
        ),
        XmlMappedEnumMember(
            'BEVEL', 15, 'bevel', 'Bevel'
        ),
        XmlMappedEnumMember(
            'BLOCK_ARC', 20, 'blockArc', 'Block arc'
        ),
        XmlMappedEnumMember(
            'CAN', 13, 'can', 'Can'
        ),
        XmlMappedEnumMember(
            'CHART_PLUS', 182, 'chartPlus', 'Chart Plus'
        ),
        XmlMappedEnumMember(
            'CHART_STAR', 181, 'chartStar', 'Chart Star'
        ),
        XmlMappedEnumMember(
            'CHART_X', 180, 'chartX', 'Chart X'
        ),
        XmlMappedEnumMember(
            'CHEVRON', 52, 'chevron', 'Chevron'
        ),
        XmlMappedEnumMember(
            'CHORD', 161, 'chord', 'Geometric chord shape'
        ),
        XmlMappedEnumMember(
            'CIRCULAR_ARROW', 60, 'circularArrow',
            'Block arrow that follows a curved 180-degree angle'
        ),
        XmlMappedEnumMember(
            'CLOUD', 179, 'cloud', 'Cloud'
        ),
        XmlMappedEnumMember(
            'CLOUD_CALLOUT', 108, 'cloudCallout', 'Cloud callout'
        ),
        XmlMappedEnumMember(
            'CORNER', 162, 'corner', 'Corner'
        ),
        XmlMappedEnumMember(
            'CORNER_TABS', 169, 'cornerTabs', 'Corner Tabs'
        ),
        XmlMappedEnumMember(
            'CROSS', 11, 'plus', 'Cross'
        ),
        XmlMappedEnumMember(
            'CUBE', 14, 'cube', 'Cube'
        ),
        XmlMappedEnumMember(
            'CURVED_DOWN_ARROW', 48, 'curvedDownArrow',
            'Block arrow that curves down'
        ),
        XmlMappedEnumMember(
            'CURVED_DOWN_RIBBON', 100, 'ellipseRibbon',
            'Ribbon banner that curves down'
        ),
        XmlMappedEnumMember(
            'CURVED_LEFT_ARROW', 46, 'curvedLeftArrow',
            'Block arrow that curves left'
        ),
        XmlMappedEnumMember(
            'CURVED_RIGHT_ARROW', 45, 'curvedRightArrow',
            'Block arrow that curves right'
        ),
        XmlMappedEnumMember(
            'CURVED_UP_ARROW', 47, 'curvedUpArrow',
            'Block arrow that curves up'
        ),
        XmlMappedEnumMember(
            'CURVED_UP_RIBBON', 99, 'ellipseRibbon2',
            'Ribbon banner that curves up'
        ),
        XmlMappedEnumMember(
            'DECAGON', 144, 'decagon', 'Decagon'
        ),
        XmlMappedEnumMember(
            'DIAGONAL_STRIPE', 141, 'diagStripe', 'Diagonal Stripe'
        ),
        XmlMappedEnumMember(
            'DIAMOND', 4, 'diamond', 'Diamond'
        ),
        XmlMappedEnumMember(
            'DODECAGON', 146, 'dodecagon', 'Dodecagon'
        ),
        XmlMappedEnumMember(
            'DONUT', 18, 'donut', 'Donut'
        ),
        XmlMappedEnumMember(
            'DOUBLE_BRACE', 27, 'bracePair', 'Double brace'
        ),
        XmlMappedEnumMember(
            'DOUBLE_BRACKET', 26, 'bracketPair', 'Double bracket'
        ),
        XmlMappedEnumMember(
            'DOUBLE_WAVE', 104, 'doubleWave', 'Double wave'
        ),
        XmlMappedEnumMember(
            'DOWN_ARROW', 36, 'downArrow', 'Block arrow that points down'
        ),
        XmlMappedEnumMember(
            'DOWN_ARROW_CALLOUT', 56, 'downArrowCallout',
            'Callout with arrow that points down'
        ),
        XmlMappedEnumMember(
            'DOWN_RIBBON', 98, 'ribbon',
            'Ribbon banner with center area below ribbon ends'
        ),
        XmlMappedEnumMember(
            'EXPLOSION1', 89, 'irregularSeal1', 'Explosion'
        ),
        XmlMappedEnumMember(
            'EXPLOSION2', 90, 'irregularSeal2', 'Explosion'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_ALTERNATE_PROCESS', 62, 'flowChartAlternateProcess',
            'Alternate process flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_CARD', 75, 'flowChartPunchedCard',
            'Card flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_COLLATE', 79, 'flowChartCollate',
            'Collate flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_CONNECTOR', 73, 'flowChartConnector',
            'Connector flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_DATA', 64, 'flowChartInputOutput',
            'Data flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_DECISION', 63, 'flowChartDecision',
            'Decision flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_DELAY', 84, 'flowChartDelay', 'Delay flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_DIRECT_ACCESS_STORAGE', 87, 'flowChartMagneticDrum',
            'Direct access storage flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_DISPLAY', 88, 'flowChartDisplay',
            'Display flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_DOCUMENT', 67, 'flowChartDocument',
            'Document flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_EXTRACT', 81, 'flowChartExtract',
            'Extract flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_INTERNAL_STORAGE', 66, 'flowChartInternalStorage',
            'Internal storage flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_MAGNETIC_DISK', 86, 'flowChartMagneticDisk',
            'Magnetic disk flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_MANUAL_INPUT', 71, 'flowChartManualInput',
            'Manual input flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_MANUAL_OPERATION', 72, 'flowChartManualOperation',
            'Manual operation flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_MERGE', 82, 'flowChartMerge', 'Merge flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_MULTIDOCUMENT', 68, 'flowChartMultidocument',
            'Multi-document flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_OFFLINE_STORAGE', 139, 'flowChartOfflineStorage',
            'Offline Storage'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_OFFPAGE_CONNECTOR', 74, 'flowChartOffpageConnector',
            'Off-page connector flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_OR', 78, 'flowChartOr', '"Or" flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_PREDEFINED_PROCESS', 65, 'flowChartPredefinedProcess',
            'Predefined process flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_PREPARATION', 70, 'flowChartPreparation',
            'Preparation flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_PROCESS', 61, 'flowChartProcess',
            'Process flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_PUNCHED_TAPE', 76, 'flowChartPunchedTape',
            'Punched tape flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_SEQUENTIAL_ACCESS_STORAGE', 85,
            'flowChartMagneticTape',
            'Sequential access storage flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_SORT', 80, 'flowChartSort', 'Sort flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_STORED_DATA', 83, 'flowChartOnlineStorage',
            'Stored data flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_SUMMING_JUNCTION', 77, 'flowChartSummingJunction',
            'Summing junction flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FLOWCHART_TERMINATOR', 69, 'flowChartTerminator',
            'Terminator flowchart symbol'
        ),
        XmlMappedEnumMember(
            'FOLDED_CORNER', 16, 'folderCorner', 'Folded corner'
        ),
        XmlMappedEnumMember(
            'FRAME', 158, 'frame', 'Frame'
        ),
        XmlMappedEnumMember(
            'FUNNEL', 174, 'funnel', 'Funnel'
        ),
        XmlMappedEnumMember(
            'GEAR_6', 172, 'gear6', 'Gear 6'
        ),
        XmlMappedEnumMember(
            'GEAR_9', 173, 'gear9', 'Gear 9'
        ),
        XmlMappedEnumMember(
            'HALF_FRAME', 159, 'halfFrame', 'Half Frame'
        ),
        XmlMappedEnumMember(
            'HEART', 21, 'heart', 'Heart'
        ),
        XmlMappedEnumMember(
            'HEPTAGON', 145, 'heptagon', 'Heptagon'
        ),
        XmlMappedEnumMember(
            'HEXAGON', 10, 'hexagon', 'Hexagon'
        ),
        XmlMappedEnumMember(
            'HORIZONTAL_SCROLL', 102, 'horizontalScroll', 'Horizontal scroll'
        ),
        XmlMappedEnumMember(
            'ISOSCELES_TRIANGLE', 7, 'triangle', 'Isosceles triangle'
        ),
        XmlMappedEnumMember(
            'LEFT_ARROW', 34, 'leftArrow', 'Block arrow that points left'
        ),
        XmlMappedEnumMember(
            'LEFT_ARROW_CALLOUT', 54, 'leftArrowCallout',
            'Callout with arrow that points left'
        ),
        XmlMappedEnumMember(
            'LEFT_BRACE', 31, 'leftBrace', 'Left brace'
        ),
        XmlMappedEnumMember(
            'LEFT_BRACKET', 29, 'leftBracket', 'Left bracket'
        ),
        XmlMappedEnumMember(
            'LEFT_CIRCULAR_ARROW', 176, 'leftCircularArrow',
            'Left Circular Arrow'
        ),
        XmlMappedEnumMember(
            'LEFT_RIGHT_ARROW', 37, 'leftRightArrow',
            'Block arrow with arrowheads that point both left and right'
        ),
        XmlMappedEnumMember(
            'LEFT_RIGHT_ARROW_CALLOUT', 57, 'leftRightArrowCallout',
            'Callout with arrowheads that point both left and right'
        ),
        XmlMappedEnumMember(
            'LEFT_RIGHT_CIRCULAR_ARROW', 177, 'leftRightCircularArrow',
            'Left Right Circular Arrow'
        ),
        XmlMappedEnumMember(
            'LEFT_RIGHT_RIBBON', 140, 'leftRightRibbon', 'Left Right Ribbon'
        ),
        XmlMappedEnumMember(
            'LEFT_RIGHT_UP_ARROW', 40, 'leftRightUpArrow',
            'Block arrow with arrowheads that point left, right, and up'
        ),
        XmlMappedEnumMember(
            'LEFT_UP_ARROW', 43, 'leftUpArrow',
            'Block arrow with arrowheads that point left and up'
        ),
        XmlMappedEnumMember(
            'LIGHTNING_BOLT', 22, 'lightningBolt', 'Lightning bolt'
        ),
        XmlMappedEnumMember(
            'LINE_CALLOUT_1', 109, 'borderCallout1',
            'Callout with border and horizontal callout line'
        ),
        XmlMappedEnumMember(
            'LINE_CALLOUT_1_ACCENT_BAR', 113, 'accentCallout1',
            'Callout with vertical accent bar'
        ),
        XmlMappedEnumMember(
            'LINE_CALLOUT_1_BORDER_AND_ACCENT_BAR', 121,
            'accentBorderCallout1',
            'Callout with border and vertical accent bar'
        ),
        XmlMappedEnumMember(
            'LINE_CALLOUT_1_NO_BORDER', 117, 'callout1',
            'Callout with horizontal line'
        ),
        XmlMappedEnumMember(
            'LINE_CALLOUT_2', 110, 'borderCallout2',
            'Callout with diagonal straight line'
        ),
        XmlMappedEnumMember(
            'LINE_CALLOUT_2_ACCENT_BAR', 114, 'accentCallout2',
            'Callout with diagonal callout line and accent bar'
        ),
        XmlMappedEnumMember(
            'LINE_CALLOUT_2_BORDER_AND_ACCENT_BAR', 122,
            'accentBorderCallout2',
            'Callout with border, diagonal straight line, and accent bar'
        ),
        XmlMappedEnumMember(
            'LINE_CALLOUT_2_NO_BORDER', 118, 'callout2',
            'Callout with no border and diagonal callout line'
        ),
        XmlMappedEnumMember(
            'LINE_CALLOUT_3', 111, 'borderCallout3', 'Callout with angled line'
        ),
        XmlMappedEnumMember(
            'LINE_CALLOUT_3_ACCENT_BAR', 115, 'accentCallout3',
            'Callout with angled callout line and accent bar'
        ),
        XmlMappedEnumMember(
            'LINE_CALLOUT_3_BORDER_AND_ACCENT_BAR', 123,
            'accentBorderCallout3',
            'Callout with border, angled callout line, and accent bar'
        ),
        XmlMappedEnumMember(
            'LINE_CALLOUT_3_NO_BORDER', 119, 'callout3',
            'Callout with no border and angled callout line'
        ),
        XmlMappedEnumMember(
            'LINE_CALLOUT_4', 112, 'borderCallout3',
            'Callout with callout line segments forming a U-shape.'
        ),
        XmlMappedEnumMember(
            'LINE_CALLOUT_4_ACCENT_BAR', 116, 'accentCallout3',
            'Callout with accent bar and callout line segments forming a U-s'
            'hape.'
        ),
        XmlMappedEnumMember(
            'LINE_CALLOUT_4_BORDER_AND_ACCENT_BAR', 124,
            'accentBorderCallout3',
            'Callout with border, accent bar, and callout line segments form'
            'ing a U-shape.'
        ),
        XmlMappedEnumMember(
            'LINE_CALLOUT_4_NO_BORDER', 120, 'callout3',
            'Callout with no border and callout line segments forming a U-sh'
            'ape.'
        ),
        XmlMappedEnumMember(
            'LINE_INVERSE', 183, 'lineInv', 'Straight Connector'
        ),
        XmlMappedEnumMember(
            'MATH_DIVIDE', 166, 'mathDivide', 'Division'
        ),
        XmlMappedEnumMember(
            'MATH_EQUAL', 167, 'mathEqual', 'Equal'
        ),
        XmlMappedEnumMember(
            'MATH_MINUS', 164, 'mathMinus', 'Minus'
        ),
        XmlMappedEnumMember(
            'MATH_MULTIPLY', 165, 'mathMultiply', 'Multiply'
        ),
        XmlMappedEnumMember(
            'MATH_NOT_EQUAL', 168, 'mathNotEqual', 'Not Equal'
        ),
        XmlMappedEnumMember(
            'MATH_PLUS', 163, 'mathPlus', 'Plus'
        ),
        XmlMappedEnumMember(
            'MOON', 24, 'moon', 'Moon'
        ),
        XmlMappedEnumMember(
            'NON_ISOSCELES_TRAPEZOID', 143, 'nonIsoscelesTrapezoid',
            'Non-isosceles Trapezoid'
        ),
        XmlMappedEnumMember(
            'NOTCHED_RIGHT_ARROW', 50, 'notchedRightArrow',
            'Notched block arrow that points right'
        ),
        XmlMappedEnumMember(
            'NO_SYMBOL', 19, 'noSmoking', '"No" symbol'
        ),
        XmlMappedEnumMember(
            'OCTAGON', 6, 'octagon', 'Octagon'
        ),
        XmlMappedEnumMember(
            'OVAL', 9, 'ellipse', 'Oval'
        ),
        XmlMappedEnumMember(
            'OVAL_CALLOUT', 107, 'wedgeEllipseCallout', 'Oval-shaped callout'
        ),
        XmlMappedEnumMember(
            'PARALLELOGRAM', 2, 'parallelogram', 'Parallelogram'
        ),
        XmlMappedEnumMember(
            'PENTAGON', 51, 'homePlate', 'Pentagon'
        ),
        XmlMappedEnumMember(
            'PIE', 142, 'pie', 'Pie'
        ),
        XmlMappedEnumMember(
            'PIE_WEDGE', 175, 'pieWedge', 'Pie'
        ),
        XmlMappedEnumMember(
            'PLAQUE', 28, 'plaque', 'Plaque'
        ),
        XmlMappedEnumMember(
            'PLAQUE_TABS', 171, 'plaqueTabs', 'Plaque Tabs'
        ),
        XmlMappedEnumMember(
            'QUAD_ARROW', 39, 'quadArrow',
            'Block arrows that point up, down, left, and right'
        ),
        XmlMappedEnumMember(
            'QUAD_ARROW_CALLOUT', 59, 'quadArrowCallout',
            'Callout with arrows that point up, down, left, and right'
        ),
        XmlMappedEnumMember(
            'RECTANGLE', 1, 'rect', 'Rectangle'
        ),
        XmlMappedEnumMember(
            'RECTANGULAR_CALLOUT', 105, 'wedgeRectCallout',
            'Rectangular callout'
        ),
        XmlMappedEnumMember(
            'REGULAR_PENTAGON', 12, 'pentagon', 'Pentagon'
        ),
        XmlMappedEnumMember(
            'RIGHT_ARROW', 33, 'rightArrow', 'Block arrow that points right'
        ),
        XmlMappedEnumMember(
            'RIGHT_ARROW_CALLOUT', 53, 'rightArrowCallout',
            'Callout with arrow that points right'
        ),
        XmlMappedEnumMember(
            'RIGHT_BRACE', 32, 'rightBrace', 'Right brace'
        ),
        XmlMappedEnumMember(
            'RIGHT_BRACKET', 30, 'rightBracket', 'Right bracket'
        ),
        XmlMappedEnumMember(
            'RIGHT_TRIANGLE', 8, 'rtTriangle', 'Right triangle'
        ),
        XmlMappedEnumMember(
            'ROUNDED_RECTANGLE', 5, 'roundRect', 'Rounded rectangle'
        ),
        XmlMappedEnumMember(
            'ROUNDED_RECTANGULAR_CALLOUT', 106, 'wedgeRoundRectCallout',
            'Rounded rectangle-shaped callout'
        ),
        XmlMappedEnumMember(
            'ROUND_1_RECTANGLE', 151, 'round1Rect',
            'Round Single Corner Rectangle'
        ),
        XmlMappedEnumMember(
            'ROUND_2_DIAG_RECTANGLE', 153, 'round2DiagRect',
            'Round Diagonal Corner Rectangle'
        ),
        XmlMappedEnumMember(
            'ROUND_2_SAME_RECTANGLE', 152, 'round2SameRect',
            'Round Same Side Corner Rectangle'
        ),
        XmlMappedEnumMember(
            'SMILEY_FACE', 17, 'smileyFace', 'Smiley face'
        ),
        XmlMappedEnumMember(
            'SNIP_1_RECTANGLE', 155, 'snip1Rect',
            'Snip Single Corner Rectangle'
        ),
        XmlMappedEnumMember(
            'SNIP_2_DIAG_RECTANGLE', 157, 'snip2DiagRect',
            'Snip Diagonal Corner Rectangle'
        ),
        XmlMappedEnumMember(
            'SNIP_2_SAME_RECTANGLE', 156, 'snip2SameRect',
            'Snip Same Side Corner Rectangle'
        ),
        XmlMappedEnumMember(
            'SNIP_ROUND_RECTANGLE', 154, 'snipRoundRect',
            'Snip and Round Single Corner Rectangle'
        ),
        XmlMappedEnumMember(
            'SQUARE_TABS', 170, 'squareTabs', 'Square Tabs'
        ),
        XmlMappedEnumMember(
            'STAR_10_POINT', 149, 'star10', '10-Point Star'
        ),
        XmlMappedEnumMember(
            'STAR_12_POINT', 150, 'star12', '12-Point Star'
        ),
        XmlMappedEnumMember(
            'STAR_16_POINT', 94, 'star16', '16-point star'
        ),
        XmlMappedEnumMember(
            'STAR_24_POINT', 95, 'star24', '24-point star'
        ),
        XmlMappedEnumMember(
            'STAR_32_POINT', 96, 'star32', '32-point star'
        ),
        XmlMappedEnumMember(
            'STAR_4_POINT', 91, 'star4', '4-point star'
        ),
        XmlMappedEnumMember(
            'STAR_5_POINT', 92, 'star5', '5-point star'
        ),
        XmlMappedEnumMember(
            'STAR_6_POINT', 147, 'star6', '6-Point Star'
        ),
        XmlMappedEnumMember(
            'STAR_7_POINT', 148, 'star7', '7-Point Star'
        ),
        XmlMappedEnumMember(
            'STAR_8_POINT', 93, 'star8', '8-point star'
        ),
        XmlMappedEnumMember(
            'STRIPED_RIGHT_ARROW', 49, 'stripedRightArrow',
            'Block arrow that points right with stripes at the tail'
        ),
        XmlMappedEnumMember(
            'SUN', 23, 'sun', 'Sun'
        ),
        XmlMappedEnumMember(
            'SWOOSH_ARROW', 178, 'swooshArrow', 'Swoosh Arrow'
        ),
        XmlMappedEnumMember(
            'TEAR', 160, 'teardrop', 'Teardrop'
        ),
        XmlMappedEnumMember(
            'TRAPEZOID', 3, 'trapezoid', 'Trapezoid'
        ),
        XmlMappedEnumMember(
            'UP_ARROW', 35, 'upArrow', 'Block arrow that points up'
        ),
        XmlMappedEnumMember(
            'UP_ARROW_CALLOUT', 55, 'upArrowCallout',
            'Callout with arrow that points up'
        ),
        XmlMappedEnumMember(
            'UP_DOWN_ARROW', 38, 'upDownArrow',
            'Block arrow that points up and down'
        ),
        XmlMappedEnumMember(
            'UP_DOWN_ARROW_CALLOUT', 58, 'upDownArrowCallout',
            'Callout with arrows that point up and down'
        ),
        XmlMappedEnumMember(
            'UP_RIBBON', 97, 'ribbon2',
            'Ribbon banner with center area above ribbon ends'
        ),
        XmlMappedEnumMember(
            'U_TURN_ARROW', 42, 'uturnArrow', 'Block arrow forming a U shape'
        ),
        XmlMappedEnumMember(
            'VERTICAL_SCROLL', 101, 'verticalScroll', 'Vertical scroll'
        ),
        XmlMappedEnumMember(
            'WAVE', 103, 'wave', 'Wave'
        ),
    )


@alias('MSO')
class MSO_SHAPE_TYPE(Enumeration):
    """
    Specifies the type of a shape

    Alias: ``MSO``

    Example::

        from pptx.enum.shapes import MSO_SHAPE_TYPE

        assert shape.type == MSO_SHAPE_TYPE.PICTURE
    """

    __ms_name__ = 'MsoShapeType'

    __url__ = (
        'http://msdn.microsoft.com/en-us/library/office/ff860759(v=office.15'
        ').aspx'
    )

    __members__ = (
        EnumMember(
            'AUTO_SHAPE', 1, 'AutoShape'
        ),
        EnumMember(
            'CALLOUT', 2, 'Callout shape'
        ),
        EnumMember(
            'CANVAS', 20, 'Drawing canvas'
        ),
        EnumMember(
            'CHART', 3, 'Chart, e.g. pie chart, bar chart'
        ),
        EnumMember(
            'COMMENT', 4, 'Comment'
        ),
        EnumMember(
            'DIAGRAM', 21, 'Diagram'
        ),
        EnumMember(
            'EMBEDDED_OLE_OBJECT', 7, 'Embedded OLE object'
        ),
        EnumMember(
            'FORM_CONTROL', 8, 'Form control'
        ),
        EnumMember(
            'FREEFORM', 5, 'Freeform'
        ),
        EnumMember(
            'GROUP', 6, 'Group shape'
        ),
        EnumMember(
            'IGX_GRAPHIC', 24, 'SmartArt graphic'
        ),
        EnumMember(
            'INK', 22, 'Ink'
        ),
        EnumMember(
            'INK_COMMENT', 23, 'Ink Comment'
        ),
        EnumMember(
            'LINE', 9, 'Line'
        ),
        EnumMember(
            'LINKED_OLE_OBJECT', 10, 'Linked OLE object'
        ),
        EnumMember(
            'LINKED_PICTURE', 11, 'Linked picture'
        ),
        EnumMember(
            'MEDIA', 16, 'Media'
        ),
        EnumMember(
            'OLE_CONTROL_OBJECT', 12, 'OLE control object'
        ),
        EnumMember(
            'PICTURE', 13, 'Picture'
        ),
        EnumMember(
            'PLACEHOLDER', 14, 'Placeholder'
        ),
        EnumMember(
            'SCRIPT_ANCHOR', 18, 'Script anchor'
        ),
        EnumMember(
            'TABLE', 19, 'Table'
        ),
        EnumMember(
            'TEXT_BOX', 17, 'Text box'
        ),
        EnumMember(
            'TEXT_EFFECT', 15, 'Text effect'
        ),
        EnumMember(
            'WEB_VIDEO', 26, 'Web video'
        ),
        ReturnValueOnlyEnumMember(
            'MIXED', -2, 'Mixed shape types'
        ),
    )


@alias('PP_PLACEHOLDER')
class PP_PLACEHOLDER_TYPE(Enumeration):
    """
    Specifies one of the 18 distinct types of placeholder.

    Alias: ``PP_PLACEHOLDER``

    Example::

        from pptx.enum.shapes import PP_PLACEHOLDER

        placeholder = slide.placeholders[0]
        assert placeholder.type == PP_PLACEHOLDER.TITLE
    """

    __ms_name__ = 'PpPlaceholderType'

    __url__ = (
        'http://msdn.microsoft.com/en-us/library/office/ff860759(v=office.15'
        ').aspx'
    )

    __members__ = (
        EnumMember(
            'BITMAP', 9, 'Clip art placeholder'
        ),
        EnumMember(
            'BODY', 2, 'Body'
        ),
        EnumMember(
            'CENTER_TITLE', 3, 'Center Title'
        ),
        EnumMember(
            'CHART', 8, 'Chart'
        ),
        EnumMember(
            'DATE', 16, 'Date'
        ),
        EnumMember(
            'FOOTER', 15, 'Footer'
        ),
        EnumMember(
            'HEADER', 14, 'Header'
        ),
        EnumMember(
            'MEDIA_CLIP', 10, 'Media Clip'
        ),
        EnumMember(
            'OBJECT', 7, 'Object'
        ),
        EnumMember(
            'ORG_CHART', 11, 'SmartArt placeholder. Organization chart is a '
            'legacy name.'
        ),
        EnumMember(
            'PICTURE', 18, 'Picture'
        ),
        EnumMember(
            'SLIDE_NUMBER', 13, 'Slide Number'
        ),
        EnumMember(
            'SUBTITLE', 4, 'Subtitle'
        ),
        EnumMember(
            'TABLE', 12, 'Table'
        ),
        EnumMember(
            'TITLE', 1, 'Title'
        ),
        EnumMember(
            'VERTICAL_BODY', 6, 'Vertical Body'
        ),
        EnumMember(
            'VERTICAL_OBJECT', 17, 'Vertical Object'
        ),
        EnumMember(
            'VERTICAL_TITLE', 5, 'Vertical Title'
        ),
        ReturnValueOnlyEnumMember(
            'MIXED', -2, 'Return value only; multiple placeholders of differ'
            'ing types.'
        ),
    )

########NEW FILE########
__FILENAME__ = text
# encoding: utf-8

"""
Enumerations used by text and related objects
"""

from __future__ import absolute_import

from .base import (
    alias, Enumeration, EnumMember, ReturnValueOnlyEnumMember,
    XmlEnumeration, XmlMappedEnumMember
)


class MSO_AUTO_SIZE(Enumeration):
    """
    Determines the type of automatic sizing allowed.

    The following names can be used to specify the automatic sizing behavior
    used to fit a shape's text within the shape bounding box, for example::

        from pptx.enum.text import MSO_AUTO_SIZE

        shape.textframe.auto_size = MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE

    The word-wrap setting of the textframe interacts with the auto-size setting
    to determine the specific auto-sizing behavior.

    Note that ``TextFrame.auto_size`` can also be set to |None|, which removes
    the auto size setting altogether. This causes the setting to be inherited,
    either from the layout placeholder, in the case of a placeholder shape, or
    from the theme.
    """
    """
    Corresponds to MsoAutoSize enumeration
    http://msdn.microsoft.com/en-us/library/office/ff865367(v=office.15).aspx
    """
    NONE = 0
    SHAPE_TO_FIT_TEXT = 1
    TEXT_TO_FIT_SHAPE = 2

    __ms_name__ = 'MsoAutoSize'

    __url__ = (
        'http://msdn.microsoft.com/en-us/library/office/ff865367(v=office.15'
        ').aspx'
    )

    __members__ = (
        EnumMember(
            'NONE', 0, 'No automatic sizing of the shape or text will be don'
            'e. Text can freely extend beyond the horizontal and vertical ed'
            'ges of the shape bounding box.'
        ),
        EnumMember(
            'SHAPE_TO_FIT_TEXT', 1, 'The shape height and possibly width are'
            ' adjusted to fit the text. Note this setting interacts with the'
            ' TextFrame.word_wrap property setting. If word wrap is turned o'
            'n, only the height of the shape will be adjusted; soft line bre'
            'aks will be used to fit the text horizontally.'
        ),
        EnumMember(
            'TEXT_TO_FIT_SHAPE', 2, 'The font size is reduced as necessary t'
            'o fit the text within the shape.'
        ),
        ReturnValueOnlyEnumMember(
            'MIXED', -2, 'Return value only; indicates a combination of auto'
            'matic sizing schemes are used.'
        ),
    )


@alias('MSO_ANCHOR')
class MSO_VERTICAL_ANCHOR(XmlEnumeration):
    """
    Specifies the vertical alignment of text in a text frame. Used with the
    ``.vertical_anchor`` property of the |TextFrame| object. Note that the
    ``vertical_anchor`` property can also have the value None, indicating
    there is no directly specified vertical anchor setting and its effective
    value is inherited from its placeholder if it has one or from the theme.
    None may also be assigned to remove an explicitly specified vertical
    anchor setting.
    """

    __ms_name__ = 'MsoVerticalAnchor'

    __url__ = 'http://msdn.microsoft.com/en-us/library/office/ff865255.aspx'

    __members__ = (
        XmlMappedEnumMember(
            None, None, None, 'Text frame has no vertical anchor specified '
            'and inherits its value from its layout placeholder or theme.'
        ),
        XmlMappedEnumMember(
            'TOP', 1, 't', 'Aligns text to top of text frame'
            ' and inherits its value from its layout placeholder or theme.'
        ),
        XmlMappedEnumMember(
            'MIDDLE', 3, 'ctr', 'Centers text vertically'
        ),
        XmlMappedEnumMember(
            'BOTTOM', 4, 'b', 'Aligns text to bottom of text frame'
        ),
        ReturnValueOnlyEnumMember(
            'MIXED', -2, 'Return value only; indicates a combination of the '
            'other states.'
        ),
    )


@alias('PP_ALIGN')
class PP_PARAGRAPH_ALIGNMENT(XmlEnumeration):
    """
    Specifies the horizontal alignment for one or more paragraphs.

    Alias: ``PP_ALIGN``

    Example::

        from pptx.enum.text import PP_ALIGN

        shape.paragraphs[0].alignment = PP_ALIGN.CENTER
    """

    __ms_name__ = 'PpParagraphAlignment'

    __url__ = (
        'http://msdn.microsoft.com/en-us/library/office/ff745375(v=office.15'
        ').aspx'
    )

    __members__ = (
        XmlMappedEnumMember(
            None, None, None, 'No alignment setting on paragraph element'
        ),
        XmlMappedEnumMember(
            'CENTER', 2, 'ctr', 'Center align'
        ),
        XmlMappedEnumMember(
            'DISTRIBUTE', 5, 'dist', 'Evenly distributes e.g. Japanese chara'
            'cters from left to right within a line'
        ),
        XmlMappedEnumMember(
            'JUSTIFY', 4, 'just', 'Justified, i.e. each line both begins and'
            ' ends at the margin with spacing between words adjusted such th'
            'at the line exactly fills the width of the paragraph.'
        ),
        XmlMappedEnumMember(
            'JUSTIFY_LOW', 7, 'justLow', 'Justify using a small amount of sp'
            'ace between words.'
        ),
        XmlMappedEnumMember(
            'LEFT', 1, 'l', 'Left aligned'
        ),
        XmlMappedEnumMember(
            'RIGHT', 3, 'r', 'Right aligned'
        ),
        XmlMappedEnumMember(
            'THAI_DISTRIBUTE', 6, 'thaiDist', 'Thai distributed'
        ),
        ReturnValueOnlyEnumMember(
            'MIXED', -2, 'Return value only; indicates multiple paragraph al'
            'ignments are present in a set of paragraphs.'
        ),
    )

########NEW FILE########
__FILENAME__ = exc
# encoding: utf-8

"""
Exceptions used with python-pptx.

The base exception class is PythonPptxError.
"""


class PythonPptxError(Exception):
    """Generic error class."""


class NotXMLError(PythonPptxError):
    """
    Raised when an XML operation (such as parsing) is attempted on a binary
    package item.
    """


class PackageNotFoundError(PythonPptxError):
    """
    Raised when a package cannot be found at the specified path.
    """

########NEW FILE########
__FILENAME__ = constants
# encoding: utf-8

"""
Constant values related to the Open Packaging Convention, in particular,
content types and relationship types.
"""


class CONTENT_TYPE(object):
    """
    Content type URIs (like MIME-types) that specify a part's format
    """
    BMP = (
        'image/bmp'
    )
    DML_CHART = (
        'application/vnd.openxmlformats-officedocument.drawingml.chart+xml'
    )
    DML_CHARTSHAPES = (
        'application/vnd.openxmlformats-officedocument.drawingml.chartshapes'
        '+xml'
    )
    DML_DIAGRAM_COLORS = (
        'application/vnd.openxmlformats-officedocument.drawingml.diagramColo'
        'rs+xml'
    )
    DML_DIAGRAM_DATA = (
        'application/vnd.openxmlformats-officedocument.drawingml.diagramData'
        '+xml'
    )
    DML_DIAGRAM_LAYOUT = (
        'application/vnd.openxmlformats-officedocument.drawingml.diagramLayo'
        'ut+xml'
    )
    DML_DIAGRAM_STYLE = (
        'application/vnd.openxmlformats-officedocument.drawingml.diagramStyl'
        'e+xml'
    )
    GIF = (
        'image/gif'
    )
    JPEG = (
        'image/jpeg'
    )
    MS_PHOTO = (
        'image/vnd.ms-photo'
    )
    OFC_CUSTOM_PROPERTIES = (
        'application/vnd.openxmlformats-officedocument.custom-properties+xml'
    )
    OFC_CUSTOM_XML_PROPERTIES = (
        'application/vnd.openxmlformats-officedocument.customXmlProperties+x'
        'ml'
    )
    OFC_DRAWING = (
        'application/vnd.openxmlformats-officedocument.drawing+xml'
    )
    OFC_EXTENDED_PROPERTIES = (
        'application/vnd.openxmlformats-officedocument.extended-properties+x'
        'ml'
    )
    OFC_OLE_OBJECT = (
        'application/vnd.openxmlformats-officedocument.oleObject'
    )
    OFC_PACKAGE = (
        'application/vnd.openxmlformats-officedocument.package'
    )
    OFC_THEME = (
        'application/vnd.openxmlformats-officedocument.theme+xml'
    )
    OFC_THEME_OVERRIDE = (
        'application/vnd.openxmlformats-officedocument.themeOverride+xml'
    )
    OFC_VML_DRAWING = (
        'application/vnd.openxmlformats-officedocument.vmlDrawing'
    )
    OPC_CORE_PROPERTIES = (
        'application/vnd.openxmlformats-package.core-properties+xml'
    )
    OPC_DIGITAL_SIGNATURE_CERTIFICATE = (
        'application/vnd.openxmlformats-package.digital-signature-certificat'
        'e'
    )
    OPC_DIGITAL_SIGNATURE_ORIGIN = (
        'application/vnd.openxmlformats-package.digital-signature-origin'
    )
    OPC_DIGITAL_SIGNATURE_XMLSIGNATURE = (
        'application/vnd.openxmlformats-package.digital-signature-xmlsignatu'
        're+xml'
    )
    OPC_RELATIONSHIPS = (
        'application/vnd.openxmlformats-package.relationships+xml'
    )
    PML_COMMENTS = (
        'application/vnd.openxmlformats-officedocument.presentationml.commen'
        'ts+xml'
    )
    PML_COMMENT_AUTHORS = (
        'application/vnd.openxmlformats-officedocument.presentationml.commen'
        'tAuthors+xml'
    )
    PML_HANDOUT_MASTER = (
        'application/vnd.openxmlformats-officedocument.presentationml.handou'
        'tMaster+xml'
    )
    PML_NOTES_MASTER = (
        'application/vnd.openxmlformats-officedocument.presentationml.notesM'
        'aster+xml'
    )
    PML_NOTES_SLIDE = (
        'application/vnd.openxmlformats-officedocument.presentationml.notesS'
        'lide+xml'
    )
    PML_PRESENTATION_MAIN = (
        'application/vnd.openxmlformats-officedocument.presentationml.presen'
        'tation.main+xml'
    )
    PML_PRES_PROPS = (
        'application/vnd.openxmlformats-officedocument.presentationml.presPr'
        'ops+xml'
    )
    PML_PRINTER_SETTINGS = (
        'application/vnd.openxmlformats-officedocument.presentationml.printe'
        'rSettings'
    )
    PML_SLIDE = (
        'application/vnd.openxmlformats-officedocument.presentationml.slide+'
        'xml'
    )
    PML_SLIDESHOW_MAIN = (
        'application/vnd.openxmlformats-officedocument.presentationml.slides'
        'how.main+xml'
    )
    PML_SLIDE_LAYOUT = (
        'application/vnd.openxmlformats-officedocument.presentationml.slideL'
        'ayout+xml'
    )
    PML_SLIDE_MASTER = (
        'application/vnd.openxmlformats-officedocument.presentationml.slideM'
        'aster+xml'
    )
    PML_SLIDE_UPDATE_INFO = (
        'application/vnd.openxmlformats-officedocument.presentationml.slideU'
        'pdateInfo+xml'
    )
    PML_TABLE_STYLES = (
        'application/vnd.openxmlformats-officedocument.presentationml.tableS'
        'tyles+xml'
    )
    PML_TAGS = (
        'application/vnd.openxmlformats-officedocument.presentationml.tags+x'
        'ml'
    )
    PML_TEMPLATE_MAIN = (
        'application/vnd.openxmlformats-officedocument.presentationml.templa'
        'te.main+xml'
    )
    PML_VIEW_PROPS = (
        'application/vnd.openxmlformats-officedocument.presentationml.viewPr'
        'ops+xml'
    )
    PNG = (
        'image/png'
    )
    SML_CALC_CHAIN = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.calcCha'
        'in+xml'
    )
    SML_CHARTSHEET = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.chartsh'
        'eet+xml'
    )
    SML_COMMENTS = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.comment'
        's+xml'
    )
    SML_CONNECTIONS = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.connect'
        'ions+xml'
    )
    SML_CUSTOM_PROPERTY = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.customP'
        'roperty'
    )
    SML_DIALOGSHEET = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.dialogs'
        'heet+xml'
    )
    SML_EXTERNAL_LINK = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.externa'
        'lLink+xml'
    )
    SML_PIVOT_CACHE_DEFINITION = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCa'
        'cheDefinition+xml'
    )
    SML_PIVOT_CACHE_RECORDS = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCa'
        'cheRecords+xml'
    )
    SML_PIVOT_TABLE = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTa'
        'ble+xml'
    )
    SML_PRINTER_SETTINGS = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.printer'
        'Settings'
    )
    SML_QUERY_TABLE = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.queryTa'
        'ble+xml'
    )
    SML_REVISION_HEADERS = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.revisio'
        'nHeaders+xml'
    )
    SML_REVISION_LOG = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.revisio'
        'nLog+xml'
    )
    SML_SHARED_STRINGS = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedS'
        'trings+xml'
    )
    SML_SHEET = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    )
    SML_SHEET_MAIN = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.m'
        'ain+xml'
    )
    SML_SHEET_METADATA = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMe'
        'tadata+xml'
    )
    SML_STYLES = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+'
        'xml'
    )
    SML_TABLE = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.table+x'
        'ml'
    )
    SML_TABLE_SINGLE_CELLS = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.tableSi'
        'ngleCells+xml'
    )
    SML_TEMPLATE_MAIN = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.templat'
        'e.main+xml'
    )
    SML_USER_NAMES = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.userNam'
        'es+xml'
    )
    SML_VOLATILE_DEPENDENCIES = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.volatil'
        'eDependencies+xml'
    )
    SML_WORKSHEET = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.workshe'
        'et+xml'
    )
    TIFF = (
        'image/tiff'
    )
    WML_COMMENTS = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.comm'
        'ents+xml'
    )
    WML_DOCUMENT_GLOSSARY = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.docu'
        'ment.glossary+xml'
    )
    WML_DOCUMENT_MAIN = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.docu'
        'ment.main+xml'
    )
    WML_ENDNOTES = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.endn'
        'otes+xml'
    )
    WML_FONT_TABLE = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.font'
        'Table+xml'
    )
    WML_FOOTER = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.foot'
        'er+xml'
    )
    WML_FOOTNOTES = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.foot'
        'notes+xml'
    )
    WML_HEADER = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.head'
        'er+xml'
    )
    WML_NUMBERING = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.numb'
        'ering+xml'
    )
    WML_PRINTER_SETTINGS = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.prin'
        'terSettings'
    )
    WML_SETTINGS = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.sett'
        'ings+xml'
    )
    WML_STYLES = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.styl'
        'es+xml'
    )
    WML_WEB_SETTINGS = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.webS'
        'ettings+xml'
    )
    XML = (
        'application/xml'
    )
    X_EMF = (
        'image/x-emf'
    )
    X_FONTDATA = (
        'application/x-fontdata'
    )
    X_FONT_TTF = (
        'application/x-font-ttf'
    )
    X_WMF = (
        'image/x-wmf'
    )


class NAMESPACE(object):
    """Constant values for OPC XML namespaces"""
    DML_WORDPROCESSING_DRAWING = (
        'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDraw'
        'ing'
    )
    OFC_RELATIONSHIPS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
    )
    OPC_RELATIONSHIPS = (
        'http://schemas.openxmlformats.org/package/2006/relationships'
    )
    OPC_CONTENT_TYPES = (
        'http://schemas.openxmlformats.org/package/2006/content-types'
    )
    WML_MAIN = (
        'http://schemas.openxmlformats.org/wordprocessingml/2006/main'
    )


class RELATIONSHIP_TARGET_MODE(object):
    """Open XML relationship target modes"""
    EXTERNAL = 'External'
    INTERNAL = 'Internal'


class RELATIONSHIP_TYPE(object):
    AUDIO = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/audio'
    )
    A_F_CHUNK = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/aFChunk'
    )
    CALC_CHAIN = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/calcChain'
    )
    CERTIFICATE = (
        'http://schemas.openxmlformats.org/package/2006/relationships/digita'
        'l-signature/certificate'
    )
    CHART = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/chart'
    )
    CHARTSHEET = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/chartsheet'
    )
    CHART_USER_SHAPES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/chartUserShapes'
    )
    COMMENTS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/comments'
    )
    COMMENT_AUTHORS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/commentAuthors'
    )
    CONNECTIONS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/connections'
    )
    CONTROL = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/control'
    )
    CORE_PROPERTIES = (
        'http://schemas.openxmlformats.org/package/2006/relationships/metada'
        'ta/core-properties'
    )
    CUSTOM_PROPERTIES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/custom-properties'
    )
    CUSTOM_PROPERTY = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/customProperty'
    )
    CUSTOM_XML = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/customXml'
    )
    CUSTOM_XML_PROPS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/customXmlProps'
    )
    DIAGRAM_COLORS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/diagramColors'
    )
    DIAGRAM_DATA = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/diagramData'
    )
    DIAGRAM_LAYOUT = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/diagramLayout'
    )
    DIAGRAM_QUICK_STYLE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/diagramQuickStyle'
    )
    DIALOGSHEET = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/dialogsheet'
    )
    DRAWING = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/drawing'
    )
    ENDNOTES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/endnotes'
    )
    EXTENDED_PROPERTIES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/extended-properties'
    )
    EXTERNAL_LINK = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/externalLink'
    )
    FONT = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/font'
    )
    FONT_TABLE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/fontTable'
    )
    FOOTER = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/footer'
    )
    FOOTNOTES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/footnotes'
    )
    GLOSSARY_DOCUMENT = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/glossaryDocument'
    )
    HANDOUT_MASTER = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/handoutMaster'
    )
    HEADER = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/header'
    )
    HYPERLINK = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/hyperlink'
    )
    IMAGE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/image'
    )
    NOTES_MASTER = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/notesMaster'
    )
    NOTES_SLIDE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/notesSlide'
    )
    NUMBERING = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/numbering'
    )
    OFFICE_DOCUMENT = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/officeDocument'
    )
    OLE_OBJECT = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/oleObject'
    )
    ORIGIN = (
        'http://schemas.openxmlformats.org/package/2006/relationships/digita'
        'l-signature/origin'
    )
    PACKAGE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/package'
    )
    PIVOT_CACHE_DEFINITION = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/pivotCacheDefinition'
    )
    PIVOT_CACHE_RECORDS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/spreadsheetml/pivotCacheRecords'
    )
    PIVOT_TABLE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/pivotTable'
    )
    PRES_PROPS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/presProps'
    )
    PRINTER_SETTINGS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/printerSettings'
    )
    QUERY_TABLE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/queryTable'
    )
    REVISION_HEADERS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/revisionHeaders'
    )
    REVISION_LOG = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/revisionLog'
    )
    SETTINGS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/settings'
    )
    SHARED_STRINGS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/sharedStrings'
    )
    SHEET_METADATA = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/sheetMetadata'
    )
    SIGNATURE = (
        'http://schemas.openxmlformats.org/package/2006/relationships/digita'
        'l-signature/signature'
    )
    SLIDE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/slide'
    )
    SLIDE_LAYOUT = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/slideLayout'
    )
    SLIDE_MASTER = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/slideMaster'
    )
    SLIDE_UPDATE_INFO = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/slideUpdateInfo'
    )
    STYLES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/styles'
    )
    TABLE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/table'
    )
    TABLE_SINGLE_CELLS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/tableSingleCells'
    )
    TABLE_STYLES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/tableStyles'
    )
    TAGS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/tags'
    )
    THEME = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/theme'
    )
    THEME_OVERRIDE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/themeOverride'
    )
    THUMBNAIL = (
        'http://schemas.openxmlformats.org/package/2006/relationships/metada'
        'ta/thumbnail'
    )
    USERNAMES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/usernames'
    )
    VIDEO = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/video'
    )
    VIEW_PROPS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/viewProps'
    )
    VML_DRAWING = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/vmlDrawing'
    )
    VOLATILE_DEPENDENCIES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/volatileDependencies'
    )
    WEB_SETTINGS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/webSettings'
    )
    WORKSHEET_SOURCE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/worksheetSource'
    )
    XML_MAPS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/xmlMaps'
    )

########NEW FILE########
__FILENAME__ = oxml
# encoding: utf-8

"""
Temporary stand-in for main oxml module that came across with the
PackageReader transplant. Probably much will get replaced with objects from
the pptx.oxml.core and then this module will either get deleted or only hold
the package related custom element classes.
"""

from __future__ import absolute_import

from lxml import etree, objectify

from .constants import NAMESPACE as NS, RELATIONSHIP_TARGET_MODE as RTM


# configure objectified XML parser
fallback_lookup = objectify.ObjectifyElementClassLookup()
element_class_lookup = etree.ElementNamespaceClassLookup(fallback_lookup)
oxml_parser = etree.XMLParser(remove_blank_text=True)
oxml_parser.set_element_class_lookup(element_class_lookup)

nsmap = {
    'ct': NS.OPC_CONTENT_TYPES,
    'pr': NS.OPC_RELATIONSHIPS,
    'r':  NS.OFC_RELATIONSHIPS,
}


# ===========================================================================
# functions
# ===========================================================================

def oxml_fromstring(text):
    """``etree.fromstring()`` replacement that uses oxml parser"""
    return objectify.fromstring(text, oxml_parser)


def oxml_tostring(elm, encoding=None, pretty_print=False, standalone=None):
    # if xsi parameter is not set to False, PowerPoint won't load without a
    # repair step; deannotate removes some original xsi:type tags in core.xml
    # if this parameter is left out (or set to True)
    objectify.deannotate(elm, xsi=False, cleanup_namespaces=True)
    return etree.tostring(elm, encoding=encoding, pretty_print=pretty_print,
                          standalone=standalone)


def serialize_part_xml(part_elm):
    # if xsi parameter is not set to False, PowerPoint won't load without a
    # repair step; deannotate removes some original xsi:type tags in core.xml
    # if this parameter is left out (or set to True)
    objectify.deannotate(part_elm, xsi=False, cleanup_namespaces=False)
    xml = etree.tostring(part_elm, encoding='UTF-8', standalone=True)
    return xml


# ===========================================================================
# Custom element classes
# ===========================================================================

class OxmlBaseElement(objectify.ObjectifiedElement):
    """
    Base class for all custom element classes, to add standardized behavior
    to all classes in one place.
    """
    @property
    def xml(self):
        """
        Return XML string for this element, suitable for testing purposes.
        Pretty printed for readability and without an XML declaration at the
        top.
        """
        return oxml_tostring(self, encoding='unicode', pretty_print=True)


class CT_Default(OxmlBaseElement):
    """
    ``<Default>`` element, specifying the default content type to be applied
    to a part with the specified extension.
    """
    @property
    def content_type(self):
        """
        String held in the ``ContentType`` attribute of this ``<Default>``
        element.
        """
        return self.get('ContentType')

    @property
    def extension(self):
        """
        String held in the ``Extension`` attribute of this ``<Default>``
        element.
        """
        return self.get('Extension')

    @staticmethod
    def new(ext, content_type):
        """
        Return a new ``<Default>`` element with attributes set to parameter
        values.
        """
        xml = '<Default xmlns="%s"/>' % nsmap['ct']
        default = oxml_fromstring(xml)
        default.set('Extension', ext)
        default.set('ContentType', content_type)
        objectify.deannotate(default, cleanup_namespaces=True)
        return default


class CT_Override(OxmlBaseElement):
    """
    ``<Override>`` element, specifying the content type to be applied for a
    part with the specified partname.
    """
    @property
    def content_type(self):
        """
        String held in the ``ContentType`` attribute of this ``<Override>``
        element.
        """
        return self.get('ContentType')

    @staticmethod
    def new(partname, content_type):
        """
        Return a new ``<Override>`` element with attributes set to parameter
        values.
        """
        xml = '<Override xmlns="%s"/>' % nsmap['ct']
        override = oxml_fromstring(xml)
        override.set('PartName', partname)
        override.set('ContentType', content_type)
        objectify.deannotate(override, cleanup_namespaces=True)
        return override

    @property
    def partname(self):
        """
        String held in the ``PartName`` attribute of this ``<Override>``
        element.
        """
        return self.get('PartName')


class CT_Relationship(OxmlBaseElement):
    """
    ``<Relationship>`` element, representing a single relationship from a
    source to a target part.
    """
    @staticmethod
    def new(rId, reltype, target, target_mode=RTM.INTERNAL):
        """
        Return a new ``<Relationship>`` element.
        """
        xml = '<Relationship xmlns="%s"/>' % nsmap['pr']
        relationship = oxml_fromstring(xml)
        relationship.set('Id', rId)
        relationship.set('Type', reltype)
        relationship.set('Target', target)
        if target_mode == RTM.EXTERNAL:
            relationship.set('TargetMode', RTM.EXTERNAL)
        objectify.deannotate(relationship, cleanup_namespaces=True)
        return relationship

    @property
    def rId(self):
        """
        String held in the ``Id`` attribute of this ``<Relationship>``
        element.
        """
        return self.get('Id')

    @property
    def reltype(self):
        """
        String held in the ``Type`` attribute of this ``<Relationship>``
        element.
        """
        return self.get('Type')

    @property
    def target_ref(self):
        """
        String held in the ``Target`` attribute of this ``<Relationship>``
        element.
        """
        return self.get('Target')

    @property
    def target_mode(self):
        """
        String held in the ``TargetMode`` attribute of this
        ``<Relationship>`` element, either ``Internal`` or ``External``.
        Defaults to ``Internal``.
        """
        return self.get('TargetMode', RTM.INTERNAL)


class CT_Relationships(OxmlBaseElement):
    """
    ``<Relationships>`` element, the root element in a .rels file.
    """
    def add_rel(self, rId, reltype, target, is_external=False):
        """
        Add a child ``<Relationship>`` element with attributes set according
        to parameter values.
        """
        target_mode = RTM.EXTERNAL if is_external else RTM.INTERNAL
        relationship = CT_Relationship.new(rId, reltype, target, target_mode)
        self.append(relationship)

    @staticmethod
    def new():
        """
        Return a new ``<Relationships>`` element.
        """
        xml = '<Relationships xmlns="%s"/>' % nsmap['pr']
        relationships = oxml_fromstring(xml)
        objectify.deannotate(relationships, cleanup_namespaces=True)
        return relationships

    @property
    def xml(self):
        """
        Return XML string for this element, suitable for saving in a .rels
        stream, not pretty printed and with an XML declaration at the top.
        """
        return oxml_tostring(self, encoding='UTF-8', standalone=True)


class CT_Types(OxmlBaseElement):
    """
    ``<Types>`` element, the container element for Default and Override
    elements in [Content_Types].xml.
    """
    def add_default(self, ext, content_type):
        """
        Add a child ``<Default>`` element with attributes set to parameter
        values.
        """
        default = CT_Default.new(ext, content_type)
        self.append(default)

    def add_override(self, partname, content_type):
        """
        Add a child ``<Override>`` element with attributes set to parameter
        values.
        """
        override = CT_Override.new(partname, content_type)
        self.append(override)

    @property
    def defaults(self):
        try:
            return self.Default[:]
        except AttributeError:
            return []

    @staticmethod
    def new():
        """
        Return a new ``<Types>`` element.
        """
        xml = '<Types xmlns="%s"/>' % nsmap['ct']
        types = oxml_fromstring(xml)
        objectify.deannotate(types, cleanup_namespaces=True)
        return types

    @property
    def overrides(self):
        try:
            return self.Override[:]
        except AttributeError:
            return []


ct_namespace = element_class_lookup.get_namespace(nsmap['ct'])
ct_namespace['Default'] = CT_Default
ct_namespace['Override'] = CT_Override
ct_namespace['Types'] = CT_Types

pr_namespace = element_class_lookup.get_namespace(nsmap['pr'])
pr_namespace['Relationship'] = CT_Relationship
pr_namespace['Relationships'] = CT_Relationships

########NEW FILE########
__FILENAME__ = package
# encoding: utf-8

"""
The :mod:`pptx.packaging` module coheres around the concerns of reading and
writing presentations to and from a .pptx file.
"""

from __future__ import absolute_import

from ..oxml.shared import serialize_part_xml
from pptx.util import lazyproperty

from .constants import RELATIONSHIP_TYPE as RT
from .oxml import CT_Relationships, nsmap
from .packuri import PACKAGE_URI, PackURI
from .pkgreader import PackageReader
from .pkgwriter import PackageWriter


class OpcPackage(object):
    """
    Main API class for |python-opc|. A new instance is constructed by calling
    the :meth:`open` class method with a path to a package file or file-like
    object containing one.
    """
    def __init__(self):
        super(OpcPackage, self).__init__()

    def iter_parts(self):
        """
        Generate exactly one reference to each of the parts in the package by
        performing a depth-first traversal of the rels graph.
        """
        def walk_parts(source, visited=list()):
            for rel in source.rels.values():
                if rel.is_external:
                    continue
                part = rel.target_part
                if part in visited:
                    continue
                visited.append(part)
                yield part
                new_source = part
                for part in walk_parts(new_source, visited):
                    yield part

        for part in walk_parts(self):
            yield part

    def load_rel(self, reltype, target, rId, is_external=False):
        """
        Return newly added |_Relationship| instance of *reltype* between this
        part and *target* with key *rId*. Target mode is set to
        ``RTM.EXTERNAL`` if *is_external* is |True|. Intended for use during
        load from a serialized package, where the rId is well known. Other
        methods exist for adding a new relationship to the package during
        processing.
        """
        return self.rels.add_relationship(reltype, target, rId, is_external)

    @property
    def main_document(self):
        """
        Return a reference to the main document part for this package.
        Examples include a document part for a WordprocessingML package, a
        presentation part for a PresentationML package, or a workbook part
        for a SpreadsheetML package.
        """
        return self.part_related_by(RT.OFFICE_DOCUMENT)

    @classmethod
    def open(cls, pkg_file):
        """
        Return an |OpcPackage| instance loaded with the contents of
        *pkg_file*.
        """
        pkg_reader = PackageReader.from_file(pkg_file)
        package = cls()
        Unmarshaller.unmarshal(pkg_reader, package, PartFactory)
        return package

    def part_related_by(self, reltype):
        """
        Return part to which this package has a relationship of *reltype*.
        Raises |KeyError| if no such relationship is found and |ValueError|
        if more than one such relationship is found.
        """
        return self.rels.part_with_reltype(reltype)

    @property
    def parts(self):
        """
        Return a list containing a reference to each of the parts in this
        package.
        """
        return [part for part in self.iter_parts()]

    def relate_to(self, part, reltype):
        """
        Return rId key of relationship to *part*, from the existing
        relationship if there is one, otherwise a newly created one.
        """
        rel = self.rels.get_or_add(reltype, part)
        return rel.rId

    @lazyproperty
    def rels(self):
        """
        Return a reference to the |RelationshipCollection| holding the
        relationships for this package.
        """
        return RelationshipCollection(PACKAGE_URI.baseURI)

    def save(self, pkg_file):
        """
        Save this package to *pkg_file*, where *file* can be either a path to
        a file (a string) or a file-like object.
        """
        # self._notify_before_marshal()
        for part in self.parts:
            part.before_marshal()
        PackageWriter.write(pkg_file, self.rels, self.parts)


class Part(object):
    """
    Base class for package parts. Provides common properties and methods, but
    intended to be subclassed in client code to implement specific part
    behaviors.
    """
    def __init__(
            self, partname, content_type, blob=None, element=None,
            package=None):
        super(Part, self).__init__()
        self._partname = partname
        self._content_type = content_type
        self._blob = blob
        self._element = element
        self._package = package

    # load/save interface to OpcPackage ------------------------------

    def after_unmarshal(self):
        """
        Entry point for post-unmarshaling processing, for example to parse
        the part XML. May be overridden by subclasses without forwarding call
        to super.
        """
        # don't place any code here, just catch call if not overridden by
        # subclass
        pass

    def before_marshal(self):
        """
        Entry point for pre-serialization processing, for example to finalize
        part naming if necessary. May be overridden by subclasses without
        forwarding call to super.
        """
        # don't place any code here, just catch call if not overridden by
        # subclass
        pass

    @property
    def blob(self):
        """
        Contents of this package part as a sequence of bytes. May be text or
        binary. Intended to be overridden by subclasses. Default behavior is
        to return load blob.
        """
        if self._element is not None:
            return serialize_part_xml(self._element)
        return self._blob

    @property
    def content_type(self):
        """
        Content type of this part.
        """
        return self._content_type

    @classmethod
    def load(cls, partname, content_type, blob, package):
        return cls(
            partname, content_type, blob=blob, element=None, package=package
        )

    def load_rel(self, reltype, target, rId, is_external=False):
        """
        Return newly added |_Relationship| instance of *reltype* between this
        part and *target* with key *rId*. Target mode is set to
        ``RTM.EXTERNAL`` if *is_external* is |True|. Intended for use during
        load from a serialized package, where the rId is well known. Other
        methods exist for adding a new relationship to a part when
        manipulating a part.
        """
        return self.rels.add_relationship(reltype, target, rId, is_external)

    @property
    def partname(self):
        """
        |PackURI| instance holding partname of this part, e.g.
        '/ppt/slides/slide1.xml'
        """
        return self._partname

    @partname.setter
    def partname(self, partname):
        if not isinstance(partname, PackURI):
            tmpl = "partname must be instance of PackURI, got '%s'"
            raise TypeError(tmpl % type(partname).__name__)
        self._partname = partname

    # relationship management interface for child objects ------------

    def drop_rel(self, rId):
        """
        Remove the relationship identified by *rId* if its reference count
        is less than 2. Relationships with a reference count of 0 are
        implicit relationships.
        """
        if self._rel_ref_count(rId) < 2:
            del self.rels[rId]

    def part_related_by(self, reltype):
        """
        Return part to which this part has a relationship of *reltype*.
        Raises |KeyError| if no such relationship is found and |ValueError|
        if more than one such relationship is found. Provides ability to
        resolve implicitly related part, such as Slide -> SlideLayout.
        """
        return self.rels.part_with_reltype(reltype)

    def relate_to(self, target, reltype, is_external=False):
        """
        Return rId key of relationship of *reltype* to *target*, from an
        existing relationship if there is one, otherwise a newly created one.
        """
        if is_external:
            return self.rels.get_or_add_ext_rel(reltype, target)
        else:
            rel = self.rels.get_or_add(reltype, target)
            return rel.rId

    @property
    def related_parts(self):
        """
        Dictionary mapping related parts by rId, so child objects can resolve
        explicit relationships present in the part XML, e.g. sldIdLst to a
        specific |Slide| instance.
        """
        return self.rels.related_parts

    @lazyproperty
    def rels(self):
        """
        |RelationshipCollection| instance holding the relationships for this
        part.
        """
        return RelationshipCollection(self._partname.baseURI)

    def target_ref(self, rId):
        """
        Return URL contained in target ref of relationship identified by
        *rId*.
        """
        rel = self.rels[rId]
        return rel.target_ref

    def _rel_ref_count(self, rId):
        """
        Return the count of references in this part's XML to the relationship
        identified by *rId*.
        """
        assert self._element is not None
        rIds = self._element.xpath('//@r:id', namespaces=nsmap)
        return len([_rId for _rId in rIds if _rId == rId])

    # ----------------------------------------------------------------

    @property
    def package(self):
        """
        |OpcPackage| instance this part belongs to.
        """
        return self._package


class PartFactory(object):
    """
    Provides a way for client code to specify a subclass of |Part| to be
    constructed by |Unmarshaller| based on its content type.
    """
    part_type_for = {}
    default_part_type = Part

    def __new__(cls, partname, content_type, blob, package):
        PartClass = cls._part_cls_for(content_type)
        return PartClass.load(partname, content_type, blob, package)

    @classmethod
    def _part_cls_for(cls, content_type):
        """
        Return the custom part class registered for *content_type*, or the
        default part class if no custom class is registered for
        *content_type*.
        """
        if content_type in cls.part_type_for:
            return cls.part_type_for[content_type]
        return cls.default_part_type


class RelationshipCollection(dict):
    """
    Collection object for |_Relationship| instances, having list semantics.
    """
    def __init__(self, baseURI):
        super(RelationshipCollection, self).__init__()
        self._baseURI = baseURI
        self._target_parts_by_rId = {}

    def add_relationship(self, reltype, target, rId, is_external=False):
        """
        Return a newly added |_Relationship| instance.
        """
        rel = _Relationship(rId, reltype, target, self._baseURI, is_external)
        self[rId] = rel
        if not is_external:
            self._target_parts_by_rId[rId] = target
        return rel

    def get_or_add(self, reltype, target_part):
        """
        Return relationship of *reltype* to *target_part*, newly added if not
        already present in collection.
        """
        rel = self._get_matching(reltype, target_part)
        if rel is None:
            rId = self._next_rId
            rel = self.add_relationship(reltype, target_part, rId)
        return rel

    def get_or_add_ext_rel(self, reltype, target_ref):
        """
        Return rId of external relationship of *reltype* to *target_ref*,
        newly added if not already present in collection.
        """
        rel = self._get_matching(reltype, target_ref, is_external=True)
        if rel is None:
            rId = self._next_rId
            rel = self.add_relationship(
                reltype, target_ref, rId, is_external=True
            )
        return rel.rId

    def part_with_reltype(self, reltype):
        """
        Return target part of rel with matching *reltype*, raising |KeyError|
        if not found and |ValueError| if more than one matching relationship
        is found.
        """
        rel = self._get_rel_of_type(reltype)
        return rel.target_part

    @property
    def related_parts(self):
        """
        dict mapping rIds to target parts for all the internal relationships
        in the collection.
        """
        return self._target_parts_by_rId

    @property
    def xml(self):
        """
        Serialize this relationship collection into XML suitable for storage
        as a .rels file in an OPC package.
        """
        rels_elm = CT_Relationships.new()
        for rel in self.values():
            rels_elm.add_rel(
                rel.rId, rel.reltype, rel.target_ref, rel.is_external
            )
        return rels_elm.xml

    def _get_matching(self, reltype, target, is_external=False):
        """
        Return relationship of matching *reltype*, *target*, and
        *is_external* from collection, or None if not found.
        """
        def matches(rel, reltype, target, is_external):
            if rel.reltype != reltype:
                return False
            if rel.is_external != is_external:
                return False
            rel_target = rel.target_ref if rel.is_external else rel.target_part
            if rel_target != target:
                return False
            return True

        for rel in self.values():
            if matches(rel, reltype, target, is_external):
                return rel
        return None

    def _get_rel_of_type(self, reltype):
        """
        Return single relationship of type *reltype* from the collection.
        Raises |KeyError| if no matching relationship is found. Raises
        |ValueError| if more than one matching relationship is found.
        """
        matching = [rel for rel in self.values() if rel.reltype == reltype]
        if len(matching) == 0:
            tmpl = "no relationship of type '%s' in collection"
            raise KeyError(tmpl % reltype)
        if len(matching) > 1:
            tmpl = "multiple relationships of type '%s' in collection"
            raise ValueError(tmpl % reltype)
        return matching[0]

    @property
    def _next_rId(self):
        """
        Next available rId in collection, starting from 'rId1' and making use
        of any gaps in numbering, e.g. 'rId2' for rIds ['rId1', 'rId3'].
        """
        for n in range(1, len(self)+2):
            rId_candidate = 'rId%d' % n  # like 'rId19'
            if rId_candidate not in self:
                return rId_candidate


class Unmarshaller(object):
    """
    Hosts static methods for unmarshalling a package from a |PackageReader|
    instance.
    """
    @staticmethod
    def unmarshal(pkg_reader, package, part_factory):
        """
        Construct graph of parts and realized relationships based on the
        contents of *pkg_reader*, delegating construction of each part to
        *part_factory*. Package relationships are added to *pkg*.
        """
        parts = Unmarshaller._unmarshal_parts(
            pkg_reader, package, part_factory
        )
        Unmarshaller._unmarshal_relationships(pkg_reader, package, parts)
        for part in parts.values():
            part.after_unmarshal()
        package.after_unmarshal()

    @staticmethod
    def _unmarshal_parts(pkg_reader, package, part_factory):
        """
        Return a dictionary of |Part| instances unmarshalled from
        *pkg_reader*, keyed by partname. Side-effect is that each part in
        *pkg_reader* is constructed using *part_factory*.
        """
        parts = {}
        for partname, content_type, blob in pkg_reader.iter_sparts():
            parts[partname] = part_factory(
                partname, content_type, blob, package
            )
        return parts

    @staticmethod
    def _unmarshal_relationships(pkg_reader, package, parts):
        """
        Add a relationship to the source object corresponding to each of the
        relationships in *pkg_reader* with its target_part set to the actual
        target part in *parts*.
        """
        for source_uri, srel in pkg_reader.iter_srels():
            source = package if source_uri == '/' else parts[source_uri]
            target = (srel.target_ref if srel.is_external
                      else parts[srel.target_partname])
            source.load_rel(srel.reltype, target, srel.rId, srel.is_external)


class _Relationship(object):
    """
    Value object for relationship to part.
    """
    def __init__(self, rId, reltype, target, baseURI, external=False):
        super(_Relationship, self).__init__()
        self._rId = rId
        self._reltype = reltype
        self._target = target
        self._baseURI = baseURI
        self._is_external = bool(external)

    @property
    def is_external(self):
        return self._is_external

    @property
    def reltype(self):
        return self._reltype

    @property
    def rId(self):
        return self._rId

    @property
    def target_part(self):
        if self._is_external:
            raise ValueError("target_part property on _Relationship is undef"
                             "ined when target mode is External")
        return self._target

    @property
    def target_ref(self):
        if self._is_external:
            return self._target
        else:
            return self._target.partname.relative_ref(self._baseURI)

########NEW FILE########
__FILENAME__ = packuri
# encoding: utf-8

"""
Provides the PackURI value type along with some useful known pack URI strings
such as PACKAGE_URI.
"""

import posixpath
import re


class PackURI(str):
    """
    Provides access to pack URI components such as the baseURI and the
    filename slice. Behaves as |str| otherwise.
    """
    _filename_re = re.compile('([a-zA-Z]+)([1-9][0-9]*)?')

    def __new__(cls, pack_uri_str):
        if not pack_uri_str[0] == '/':
            tmpl = "PackURI must begin with slash, got '%s'"
            raise ValueError(tmpl % pack_uri_str)
        return str.__new__(cls, pack_uri_str)

    @staticmethod
    def from_rel_ref(baseURI, relative_ref):
        """
        Return a |PackURI| instance containing the absolute pack URI formed by
        translating *relative_ref* onto *baseURI*.
        """
        joined_uri = posixpath.join(baseURI, relative_ref)
        abs_uri = posixpath.abspath(joined_uri)
        return PackURI(abs_uri)

    @property
    def baseURI(self):
        """
        The base URI of this pack URI, the directory portion, roughly
        speaking. E.g. ``'/ppt/slides'`` for ``'/ppt/slides/slide1.xml'``.
        For the package pseudo-partname '/', baseURI is '/'.
        """
        return posixpath.split(self)[0]

    @property
    def ext(self):
        """
        The extension portion of this pack URI, e.g. ``'xml'`` for
        ``'/ppt/slides/slide1.xml'``. Note that the period is not included.
        """
        # raw_ext is either empty string or starts with period, e.g. '.xml'
        raw_ext = posixpath.splitext(self)[1]
        return raw_ext[1:] if raw_ext.startswith('.') else raw_ext

    @property
    def filename(self):
        """
        The "filename" portion of this pack URI, e.g. ``'slide1.xml'`` for
        ``'/ppt/slides/slide1.xml'``. For the package pseudo-partname '/',
        filename is ''.
        """
        return posixpath.split(self)[1]

    @property
    def idx(self):
        """
        Return partname index as integer for tuple partname or None for
        singleton partname, e.g. ``21`` for ``'/ppt/slides/slide21.xml'`` and
        |None| for ``'/ppt/presentation.xml'``.
        """
        filename = self.filename
        if not filename:
            return None
        name_part = posixpath.splitext(filename)[0]  # filename w/ext removed
        match = self._filename_re.match(name_part)
        if match is None:
            return None
        if match.group(2):
            return int(match.group(2))
        return None

    @property
    def membername(self):
        """
        The pack URI with the leading slash stripped off, the form used as
        the Zip file membername for the package item. Returns '' for the
        package pseudo-partname '/'.
        """
        return self[1:]

    def relative_ref(self, baseURI):
        """
        Return string containing relative reference to package item from
        *baseURI*. E.g. PackURI('/ppt/slideLayouts/slideLayout1.xml') would
        return '../slideLayouts/slideLayout1.xml' for baseURI '/ppt/slides'.
        """
        # workaround for posixpath bug in 2.6, doesn't generate correct
        # relative path when *start* (second) parameter is root ('/')
        if baseURI == '/':
            relpath = self[1:]
        else:
            relpath = posixpath.relpath(self, baseURI)
        return relpath

    @property
    def rels_uri(self):
        """
        The pack URI of the .rels part corresponding to the current pack URI.
        Only produces sensible output if the pack URI is a partname or the
        package pseudo-partname '/'.
        """
        rels_filename = '%s.rels' % self.filename
        rels_uri_str = posixpath.join(self.baseURI, '_rels', rels_filename)
        return PackURI(rels_uri_str)


PACKAGE_URI = PackURI('/')
CONTENT_TYPES_URI = PackURI('/[Content_Types].xml')

########NEW FILE########
__FILENAME__ = phys_pkg
# encoding: utf-8

"""
Provides a general interface to a *physical* OPC package, such as a zip file.
"""

from __future__ import absolute_import

import os

from zipfile import ZipFile, is_zipfile, ZIP_DEFLATED

from pptx.exceptions import PackageNotFoundError

from .packuri import CONTENT_TYPES_URI


class PhysPkgReader(object):
    """
    Factory for physical package reader objects.
    """
    def __new__(cls, pkg_file):
        # if *pkg_file* is a string, treat it as a path
        if isinstance(pkg_file, basestring):
            if os.path.isdir(pkg_file):
                reader_cls = _DirPkgReader
            elif is_zipfile(pkg_file):
                reader_cls = _ZipPkgReader
            else:
                raise PackageNotFoundError(
                    "Package not found at '%s'" % pkg_file
                )
        else:  # assume it's a stream and pass it to Zip reader to sort out
            reader_cls = _ZipPkgReader

        return super(PhysPkgReader, cls).__new__(reader_cls)


class PhysPkgWriter(object):
    """
    Factory for physical package writer objects.
    """
    def __new__(cls, pkg_file):
        return super(PhysPkgWriter, cls).__new__(_ZipPkgWriter)


class _DirPkgReader(PhysPkgReader):
    """
    Implements |PhysPkgReader| interface for an OPC package extracted into a
    directory.
    """
    def __init__(self, path):
        """
        *path* is the path to a directory containing an expanded package.
        """
        super(_DirPkgReader, self).__init__()
        self._path = os.path.abspath(path)

    def blob_for(self, pack_uri):
        """
        Return contents of file corresponding to *pack_uri* in package
        directory.
        """
        path = os.path.join(self._path, pack_uri.membername)
        with open(path, 'rb') as f:
            blob = f.read()
        return blob

    def close(self):
        """
        Provides interface consistency with |ZipFileSystem|, but does
        nothing, a directory file system doesn't need closing.
        """
        pass

    @property
    def content_types_xml(self):
        """
        Return the `[Content_Types].xml` blob from the package.
        """
        return self.blob_for(CONTENT_TYPES_URI)

    def rels_xml_for(self, source_uri):
        """
        Return rels item XML for source with *source_uri*, or None if the
        item has no rels item.
        """
        try:
            rels_xml = self.blob_for(source_uri.rels_uri)
        except IOError:
            rels_xml = None
        return rels_xml


class _ZipPkgReader(PhysPkgReader):
    """
    Implements |PhysPkgReader| interface for a zip file OPC package.
    """
    def __init__(self, pkg_file):
        super(_ZipPkgReader, self).__init__()
        self._zipf = ZipFile(pkg_file, 'r')

    def blob_for(self, pack_uri):
        """
        Return blob corresponding to *pack_uri*. Raises |ValueError| if no
        matching member is present in zip archive.
        """
        return self._zipf.read(pack_uri.membername)

    def close(self):
        """
        Close the zip archive, releasing any resources it is using.
        """
        self._zipf.close()

    @property
    def content_types_xml(self):
        """
        Return the `[Content_Types].xml` blob from the zip package.
        """
        return self.blob_for(CONTENT_TYPES_URI)

    def rels_xml_for(self, source_uri):
        """
        Return rels item XML for source with *source_uri* or None if no rels
        item is present.
        """
        try:
            rels_xml = self.blob_for(source_uri.rels_uri)
        except KeyError:
            rels_xml = None
        return rels_xml


class _ZipPkgWriter(PhysPkgWriter):
    """
    Implements |PhysPkgWriter| interface for a zip file OPC package.
    """
    def __init__(self, pkg_file):
        super(_ZipPkgWriter, self).__init__()
        self._zipf = ZipFile(pkg_file, 'w', compression=ZIP_DEFLATED)

    def close(self):
        """
        Close the zip archive, flushing any pending physical writes and
        releasing any resources it's using.
        """
        self._zipf.close()

    def write(self, pack_uri, blob):
        """
        Write *blob* to this zip package with the membername corresponding to
        *pack_uri*.
        """
        self._zipf.writestr(pack_uri.membername, blob)

########NEW FILE########
__FILENAME__ = pkgreader
# encoding: utf-8

"""
Provides a low-level, read-only API to a serialized Open Packaging Convention
(OPC) package.
"""

from __future__ import absolute_import

from .constants import RELATIONSHIP_TARGET_MODE as RTM
from .oxml import oxml_fromstring
from .packuri import PACKAGE_URI, PackURI
from .phys_pkg import PhysPkgReader
from .shared import CaseInsensitiveDict


class PackageReader(object):
    """
    Provides access to the contents of a zip-format OPC package via its
    :attr:`serialized_parts` and :attr:`pkg_srels` attributes.
    """
    def __init__(self, content_types, pkg_srels, sparts):
        super(PackageReader, self).__init__()
        self._pkg_srels = pkg_srels
        self._sparts = sparts

    @staticmethod
    def from_file(pkg_file):
        """
        Return a |PackageReader| instance loaded with contents of *pkg_file*.
        """
        phys_reader = PhysPkgReader(pkg_file)
        content_types = _ContentTypeMap.from_xml(phys_reader.content_types_xml)
        pkg_srels = PackageReader._srels_for(phys_reader, PACKAGE_URI)
        sparts = PackageReader._load_serialized_parts(
            phys_reader, pkg_srels, content_types
        )
        phys_reader.close()
        return PackageReader(content_types, pkg_srels, sparts)

    def iter_sparts(self):
        """
        Generate a 3-tuple `(partname, content_type, blob)` for each of the
        serialized parts in the package.
        """
        for spart in self._sparts:
            yield (spart.partname, spart.content_type, spart.blob)

    def iter_srels(self):
        """
        Generate a 2-tuple `(source_uri, srel)` for each of the relationships
        in the package.
        """
        for srel in self._pkg_srels:
            yield (PACKAGE_URI, srel)
        for spart in self._sparts:
            for srel in spart.srels:
                yield (spart.partname, srel)

    @staticmethod
    def _load_serialized_parts(phys_reader, pkg_srels, content_types):
        """
        Return a list of |_SerializedPart| instances corresponding to the
        parts in *phys_reader* accessible by walking the relationship graph
        starting with *pkg_srels*.
        """
        sparts = []
        part_walker = PackageReader._walk_phys_parts(phys_reader, pkg_srels)
        for partname, blob, srels in part_walker:
            content_type = content_types[partname]
            spart = _SerializedPart(partname, content_type, blob, srels)
            sparts.append(spart)
        return tuple(sparts)

    @staticmethod
    def _srels_for(phys_reader, source_uri):
        """
        Return |_SerializedRelationshipCollection| instance populated with
        relationships for source identified by *source_uri*.
        """
        rels_xml = phys_reader.rels_xml_for(source_uri)
        return _SerializedRelationshipCollection.load_from_xml(
            source_uri.baseURI, rels_xml)

    @staticmethod
    def _walk_phys_parts(phys_reader, srels, visited_partnames=None):
        """
        Generate a 3-tuple `(partname, blob, srels)` for each of the parts in
        *phys_reader* by walking the relationship graph rooted at srels.
        """
        if visited_partnames is None:
            visited_partnames = []
        for srel in srels:
            if srel.is_external:
                continue
            partname = srel.target_partname
            if partname in visited_partnames:
                continue
            visited_partnames.append(partname)
            part_srels = PackageReader._srels_for(phys_reader, partname)
            blob = phys_reader.blob_for(partname)
            yield (partname, blob, part_srels)
            for partname, blob, srels in PackageReader._walk_phys_parts(
                    phys_reader, part_srels, visited_partnames):
                yield (partname, blob, srels)


class _ContentTypeMap(object):
    """
    Value type providing dictionary semantics for looking up content type by
    part name, e.g. ``content_type = cti['/ppt/presentation.xml']``.
    """
    def __init__(self):
        super(_ContentTypeMap, self).__init__()
        self._overrides = CaseInsensitiveDict()
        self._defaults = CaseInsensitiveDict()

    def __getitem__(self, partname):
        """
        Return content type for part identified by *partname*.
        """
        if not isinstance(partname, PackURI):
            tmpl = "_ContentTypeMap key must be <type 'PackURI'>, got %s"
            raise KeyError(tmpl % type(partname))
        if partname in self._overrides:
            return self._overrides[partname]
        if partname.ext in self._defaults:
            return self._defaults[partname.ext]
        tmpl = "no content type for partname '%s' in [Content_Types].xml"
        raise KeyError(tmpl % partname)

    @staticmethod
    def from_xml(content_types_xml):
        """
        Return a new |_ContentTypeMap| instance populated with the contents
        of *content_types_xml*.
        """
        types_elm = oxml_fromstring(content_types_xml)
        ct_map = _ContentTypeMap()
        for o in types_elm.overrides:
            ct_map._add_override(o.partname, o.content_type)
        for d in types_elm.defaults:
            ct_map._add_default(d.extension, d.content_type)
        return ct_map

    def _add_default(self, extension, content_type):
        """
        Add the default mapping of *extension* to *content_type* to this
        content type mapping. *extension* does not include the leading
        period.
        """
        self._defaults[extension] = content_type

    def _add_override(self, partname, content_type):
        """
        Add the default mapping of *partname* to *content_type* to this
        content type mapping.
        """
        self._overrides[partname] = content_type


class _SerializedPart(object):
    """
    Value object for an OPC package part. Provides access to the partname,
    content type, blob, and serialized relationships for the part.
    """
    def __init__(self, partname, content_type, blob, srels):
        super(_SerializedPart, self).__init__()
        self._partname = partname
        self._content_type = content_type
        self._blob = blob
        self._srels = srels

    @property
    def partname(self):
        return self._partname

    @property
    def content_type(self):
        return self._content_type

    @property
    def blob(self):
        return self._blob

    @property
    def srels(self):
        return self._srels


class _SerializedRelationship(object):
    """
    Value object representing a serialized relationship in an OPC package.
    Serialized, in this case, means any target part is referred to via its
    partname rather than a direct link to an in-memory |Part| object.
    """
    def __init__(self, baseURI, rel_elm):
        super(_SerializedRelationship, self).__init__()
        self._baseURI = baseURI
        self._rId = rel_elm.rId
        self._reltype = rel_elm.reltype
        self._target_mode = rel_elm.target_mode
        self._target_ref = rel_elm.target_ref

    @property
    def is_external(self):
        """
        True if target_mode is ``RTM.EXTERNAL``
        """
        return self._target_mode == RTM.EXTERNAL

    @property
    def reltype(self):
        """Relationship type, like ``RT.OFFICE_DOCUMENT``"""
        return self._reltype

    @property
    def rId(self):
        """
        Relationship id, like 'rId9', corresponds to the ``Id`` attribute on
        the ``CT_Relationship`` element.
        """
        return self._rId

    @property
    def target_mode(self):
        """
        String in ``TargetMode`` attribute of ``CT_Relationship`` element,
        one of ``RTM.INTERNAL`` or ``RTM.EXTERNAL``.
        """
        return self._target_mode

    @property
    def target_ref(self):
        """
        String in ``Target`` attribute of ``CT_Relationship`` element, a
        relative part reference for internal target mode or an arbitrary URI,
        e.g. an HTTP URL, for external target mode.
        """
        return self._target_ref

    @property
    def target_partname(self):
        """
        |PackURI| instance containing partname targeted by this relationship.
        Raises ``ValueError`` on reference if target_mode is ``'External'``.
        Use :attr:`target_mode` to check before referencing.
        """
        if self.is_external:
            msg = ('target_partname attribute on Relationship is undefined w'
                   'here TargetMode == "External"')
            raise ValueError(msg)
        # lazy-load _target_partname attribute
        if not hasattr(self, '_target_partname'):
            self._target_partname = PackURI.from_rel_ref(self._baseURI,
                                                         self.target_ref)
        return self._target_partname


class _SerializedRelationshipCollection(object):
    """
    Read-only sequence of |_SerializedRelationship| instances corresponding
    to the relationships item XML passed to constructor.
    """
    def __init__(self):
        super(_SerializedRelationshipCollection, self).__init__()
        self._srels = []

    def __iter__(self):
        """Support iteration, e.g. 'for x in srels:'"""
        return self._srels.__iter__()

    @staticmethod
    def load_from_xml(baseURI, rels_item_xml):
        """
        Return |_SerializedRelationshipCollection| instance loaded with the
        relationships contained in *rels_item_xml*. Returns an empty
        collection if *rels_item_xml* is |None|.
        """
        srels = _SerializedRelationshipCollection()
        if rels_item_xml is not None:
            rels_elm = oxml_fromstring(rels_item_xml)
            for rel_elm in rels_elm.Relationship:
                srels._srels.append(_SerializedRelationship(baseURI, rel_elm))
        return srels

########NEW FILE########
__FILENAME__ = pkgwriter
# encoding: utf-8

"""
Provides a low-level, write-only API to a serialized Open Packaging
Convention (OPC) package, essentially an implementation of OpcPackage.save()
"""

from __future__ import absolute_import

from .constants import CONTENT_TYPE as CT
from .oxml import CT_Types, serialize_part_xml
from .packuri import CONTENT_TYPES_URI, PACKAGE_URI
from .phys_pkg import PhysPkgWriter
from .shared import CaseInsensitiveDict
from .spec import default_content_types


class PackageWriter(object):
    """
    Writes a zip-format OPC package to *pkg_file*, where *pkg_file* can be
    either a path to a zip file (a string) or a file-like object. Its single
    API method, :meth:`write`, is static, so this class is not intended to
    be instantiated.
    """
    @staticmethod
    def write(pkg_file, pkg_rels, parts):
        """
        Write a physical package (.pptx file) to *pkg_file* containing
        *pkg_rels* and *parts* and a content types stream based on the
        content types of the parts.
        """
        phys_writer = PhysPkgWriter(pkg_file)
        PackageWriter._write_content_types_stream(phys_writer, parts)
        PackageWriter._write_pkg_rels(phys_writer, pkg_rels)
        PackageWriter._write_parts(phys_writer, parts)
        phys_writer.close()

    @staticmethod
    def _write_content_types_stream(phys_writer, parts):
        """
        Write ``[Content_Types].xml`` part to the physical package with an
        appropriate content type lookup target for each part in *parts*.
        """
        content_types_blob = serialize_part_xml(
            _ContentTypesItem.xml_for(parts)
        )
        phys_writer.write(CONTENT_TYPES_URI, content_types_blob)

    @staticmethod
    def _write_parts(phys_writer, parts):
        """
        Write the blob of each part in *parts* to the package, along with a
        rels item for its relationships if and only if it has any.
        """
        for part in parts:
            phys_writer.write(part.partname, part.blob)
            if len(part._rels):
                phys_writer.write(part.partname.rels_uri, part._rels.xml)

    @staticmethod
    def _write_pkg_rels(phys_writer, pkg_rels):
        """
        Write the XML rels item for *pkg_rels* ('/_rels/.rels') to the
        package.
        """
        phys_writer.write(PACKAGE_URI.rels_uri, pkg_rels.xml)


class _ContentTypesItem(object):
    """
    Service class that composes a content types item ([Content_Types].xml)
    based on a list of parts. Not meant to be instantiated directly, its
    single interface method is xml_for(), e.g.
    ``_ContentTypesItem.xml_for(parts)``.
    """
    def __init__(self):
        self._defaults = CaseInsensitiveDict()
        self._overrides = dict()

    @classmethod
    def xml_for(cls, parts):
        """
        Return content types XML mapping each part in *parts* to the
        appropriate content type and suitable for storage as
        ``[Content_Types].xml`` in an OPC package.
        """
        cti = cls()
        cti._defaults['rels'] = CT.OPC_RELATIONSHIPS
        cti._defaults['xml'] = CT.XML
        for part in parts:
            cti._add_content_type(part.partname, part.content_type)
        return cti._xml()

    def _add_content_type(self, partname, content_type):
        """
        Add a content type for the part with *partname* and *content_type*,
        using a default or override as appropriate.
        """
        ext = partname.ext
        if (ext.lower(), content_type) in default_content_types:
            self._defaults[ext] = content_type
        else:
            self._overrides[partname] = content_type

    def _xml(self):
        """
        Return etree element containing the XML representation of this content
        types item, suitable for serialization to the ``[Content_Types].xml``
        item for an OPC package. Although the sequence of elements is not
        strictly significant, as an aid to testing and readability Default
        elements are sorted by extension and Override elements are sorted by
        partname.
        """
        _types_elm = CT_Types.new()
        for ext in sorted(self._defaults.keys()):
            _types_elm.add_default(ext, self._defaults[ext])
        for partname in sorted(self._overrides.keys()):
            _types_elm.add_override(partname, self._overrides[partname])
        return _types_elm

########NEW FILE########
__FILENAME__ = shared
# encoding: utf-8

"""
Objects shared by modules in the pptx.opc sub-package
"""

from __future__ import absolute_import, print_function, unicode_literals


class CaseInsensitiveDict(dict):
    """
    Mapping type that behaves like dict except that it matches without respect
    to the case of the key. E.g. cid['A'] == cid['a']. Note this is not
    general-purpose, just complete enough to satisfy opc package needs. It
    assumes str keys for example.
    """
    def __contains__(self, key):
        return super(CaseInsensitiveDict, self).__contains__(key.lower())

    def __getitem__(self, key):
        return super(CaseInsensitiveDict, self).__getitem__(key.lower())

    def __setitem__(self, key, value):
        return super(CaseInsensitiveDict, self).__setitem__(
            key.lower(), value
        )

########NEW FILE########
__FILENAME__ = spec
# encoding: utf-8

"""
Provides mappings that embody aspects of the Open XML spec ISO/IEC 29500.
"""

from .constants import CONTENT_TYPE as CT


default_content_types = (
    ('bin',     CT.PML_PRINTER_SETTINGS),
    ('bin',     CT.SML_PRINTER_SETTINGS),
    ('bin',     CT.WML_PRINTER_SETTINGS),
    ('bmp',     CT.BMP),
    ('emf',     CT.X_EMF),
    ('fntdata', CT.X_FONTDATA),
    ('gif',     CT.GIF),
    ('jpe',     CT.JPEG),
    ('jpeg',    CT.JPEG),
    ('jpg',     CT.JPEG),
    ('png',     CT.PNG),
    ('rels',    CT.OPC_RELATIONSHIPS),
    ('tif',     CT.TIFF),
    ('tiff',    CT.TIFF),
    ('wdp',     CT.MS_PHOTO),
    ('wmf',     CT.X_WMF),
    ('xlsx',    CT.SML_SHEET),
    ('xml',     CT.XML),
)


image_content_types = {
    'bmp':  CT.BMP,
    'emf':  CT.X_EMF,
    'gif':  CT.GIF,
    'jpe':  CT.JPEG,
    'jpeg': CT.JPEG,
    'jpg':  CT.JPEG,
    'png':  CT.PNG,
    'tif':  CT.TIFF,
    'tiff': CT.TIFF,
    'wdp':  CT.MS_PHOTO,
    'wmf':  CT.X_WMF,
}

########NEW FILE########
__FILENAME__ = coreprops
# encoding: utf-8

"""
lxml custom element classes for core properties-related XML elements.
"""

from __future__ import absolute_import

import re

from datetime import datetime, timedelta

from lxml import objectify

from . import parse_xml_bytes
from .ns import nsdecls, qn


class CT_CoreProperties(objectify.ObjectifiedElement):
    """
    ``<cp:coreProperties>`` element, the root element of the Core Properties
    part stored as ``/docProps/core.xml``. Implements many of the Dublin Core
    document metadata elements. String elements resolve to an empty string
    ('') if the element is not present in the XML. String elements are
    limited in length to 255 unicode characters.
    """
    _date_tags = {
        'created':      'dcterms:created',
        'last_printed': 'cp:lastPrinted',
        'modified':     'dcterms:modified',
    }
    _str_tags = {
        'author':           'dc:creator',
        'category':         'cp:category',
        'comments':         'dc:description',
        'content_status':   'cp:contentStatus',
        'identifier':       'dc:identifier',
        'keywords':         'cp:keywords',
        'language':         'dc:language',
        'last_modified_by': 'cp:lastModifiedBy',
        'subject':          'dc:subject',
        'title':            'dc:title',
        'version':          'cp:version',
    }
    _coreProperties_tmpl = (
        '<cp:coreProperties %s/>\n' % nsdecls('cp', 'dc', 'dcterms')
    )

    @staticmethod
    def new_coreProperties():
        """Return a new ``<cp:coreProperties>`` element"""
        xml = CT_CoreProperties._coreProperties_tmpl
        coreProperties = parse_xml_bytes(xml)
        return coreProperties

    def __getattribute__(self, name):
        """
        Intercept attribute access to generalize property getters.
        """
        if name in CT_CoreProperties._str_tags:
            return self._get_str_prop(name)
        elif name in CT_CoreProperties._date_tags:
            return self._get_date_prop(name)
        elif name == 'revision':
            return self._get_revision()
        else:
            return super(CT_CoreProperties, self).__getattribute__(name)

    def __setattr__(self, name, value):
        """
        Override ``__setattr__`` defined in ObjectifiedElement super class
        to intercept messages intended for custom property setters.
        """
        if name in CT_CoreProperties._str_tags:
            self._set_str_prop(name, value)
        elif name in CT_CoreProperties._date_tags:
            self._set_date_prop(name, value)
        elif name == 'revision':
            self._set_revision(value)
        else:
            super(CT_CoreProperties, self).__setattr__(name, value)

    def _get_str_prop(self, name):
        """Return string value of *name* property."""
        # explicit class reference avoids another pass through getattribute
        tag = qn(CT_CoreProperties._str_tags[name])
        if not hasattr(self, tag):
            return ''
        return getattr(self, tag).text

    def _get_date_prop(self, name):
        """Return datetime value of *name* property."""
        # explicit class reference avoids another pass through getattribute
        tag = qn(CT_CoreProperties._date_tags[name])
        # date properties return None when property element not present
        if not hasattr(self, tag):
            return None
        datetime_str = getattr(self, tag).text
        try:
            return self._parse_W3CDTF_to_datetime(datetime_str)
        except ValueError:
            # invalid datetime strings are ignored
            return None

    def _get_revision(self):
        """Return integer value of revision property."""
        tag = qn('cp:revision')
        # revision returns zero when element not present
        if not hasattr(self, tag):
            return 0
        revision_str = getattr(self, tag).text
        try:
            revision = int(revision_str)
        except ValueError:
            # non-integer revision strings also resolve to 0
            revision = 0
        # as do negative integers
        if revision < 0:
            revision = 0
        return revision

    def _set_str_prop(self, name, value):
        """Set string value of *name* property to *value*"""
        value = str(value)
        if len(value) > 255:
            tmpl = ("exceeded 255 char max length of property '%s', got:"
                    "\n\n'%s'")
            raise ValueError(tmpl % (name, value))
        tag = qn(CT_CoreProperties._str_tags[name])
        setattr(self, tag, value)
        # objectify will leave in a py: namespace without this cleanup
        elm = getattr(self, tag)
        objectify.deannotate(elm, cleanup_namespaces=True)

    def _set_date_prop(self, name, value):
        """Set datetime value of *name* property to *value*"""
        if not isinstance(value, datetime):
            tmpl = ("'%s' property requires <type 'datetime.datetime'> objec"
                    "t, got %s")
            raise ValueError(tmpl % (name, type(value)))
        tagname = CT_CoreProperties._date_tags[name]
        tag = qn(tagname)
        dt_str = value.strftime('%Y-%m-%dT%H:%M:%SZ')
        setattr(self, tag, dt_str)
        # objectify will leave in a py: namespace without this cleanup
        elm = getattr(self, tag)
        objectify.deannotate(elm, cleanup_namespaces=True)
        if name in ('created', 'modified'):
            # these two require an explicit 'xsi:type' attribute
            # first and last line are a hack required to add the xsi
            # namespace to the root element rather than each child element
            # in which it is referenced
            self.set(qn('xsi:foo'), 'bar')
            self[tag].set(qn('xsi:type'), 'dcterms:W3CDTF')
            del self.attrib[qn('xsi:foo')]

    def _set_revision(self, value):
        """Set integer value of revision property to *value*"""
        if not isinstance(value, int) or value < 1:
            tmpl = "revision property requires positive int, got '%s'"
            raise ValueError(tmpl % value)
        tag = qn('cp:revision')
        setattr(self, tag, str(value))
        # objectify will leave in a py: namespace without this cleanup
        elm = getattr(self, tag)
        objectify.deannotate(elm, cleanup_namespaces=True)

    _offset_pattern = re.compile('([+-])(\d\d):(\d\d)')

    @classmethod
    def _offset_dt(cls, dt, offset_str):
        """
        Return a |datetime| instance that is offset from datetime *dt* by
        the timezone offset specified in *offset_str*, a string like
        ``'-07:00'``.
        """
        match = cls._offset_pattern.match(offset_str)
        if match is None:
            raise ValueError("'%s' is not a valid offset string" % offset_str)
        sign, hours_str, minutes_str = match.groups()
        sign_factor = -1 if sign == '+' else 1
        hours = int(hours_str) * sign_factor
        minutes = int(minutes_str) * sign_factor
        td = timedelta(hours=hours, minutes=minutes)
        return dt + td

    @classmethod
    def _parse_W3CDTF_to_datetime(cls, w3cdtf_str):
        # valid W3CDTF date cases:
        # yyyy e.g. '2003'
        # yyyy-mm e.g. '2003-12'
        # yyyy-mm-dd e.g. '2003-12-31'
        # UTC timezone e.g. '2003-12-31T10:14:55Z'
        # numeric timezone e.g. '2003-12-31T10:14:55-08:00'
        templates = (
            '%Y-%m-%dT%H:%M:%S',
            '%Y-%m-%d',
            '%Y-%m',
            '%Y',
        )
        # strptime isn't smart enough to parse literal timezone offsets like
        # '-07:30', so we have to do it ourselves
        parseable_part = w3cdtf_str[:19]
        offset_str = w3cdtf_str[19:]
        dt = None
        for tmpl in templates:
            try:
                dt = datetime.strptime(parseable_part, tmpl)
            except ValueError:
                continue
        if dt is None:
            tmpl = "could not parse W3CDTF datetime string '%s'"
            raise ValueError(tmpl % w3cdtf_str)
        if len(offset_str) == 6:
            return cls._offset_dt(dt, offset_str)
        return dt

########NEW FILE########
__FILENAME__ = color
# encoding: utf-8

"""
lxml custom element classes for DrawingML-related XML elements.
"""

from __future__ import absolute_import

from lxml import objectify

from ...enum.dml import MSO_THEME_COLOR
from ..ns import qn
from ..shared import SubElement


class OxmlElement(objectify.ObjectifiedElement):

    def _first_child_found_in(self, *tagnames):
        """
        Return the first child found with tag in *tagnames*, or None if
        not found.
        """
        for tagname in tagnames:
            child = self.find(qn(tagname))
            if child is not None:
                return child
        return None


class _BaseColorElement(OxmlElement):
    """
    Base class for <a:srgbClr> and <a:schemeClr> elements.
    """
    def __setattr__(self, name, value):
        """
        Override ``__setattr__`` defined in ObjectifiedElement super class
        to intercept messages intended for custom property setters.
        """
        if name == 'val':
            self._set_val(value)
        else:
            super(_BaseColorElement, self).__setattr__(name, value)

    def add_lumMod(self, value):
        """
        Return a newly added <a:lumMod> child element.
        """
        return SubElement(self, 'a:lumMod', val=str(value))

    def add_lumOff(self, value):
        """
        Return a newly added <a:lumOff> child element.
        """
        return SubElement(self, 'a:lumOff', val=str(value))

    def clear_lum(self):
        """
        Return self after removing any <a:lumMod> and <a:lumOff> child
        elements.
        """
        lum_tagnames = (qn('a:lumMod'), qn('a:lumOff'))
        for child in self.getchildren():
            if child.tag in lum_tagnames:
                self.remove(child)
        return self

    @property
    def lumMod(self):
        """
        The <a:lumMod> child element, or None if not present.
        """
        return self.find(qn('a:lumMod'))

    @property
    def lumOff(self):
        """
        The <a:lumOff> child element, or None if not present.
        """
        return self.find(qn('a:lumOff'))

    @property
    def val(self):
        return self.get('val')

    def _set_val(self, value):
        self.set('val', value)


class CT_HslColor(_BaseColorElement):
    """
    Custom element class for <a:hslClr> element.
    """


class CT_Percentage(OxmlElement):
    """
    Custom element class for <a:lumMod> and <a:lumOff> elements.
    """
    @property
    def val(self):
        return self.get('val')


class CT_PresetColor(_BaseColorElement):
    """
    Custom element class for <a:prstClr> element.
    """


class CT_SchemeColor(_BaseColorElement):
    """
    Custom element class for <a:schemeClr> element.
    """
    @property
    def val(self):
        val = self.get('val')
        mso_theme_color_idx = MSO_THEME_COLOR.from_xml(val)
        return mso_theme_color_idx

    def _set_val(self, mso_theme_color_idx):
        val = MSO_THEME_COLOR.to_xml(mso_theme_color_idx)
        self.set('val', val)


class CT_ScRgbColor(_BaseColorElement):
    """
    Custom element class for <a:scrgbClr> element.
    """


class CT_SRgbColor(_BaseColorElement):
    """
    Custom element class for <a:srgbClr> element.
    """


class CT_SystemColor(_BaseColorElement):
    """
    Custom element class for <a:sysClr> element.
    """

########NEW FILE########
__FILENAME__ = fill
# encoding: utf-8

"""
lxml custom element classes for DrawingML-related XML elements.
"""

from __future__ import absolute_import

from lxml import objectify

from ..ns import qn
from ..shared import SubElement


class OxmlElement(objectify.ObjectifiedElement):

    def _first_child_found_in(self, *tagnames):
        """
        Return the first child found with tag in *tagnames*, or None if
        not found.
        """
        for tagname in tagnames:
            child = self.find(qn(tagname))
            if child is not None:
                return child
        return None


class CT_BlipFillProperties(OxmlElement):
    """
    Custom element class for <a:blipFill> element.
    """


class CT_GradientFillProperties(OxmlElement):
    """
    Custom element class for <a:gradFill> element.
    """


class CT_GroupFillProperties(OxmlElement):
    """
    Custom element class for <a:grpFill> element.
    """


class CT_NoFillProperties(OxmlElement):
    """
    Custom element class for <a:NoFill> element.
    """


class CT_PatternFillProperties(OxmlElement):
    """
    Custom element class for <a:pattFill> element.
    """


class CT_SolidColorFillProperties(OxmlElement):
    """
    Custom element class for <a:solidFill> element.
    """
    @property
    def eg_colorchoice(self):
        """
        Return the child representing the EG_ColorChoice element group in
        this element, or |None| if no such child is present.
        """
        return self._first_child_found_in(
            'a:scrgbClr', 'a:srgbClr', 'a:hslClr', 'a:sysClr', 'a:schemeClr',
            'a:prstClr'
        )

    def get_or_change_to_schemeClr(self):
        """
        Return the <a:schemeClr> child of this <a:solidFill>, replacing any
        other EG_ColorChoice element if found, perhaps most commonly a
        <a:srgbClr> element.
        """
        if self.schemeClr is not None:
            return self.schemeClr
        self._clear_color_choice()
        return SubElement(self, 'a:schemeClr')

    def get_or_change_to_srgbClr(self):
        """
        Return the <a:srgbClr> child of this <a:solidFill>, replacing any
        other EG_ColorChoice element if found, perhaps most commonly a
        <a:schemeClr> element.
        """
        if self.srgbClr is not None:
            return self.srgbClr
        self._clear_color_choice()
        return self._add_srgbClr()

    @property
    def schemeClr(self):
        """
        The <a:schemeClr> child element, or None if not present.
        """
        return self.find(qn('a:schemeClr'))

    @property
    def srgbClr(self):
        """
        The <a:srgbClr> child element, or None if not present.
        """
        return self.find(qn('a:srgbClr'))

    def _add_srgbClr(self):
        """
        Return a newly added <a:srgbClr> child element.
        """
        return SubElement(self, 'a:srgbClr')

    def _clear_color_choice(self):
        """
        Remove the EG_ColorChoice child element, e.g. <a:schemeClr>.
        """
        eg_colorchoice_tagnames = (
            'a:scrgbClr', 'a:srgbClr', 'a:hslClr', 'a:sysClr', 'a:schemeClr',
            'a:prstClr'
        )
        for tagname in eg_colorchoice_tagnames:
            element = self.find(qn(tagname))
            if element is not None:
                self.remove(element)


class EG_FillProperties(object):

    __member_names__ = (
        'a:noFill', 'a:solidFill', 'a:gradFill', 'a:blipFill', 'a:pattFill',
        'a:grpFill'
    )

########NEW FILE########
__FILENAME__ = line
# encoding: utf-8

"""
lxml custom element classes for DrawingML line-related XML elements.
"""

from __future__ import absolute_import


class EG_LineDashProperties(object):

    __member_names__ = ('a:prstDash', 'a:custDash')


class EG_LineFillProperties(object):

    __member_names__ = (
        'a:noFill', 'a:solidFill', 'a:gradFill', 'a:pattFill'
    )


class EG_LineJoinProperties(object):

    __member_names__ = ('a:round', 'a:bevel', 'a:miter')

########NEW FILE########
__FILENAME__ = ns
# encoding: utf-8

"""
Namespace related objects.
"""

from __future__ import absolute_import


#: Maps namespace prefix to namespace name for all known PowerPoint XML
#: namespaces.
_nsmap = {
    'a':   ('http://schemas.openxmlformats.org/drawingml/2006/main'),
    'cp':  ('http://schemas.openxmlformats.org/package/2006/metadata/core-pro'
            'perties'),
    'ct':  ('http://schemas.openxmlformats.org/package/2006/content-types'),
    'dc':  ('http://purl.org/dc/elements/1.1/'),
    'dcmitype': ('http://purl.org/dc/dcmitype/'),
    'dcterms':  ('http://purl.org/dc/terms/'),
    'ep':  ('http://schemas.openxmlformats.org/officeDocument/2006/extended-p'
            'roperties'),
    'i':   ('http://schemas.openxmlformats.org/officeDocument/2006/relationsh'
            'ips/image'),
    'm':   ('http://schemas.openxmlformats.org/officeDocument/2006/math'),
    'mo':  ('http://schemas.microsoft.com/office/mac/office/2008/main'),
    'mv':  ('urn:schemas-microsoft-com:mac:vml'),
    'o':   ('urn:schemas-microsoft-com:office:office'),
    'p':   ('http://schemas.openxmlformats.org/presentationml/2006/main'),
    'pd':  ('http://schemas.openxmlformats.org/drawingml/2006/presentationDra'
            'wing'),
    'pic': ('http://schemas.openxmlformats.org/drawingml/2006/picture'),
    'pr':  ('http://schemas.openxmlformats.org/package/2006/relationships'),
    'r':   ('http://schemas.openxmlformats.org/officeDocument/2006/relationsh'
            'ips'),
    'sl':  ('http://schemas.openxmlformats.org/officeDocument/2006/relationsh'
            'ips/slideLayout'),
    'v':   ('urn:schemas-microsoft-com:vml'),
    've':  ('http://schemas.openxmlformats.org/markup-compatibility/2006'),
    'w':   ('http://schemas.openxmlformats.org/wordprocessingml/2006/main'),
    'w10': ('urn:schemas-microsoft-com:office:word'),
    'wne': ('http://schemas.microsoft.com/office/word/2006/wordml'),
    'wp':  ('http://schemas.openxmlformats.org/drawingml/2006/wordprocessingD'
            'rawing'),
    'xsi': ('http://www.w3.org/2001/XMLSchema-instance')
}


class NamespacePrefixedTag(str):
    """
    Value object that knows the semantics of an XML tag having a namespace
    prefix.
    """
    def __new__(cls, nstag, *args):
        return super(NamespacePrefixedTag, cls).__new__(cls, nstag)

    def __init__(self, nstag):
        self._pfx, self._local_part = nstag.split(':')
        self._ns_uri = _nsmap[self._pfx]

    @property
    def clark_name(self):
        return '{%s}%s' % (self._ns_uri, self._local_part)

    @property
    def local_part(self):
        """
        Return the local part of the tag as a string. E.g. 'foobar' is
        returned for tag 'f:foobar'.
        """
        return self._local_part

    @property
    def nsmap(self):
        """
        Return a dict having a single member, mapping the namespace prefix of
        this tag to it's namespace name (e.g. {'f': 'http://foo/bar'}). This
        is handy for passing to xpath calls and other uses.
        """
        return {self._pfx: self._ns_uri}

    @property
    def nspfx(self):
        """
        Return the string namespace prefix for the tag, e.g. 'f' is returned
        for tag 'f:foobar'.
        """
        return self._pfx

    @property
    def nsuri(self):
        """
        Return the namespace URI for the tag, e.g. 'http://foo/bar' would be
        returned for tag 'f:foobar' if the 'f' prefix maps to
        'http://foo/bar' in _nsmap.
        """
        return self._ns_uri


def namespaces(*prefixes):
    """
    Return a dict containing the subset namespace prefix mappings specified by
    *prefixes*. Any number of namespace prefixes can be supplied, e.g.
    namespaces('a', 'r', 'p').
    """
    namespaces = {}
    for prefix in prefixes:
        namespaces[prefix] = _nsmap[prefix]
    return namespaces


nsmap = namespaces  # alias for more compact use with Element()


def nsdecls(*prefixes):
    return ' '.join(['xmlns:%s="%s"' % (pfx, _nsmap[pfx]) for pfx in prefixes])


def nsuri(nspfx):
    """
    Return the namespace URI corresponding to *nspfx*. For example, it would
    return 'http://foo/bar' for an *nspfx* of 'f' if the 'f' prefix maps to
    'http://foo/bar' in _nsmap.
    """
    return _nsmap[nspfx]


def qn(namespace_prefixed_tag):
    """
    Return a Clark-notation qualified tag name corresponding to
    *namespace_prefixed_tag*, a string like 'p:body'. 'qn' stands for
    *qualified name*. As an example, ``qn('p:cSld')`` returns
    ``'{http://schemas.../main}cSld'``.
    """
    nsptag = NamespacePrefixedTag(namespace_prefixed_tag)
    return nsptag.clark_name

########NEW FILE########
__FILENAME__ = presentation
# encoding: utf-8

"""
Custom element classes for presentation-related XML elements.
"""

from __future__ import absolute_import

from .shared import BaseOxmlElement, child, Element, SubElement
from .ns import _nsmap, qn


class CT_Presentation(BaseOxmlElement):
    """
    ``<p:presentation>`` element, root of the Presentation part stored as
    ``/ppt/presentation.xml``.
    """
    def get_or_add_sldIdLst(self):
        """
        Return the <p:sldIdLst> child element, creating one first if
        necessary.
        """
        sldIdLst = child(self, 'p:sldIdLst')
        if sldIdLst is None:
            sldIdLst = self._add_sldIdLst()
        return sldIdLst

    def get_or_add_sldMasterIdLst(self):
        """
        Return the sldMasterIdLst child element, newly added if not present.
        """
        sldMasterIdLst = self.sldMasterIdLst
        if sldMasterIdLst is None:
            sldMasterIdLst = self._add_sldMasterIdLst()
        return sldMasterIdLst

    @property
    def sldMasterIdLst(self):
        """
        The first ``<p:sldMasterIdLst>`` child element, or |None| if not
        present.
        """
        return self.find(qn('p:sldMasterIdLst'))

    def _add_sldIdLst(self):
        """
        Return a newly created <p:sldIdLst> child element.
        """
        sldIdLst = Element('p:sldIdLst')
        # insert new sldIdLst element in right sequence
        sldSz = child(self, 'p:sldSz')
        if sldSz is not None:
            sldSz.addprevious(sldIdLst)
        else:
            notesSz = child(self, 'p:notesSz')
            notesSz.addprevious(sldIdLst)
        return sldIdLst

    def _add_sldMasterIdLst(self):
        """
        Return a newly added sldMasterIdLst child element. Assumes one is not
        present.
        """
        sldMasterIdLst = CT_SlideMasterIdList.new()
        self.insert(0, sldMasterIdLst)
        return sldMasterIdLst


class CT_SlideId(BaseOxmlElement):
    """
    ``<p:sldId>`` element, direct child of <p:sldIdLst> that contains an rId
    reference to a slide in the presentation.
    """
    @property
    def rId(self):
        return self.get(qn('r:id'))


class CT_SlideIdList(BaseOxmlElement):
    """
    ``<p:sldIdLst>`` element, direct child of <p:presentation> that contains
    a list of the slide parts in the presentation.
    """
    def __getitem__(self, idx):
        """
        Provide indexed access, (e.g. 'collection[0]').
        """
        return self.getchildren()[idx]

    def __iter__(self):
        return self.iterchildren()

    def __len__(self):
        return self.countchildren()

    def add_sldId(self, rId):
        """
        Return a reference to a newly created <p:sldId> child element having
        its r:id attribute set to *rId*.
        """
        sldId = SubElement(self, 'p:sldId', id=self._next_id)
        sldId.set(qn('r:id'), rId)
        return sldId

    @property
    def _next_id(self):
        """
        Return the next available slide ID as a string. Valid slide IDs start
        at 256. Unused ids in the sequences starting from 256 are used first.
        """
        id_str_lst = self.xpath('./p:sldId/@id', namespaces=_nsmap)
        used_ids = [int(id_str) for id_str in id_str_lst]
        for n in range(256, 258+len(used_ids)):
            if n not in used_ids:
                return str(n)


class CT_SlideMasterIdList(BaseOxmlElement):
    """
    ``<p:sldMasterIdLst>`` element, child of ``<p:presentation>`` containing
    references to the slide masters that belong to the presentation.
    """
    def __len__(self):
        """
        Return the number of ``<p:sldMasterId>`` child elements
        """
        sldMasterId_lst = self.findall(qn('p:sldMasterId'))
        return len(sldMasterId_lst)

    @classmethod
    def new(cls):
        """
        Return a new ``<p:sldMasterIdLst>`` element.
        """
        return Element('p:sldMasterIdLst')

    @property
    def sldMasterId_lst(self):
        """
        Sequence of ``<p:sldMasterId>`` child elements
        """
        return self.findall(qn('p:sldMasterId'))


class CT_SlideMasterIdListEntry(BaseOxmlElement):
    """
    ``<p:sldMasterId>`` element, child of ``<p:sldMasterIdLst>`` containing
    a reference to a slide master.
    """
    @property
    def rId(self):
        return self.get(qn('r:id'))


class CT_SlideSize(BaseOxmlElement):
    """
    ``<p:sldSz>`` element, direct child of <p:presentation> that contains the
    width and height of slides in the presentation.
    """
    def __setattr__(self, name, value):
        """
        Override ``__setattr__`` defined in ObjectifiedElement super class
        to intercept messages intended for custom property setters.
        """
        if name in ('cx', 'cy'):
            value_str = str(int(value))
            self.set(name, value_str)
        else:
            super(CT_SlideSize, self).__setattr__(name, value)

    @property
    def cx(self):
        return int(self.get('cx'))

    @property
    def cy(self):
        return int(self.get('cy'))

########NEW FILE########
__FILENAME__ = autoshape
# encoding: utf-8

"""
lxml custom element classes for shape-related XML elements.
"""

from __future__ import absolute_import

from lxml import objectify

from .. import parse_xml_bytes
from ..ns import nsdecls, qn
from .shared import (
    BaseShapeElement, ST_Direction, ST_PlaceholderSize, ST_PlaceholderType
)
from ..shared import BaseOxmlElement, child, SubElement
from ..text import CT_TextBody


class CT_PresetGeometry2D(BaseOxmlElement):
    """<a:prstGeom> custom element class"""
    @property
    def gd(self):
        """
        Sequence containing the ``gd`` element children of ``<a:avLst>``
        child element, empty if none are present.
        """
        try:
            gd_elms = tuple([gd for gd in self.avLst.gd])
        except AttributeError:
            gd_elms = ()
        return gd_elms

    @property
    def prst(self):
        """Value of required ``prst`` attribute."""
        return self.get('prst')

    def rewrite_guides(self, guides):
        """
        Remove any ``<a:gd>`` element children of ``<a:avLst>`` and replace
        them with ones having (name, val) in *guides*.
        """
        try:
            avLst = self.avLst
        except AttributeError:
            avLst = SubElement(self, 'a:avLst')
        if hasattr(self.avLst, 'gd'):
            for gd_elm in self.avLst.gd[:]:
                avLst.remove(gd_elm)
        for name, val in guides:
            gd = SubElement(avLst, 'a:gd')
            gd.set('name', name)
            gd.set('fmla', 'val %d' % val)


class CT_Shape(BaseShapeElement):
    """<p:sp> custom element class"""
    _autoshape_sp_tmpl = (
        '<p:sp %s>\n'
        '  <p:nvSpPr>\n'
        '    <p:cNvPr id="%s" name="%s"/>\n'
        '    <p:cNvSpPr/>\n'
        '    <p:nvPr/>\n'
        '  </p:nvSpPr>\n'
        '  <p:spPr>\n'
        '    <a:xfrm>\n'
        '      <a:off x="%s" y="%s"/>\n'
        '      <a:ext cx="%s" cy="%s"/>\n'
        '    </a:xfrm>\n'
        '    <a:prstGeom prst="%s">\n'
        '      <a:avLst/>\n'
        '    </a:prstGeom>\n'
        '  </p:spPr>\n'
        '  <p:style>\n'
        '    <a:lnRef idx="1">\n'
        '      <a:schemeClr val="accent1"/>\n'
        '    </a:lnRef>\n'
        '    <a:fillRef idx="3">\n'
        '      <a:schemeClr val="accent1"/>\n'
        '    </a:fillRef>\n'
        '    <a:effectRef idx="2">\n'
        '      <a:schemeClr val="accent1"/>\n'
        '    </a:effectRef>\n'
        '    <a:fontRef idx="minor">\n'
        '      <a:schemeClr val="lt1"/>\n'
        '    </a:fontRef>\n'
        '  </p:style>\n'
        '  <p:txBody>\n'
        '    <a:bodyPr rtlCol="0" anchor="ctr"/>\n'
        '    <a:lstStyle/>\n'
        '    <a:p>\n'
        '      <a:pPr algn="ctr"/>\n'
        '    </a:p>\n'
        '  </p:txBody>\n'
        '</p:sp>' %
        (nsdecls('a', 'p'), '%d', '%s', '%d', '%d', '%d', '%d', '%s')
    )

    _ph_sp_tmpl = (
        '<p:sp %s>\n'
        '  <p:nvSpPr>\n'
        '    <p:cNvPr id="%s" name="%s"/>\n'
        '    <p:cNvSpPr/>\n'
        '    <p:nvPr/>\n'
        '  </p:nvSpPr>\n'
        '  <p:spPr/>\n'
        '</p:sp>' % (nsdecls('a', 'p'), '%d', '%s')
    )

    _textbox_sp_tmpl = (
        '<p:sp %s>\n'
        '  <p:nvSpPr>\n'
        '    <p:cNvPr id="%s" name="%s"/>\n'
        '    <p:cNvSpPr txBox="1"/>\n'
        '    <p:nvPr/>\n'
        '  </p:nvSpPr>\n'
        '  <p:spPr>\n'
        '    <a:xfrm>\n'
        '      <a:off x="%s" y="%s"/>\n'
        '      <a:ext cx="%s" cy="%s"/>\n'
        '    </a:xfrm>\n'
        '    <a:prstGeom prst="rect">\n'
        '      <a:avLst/>\n'
        '    </a:prstGeom>\n'
        '    <a:noFill/>\n'
        '  </p:spPr>\n'
        '  <p:txBody>\n'
        '    <a:bodyPr wrap="none">\n'
        '      <a:spAutoFit/>\n'
        '    </a:bodyPr>\n'
        '    <a:lstStyle/>\n'
        '    <a:p/>\n'
        '  </p:txBody>\n'
        '</p:sp>' % (nsdecls('a', 'p'), '%d', '%s', '%d', '%d', '%d', '%d')
    )

    def get_or_add_ln(self):
        """
        Return the <a:ln> grandchild element, newly added if not present.
        """
        return self.spPr.get_or_add_ln()

    @property
    def is_autoshape(self):
        """
        True if this shape is an auto shape. A shape is an auto shape if it
        has a ``<a:prstGeom>`` element and does not have a txBox="1" attribute
        on cNvSpPr.
        """
        prstGeom = child(self.spPr, 'a:prstGeom')
        if prstGeom is None:
            return False
        txBox = self.nvSpPr.cNvSpPr.get('txBox')
        if txBox in ('true', '1'):
            return False
        return True

    @property
    def is_textbox(self):
        """
        True if this shape is a text box. A shape is a text box if it has a
        txBox="1" attribute on cNvSpPr.
        """
        txBox = self.nvSpPr.cNvSpPr.get('txBox')
        if txBox in ('true', '1'):
            return True
        return False

    @property
    def ln(self):
        """
        ``<a:ln>`` grand-child element or |None| if not present
        """
        return self.spPr.ln

    @staticmethod
    def new_autoshape_sp(id_, name, prst, left, top, width, height):
        """
        Return a new ``<p:sp>`` element tree configured as a base auto shape.
        """
        xml = CT_Shape._autoshape_sp_tmpl % (id_, name, left, top,
                                             width, height, prst)
        sp = parse_xml_bytes(xml)
        objectify.deannotate(sp, cleanup_namespaces=True)
        return sp

    @staticmethod
    def new_placeholder_sp(id_, name, ph_type, orient, sz, idx):
        """
        Return a new ``<p:sp>`` element tree configured as a placeholder
        shape.
        """
        xml = CT_Shape._ph_sp_tmpl % (id_, name)
        sp = parse_xml_bytes(xml)

        # placeholder shapes get a "no group" lock
        SubElement(sp.nvSpPr.cNvSpPr, 'a:spLocks')
        sp.nvSpPr.cNvSpPr[qn('a:spLocks')].set('noGrp', '1')

        # placeholder (ph) element attributes values vary by type
        ph = SubElement(sp.nvSpPr.nvPr, 'p:ph')
        if ph_type != ST_PlaceholderType.OBJ:
            ph.set('type', ph_type)
        if orient != ST_Direction.HORZ:
            ph.set('orient', orient)
        if sz != ST_PlaceholderSize.FULL:
            ph.set('sz', sz)
        if idx != 0:
            ph.set('idx', str(idx))

        placeholder_types_that_have_a_text_frame = (
            ST_PlaceholderType.TITLE, ST_PlaceholderType.CTR_TITLE,
            ST_PlaceholderType.SUB_TITLE, ST_PlaceholderType.BODY,
            ST_PlaceholderType.OBJ
        )

        if ph_type in placeholder_types_that_have_a_text_frame:
            sp.append(CT_TextBody.new_txBody())

        objectify.deannotate(sp, cleanup_namespaces=True)
        return sp

    @staticmethod
    def new_textbox_sp(id_, name, left, top, width, height):
        """
        Return a new ``<p:sp>`` element tree configured as a base textbox
        shape.
        """
        xml = CT_Shape._textbox_sp_tmpl % (id_, name, left, top, width, height)
        sp = parse_xml_bytes(xml)
        objectify.deannotate(sp, cleanup_namespaces=True)
        return sp

    @property
    def prst(self):
        """
        Value of ``prst`` attribute of ``<a:prstGeom>`` element or |None| if
        not present.
        """
        prstGeom = child(self.spPr, 'a:prstGeom')
        if prstGeom is None:
            return None
        return prstGeom.get('prst')

    @property
    def prstGeom(self):
        """
        Reference to ``<a:prstGeom>`` child element or |None| if this shape
        doesn't have one, for example, if it's a placeholder shape.
        """
        return child(self.spPr, 'a:prstGeom')

    @property
    def spPr(self):
        """
        Required ``<p:spPr>`` child element containing shape properties
        """
        return self.find(qn('p:spPr'))

########NEW FILE########
__FILENAME__ = connector
# encoding: utf-8

"""
lxml custom element classes for shape-related XML elements.
"""

from __future__ import absolute_import

from ..ns import qn
from .shared import BaseShapeElement


class CT_Connector(BaseShapeElement):
    """
    A line/connector shape ``<p:cxnSp>`` element
    """
    @property
    def spPr(self):
        return self.find(qn('p:spPr'))

########NEW FILE########
__FILENAME__ = graphfrm
# encoding: utf-8

"""
lxml custom element class for CT_GraphicalObjectFrame XML element.
"""

from __future__ import absolute_import

from lxml import objectify

from .. import parse_xml_bytes
from ..ns import nsdecls, qn
from .shared import BaseShapeElement
from .table import CT_Table


class CT_GraphicalObjectFrame(BaseShapeElement):
    """
    ``<p:graphicFrame>`` element, which is a container for a table, a chart,
    or another graphical object.
    """
    DATATYPE_TABLE = 'http://schemas.openxmlformats.org/drawingml/2006/table'

    _graphicFrame_tmpl = (
        '<p:graphicFrame %s>\n'
        '  <p:nvGraphicFramePr>\n'
        '    <p:cNvPr id="%s" name="%s"/>\n'
        '    <p:cNvGraphicFramePr>\n'
        '      <a:graphicFrameLocks noGrp="1"/>\n'
        '    </p:cNvGraphicFramePr>\n'
        '    <p:nvPr/>\n'
        '  </p:nvGraphicFramePr>\n'
        '  <p:xfrm>\n'
        '    <a:off x="%s" y="%s"/>\n'
        '    <a:ext cx="%s" cy="%s"/>\n'
        '  </p:xfrm>\n'
        '  <a:graphic>\n'
        '    <a:graphicData/>\n'
        '  </a:graphic>\n'
        '</p:graphicFrame>' %
        (nsdecls('a', 'p'), '%d', '%s', '%d', '%d', '%d', '%d')
    )

    def get_or_add_xfrm(self):
        """
        Return the required ``<p:xfrm>`` child element. Overrides version on
        BaseShapeElement.
        """
        return self.xfrm

    @property
    def has_table(self):
        """True if graphicFrame contains a table, False otherwise"""
        datatype = self[qn('a:graphic')].graphicData.get('uri')
        if datatype == CT_GraphicalObjectFrame.DATATYPE_TABLE:
            return True
        return False

    @staticmethod
    def new_graphicFrame(id_, name, left, top, width, height):
        """
        Return a new ``<p:graphicFrame>`` element tree suitable for containing
        a table or chart. Note that a graphicFrame element is not a valid
        shape until it contains a graphical object such as a table.
        """
        xml = CT_GraphicalObjectFrame._graphicFrame_tmpl % (
            id_, name, left, top, width, height)
        graphicFrame = parse_xml_bytes(xml)

        objectify.deannotate(graphicFrame, cleanup_namespaces=True)
        return graphicFrame

    @staticmethod
    def new_table(id_, name, rows, cols, left, top, width, height):
        """
        Return a ``<p:graphicFrame>`` element tree populated with a table
        element.
        """
        graphicFrame = CT_GraphicalObjectFrame.new_graphicFrame(
            id_, name, left, top, width, height)

        # set type of contained graphic to table
        graphicData = graphicFrame[qn('a:graphic')].graphicData
        graphicData.set('uri', CT_GraphicalObjectFrame.DATATYPE_TABLE)

        # add tbl element tree
        tbl = CT_Table.new_tbl(rows, cols, width, height)
        graphicData.append(tbl)

        objectify.deannotate(graphicFrame, cleanup_namespaces=True)
        return graphicFrame

    @property
    def xfrm(self):
        """
        The required ``<p:xfrm>`` child element
        """
        return self.find(qn('p:xfrm'))

########NEW FILE########
__FILENAME__ = groupshape
# encoding: utf-8

"""
lxml custom element classes for shape tree-related XML elements.
"""

from __future__ import absolute_import

from .autoshape import CT_Shape
from .graphfrm import CT_GraphicalObjectFrame
from ..ns import qn
from .picture import CT_Picture
from .shared import BaseShapeElement
from ..shared import BaseOxmlElement, Element


class CT_GroupShape(BaseShapeElement):
    """
    Used for the shape tree (``<p:spTree>``) element as well as the group
    shape (``<p:grpSp>``) element.
    """

    _shape_tags = (
        qn('p:sp'), qn('p:grpSp'), qn('p:graphicFrame'), qn('p:cxnSp'),
        qn('p:pic'), qn('p:contentPart')
    )

    def add_autoshape(self, id_, name, prst, x, y, cx, cy):
        """
        Append a new ``<p:sp>`` shape to the group/shapetree having the
        properties specified in call.
        """
        sp = CT_Shape.new_autoshape_sp(id_, name, prst, x, y, cx, cy)
        self.insert_element_before(sp, 'p:extLst')
        return sp

    def add_pic(self, id_, name, desc, rId, x, y, cx, cy):
        """
        Append a ``<p:pic>`` shape to the group/shapetree having properties
        as specified in call.
        """
        pic = CT_Picture.new_pic(id_, name, desc, rId, x, y, cx, cy)
        self.insert_element_before(pic, 'p:extLst')
        return pic

    def add_placeholder(self, id_, name, ph_type, orient, sz, idx):
        """
        Append a newly-created placeholder ``<p:sp>`` shape having the
        specified placeholder properties.
        """
        sp = CT_Shape.new_placeholder_sp(
            id_, name, ph_type, orient, sz, idx
        )
        self.insert_element_before(sp, 'p:extLst')
        return sp

    def add_table(self, id_, name, rows, cols, x, y, cx, cy):
        """
        Append a ``<p:graphicFrame>`` shape containing a table as specified
        in call.
        """
        graphicFrame = CT_GraphicalObjectFrame.new_table(
            id_, name, rows, cols, x, y, cx, cy
        )
        self.insert_element_before(graphicFrame, 'p:extLst')
        return graphicFrame

    def add_textbox(self, id_, name, x, y, cx, cy):
        """
        Append a newly-created textbox ``<p:sp>`` shape having the specified
        position and size.
        """
        sp = CT_Shape.new_textbox_sp(id_, name, x, y, cx, cy)
        self.insert_element_before(sp, 'p:extLst')
        return sp

    def get_or_add_xfrm(self):
        """
        Return the ``<a:xfrm>`` grandchild element, newly-added if not
        present.
        """
        return self.grpSpPr.get_or_add_xfrm()

    @property
    def grpSpPr(self):
        """
        The required ``<p:grpSpPr>`` child element
        """
        return self.find(qn('p:grpSpPr'))

    def iter_shape_elms(self):
        """
        Generate each child of this ``<p:spTree>`` element that corresponds
        to a shape, in the sequence they appear in the XML.
        """
        for elm in self.iterchildren():
            if elm.tag in self._shape_tags:
                yield elm

    @property
    def xfrm(self):
        """
        The ``<a:xfrm>`` grandchild element or |None| if not found
        """
        return self.grpSpPr.xfrm


class CT_GroupShapeProperties(BaseOxmlElement):
    """
    The ``<p:grpSpPr>`` element
    """
    def get_or_add_xfrm(self):
        """
        Return the <a:xfrm> child element, newly added if not already
        present.
        """
        xfrm = self.xfrm
        if xfrm is None:
            xfrm = Element('a:xfrm')
            self.insert(0, xfrm)
        return xfrm

    @property
    def xfrm(self):
        """
        The ``<a:xfrm>`` child element, or |None| if not present
        """
        return self.find(qn('a:xfrm'))

########NEW FILE########
__FILENAME__ = picture
# encoding: utf-8

"""
lxml custom element classes for picture-related XML elements.
"""

from __future__ import absolute_import

from lxml import objectify

from .. import parse_xml_bytes
from ..ns import nsdecls, qn
from .shared import BaseShapeElement


class CT_Picture(BaseShapeElement):
    """
    ``<p:pic>`` element, which represents a picture shape (an image placement
    on a slide).
    """
    _pic_tmpl = (
        '<p:pic %s>\n'
        '  <p:nvPicPr>\n'
        '    <p:cNvPr id="%s" name="%s" descr="%s"/>\n'
        '    <p:cNvPicPr>\n'
        '      <a:picLocks noChangeAspect="1"/>\n'
        '    </p:cNvPicPr>\n'
        '    <p:nvPr/>\n'
        '  </p:nvPicPr>\n'
        '  <p:blipFill>\n'
        '    <a:blip r:embed="%s"/>\n'
        '    <a:stretch>\n'
        '      <a:fillRect/>\n'
        '    </a:stretch>\n'
        '  </p:blipFill>\n'
        '  <p:spPr>\n'
        '    <a:xfrm>\n'
        '      <a:off x="%s" y="%s"/>\n'
        '      <a:ext cx="%s" cy="%s"/>\n'
        '    </a:xfrm>\n'
        '    <a:prstGeom prst="rect">\n'
        '      <a:avLst/>\n'
        '    </a:prstGeom>\n'
        '  </p:spPr>\n'
        '</p:pic>' % (nsdecls('a', 'p', 'r'), '%d', '%s', '%s', '%s',
                      '%d', '%d', '%d', '%d')
    )

    def get_or_add_ln(self):
        """
        Return the <a:ln> grandchild element, newly added if not present.
        """
        return self.spPr.get_or_add_ln()

    @property
    def ln(self):
        """
        ``<a:ln>`` grand-child element or |None| if not present
        """
        return self.spPr.ln

    @staticmethod
    def new_pic(id_, name, desc, rId, left, top, width, height):
        """
        Return a new ``<p:pic>`` element tree configured with the supplied
        parameters.
        """
        xml = CT_Picture._pic_tmpl % (id_, name, desc, rId,
                                      left, top, width, height)
        pic = parse_xml_bytes(xml)

        objectify.deannotate(pic, cleanup_namespaces=True)
        return pic

    @property
    def spPr(self):
        """
        The required <a:spPr> child element, raises if not present.
        """
        spPr = self.find(qn('p:spPr'))
        if spPr is None:
            # TODO: this should be ValidationError, not ValueError
            raise ValueError("pic element missing required spPr child")
        return spPr

########NEW FILE########
__FILENAME__ = shared
# encoding: utf-8

"""
Common shape-related oxml objects
"""

from __future__ import absolute_import

from ..dml.fill import EG_FillProperties
from ..dml.line import (
    EG_LineDashProperties, EG_LineFillProperties, EG_LineJoinProperties
)
from ..ns import _nsmap, qn
from ..shared import BaseOxmlElement, ChildTagnames, Element
from ...util import Emu


class BaseShapeElement(BaseOxmlElement):
    """
    Provides common behavior for shape element classes like CT_Shape,
    CT_Picture, etc.
    """
    def __getattr__(self, name):
        # common code for position and size attributes
        if name in ('x', 'y', 'cx', 'cy'):
            xfrm = self.xfrm
            if xfrm is None:
                return None
            return getattr(xfrm, name)
        else:
            return super(BaseShapeElement, self).__getattr__(name)

    def __setattr__(self, name, value):
        """
        Override ``__setattr__`` defined in ObjectifiedElement super class
        to intercept messages intended for custom property setters.
        """
        if name in ('x', 'y', 'cx', 'cy'):
            xfrm = self.get_or_add_xfrm()
            setattr(xfrm, name, value)
        else:
            super(BaseShapeElement, self).__setattr__(name, value)

    def get_or_add_xfrm(self):
        """
        Return the ``<a:xfrm>`` grandchild element, newly-added if not
        present. This version works for ``<p:sp>``, ``<p:cxnSp>``, and
        ``<p:pic>`` elements, others will need to override.
        """
        return self.spPr.get_or_add_xfrm()

    @property
    def has_ph_elm(self):
        """
        True if this shape element has a ``<p:ph>`` descendant, indicating it
        is a placeholder shape. False otherwise.
        """
        return self.ph is not None

    @property
    def ph(self):
        """
        The ``<p:ph>`` descendant element if there is one, None otherwise.
        """
        xpath = './*[1]/p:nvPr/p:ph'
        ph_elms = self.xpath(xpath, namespaces=_nsmap)
        if len(ph_elms) == 0:
            return None
        return ph_elms[0]

    @property
    def ph_idx(self):
        """
        Integer value of placeholder idx attribute, None if shape has no
        ``<p:ph>`` descendant.
        """
        ph = self.ph
        if ph is None:
            return None
        return int(ph.get('idx', 0))

    @property
    def ph_orient(self):
        """
        Placeholder orientation, e.g. ST_Direction.VERT ('vert'), None if
        shape has no ``<p:ph>`` descendant.
        """
        ph = self.ph
        if ph is None:
            return None
        return ph.get('orient', ST_Direction.HORZ)

    @property
    def ph_sz(self):
        """
        Placeholder size, e.g. ST_PlaceholderSize.HALF, None if shape has no
        ``<p:ph>`` descendant.
        """
        ph = self.ph
        if ph is None:
            return None
        return ph.get('sz', ST_PlaceholderSize.FULL)

    @property
    def ph_type(self):
        """
        Placeholder type, e.g. ST_PlaceholderType.TITLE ('title'), none if
        shape has no ``<p:ph>`` descendant.
        """
        ph = self.ph
        if ph is None:
            return None
        return ph.get('type', ST_PlaceholderType.OBJ)

    @property
    def shape_id(self):
        """
        Integer id of this shape
        """
        return int(self._nvXxPr.cNvPr.get('id'))

    @property
    def shape_name(self):
        """
        Name of this shape
        """
        return self._nvXxPr.cNvPr.get('name')

    @property
    def txBody(self):
        """
        Child ``<p:txBody>`` element, None if not present
        """
        return self.find(qn('p:txBody'))

    @property
    def xfrm(self):
        """
        The ``<a:xfrm>`` grandchild element or |None| if not found. This
        version works for ``<p:sp>``, ``<p:cxnSp>``, and ``<p:pic>``
        elements, others will need to override.
        """
        return self.spPr.xfrm

    @property
    def _nvXxPr(self):
        """
        Non-visual shape properties element for this shape. Actual name
        depends on the shape type, e.g. ``<p:nvPicPr>`` for picture shape.
        """
        return self.xpath('./*[1]', namespaces=_nsmap)[0]


class Fillable(BaseOxmlElement):
    """
    Provides common behavior for property elements that can contain one of
    the fill properties elements like ``<a:solidFill>``. Subclassed by
    CT_ShapeProperties and CT_LineProperties, perhaps others in the future.
    """
    def get_or_change_to_noFill(self):
        """
        Return the <a:noFill> child element, replacing any other fill
        element if found, e.g. a <a:gradFill> element.
        """
        if self.noFill is not None:
            return self.noFill
        self.remove_fill_element()
        return self._add_noFill()

    def get_or_change_to_solidFill(self):
        """
        Return the <a:solidFill> child element, replacing any other fill
        element if found, e.g. a <a:gradFill> element.
        """
        if self.solidFill is not None:
            return self.solidFill
        self.remove_fill_element()
        return self._add_solidFill()

    @property
    def noFill(self):
        """
        The <a:noFill> child element, or None if not present.
        """
        return self.find(qn('a:noFill'))

    @property
    def solidFill(self):
        """
        The <a:solidFill> child element, or None if not present.
        """
        return self.find(qn('a:solidFill'))

    def _add_noFill(self):
        """
        Return a newly added <a:noFill> child element, assuming no other fill
        EG_FillProperties element is present.
        """
        noFill = Element('a:noFill')
        successor_tagnames = self.child_tagnames_after('a:noFill')
        self.insert_element_before(noFill, *successor_tagnames)
        return noFill

    def _add_solidFill(self):
        """
        Return a newly added <a:solidFill> child element.
        """
        solidFill = Element('a:solidFill')
        successor_tagnames = self.child_tagnames_after('a:solidFill')
        self.insert_element_before(solidFill, *successor_tagnames)
        return solidFill


class EG_EffectProperties(object):

    __member_names__ = ('a:effectLst', 'a:effectDag')


class EG_Geometry(object):

    __member_names__ = ('a:custGeom', 'a:prstGeom')


class CT_LineProperties(Fillable):
    """
    Custom element class for <a:ln> element
    """

    child_tagnames = ChildTagnames.from_nested_sequence(
        EG_LineFillProperties.__member_names__,
        EG_LineDashProperties.__member_names__,
        EG_LineJoinProperties.__member_names__,
        'a:headEnd', 'a:tailEnd', 'a:extLst',
    )

    def __setattr__(self, name, value):
        """
        Override ``__setattr__`` defined in ObjectifiedElement super class
        to intercept messages intended for custom property setters.
        """
        if name == 'w':
            if value is None:
                if name in self.attrib:
                    del self.attrib[name]
            else:
                val = str(value)
                self.set(name, val)
        else:
            super(CT_LineProperties, self).__setattr__(name, value)

    @property
    def fill_element(self):
        """
        Return the child representing the EG_FillProperties element group
        member in this element, or |None| if no such child is present.
        """
        return self.first_child_found_in(
            *EG_LineFillProperties.__member_names__
        )

    def remove_fill_element(self):
        """
        Remove the fill child element, e.g ``<a:solidFill>`` if present.
        """
        self.remove_if_present(*EG_LineFillProperties.__member_names__)

    @property
    def w(self):
        """
        Integer value of optional ``w`` attribute, or |None| if not present
        """
        w_str = self.get('w')
        if w_str is None:
            return None
        return Emu(int(w_str))


class CT_Point2D(BaseOxmlElement):
    """
    Custom element class for <a:off> element.
    """
    def __setattr__(self, name, value):
        """
        Override ``__setattr__`` defined in ObjectifiedElement super class
        to intercept messages intended for custom property setters.
        """
        if name in ('x', 'y'):
            self.set(name, str(value))
        else:
            super(CT_Point2D, self).__setattr__(name, value)

    @property
    def x(self):
        """
        Integer value of required ``x`` attribute.
        """
        x_str = self.get('x')
        return int(x_str)

    @property
    def y(self):
        """
        Integer value of required ``y`` attribute.
        """
        y_str = self.get('y')
        return int(y_str)


class CT_PositiveSize2D(BaseOxmlElement):
    """
    Custom element class for <a:ext> element.
    """
    def __setattr__(self, name, value):
        """
        Override ``__setattr__`` defined in ObjectifiedElement super class
        to intercept messages intended for custom property setters.
        """
        if name in ('cx', 'cy'):
            self.set(name, str(value))
        else:
            super(CT_PositiveSize2D, self).__setattr__(name, value)

    @property
    def cx(self):
        """
        Integer value of required ``cx`` attribute.
        """
        cx_str = self.get('cx')
        return int(cx_str)

    @property
    def cy(self):
        """
        Integer value of required ``cy`` attribute.
        """
        cy_str = self.get('cy')
        return int(cy_str)


class CT_ShapeProperties(Fillable):
    """
    Custom element class for <p:spPr> element. Shared by ``<p:sp>``,
    ``<p:pic>``, and ``<p:cxnSp>`` elements as well as a few more obscure
    ones.
    """

    child_tagnames = ChildTagnames.from_nested_sequence(
        'a:xfrm',
        EG_Geometry.__member_names__,
        EG_FillProperties.__member_names__,
        'a:ln',
        EG_EffectProperties.__member_names__,
        'a:scene3d', 'a:sp3d', 'a:extLst',
    )

    @property
    def cx(self):
        """
        Shape width as an instance of Emu, or None if not present.
        """
        cx_str_lst = self.xpath('./a:xfrm/a:ext/@cx', namespaces=_nsmap)
        if not cx_str_lst:
            return None
        return Emu(cx_str_lst[0])

    @property
    def cy(self):
        """
        Shape height as an instance of Emu, or None if not present.
        """
        cy_str_lst = self.xpath('./a:xfrm/a:ext/@cy', namespaces=_nsmap)
        if not cy_str_lst:
            return None
        return Emu(cy_str_lst[0])

    @property
    def fill_element(self):
        """
        Return the child representing the EG_FillProperties element group
        member in this element, or |None| if no such child is present.
        """
        return self.first_child_found_in(
            *EG_FillProperties.__member_names__
        )

    def get_or_add_ln(self):
        """
        Return the <a:ln> child element, newly added if not present.
        """
        ln = self.ln
        if ln is None:
            ln = self._add_ln()
        return ln

    def get_or_add_xfrm(self):
        """
        Return the <a:xfrm> child element, newly added if not already
        present.
        """
        xfrm = self.xfrm
        if xfrm is None:
            xfrm = self._add_xfrm()
        return xfrm

    @property
    def ln(self):
        """
        The <a:ln> child element, or None if not present.
        """
        return self.find(qn('a:ln'))

    def remove_fill_element(self):
        """
        Remove the fill child element, e.g ``<a:solidFill>`` if present.
        """
        self.remove_if_present(*EG_FillProperties.__member_names__)

    @property
    def x(self):
        """
        The offset of the left edge of the shape from the left edge of the
        slide, as an instance of Emu. Corresponds to the value of the
        `./xfrm/off/@x` attribute. None if not present.
        """
        x_str_lst = self.xpath('./a:xfrm/a:off/@x', namespaces=_nsmap)
        if not x_str_lst:
            return None
        return Emu(x_str_lst[0])

    @property
    def xfrm(self):
        """
        The <a:xfrm> child element, or None if not present.
        """
        return self.find(qn('a:xfrm'))

    @property
    def y(self):
        """
        The offset of the top of the shape from the top of the slide, as an
        instance of Emu. None if not present.
        """
        y_str_lst = self.xpath('./a:xfrm/a:off/@y', namespaces=_nsmap)
        if not y_str_lst:
            return None
        return Emu(y_str_lst[0])

    def _add_ln(self):
        """
        Return a newly added <a:ln> child element. It is the caller's
        responsibility to ensure one is not already present.
        """
        ln = Element('a:ln')
        successor_tagnames = self.child_tagnames_after('a:ln')
        self.insert_element_before(ln, *successor_tagnames)
        return ln

    def _add_xfrm(self):
        """
        Return a newly added <a:xfrm> child element.
        """
        xfrm = Element('a:xfrm')
        successor_tagnames = self.child_tagnames_after('a:xfrm')
        self.insert_element_before(xfrm, *successor_tagnames)
        return xfrm


class CT_Transform2D(BaseOxmlElement):
    """
    Custom element class for <a:xfrm> element.
    """
    def __getattr__(self, name):
        # common code for position and size attributes
        if name in ('x', 'y'):
            off = self.off
            if off is None:
                return None
            return getattr(off, name)
        elif name in ('cx', 'cy'):
            ext = self.ext
            if ext is None:
                return None
            return getattr(ext, name)
        else:
            return super(CT_Transform2D, self).__getattr__(name)

    def __setattr__(self, name, value):
        """
        Override ``__setattr__`` defined in ObjectifiedElement super class
        to intercept messages intended for custom property setters.
        """
        if name in ('x', 'y'):
            off = self.get_or_add_off()
            setattr(off, name, value)
        elif name in ('cx', 'cy'):
            ext = self.get_or_add_ext()
            setattr(ext, name, value)
        else:
            super(CT_Transform2D, self).__setattr__(name, value)

    @property
    def ext(self):
        """
        The <a:ext> child element, or None if not present.
        """
        return self.find(qn('a:ext'))

    def get_or_add_ext(self):
        """
        Return the <a:ext> child element, newly added if not already
        present.
        """
        ext = self.ext
        if ext is None:
            ext = Element('a:ext')
            ext.set('cx', '0')
            ext.set('cy', '0')
            self.append(ext)
        return ext

    def get_or_add_off(self):
        """
        Return the <a:off> child element, newly added if not already
        present.
        """
        off = self.off
        if off is None:
            off = Element('a:off')
            off.set('x', '0')
            off.set('y', '0')
            self.insert(0, off)
        return off

    @property
    def off(self):
        """
        The <a:off> child element, or None if not present.
        """
        return self.find(qn('a:off'))


class ST_Direction(object):
    """
    Valid values for <p:ph orient=""> attribute
    """

    HORZ = 'horz'
    VERT = 'vert'


class ST_PlaceholderSize(object):
    """
    Valid values for <p:ph> sz (size) attribute
    """
    FULL = 'full'
    HALF = 'half'
    QUARTER = 'quarter'


class ST_PlaceholderType(object):

    BODY = 'body'
    CHART = 'chart'
    CLIP_ART = 'clipArt'
    CTR_TITLE = 'ctrTitle'
    DGM = 'dgm'
    DT = 'dt'
    FTR = 'ftr'
    HDR = 'hdr'
    MEDIA = 'media'
    OBJ = 'obj'
    PIC = 'pic'
    SLD_IMG = 'sldImg'
    SLD_NUM = 'sldNum'
    SUB_TITLE = 'subTitle'
    TBL = 'tbl'
    TITLE = 'title'

########NEW FILE########
__FILENAME__ = table
# encoding: utf-8

"""
lxml custom element classes for table-related XML elements.
"""

from __future__ import absolute_import

from lxml import objectify

from .. import parse_xml_bytes, XSD_TRUE
from ...enum.text import MSO_ANCHOR
from ..ns import nsdecls, qn
from ..shared import Element, SubElement


class CT_Table(objectify.ObjectifiedElement):
    """``<a:tbl>`` custom element class"""
    _tbl_tmpl = (
        '<a:tbl %s>\n'
        '  <a:tblPr firstRow="1" bandRow="1">\n'
        '    <a:tableStyleId>%s</a:tableStyleId>\n'
        '  </a:tblPr>\n'
        '  <a:tblGrid/>\n'
        '</a:tbl>' % (nsdecls('a'), '%s')
    )

    BOOLPROPS = (
        'bandCol', 'bandRow', 'firstCol', 'firstRow', 'lastCol', 'lastRow'
    )

    def __getattr__(self, attr):
        """
        Implement getter side of properties. Filters ``__getattr__`` messages
        to ObjectifiedElement base class to intercept messages intended for
        custom property getters.
        """
        if attr in CT_Table.BOOLPROPS:
            return self._get_boolean_property(attr)
        else:
            return super(CT_Table, self).__getattr__(attr)

    def __setattr__(self, attr, value):
        """
        Implement setter side of properties. Filters ``__setattr__`` messages
        to ObjectifiedElement base class to intercept messages intended for
        custom property setters.
        """
        if attr in CT_Table.BOOLPROPS:
            self._set_boolean_property(attr, value)
        else:
            super(CT_Table, self).__setattr__(attr, value)

    def _get_boolean_property(self, propname):
        """
        Generalized getter for the boolean properties on the ``<a:tblPr>``
        child element. Defaults to False if *propname* attribute is missing
        or ``<a:tblPr>`` element itself is not present.
        """
        if not self.has_tblPr:
            return False
        return self.tblPr.get(propname) in ('1', 'true')

    def _set_boolean_property(self, propname, value):
        """
        Generalized setter for boolean properties on the ``<a:tblPr>`` child
        element, setting *propname* attribute appropriately based on *value*.
        If *value* is truthy, the attribute is set to "1"; a tblPr child
        element is added if necessary. If *value* is falsey, the *propname*
        attribute is removed if present, allowing its default value of False
        to be its effective value.
        """
        if value:
            tblPr = self._get_or_insert_tblPr()
            tblPr.set(propname, XSD_TRUE)
        elif not self.has_tblPr:
            pass
        elif propname in self.tblPr.attrib:
            del self.tblPr.attrib[propname]

    @property
    def has_tblPr(self):
        """
        True if this ``<a:tbl>`` element has a ``<a:tblPr>`` child element,
        False otherwise.
        """
        try:
            self.tblPr
            return True
        except AttributeError:
            return False

    def _get_or_insert_tblPr(self):
        """Return tblPr child element, inserting a new one if not present"""
        if not self.has_tblPr:
            tblPr = Element('a:tblPr')
            self.insert(0, tblPr)
        return self.tblPr

    @staticmethod
    def new_tbl(rows, cols, width, height, tableStyleId=None):
        """Return a new ``<p:tbl>`` element tree"""
        # working hypothesis is this is the default table style GUID
        if tableStyleId is None:
            tableStyleId = '{5C22544A-7EE6-4342-B048-85BDC9FD1C3A}'

        xml = CT_Table._tbl_tmpl % (tableStyleId)
        tbl = parse_xml_bytes(xml)

        # add specified number of rows and columns
        rowheight = height/rows
        colwidth = width/cols

        for col in range(cols):
            # adjust width of last col to absorb any div error
            if col == cols-1:
                colwidth = width - ((cols-1) * colwidth)
            SubElement(tbl.tblGrid, 'a:gridCol', w=str(colwidth))

        for row in range(rows):
            # adjust height of last row to absorb any div error
            if row == rows-1:
                rowheight = height - ((rows-1) * rowheight)
            tr = SubElement(tbl, 'a:tr', h=str(rowheight))
            for col in range(cols):
                tr.append(CT_TableCell.new_tc())

        objectify.deannotate(tbl, cleanup_namespaces=True)
        return tbl


class CT_TableCell(objectify.ObjectifiedElement):
    """``<a:tc>`` custom element class"""
    _tc_tmpl = (
        '<a:tc %s>\n'
        '  <a:txBody>\n'
        '    <a:bodyPr/>\n'
        '    <a:lstStyle/>\n'
        '    <a:p/>\n'
        '  </a:txBody>\n'
        '  <a:tcPr/>\n'
        '</a:tc>' % nsdecls('a')
    )

    def __setattr__(self, attr, value):
        """
        This hack is needed to make setter side of properties work,
        overrides ``__setattr__`` defined in ObjectifiedElement super class
        just enough to route messages intended for custom property setters.
        """
        if attr == 'anchor':
            self._set_anchor(value)
        elif attr in ('marT', 'marR', 'marB', 'marL'):
            self._set_marX(attr, value)
        else:
            super(CT_TableCell, self).__setattr__(attr, value)

    @property
    def anchor(self):
        """
        String held in ``anchor`` attribute of ``<a:tcPr>`` child element of
        this ``<a:tc>`` element.
        """
        if self.tcPr is None:
            return None
        anchor = self.tcPr.get('anchor')
        return MSO_ANCHOR.from_xml(anchor)

    def get_or_add_tcPr(self):
        tcPr = self.tcPr
        if tcPr is None:
            tcPr = Element('a:tcPr')
            idx = 1 if self.txBody else 0
            self.insert(idx, tcPr)
        return tcPr

    def get_or_add_txBody(self):
        """
        Return the <a:rPr> child element of this <a:r> element, newly added
        if not already present.
        """
        if self.txBody is None:
            txBody = Element('a:txBody')
            SubElement(txBody, 'a:bodyPr')
            SubElement(txBody, 'a:p')
            self.insert(0, txBody)
        return self.txBody

    @property
    def marT(self):
        """
        Read/write integer top margin value represented in ``marT`` attribute
        of the ``<a:tcPr>`` child element of this ``<a:tc>`` element. If the
        attribute is not present, the default value ``45720`` (0.05 inches)
        is returned for top and bottom; ``91440`` (0.10 inches) is the
        default for left and right. Assigning |None| to any ``marX``
        property clears that attribute from the element, effectively setting
        it to the default value.
        """
        return self._get_marX('marT', 45720)

    @property
    def marR(self):
        """right margin value represented in ``marR`` attribute"""
        return self._get_marX('marR', 91440)

    @property
    def marB(self):
        """bottom margin value represented in ``marB`` attribute"""
        return self._get_marX('marB', 45720)

    @property
    def marL(self):
        """left margin value represented in ``marL`` attribute"""
        return self._get_marX('marL', 91440)

    @staticmethod
    def new_tc():
        """Return a new ``<a:tc>`` element tree"""
        xml = CT_TableCell._tc_tmpl
        tc = parse_xml_bytes(xml)
        objectify.deannotate(tc, cleanup_namespaces=True)
        return tc

    @property
    def tcPr(self):
        return self.find(qn('a:tcPr'))

    @property
    def txBody(self):
        """
        The <a:txBody> child element, or None if not present.
        """
        return self.find(qn('a:txBody'))

    def _clear_anchor(self):
        """
        Remove anchor attribute from ``<a:tcPr>`` if it exists
        """
        if self.tcPr is None:
            return
        if 'anchor' in self.tcPr.attrib:
            del self.tcPr.attrib['anchor']

    def _get_marX(self, attr_name, default):
        """
        generalized method to get margin values
        """
        if self.tcPr is None:
            return default
        return int(self.tcPr.get(attr_name, default))

    def _set_anchor(self, anchor_enum_idx):
        """
        Set value of anchor attribute on ``<a:tcPr>`` child element
        """
        anchor = MSO_ANCHOR.to_xml(anchor_enum_idx)
        if anchor is None:
            return self._clear_anchor()
        tcPr = self.get_or_add_tcPr()
        tcPr.set('anchor', anchor)

    def _set_marX(self, marX, value):
        """
        Set value of marX attribute on ``<a:tcPr>`` child element. If *marX*
        is |None|, the marX attribute is removed.
        """
        tcPr = self.get_or_add_tcPr()
        if value is None:
            if marX in tcPr.attrib:
                del tcPr.attrib[marX]
        else:
            tcPr.set(marX, str(value))


class CT_TableCellProperties(objectify.ObjectifiedElement):
    """
    ``<a:tcPr>`` custom element class
    """
    @property
    def fill_element(self):
        """
        Return the child representing the EG_FillProperties element group
        member in this element, or |None| if no such child is present.
        """
        return self._first_child_found_in(
            'a:noFill', 'a:solidFill', 'a:gradFill', 'a:blipFill',
            'a:pattFill', 'a:grpFill'
        )

    def get_or_change_to_noFill(self):
        """
        Return the <a:noFill> child element, replacing any other fill
        element if found, e.g. a <a:gradFill> element.
        """
        # return existing one if there is one
        if self.noFill is not None:
            return self.noFill
        # get rid of other fill element type if there is one
        self._remove_if_present(
            'a:solidFill', 'a:gradFill', 'a:blipFill', 'a:pattFill',
            'a:grpFill'
        )
        # add noFill element in right sequence
        return self._add_noFill()

    def get_or_change_to_solidFill(self):
        """
        Return the <a:solidFill> child element, replacing any other fill
        element if found, e.g. a <a:gradFill> element.
        """
        # return existing one if there is one
        if self.solidFill is not None:
            return self.solidFill
        # get rid of other fill element type if there is one
        self._remove_if_present(
            'a:noFill', 'a:gradFill', 'a:blipFill', 'a:pattFill', 'a:grpFill'
        )
        # add solidFill element in right sequence
        return self._add_solidFill()

    @property
    def noFill(self):
        """
        The <a:noFill> child element, or None if not present.
        """
        return self.find(qn('a:noFill'))

    @property
    def solidFill(self):
        """
        The <a:solidFill> child element, or None if not present.
        """
        return self.find(qn('a:solidFill'))

    def _add_noFill(self):
        """
        Return a newly added <a:noFill> child element; assume no other fill
        EG_FillProperties element is present.
        """
        noFill = Element('a:noFill')
        successor = self._first_successor_in('a:headers', 'a:extLst')
        if successor is not None:
            successor.addprevious(noFill)
        else:
            self.append(noFill)
        return noFill

    def _add_solidFill(self):
        """
        Return a newly added <a:solidFill> child element.
        """
        solidFill = Element('a:solidFill')
        successor = self._first_successor_in('a:headers', 'a:extLst')
        if successor is not None:
            successor.addprevious(solidFill)
        else:
            self.append(solidFill)
        return solidFill

    def _first_child_found_in(self, *tagnames):
        """
        Return the first child found with tag in *tagnames*, or None if
        not found.
        """
        for tagname in tagnames:
            child = self.find(qn(tagname))
            if child is not None:
                return child
        return None

    def _first_successor_in(self, *successor_tagnames):
        """
        Return the first child with tag in *successor_tagnames*, or None if
        not found.
        """
        for tagname in successor_tagnames:
            successor = self.find(qn(tagname))
            if successor is not None:
                return successor
        return None

    def _remove_if_present(self, *tagnames):
        for tagname in tagnames:
            element = self.find(qn(tagname))
            if element is not None:
                self.remove(element)

########NEW FILE########
__FILENAME__ = shared
# encoding: utf-8

"""
General purpose functions that raise the abstraction level of interacting with
lxml.objectify elements.
"""

from __future__ import absolute_import

import itertools
import re

from lxml import etree, objectify

from . import oxml_parser
from .ns import NamespacePrefixedTag, qn


def child(element, child_tag_str):
    """
    Return the first direct child of *element* having tag matching
    *child_tag_str* or |None| if no such child element is present.
    """
    nsptag = NamespacePrefixedTag(child_tag_str)
    xpath = './%s' % child_tag_str
    matching_children = element.xpath(xpath, namespaces=nsptag.nsmap)
    return matching_children[0] if len(matching_children) else None


def Element(nsptag_str, nsmap=None):
    """
    Return a 'loose' lxml element having the tag specified by *nsptag_str*.
    *nsptag_str* must contain the standard namespace prefix, e.g. 'a:tbl'.
    The resulting element is an instance of the custom element class for this
    tag name if one is defined.
    """
    nsptag = NamespacePrefixedTag(nsptag_str)
    nsmap = nsmap if nsmap is not None else nsptag.nsmap
    return oxml_parser.makeelement(nsptag.clark_name, nsmap=nsmap)


def get_or_add(parent, nsptag_str):
    """
    Return the first direct child element of *parent* with tag matching
    *nsptag_str*. If no such child is found, a new one is created and
    returned.
    """
    _child = child(parent, nsptag_str)
    if _child is None:
        _child = SubElement(parent, nsptag_str)
    return _child


def serialize_for_reading(element):
    """
    Serialize *element* to human-readable XML suitable for tests. No XML
    declaration.
    """
    xml = etree.tostring(element, encoding='unicode', pretty_print=True)
    return XmlString(xml)


def serialize_part_xml(part_elm):
    # if xsi parameter is not set to False, PowerPoint won't load without a
    # repair step; deannotate removes some original xsi:type tags in core.xml
    # if this parameter is left out (or set to True)
    objectify.deannotate(part_elm, xsi=False, cleanup_namespaces=False)
    xml = etree.tostring(part_elm, encoding='UTF-8', standalone=True)
    return xml


def SubElement(parent, nsptag_str, **extra):
    """
    Return an lxml element having *nsptag_str*, newly added as a direct child
    of *parent*. The new element is appended to the sequence of children, so
    this method is not suitable if the child element must be inserted at a
    different position in the sequence. The class of the returned element is
    the custom element class for its tag, if one is defined. Additional
    named parameters defined on lxml ``makeelement()`` are accepted, such as
    attrib=attr_dct and e.g. ``visible='1'``.
    """
    nsptag = NamespacePrefixedTag(nsptag_str)
    return objectify.SubElement(
        parent, nsptag.clark_name, nsmap=nsptag.nsmap, **extra
    )


class XmlString(unicode):
    """
    Provides string comparison override suitable for serialized XML that is
    useful for tests.
    """

    # '    <w:xyz xmlns:a="http://ns/decl/a" attr_name="val">text</w:xyz>'
    # |          |                                          ||           |
    # +----------+------------------------------------------++-----------+
    #  front      attrs                                     | text
    #                                                     close

    _xml_elm_line_patt = re.compile(
        '( *</?[\w:]+)(.*?)(/?>)([^<]*</\w+>)?'
    )

    def __eq__(self, other):
        lines = self.splitlines()
        lines_other = other.splitlines()
        if len(lines) != len(lines_other):
            return False
        for line, line_other in zip(lines, lines_other):
            if not self._eq_elm_strs(line, line_other):
                return False
        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def _attr_seq(self, attrs):
        """
        Return a sequence of attribute strings parsed from *attrs*. Each
        attribute string is stripped of whitespace on both ends.
        """
        attrs = attrs.strip()
        attr_lst = attrs.split()
        return sorted(attr_lst)

    def _eq_elm_strs(self, line, line_2):
        """
        Return True if the element in *line_2* is XML equivalent to the
        element in *line*.
        """
        front, attrs, close, text = self._parse_line(line)
        front_2, attrs_2, close_2, text_2 = self._parse_line(line_2)
        if front != front_2:
            return False
        if self._attr_seq(attrs) != self._attr_seq(attrs_2):
            return False
        if close != close_2:
            return False
        if text != text_2:
            return False
        return True

    def _parse_line(self, line):
        """
        Return front, attrs, close, text 4-tuple result of parsing XML element
        string *line*.
        """
        match = self._xml_elm_line_patt.match(line)
        front, attrs, close, text = [match.group(n) for n in range(1, 5)]
        return front, attrs, close, text


class BaseOxmlElement(objectify.ObjectifiedElement):
    """
    Provides common behavior for oxml element classes
    """
    @classmethod
    def child_tagnames_after(cls, tagname):
        """
        Return a sequence containing the namespace prefixed child tagnames,
        e.g. 'a:prstGeom', that occur after *tagname* in this element.
        """
        return cls.child_tagnames.tagnames_after(tagname)

    def first_child_found_in(self, *tagnames):
        """
        Return the first child found with tag in *tagnames*, or None if
        not found.
        """
        for tagname in tagnames:
            child = self.find(qn(tagname))
            if child is not None:
                return child
        return None

    def insert_element_before(self, elm, *tagnames):
        successor = self.first_child_found_in(*tagnames)
        if successor is not None:
            successor.addprevious(elm)
        else:
            self.append(elm)
        return elm

    def remove_if_present(self, *tagnames):
        """
        Remove all child elements having tagname in *tagnames*.
        """
        for tagname in tagnames:
            element = self.find(qn(tagname))
            if element is not None:
                self.remove(element)

    @property
    def xml(self):
        """
        Return XML string for this element, suitable for testing purposes.
        Pretty printed for readability and without an XML declaration at the
        top.
        """
        return serialize_for_reading(self)


class _Tagname(object):
    """
    A leaf node in a |_ChildTagnames| tree, containing an individual tagname.
    """
    def __init__(self, tagname):
        super(_Tagname, self).__init__()
        self._tagname = tagname

    def __contains__(self, tagname):
        return tagname == self._tagname

    @property
    def tagnames(self):
        """
        A sequence containing the tagname for this instance
        """
        return (self._tagname,)


class ChildTagnames(object):
    """
    Sequenced tree structure of namespace prefixed tagnames occuring in an
    XML element. An element group is represented by a child node of this same
    class. An element name is represented by an instance of _MemberName.
    """
    def __init__(self, children):
        super(ChildTagnames, self).__init__()
        self._children = tuple(children)

    def __contains__(self, tagname):
        """
        Return |True| if *tagname* belongs to this set of tagnames, |False|
        otherwise. Implements ``tagname in member_names`` functionality.
        """
        for child in self._children:
            if tagname in child:
                return True
        return False

    def __iter__(self):
        return iter(self._children)

    @classmethod
    def from_nested_sequence(cls, *nested_sequence):
        """
        Return an instance of this class constructed from a sequence of
        tagnames and tagname sequences representing the child elements and
        element groups of an XML element.
        """
        children = []
        for item in nested_sequence:
            if isinstance(item, basestring):
                member_name = _Tagname(item)
                children.append(member_name)
                continue
            subtree = ChildTagnames.from_nested_sequence(*item)
            children.append(subtree)
        return cls(children)

    @property
    def tagnames(self):
        """
        A sequence containing the tagnames in this subgraph, in depth-first
        order.
        """
        tagname_lists = [child.tagnames for child in self._children]
        tagnames = itertools.chain(*tagname_lists)
        return tuple(tagnames)

    def tagnames_after(self, tagname):
        """
        Return a sequence containing the tagnames in this subtree that occur
        in children that follow the child containing *tagname*.
        """
        if tagname not in self:
            raise ValueError("tagname '%s' not in element member names")
        # pass over child nodes before and within which item occurs
        found = False
        tagnames_after = []
        for subtree in self:
            if found:
                tagnames_after.extend(subtree.tagnames)
                continue
            found = tagname in subtree
        return tuple(tagnames_after)

########NEW FILE########
__FILENAME__ = slide
# encoding: utf-8

"""
lxml custom element classes for slide master-related XML elements.
"""

from __future__ import absolute_import

from .shared import BaseOxmlElement


class CT_Slide(BaseOxmlElement):
    """
    ``<p:sld>`` element, root of a slide part
    """

########NEW FILE########
__FILENAME__ = slidemaster
# encoding: utf-8

"""
lxml custom element classes for slide master-related XML elements.
"""

from __future__ import absolute_import

from .ns import qn
from .shared import BaseOxmlElement, Element


class CT_SlideLayoutIdList(BaseOxmlElement):
    """
    ``<p:sldLayoutIdLst>`` element, child of ``<p:sldMaster>`` containing
    references to the slide layouts that inherit from the slide master.
    """
    def __len__(self):
        """
        Return the number of ``<p:sldLayoutId>`` child elements
        """
        sldLayoutId_lst = self.findall(qn('p:sldLayoutId'))
        return len(sldLayoutId_lst)

    @classmethod
    def new(cls):
        """
        Return a new ``<p:sldLayoutIdLst>`` element.
        """
        return Element('p:sldLayoutIdLst')

    @property
    def sldLayoutId_lst(self):
        """
        Sequence of ``<p:sldLayoutId>`` child elements
        """
        return self.findall(qn('p:sldLayoutId'))


class CT_SlideLayoutIdListEntry(BaseOxmlElement):
    """
    ``<p:sldLayoutId>`` element, child of ``<p:sldLayoutIdLst>`` containing
    a reference to a slide layout.
    """
    @property
    def rId(self):
        return self.get(qn('r:id'))


class CT_SlideMaster(BaseOxmlElement):
    """
    ``<p:sldMaster>`` element, root of a slide master part
    """
    def get_or_add_sldLayoutIdLst(self):
        """
        Return the sldLayoutIdLst child element, newly added if not present.
        """
        sldLayoutIdLst = self.sldLayoutIdLst
        if sldLayoutIdLst is None:
            sldLayoutIdLst = self._add_sldLayoutIdLst()
        return sldLayoutIdLst

    @property
    def sldLayoutIdLst(self):
        """
        The first ``<p:sldLayoutIdLst>`` child element, or |None| if not
        present.
        """
        return self.find(qn('p:sldLayoutIdLst'))

    def _add_sldLayoutIdLst(self):
        """
        Return a newly added sldLayoutIdLst child element. Assumes one is not
        present.
        """
        sldLayoutIdLst = CT_SlideLayoutIdList.new()
        self.insert_element_before(
            sldLayoutIdLst, 'p:transition', 'p:timing', 'p:hf', 'p:txStyles',
            'p:extLst'
        )
        return sldLayoutIdLst

########NEW FILE########
__FILENAME__ = text
# encoding: utf-8

"""
lxml custom element classes for text-related XML elements.
"""

from __future__ import absolute_import

from lxml import objectify

from . import parse_xml_bytes
from ..enum.text import MSO_AUTO_SIZE
from .ns import nsdecls, nsmap, qn
from .shared import Element, SubElement
from ..util import Centipoints


class CT_Hyperlink(objectify.ObjectifiedElement):
    """
    Custom element class for <a:hlinkClick> elements.
    """
    @property
    def rId(self):
        return self.get(qn('r:id'))


class CT_RegularTextRun(objectify.ObjectifiedElement):
    """
    Custom element class for <a:r> elements.
    """
    def get_or_add_rPr(self):
        """
        Return the <a:rPr> child element of this <a:r> element, newly added
        if not already present.
        """
        if not hasattr(self, 'rPr'):
            self.insert(0, Element('a:rPr'))
        return self.rPr


class CT_TextBody(objectify.ObjectifiedElement):
    """
    <p:txBody> custom element class
    """
    _txBody_tmpl = (
        '<p:txBody %s>\n'
        '  <a:bodyPr/>\n'
        '  <a:lstStyle/>\n'
        '  <a:p/>\n'
        '</p:txBody>\n' % (nsdecls('a', 'p'))
    )

    @staticmethod
    def new_txBody():
        """Return a new ``<p:txBody>`` element tree"""
        xml = CT_TextBody._txBody_tmpl
        txBody = parse_xml_bytes(xml)
        objectify.deannotate(txBody, cleanup_namespaces=True)
        return txBody

    @property
    def bodyPr(self):
        return self[qn('a:bodyPr')]


class Schema(object):
    def __init__(self):
        self._attrs = {}

    def add_attr(self, attr):
        self._attrs[attr.prop_name] = attr

    @property
    def attrs(self):
        return self._attrs

    def is_attr_prop(self, prop_name):
        return prop_name in self._attrs.keys()


class Attribute(object):
    def __init__(self, prop_name, type_cls, attr_name=None):
        self._prop_name = prop_name
        self._type_cls = type_cls
        self._attr_name = attr_name if attr_name is not None else prop_name

    @property
    def prop_name(self):
        return self._prop_name

    def get(self, elm):
        if self._attr_name not in elm.attrib:
            return None
        xml_val = elm.get(self._attr_name)
        return self._type_cls.from_xml(xml_val)

    def set(self, elm, value):
        if value is None and self._attr_name in elm.attrib:
            del elm.attrib[self._attr_name]
        else:
            xml_val = self._type_cls.to_xml(value)
            elm.set(self._attr_name, xml_val)


class ST_Coordinate32(object):
    @classmethod
    def from_xml(cls, value):
        return int(value)

    @classmethod
    def to_xml(cls, value):
        if not isinstance(value, int):
            raise ValueError('int value required')
        return str(value)


class OxmlElement(objectify.ObjectifiedElement):

    def __getattr__(self, name):
        if self.schema.is_attr_prop(name):
            attr = self.schema.attrs[name]
            return attr.get(self)
        else:
            return super(OxmlElement, self).__getattr__(name)

    def __setattr__(self, name, value):
        """
        Override ``__setattr__`` defined in ObjectifiedElement super class
        to intercept messages intended for custom property setters.
        """
        if self.schema.is_attr_prop(name):
            attr = self.schema.attrs[name]
            attr.set(self, value)
        else:
            super(OxmlElement, self).__setattr__(name, value)


class CT_TextBodyProperties(OxmlElement):
    """
    <a:bodyPr> custom element class
    """
    schema = Schema()
    schema.add_attr(Attribute('lIns', ST_Coordinate32))
    schema.add_attr(Attribute('tIns', ST_Coordinate32))
    schema.add_attr(Attribute('rIns', ST_Coordinate32))
    schema.add_attr(Attribute('bIns', ST_Coordinate32))
    # lIns = Attribute(ST_Coordinate32)

    def __setattr__(self, name, value):
        """
        Implement property setters
        """
        if name == 'autofit':
            self._set_autofit(value)
        else:
            super(CT_TextBodyProperties, self).__setattr__(name, value)

    @property
    def autofit(self):
        """
        The autofit setting for the textframe
        """
        if self.noAutofit is not None:
            return MSO_AUTO_SIZE.NONE
        if self.normAutofit is not None:
            return MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE
        if self.spAutoFit is not None:
            return MSO_AUTO_SIZE.SHAPE_TO_FIT_TEXT
        return None

    @property
    def noAutofit(self):
        """
        The <a:noAutofit> child element, or None if not present.
        """
        return self.find(qn('a:noAutofit'))

    @property
    def normAutofit(self):
        """
        The <a:normAutofit> child element, or None if not present.
        """
        return self.find(qn('a:normAutofit'))

    @property
    def spAutoFit(self):
        """
        The <a:spAutoFit> child element, or None if not present.
        """
        return self.find(qn('a:spAutoFit'))

    def _add_noAutofit(self):
        noAutofit = Element('a:noAutofit')
        self._insert_autofit(noAutofit)
        return noAutofit

    def _add_normAutofit(self):
        normAutofit = Element('a:normAutofit')
        self._insert_autofit(normAutofit)
        return normAutofit

    def _add_spAutoFit(self):
        spAutoFit = Element('a:spAutoFit')
        self._insert_autofit(spAutoFit)
        return spAutoFit

    def _first_child_found_in(self, *tagnames):
        """
        Return the first child found with tag in *tagnames*, or None if
        not found.
        """
        for tagname in tagnames:
            child = self.find(qn(tagname))
            if child is not None:
                return child
        return None

    def _insert_autofit(self, autofit_elm):
        self._insert_element_before(
            autofit_elm, 'a:scene3d', 'a:sp3d', 'a:flatTx', 'a:extLst'
        )

    def _insert_element_before(self, elm, *tagnames):
        successor = self._first_child_found_in(*tagnames)
        if successor is not None:
            successor.addprevious(elm)
        else:
            self.append(elm)
        return elm

    def _remove_if_present(self, *tagnames):
        for tagname in tagnames:
            element = self.find(qn(tagname))
            if element is not None:
                self.remove(element)

    def _set_autofit(self, value):
        self._remove_if_present(
            'a:noAutofit', 'a:normAutofit', 'a:spAutoFit'
        )
        if value == MSO_AUTO_SIZE.NONE:
            self._add_noAutofit()
        elif value == MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE:
            self._add_normAutofit()
        elif value == MSO_AUTO_SIZE.SHAPE_TO_FIT_TEXT:
            self._add_spAutoFit()


class CT_TextCharacterProperties(objectify.ObjectifiedElement):
    """
    Custom element class for all of <a:rPr>, <a:defRPr>, and <a:endParaRPr>
    elements. 'rPr' is short for 'run properties', and it corresponds to the
    _Font proxy class.
    """
    def __getattr__(self, name):
        """
        Override ``__getattr__`` defined in ObjectifiedElement super class
        to intercept messages intended for custom property setters.
        """
        if name in ('b', 'i'):
            return self._get_bool_attr(name)
        elif name == 'fill_element':
            return self._eg_fill_properties()
        elif name == 'hlinkClick':
            return self.find(qn('a:hlinkClick'))
        else:
            return super(CT_TextCharacterProperties, self).__getattr__(name)

    def __setattr__(self, name, value):
        """
        Override ``__setattr__`` defined in ObjectifiedElement super class
        to intercept messages intended for custom property setters.
        """
        if name in ('b', 'i'):
            self._set_bool_attr(name, value)
        elif name == 'hlinkClick':
            self._set_hlinkClick(value)
        elif name == 'sz':
            emu_str = str(value.centipoints)
            self.set(name, emu_str)
        else:
            super(CT_TextCharacterProperties, self).__setattr__(name, value)

    def add_hlinkClick(self, rId):
        """
        Add an <a:hlinkClick> child element with r:id attribute set to *rId*.
        """
        assert self.find(qn('a:hlinkClick')) is None

        hlinkClick = Element('a:hlinkClick', nsmap('a', 'r'))
        hlinkClick.set(qn('r:id'), rId)

        # find right insertion spot, will go away once xmlchemy comes in
        if self.find(qn('a:hlinkMouseOver')):
            successor = self.find(qn('a:hlinkMouseOver'))
            successor.addprevious(hlinkClick)
        elif self.find(qn('a:rtl')):
            successor = self.find(qn('a:rtl'))
            successor.addprevious(hlinkClick)
        elif self.find(qn('a:extLst')):
            successor = self.find(qn('a:extLst'))
            successor.addprevious(hlinkClick)
        else:
            self.append(hlinkClick)

        return hlinkClick

    def get_or_add_latin(self):
        """
        Return the <a:latin> child element, a newly added one if not present.
        """
        latin = self.latin
        if latin is None:
            latin = self._add_latin()
        return latin

    def get_or_change_to_noFill(self):
        """
        Return the <a:noFill> child element, replacing any other fill
        element if found, e.g. a <a:gradFill> element.
        """
        # return existing one if there is one
        if self.noFill is not None:
            return self.noFill
        # get rid of other fill element type if there is one
        self._remove_if_present(
            'a:blipFill', 'a:gradFill', 'a:grpFill', 'a:pattFill',
            'a:solidFill'
        )
        # add noFill element in right sequence
        return self._add_noFill()

    def get_or_change_to_solidFill(self):
        """
        Return the <a:solidFill> child element, replacing any other fill
        element if found, e.g. a <a:gradFill> element.
        """
        # return existing one if there is one
        if self.solidFill is not None:
            return self.solidFill
        # get rid of other fill element type if there is one
        self._remove_if_present(
            'a:blipFill', 'a:gradFill', 'a:grpFill', 'a:noFill', 'a:pattFill'
        )
        # add solidFill element in right sequence
        return self._add_solidFill()

    @property
    def latin(self):
        """
        The <a:latin> child element, or None if not present.
        """
        return self.find(qn('a:latin'))

    @property
    def noFill(self):
        """
        The <a:noFill> child element, or None if not present.
        """
        return self.find(qn('a:noFill'))

    def remove_latin(self):
        """
        Remove the <a:latin> child element if it exists.
        """
        if self.latin is not None:
            self.remove(self.latin)

    @property
    def solidFill(self):
        """
        The <a:solidFill> child element, or None if not present.
        """
        return self.find(qn('a:solidFill'))

    @property
    def sz(self):
        """
        The value of the ``sz`` attribute, or None if not present.
        """
        val = self.get('sz')
        if val is None:
            return None
        return Centipoints(int(val))

    def _add_latin(self):
        """
        Return a newly added <a:latin> child element; assume one is not
        already present.
        """
        latin = Element('a:latin')
        successor = self._first_child_found_in(
            'a:ea', 'a:cs', 'a:sym', 'a:hlinkClick', 'a:hlinkMouseOver',
            'a:rtl', 'a:extLst'
        )
        if successor is not None:
            successor.addprevious(latin)
        else:
            self.append(latin)
        return latin

    def _add_noFill(self):
        """
        Return a newly added <a:noFill> child element, assuming no other fill
        EG_FillProperties element is present.
        """
        noFill = Element('a:noFill')
        ln = self.find(qn('a:ln'))
        if ln is not None:
            self.insert(1, noFill)
        else:
            self.insert(0, noFill)
        return noFill

    def _add_solidFill(self):
        """
        Return a newly added <a:solidFill> child element.
        """
        solidFill = Element('a:solidFill')
        ln = self.find(qn('a:ln'))
        if ln is not None:
            self.insert(1, solidFill)
        else:
            self.insert(0, solidFill)
        return solidFill

    def _eg_fill_properties(self):
        """
        Return the child representing the EG_FillProperties element group
        member in this element, or |None| if no such child is present.
        """
        return self._first_child_found_in(
            'a:noFill', 'a:solidFill', 'a:gradFill', 'a:blipFill',
            'a:pattFill', 'a:grpFill'
        )

    def _first_child_found_in(self, *tagnames):
        """
        Return the first child found with tag in *tagnames*, or None if
        not found.
        """
        for tagname in tagnames:
            child = self.find(qn(tagname))
            if child is not None:
                return child
        return None

    def _get_bool_attr(self, name):
        """
        True if *name* attribute is a truthy value, False if a falsey value,
        and None if no *name* attribute is present.
        """
        attr_str = self.get(name)
        if attr_str is None:
            return None
        if attr_str in ('true', '1'):
            return True
        return False

    def _remove_if_present(self, *tagnames):
        for tagname in tagnames:
            element = self.find(qn(tagname))
            if element is not None:
                self.remove(element)

    def _set_bool_attr(self, name, value):
        """
        Set boolean attribute of this element having *name* to boolean value
        of *value*.
        """
        if value is None:
            if name in self.attrib:
                del self.attrib[name]
        elif bool(value):
            self.set(name, '1')
        else:
            self.set(name, '0')

    def _set_hlinkClick(self, value):
        """
        For *value* is None, remove the ``<a:hlinkClick>`` child. For all
        other values, raise |ValueError|.
        """
        if value is not None:
            tmpl = "only None can be assigned to optional element, got '%s'"
            raise ValueError(tmpl % value)
        # value is None ----------------
        hlinkClick = self.find(qn('a:hlinkClick'))
        if hlinkClick is not None:
            self.remove(hlinkClick)


class CT_TextFont(objectify.ObjectifiedElement):
    """
    Custom element class for <a:latin>, <a:ea>, <a:cs>, and <a:sym> child
    elements of CT_TextCharacterProperties, e.g. <a:rPr>.
    """
    def __setattr__(self, name, value):
        if name == 'typeface':
            self.set('typeface', value)
        else:
            super(CT_TextFont, self).__setattr__(name, value)

    @property
    def typeface(self):
        """
        Typeface name to use for characters governed by this element, e.g.
        Latin characters if it is a <a:latin> element.
        """
        return self.get('typeface')


class CT_TextParagraph(objectify.ObjectifiedElement):
    """
    <a:p> custom element class
    """
    def add_r(self):
        """
        Return a newly appended <a:r> element.
        """
        r = Element('a:r')
        SubElement(r, 'a:t')
        # work out where to insert it, ahead of a:endParaRPr if there is one
        try:
            self.endParaRPr.addprevious(r)
        except AttributeError:
            self.append(r)
        return r

    def remove_child_r_elms(self):
        """
        Return self after removing all <a:r> child elements.
        """
        children = self.getchildren()
        for child in children:
            if child.tag == qn('a:r'):
                self.remove(child)
        return self

    def get_or_add_pPr(self):
        """
        Return the <a:pPr> child element of this <a:p> element, a newly added
        one if one is not present.
        """
        if not hasattr(self, 'pPr'):
            pPr = Element('a:pPr')
            self.insert(0, pPr)
        return self.pPr


class CT_TextParagraphProperties(objectify.ObjectifiedElement):
    """
    <a:pPr> custom element class
    """
    def __setattr__(self, name, value):
        """
        Override ``__setattr__`` defined in ObjectifiedElement super class
        to intercept messages intended for custom property setters.
        """
        if name in ('algn',):
            self._set_attr(name, value)
        else:
            super(CT_TextParagraphProperties, self).__setattr__(name, value)

    @property
    def algn(self):
        """
        Paragraph horizontal alignment value, like ``TAT.CENTER``. Value of
        'algn' attribute on <a:pPr> child element. None if no 'algn'
        attribute is present.
        """
        return self.get('algn')

    def get_or_add_defRPr(self):
        """
        Return the <a:defRPr> child element of this <a:pPr> element, newly
        added if not already present.
        """
        if not hasattr(self, 'defRPr'):
            defRPr = Element('a:defRPr')
            try:
                self.extLst.addprevious(defRPr)
            except AttributeError:
                self.append(defRPr)
        return self.defRPr

    def _set_attr(self, name, value):
        """
        Set attribute of this element having *name* to *value*.
        """
        if value is None and name in self.attrib:
            del self.attrib[name]
        else:
            self.set(name, value)

########NEW FILE########
__FILENAME__ = package
# encoding: utf-8

"""
API classes for dealing with presentations and other objects one typically
encounters as an end-user of the PowerPoint user interface.
"""

from __future__ import absolute_import

import os

from pptx.opc.constants import RELATIONSHIP_TYPE as RT
from pptx.opc.package import OpcPackage
from pptx.parts.coreprops import CoreProperties
from pptx.parts.image import ImageCollection
from pptx.util import lazyproperty


class Package(OpcPackage):
    """
    Return an instance of |Package| loaded from *file*, where *file* can be a
    path (a string) or a file-like object. If *file* is a path, it can be
    either a path to a PowerPoint `.pptx` file or a path to a directory
    containing an expanded presentation file, as would result from unzipping
    a `.pptx` file. If *file* is |None|, the default presentation template is
    loaded.
    """

    # path of the default presentation, used when no path specified
    _default_pptx_path = os.path.join(
        os.path.split(__file__)[0], 'templates', 'default.pptx'
    )

    def after_unmarshal(self):
        """
        Called by loading code after all parts and relationships have been
        loaded, to afford the opportunity for any required post-processing.
        """
        # gather image parts into _images
        self._images.load(self.parts)

    @lazyproperty
    def core_properties(self):
        """
        Instance of |CoreProperties| holding the read/write Dublin Core
        document properties for this presentation. Creates a default core
        properties part if one is not present (not common).
        """
        try:
            return self.part_related_by(RT.CORE_PROPERTIES)
        except KeyError:
            core_props = CoreProperties.default()
            self.relate_to(core_props, RT.CORE_PROPERTIES)
            return core_props

    @classmethod
    def open(cls, pkg_file=None):
        """
        Return |Package| instance loaded with contents of .pptx package at
        *pkg_file*, or the default presentation package if *pkg_file* is
        missing or |None|.
        """
        if pkg_file is None:
            pkg_file = cls._default_pptx_path
        return super(Package, cls).open(pkg_file)

    @property
    def presentation(self):
        """
        Reference to the |Presentation| instance contained in this package.
        """
        return self.main_document

    @lazyproperty
    def _images(self):
        """
        Collection containing a reference to each of the image parts in this
        package.
        """
        return ImageCollection()

########NEW FILE########
__FILENAME__ = coreprops
# encoding: utf-8

"""
Core properties part, corresponds to ``/docProps/core.xml`` part in package.
"""

from __future__ import absolute_import

from datetime import datetime

from ..opc.constants import CONTENT_TYPE as CT
from ..opc.package import Part
from ..opc.packuri import PackURI
from ..oxml import parse_xml_bytes
from ..oxml.coreprops import CT_CoreProperties


class CoreProperties(Part):
    """
    Corresponds to part named ``/docProps/core.xml``, containing the core
    document properties for this document package.
    """
    _propnames = (
        'author', 'category', 'comments', 'content_status', 'created',
        'identifier', 'keywords', 'language', 'last_modified_by',
        'last_printed', 'modified', 'revision', 'subject', 'title', 'version'
    )

    def __init__(self, partname, content_type, core_props_elm):
        super(CoreProperties, self).__init__(
            partname, content_type, element=core_props_elm
        )

    @classmethod
    def default(cls):
        core_props = cls._new()
        core_props.title = 'PowerPoint Presentation'
        core_props.last_modified_by = 'python-pptx'
        core_props.revision = 1
        core_props.modified = datetime.utcnow()
        return core_props

    @classmethod
    def load(cls, partname, content_type, blob, package):
        core_props_elm = parse_xml_bytes(blob)
        core_props = cls(partname, content_type, core_props_elm)
        return core_props

    @classmethod
    def _new(cls):
        partname = PackURI('/docProps/core.xml')
        content_type = CT.OPC_CORE_PROPERTIES
        core_props_elm = CT_CoreProperties.new_coreProperties()
        return CoreProperties(partname, content_type, core_props_elm)

    def __getattribute__(self, name):
        """
        Intercept attribute access to generalize property getters.
        """
        if name in CoreProperties._propnames:
            return getattr(self._element, name)
        else:
            return super(CoreProperties, self).__getattribute__(name)

    def __setattr__(self, name, value):
        """
        Intercept attribute assignment to generalize assignment to properties
        """
        if name in CoreProperties._propnames:
            setattr(self._element, name, value)
        else:
            super(CoreProperties, self).__setattr__(name, value)

########NEW FILE########
__FILENAME__ = image
# encoding: utf-8

"""
Image part objects, including Image
"""

import hashlib
import os
import posixpath

try:
    from PIL import Image as PIL_Image
except ImportError:
    import Image as PIL_Image

from StringIO import StringIO

from pptx.opc.package import Part
from pptx.opc.packuri import PackURI
from pptx.opc.spec import image_content_types
from pptx.parts.part import PartCollection
from pptx.util import Px


class Image(Part):
    """
    Return new Image part instance. *file* may be |None|, a path to a file (a
    string), or a file-like object. If *file* is |None|, no image is loaded
    and :meth:`_load` must be called before using the instance. Otherwise, the
    file referenced or contained in *file* is loaded. Corresponds to package
    files ppt/media/image[1-9][0-9]*.*.
    """
    def __init__(self, partname, content_type, blob, ext, filepath=None):
        super(Image, self).__init__(partname, content_type, blob)
        self._ext = ext
        self._filepath = filepath

    @classmethod
    def new(cls, partname, img_file):
        """
        Return a new Image part instance from *img_file*, which may be a path
        to a file (a string), or a file-like object. Corresponds to package
        files ppt/media/image[1-9][0-9]*.*.
        """
        filepath, ext, content_type, blob = cls._load_from_file(img_file)
        image = cls(partname, content_type, blob, ext, filepath)
        return image

    @property
    def ext(self):
        """
        Return file extension for this image e.g. ``'png'``.
        """
        return self._ext

    @classmethod
    def load(cls, partname, content_type, blob, package):
        ext = posixpath.splitext(partname)[1]
        return cls(partname, content_type, blob, ext)

    @property
    def _desc(self):
        """
        Return filename associated with this image, either the filename of the
        original image file the image was created with or a synthetic name of
        the form ``image.ext`` where ``ext`` is appropriate to the image file
        format, e.g. ``'jpg'``.
        """
        if self._filepath is not None:
            return os.path.split(self._filepath)[1]
        # return generic filename if original filename is unknown
        return 'image.%s' % self.ext

    @staticmethod
    def _ext_from_image_stream(stream):
        """
        Return the filename extension appropriate to the image file contained
        in *stream*.
        """
        ext_map = {
            'GIF': 'gif', 'JPEG': 'jpg', 'PNG': 'png', 'TIFF': 'tiff',
            'WMF': 'wmf'
        }
        stream.seek(0)
        format = PIL_Image.open(stream).format
        if format not in ext_map:
            tmpl = "unsupported image format, expected one of: %s, got '%s'"
            raise ValueError(tmpl % (ext_map.keys(), format))
        return ext_map[format]

    @staticmethod
    def _image_ext_content_type(ext):
        """
        Return the content type corresponding to filename extension *ext*
        """
        key = ext.lower()
        if key not in image_content_types:
            tmpl = "unsupported image file extension '%s'"
            raise ValueError(tmpl % (ext))
        content_type = image_content_types[key]
        return content_type

    @classmethod
    def _load_from_file(cls, img_file):
        """
        Load image from *img_file*, which is either a path to an image file
        or a file-like object.
        """
        if isinstance(img_file, basestring):  # img_file is a path
            filepath = img_file
            ext = os.path.splitext(filepath)[1][1:]
            content_type = cls._image_ext_content_type(ext)
            with open(filepath, 'rb') as f:
                blob = f.read()
        else:  # assume img_file is a file-like object
            filepath = None
            ext = cls._ext_from_image_stream(img_file)
            content_type = cls._image_ext_content_type(ext)
            img_file.seek(0)
            blob = img_file.read()
        return filepath, ext, content_type, blob

    def _scale(self, width, height):
        """
        Return scaled image dimensions based on supplied parameters. If
        *width* and *height* are both |None|, the native image size is
        returned. If neither *width* nor *height* is |None|, their values are
        returned unchanged. If a value is provided for either *width* or
        *height* and the other is |None|, the dimensions are scaled,
        preserving the image's aspect ratio.
        """
        native_width_px, native_height_px = self._size
        native_width = Px(native_width_px)
        native_height = Px(native_height_px)

        if width is None and height is None:
            width = native_width
            height = native_height
        elif width is None:
            scaling_factor = float(height) / float(native_height)
            width = int(round(native_width * scaling_factor))
        elif height is None:
            scaling_factor = float(width) / float(native_width)
            height = int(round(native_height * scaling_factor))
        return width, height

    @property
    def _sha1(self):
        """Return SHA1 hash digest for image"""
        return hashlib.sha1(self._blob).hexdigest()

    @property
    def _size(self):
        """
        Return *width*, *height* tuple representing native dimensions of
        image in pixels.
        """
        image_stream = StringIO(self._blob)
        width_px, height_px = PIL_Image.open(image_stream).size
        image_stream.close()
        return width_px, height_px


class ImageCollection(PartCollection):
    """
    Immutable sequence of images, typically belonging to an instance of
    |Package|. An image part containing a particular image blob appears only
    once in an instance, regardless of how many times it is referenced by a
    pic shape in a slide.
    """
    def __init__(self):
        super(ImageCollection, self).__init__()

    def add_image(self, file):
        """
        Return image part containing the image in *file*, which is either a
        path to an image file or a file-like object containing an image. If an
        image instance containing this same image already exists, that
        instance is returned. If it does not yet exist, a new one is created.
        """
        # use Image constructor to validate and characterize image file
        partname = PackURI('/ppt/media/image1.jpeg')  # dummy just for baseURI
        image = Image.new(partname, file)
        # return matching image if found
        for existing_image in self._values:
            if existing_image._sha1 == image._sha1:
                return existing_image
        # otherwise add it to collection and return new image
        self._values.append(image)
        self._rename_images()
        return image

    def load(self, parts):
        """
        Load the image collection with all the image parts in iterable
        *parts*.
        """
        def is_image_part(part):
            return (
                isinstance(part, Image) and
                part.partname.startswith('/ppt/media/')
            )
        for part in parts:
            if is_image_part(part):
                self.add_part(part)

    def _rename_images(self):
        """
        Assign partnames like ``/ppt/media/image9.png`` to all images in the
        collection. The name portion is always ``image``. The number part
        forms a continuous sequence starting at 1 (e.g. 1, 2, 3, ...). The
        extension is preserved during renaming.
        """
        for idx, image in enumerate(self._values):
            partname_str = '/ppt/media/image%d.%s' % (idx+1, image.ext)
            image.partname = PackURI(partname_str)

########NEW FILE########
__FILENAME__ = part
# encoding: utf-8

"""
General-purpose Part-related objects
"""

from pptx.opc.packuri import PackURI
from pptx.util import Collection


class PartCollection(Collection):
    """
    Sequence of parts. Sensitive to partname index when ordering parts added
    via _loadpart(), e.g. ``/ppt/slide/slide2.xml`` appears before
    ``/ppt/slide/slide10.xml`` rather than after it as it does in a
    lexicographical sort.
    """
    def __init__(self):
        super(PartCollection, self).__init__()

    def add_part(self, part):
        """
        Insert a new part into the collection such that list remains sorted
        in logical partname order (e.g. slide10.xml comes after slide9.xml).
        """
        new_partidx = part.partname.idx
        for idx, seq_part in enumerate(self._values):
            partidx = PackURI(seq_part.partname).idx
            if partidx > new_partidx:
                self._values.insert(idx, part)
                return
        self._values.append(part)

########NEW FILE########
__FILENAME__ = presentation
# encoding: utf-8

"""
Presentation part, the main part in a .pptx package.
"""

from __future__ import absolute_import

from warnings import warn

from ..opc.package import Part
from ..oxml import parse_xml_bytes
from .slide import SlideCollection
from ..util import lazyproperty


class PresentationPart(Part):
    """
    Top level class in object model, represents the contents of the /ppt
    directory of a .pptx file.
    """
    def __init__(self, partname, content_type, presentation_elm, package):
        super(PresentationPart, self).__init__(
            partname, content_type, element=presentation_elm, package=package
        )

    @classmethod
    def load(cls, partname, content_type, blob, package):
        presentation_elm = parse_xml_bytes(blob)
        presentation = cls(partname, content_type, presentation_elm, package)
        return presentation

    @property
    def sldMasterIdLst(self):
        """
        The ``<p:sldMasterIdLst>`` child element specifying the slide masters
        of this presentation in the XML.
        """
        return self._element.get_or_add_sldMasterIdLst()

    @lazyproperty
    def slide_masters(self):
        """
        Sequence of |SlideMaster| objects belonging to this presentation
        """
        return _SlideMasters(self)

    @property
    def slidemasters(self):
        """
        Deprecated. Use ``.slide_masters`` property instead.
        """
        msg = (
            'Presentation.slidemasters property is deprecated. Use .slide_ma'
            'sters instead.'
        )
        warn(msg, UserWarning, stacklevel=2)
        return self.slide_masters

    @property
    def slide_height(self):
        """
        Height of slides in this presentation, in English Metric Units (EMU)
        """
        sldSz = self._element.sldSz
        return sldSz.cy

    @slide_height.setter
    def slide_height(self, height):
        sldSz = self._element.sldSz
        sldSz.cy = height

    @property
    def slide_width(self):
        """
        Width of slides in this presentation, in English Metric Units (EMU)
        """
        sldSz = self._element.sldSz
        return sldSz.cx

    @slide_width.setter
    def slide_width(self, width):
        sldSz = self._element.sldSz
        sldSz.cx = width

    @lazyproperty
    def slides(self):
        """
        |SlideCollection| object containing the slides in this presentation.
        """
        sldIdLst = self._element.get_or_add_sldIdLst()
        slides = SlideCollection(sldIdLst, self)
        slides.rename_slides()  # start from known state
        return slides


class _SlideMasters(object):
    """
    Collection of |SlideMaster| instances belonging to a presentation. Has
    list access semantics, supporting indexed access, len(), and iteration.
    """
    def __init__(self, presentation):
        super(_SlideMasters, self).__init__()
        self._presentation = presentation

    def __getitem__(self, idx):
        """
        Provide indexed access, (e.g. ``slide_masters[2]``).
        """
        sldMasterId_lst = self._sldMasterIdLst.sldMasterId_lst
        if idx >= len(sldMasterId_lst):
            raise IndexError('slide master index out of range')
        rId = sldMasterId_lst[idx].rId
        return self._presentation.related_parts[rId]

    def __iter__(self):
        """
        Generate a reference to each of the |SlideMaster| instances in the
        collection, in sequence.
        """
        for rId in self._iter_rIds():
            yield self._presentation.related_parts[rId]

    def __len__(self):
        """
        Support len() built-in function (e.g. 'len(slide_masters) == 4').
        """
        return len(self._sldMasterIdLst)

    def _iter_rIds(self):
        """
        Generate the rId for each slide master in the collection, in
        sequence.
        """
        sldMasterId_lst = self._sldMasterIdLst.sldMasterId_lst
        for sldMasterId in sldMasterId_lst:
            yield sldMasterId.rId

    @property
    def _sldMasterIdLst(self):
        """
        The ``<p:sldMasterIdLst>`` element specifying the slide masters in
        this collection. This element is a child of the ``<p:presentation>``
        element, the root element of a presentation part.
        """
        return self._presentation.sldMasterIdLst

########NEW FILE########
__FILENAME__ = slide
# encoding: utf-8

"""
Slide and related objects.
"""

from __future__ import absolute_import

from warnings import warn

from ..opc.constants import CONTENT_TYPE as CT, RELATIONSHIP_TYPE as RT
from ..opc.package import Part
from ..opc.packuri import PackURI
from ..oxml import parse_xml_bytes
from ..oxml.ns import nsmap, _nsmap, qn
from ..oxml.shared import Element, SubElement
from ..oxml.shapes.shared import ST_Direction, ST_PlaceholderType
from ..shapes.autoshape import AutoShapeType
from ..shapes.placeholder import BasePlaceholder, BasePlaceholders
from ..shapes.shapetree import BaseShapeFactory, BaseShapeTree
from ..util import lazyproperty


class BaseSlide(Part):
    """
    Base class for slide parts, e.g. slide, slideLayout, slideMaster,
    notesSlide, notesMaster, and handoutMaster.
    """
    def __init__(self, partname, content_type, element, package):
        super(BaseSlide, self).__init__(
            partname, content_type, element=element, package=package
        )

    @classmethod
    def load(cls, partname, content_type, blob, package):
        slide_elm = parse_xml_bytes(blob)
        slide = cls(partname, content_type, slide_elm, package)
        return slide

    @property
    def name(self):
        """
        Internal name of this slide.
        """
        cSld = self._element.cSld
        return cSld.get('name', default='')

    @property
    def part(self):
        """
        Part of the parent protocol, "children" of the slide will not know
        the part that contains them so must ask their parent object. That
        chain of delegation ends here for slide child objects.
        """
        return self

    @property
    def spTree(self):
        """
        Reference to ``<p:spTree>`` element for this slide
        """
        spTree_lst = self._element.xpath(
            './p:cSld/p:spTree', namespaces=_nsmap
        )
        return spTree_lst[0]

    def _add_image(self, img_file):
        """
        Return 2-tuple ``(image, rId)`` representing an |Image| part
        corresponding to the image in *img_file*, newly created if no
        matching image part is already present. If the slide already has a
        relationship to an existing image, that relationship is reused.
        """
        image = self._package._images.add_image(img_file)
        rId = self.relate_to(image, RT.IMAGE)
        return (image, rId)


class Slide(BaseSlide):
    """
    Slide part. Corresponds to package files ppt/slides/slide[1-9][0-9]*.xml.
    """
    @classmethod
    def new(cls, slidelayout, partname, package):
        """
        Return a new slide based on *slidelayout* and having *partname*,
        created from scratch.
        """
        slide_elm = cls._minimal_element()
        slide = cls(partname, CT.PML_SLIDE, slide_elm, package)
        slide.shapes.clone_layout_placeholders(slidelayout)
        slide.relate_to(slidelayout, RT.SLIDE_LAYOUT)
        return slide

    @lazyproperty
    def placeholders(self):
        """
        Instance of |_SlidePlaceholders| containing sequence of placeholder
        shapes in this slide.
        """
        return _SlidePlaceholders(self)

    @lazyproperty
    def shapes(self):
        """
        Instance of |_SlideShapeTree| containing sequence of shape objects
        appearing on this slide.
        """
        return _SlideShapeTree(self)

    @property
    def slide_layout(self):
        """
        |SlideLayout| object this slide inherits appearance from.
        """
        return self.part_related_by(RT.SLIDE_LAYOUT)

    @property
    def slidelayout(self):
        """
        Deprecated. Use ``.slide_layout`` property instead.
        """
        msg = (
            'Slide.slidelayout property is deprecated. Use .slide_layout '
            'instead.'
        )
        warn(msg, UserWarning, stacklevel=2)
        return self.slide_layout

    @staticmethod
    def _minimal_element():
        """
        Return element containing the minimal XML for a slide, based on what
        is required by the XMLSchema.
        """
        sld = Element('p:sld', nsmap('a', 'p', 'r'))
        SubElement(sld, 'p:cSld')
        SubElement(sld.cSld, 'p:spTree')
        SubElement(sld.cSld.spTree, 'p:nvGrpSpPr')
        SubElement(sld.cSld.spTree.nvGrpSpPr, 'p:cNvPr')
        SubElement(sld.cSld.spTree.nvGrpSpPr, 'p:cNvGrpSpPr')
        SubElement(sld.cSld.spTree.nvGrpSpPr, 'p:nvPr')
        SubElement(sld.cSld.spTree, 'p:grpSpPr')
        sld.cSld.spTree.nvGrpSpPr.cNvPr.set('id', '1')
        sld.cSld.spTree.nvGrpSpPr.cNvPr.set('name', '')
        SubElement(sld, 'p:clrMapOvr')
        SubElement(sld.clrMapOvr, 'a:masterClrMapping')
        return sld


class SlideCollection(object):
    """
    Sequence of slides belonging to an instance of |Presentation|, having list
    semantics for access to individual slides. Supports indexed access,
    len(), and iteration.
    """
    def __init__(self, sldIdLst, prs):
        super(SlideCollection, self).__init__()
        self._sldIdLst = sldIdLst
        self._prs = prs

    def __getitem__(self, idx):
        """
        Provide indexed access, (e.g. 'slides[0]').
        """
        if idx >= len(self._sldIdLst):
            raise IndexError('slide index out of range')
        rId = self._sldIdLst[idx].rId
        return self._prs.related_parts[rId]

    def __iter__(self):
        """
        Support iteration (e.g. 'for slide in slides:').
        """
        for sldId in self._sldIdLst:
            rId = sldId.rId
            yield self._prs.related_parts[rId]

    def __len__(self):
        """
        Support len() built-in function (e.g. 'len(slides) == 4').
        """
        return len(self._sldIdLst)

    def add_slide(self, slidelayout):
        """
        Return a newly added slide that inherits layout from *slidelayout*.
        """
        partname = self._next_partname
        package = self._prs.package
        slide = Slide.new(slidelayout, partname, package)
        rId = self._prs.relate_to(slide, RT.SLIDE)
        self._sldIdLst.add_sldId(rId)
        return slide

    def rename_slides(self):
        """
        Assign partnames like ``/ppt/slides/slide9.xml`` to all slides in the
        collection. The name portion is always ``slide``. The number part
        forms a continuous sequence starting at 1 (e.g. 1, 2, 3, ...). The
        extension is always ``.xml``.
        """
        for idx, slide in enumerate(self):
            partname_str = '/ppt/slides/slide%d.xml' % (idx+1)
            slide.partname = PackURI(partname_str)

    @property
    def _next_partname(self):
        """
        Return |PackURI| instance containing the partname for a slide to be
        appended to this slide collection, e.g. ``/ppt/slides/slide9.xml``
        for a slide collection containing 8 slides.
        """
        partname_str = '/ppt/slides/slide%d.xml' % (len(self)+1)
        return PackURI(partname_str)


class _SlideShapeTree(BaseShapeTree):
    """
    Sequence of shapes appearing on a slide. The first shape in the sequence
    is the backmost in z-order and the last shape is topmost. Supports indexed
    access, len(), index(), and iteration.
    """
    def add_picture(self, image_file, left, top, width=None, height=None):
        """
        Add picture shape displaying image in *image_file*, where
        *image_file* can be either a path to a file (a string) or a file-like
        object.
        """
        image_part, rId = self._get_or_add_image_part(image_file)
        pic = self._add_pic_from_image_part(
            image_part, rId, left, top, width, height
        )
        picture = self._shape_factory(pic)
        return picture

    def add_shape(self, autoshape_type_id, left, top, width, height):
        """
        Add auto shape of type specified by *autoshape_type_id* (like
        ``MSO_SHAPE.RECTANGLE``) and of specified size at specified position.
        """
        autoshape_type = AutoShapeType(autoshape_type_id)
        sp = self._add_sp_from_autoshape_type(
            autoshape_type, left, top, width, height
        )
        shape = self._shape_factory(sp)
        return shape

    def add_table(self, rows, cols, left, top, width, height):
        """
        Add table shape with the specified number of *rows* and *cols* at the
        specified position with the specified size. *width* is evenly
        distributed between the *cols* columns of the new table. Likewise,
        *height* is evenly distributed between the *rows* rows created.
        """
        graphicFrame = self._add_graphicFrame_containing_table(
            rows, cols, left, top, width, height
        )
        table = self._shape_factory(graphicFrame)
        return table

    def add_textbox(self, left, top, width, height):
        """
        Add text box shape of specified size at specified position on slide.
        """
        sp = self._add_textbox_sp(left, top, width, height)
        textbox = self._shape_factory(sp)
        return textbox

    def clone_layout_placeholders(self, slide_layout):
        """
        Add placeholder shapes based on those in *slide_layout*. Z-order of
        placeholders is preserved. Latent placeholders (date, slide number,
        and footer) are not cloned.
        """
        for placeholder in slide_layout.iter_cloneable_placeholders():
            self._clone_layout_placeholder(placeholder)

    def index(self, shape):
        """
        Return the index of *shape* in this sequence, raising |ValueError| if
        *shape* is not in the collection.
        """
        shape_elm = shape.element
        for idx, elm in enumerate(self._spTree.iter_shape_elms()):
            if elm is shape_elm:
                return idx
        raise ValueError('shape not in collection')

    @property
    def placeholders(self):
        """
        Instance of |_SlidePlaceholders| containing sequence of placeholder
        shapes in this slide.
        """
        return self._slide.placeholders

    @property
    def title(self):
        """
        The title placeholder shape on the slide or |None| if the slide has
        no title placeholder.
        """
        for elm in self._spTree.iter_shape_elms():
            if elm.ph_idx == 0:
                return self._shape_factory(elm)
        return None

    def _add_graphicFrame_containing_table(self, rows, cols, x, y, cx, cy):
        """
        Return a newly added ``<p:graphicFrame>`` element containing a table
        as specified by the parameters.
        """
        id_ = self._next_shape_id
        name = 'Table %d' % (id_-1)
        graphicFrame = self._spTree.add_table(
            id_, name, rows, cols, x, y, cx, cy
        )
        return graphicFrame

    def _add_pic_from_image_part(self, image_part, rId, x, y, cx, cy):
        """
        Return a newly added ``<p:pic>`` element specifying a picture shape
        displaying *image_part* with size and position specified by *x*, *y*,
        *cx*, and *cy*. The element is appended to the shape tree, causing it
        to be displayed first in z-order on the slide.
        """
        id = self._next_shape_id
        name = 'Picture %d' % (id-1)
        desc = image_part._desc
        scaled_cx, scaled_cy = image_part._scale(cx, cy)

        pic = self._spTree.add_pic(
            id, name, desc, rId, x, y, scaled_cx, scaled_cy
        )

        return pic

    def _add_sp_from_autoshape_type(self, autoshape_type, x, y, cx, cy):
        """
        Return a newly-added ``<p:sp>`` element for a shape of
        *autoshape_type* at position (x, y) and of size (cx, cy).
        """
        id_ = self._next_shape_id
        name = '%s %d' % (autoshape_type.basename, id_-1)
        sp = self._spTree.add_autoshape(
            id_, name, autoshape_type.prst, x, y, cx, cy
        )
        return sp

    def _add_textbox_sp(self, x, y, cx, cy):
        """
        Return a newly-added textbox ``<p:sp>`` element at position (x, y)
        and of size (cx, cy).
        """
        id_ = self._next_shape_id
        name = 'TextBox %d' % (id_-1)
        sp = self._spTree.add_textbox(id_, name, x, y, cx, cy)
        return sp

    def _clone_layout_placeholder(self, layout_placeholder):
        """
        Add a new placeholder shape based on the slide layout placeholder
        *layout_ph*.
        """
        id_ = self._next_shape_id
        ph_type = layout_placeholder.ph_type
        orient = layout_placeholder.orient
        name = self._next_ph_name(ph_type, id_, orient)
        sz = layout_placeholder.sz
        idx = layout_placeholder.idx

        self._spTree.add_placeholder(id_, name, ph_type, orient, sz, idx)

    def _get_or_add_image_part(self, image_file):
        """
        Return an (image_part, rId) 2-tuple corresponding to an image part
        containing the image in *image_file*, and related to this object's
        part with the key *rId*. If the image part and/or relationship
        already exists, they are reused, otherwise they are newly created.
        """
        slide = self._slide
        image_part, rId = slide._add_image(image_file)
        return image_part, rId

    def _next_ph_name(self, ph_type, id, orient):
        """
        Next unique placeholder name for placeholder shape of type *ph_type*,
        with id number *id* and orientation *orient*. Usually will be standard
        placeholder root name suffixed with id-1, e.g.
        _next_ph_name(ST_PlaceholderType.TBL, 4, 'horz') ==>
        'Table Placeholder 3'. The number is incremented as necessary to make
        the name unique within the collection. If *orient* is ``'vert'``, the
        placeholder name is prefixed with ``'Vertical '``.
        """
        basename = {
            # BODY is named 'Notes Placeholder' in a notes master
            ST_PlaceholderType.BODY:      'Text Placeholder',
            ST_PlaceholderType.CHART:     'Chart Placeholder',
            ST_PlaceholderType.CLIP_ART:  'ClipArt Placeholder',
            ST_PlaceholderType.CTR_TITLE: 'Title',
            ST_PlaceholderType.DGM:       'SmartArt Placeholder',
            ST_PlaceholderType.DT:        'Date Placeholder',
            ST_PlaceholderType.FTR:       'Footer Placeholder',
            ST_PlaceholderType.HDR:       'Header Placeholder',
            ST_PlaceholderType.MEDIA:     'Media Placeholder',
            ST_PlaceholderType.OBJ:       'Content Placeholder',
            ST_PlaceholderType.PIC:       'Picture Placeholder',
            ST_PlaceholderType.SLD_IMG:   'Slide Image Placeholder',
            ST_PlaceholderType.SLD_NUM:   'Slide Number Placeholder',
            ST_PlaceholderType.SUB_TITLE: 'Subtitle',
            ST_PlaceholderType.TBL:       'Table Placeholder',
            ST_PlaceholderType.TITLE:     'Title',
        }[ph_type]

        # prefix rootname with 'Vertical ' if orient is 'vert'
        if orient == ST_Direction.VERT:
            basename = 'Vertical %s' % basename

        # increment numpart as necessary to make name unique
        numpart = id - 1
        names = self._spTree.xpath('//p:cNvPr/@name', namespaces=_nsmap)
        while True:
            name = '%s %d' % (basename, numpart)
            if name not in names:
                break
            numpart += 1

        return name

    def _shape_factory(self, shape_elm):
        """
        Return an instance of the appropriate shape proxy class for
        *shape_elm*.
        """
        return _SlideShapeFactory(shape_elm, self)


def _SlideShapeFactory(shape_elm, parent):
    """
    Return an instance of the appropriate shape proxy class for *shape_elm*
    on a slide.
    """
    tag_name = shape_elm.tag
    if tag_name == qn('p:sp') and shape_elm.has_ph_elm:
        return _SlidePlaceholder(shape_elm, parent)
    return BaseShapeFactory(shape_elm, parent)


class _SlidePlaceholder(BasePlaceholder):
    """
    Placeholder shape on a slide. Inherits shape properties from its
    corresponding slide layout placeholder.
    """
    @property
    def height(self):
        """
        The effective height of this placeholder shape; its directly-applied
        height if it has one, otherwise the height of its parent layout
        placeholder.
        """
        return self._effective_value('height')

    @property
    def left(self):
        """
        The effective left of this placeholder shape; its directly-applied
        left if it has one, otherwise the left of its parent layout
        placeholder.
        """
        return self._effective_value('left')

    @property
    def top(self):
        """
        The effective top of this placeholder shape; its directly-applied
        top if it has one, otherwise the top of its parent layout
        placeholder.
        """
        return self._effective_value('top')

    @property
    def width(self):
        """
        The effective width of this placeholder shape; its directly-applied
        width if it has one, otherwise the width of its parent layout
        placeholder.
        """
        return self._effective_value('width')

    def _effective_value(self, attr_name):
        """
        The effective value of *attr_name* on this placeholder shape; its
        directly-applied value if it has one, otherwise the value on the
        layout placeholder it inherits from.
        """
        directly_applied_value = getattr(
            super(_SlidePlaceholder, self), attr_name
        )
        if directly_applied_value is not None:
            return directly_applied_value
        return self._inherited_value(attr_name)

    def _inherited_value(self, attr_name):
        """
        The attribute value, e.g. 'width' of the layout placeholder this
        slide placeholder inherits from
        """
        layout_placeholder = self._layout_placeholder
        if layout_placeholder is None:
            return None
        inherited_value = getattr(layout_placeholder, attr_name)
        return inherited_value

    @property
    def _layout_placeholder(self):
        """
        The layout placeholder shape this slide placeholder inherits from
        """
        layout = self._slide_layout
        layout_placeholder = layout.placeholders.get(idx=self.idx)
        return layout_placeholder

    @property
    def _slide_layout(self):
        """
        The slide layout from which the slide this placeholder belongs to
        inherits.
        """
        slide = self.part
        return slide.slide_layout


class _SlidePlaceholders(BasePlaceholders):
    """
    Sequence of placeholder shapes on a slide.
    """
    def _shape_factory(self, shape_elm):
        """
        Return an instance of the appropriate shape proxy class for
        *shape_elm* on a slide.
        """
        return _SlideShapeFactory(shape_elm, self)

########NEW FILE########
__FILENAME__ = slidelayout
# encoding: utf-8

"""
Slide layout-related objects.
"""

from __future__ import absolute_import

from warnings import warn

from ..opc.constants import RELATIONSHIP_TYPE as RT
from ..oxml.ns import qn
from ..oxml.shapes.shared import ST_PlaceholderType
from ..shapes.placeholder import BasePlaceholder, BasePlaceholders
from ..shapes.shapetree import BaseShapeFactory, BaseShapeTree
from .slide import BaseSlide
from ..util import lazyproperty


class SlideLayout(BaseSlide):
    """
    Slide layout part. Corresponds to package files
    ``ppt/slideLayouts/slideLayout[1-9][0-9]*.xml``.
    """
    def iter_cloneable_placeholders(self):
        """
        Generate a reference to each layout placeholder on this slide layout
        that should be cloned to a slide when the layout is applied to the
        slide.
        """
        latent_ph_types = (
            ST_PlaceholderType.DT, ST_PlaceholderType.FTR,
            ST_PlaceholderType.SLD_NUM
        )
        for ph in self.placeholders:
            if ph.ph_type not in latent_ph_types:
                yield ph

    @lazyproperty
    def placeholders(self):
        """
        Instance of |_LayoutPlaceholders| containing sequence of placeholder
        shapes in this slide layout, sorted in *idx* order.
        """
        return _LayoutPlaceholders(self)

    @lazyproperty
    def shapes(self):
        """
        Instance of |_LayoutShapeTree| containing sequence of shapes
        appearing on this slide layout.
        """
        return _LayoutShapeTree(self)

    @property
    def slide_master(self):
        """
        Slide master from which this slide layout inherits properties.
        """
        return self.part_related_by(RT.SLIDE_MASTER)

    @property
    def slidemaster(self):
        """
        Deprecated. Use ``.slide_master`` property instead.
        """
        msg = (
            'SlideLayout.slidemaster property is deprecated. Use .slide_mast'
            'er instead.'
        )
        warn(msg, UserWarning, stacklevel=2)
        return self.slide_master


class _LayoutShapeTree(BaseShapeTree):
    """
    Sequence of shapes appearing on a slide layout. The first shape in the
    sequence is the backmost in z-order and the last shape is topmost.
    Supports indexed access, len(), index(), and iteration.
    """
    def _shape_factory(self, shape_elm):
        """
        Return an instance of the appropriate shape proxy class for
        *shape_elm*.
        """
        parent = self
        return _LayoutShapeFactory(shape_elm, parent)


def _LayoutShapeFactory(shape_elm, parent):
    """
    Return an instance of the appropriate shape proxy class for *shape_elm*
    on a slide layout.
    """
    tag_name = shape_elm.tag
    if tag_name == qn('p:sp') and shape_elm.has_ph_elm:
        return _LayoutPlaceholder(shape_elm, parent)
    return BaseShapeFactory(shape_elm, parent)


class _LayoutPlaceholder(BasePlaceholder):
    """
    Placeholder shape on a slide layout, providing differentiated behavior
    for slide layout placeholders, in particular, inheriting shape properties
    from the master placeholder having the same type, when a matching one
    exists.
    """
    @property
    def height(self):
        """
        The effective height of this placeholder shape; its directly-applied
        height if it has one, otherwise the height of its parent master
        placeholder.
        """
        return self._direct_or_inherited_value('height')

    @property
    def left(self):
        """
        The effective left of this placeholder shape; its directly-applied
        left if it has one, otherwise the left of its parent master
        placeholder.
        """
        return self._direct_or_inherited_value('left')

    @property
    def top(self):
        """
        The effective top of this placeholder shape; its directly-applied
        top if it has one, otherwise the top of its parent master
        placeholder.
        """
        return self._direct_or_inherited_value('top')

    @property
    def width(self):
        """
        The effective width of this placeholder shape; its directly-applied
        width if it has one, otherwise the width of its parent master
        placeholder.
        """
        return self._direct_or_inherited_value('width')

    def _direct_or_inherited_value(self, attr_name):
        """
        The effective value of *attr_name* on this placeholder shape; its
        directly-applied value if it has one, otherwise the value on the
        master placeholder it inherits from.
        """
        directly_applied_value = getattr(
            super(_LayoutPlaceholder, self), attr_name
        )
        if directly_applied_value is not None:
            return directly_applied_value
        inherited_value = self._inherited_value(attr_name)
        return inherited_value

    def _inherited_value(self, attr_name):
        """
        The attribute value, e.g. 'width' of the parent master placeholder of
        this placeholder shape
        """
        master_placeholder = self._master_placeholder
        if master_placeholder is None:
            return None
        inherited_value = getattr(master_placeholder, attr_name)
        return inherited_value

    @property
    def _master_placeholder(self):
        """
        The master placeholder shape this layout placeholder inherits from.
        """
        inheritee_ph_type = {
            'body':     'body',
            'chart':    'body',
            'clipArt':  'body',
            'ctrTitle': 'title',
            'dgm':      'body',
            'dt':       'dt',
            'ftr':      'ftr',
            'media':    'body',
            'obj':      'body',
            'pic':      'body',
            'sldNum':   'sldNum',
            'subTitle': 'body',
            'tbl':      'body',
            'title':    'title',
        }[self.ph_type]
        slide_master = self._slide_master
        master_placeholder = slide_master.placeholders.get(
            inheritee_ph_type, None
        )
        return master_placeholder

    @property
    def _slide_master(self):
        """
        The slide master this placeholder inherits from.
        """
        slide_layout = self.part
        slide_master = slide_layout.slide_master
        return slide_master


class _LayoutPlaceholders(BasePlaceholders):
    """
    Sequence of _LayoutPlaceholder instances representing the placeholder
    shapes on a slide layout.
    """
    def get(self, idx, default=None):
        """
        Return the first placeholder shape with matching *idx* value, or
        *default* if not found.
        """
        for placeholder in self:
            if placeholder.idx == idx:
                return placeholder
        return default

    def _shape_factory(self, shape_elm):
        """
        Return an instance of the appropriate shape proxy class for
        *shape_elm*.
        """
        parent = self
        return _LayoutShapeFactory(shape_elm, parent)

########NEW FILE########
__FILENAME__ = slidemaster
# encoding: utf-8

"""
Objects related to the slide master part
"""

from __future__ import absolute_import, print_function

from warnings import warn

from ..oxml.ns import qn
from ..shapes.placeholder import BasePlaceholder, BasePlaceholders
from ..shapes.shapetree import BaseShapeFactory, BaseShapeTree
from .slide import BaseSlide
from ..util import lazyproperty


class SlideMaster(BaseSlide):
    """
    Slide master part. Corresponds to package files
    ppt/slideMasters/slideMaster[1-9][0-9]*.xml.
    """
    @lazyproperty
    def placeholders(self):
        """
        Instance of |_MasterPlaceholders| containing sequence of placeholder
        shapes in this slide master, sorted in *idx* order.
        """
        return _MasterPlaceholders(self)

    @lazyproperty
    def shapes(self):
        """
        Instance of |_MasterShapeTree| containing sequence of shape objects
        appearing on this slide.
        """
        return _MasterShapeTree(self)

    @property
    def sldLayoutIdLst(self):
        """
        The ``<p:sldLayoutIdLst>`` child element specifying the slide layouts
        of this slide master in the XML.
        """
        return self._element.get_or_add_sldLayoutIdLst()

    @lazyproperty
    def slide_layouts(self):
        """
        Sequence of |SlideLayout| objects belonging to this slide master
        """
        return _SlideLayouts(self)

    @property
    def slidelayouts(self):
        """
        Deprecated. Use ``.slide_layouts`` property instead.
        """
        msg = (
            'SlideMaster.slidelayouts property is deprecated. Use .slide_lay'
            'outs instead.'
        )
        warn(msg, UserWarning, stacklevel=2)
        return self.slide_layouts


class _SlideLayouts(object):
    """
    Collection of slide layouts belonging to an instance of |SlideMaster|,
    having list access semantics. Supports indexed access, len(), and
    iteration.
    """
    def __init__(self, slide_master):
        super(_SlideLayouts, self).__init__()
        self._slide_master = slide_master

    def __getitem__(self, idx):
        """
        Provide indexed access, (e.g. ``slide_layouts[2]``).
        """
        if idx >= len(self._sldLayoutIdLst):
            raise IndexError('slide layout index out of range')
        rId = self._sldLayoutIdLst.sldLayoutId_lst[idx].rId
        return self._slide_master.related_parts[rId]

    def __iter__(self):
        """
        Generate a reference to each of the |SlideLayout| instances in the
        collection, in sequence.
        """
        for rId in self._iter_rIds():
            yield self._slide_master.related_parts[rId]

    def __len__(self):
        """
        Support len() built-in function (e.g. 'len(slides) == 4').
        """
        return len(self._sldLayoutIdLst)

    def _iter_rIds(self):
        """
        Generate the rId for each slide layout in the collection, in
        sequence.
        """
        sldLayoutId_lst = self._sldLayoutIdLst.sldLayoutId_lst
        for sldLayoutId in sldLayoutId_lst:
            yield sldLayoutId.rId

    @property
    def _sldLayoutIdLst(self):
        """
        The ``<p:sldLayoutIdLst>`` element specifying the slide layouts in
        this collection. This element is a child of the ``<p:sldMaster>``
        element, the root element of a slide master part.
        """
        return self._slide_master.sldLayoutIdLst


class _MasterShapeTree(BaseShapeTree):
    """
    Sequence of shapes appearing on a slide master. The first shape in the
    sequence is the backmost in z-order and the last shape is topmost.
    Supports indexed access, len(), and iteration.
    """
    def _shape_factory(self, shape_elm):
        """
        Return an instance of the appropriate shape proxy class for
        *shape_elm*.
        """
        return _MasterShapeFactory(shape_elm, self)


def _MasterShapeFactory(shape_elm, parent):
    """
    Return an instance of the appropriate shape proxy class for *shape_elm*
    on a slide master.
    """
    tag_name = shape_elm.tag
    if tag_name == qn('p:sp') and shape_elm.has_ph_elm:
        return _MasterPlaceholder(shape_elm, parent)
    return BaseShapeFactory(shape_elm, parent)


class _MasterPlaceholder(BasePlaceholder):
    """
    Placeholder shape on a slide master.
    """


class _MasterPlaceholders(BasePlaceholders):
    """
    Sequence of _MasterPlaceholder instances representing the placeholder
    shapes on a slide master.
    """
    def get(self, ph_type, default=None):
        """
        Return the first placeholder shape with type *ph_type* (e.g. 'body'),
        or *default* if no such placeholder shape is present in the
        collection.
        """
        for placeholder in self:
            if placeholder.ph_type == ph_type:
                return placeholder
        return default

    def _shape_factory(self, shape_elm):
        """
        Return an instance of the appropriate shape proxy class for
        *shape_elm*.
        """
        return _MasterShapeFactory(shape_elm, self)

########NEW FILE########
__FILENAME__ = autoshape
# encoding: utf-8

"""
Autoshape-related objects such as Shape and Adjustment.
"""

from numbers import Number

from ..dml.fill import FillFormat
from ..dml.line import LineFormat
from ..enum.shapes import MSO_AUTO_SHAPE_TYPE, MSO_SHAPE_TYPE
from .shape import BaseShape
from ..spec import autoshape_types
from ..util import lazyproperty


class Adjustment(object):
    """
    An adjustment value for an autoshape.

    An adjustment value corresponds to the position of an adjustment handle on
    an auto shape. Adjustment handles are the small yellow diamond-shaped
    handles that appear on certain auto shapes and allow the outline of the
    shape to be adjusted. For example, a rounded rectangle has an adjustment
    handle that allows the radius of its corner rounding to be adjusted.

    Values are |float| and generally range from 0.0 to 1.0, although the value
    can be negative or greater than 1.0 in certain circumstances.
    """
    def __init__(self, name, def_val, actual=None):
        super(Adjustment, self).__init__()
        self.name = name
        self.def_val = def_val
        self.actual = actual

    @property
    def effective_value(self):
        """
        Read/write |float| representing normalized adjustment value for this
        adjustment. Actual values are a large-ish integer expressed in shape
        coordinates, nominally between 0 and 100,000. The effective value is
        normalized to a corresponding value nominally between 0.0 and 1.0.
        Intuitively this represents the proportion of the width or height of
        the shape at which the adjustment value is located from its starting
        point. For simple shapes such as a rounded rectangle, this intuitive
        correspondence holds. For more complicated shapes and at more extreme
        shape proportions (e.g. width is much greater than height), the value
        can become negative or greater than 1.0.
        """
        raw_value = self.actual
        if raw_value is None:
            raw_value = self.def_val
        return self._normalize(raw_value)

    @effective_value.setter
    def effective_value(self, value):
        if not isinstance(value, Number):
            tmpl = "adjustment value must be numeric, got '%s'"
            raise ValueError(tmpl % value)
        self.actual = self._denormalize(value)

    @staticmethod
    def _denormalize(value):
        """
        Return integer corresponding to normalized *raw_value* on unit basis
        of 100,000. See Adjustment.normalize for additional details.
        """
        return int(value * 100000.0)

    @staticmethod
    def _normalize(raw_value):
        """
        Return normalized value for *raw_value*. A normalized value is a
        |float| between 0.0 and 1.0 for nominal raw values between 0 and
        100,000. Raw values less than 0 and greater than 100,000 are valid
        and return values calculated on the same unit basis of 100,000.
        """
        return raw_value / 100000.0

    @property
    def val(self):
        """
        Denormalized effective value (expressed in shape coordinates),
        suitable for using in the XML.
        """
        return self.actual if self.actual is not None else self.def_val


class AdjustmentCollection(object):
    """
    Sequence of |Adjustment| instances for an auto shape, each representing
    an available adjustment for a shape of its type. Supports ``len()`` and
    indexed access, e.g. ``shape.adjustments[1] = 0.15``.
    """
    def __init__(self, prstGeom):
        super(AdjustmentCollection, self).__init__()
        self._adjustments_ = self._initialized_adjustments(prstGeom)
        self._prstGeom = prstGeom

    def __getitem__(self, key):
        """Provides indexed access, (e.g. 'adjustments[9]')."""
        return self._adjustments_[key].effective_value

    def __setitem__(self, key, value):
        """
        Provides item assignment via an indexed expression, e.g.
        ``adjustments[9] = 999.9``. Causes all adjustment values in
        collection to be written to the XML.
        """
        self._adjustments_[key].effective_value = value
        self._rewrite_guides()

    def _initialized_adjustments(self, prstGeom):
        """
        Return an initialized list of adjustment values based on the contents
        of *prstGeom*
        """
        if prstGeom is None:
            return []
        davs = AutoShapeType.default_adjustment_values(prstGeom.prst)
        adjustments = [Adjustment(name, def_val) for name, def_val in davs]
        self._update_adjustments_with_actuals(adjustments, prstGeom.gd)
        return adjustments

    def _rewrite_guides(self):
        """
        Write ``<a:gd>`` elements to the XML, one for each adjustment value.
        Any existing guide elements are overwritten.
        """
        guides = [(adj.name, adj.val) for adj in self._adjustments_]
        self._prstGeom.rewrite_guides(guides)

    @staticmethod
    def _update_adjustments_with_actuals(adjustments, guides):
        """
        Update |Adjustment| instances in *adjustments* with actual values
        held in *guides*, a list of ``<a:gd>`` elements. Guides with a name
        that does not match an adjustment object are skipped.
        """
        adjustments_by_name = dict((adj.name, adj) for adj in adjustments)
        for gd in guides:
            name = gd.get('name')
            actual = int(gd.get('fmla')[4:])
            try:
                adjustment = adjustments_by_name[name]
            except KeyError:
                continue
            adjustment.actual = actual
        return

    @property
    def _adjustments(self):
        """
        Sequence containing direct references to the |Adjustment| objects
        contained in collection.
        """
        return tuple(self._adjustments_)

    def __len__(self):
        """Implement built-in function len()"""
        return len(self._adjustments_)


class AutoShapeType(object):
    """
    Return an instance of |AutoShapeType| containing metadata for an auto
    shape of type identified by *autoshape_type_id*. Instances are cached, so
    no more than one instance for a particular auto shape type is in memory.

    Instances provide the following attributes:

    .. attribute:: autoshape_type_id

       Integer uniquely identifying this auto shape type. Corresponds to a
       value in ``pptx.constants.MSO`` like ``MSO_SHAPE.ROUNDED_RECTANGLE``.

    .. attribute:: basename

       Base part of shape name for auto shapes of this type, e.g. ``Rounded
       Rectangle`` becomes ``Rounded Rectangle 99`` when the distinguishing
       integer is added to the shape name.

    .. attribute:: prst

       String identifier for this auto shape type used in the ``<a:prstGeom>``
       element.

    .. attribute:: desc

       Informal string description of auto shape.

    """
    _instances = {}

    def __new__(cls, autoshape_type_id):
        """
        Only create new instance on first call for content_type. After that,
        use cached instance.
        """
        # if there's not a matching instance in the cache, create one
        if autoshape_type_id not in cls._instances:
            inst = super(AutoShapeType, cls).__new__(cls)
            cls._instances[autoshape_type_id] = inst
        # return the instance; note that __init__() gets called either way
        return cls._instances[autoshape_type_id]

    def __init__(self, autoshape_type_id):
        """Initialize attributes from constant values in pptx.spec"""
        # skip loading if this instance is from the cache
        if hasattr(self, '_loaded'):
            return
        # raise on bad autoshape_type_id
        if autoshape_type_id not in autoshape_types:
            tmpl = "no autoshape type with id %d in pptx.spec.autoshape_types"
            raise KeyError(tmpl % autoshape_type_id)
        # otherwise initialize new instance
        autoshape_type = autoshape_types[autoshape_type_id]
        self._autoshape_type_id = autoshape_type_id
        self._basename = autoshape_type['basename']
        self._loaded = True

    @property
    def autoshape_type_id(self):
        """Integer identifier of this auto shape type"""
        return self._autoshape_type_id

    @property
    def basename(self):
        """
        Base of shape name (less the distinguishing integer) for this auto
        shape type
        """
        return self._basename

    @classmethod
    def default_adjustment_values(cls, prst):
        """
        Return sequence of name, value tuples representing the adjustment
        value defaults for the auto shape type identified by *prst*.
        """
        try:
            autoshape_type_id = cls.id_from_prst(prst)
        except KeyError:
            return ()
        return autoshape_types[autoshape_type_id]['avLst']

    @property
    def desc(self):
        """Informal description of this auto shape type"""
        return self._desc

    @classmethod
    def id_from_prst(cls, prst):
        """
        Return auto shape id (e.g. ``MSO_SHAPE.RECTANGLE``) corresponding to
        preset geometry keyword *prst*.
        """
        return MSO_AUTO_SHAPE_TYPE.from_xml(prst)

    @property
    def prst(self):
        """
        Preset geometry identifier string for this auto shape. Used in the
        ``prst`` attribute of ``<a:prstGeom>`` element to specify the geometry
        to be used in rendering the shape, for example ``'roundRect'``.
        """
        return MSO_AUTO_SHAPE_TYPE.to_xml(self._autoshape_type_id)


class Shape(BaseShape):
    """
    A shape that can appear on a slide. Corresponds to the ``<p:sp>`` element
    that can appear in any of the slide-type parts (slide, slideLayout,
    slideMaster, notesPage, notesMaster, handoutMaster).
    """
    def __init__(self, sp, parent):
        super(Shape, self).__init__(sp, parent)
        self._sp = sp

    @lazyproperty
    def adjustments(self):
        """
        Read-only reference to |AdjustmentCollection| instance for this
        shape
        """
        return AdjustmentCollection(self._sp.prstGeom)

    @property
    def auto_shape_type(self):
        """
        Unique integer identifying the type of this auto shape, like
        ``MSO_SHAPE.ROUNDED_RECTANGLE``. Raises |ValueError| if this shape is
        not an auto shape.
        """
        if not self._sp.is_autoshape:
            msg = "shape is not an auto shape"
            raise ValueError(msg)
        prst = self._sp.prst
        auto_shape_type_id = AutoShapeType.id_from_prst(prst)
        return auto_shape_type_id

    @lazyproperty
    def fill(self):
        """
        |FillFormat| instance for this shape, providing access to fill
        properties such as fill color.
        """
        return FillFormat.from_fill_parent(self._sp.spPr)

    def get_or_add_ln(self):
        """
        Return the ``<a:ln>`` element containing the line format properties
        XML for this shape.
        """
        return self._sp.get_or_add_ln()

    @lazyproperty
    def line(self):
        """
        |LineFormat| instance for this shape, providing access to line
        properties such as line color.
        """
        return LineFormat(self)

    @property
    def ln(self):
        """
        The ``<a:ln>`` element containing the line format properties such as
        line color and width. |None| if no ``<a:ln>`` element is present.
        """
        return self._sp.ln

    @property
    def shape_type(self):
        """
        Unique integer identifying the type of this shape, like
        ``MSO_SHAPE_TYPE.TEXT_BOX``.
        """
        if self.is_placeholder:
            return MSO_SHAPE_TYPE.PLACEHOLDER
        if self._sp.is_autoshape:
            return MSO_SHAPE_TYPE.AUTO_SHAPE
        if self._sp.is_textbox:
            return MSO_SHAPE_TYPE.TEXT_BOX
        msg = 'Shape instance of unrecognized shape type'
        raise NotImplementedError(msg)

########NEW FILE########
__FILENAME__ = graphfrm
# encoding: utf-8

"""
Graphic Frame shape and related objects. A graphic frame is a common
container for table, chart, smart art, and media objects.
"""

from __future__ import absolute_import

from pptx.shapes.shape import BaseShape


class GraphicFrame(BaseShape):
    """
    Container shape for table, chart, smart art, and media objects.
    Corresponds to a ``<p:graphicFrame>`` element in the shape tree.
    """

########NEW FILE########
__FILENAME__ = picture
# encoding: utf-8

"""
Picture shape.
"""

from ..dml.line import LineFormat
from ..enum.shapes import MSO_SHAPE_TYPE
from .shape import BaseShape
from ..util import lazyproperty


class Picture(BaseShape):
    """
    A picture shape, one that places an image on a slide. Corresponds to the
    ``<p:pic>`` element.
    """
    def __init__(self, pic, parent):
        super(Picture, self).__init__(pic, parent)
        self._pic = pic

    def get_or_add_ln(self):
        """
        Return the ``<a:ln>`` element containing the line format properties
        XML for this picture.
        """
        return self._pic.get_or_add_ln()

    @lazyproperty
    def line(self):
        """
        An instance of |LineFormat|, providing access to the properties of
        the outline bordering this picture, such as its color and width.
        """
        return LineFormat(self)

    @property
    def ln(self):
        """
        The ``<a:ln>`` element containing the line format properties such as
        line color and width. |None| if no ``<a:ln>`` element is present.
        """
        return self._pic.ln

    @property
    def shape_type(self):
        """
        Unique integer identifying the type of this shape, unconditionally
        ``MSO_SHAPE_TYPE.PICTURE`` in this case.
        """
        return MSO_SHAPE_TYPE.PICTURE

########NEW FILE########
__FILENAME__ = placeholder
# encoding: utf-8

"""
Placeholder object, a wrapper (decorator pattern) around an autoshape having
a ``ph`` element. Provides access to placeholder-specific properties of the
shape, such as the placeholder type. All other attribute gets are forwarded
to the underlying shape.
"""

from pptx.shapes.autoshape import Shape
from pptx.shapes.shapetree import BaseShapeTree


class BasePlaceholders(BaseShapeTree):
    """
    Base class for placeholder collections that differentiate behaviors for
    a master, layout, and slide.
    """
    @staticmethod
    def _is_member_elm(shape_elm):
        """
        True if *shape_elm* is a placeholder shape, False otherwise.
        """
        return shape_elm.has_ph_elm


class BasePlaceholder(Shape):
    """
    Base class for placeholder subclasses that differentiate the varying
    behaviors of placeholders on a master, layout, and slide.
    """
    @property
    def idx(self):
        """
        Integer placeholder 'idx' attribute, e.g. 0
        """
        return self._sp.ph_idx

    @property
    def orient(self):
        """
        Placeholder orientation, e.g. ST_Direction.HORZ
        """
        return self._sp.ph_orient

    @property
    def ph_type(self):
        """
        Placeholder type, e.g. ST_PlaceholderType.CTR_TITLE
        """
        return self._sp.ph_type

    @property
    def sz(self):
        """
        Placeholder 'sz' attribute, e.g. ST_PlaceholderSize.FULL
        """
        return self._sp.ph_sz

########NEW FILE########
__FILENAME__ = shape
# encoding: utf-8

"""
Base shape-related objects such as BaseShape.
"""

from __future__ import absolute_import, print_function

from ..text import TextFrame
from ..util import to_unicode


class BaseShape(object):
    """
    Base class for shape objects, including |Shape|, |Picture|, and
    |GraphicFrame|.
    """
    def __init__(self, shape_elm, parent):
        super(BaseShape, self).__init__()
        self._element = shape_elm
        self._parent = parent

    @property
    def element(self):
        """
        Reference to the lxml element for this shape, e.g. a CT_Shape
        instance.
        """
        return self._element

    @property
    def has_textframe(self):
        """
        True if this shape has a txBody element and can contain text.
        """
        return self._element.txBody is not None

    @property
    def height(self):
        """
        Read/write. Integer distance between top and bottom extents of shape
        in EMUs
        """
        return self._element.cy

    @height.setter
    def height(self, value):
        self._element.cy = value

    @property
    def id(self):
        """
        Id of this shape. Note that ids are constrained to positive integers.
        """
        return self._element.shape_id

    @property
    def is_placeholder(self):
        """
        True if this shape is a placeholder. A shape is a placeholder if it
        has a <p:ph> element.
        """
        return self._element.has_ph_elm

    @property
    def left(self):
        """
        Read/write. Integer distance of the left edge of this shape from the
        left edge of the slide, in English Metric Units (EMU)
        """
        return self._element.x

    @left.setter
    def left(self, value):
        self._element.x = value

    @property
    def name(self):
        """
        Name of this shape, e.g. 'Picture 7'
        """
        return self._element.shape_name

    @property
    def part(self):
        """
        The package part containing this object, a _BaseSlide subclass in
        this case.
        """
        return self._parent.part

    @property
    def shape_type(self):
        """
        Unique integer identifying the type of this shape, like
        ``MSO_SHAPE_TYPE.CHART``. Must be implemented by subclasses.
        """
        # # This one returns |None| unconditionally to account for shapes
        # # that haven't been implemented yet, like group shape and chart.
        # # Once those are done this should raise |NotImplementedError|.
        # msg = 'shape_type property must be implemented by subclasses'
        # raise NotImplementedError(msg)
        return None

    @property
    def top(self):
        """
        Read/write. Integer distance of the top edge of this shape from the
        top edge of the slide, in English Metric Units (EMU)
        """
        return self._element.y

    @top.setter
    def top(self, value):
        self._element.y = value

    def _set_text(self, text):
        """
        Replace all text in the shape with a single run containing *text*
        """
        if not self.has_textframe:
            raise TypeError("cannot set text of shape with no text frame")
        self.textframe.text = to_unicode(text)

    #: Write-only. Assignment to *text* replaces all text currently contained
    #: by the shape, resulting in a text frame containing exactly one
    #: paragraph, itself containing a single run. The assigned value can be a
    #: 7-bit ASCII string, a UTF-8 encoded 8-bit string, or unicode. String
    #: values are converted to unicode assuming UTF-8 encoding.
    text = property(None, _set_text)

    @property
    def textframe(self):
        """
        |TextFrame| instance for this shape. Raises |ValueError| if shape has
        no text frame. Use :attr:`has_textframe` to check whether a shape has
        a text frame.
        """
        txBody = self._element.txBody
        if txBody is None:
            raise ValueError('shape has no text frame')
        return TextFrame(txBody, self)

    @property
    def width(self):
        """
        Read/write. Integer distance between left and right extents of shape
        in EMUs
        """
        return self._element.cx

    @width.setter
    def width(self, value):
        self._element.cx = value

########NEW FILE########
__FILENAME__ = shapetree
# encoding: utf-8

"""
The shape tree, the structure that holds a slide's shapes.
"""

from .autoshape import Shape
from ..oxml.ns import qn
from .picture import Picture
from .shape import BaseShape
from .table import Table


class BaseShapeTree(object):
    """
    Base class for a shape collection appearing in a slide-type object,
    include Slide, SlideLayout, and SlideMaster, providing common methods.
    """
    def __init__(self, slide):
        super(BaseShapeTree, self).__init__()
        self._slide = slide

    def __getitem__(self, idx):
        """
        Return shape at *idx* in sequence, e.g. ``shapes[2]``.
        """
        shape_elms = list(self._iter_member_elms())
        try:
            shape_elm = shape_elms[idx]
        except IndexError:
            raise IndexError('shape index out of range')
        return self._shape_factory(shape_elm)

    def __iter__(self):
        """
        Generate a reference to each shape in the collection, in sequence.
        """
        for shape_elm in self._iter_member_elms():
            yield self._shape_factory(shape_elm)

    def __len__(self):
        """
        Return count of shapes in this shape tree. A group shape contributes
        1 to the total, without regard to the number of shapes contained in
        the group.
        """
        shape_elms = list(self._iter_member_elms())
        return len(shape_elms)

    @property
    def part(self):
        """
        The package part containing this object, a _BaseSlide subclass in
        this case.
        """
        return self._slide

    @staticmethod
    def _is_member_elm(shape_elm):
        """
        Return true if *shape_elm* represents a member of this collection,
        False otherwise.
        """
        return True

    def _iter_member_elms(self):
        """
        Generate each child of the ``<p:spTree>`` element that corresponds to
        a shape, in the sequence they appear in the XML.
        """
        spTree = self._slide.spTree
        for shape_elm in spTree.iter_shape_elms():
            if self._is_member_elm(shape_elm):
                yield shape_elm

    @property
    def _next_shape_id(self):
        """
        Next available positive integer drawing object id in shape tree,
        starting from 1 and making use of any gaps in numbering. In practice,
        the minimum id is 2 because the spTree element is always assigned
        id="1".
        """
        id_str_lst = self._spTree.xpath('//@id')
        used_ids = [int(id_str) for id_str in id_str_lst if id_str.isdigit()]
        for n in range(1, len(used_ids)+2):
            if n not in used_ids:
                return n

    def _shape_factory(self, shape_elm):
        """
        Return an instance of the appropriate shape proxy class for
        *shape_elm*.
        """
        return BaseShapeFactory(shape_elm, self)

    @property
    def _spTree(self):
        """
        The ``<p:spTree>`` element underlying this shape tree object
        """
        return self._slide.spTree


def BaseShapeFactory(shape_elm, parent):
    """
    Return an instance of the appropriate shape proxy class for *shape_elm*.
    """
    tag_name = shape_elm.tag
    if tag_name == qn('p:sp'):
        return Shape(shape_elm, parent)
    if tag_name == qn('p:pic'):
        return Picture(shape_elm, parent)
    if tag_name == qn('p:graphicFrame'):
        if shape_elm.has_table:
            return Table(shape_elm, parent)
    return BaseShape(shape_elm, parent)

########NEW FILE########
__FILENAME__ = table
# encoding: utf-8

"""
Table-related objects such as Table and Cell.
"""

from . import Subshape
from ..dml.fill import FillFormat
from ..enum.shapes import MSO_SHAPE_TYPE
from .graphfrm import GraphicFrame
from ..oxml.ns import qn
from ..text import TextFrame
from ..util import lazyproperty, to_unicode


class Table(GraphicFrame):
    """
    A table shape. Not intended to be constructed directly, use
    :meth:`.Slide.shapes.add_table` to add a table to a slide.
    """
    def __init__(self, graphicFrame, parent):
        super(Table, self).__init__(graphicFrame, parent)
        self._graphicFrame = graphicFrame
        self._tbl_elm = graphicFrame[qn('a:graphic')].graphicData.tbl
        self._rows = _RowCollection(self._tbl_elm, self)
        self._columns = _ColumnCollection(self._tbl_elm, self)

    def cell(self, row_idx, col_idx):
        """Return table cell at *row_idx*, *col_idx* location"""
        row = self.rows[row_idx]
        return row.cells[col_idx]

    @property
    def columns(self):
        """
        Read-only reference to collection of |_Column| objects representing
        the table's columns. |_Column| objects are accessed using list
        notation, e.g. ``col = tbl.columns[0]``.
        """
        return self._columns

    @property
    def first_col(self):
        """
        Read/write boolean property which, when true, indicates the first
        column should be formatted differently, as for a side-heading column
        at the far left of the table.
        """
        return self._tbl_elm.firstCol

    @property
    def first_row(self):
        """
        Read/write boolean property which, when true, indicates the first
        row should be formatted differently, e.g. for column headings.
        """
        return self._tbl_elm.firstRow

    @property
    def horz_banding(self):
        """
        Read/write boolean property which, when true, indicates the rows of
        the table should appear with alternating shading.
        """
        return self._tbl_elm.bandRow

    @property
    def last_col(self):
        """
        Read/write boolean property which, when true, indicates the last
        column should be formatted differently, as for a row totals column at
        the far right of the table.
        """
        return self._tbl_elm.lastCol

    @property
    def last_row(self):
        """
        Read/write boolean property which, when true, indicates the last
        row should be formatted differently, as for a totals row at the
        bottom of the table.
        """
        return self._tbl_elm.lastRow

    @first_col.setter
    def first_col(self, value):
        self._tbl_elm.firstCol = bool(value)

    @first_row.setter
    def first_row(self, value):
        self._tbl_elm.firstRow = bool(value)

    @horz_banding.setter
    def horz_banding(self, value):
        self._tbl_elm.bandRow = bool(value)

    @last_col.setter
    def last_col(self, value):
        self._tbl_elm.lastCol = bool(value)

    def notify_height_changed(self):
        """
        Called by a row when its height changes, triggering the graphic frame
        to recalculate its total height (as the sum of the row heights).
        """
        new_table_height = sum([row.height for row in self.rows])
        self._graphicFrame.cy = new_table_height

    def notify_width_changed(self):
        """
        Called by a column when its width changes, triggering the graphic
        frame to recalculate its total width (as the sum of the column
        widths).
        """
        new_table_width = sum([col.width for col in self.columns])
        self._graphicFrame.cx = new_table_width

    @last_row.setter
    def last_row(self, value):
        self._tbl_elm.lastRow = bool(value)

    @property
    def rows(self):
        """
        Read-only reference to collection of |_Row| objects representing the
        table's rows. |_Row| objects are accessed using list notation, e.g.
        ``col = tbl.rows[0]``.
        """
        return self._rows

    @property
    def shape_type(self):
        """
        Unique integer identifying the type of this shape, unconditionally
        ``MSO_SHAPE_TYPE.TABLE`` in this case.
        """
        return MSO_SHAPE_TYPE.TABLE

    @property
    def vert_banding(self):
        """
        Read/write boolean property which, when true, indicates the columns
        of the table should appear with alternating shading.
        """
        return self._tbl_elm.bandCol

    @vert_banding.setter
    def vert_banding(self, value):
        self._tbl_elm.bandCol = bool(value)


class _Cell(Subshape):
    """
    Table cell
    """
    def __init__(self, tc, parent):
        super(_Cell, self).__init__(parent)
        self._tc = tc

    @lazyproperty
    def fill(self):
        """
        |FillFormat| instance for this cell, providing access to fill
        properties such as foreground color.
        """
        tcPr = self._tc.get_or_add_tcPr()
        return FillFormat.from_fill_parent(tcPr)

    @property
    def margin_top(self):
        """
        Read/write integer value of top margin of cell in English Metric
        Units (EMU). If assigned |None|, the default value is used, 0.1
        inches for left and right margins and 0.05 inches for top and bottom.
        """
        return self._tc.marT

    @property
    def margin_right(self):
        """Right margin of cell"""
        return self._tc.marR

    @property
    def margin_bottom(self):
        """Bottom margin of cell"""
        return self._tc.marB

    @property
    def margin_left(self):
        """Left margin of cell"""
        return self._tc.marL

    @margin_top.setter
    def margin_top(self, margin_top):
        self._validate_margin_value(margin_top)
        self._tc.marT = margin_top

    @margin_right.setter
    def margin_right(self, margin_right):
        self._validate_margin_value(margin_right)
        self._tc.marR = margin_right

    @margin_bottom.setter
    def margin_bottom(self, margin_bottom):
        self._validate_margin_value(margin_bottom)
        self._tc.marB = margin_bottom

    @margin_left.setter
    def margin_left(self, margin_left):
        self._validate_margin_value(margin_left)
        self._tc.marL = margin_left

    def text(self, text):
        """
        Replace all text in cell with single run containing *text*
        """
        self.textframe.text = to_unicode(text)

    #: Write-only. Assignment to *text* replaces all text currently contained
    #: in the cell, resulting in a text frame containing exactly one
    #: paragraph, itself containing a single run. The assigned value can be a
    #: 7-bit ASCII string, a UTF-8 encoded 8-bit string, or unicode. String
    #: values are converted to unicode assuming UTF-8 encoding.
    text = property(None, text)

    @property
    def textframe(self):
        """
        |TextFrame| instance containing the text that appears in the cell.
        """
        txBody = self._tc.get_or_add_txBody()
        return TextFrame(txBody, self)

    @property
    def vertical_anchor(self):
        """
        Vertical anchor of this table cell, determines the vertical alignment
        of text in the cell. Value is like ``MSO_ANCHOR.MIDDLE``. Can be
        |None|, meaning the cell has no vertical anchor setting and its
        effective value is inherited from a higher-level object.
        """
        return self._tc.anchor

    @vertical_anchor.setter
    def vertical_anchor(self, mso_anchor_idx):
        """
        Set vertical_anchor of this cell to *vertical_anchor*, a constant
        value like ``MSO_ANCHOR.MIDDLE``. If *vertical_anchor* is |None|, any
        vertical anchor setting is cleared and its effective value is
        inherited.
        """
        self._tc.anchor = mso_anchor_idx

    @staticmethod
    def _validate_margin_value(margin_value):
        """
        Raise ValueError if *margin_value* is not a positive integer value or
        |None|.
        """
        if (not isinstance(margin_value, (int, long))
                and margin_value is not None):
            tmpl = "margin value must be integer or None, got '%s'"
            raise TypeError(tmpl % margin_value)


class _Column(Subshape):
    """
    Table column
    """
    def __init__(self, gridCol, parent):
        super(_Column, self).__init__(parent)
        self._gridCol = gridCol

    def _get_width(self):
        """
        Return width of column in EMU
        """
        return int(self._gridCol.get('w'))

    def _set_width(self, width):
        """
        Set column width to *width*, a positive integer value.
        """
        if not isinstance(width, int) or width < 0:
            msg = "column width must be positive integer"
            raise ValueError(msg)
        self._gridCol.set('w', str(width))
        self._parent.notify_width_changed()

    #: Read-write integer width of this column in English Metric Units (EMU).
    width = property(_get_width, _set_width)


class _Row(Subshape):
    """
    Table row
    """
    def __init__(self, tr, parent):
        super(_Row, self).__init__(parent)
        self._tr = tr
        self._cells = _CellCollection(tr, self)

    @property
    def cells(self):
        """
        Read-only reference to collection of cells in row. An individual cell
        is referenced using list notation, e.g. ``cell = row.cells[0]``.
        """
        return self._cells

    def _get_height(self):
        """
        Return height of row in EMU
        """
        return int(self._tr.get('h'))

    def _set_height(self, height):
        """
        Set row height to *height*, a positive integer value.
        """
        if not isinstance(height, int) or height < 0:
            msg = "row height must be positive integer"
            raise ValueError(msg)
        self._tr.set('h', str(height))
        self._parent.notify_height_changed()

    #: Read/write integer height of this row in English Metric Units (EMU).
    height = property(_get_height, _set_height)


class _CellCollection(Subshape):
    """
    "Horizontal" sequence of row cells
    """
    def __init__(self, tr, parent):
        super(_CellCollection, self).__init__(parent)
        self._tr = tr

    def __getitem__(self, idx):
        """Provides indexed access, (e.g. 'cells[0]')."""
        if idx < 0 or idx >= len(self._tr.tc):
            msg = "cell index [%d] out of range" % idx
            raise IndexError(msg)
        return _Cell(self._tr.tc[idx], self)

    def __len__(self):
        """Supports len() function (e.g. 'len(cells) == 1')."""
        return len(self._tr.tc)


class _ColumnCollection(Subshape):
    """
    Sequence of table columns.
    """
    def __init__(self, tbl_elm, parent):
        super(_ColumnCollection, self).__init__(parent)
        self._tbl_elm = tbl_elm

    def __getitem__(self, idx):
        """Provides indexed access, (e.g. 'columns[0]')."""
        if idx < 0 or idx >= len(self._tbl_elm.tblGrid.gridCol):
            msg = "column index [%d] out of range" % idx
            raise IndexError(msg)
        return _Column(self._tbl_elm.tblGrid.gridCol[idx], self)

    def __len__(self):
        """Supports len() function (e.g. 'len(columns) == 1')."""
        return len(self._tbl_elm.tblGrid.gridCol)

    def notify_width_changed(self):
        """
        Called by a column when its width changes. Pass along to parent.
        """
        self._parent.notify_width_changed()


class _RowCollection(Subshape):
    """
    Sequence of table rows.
    """
    def __init__(self, tbl_elm, parent):
        super(_RowCollection, self).__init__(parent)
        self._tbl_elm = tbl_elm

    def __getitem__(self, idx):
        """Provides indexed access, (e.g. 'rows[0]')."""
        if idx < 0 or idx >= len(self._tbl_elm.tr):
            msg = "row index [%d] out of range" % idx
            raise IndexError(msg)
        return _Row(self._tbl_elm.tr[idx], self)

    def __len__(self):
        """Supports len() function (e.g. 'len(rows) == 1')."""
        return len(self._tbl_elm.tr)

    def notify_height_changed(self):
        """
        Called by a row when its height changes. Pass along to parent.
        """
        self._parent.notify_height_changed()

########NEW FILE########
__FILENAME__ = spec
# encoding: utf-8

"""
Mappings from the ISO/IEC 29500 spec or inferred from PowerPoint application
behavior
"""

from __future__ import absolute_import

from pptx.enum.shapes import MSO_SHAPE


# ============================================================================
# AutoShape type specs
# ============================================================================

autoshape_types = {
    MSO_SHAPE.ACTION_BUTTON_BACK_OR_PREVIOUS: {
        'basename': 'Action Button: Back or Previous',
        'avLst':    ()
    },
    MSO_SHAPE.ACTION_BUTTON_BEGINNING: {
        'basename': 'Action Button: Beginning',
        'avLst':    ()
    },
    MSO_SHAPE.ACTION_BUTTON_CUSTOM: {
        'basename': 'Action Button: Custom',
        'avLst':    ()
    },
    MSO_SHAPE.ACTION_BUTTON_DOCUMENT: {
        'basename': 'Action Button: Document',
        'avLst':    ()
    },
    MSO_SHAPE.ACTION_BUTTON_END: {
        'basename': 'Action Button: End',
        'avLst':    ()
    },
    MSO_SHAPE.ACTION_BUTTON_FORWARD_OR_NEXT: {
        'basename': 'Action Button: Forward or Next',
        'avLst':    ()
    },
    MSO_SHAPE.ACTION_BUTTON_HELP: {
        'basename': 'Action Button: Help',
        'avLst':    ()
    },
    MSO_SHAPE.ACTION_BUTTON_HOME: {
        'basename': 'Action Button: Home',
        'avLst':    ()
    },
    MSO_SHAPE.ACTION_BUTTON_INFORMATION: {
        'basename': 'Action Button: Information',
        'avLst':    ()
    },
    MSO_SHAPE.ACTION_BUTTON_MOVIE: {
        'basename': 'Action Button: Movie',
        'avLst':    ()
    },
    MSO_SHAPE.ACTION_BUTTON_RETURN: {
        'basename': 'Action Button: Return',
        'avLst':    ()
    },
    MSO_SHAPE.ACTION_BUTTON_SOUND: {
        'basename': 'Action Button: Sound',
        'avLst':    ()
    },
    MSO_SHAPE.ARC: {
        'basename': 'Arc',
        'avLst':    (
            ('adj1', 16200000),
            ('adj2', 0),
        )
    },
    MSO_SHAPE.BALLOON: {
        'basename': 'Rounded Rectangular Callout',
        'avLst':    (
            ('adj1', -20833),
            ('adj2', 62500),
            ('adj3', 16667),
        )
    },
    MSO_SHAPE.BENT_ARROW: {
        'basename': 'Bent Arrow',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 25000),
            ('adj3', 25000),
            ('adj4', 43750),
        )
    },
    MSO_SHAPE.BENT_UP_ARROW: {
        'basename': 'Bent-Up Arrow',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 25000),
            ('adj3', 25000),
        )
    },
    MSO_SHAPE.BEVEL: {
        'basename': 'Bevel',
        'avLst':    (
            ('adj', 12500),
        )
    },
    MSO_SHAPE.BLOCK_ARC: {
        'basename': 'Block Arc',
        'avLst':    (
            ('adj1', 10800000),
            ('adj2', 0),
            ('adj3', 25000),
        )
    },
    MSO_SHAPE.CAN: {
        'basename': 'Can',
        'avLst':    (
            ('adj', 25000),
        )
    },
    MSO_SHAPE.CHART_PLUS: {
        'basename': 'Chart Plus',
        'avLst':    ()
    },
    MSO_SHAPE.CHART_STAR: {
        'basename': 'Chart Star',
        'avLst':    ()
    },
    MSO_SHAPE.CHART_X: {
        'basename': 'Chart X',
        'avLst':    ()
    },
    MSO_SHAPE.CHEVRON: {
        'basename': 'Chevron',
        'avLst':    (
            ('adj', 50000),
        )
    },
    MSO_SHAPE.CHORD: {
        'basename': 'Chord',
        'avLst':    (
            ('adj1', 2700000),
            ('adj2', 16200000),
        )
    },
    MSO_SHAPE.CIRCULAR_ARROW: {
        'basename': 'Circular Arrow',
        'avLst':    (
            ('adj1', 12500),
            ('adj2', 1142319),
            ('adj3', 20457681),
            ('adj4', 10800000),
            ('adj5', 12500),
        )
    },
    MSO_SHAPE.CLOUD: {
        'basename': 'Cloud',
        'avLst':    ()
    },
    MSO_SHAPE.CLOUD_CALLOUT: {
        'basename': 'Cloud Callout',
        'avLst':    (
            ('adj1', -20833),
            ('adj2', 62500),
        )
    },
    MSO_SHAPE.CORNER: {
        'basename': 'Corner',
        'avLst':    (
            ('adj1', 50000),
            ('adj2', 50000),
        )
    },
    MSO_SHAPE.CORNER_TABS: {
        'basename': 'Corner Tabs',
        'avLst':    ()
    },
    MSO_SHAPE.CROSS: {
        'basename': 'Cross',
        'avLst':    (
            ('adj', 25000),
        )
    },
    MSO_SHAPE.CUBE: {
        'basename': 'Cube',
        'avLst':    (
            ('adj', 25000),
        )
    },
    MSO_SHAPE.CURVED_DOWN_ARROW: {
        'basename': 'Curved Down Arrow',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 50000),
            ('adj3', 25000),
        )
    },
    MSO_SHAPE.CURVED_DOWN_RIBBON: {
        'basename': 'Curved Down Ribbon',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 50000),
            ('adj3', 12500),
        )
    },
    MSO_SHAPE.CURVED_LEFT_ARROW: {
        'basename': 'Curved Left Arrow',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 50000),
            ('adj3', 25000),
        )
    },
    MSO_SHAPE.CURVED_RIGHT_ARROW: {
        'basename': 'Curved Right Arrow',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 50000),
            ('adj3', 25000),
        )
    },
    MSO_SHAPE.CURVED_UP_ARROW: {
        'basename': 'Curved Up Arrow',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 50000),
            ('adj3', 25000),
        )
    },
    MSO_SHAPE.CURVED_UP_RIBBON: {
        'basename': 'Curved Up Ribbon',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 50000),
            ('adj3', 12500),
        )
    },
    MSO_SHAPE.DECAGON: {
        'basename': 'Decagon',
        'avLst':    (
            ('vf', 105146),
        )
    },
    MSO_SHAPE.DIAGONAL_STRIPE: {
        'basename': 'Diagonal Stripe',
        'avLst':    (
            ('adj', 50000),
        )
    },
    MSO_SHAPE.DIAMOND: {
        'basename': 'Diamond',
        'avLst':    ()
    },
    MSO_SHAPE.DODECAGON: {
        'basename': 'Dodecagon',
        'avLst':    ()
    },
    MSO_SHAPE.DONUT: {
        'basename': 'Donut',
        'avLst':    (
            ('adj', 25000),
        )
    },
    MSO_SHAPE.DOUBLE_BRACE: {
        'basename': 'Double Brace',
        'avLst':    (
            ('adj', 8333),
        )
    },
    MSO_SHAPE.DOUBLE_BRACKET: {
        'basename': 'Double Bracket',
        'avLst':    (
            ('adj', 16667),
        )
    },
    MSO_SHAPE.DOUBLE_WAVE: {
        'basename': 'Double Wave',
        'avLst':    (
            ('adj1', 6250),
            ('adj2', 0),
        )
    },
    MSO_SHAPE.DOWN_ARROW: {
        'basename': 'Down Arrow',
        'avLst':    (
            ('adj1', 50000),
            ('adj2', 50000),
        )
    },
    MSO_SHAPE.DOWN_ARROW_CALLOUT: {
        'basename': 'Down Arrow Callout',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 25000),
            ('adj3', 25000),
            ('adj4', 64977),
        )
    },
    MSO_SHAPE.DOWN_RIBBON: {
        'basename': 'Down Ribbon',
        'avLst':    (
            ('adj1', 16667),
            ('adj2', 50000),
        )
    },
    MSO_SHAPE.EXPLOSION1: {
        'basename': 'Explosion',
        'avLst':    ()
    },
    MSO_SHAPE.EXPLOSION2: {
        'basename': 'Explosion',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_ALTERNATE_PROCESS: {
        'basename': 'Alternate process',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_CARD: {
        'basename': 'Card',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_COLLATE: {
        'basename': 'Collate',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_CONNECTOR: {
        'basename': 'Connector',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_DATA: {
        'basename': 'Data',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_DECISION: {
        'basename': 'Decision',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_DELAY: {
        'basename': 'Delay',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_DIRECT_ACCESS_STORAGE: {
        'basename': 'Direct Access Storage',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_DISPLAY: {
        'basename': 'Display',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_DOCUMENT: {
        'basename': 'Document',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_EXTRACT: {
        'basename': 'Extract',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_INTERNAL_STORAGE: {
        'basename': 'Internal Storage',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_MAGNETIC_DISK: {
        'basename': 'Magnetic Disk',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_MANUAL_INPUT: {
        'basename': 'Manual Input',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_MANUAL_OPERATION: {
        'basename': 'Manual Operation',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_MERGE: {
        'basename': 'Merge',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_MULTIDOCUMENT: {
        'basename': 'Multidocument',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_OFFLINE_STORAGE: {
        'basename': 'Offline Storage',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_OFFPAGE_CONNECTOR: {
        'basename': 'Off-page Connector',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_OR: {
        'basename': 'Or',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_PREDEFINED_PROCESS: {
        'basename': 'Predefined Process',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_PREPARATION: {
        'basename': 'Preparation',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_PROCESS: {
        'basename': 'Process',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_PUNCHED_TAPE: {
        'basename': 'Punched Tape',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_SEQUENTIAL_ACCESS_STORAGE: {
        'basename': 'Sequential Access Storage',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_SORT: {
        'basename': 'Sort',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_STORED_DATA: {
        'basename': 'Stored Data',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_SUMMING_JUNCTION: {
        'basename': 'Summing Junction',
        'avLst':    ()
    },
    MSO_SHAPE.FLOWCHART_TERMINATOR: {
        'basename': 'Terminator',
        'avLst':    ()
    },
    MSO_SHAPE.FOLDED_CORNER: {
        'basename': 'Folded Corner',
        'avLst':    ()
    },
    MSO_SHAPE.FRAME: {
        'basename': 'Frame',
        'avLst':    (
            ('adj1', 12500),
        )
    },
    MSO_SHAPE.FUNNEL: {
        'basename': 'Funnel',
        'avLst':    ()
    },
    MSO_SHAPE.GEAR_6: {
        'basename': 'Gear 6',
        'avLst':    (
            ('adj1', 15000),
            ('adj2', 3526),
        )
    },
    MSO_SHAPE.GEAR_9: {
        'basename': 'Gear 9',
        'avLst':    (
            ('adj1', 10000),
            ('adj2', 1763),
        )
    },
    MSO_SHAPE.HALF_FRAME: {
        'basename': 'Half Frame',
        'avLst':    (
            ('adj1', 33333),
            ('adj2', 33333),
        )
    },
    MSO_SHAPE.HEART: {
        'basename': 'Heart',
        'avLst':    ()
    },
    MSO_SHAPE.HEPTAGON: {
        'basename': 'Heptagon',
        'avLst':    (
            ('hf', 102572),
            ('vf', 105210),
        )
    },
    MSO_SHAPE.HEXAGON: {
        'basename': 'Hexagon',
        'avLst':    (
            ('adj', 25000),
            ('vf', 115470),
        )
    },
    MSO_SHAPE.HORIZONTAL_SCROLL: {
        'basename': 'Horizontal Scroll',
        'avLst':    (
            ('adj', 12500),
        )
    },
    MSO_SHAPE.ISOSCELES_TRIANGLE: {
        'basename': 'Isosceles Triangle',
        'avLst':    (
            ('adj', 50000),
        )
    },
    MSO_SHAPE.LEFT_ARROW: {
        'basename': 'Left Arrow',
        'avLst':    (
            ('adj1', 50000),
            ('adj2', 50000),
        )
    },
    MSO_SHAPE.LEFT_ARROW_CALLOUT: {
        'basename': 'Left Arrow Callout',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 25000),
            ('adj3', 25000),
            ('adj4', 64977),
        )
    },
    MSO_SHAPE.LEFT_BRACE: {
        'basename': 'Left Brace',
        'avLst':    (
            ('adj1', 8333),
            ('adj2', 50000),
        )
    },
    MSO_SHAPE.LEFT_BRACKET: {
        'basename': 'Left Bracket',
        'avLst':    (
            ('adj', 8333),
        )
    },
    MSO_SHAPE.LEFT_CIRCULAR_ARROW: {
        'basename': 'Left Circular Arrow',
        'avLst':    (
            ('adj1', 12500),
            ('adj2', -1142319),
            ('adj3', 1142319),
            ('adj4', 10800000),
            ('adj5', 12500),
        )
    },
    MSO_SHAPE.LEFT_RIGHT_ARROW: {
        'basename': 'Left-Right Arrow',
        'avLst':    (
            ('adj1', 50000),
            ('adj2', 50000),
        )
    },
    MSO_SHAPE.LEFT_RIGHT_ARROW_CALLOUT: {
        'basename': 'Left-Right Arrow Callout',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 25000),
            ('adj3', 25000),
            ('adj4', 48123),
        )
    },
    MSO_SHAPE.LEFT_RIGHT_CIRCULAR_ARROW: {
        'basename': 'Left Right Circular Arrow',
        'avLst':    (
            ('adj1', 12500),
            ('adj2', 1142319),
            ('adj3', 20457681),
            ('adj4', 11942319),
            ('adj5', 12500),
        )
    },
    MSO_SHAPE.LEFT_RIGHT_RIBBON: {
        'basename': 'Left Right Ribbon',
        'avLst':    (
            ('adj1', 50000),
            ('adj2', 50000),
            ('adj3', 16667),
        )
    },
    MSO_SHAPE.LEFT_RIGHT_UP_ARROW: {
        'basename': 'Left-Right-Up Arrow',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 25000),
            ('adj3', 25000),
        )
    },
    MSO_SHAPE.LEFT_UP_ARROW: {
        'basename': 'Left-Up Arrow',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 25000),
            ('adj3', 25000),
        )
    },
    MSO_SHAPE.LIGHTNING_BOLT: {
        'basename': 'Lightning Bolt',
        'avLst':    ()
    },
    MSO_SHAPE.LINE_CALLOUT_1: {
        'basename': 'Line Callout 1',
        'avLst':    (
            ('adj1', 18750),
            ('adj2', -8333),
            ('adj3', 112500),
            ('adj4', -38333),
        )
    },
    MSO_SHAPE.LINE_CALLOUT_1_ACCENT_BAR: {
        'basename': 'Line Callout 1 (Accent Bar)',
        'avLst':    (
            ('adj1', 18750),
            ('adj2', -8333),
            ('adj3', 112500),
            ('adj4', -38333),
        )
    },
    MSO_SHAPE.LINE_CALLOUT_1_BORDER_AND_ACCENT_BAR: {
        'basename': 'Line Callout 1 (Border and Accent Bar)',
        'avLst':    (
            ('adj1', 18750),
            ('adj2', -8333),
            ('adj3', 112500),
            ('adj4', -38333),
        )
    },
    MSO_SHAPE.LINE_CALLOUT_1_NO_BORDER: {
        'basename': 'Line Callout 1 (No Border)',
        'avLst':    (
            ('adj1', 18750),
            ('adj2', -8333),
            ('adj3', 112500),
            ('adj4', -38333),
        )
    },
    MSO_SHAPE.LINE_CALLOUT_2: {
        'basename': 'Line Callout 2',
        'avLst':    (
            ('adj1', 18750),
            ('adj2', -8333),
            ('adj3', 18750),
            ('adj4', -16667),
            ('adj5', 112500),
            ('adj6', -46667),
        )
    },
    MSO_SHAPE.LINE_CALLOUT_2_ACCENT_BAR: {
        'basename': 'Line Callout 2 (Accent Bar)',
        'avLst':    (
            ('adj1', 18750),
            ('adj2', -8333),
            ('adj3', 18750),
            ('adj4', -16667),
            ('adj5', 112500),
            ('adj6', -46667),
        )
    },
    MSO_SHAPE.LINE_CALLOUT_2_BORDER_AND_ACCENT_BAR: {
        'basename': 'Line Callout 2 (Border and Accent Bar)',
        'avLst':    (
            ('adj1', 18750),
            ('adj2', -8333),
            ('adj3', 18750),
            ('adj4', -16667),
            ('adj5', 112500),
            ('adj6', -46667),
        )
    },
    MSO_SHAPE.LINE_CALLOUT_2_NO_BORDER: {
        'basename': 'Line Callout 2 (No Border)',
        'avLst':    (
            ('adj1', 18750),
            ('adj2', -8333),
            ('adj3', 18750),
            ('adj4', -16667),
            ('adj5', 112500),
            ('adj6', -46667),
        )
    },
    MSO_SHAPE.LINE_CALLOUT_3: {
        'basename': 'Line Callout 3',
        'avLst':    (
            ('adj1', 18750),
            ('adj2', -8333),
            ('adj3', 18750),
            ('adj4', -16667),
            ('adj5', 100000),
            ('adj6', -16667),
            ('adj7', 112963),
            ('adj8', -8333),
        )
    },
    MSO_SHAPE.LINE_CALLOUT_3_ACCENT_BAR: {
        'basename': 'Line Callout 3 (Accent Bar)',
        'avLst':    (
            ('adj1', 18750),
            ('adj2', -8333),
            ('adj3', 18750),
            ('adj4', -16667),
            ('adj5', 100000),
            ('adj6', -16667),
            ('adj7', 112963),
            ('adj8', -8333),
        )
    },
    MSO_SHAPE.LINE_CALLOUT_3_BORDER_AND_ACCENT_BAR: {
        'basename': 'Line Callout 3 (Border and Accent Bar)',
        'avLst':    (
            ('adj1', 18750),
            ('adj2', -8333),
            ('adj3', 18750),
            ('adj4', -16667),
            ('adj5', 100000),
            ('adj6', -16667),
            ('adj7', 112963),
            ('adj8', -8333),
        )
    },
    MSO_SHAPE.LINE_CALLOUT_3_NO_BORDER: {
        'basename': 'Line Callout 3 (No Border)',
        'avLst':    (
            ('adj1', 18750),
            ('adj2', -8333),
            ('adj3', 18750),
            ('adj4', -16667),
            ('adj5', 100000),
            ('adj6', -16667),
            ('adj7', 112963),
            ('adj8', -8333),
        )
    },
    MSO_SHAPE.LINE_CALLOUT_4: {
        'basename': 'Line Callout 3',
        'avLst':    (
            ('adj1', 18750),
            ('adj2', -8333),
            ('adj3', 18750),
            ('adj4', -16667),
            ('adj5', 100000),
            ('adj6', -16667),
            ('adj7', 112963),
            ('adj8', -8333),
        )
    },
    MSO_SHAPE.LINE_CALLOUT_4_ACCENT_BAR: {
        'basename': 'Line Callout 3 (Accent Bar)',
        'avLst':    (
            ('adj1', 18750),
            ('adj2', -8333),
            ('adj3', 18750),
            ('adj4', -16667),
            ('adj5', 100000),
            ('adj6', -16667),
            ('adj7', 112963),
            ('adj8', -8333),
        )
    },
    MSO_SHAPE.LINE_CALLOUT_4_BORDER_AND_ACCENT_BAR: {
        'basename': 'Line Callout 3 (Border and Accent Bar)',
        'avLst':    (
            ('adj1', 18750),
            ('adj2', -8333),
            ('adj3', 18750),
            ('adj4', -16667),
            ('adj5', 100000),
            ('adj6', -16667),
            ('adj7', 112963),
            ('adj8', -8333),
        )
    },
    MSO_SHAPE.LINE_CALLOUT_4_NO_BORDER: {
        'basename': 'Line Callout 3 (No Border)',
        'avLst':    (
            ('adj1', 18750),
            ('adj2', -8333),
            ('adj3', 18750),
            ('adj4', -16667),
            ('adj5', 100000),
            ('adj6', -16667),
            ('adj7', 112963),
            ('adj8', -8333),
        )
    },
    MSO_SHAPE.LINE_INVERSE: {
        'basename': 'Straight Connector',
        'avLst':    ()
    },
    MSO_SHAPE.MATH_DIVIDE: {
        'basename': 'Division',
        'avLst':    (
            ('adj1', 23520),
            ('adj2', 5880),
            ('adj3', 11760),
        )
    },
    MSO_SHAPE.MATH_EQUAL: {
        'basename': 'Equal',
        'avLst':    (
            ('adj1', 23520),
            ('adj2', 11760),
        )
    },
    MSO_SHAPE.MATH_MINUS: {
        'basename': 'Minus',
        'avLst':    (
            ('adj1', 23520),
        )
    },
    MSO_SHAPE.MATH_MULTIPLY: {
        'basename': 'Multiply',
        'avLst':    (
            ('adj1', 23520),
        )
    },
    MSO_SHAPE.MATH_NOT_EQUAL: {
        'basename': 'Not Equal',
        'avLst':    (
            ('adj1', 23520),
            ('adj2', 6600000),
            ('adj3', 11760),
        )
    },
    MSO_SHAPE.MATH_PLUS: {
        'basename': 'Plus',
        'avLst':    (
            ('adj1', 23520),
        )
    },
    MSO_SHAPE.MOON: {
        'basename': 'Moon',
        'avLst':    (
            ('adj', 50000),
        )
    },
    MSO_SHAPE.NON_ISOSCELES_TRAPEZOID: {
        'basename': 'Non-isosceles Trapezoid',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 25000),
        )
    },
    MSO_SHAPE.NOTCHED_RIGHT_ARROW: {
        'basename': 'Notched Right Arrow',
        'avLst':    (
            ('adj1', 50000),
            ('adj2', 50000),
        )
    },
    MSO_SHAPE.NO_SYMBOL: {
        'basename': '"No" symbol',
        'avLst':    (
            ('adj', 18750),
        )
    },
    MSO_SHAPE.OCTAGON: {
        'basename': 'Octagon',
        'avLst':    (
            ('adj', 29289),
        )
    },
    MSO_SHAPE.OVAL: {
        'basename': 'Oval',
        'avLst':    ()
    },
    MSO_SHAPE.OVAL_CALLOUT: {
        'basename': 'Oval Callout',
        'avLst':    (
            ('adj1', -20833),
            ('adj2', 62500),
        )
    },
    MSO_SHAPE.PARALLELOGRAM: {
        'basename': 'Parallelogram',
        'avLst':    (
            ('adj', 25000),
        )
    },
    MSO_SHAPE.PENTAGON: {
        'basename': 'Pentagon',
        'avLst':    (
            ('adj', 50000),
        )
    },
    MSO_SHAPE.PIE: {
        'basename': 'Pie',
        'avLst':    (
            ('adj1', 0),
            ('adj2', 16200000),
        )
    },
    MSO_SHAPE.PIE_WEDGE: {
        'basename': 'Pie',
        'avLst':    ()
    },
    MSO_SHAPE.PLAQUE: {
        'basename': 'Plaque',
        'avLst':    (
            ('adj', 16667),
        )
    },
    MSO_SHAPE.PLAQUE_TABS: {
        'basename': 'Plaque Tabs',
        'avLst':    ()
    },
    MSO_SHAPE.QUAD_ARROW: {
        'basename': 'Quad Arrow',
        'avLst':    (
            ('adj1', 22500),
            ('adj2', 22500),
            ('adj3', 22500),
        )
    },
    MSO_SHAPE.QUAD_ARROW_CALLOUT: {
        'basename': 'Quad Arrow Callout',
        'avLst':    (
            ('adj1', 18515),
            ('adj2', 18515),
            ('adj3', 18515),
            ('adj4', 48123),
        )
    },
    MSO_SHAPE.RECTANGLE: {
        'basename': 'Rectangle',
        'avLst':    ()
    },
    MSO_SHAPE.RECTANGULAR_CALLOUT: {
        'basename': 'Rectangular Callout',
        'avLst':    (
            ('adj1', -20833),
            ('adj2', 62500),
        )
    },
    MSO_SHAPE.REGULAR_PENTAGON: {
        'basename': 'Regular Pentagon',
        'avLst':    (
            ('hf', 105146),
            ('vf', 110557),
        )
    },
    MSO_SHAPE.RIGHT_ARROW: {
        'basename': 'Right Arrow',
        'avLst':    (
            ('adj1', 50000),
            ('adj2', 50000),
        )
    },
    MSO_SHAPE.RIGHT_ARROW_CALLOUT: {
        'basename': 'Right Arrow Callout',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 25000),
            ('adj3', 25000),
            ('adj4', 64977),
        )
    },
    MSO_SHAPE.RIGHT_BRACE: {
        'basename': 'Right Brace',
        'avLst':    (
            ('adj1', 8333),
            ('adj2', 50000),
        )
    },
    MSO_SHAPE.RIGHT_BRACKET: {
        'basename': 'Right Bracket',
        'avLst':    (
            ('adj', 8333),
        )
    },
    MSO_SHAPE.RIGHT_TRIANGLE: {
        'basename': 'Right Triangle',
        'avLst':    ()
    },
    MSO_SHAPE.ROUNDED_RECTANGLE: {
        'basename': 'Rounded Rectangle',
        'avLst':    (
            ('adj', 16667),
        )
    },
    MSO_SHAPE.ROUNDED_RECTANGULAR_CALLOUT: {
        'basename': 'Rounded Rectangular Callout',
        'avLst':    (
            ('adj1', -20833),
            ('adj2', 62500),
            ('adj3', 16667),
        )
    },
    MSO_SHAPE.ROUND_1_RECTANGLE: {
        'basename': 'Round Single Corner Rectangle',
        'avLst':    (
            ('adj', 16667),
        )
    },
    MSO_SHAPE.ROUND_2_DIAG_RECTANGLE: {
        'basename': 'Round Diagonal Corner Rectangle',
        'avLst':    (
            ('adj1', 16667),
            ('adj2', 0),
        )
    },
    MSO_SHAPE.ROUND_2_SAME_RECTANGLE: {
        'basename': 'Round Same Side Corner Rectangle',
        'avLst':    (
            ('adj1', 16667),
            ('adj2', 0),
        )
    },
    MSO_SHAPE.SMILEY_FACE: {
        'basename': 'Smiley Face',
        'avLst':    (
            ('adj', 4653),
        )
    },
    MSO_SHAPE.SNIP_1_RECTANGLE: {
        'basename': 'Snip Single Corner Rectangle',
        'avLst':    (
            ('adj', 16667),
        )
    },
    MSO_SHAPE.SNIP_2_DIAG_RECTANGLE: {
        'basename': 'Snip Diagonal Corner Rectangle',
        'avLst':    (
            ('adj1', 0),
            ('adj2', 16667),
        )
    },
    MSO_SHAPE.SNIP_2_SAME_RECTANGLE: {
        'basename': 'Snip Same Side Corner Rectangle',
        'avLst':    (
            ('adj1', 16667),
            ('adj2', 0),
        )
    },
    MSO_SHAPE.SNIP_ROUND_RECTANGLE: {
        'basename': 'Snip and Round Single Corner Rectangle',
        'avLst':    (
            ('adj1', 16667),
            ('adj2', 16667),
        )
    },
    MSO_SHAPE.SQUARE_TABS: {
        'basename': 'Square Tabs',
        'avLst':    ()
    },
    MSO_SHAPE.STAR_10_POINT: {
        'basename': '10-Point Star',
        'avLst':    (
            ('adj', 42533),
            ('hf', 105146),
        )
    },
    MSO_SHAPE.STAR_12_POINT: {
        'basename': '12-Point Star',
        'avLst':    (
            ('adj', 37500),
        )
    },
    MSO_SHAPE.STAR_16_POINT: {
        'basename': '16-Point Star',
        'avLst':    (
            ('adj', 37500),
        )
    },
    MSO_SHAPE.STAR_24_POINT: {
        'basename': '24-Point Star',
        'avLst':    (
            ('adj', 37500),
        )
    },
    MSO_SHAPE.STAR_32_POINT: {
        'basename': '32-Point Star',
        'avLst':    (
            ('adj', 37500),
        )
    },
    MSO_SHAPE.STAR_4_POINT: {
        'basename': '4-Point Star',
        'avLst':    (
            ('adj', 12500),
        )
    },
    MSO_SHAPE.STAR_5_POINT: {
        'basename': '5-Point Star',
        'avLst':    (
            ('adj', 19098),
            ('hf', 105146),
            ('vf', 110557),
        )
    },
    MSO_SHAPE.STAR_6_POINT: {
        'basename': '6-Point Star',
        'avLst':    (
            ('adj', 28868),
            ('hf', 115470),
        )
    },
    MSO_SHAPE.STAR_7_POINT: {
        'basename': '7-Point Star',
        'avLst':    (
            ('adj', 34601),
            ('hf', 102572),
            ('vf', 105210),
        )
    },
    MSO_SHAPE.STAR_8_POINT: {
        'basename': '8-Point Star',
        'avLst':    (
            ('adj', 37500),
        )
    },
    MSO_SHAPE.STRIPED_RIGHT_ARROW: {
        'basename': 'Striped Right Arrow',
        'avLst':    (
            ('adj1', 50000),
            ('adj2', 50000),
        )
    },
    MSO_SHAPE.SUN: {
        'basename': 'Sun',
        'avLst':    (
            ('adj', 25000),
        )
    },
    MSO_SHAPE.SWOOSH_ARROW: {
        'basename': 'Swoosh Arrow',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 16667),
        )
    },
    MSO_SHAPE.TEAR: {
        'basename': 'Teardrop',
        'avLst':    (
            ('adj', 100000),
        )
    },
    MSO_SHAPE.TRAPEZOID: {
        'basename': 'Trapezoid',
        'avLst':    (
            ('adj', 25000),
        )
    },
    MSO_SHAPE.UP_ARROW: {
        'basename': 'Up Arrow',
        'avLst':    ()
    },
    MSO_SHAPE.UP_ARROW_CALLOUT: {
        'basename': 'Up Arrow Callout',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 25000),
            ('adj3', 25000),
            ('adj4', 64977),
        )
    },
    MSO_SHAPE.UP_DOWN_ARROW: {
        'basename': 'Up-Down Arrow',
        'avLst':    (
            ('adj1', 50000),
            ('adj1', 50000),
            ('adj2', 50000),
            ('adj2', 50000),
        )
    },
    MSO_SHAPE.UP_DOWN_ARROW_CALLOUT: {
        'basename': 'Up-Down Arrow Callout',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 25000),
            ('adj3', 25000),
            ('adj4', 48123),
        )
    },
    MSO_SHAPE.UP_RIBBON: {
        'basename': 'Up Ribbon',
        'avLst':    (
            ('adj1', 16667),
            ('adj2', 50000),
        )
    },
    MSO_SHAPE.U_TURN_ARROW: {
        'basename': 'U-Turn Arrow',
        'avLst':    (
            ('adj1', 25000),
            ('adj2', 25000),
            ('adj3', 25000),
            ('adj4', 43750),
            ('adj5', 75000),
        )
    },
    MSO_SHAPE.VERTICAL_SCROLL: {
        'basename': 'Vertical Scroll',
        'avLst':    (
            ('adj', 12500),
        )
    },
    MSO_SHAPE.WAVE: {
        'basename': 'Wave',
        'avLst':    (
            ('adj1', 12500),
            ('adj2', 0),
        )
    },
}

########NEW FILE########
__FILENAME__ = text
# encoding: utf-8

"""
Text-related objects such as TextFrame and Paragraph.
"""

from .dml.fill import FillFormat
from .enum.dml import MSO_FILL
from .enum.text import MSO_ANCHOR, PP_ALIGN
from .opc.constants import RELATIONSHIP_TYPE as RT
from .oxml.shared import Element, get_or_add
from .oxml.ns import _nsmap, qn
from .shapes import Subshape
from .util import Emu, lazyproperty, to_unicode


class TextFrame(Subshape):
    """
    The part of a shape that contains its text. Not all shapes have a text
    frame. Corresponds to the ``<p:txBody>`` element that can appear as a
    child element of ``<p:sp>``. Not intended to be constructed directly.
    """
    def __init__(self, txBody, parent):
        super(TextFrame, self).__init__(parent)
        self._txBody = txBody

    def add_paragraph(self):
        """
        Return new |_Paragraph| instance appended to the sequence of
        paragraphs contained in this text frame.
        """
        # <a:p> elements are last in txBody, so can simply append new one
        p = Element('a:p')
        self._txBody.append(p)
        return _Paragraph(p, self)

    @property
    def auto_size(self):
        """
        The type of automatic resizing that should be used to fit the text of
        this shape within its bounding box when the text would otherwise
        extend beyond the shape boundaries. May be |None|,
        ``MSO_AUTO_SIZE.NONE``, ``MSO_AUTO_SIZE.SHAPE_TO_FIT_TEXT``, or
        ``MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE``.
        """
        return self._bodyPr.autofit

    @auto_size.setter
    def auto_size(self, value):
        self._bodyPr.autofit = value

    def clear(self):
        """
        Remove all paragraphs except one empty one.
        """
        p_list = self._txBody.xpath('./a:p', namespaces=_nsmap)
        for p in p_list[1:]:
            self._txBody.remove(p)
        p = self.paragraphs[0]
        p.clear()

    @property
    def margin_bottom(self):
        """
        Inset of text from textframe border in EMU. ``pptx.util.Inches``
        provides a convenient way of setting the value, e.g.
        ``textframe.margin_bottom = Inches(0.05)``. Returns |None| if there
        is no explicit margin setting, meaning the setting is inherited from
        a master or theme. Conversely, setting a margin to |None| removes any
        explicit setting at the shape level and restores inheritance of the
        effective value.
        """
        return self._bodyPr.bIns

    @margin_bottom.setter
    def margin_bottom(self, emu):
        self._bodyPr.bIns = emu

    @property
    def margin_left(self):
        return self._bodyPr.lIns

    @margin_left.setter
    def margin_left(self, emu):
        self._bodyPr.lIns = emu

    @property
    def margin_right(self):
        return self._bodyPr.rIns

    @margin_right.setter
    def margin_right(self, emu):
        self._bodyPr.rIns = emu

    @property
    def margin_top(self):
        return self._bodyPr.tIns

    @margin_top.setter
    def margin_top(self, emu):
        self._bodyPr.tIns = emu

    @property
    def paragraphs(self):
        """
        Immutable sequence of |_Paragraph| instances corresponding to the
        paragraphs in this text frame. A text frame always contains at least
        one paragraph.
        """
        return tuple([_Paragraph(p, self) for p in self._txBody[qn('a:p')]])

    def _set_text(self, text):
        """Replace all text in text frame with single run containing *text*"""
        self.clear()
        self.paragraphs[0].text = to_unicode(text)

    #: Write-only. Assignment to *text* replaces all text currently contained
    #: in the text frame with the assigned expression. After assignment, the
    #: text frame contains exactly one paragraph containing a single run
    #: containing all the text. The assigned value can be a 7-bit ASCII
    #: string, a UTF-8 encoded 8-bit string, or unicode. String values are
    #: converted to unicode assuming UTF-8 encoding.
    text = property(None, _set_text)

    def _set_vertical_anchor(self, value):
        """
        Set ``anchor`` attribute of ``<a:bodyPr>`` element
        """
        anchor = MSO_ANCHOR.to_xml(value)
        bodyPr = get_or_add(self._txBody, 'a:bodyPr')
        bodyPr.set('anchor', anchor)

    #: Write-only. Assignment to *vertical_anchor* sets the vertical
    #: alignment of the text frame to top, middle, or bottom. Valid values are
    #: ``MSO_ANCHOR.TOP``, ``MSO_ANCHOR.MIDDLE``, or ``MSO_ANCHOR.BOTTOM``.
    #: The ``MSO`` name is imported from ``pptx.constants``.
    vertical_anchor = property(None, _set_vertical_anchor)

    @property
    def word_wrap(self):
        """
        Read-write value of the word wrap setting for this text frame, either
        True, False, or None. Assignment to *word_wrap* sets the wrapping
        behavior. True and False turn word wrap on and off, respectively.
        Assigning None to word wrap causes its word wrap setting to be
        removed entirely and the text frame wrapping behavior to be inherited
        from a parent element.
        """
        value_map = {'square': True, 'none': False, None: None}
        bodyPr = get_or_add(self._txBody, 'a:bodyPr')
        value = bodyPr.get('wrap')
        return value_map[value]

    @word_wrap.setter
    def word_wrap(self, value):
        value_map = {True: 'square', False: 'none'}
        bodyPr = get_or_add(self._txBody, 'a:bodyPr')
        if value is None:
            if 'wrap' in bodyPr.attrib:
                del bodyPr.attrib['wrap']
            return
        bodyPr.set('wrap', value_map[value])

    @property
    def _bodyPr(self):
        return self._txBody.bodyPr


class _Font(object):
    """
    Character properties object, providing font size, font name, bold,
    italic, etc. Corresponds to ``<a:rPr>`` child element of a run. Also
    appears as ``<a:defRPr>`` and ``<a:endParaRPr>`` in paragraph and
    ``<a:defRPr>`` in list style elements.
    """
    def __init__(self, rPr):
        super(_Font, self).__init__()
        self._rPr = rPr

    @property
    def bold(self):
        """
        Get or set boolean bold value of |_Font|, e.g.
        ``paragraph.font.bold = True``. If set to |None|, the bold setting is
        cleared and is inherited from an enclosing shape's setting, or a
        setting in a style or master. Returns None if no bold attribute is
        present, meaning the effective bold value is inherited from a master
        or the theme.
        """
        return self._rPr.b

    @bold.setter
    def bold(self, value):
        self._rPr.b = value

    @lazyproperty
    def color(self):
        """
        The |ColorFormat| instance that provides access to the color settings
        for this font.
        """
        if self.fill.type != MSO_FILL.SOLID:
            self.fill.solid()
        return self.fill.fore_color

    @lazyproperty
    def fill(self):
        """
        |FillFormat| instance for this font, providing access to fill
        properties such as fill color.
        """
        return FillFormat.from_fill_parent(self._rPr)

    @property
    def italic(self):
        """
        Get or set boolean italic value of |_Font| instance, with the same
        behaviors as bold with respect to None values.
        """
        return self._rPr.i

    @italic.setter
    def italic(self, value):
        self._rPr.i = value

    @property
    def name(self):
        """
        Get or set the typeface name for this |_Font| instance, causing the
        text it controls to appear in the named font, if a matching font is
        found. Returns |None| if the typeface is currently inherited from the
        theme. Setting it to |None| removes any override of the theme
        typeface.
        """
        latin = self._rPr.latin
        if latin is None:
            return None
        return latin.typeface

    @name.setter
    def name(self, value):
        if value is None:
            self._rPr.remove_latin()
        else:
            latin = self._rPr.get_or_add_latin()
            latin.typeface = value

    @property
    def size(self):
        """
        Height of the font in English Metric Units (EMU). The value is
        an instance of |BaseLength|, a subclass of |int| having properties
        for convenient conversion into points or other length units.
        Likewise, the :class:`pptx.util.Pt` class allows convenient
        specification of point values::

            >> font.size = Pt(24)
            >> font.size
            304800
            >> font.size.pt
            24.0
        """
        return self._rPr.sz

    @size.setter
    def size(self, emu):
        self._rPr.sz = Emu(emu)


class _Hyperlink(Subshape):
    """
    Text run hyperlink object. Corresponds to ``<a:hlinkClick>`` child
    element of the run's properties element (``<a:rPr>``).
    """
    def __init__(self, rPr, parent):
        super(_Hyperlink, self).__init__(parent)
        self._rPr = rPr

    @property
    def address(self):
        """
        Read/write. The URL of the hyperlink. URL can be on http, https,
        mailto, or file scheme; others may work.
        """
        if self._hlinkClick is None:
            return None
        return self.part.target_ref(self._hlinkClick.rId)

    @address.setter
    def address(self, url):
        # implements all three of add, change, and remove hyperlink
        if self._hlinkClick is not None:
            self._remove_hlinkClick()
        if url:
            self._add_hlinkClick(url)

    def _add_hlinkClick(self, url):
        rId = self.part.relate_to(url, RT.HYPERLINK, is_external=True)
        self._rPr.add_hlinkClick(rId)

    @property
    def _hlinkClick(self):
        return self._rPr.hlinkClick

    def _remove_hlinkClick(self):
        assert self._hlinkClick is not None
        self.part.drop_rel(self._hlinkClick.rId)
        self._rPr.hlinkClick = None


class _Paragraph(Subshape):
    """
    Paragraph object. Not intended to be constructed directly.
    """
    def __init__(self, p, parent):
        super(_Paragraph, self).__init__(parent)
        self._p = p

    def add_run(self):
        """
        Return a new run appended to the runs in this paragraph.
        """
        r = self._p.add_r()
        return _Run(r, self)

    @property
    def alignment(self):
        """
        Horizontal alignment of this paragraph, represented by a constant
        value like ``PP_ALIGN.CENTER``. Its value can be |None|, meaning the
        paragraph has no alignment setting and its effective value is
        inherited from a higher-level object.
        """
        return PP_ALIGN.from_xml(self._pPr.algn)

    @alignment.setter
    def alignment(self, alignment):
        algn = PP_ALIGN.to_xml(alignment)
        self._pPr.algn = algn

    def clear(self):
        """
        Remove all runs from this paragraph. Paragraph properties are
        preserved.
        """
        self._p.remove_child_r_elms()

    @property
    def font(self):
        """
        |_Font| object containing default character properties for the runs in
        this paragraph. These character properties override default properties
        inherited from parent objects such as the text frame the paragraph is
        contained in and they may be overridden by character properties set at
        the run level.
        """
        return _Font(self._defRPr)

    @property
    def level(self):
        """
        Read-write integer indentation level of this paragraph, having a
        range of 0-8 inclusive. 0 represents a top-level paragraph and is the
        default value. Indentation level is most commonly encountered in a
        bulleted list, as is found on a word bullet slide.
        """
        # return self._pPr.lvl
        return int(self._pPr.get('lvl', 0))

    @level.setter
    def level(self, level):
        if not isinstance(level, int) or level < 0 or level > 8:
            msg = "paragraph level must be integer between 0 and 8 inclusive"
            raise ValueError(msg)
        self._pPr.set('lvl', str(level))

    @property
    def runs(self):
        """
        Immutable sequence of |_Run| instances corresponding to the runs in
        this paragraph.
        """
        xpath = './a:r'
        r_elms = self._p.xpath(xpath, namespaces=_nsmap)
        runs = []
        for r in r_elms:
            runs.append(_Run(r, self))
        return tuple(runs)

    @property
    def _defRPr(self):
        """
        The |CT_TextCharacterProperties| instance (<a:defRPr> element) that
        defines the default run properties for runs in this paragraph. Causes
        the element to be added if not present.
        """
        return self._pPr.get_or_add_defRPr()

    @property
    def _pPr(self):
        """
        The |CT_TextParagraphProperties| instance for this paragraph, the
        <a:pPr> element containing its paragraph properties. Causes the
        element to be added if not present.
        """
        return self._p.get_or_add_pPr()

    def _set_text(self, text):
        """Replace runs with single run containing *text*"""
        self.clear()
        r = self.add_run()
        r.text = to_unicode(text)

    #: Write-only. Assignment to *text* replaces all text currently contained
    #: in the paragraph. After assignment, the paragraph containins exactly
    #: one run containing the text value of the assigned expression. The
    #: assigned value can be a 7-bit ASCII string, a UTF-8 encoded 8-bit
    #: string, or unicode. String values are converted to unicode assuming
    #: UTF-8 encoding.
    text = property(None, _set_text)


class _Run(Subshape):
    """
    Text run object. Corresponds to ``<a:r>`` child element in a paragraph.
    """
    def __init__(self, r, parent):
        super(_Run, self).__init__(parent)
        self._r = r

    @property
    def font(self):
        """
        |_Font| instance containing run-level character properties for the
        text in this run. Character properties can be and perhaps most often
        are inherited from parent objects such as the paragraph and slide
        layout the run is contained in. Only those specifically overridden at
        the run level are contained in the font object.
        """
        rPr = self._r.get_or_add_rPr()
        return _Font(rPr)

    @lazyproperty
    def hyperlink(self):
        """
        |_Hyperlink| instance acting as proxy for any ``<a:hlinkClick>``
        element under the run properties element. Created on demand, the
        hyperlink object is available whether an ``<a:hlinkClick>`` element
        is present or not, and creates or deletes that element as appropriate
        in response to actions on its methods and attributes.
        """
        rPr = self._r.get_or_add_rPr()
        return _Hyperlink(rPr, self)

    @property
    def text(self):
        """
        Read/Write. Text contained in the run. A regular text run is required
        to contain exactly one ``<a:t>`` (text) element. Assignment to *text*
        replaces the text currently contained in the run. The assigned value
        can be a 7-bit ASCII string, a UTF-8 encoded 8-bit string, or unicode.
        String values are converted to unicode assuming UTF-8 encoding.
        """
        return self._r.t.text

    @text.setter
    def text(self, str):
        """Set the text of this run to *str*."""
        self._r.t._setText(to_unicode(str))

########NEW FILE########
__FILENAME__ = util
# encoding: utf-8

"""
Utility functions and classes that come in handy when working with PowerPoint
and Open XML.
"""

import platform


class BaseLength(int):
    """
    Base class for length classes Inches, Emu, Cm, Mm, Pt, and Px. Provides
    properties for converting length values to convenient units.
    """

    _EMUS_PER_INCH = 914400
    _EMUS_PER_CENTIPOINT = 127
    _EMUS_PER_CM = 360000
    _EMUS_PER_MM = 36000
    _EMUS_PER_PT = 12700
    _EMUS_PER_PX = 9525 if platform.system() == 'Windows' else 12700

    def __new__(cls, emu):
        return int.__new__(cls, emu)

    @property
    def inches(self):
        """
        Floating point length in inches
        """
        return self / float(self._EMUS_PER_INCH)

    @property
    def centipoints(self):
        """
        Integer length in hundredths of a point (1/7200 inch). Used
        internally because PowerPoint stores font size in centipoints.
        """
        return self / self._EMUS_PER_CENTIPOINT

    @property
    def cm(self):
        """
        Floating point length in centimeters
        """
        return self / float(self._EMUS_PER_CM)

    @property
    def emu(self):
        """
        Integer length in English Metric Units
        """
        return self

    @property
    def mm(self):
        """
        Floating point length in millimeters
        """
        return self / float(self._EMUS_PER_MM)

    @property
    def pt(self):
        """
        Floating point length in points
        """
        return self / float(self._EMUS_PER_PT)

    @property
    def px(self):
        """
        Integer length in pixels. Note this value is platform dependent,
        using 96 pixels/inch on Windows, 72 pixels/inch on all other
        platforms.
        """
        # round can somtimes return values like x.999999 which are truncated
        # to x by int(); adding the 0.1 prevents this
        return int(round(self / float(self._EMUS_PER_PX)) + 0.1)


class Inches(BaseLength):
    """
    Convenience constructor for length in inches
    """
    def __new__(cls, inches):
        emu = int(inches * BaseLength._EMUS_PER_INCH)
        return BaseLength.__new__(cls, emu)


class Centipoints(BaseLength):
    """
    Convenience constructor for length in hundredths of a point
    """
    def __new__(cls, centipoints):
        emu = int(centipoints * BaseLength._EMUS_PER_CENTIPOINT)
        return BaseLength.__new__(cls, emu)


class Cm(BaseLength):
    """
    Convenience constructor for length in centimeters
    """
    def __new__(cls, cm):
        emu = int(cm * BaseLength._EMUS_PER_CM)
        return BaseLength.__new__(cls, emu)


class Emu(BaseLength):
    """
    Convenience constructor for length in english metric units
    """
    def __new__(cls, emu):
        return BaseLength.__new__(cls, int(emu))


class Mm(BaseLength):
    """
    Convenience constructor for length in millimeters
    """
    def __new__(cls, mm):
        emu = int(mm * BaseLength._EMUS_PER_MM)
        return BaseLength.__new__(cls, emu)


class Pt(BaseLength):
    """
    Convenience value class for specifying a length in points
    """
    def __new__(cls, points):
        emu = int(points * BaseLength._EMUS_PER_PT)
        return BaseLength.__new__(cls, emu)


class Px(BaseLength):
    """
    Convenience constructor for length in pixels
    """
    def __new__(cls, px):
        emu = int(px * BaseLength._EMUS_PER_PX)
        return BaseLength.__new__(cls, emu)


class Collection(object):
    """
    Base class for collection classes. May also be used for part collections
    that don't yet have any custom methods.

    Has the following characteristics.:

    * Container (implements __contains__)
    * Iterable (delegates __iter__ to |list|)
    * Sized (implements __len__)
    * Sequence (delegates __getitem__ to |list|)
    """
    def __init__(self):
        super(Collection, self).__init__()
        self._values_ = []

    @property
    def _values(self):
        """Return read-only reference to collection values (list)."""
        return self._values_

    def __contains__(self, item):  # __iter__ would do this job by itself
        """Supports 'in' operator (e.g. 'x in collection')."""
        return (item in self._values_)

    def __getitem__(self, key):
        """Provides indexed access, (e.g. 'collection[0]')."""
        return self._values_.__getitem__(key)

    def __iter__(self):
        """Supports iteration (e.g. 'for x in collection: pass')."""
        return self._values_.__iter__()

    def __len__(self):
        """Supports len() function (e.g. 'len(collection) == 1')."""
        return len(self._values_)

    def index(self, item):
        """Supports index method (e.g. '[1, 2, 3].index(2) == 1')."""
        return self._values_.index(item)


def lazyproperty(f):
    """
    @lazyprop decorator. Decorated method will be called only on first access
    to calculate a cached property value. After that, the cached value is
    returned.
    """
    cache_attr_name = '_%s' % f.__name__  # like '_foobar' for prop 'foobar'
    docstring = f.__doc__

    def get_prop_value(obj):
        try:
            return getattr(obj, cache_attr_name)
        except AttributeError:
            value = f(obj)
            setattr(obj, cache_attr_name, value)
            return value

    return property(get_prop_value, doc=docstring)


def to_unicode(text):
    """
    Return *text* as a unicode string.

    *text* can be a 7-bit ASCII string, a UTF-8 encoded 8-bit string, or
    unicode. String values are converted to unicode assuming UTF-8 encoding.
    Unicode values are returned unchanged.
    """
    # both str and unicode inherit from basestring
    if not isinstance(text, basestring):
        tmpl = 'expected UTF-8 encoded string or unicode, got %s value %s'
        raise TypeError(tmpl % (type(text), text))
    # return unicode strings unchanged
    if isinstance(text, unicode):
        return text
    # otherwise assume UTF-8 encoding, which also works for ASCII
    return unicode(text, 'utf-8')

########NEW FILE########
__FILENAME__ = gen_spec
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# gen_spec.py
#

import argparse
import os
import sqlite3
import sys

from lxml import objectify

sys.path.append('/Users/scanny/Dropbox/src/python-pptx')

# import pdb; pdb.set_trace()


"""
Utility code to load spec database and generate portions of constants.py and
spec.py

Fields
----------------------------------------

id_
   Distinct integer identifier, defined in the MS API specification, although
   that spec is incomplete. When not documented, it is discovered by
   inspection in the PowerPoint built-in VBA IDE.

ms_name
   name assigned to the auto shape type in the MS API, e.g.
   'msoShapeRoundedRectangle'.

desc
   description of auto shape type from MS API specification, invented for
   auto shapes not documented by Microsoft.

const_name
   upper snake case name used for symbolic constant representing id of the
   auto shape, e.g. 'LINE_CALLOUT_1_ACCENT_BAR'.

base_name
   base of name an instance of this auto shape type is assigned in the XML,
   e.g. '10-Point Star'. In the XML, an integer suffix is appended to create
   the shape name, e.g. 'Rounded Rectangle 9'.

prst
   string key used in the XML to specify the type of an auto shape element,
   e.g. 'roundRect'.

adj_vals
   sequence of (name, val) tuples specifying the available adjustment values
   for the auto shape type along with the default value for each.


Sources
----------------------------------------

src_data/msoAutoShapeType.py
   Tuples containing all the components of the full definition from the
   various sources, documented, generated, and hand-coded where necessary.

presetShapeDefinitions.xml
   The adjustment values are pulled from the XML file in which they are
   defined, distributed as part of the ISO/IEC spec.


Outputs
----------------------------------------

constants.py
spec.py
autoshapetypes.rst (not implemented yet)

"""


class MsoAutoShapeTypeCollection(list):
    """auto shape type documented by Microsoft"""
    def __init__(self):
        super(MsoAutoShapeTypeCollection, self).__init__()

    @classmethod
    def load(cls, sort=None):
        conn = sqlite3.connect('spec.db')
        c = conn.cursor()
        c.execute(
            '  SELECT id, prst, const_name, base_name, ms_name, desc\n'
            '    FROM auto_shape_types\n'
            'ORDER BY const_name'
        )
        mastc = cls()
        for id_, prst, const_name, base_name, ms_name, desc in c:
            mast = MsoAutoShapeType(id_, prst, const_name, base_name,
                                    ms_name, desc)
            mastc.append(mast)
        mastc.load_adjustment_values(c)
        conn.close()
        return mastc

    def load_adjustment_values(self, c):
        """load adjustment values for auto shape types in self"""
        # retrieve auto shape types in const_name order --------
        for mast in self:
            # retriev adj vals for this auto shape type --------
            c.execute(
                '  SELECT name, val\n'
                '    FROM adjustment_values\n'
                '   WHERE prst = ?\n'
                'ORDER BY seq_nmbr', (mast.prst,)
            )
            for name, val in c:
                mast.adj_vals.append(AdjustmentValue(name, val))


class MsoAutoShapeType(object):
    def __init__(self, id_, prst, const_name, base_name, ms_name, desc):
        super(MsoAutoShapeType, self).__init__()
        self.id_ = id_
        self.prst = prst
        self.const_name = const_name
        self.base_name = base_name
        self.ms_name = ms_name
        self.desc = desc
        self.adj_vals = []


class AdjustmentValue(object):
    def __init__(self, name, val):
        super(AdjustmentValue, self).__init__()
        self.name = name
        self.val = val


def create_tables(c):
    """create (or recreate) the auto shape type tables"""
    # auto_shape_types ---------------------
    c.execute(
        'DROP TABLE IF EXISTS auto_shape_types'
    )
    c.execute(
        'CREATE TABLE auto_shape_types (\n'
        '    id         integer,\n'
        '    prst       text,\n'
        '    const_name text,\n'
        '    base_name  text,\n'
        '    ms_name    text,\n'
        '    desc       text\n'
        ')\n'
    )
    c.execute(
        'DROP TABLE IF EXISTS adjustment_values'
    )
    c.execute(
        'CREATE TABLE adjustment_values (\n'
        '    prst     text,\n'
        '    seq_nmbr integer,\n'
        '    name     text,\n'
        '    val      integer\n'
        ')\n'
    )


def insert_adjustment_values(c):
    """insert adjustment values into their table"""
    adjustment_values = load_adjustment_values()
    # insert into table ------------------------------------
    q_insert = (
        'INSERT INTO adjustment_values\n'
        '            (prst, seq_nmbr, name, val)\n'
        '     VALUES (?, ?, ?, ?)\n'
    )
    c.executemany(q_insert, adjustment_values)


def load_adjustment_values():
    """load adjustment values and their default values from XML"""
    # parse XML --------------------------------------------
    thisdir = os.path.split(__file__)[0]
    prst_defs_relpath = (
        'ISO-IEC-29500-1/schemas/dml-geometries/OfficeOpenXML-DrawingMLGeomet'
        'ries/presetShapeDefinitions.xml'
    )
    prst_defs_path = os.path.join(thisdir, prst_defs_relpath)
    presetShapeDefinitions = objectify.parse(prst_defs_path).getroot()
    # load individual records into tuples to return --------
    ns = 'http://schemas.openxmlformats.org/drawingml/2006/main'
    avLst_qn = '{%s}avLst' % ns
    adjustment_values = []
    for shapedef in presetShapeDefinitions.iterchildren():
        prst = shapedef.tag
        try:
            avLst = shapedef[avLst_qn]
        except AttributeError:
            continue
        for idx, gd in enumerate(avLst.gd):
            name = gd.get('name')
            val = int(gd.get('fmla')[4:])  # strip off leading 'val '
            record = (prst, idx+1, name, val)
            adjustment_values.append(record)
    return adjustment_values


def print_mso_auto_shape_type_constants():
    """print symbolic constant definitions for msoAutoShapeType"""
    auto_shape_types = MsoAutoShapeTypeCollection.load(sort='const_name')
    out = render_mso_auto_shape_type_constants(auto_shape_types)
    print out


def print_mso_auto_shape_type_enum():
    """print symbolic constant definitions for msoAutoShapeType"""
    auto_shape_types = MsoAutoShapeTypeCollection.load(sort='const_name')
    out = render_mso_auto_shape_type_enum(auto_shape_types)
    print out


def print_mso_auto_shape_type_spec():
    """print spec dictionary for msoAutoShapeType"""
    auto_shape_types = MsoAutoShapeTypeCollection.load(sort='const_name')
    out = render_mso_auto_shape_type_spec(auto_shape_types)
    print out


def render_adj_vals(adj_vals):
    # calculate adj_vals string, possibly multi-line ---
    if adj_vals:
        lines = []
        for av in adj_vals:
            indent = ' ' * 12
            line = "%s('%s', %d)," % (indent, av.name, av.val)
            lines.append(line)
        lines_str = '\n'.join(lines)
        out = '(\n%s\n        )' % lines_str
    else:
        out = '()'
    return out


def render_desc(desc):
    """calculate desc string, wrapped if too long"""
    desc = desc + '.'
    desc_lines = split_len(desc, 54)
    if len(desc_lines) > 1:
        join_str = "'\n%s'" % (' '*21)
        lines_str = join_str.join(desc_lines)
        out = "('%s')" % lines_str
    else:
        out = "'%s'" % desc_lines[0]
    return out


def render_mso_auto_shape_type_constants(auto_shape_types):
    out = (
        'class MSO_AUTO_SHAPE_TYPE(object):\n'
        '    """\n'
        '    Constants corresponding to the msoAutoShapeType enumeration in '
        'the\n    MS API. Standard abbreviation is \'MAST\', e.g.:\n\n      '
        '  from pptx.spec import MSO_AUTO_SHAPE_TYPE as MAST\n\n'
        '    """\n'
        '    # msoAutoShapeType -----------------\n'
    )
    for ast in auto_shape_types:
        out += '    %s = %d\n' % (ast.const_name, ast.id_)
    return out


def render_mso_auto_shape_type_enum(auto_shape_types):
    out = (
        'class MSO_AUTO_SHAPE_TYPE(XmlEnumeration):\n'
        '    """\n'
        '    Specifies a type of AutoShape, e.g. DOWN_ARROW\n'
        '    """\n'
        '\n'
        '    __members__ = (\n'
    )
    for ast in auto_shape_types:
        tmpl = (
            "        XmlMappedEnumMember(\n"
            "            '%s', %d, '%s', '%s'\n"
            "        ),\n"
        )
        args = (ast.const_name, ast.id_, ast.prst, ast.desc)
        out += tmpl % args
        # break
    out += '    )'
    return out


def render_mso_auto_shape_type_spec(auto_shape_types):
    out = 'autoshape_types = {\n'
    for idx, ast in enumerate(auto_shape_types):
        out += (
            "    MAST.%s: {\n"
            "        'basename': '%s',\n"
            "        'prst':     '%s',\n"
            "        'avLst':    %s\n"
            "    },\n" %
            (ast.const_name, ast.base_name, ast.prst,
             render_adj_vals(ast.adj_vals))
        )
    out += '}'
    return out


def split_len(s, length):
    """split string *s* into list of strings no longer than *length*"""
    return [s[i:i+length] for i in range(0, len(s), length)]


def to_mixed_case(s):
    """
    convert upper snake case string to mixed case, e.g. MIXED_CASE becomes
    MixedCase
    """
    out = ''
    last_c = ''
    for c in s:
        if c == '_':
            pass
        elif last_c in ('', '_'):
            out += c.upper()
        else:
            out += c.lower()
        last_c = c
    return out


# ===========================================================================
# load auto shape types into database
# ===========================================================================
# this code is broken now, in particular the insert functions need to be
# connected to the new file src_data/msoAutoShapeType.py
# ===========================================================================

# conn = sqlite3.connect('spec.db')
# c = conn.cursor()

# # create_tables(c)
# # insert_adjustment_values(c)

# conn.commit()
# conn.close()


# ============================================================================
# CLI parser
# ============================================================================

def parse_args(spectypes):
    """
    Return arguments object formed by parsing the command line used to launch
    the program.
    """
    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument(
        "-c", "--constants",
        help="emit constants instead of spec dict",
        action="store_true"
    )
    arg_parser.add_argument(
        "spectype",
        help="specifies the spec type to be generated",
        choices=spectypes
    )
    return arg_parser.parse_args()


# ============================================================================
# main
# ============================================================================

spectypes = ('msoAutoShapeType', 'MSO_AUTO_SHAPE_TYPE')

args = parse_args(spectypes)

# call print function for requested spectype ---------------
if args.constants:
    if args.spectype == 'msoAutoShapeType':
        print_mso_auto_shape_type_constants()
else:
    if args.spectype == 'msoAutoShapeType':
        print_mso_auto_shape_type_spec()
    elif args.spectype == 'MSO_AUTO_SHAPE_TYPE':
        print_mso_auto_shape_type_enum()

# avoid error message "close failed ... sys.excepthook is missing ...
sys.stdout.flush()

########NEW FILE########
__FILENAME__ = msoAutoShapeType
# -*- coding: utf-8 -*-
#
# msoAutoShapeType.py
#
# original source for msoAutoShapeType constants and spec definitions
#


def msdn_msoAutoShapeTypes():
    """
    Return sequence of tuples representing the msoAutoShapeType enumeration
    as defined in the MS Office API.

    Access with::

        for ms_name, id_, desc in msdn_msoAutoShapeTypes():
            ...

    This is structured as a function simply so code folding will work on it.
    """
    return (
        ('msoShape10PointStar', 149, '10-Point Star'),
        ('msoShape12PointStar', 150, '12-Point Star'),
        ('msoShape16pointStar', 94, '16-point star.'),
        ('msoShape24pointStar', 95, '24-point star.'),
        ('msoShape32pointStar', 96, '32-point star.'),
        ('msoShape4pointStar', 91, '4-point star.'),
        ('msoShape5pointStar', 92, '5-point star.'),
        ('msoShape6PointStar', 147, '6-Point Star'),
        ('msoShape7PointStar', 148, '7-Point Star'),
        ('msoShape8pointStar', 93, '8-point star.'),
        ('msoShapeActionButtonBackorPrevious', 129,
         'Back or Previous button. Supports mouse-click and mouse-over actio'
         'ns.'),
        ('msoShapeActionButtonBeginning', 131,
         'Beginning button. Supports mouse-click and mouse-over actions.'),
        ('msoShapeActionButtonCustom', 125,
         'Button with no default picture or text. Supports mouse-click and m'
         'ouse-over actions.'),
        ('msoShapeActionButtonDocument', 134,
         'Document button. Supports mouse-click and mouse-over actions.'),
        ('msoShapeActionButtonEnd', 132,
         'End button. Supports mouse-click and mouse-over actions.'),
        ('msoShapeActionButtonForwardorNext', 130,
         'Forward or Next button. Supports mouse-click and mouse-over action'
         's.'),
        ('msoShapeActionButtonHelp', 127,
         'Help button. Supports mouse-click and mouse-over actions.'),
        ('msoShapeActionButtonHome', 126,
         'Home button. Supports mouse-click and mouse-over actions.'),
        ('msoShapeActionButtonInformation', 128,
         'Information button. Supports mouse-click and mouse-over actions.'),
        ('msoShapeActionButtonMovie', 136,
         'Movie button. Supports mouse-click and mouse-over actions.'),
        ('msoShapeActionButtonReturn', 133,
         'Return button. Supports mouse-click and mouse-over actions.'),
        ('msoShapeActionButtonSound', 135,
         'Sound button. Supports mouse-click and mouse-over actions.'),
        ('msoShapeArc', 25, 'Arc.'),
        ('msoShapeBalloon', 137, 'Balloon.'),
        ('msoShapeBentArrow', 41,
         'Block arrow that follows a curved 90-degree angle.'),
        ('msoShapeBentUpArrow', 44,
         'Block arrow that follows a sharp 90-degree angle. Points up by def'
         'ault.'),
        ('msoShapeBevel', 15, 'Bevel.'),
        ('msoShapeBlockArc', 20, 'Block arc.'),
        ('msoShapeCan', 13, 'Can.'),
        ('msoShapeChartPlus', 182, 'Chart Plus'),
        ('msoShapeChartStar', 181, 'Chart Star'),
        ('msoShapeChartX', 180, 'Chart X'),
        ('msoShapeChevron', 52, 'Chevron.'),
        ('msoShapeChord', 161, 'Geometric chord shape'),
        ('msoShapeCircularArrow', 60,
         'Block arrow that follows a curved 180-degree angle.'),
        ('msoShapeCloud', 179, 'Cloud'),
        ('msoShapeCloudCallout', 108, 'Cloud callout.'),
        ('msoShapeCorner', 162, 'Corner'),
        ('msoShapeCornerTabs', 169, 'Corner Tabs'),
        ('msoShapeCross', 11, 'Cross.'),
        ('msoShapeCube', 14, 'Cube.'),
        ('msoShapeCurvedDownArrow', 48, 'Block arrow that curves down.'),
        ('msoShapeCurvedDownRibbon', 100, 'Ribbon banner that curves down.'),
        ('msoShapeCurvedLeftArrow', 46, 'Block arrow that curves left.'),
        ('msoShapeCurvedRightArrow', 45, 'Block arrow that curves right.'),
        ('msoShapeCurvedUpArrow', 47, 'Block arrow that curves up.'),
        ('msoShapeCurvedUpRibbon', 99, 'Ribbon banner that curves up.'),
        ('msoShapeDecagon', 144, 'Decagon'),
        ('msoShapeDiagonalStripe', 141, 'Diagonal Stripe'),
        ('msoShapeDiamond', 4, 'Diamond'),
        ('msoShapeDodecagon', 146, 'Dodecagon'),
        ('msoShapeDonut', 18, 'Donut.'),
        ('msoShapeDoubleBrace', 27, 'Double brace.'),
        ('msoShapeDoubleBracket', 26, 'Double bracket.'),
        ('msoShapeDoubleWave', 104, 'Double wave.'),
        ('msoShapeDownArrow', 36, 'Block arrow that points down.'),
        ('msoShapeDownArrowCallout', 56,
         'Callout with arrow that points down.'),
        ('msoShapeDownRibbon', 98,
         'Ribbon banner with center area below ribbon ends.'),
        ('msoShapeExplosion1', 89, 'Explosion.'),
        ('msoShapeExplosion2', 90, 'Explosion.'),
        ('msoShapeFlowchartAlternateProcess', 62,
         'Alternate process flowchart symbol.'),
        ('msoShapeFlowchartCard', 75, 'Card flowchart symbol.'),
        ('msoShapeFlowchartCollate', 79, 'Collate flowchart symbol.'),
        ('msoShapeFlowchartConnector', 73, 'Connector flowchart symbol.'),
        ('msoShapeFlowchartData', 64, 'Data flowchart symbol.'),
        ('msoShapeFlowchartDecision', 63, 'Decision flowchart symbol.'),
        ('msoShapeFlowchartDelay', 84, 'Delay flowchart symbol.'),
        ('msoShapeFlowchartDirectAccessStorage', 87,
         'Direct access storage flowchart symbol.'),
        ('msoShapeFlowchartDisplay', 88, 'Display flowchart symbol.'),
        ('msoShapeFlowchartDocument', 67, 'Document flowchart symbol.'),
        ('msoShapeFlowchartExtract', 81, 'Extract flowchart symbol.'),
        ('msoShapeFlowchartInternalStorage', 66,
         'Internal storage flowchart symbol.'),
        ('msoShapeFlowchartMagneticDisk', 86,
         'Magnetic disk flowchart symbol.'),
        ('msoShapeFlowchartManualInput', 71,
         'Manual input flowchart symbol.'),
        ('msoShapeFlowchartManualOperation', 72,
         'Manual operation flowchart symbol.'),
        ('msoShapeFlowchartMerge', 82, 'Merge flowchart symbol.'),
        ('msoShapeFlowchartMultidocument', 68,
         'Multi-document flowchart symbol.'),
        ('msoShapeFlowchartOfflineStorage', 139, 'Offline Storage'),
        ('msoShapeFlowchartOffpageConnector', 74,
         'Off-page connector flowchart symbol.'),
        ('msoShapeFlowchartOr', 78, '"Or" flowchart symbol.'),
        ('msoShapeFlowchartPredefinedProcess', 65,
         'Predefined process flowchart symbol.'),
        ('msoShapeFlowchartPreparation', 70,
         'Preparation flowchart symbol.'),
        ('msoShapeFlowchartProcess', 61, 'Process flowchart symbol.'),
        ('msoShapeFlowchartPunchedTape', 76,
         'Punched tape flowchart symbol.'),
        ('msoShapeFlowchartSequentialAccessStorage', 85,
         'Sequential access storage flowchart symbol.'),
        ('msoShapeFlowchartSort', 80, 'Sort flowchart symbol.'),
        ('msoShapeFlowchartStoredData', 83, 'Stored data flowchart symbol.'),
        ('msoShapeFlowchartSummingJunction', 77,
         'Summing junction flowchart symbol.'),
        ('msoShapeFlowchartTerminator', 69, 'Terminator flowchart symbol.'),
        ('msoShapeFoldedCorner', 16, 'Folded corner.'),
        ('msoShapeFrame', 158, 'Frame'),
        ('msoShapeFunnel', 174, 'Funnel'),
        ('msoShapeGear6', 172, 'Gear 6'),
        ('msoShapeGear9', 173, 'Gear 9'),
        ('msoShapeHalfFrame', 159, 'Half Frame'),
        ('msoShapeHeart', 21, 'Heart.'),
        ('msoShapeHeptagon', 145, 'Heptagon'),
        ('msoShapeHexagon', 10, 'Hexagon.'),
        ('msoShapeHorizontalScroll', 102, 'Horizontal scroll.'),
        ('msoShapeIsoscelesTriangle', 7, 'Isosceles triangle.'),
        ('msoShapeLeftArrow', 34, 'Block arrow that points left.'),
        ('msoShapeLeftArrowCallout', 54,
         'Callout with arrow that points left.'),
        ('msoShapeLeftBrace', 31, 'Left brace.'),
        ('msoShapeLeftBracket', 29, 'Left bracket.'),
        ('msoShapeLeftCircularArrow', 176, 'Left Circular Arrow'),
        ('msoShapeLeftRightArrow', 37,
         'Block arrow with arrowheads that point both left and right.'),
        ('msoShapeLeftRightArrowCallout', 57,
         'Callout with arrowheads that point both left and right.'),
        ('msoShapeLeftRightCircularArrow', 177, 'Left Right Circular Arrow'),
        ('msoShapeLeftRightRibbon', 140, 'Left Right Ribbon'),
        ('msoShapeLeftRightUpArrow', 40,
         'Block arrow with arrowheads that point left, right, and up.'),
        ('msoShapeLeftUpArrow', 43,
         'Block arrow with arrowheads that point left and up.'),
        ('msoShapeLightningBolt', 22, 'Lightning bolt.'),
        ('msoShapeLineCallout1', 109,
         'Callout with border and horizontal callout line.'),
        ('msoShapeLineCallout1AccentBar', 113,
         'Callout with horizontal accent bar.'),
        ('msoShapeLineCallout1BorderandAccentBar', 121,
         'Callout with border and horizontal accent bar.'),
        ('msoShapeLineCallout1NoBorder', 117,
         'Callout with horizontal line.'),
        ('msoShapeLineCallout2', 110,
         'Callout with diagonal straight line.'),
        ('msoShapeLineCallout2AccentBar', 114,
         'Callout with diagonal callout line and accent bar.'),
        ('msoShapeLineCallout2BorderandAccentBar', 122,
         'Callout with border, diagonal straight line, and accent bar.'),
        ('msoShapeLineCallout2NoBorder', 118,
         'Callout with no border and diagonal callout line.'),
        ('msoShapeLineCallout3', 111, 'Callout with angled line.'),
        ('msoShapeLineCallout3AccentBar', 115,
         'Callout with angled callout line and accent bar.'),
        ('msoShapeLineCallout3BorderandAccentBar', 123,
         'Callout with border, angled callout line, and accent bar.'),
        ('msoShapeLineCallout3NoBorder', 119,
         'Callout with no border and angled callout line.'),
        ('msoShapeLineCallout4', 112,
         'Callout with callout line segments forming a U-shape.'),
        ('msoShapeLineCallout4AccentBar', 116,
         'Callout with accent bar and callout line segments forming a U-shap'
         'e.'),
        ('msoShapeLineCallout4BorderandAccentBar', 124,
         'Callout with border, accent bar, and callout line segments forming'
         'a U-shape.'),
        ('msoShapeLineCallout4NoBorder', 120,
         'Callout with no border and callout line segments forming a U-shape'
         '.'),
        ('msoShapeLineInverse', 183, 'Straight Connector'),
        ('msoShapeMathDivide', 166, 'Division'),
        ('msoShapeMathEqual', 167, 'Equal'),
        ('msoShapeMathMinus', 164, 'Minus'),
        ('msoShapeMathMultiply', 165, 'Multiply'),
        ('msoShapeMathNotEqual', 168, 'Not Equal'),
        ('msoShapeMathPlus', 163, 'Plus'),
        ('msoShapeMoon', 24, 'Moon.'),
        ('msoShapeNoSymbol', 19, '"No" symbol.'),
        ('msoShapeNonIsoscelesTrapezoid', 143, 'Non-isosceles Trapezoid'),
        ('msoShapeNotPrimitive', 138, 'Not supported.'),
        ('msoShapeNotchedRightArrow', 50,
         'Notched block arrow that points right.'),
        ('msoShapeOctagon', 6, 'Octagon'),
        ('msoShapeOval', 9, 'Oval'),
        ('msoShapeOvalCallout', 107, 'Oval-shaped callout.'),
        ('msoShapeParallelogram', 2, 'Parallelogram'),
        ('msoShapePentagon', 51, 'Pentagon.'),
        ('msoShapePie', 142, 'Pie'),
        ('msoShapePieWedge', 175, 'Pie'),
        ('msoShapePlaque', 28, 'Plaque.'),
        ('msoShapePlaqueTabs', 171, 'Plaque Tabs'),
        ('msoShapeQuadArrow', 39,
         'Block arrows that point up, down, left, and right.'),
        ('msoShapeQuadArrowCallout', 59,
         'Callout with arrows that point up, down, left, and right.'),
        ('msoShapeRectangle', 1, 'Rectangle'),
        ('msoShapeRectangularCallout', 105, 'Rectangular callout.'),
        ('msoShapeRegularPentagon', 12, 'Pentagon.'),
        ('msoShapeRightArrow', 33, 'Block arrow that points right.'),
        ('msoShapeRightArrowCallout', 53,
         'Callout with arrow that points right.'),
        ('msoShapeRightBrace', 32, 'Right brace.'),
        ('msoShapeRightBracket', 30, 'Right bracket.'),
        ('msoShapeRightTriangle', 8, 'Right triangle.'),
        ('msoShapeRound1Rectangle', 151, 'Round Single Corner Rectangle'),
        ('msoShapeRound2DiagRectangle', 153,
         'Round Diagonal Corner Rectangle'),
        ('msoShapeRound2SameRectangle', 152,
         'Round Same Side Corner Rectangle'),
        ('msoShapeRoundedRectangle', 5, 'Rounded rectangle.'),
        ('msoShapeRoundedRectangularCallout', 106,
         'Rounded rectangle-shaped callout.'),
        ('msoShapeSmileyFace', 17, 'Smiley face.'),
        ('msoShapeSnip1Rectangle', 155, 'Snip Single Corner Rectangle'),
        ('msoShapeSnip2DiagRectangle', 157,
         'Snip Diagonal Corner Rectangle'),
        ('msoShapeSnip2SameRectangle', 156,
         'Snip Same Side Corner Rectangle'),
        ('msoShapeSnipRoundRectangle', 154,
         'Snip and Round Single Corner Rectangle'),
        ('msoShapeSquareTabs', 170, 'Square Tabs'),
        ('msoShapeStripedRightArrow', 49,
         'Block arrow that points right with stripes at the tail.'),
        ('msoShapeSun', 23, 'Sun.'),
        ('msoShapeSwooshArrow', 178, 'Swoosh Arrow'),
        ('msoShapeTear', 160, 'Teardrop'),
        ('msoShapeTrapezoid', 3, 'Trapezoid'),
        ('msoShapeUTurnArrow', 42, 'Block arrow forming a U shape.'),
        ('msoShapeUpArrow', 35, 'Block arrow that points up.'),
        ('msoShapeUpArrowCallout', 55, 'Callout with arrow that points up.'),
        ('msoShapeUpDownArrow', 38, 'Block arrow that points up and down.'),
        ('msoShapeUpDownArrowCallout', 58,
         'Callout with arrows that point up and down.'),
        ('msoShapeUpRibbon', 97,
         'Ribbon banner with center area above ribbon ends.'),
        ('msoShapeVerticalScroll', 101, 'Vertical scroll.'),
        ('msoShapeWave', 103, 'Wave.')
    )


def prst_map():
    """
    Sequence of tuples representing the mapping of names in the
    msoAutoShapeType enumeration to the 'prst' and 'name' values used in the
    XML to specify and identify that auto shape type. These were discovered
    using the VBA editor in PowerPoint for Windows.

    Access with::

        for ms_name, prst, base_name in prst_map():
            ...

    """
    return (
        ('msoShape10PointStar', 'star10', '10-Point Star'),
        ('msoShape12PointStar', 'star12', '12-Point Star'),
        ('msoShape16pointStar', 'star16', '16-Point Star'),
        ('msoShape24pointStar', 'star24', '24-Point Star'),
        ('msoShape32pointStar', 'star32', '32-Point Star'),
        ('msoShape4pointStar', 'star4', '4-Point Star'),
        ('msoShape5pointStar', 'star5', '5-Point Star'),
        ('msoShape6PointStar', 'star6', '6-Point Star'),
        ('msoShape7PointStar', 'star7', '7-Point Star'),
        ('msoShape8pointStar', 'star8', '8-Point Star'),
        ('msoShapeActionButtonBackorPrevious', 'actionButtonBackPrevious',
         'Action Button: Back or Previous'),
        ('msoShapeActionButtonBeginning', 'actionButtonBeginning',
         'Action Button: Beginning'),
        ('msoShapeActionButtonCustom', 'actionButtonBlank',
         'Action Button: Custom'),
        ('msoShapeActionButtonDocument', 'actionButtonDocument',
         'Action Button: Document'),
        ('msoShapeActionButtonEnd', 'actionButtonEnd', 'Action Button: End'),
        ('msoShapeActionButtonForwardorNext', 'actionButtonForwardNext',
         'Action Button: Forward or Next'),
        ('msoShapeActionButtonHelp', 'actionButtonHelp',
         'Action Button: Help'),
        ('msoShapeActionButtonHome', 'actionButtonHome',
         'Action Button: Home'),
        ('msoShapeActionButtonInformation', 'actionButtonInformation',
         'Action Button: Information'),
        ('msoShapeActionButtonMovie', 'actionButtonMovie',
         'Action Button: Movie'),
        ('msoShapeActionButtonReturn', 'actionButtonReturn',
         'Action Button: Return'),
        ('msoShapeActionButtonSound', 'actionButtonSound',
         'Action Button: Sound'),
        ('msoShapeArc', 'arc', 'Arc'),
        ('msoShapeBalloon', 'wedgeRoundRectCallout',
         'Rounded Rectangular Callout'),
        ('msoShapeBentArrow', 'bentArrow', 'Bent Arrow'),
        ('msoShapeBentUpArrow', 'bentUpArrow', 'Bent-Up Arrow'),
        ('msoShapeBevel', 'bevel', 'Bevel'),
        ('msoShapeBlockArc', 'blockArc', 'Block Arc'),
        ('msoShapeCan', 'can', 'Can'),
        ('msoShapeChartPlus', 'chartPlus', 'Chart Plus'),
        ('msoShapeChartStar', 'chartStar', 'Chart Star'),
        ('msoShapeChartX', 'chartX', 'Chart X'),
        ('msoShapeChevron', 'chevron', 'Chevron'),
        ('msoShapeChord', 'chord', 'Chord'),
        ('msoShapeCircularArrow', 'circularArrow', 'Circular Arrow'),
        ('msoShapeCloud', 'cloud', 'Cloud'),
        ('msoShapeCloudCallout', 'cloudCallout', 'Cloud Callout'),
        ('msoShapeCorner', 'corner', 'Corner'),
        ('msoShapeCornerTabs', 'cornerTabs', 'Corner Tabs'),
        ('msoShapeCross', 'plus', 'Cross'),
        ('msoShapeCube', 'cube', 'Cube'),
        ('msoShapeCurvedDownArrow', 'curvedDownArrow', 'Curved Down Arrow'),
        ('msoShapeCurvedDownRibbon', 'ellipseRibbon', 'Curved Down Ribbon'),
        ('msoShapeCurvedLeftArrow', 'curvedLeftArrow', 'Curved Left Arrow'),
        ('msoShapeCurvedRightArrow', 'curvedRightArrow',
         'Curved Right Arrow'),
        ('msoShapeCurvedUpArrow', 'curvedUpArrow', 'Curved Up Arrow'),
        ('msoShapeCurvedUpRibbon', 'ellipseRibbon2', 'Curved Up Ribbon'),
        ('msoShapeDecagon', 'decagon', 'Decagon'),
        ('msoShapeDiagonalStripe', 'diagStripe', 'Diagonal Stripe'),
        ('msoShapeDiamond', 'diamond', 'Diamond'),
        ('msoShapeDodecagon', 'dodecagon', 'Dodecagon'),
        ('msoShapeDonut', 'donut', 'Donut'),
        ('msoShapeDoubleBrace', 'bracePair', 'Double Brace'),
        ('msoShapeDoubleBracket', 'bracketPair', 'Double Bracket'),
        ('msoShapeDoubleWave', 'doubleWave', 'Double Wave'),
        ('msoShapeDownArrow', 'downArrow', 'Down Arrow'),
        ('msoShapeDownArrowCallout', 'downArrowCallout', 'Down Arrow Callout'),
        ('msoShapeDownRibbon', 'ribbon', 'Down Ribbon'),
        ('msoShapeExplosion1', 'irregularSeal1', 'Explosion'),
        ('msoShapeExplosion2', 'irregularSeal2', 'Explosion'),
        ('msoShapeFlowchartAlternateProcess', 'flowChartAlternateProcess',
         'Alternate process'),
        ('msoShapeFlowchartCard', 'flowChartPunchedCard', 'Card'),
        ('msoShapeFlowchartCollate', 'flowChartCollate', 'Collate'),
        ('msoShapeFlowchartConnector', 'flowChartConnector', 'Connector'),
        ('msoShapeFlowchartData', 'flowChartInputOutput', 'Data'),
        ('msoShapeFlowchartDecision', 'flowChartDecision', 'Decision'),
        ('msoShapeFlowchartDelay', 'flowChartDelay', 'Delay'),
        ('msoShapeFlowchartDirectAccessStorage', 'flowChartMagneticDrum',
         'Direct Access Storage'),
        ('msoShapeFlowchartDisplay', 'flowChartDisplay', 'Display'),
        ('msoShapeFlowchartDocument', 'flowChartDocument', 'Document'),
        ('msoShapeFlowchartExtract', 'flowChartExtract', 'Extract'),
        ('msoShapeFlowchartInternalStorage', 'flowChartInternalStorage',
         'Internal Storage'),
        ('msoShapeFlowchartMagneticDisk', 'flowChartMagneticDisk',
         'Magnetic Disk'),
        ('msoShapeFlowchartManualInput', 'flowChartManualInput',
         'Manual Input'),
        ('msoShapeFlowchartManualOperation', 'flowChartManualOperation',
         'Manual Operation'),
        ('msoShapeFlowchartMerge', 'flowChartMerge', 'Merge'),
        ('msoShapeFlowchartMultidocument', 'flowChartMultidocument',
         'Multidocument'),
        ('msoShapeFlowchartOfflineStorage', 'flowChartOfflineStorage',
         'Offline Storage'),
        ('msoShapeFlowchartOffpageConnector', 'flowChartOffpageConnector',
         'Off-page Connector'),
        ('msoShapeFlowchartOr', 'flowChartOr', 'Or'),
        ('msoShapeFlowchartPredefinedProcess', 'flowChartPredefinedProcess',
         'Predefined Process'),
        ('msoShapeFlowchartPreparation', 'flowChartPreparation',
         'Preparation'),
        ('msoShapeFlowchartProcess', 'flowChartProcess', 'Process'),
        ('msoShapeFlowchartPunchedTape', 'flowChartPunchedTape',
         'Punched Tape'),
        ('msoShapeFlowchartSequentialAccessStorage',
         'flowChartMagneticTape', 'Sequential Access Storage'),
        ('msoShapeFlowchartSort', 'flowChartSort', 'Sort'),
        ('msoShapeFlowchartStoredData', 'flowChartOnlineStorage',
         'Stored Data'),
        ('msoShapeFlowchartSummingJunction', 'flowChartSummingJunction',
         'Summing Junction'),
        ('msoShapeFlowchartTerminator', 'flowChartTerminator', 'Terminator'),
        ('msoShapeFoldedCorner', 'folderCorner', 'Folded Corner'),
        ('msoShapeFrame', 'frame', 'Frame'),
        ('msoShapeFunnel', 'funnel', 'Funnel'),
        ('msoShapeGear6', 'gear6', 'Gear 6'),
        ('msoShapeGear9', 'gear9', 'Gear 9'),
        ('msoShapeHalfFrame', 'halfFrame', 'Half Frame'),
        ('msoShapeHeart', 'heart', 'Heart'),
        ('msoShapeHeptagon', 'heptagon', 'Heptagon'),
        ('msoShapeHexagon', 'hexagon', 'Hexagon'),
        ('msoShapeHorizontalScroll', 'horizontalScroll',
         'Horizontal Scroll'),
        ('msoShapeIsoscelesTriangle', 'triangle', 'Isosceles Triangle'),
        ('msoShapeLeftArrow', 'leftArrow', 'Left Arrow'),
        ('msoShapeLeftArrowCallout', 'leftArrowCallout',
         'Left Arrow Callout'),
        ('msoShapeLeftBrace', 'leftBrace', 'Left Brace'),
        ('msoShapeLeftBracket', 'leftBracket', 'Left Bracket'),
        ('msoShapeLeftCircularArrow', 'leftCircularArrow',
         'Left Circular Arrow'),
        ('msoShapeLeftRightArrow', 'leftRightArrow', 'Left-Right Arrow'),
        ('msoShapeLeftRightArrowCallout', 'leftRightArrowCallout',
         'Left-Right Arrow Callout'),
        ('msoShapeLeftRightCircularArrow', 'leftRightCircularArrow',
         'Left Right Circular Arrow'),
        ('msoShapeLeftRightRibbon', 'leftRightRibbon', 'Left Right Ribbon'),
        ('msoShapeLeftRightUpArrow', 'leftRightUpArrow',
         'Left-Right-Up Arrow'),
        ('msoShapeLeftUpArrow', 'leftUpArrow', 'Left-Up Arrow'),
        ('msoShapeLightningBolt', 'lightningBolt', 'Lightning Bolt'),
        ('msoShapeLineCallout1', 'borderCallout1', 'Line Callout 1'),
        ('msoShapeLineCallout1AccentBar', 'accentCallout1',
         'Line Callout 1 (Accent Bar)'),
        ('msoShapeLineCallout1BorderandAccentBar', 'accentBorderCallout1',
         'Line Callout 1 (Border and Accent Bar)'),
        ('msoShapeLineCallout1NoBorder', 'callout1',
         'Line Callout 1 (No Border)'),
        ('msoShapeLineCallout2', 'borderCallout2', 'Line Callout 2'),
        ('msoShapeLineCallout2AccentBar', 'accentCallout2',
         'Line Callout 2 (Accent Bar)'),
        ('msoShapeLineCallout2BorderandAccentBar', 'accentBorderCallout2',
         'Line Callout 2 (Border and Accent Bar)'),
        ('msoShapeLineCallout2NoBorder', 'callout2',
         'Line Callout 2 (No Border)'),
        ('msoShapeLineCallout3', 'borderCallout3', 'Line Callout 3'),
        ('msoShapeLineCallout3AccentBar', 'accentCallout3',
         'Line Callout 3 (Accent Bar)'),
        ('msoShapeLineCallout3BorderandAccentBar', 'accentBorderCallout3',
         'Line Callout 3 (Border and Accent Bar)'),
        ('msoShapeLineCallout3NoBorder', 'callout3',
         'Line Callout 3 (No Border)'),
        ('msoShapeLineCallout4', 'borderCallout3', 'Line Callout 3'),
        ('msoShapeLineCallout4AccentBar', 'accentCallout3',
         'Line Callout 3 (Accent Bar)'),
        ('msoShapeLineCallout4BorderandAccentBar', 'accentBorderCallout3',
         'Line Callout 3 (Border and Accent Bar)'),
        ('msoShapeLineCallout4NoBorder', 'callout3',
         'Line Callout 3 (No Border)'),
        ('msoShapeLineInverse', 'lineInv', 'Straight Connector'),
        ('msoShapeMathDivide', 'mathDivide', 'Division'),
        ('msoShapeMathEqual', 'mathEqual', 'Equal'),
        ('msoShapeMathMinus', 'mathMinus', 'Minus'),
        ('msoShapeMathMultiply', 'mathMultiply', 'Multiply'),
        ('msoShapeMathNotEqual', 'mathNotEqual', 'Not Equal'),
        ('msoShapeMathPlus', 'mathPlus', 'Plus'),
        ('msoShapeMoon', 'moon', 'Moon'),
        ('msoShapeNoSymbol', 'noSmoking', '"No" symbol'),
        ('msoShapeNonIsoscelesTrapezoid', 'nonIsoscelesTrapezoid',
         'Non-isosceles Trapezoid'),
        ('msoShapeNotchedRightArrow', 'notchedRightArrow',
         'Notched Right Arrow'),
        ('msoShapeOctagon', 'octagon', 'Octagon'),
        ('msoShapeOval', 'ellipse', 'Oval'),
        ('msoShapeOvalCallout', 'wedgeEllipseCallout', 'Oval Callout'),
        ('msoShapeParallelogram', 'parallelogram', 'Parallelogram'),
        ('msoShapePentagon', 'homePlate', 'Pentagon'),
        ('msoShapePie', 'pie', 'Pie'),
        ('msoShapePieWedge', 'pieWedge', 'Pie'),
        ('msoShapePlaque', 'plaque', 'Plaque'),
        ('msoShapePlaqueTabs', 'plaqueTabs', 'Plaque Tabs'),
        ('msoShapeQuadArrow', 'quadArrow', 'Quad Arrow'),
        ('msoShapeQuadArrowCallout', 'quadArrowCallout',
         'Quad Arrow Callout'),
        ('msoShapeRectangle', 'rect', 'Rectangle'),
        ('msoShapeRectangularCallout', 'wedgeRectCallout',
         'Rectangular Callout'),
        ('msoShapeRegularPentagon', 'pentagon', 'Regular Pentagon'),
        ('msoShapeRightArrow', 'rightArrow', 'Right Arrow'),
        ('msoShapeRightArrowCallout', 'rightArrowCallout',
         'Right Arrow Callout'),
        ('msoShapeRightBrace', 'rightBrace', 'Right Brace'),
        ('msoShapeRightBracket', 'rightBracket', 'Right Bracket'),
        ('msoShapeRightTriangle', 'rtTriangle', 'Right Triangle'),
        ('msoShapeRound1Rectangle', 'round1Rect',
         'Round Single Corner Rectangle'),
        ('msoShapeRound2DiagRectangle', 'round2DiagRect',
         'Round Diagonal Corner Rectangle'),
        ('msoShapeRound2SameRectangle', 'round2SameRect',
         'Round Same Side Corner Rectangle'),
        ('msoShapeRoundedRectangle', 'roundRect', 'Rounded Rectangle'),
        ('msoShapeRoundedRectangularCallout', 'wedgeRoundRectCallout',
         'Rounded Rectangular Callout'),
        ('msoShapeSmileyFace', 'smileyFace', 'Smiley Face'),
        ('msoShapeSnip1Rectangle', 'snip1Rect',
         'Snip Single Corner Rectangle'),
        ('msoShapeSnip2DiagRectangle', 'snip2DiagRect',
         'Snip Diagonal Corner Rectangle'),
        ('msoShapeSnip2SameRectangle', 'snip2SameRect',
         'Snip Same Side Corner Rectangle'),
        ('msoShapeSnipRoundRectangle', 'snipRoundRect',
         'Snip and Round Single Corner Rectangle'),
        ('msoShapeSquareTabs', 'squareTabs', 'Square Tabs'),
        ('msoShapeStripedRightArrow', 'stripedRightArrow',
         'Striped Right Arrow'),
        ('msoShapeSun', 'sun', 'Sun'),
        ('msoShapeSwooshArrow', 'swooshArrow', 'Swoosh Arrow'),
        ('msoShapeTear', 'teardrop', 'Teardrop'),
        ('msoShapeTrapezoid', 'trapezoid', 'Trapezoid'),
        ('msoShapeUTurnArrow', 'uturnArrow', 'U-Turn Arrow'),
        ('msoShapeUpArrow', 'upArrow', 'Up Arrow'),
        ('msoShapeUpArrowCallout', 'upArrowCallout', 'Up Arrow Callout'),
        ('msoShapeUpDownArrow', 'upDownArrow', 'Up-Down Arrow'),
        ('msoShapeUpDownArrowCallout', 'upDownArrowCallout',
         'Up-Down Arrow Callout'),
        ('msoShapeUpRibbon', 'ribbon2', 'Up Ribbon'),
        ('msoShapeVerticalScroll', 'verticalScroll', 'Vertical Scroll'),
        ('msoShapeWave', 'wave', 'Wave')
    )


def const_name_map():
    """
    Sequence of tuples representing the mapping of msoAutoShapeType
    enumeration names to the constant names used in python-pptx to identify
    an auto shape type. The mapping is largely coercing the camel case to
    upper snake case, but some names produced by that transformation require
    transformation to be suitable.

    Access with::

        for ms_name, const_name in const_name_map():
            ...

    """
    return (
        ('msoShape10PointStar', 'STAR_10_POINT'),
        ('msoShape12PointStar', 'STAR_12_POINT'),
        ('msoShape16pointStar', 'STAR_16_POINT'),
        ('msoShape24pointStar', 'STAR_24_POINT'),
        ('msoShape32pointStar', 'STAR_32_POINT'),
        ('msoShape4pointStar', 'STAR_4_POINT'),
        ('msoShape5pointStar', 'STAR_5_POINT'),
        ('msoShape6PointStar', 'STAR_6_POINT'),
        ('msoShape7PointStar', 'STAR_7_POINT'),
        ('msoShape8pointStar', 'STAR_8_POINT'),
        ('msoShapeActionButtonBackorPrevious',
         'ACTION_BUTTON_BACK_OR_PREVIOUS'),
        ('msoShapeActionButtonBeginning', 'ACTION_BUTTON_BEGINNING'),
        ('msoShapeActionButtonCustom', 'ACTION_BUTTON_CUSTOM'),
        ('msoShapeActionButtonDocument', 'ACTION_BUTTON_DOCUMENT'),
        ('msoShapeActionButtonEnd', 'ACTION_BUTTON_END'),
        ('msoShapeActionButtonForwardorNext',
         'ACTION_BUTTON_FORWARD_OR_NEXT'),
        ('msoShapeActionButtonHelp', 'ACTION_BUTTON_HELP'),
        ('msoShapeActionButtonHome', 'ACTION_BUTTON_HOME'),
        ('msoShapeActionButtonInformation', 'ACTION_BUTTON_INFORMATION'),
        ('msoShapeActionButtonMovie', 'ACTION_BUTTON_MOVIE'),
        ('msoShapeActionButtonReturn', 'ACTION_BUTTON_RETURN'),
        ('msoShapeActionButtonSound', 'ACTION_BUTTON_SOUND'),
        ('msoShapeArc', 'ARC'),
        ('msoShapeBalloon', 'BALLOON'),
        ('msoShapeBentArrow', 'BENT_ARROW'),
        ('msoShapeBentUpArrow', 'BENT_UP_ARROW'),
        ('msoShapeBevel', 'BEVEL'),
        ('msoShapeBlockArc', 'BLOCK_ARC'),
        ('msoShapeCan', 'CAN'),
        ('msoShapeChartPlus', 'CHART_PLUS'),
        ('msoShapeChartStar', 'CHART_STAR'),
        ('msoShapeChartX', 'CHART_X'),
        ('msoShapeChevron', 'CHEVRON'),
        ('msoShapeChord', 'CHORD'),
        ('msoShapeCircularArrow', 'CIRCULAR_ARROW'),
        ('msoShapeCloud', 'CLOUD'),
        ('msoShapeCloudCallout', 'CLOUD_CALLOUT'),
        ('msoShapeCorner', 'CORNER'),
        ('msoShapeCornerTabs', 'CORNER_TABS'),
        ('msoShapeCross', 'CROSS'),
        ('msoShapeCube', 'CUBE'),
        ('msoShapeCurvedDownArrow', 'CURVED_DOWN_ARROW'),
        ('msoShapeCurvedDownRibbon', 'CURVED_DOWN_RIBBON'),
        ('msoShapeCurvedLeftArrow', 'CURVED_LEFT_ARROW'),
        ('msoShapeCurvedRightArrow', 'CURVED_RIGHT_ARROW'),
        ('msoShapeCurvedUpArrow', 'CURVED_UP_ARROW'),
        ('msoShapeCurvedUpRibbon', 'CURVED_UP_RIBBON'),
        ('msoShapeDecagon', 'DECAGON'),
        ('msoShapeDiagonalStripe', 'DIAGONAL_STRIPE'),
        ('msoShapeDiamond', 'DIAMOND'),
        ('msoShapeDodecagon', 'DODECAGON'),
        ('msoShapeDonut', 'DONUT'),
        ('msoShapeDoubleBrace', 'DOUBLE_BRACE'),
        ('msoShapeDoubleBracket', 'DOUBLE_BRACKET'),
        ('msoShapeDoubleWave', 'DOUBLE_WAVE'),
        ('msoShapeDownArrow', 'DOWN_ARROW'),
        ('msoShapeDownArrowCallout', 'DOWN_ARROW_CALLOUT'),
        ('msoShapeDownRibbon', 'DOWN_RIBBON'),
        ('msoShapeExplosion1', 'EXPLOSION1'),
        ('msoShapeExplosion2', 'EXPLOSION2'),
        ('msoShapeFlowchartAlternateProcess', 'FLOWCHART_ALTERNATE_PROCESS'),
        ('msoShapeFlowchartCard', 'FLOWCHART_CARD'),
        ('msoShapeFlowchartCollate', 'FLOWCHART_COLLATE'),
        ('msoShapeFlowchartConnector', 'FLOWCHART_CONNECTOR'),
        ('msoShapeFlowchartData', 'FLOWCHART_DATA'),
        ('msoShapeFlowchartDecision', 'FLOWCHART_DECISION'),
        ('msoShapeFlowchartDelay', 'FLOWCHART_DELAY'),
        ('msoShapeFlowchartDirectAccessStorage',
         'FLOWCHART_DIRECT_ACCESS_STORAGE'),
        ('msoShapeFlowchartDisplay', 'FLOWCHART_DISPLAY'),
        ('msoShapeFlowchartDocument', 'FLOWCHART_DOCUMENT'),
        ('msoShapeFlowchartExtract', 'FLOWCHART_EXTRACT'),
        ('msoShapeFlowchartInternalStorage', 'FLOWCHART_INTERNAL_STORAGE'),
        ('msoShapeFlowchartMagneticDisk', 'FLOWCHART_MAGNETIC_DISK'),
        ('msoShapeFlowchartManualInput', 'FLOWCHART_MANUAL_INPUT'),
        ('msoShapeFlowchartManualOperation', 'FLOWCHART_MANUAL_OPERATION'),
        ('msoShapeFlowchartMerge', 'FLOWCHART_MERGE'),
        ('msoShapeFlowchartMultidocument', 'FLOWCHART_MULTIDOCUMENT'),
        ('msoShapeFlowchartOfflineStorage', 'FLOWCHART_OFFLINE_STORAGE'),
        ('msoShapeFlowchartOffpageConnector', 'FLOWCHART_OFFPAGE_CONNECTOR'),
        ('msoShapeFlowchartOr', 'FLOWCHART_OR'),
        ('msoShapeFlowchartPredefinedProcess',
         'FLOWCHART_PREDEFINED_PROCESS'),
        ('msoShapeFlowchartPreparation', 'FLOWCHART_PREPARATION'),
        ('msoShapeFlowchartProcess', 'FLOWCHART_PROCESS'),
        ('msoShapeFlowchartPunchedTape', 'FLOWCHART_PUNCHED_TAPE'),
        ('msoShapeFlowchartSequentialAccessStorage',
         'FLOWCHART_SEQUENTIAL_ACCESS_STORAGE'),
        ('msoShapeFlowchartSort', 'FLOWCHART_SORT'),
        ('msoShapeFlowchartStoredData', 'FLOWCHART_STORED_DATA'),
        ('msoShapeFlowchartSummingJunction', 'FLOWCHART_SUMMING_JUNCTION'),
        ('msoShapeFlowchartTerminator', 'FLOWCHART_TERMINATOR'),
        ('msoShapeFoldedCorner', 'FOLDED_CORNER'),
        ('msoShapeFrame', 'FRAME'),
        ('msoShapeFunnel', 'FUNNEL'),
        ('msoShapeGear6', 'GEAR_6'),
        ('msoShapeGear9', 'GEAR_9'),
        ('msoShapeHalfFrame', 'HALF_FRAME'),
        ('msoShapeHeart', 'HEART'),
        ('msoShapeHeptagon', 'HEPTAGON'),
        ('msoShapeHexagon', 'HEXAGON'),
        ('msoShapeHorizontalScroll', 'HORIZONTAL_SCROLL'),
        ('msoShapeIsoscelesTriangle', 'ISOSCELES_TRIANGLE'),
        ('msoShapeLeftArrow', 'LEFT_ARROW'),
        ('msoShapeLeftArrowCallout', 'LEFT_ARROW_CALLOUT'),
        ('msoShapeLeftBrace', 'LEFT_BRACE'),
        ('msoShapeLeftBracket', 'LEFT_BRACKET'),
        ('msoShapeLeftCircularArrow', 'LEFT_CIRCULAR_ARROW'),
        ('msoShapeLeftRightArrow', 'LEFT_RIGHT_ARROW'),
        ('msoShapeLeftRightArrowCallout', 'LEFT_RIGHT_ARROW_CALLOUT'),
        ('msoShapeLeftRightCircularArrow', 'LEFT_RIGHT_CIRCULAR_ARROW'),
        ('msoShapeLeftRightRibbon', 'LEFT_RIGHT_RIBBON'),
        ('msoShapeLeftRightUpArrow', 'LEFT_RIGHT_UP_ARROW'),
        ('msoShapeLeftUpArrow', 'LEFT_UP_ARROW'),
        ('msoShapeLightningBolt', 'LIGHTNING_BOLT'),
        ('msoShapeLineCallout1', 'LINE_CALLOUT_1'),
        ('msoShapeLineCallout1AccentBar', 'LINE_CALLOUT_1_ACCENT_BAR'),
        ('msoShapeLineCallout1BorderandAccentBar',
         'LINE_CALLOUT_1_BORDER_AND_ACCENT_BAR'),
        ('msoShapeLineCallout1NoBorder', 'LINE_CALLOUT_1_NO_BORDER'),
        ('msoShapeLineCallout2', 'LINE_CALLOUT_2'),
        ('msoShapeLineCallout2AccentBar', 'LINE_CALLOUT_2_ACCENT_BAR'),
        ('msoShapeLineCallout2BorderandAccentBar',
         'LINE_CALLOUT_2_BORDER_AND_ACCENT_BAR'),
        ('msoShapeLineCallout2NoBorder', 'LINE_CALLOUT_2_NO_BORDER'),
        ('msoShapeLineCallout3', 'LINE_CALLOUT_3'),
        ('msoShapeLineCallout3AccentBar', 'LINE_CALLOUT_3_ACCENT_BAR'),
        ('msoShapeLineCallout3BorderandAccentBar',
         'LINE_CALLOUT_3_BORDER_AND_ACCENT_BAR'),
        ('msoShapeLineCallout3NoBorder', 'LINE_CALLOUT_3_NO_BORDER'),
        ('msoShapeLineCallout4', 'LINE_CALLOUT_4'),
        ('msoShapeLineCallout4AccentBar', 'LINE_CALLOUT_4_ACCENT_BAR'),
        ('msoShapeLineCallout4BorderandAccentBar',
         'LINE_CALLOUT_4_BORDER_AND_ACCENT_BAR'),
        ('msoShapeLineCallout4NoBorder', 'LINE_CALLOUT_4_NO_BORDER'),
        ('msoShapeLineInverse', 'LINE_INVERSE'),
        ('msoShapeMathDivide', 'MATH_DIVIDE'),
        ('msoShapeMathEqual', 'MATH_EQUAL'),
        ('msoShapeMathMinus', 'MATH_MINUS'),
        ('msoShapeMathMultiply', 'MATH_MULTIPLY'),
        ('msoShapeMathNotEqual', 'MATH_NOT_EQUAL'),
        ('msoShapeMathPlus', 'MATH_PLUS'),
        ('msoShapeMoon', 'MOON'),
        ('msoShapeNoSymbol', 'NO_SYMBOL'),
        ('msoShapeNonIsoscelesTrapezoid', 'NON_ISOSCELES_TRAPEZOID'),
        ('msoShapeNotchedRightArrow', 'NOTCHED_RIGHT_ARROW'),
        ('msoShapeOctagon', 'OCTAGON'),
        ('msoShapeOval', 'OVAL'),
        ('msoShapeOvalCallout', 'OVAL_CALLOUT'),
        ('msoShapeParallelogram', 'PARALLELOGRAM'),
        ('msoShapePentagon', 'PENTAGON'),
        ('msoShapePie', 'PIE'),
        ('msoShapePieWedge', 'PIE_WEDGE'),
        ('msoShapePlaque', 'PLAQUE'),
        ('msoShapePlaqueTabs', 'PLAQUE_TABS'),
        ('msoShapeQuadArrow', 'QUAD_ARROW'),
        ('msoShapeQuadArrowCallout', 'QUAD_ARROW_CALLOUT'),
        ('msoShapeRectangle', 'RECTANGLE'),
        ('msoShapeRectangularCallout', 'RECTANGULAR_CALLOUT'),
        ('msoShapeRegularPentagon', 'REGULAR_PENTAGON'),
        ('msoShapeRightArrow', 'RIGHT_ARROW'),
        ('msoShapeRightArrowCallout', 'RIGHT_ARROW_CALLOUT'),
        ('msoShapeRightBrace', 'RIGHT_BRACE'),
        ('msoShapeRightBracket', 'RIGHT_BRACKET'),
        ('msoShapeRightTriangle', 'RIGHT_TRIANGLE'),
        ('msoShapeRound1Rectangle', 'ROUND_1_RECTANGLE'),
        ('msoShapeRound2DiagRectangle', 'ROUND_2_DIAG_RECTANGLE'),
        ('msoShapeRound2SameRectangle', 'ROUND_2_SAME_RECTANGLE'),
        ('msoShapeRoundedRectangle', 'ROUNDED_RECTANGLE'),
        ('msoShapeRoundedRectangularCallout', 'ROUNDED_RECTANGULAR_CALLOUT'),
        ('msoShapeSmileyFace', 'SMILEY_FACE'),
        ('msoShapeSnip1Rectangle', 'SNIP_1_RECTANGLE'),
        ('msoShapeSnip2DiagRectangle', 'SNIP_2_DIAG_RECTANGLE'),
        ('msoShapeSnip2SameRectangle', 'SNIP_2_SAME_RECTANGLE'),
        ('msoShapeSnipRoundRectangle', 'SNIP_ROUND_RECTANGLE'),
        ('msoShapeSquareTabs', 'SQUARE_TABS'),
        ('msoShapeStripedRightArrow', 'STRIPED_RIGHT_ARROW'),
        ('msoShapeSun', 'SUN'),
        ('msoShapeSwooshArrow', 'SWOOSH_ARROW'),
        ('msoShapeTear', 'TEAR'),
        ('msoShapeTrapezoid', 'TRAPEZOID'),
        ('msoShapeUTurnArrow', 'U_TURN_ARROW'),
        ('msoShapeUpArrow', 'UP_ARROW'),
        ('msoShapeUpArrowCallout', 'UP_ARROW_CALLOUT'),
        ('msoShapeUpDownArrow', 'UP_DOWN_ARROW'),
        ('msoShapeUpDownArrowCallout', 'UP_DOWN_ARROW_CALLOUT'),
        ('msoShapeUpRibbon', 'UP_RIBBON'),
        ('msoShapeVerticalScroll', 'VERTICAL_SCROLL'),
        ('msoShapeWave', 'WAVE')
    )

########NEW FILE########
__FILENAME__ = scratch
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# scratch.py
#
# utility code to generate one-time text runs from spec.db

import sqlite3


# establish database connection ------------------------
conn = sqlite3.connect('../spec.db')
c = conn.cursor()

# # retrieve ms_name to const_name mapping in prst order -
# c.execute(
#     '  SELECT ms_name, const_name\n'
#     '    FROM auto_shape_types\n'
#     'ORDER BY ms_name'
# )
# lines = []
# for ms_name, const_name in c:
#     lines.append("    ('%s', '%s')" % (ms_name, const_name))
# const_name_list_str = ',\n'.join(lines)

# out = 'const_name_map = (\n%s\n)' % const_name_list_str

# retrieve ms_name to PresentationML mappings --------------
c.execute(
    '  SELECT ms_name, prst, base_name\n'
    '    FROM auto_shape_types\n'
    'ORDER BY ms_name'
)
lines = []
for ms_name, prst, base_name in c:
    lines.append("        ('%s', '%s', '%s')" % (ms_name, prst, base_name))
pml_list_str = ',\n'.join(lines)

out = 'def pml_map():\n    return (\n%s\n    )' % pml_list_str

# tear down database connection ------------------------
conn.commit()
conn.close()

print out

########NEW FILE########
__FILENAME__ = test_color
# encoding: utf-8

"""
Test suite for pptx.text module.
"""

from __future__ import absolute_import

import pytest

from pptx.dml.color import ColorFormat, RGBColor
from pptx.enum.dml import MSO_COLOR_TYPE, MSO_THEME_COLOR

from ..oxml.unitdata.dml import (
    a_lumMod, a_lumOff, a_prstClr, a_schemeClr, a_solidFill, a_sysClr,
    an_hslClr, an_scrgbClr, an_srgbClr
)
from ..unitutil import actual_xml


class DescribeColorFormat(object):

    def it_knows_the_type_of_its_color(self, color_type_fixture_):
        color_format, color_type = color_type_fixture_
        assert color_format.type == color_type

    def it_knows_the_RGB_value_of_an_RGB_color(self, rgb_color_format):
        color_format = rgb_color_format
        assert color_format.rgb == RGBColor(0x12, 0x34, 0x56)

    def it_raises_on_rgb_get_for_colors_other_than_rgb(
            self, rgb_raise_fixture_):
        color_format, exception_type = rgb_raise_fixture_
        with pytest.raises(exception_type):
            color_format.rgb

    def it_knows_the_theme_color_of_a_theme_color(
            self, get_theme_color_fixture_):
        color_format, theme_color = get_theme_color_fixture_
        assert color_format.theme_color == theme_color

    def it_raises_on_theme_color_get_for_NoneColor(
            self, _NoneColor_color_format):
        with pytest.raises(AttributeError):
            _NoneColor_color_format.theme_color

    def it_knows_its_brightness_adjustment(
            self, color_format_with_brightness):
        color_format, expected_brightness = color_format_with_brightness
        assert color_format.brightness == expected_brightness

    def it_can_set_itself_to_an_RGB_color(self, set_rgb_fixture_):
        color_format, rgb_color, expected_xml = set_rgb_fixture_
        color_format.rgb = rgb_color
        assert actual_xml(color_format._xFill) == expected_xml

    def it_raises_on_assign_non_RGBColor_type_to_rgb(self, rgb_color_format):
        color_format = rgb_color_format
        with pytest.raises(ValueError):
            color_format.rgb = (0x12, 0x34, 0x56)

    def it_can_set_itself_to_a_theme_color(self, set_theme_color_fixture_):
        color_format, theme_color, expected_xml = set_theme_color_fixture_
        color_format.theme_color = theme_color
        assert actual_xml(color_format._xFill) == expected_xml

    def it_can_set_its_brightness_adjustment(self, set_brightness_fixture_):
        color_format, brightness, expected_xml = set_brightness_fixture_
        color_format.brightness = brightness
        assert actual_xml(color_format._xFill) == expected_xml

    def it_raises_on_attempt_to_set_brightness_out_of_range(
            self, rgb_color_format):
        with pytest.raises(ValueError):
            rgb_color_format.brightness = 1.1
        with pytest.raises(ValueError):
            rgb_color_format.brightness = -1.1

    def it_raises_on_attempt_to_set_brightness_on_None_color_type(
            self, color_format_having_none_color_type):
        color_format = color_format_having_none_color_type
        with pytest.raises(ValueError):
            color_format.brightness = 0.5

    # fixtures ---------------------------------------------

    @pytest.fixture
    def color_format_having_none_color_type(self):
        solidFill = a_solidFill().with_nsdecls().element
        color_format = ColorFormat.from_colorchoice_parent(solidFill)
        return color_format

    @pytest.fixture(params=['hsl', 'prst', 'scheme', 'scrgb', 'srgb', 'sys'])
    def color_format_with_brightness(self, request):
        mapping = {
            'hsl':    (an_hslClr,   55000, 45000,  0.45),
            'prst':   (a_prstClr,   None,  None,   0.0),
            'scheme': (a_schemeClr, 15000, None,  -0.85),
            'scrgb':  (an_scrgbClr, 15000, 85000,  0.85),
            'srgb':   (an_srgbClr,  None,  None,   0.0),
            'sys':    (a_sysClr,    23000, None,  -0.77),
        }
        xClr_bldr_fn, lumMod, lumOff, exp_brightness = mapping[request.param]
        xClr_bldr = xClr_bldr_fn()
        if lumMod is not None:
            xClr_bldr.with_child(a_lumMod().with_val(lumMod))
        if lumOff is not None:
            xClr_bldr.with_child(a_lumOff().with_val(lumOff))
        solidFill = (
            a_solidFill().with_nsdecls()
                         .with_child(xClr_bldr)
                         .element
        )
        color_format = ColorFormat.from_colorchoice_parent(solidFill)
        return color_format, exp_brightness

    @pytest.fixture(params=[
        'none', 'hsl', 'prst', 'scheme', 'scrgb', 'srgb', 'sys'
    ])
    def color_type_fixture_(self, request):
        mapping = {
            'none':   (None,        None),
            'hsl':    (an_hslClr,   MSO_COLOR_TYPE.HSL),
            'prst':   (a_prstClr,   MSO_COLOR_TYPE.PRESET),
            'srgb':   (an_srgbClr,  MSO_COLOR_TYPE.RGB),
            'scheme': (a_schemeClr, MSO_COLOR_TYPE.SCHEME),
            'scrgb':  (an_scrgbClr, MSO_COLOR_TYPE.SCRGB),
            'sys':    (a_sysClr,    MSO_COLOR_TYPE.SYSTEM),
        }
        xClr_bldr_fn, color_type = mapping[request.param]
        solidFill_bldr = a_solidFill().with_nsdecls()
        if xClr_bldr_fn is not None:
            solidFill_bldr.with_child(xClr_bldr_fn())
        solidFill = solidFill_bldr.element
        color_format = ColorFormat.from_colorchoice_parent(solidFill)
        return color_format, color_type

    @pytest.fixture
    def _NoneColor_color_format(self):
        solidFill = a_solidFill().with_nsdecls().element
        color_format = ColorFormat.from_colorchoice_parent(solidFill)
        return color_format

    @pytest.fixture
    def rgb_color_format(self):
        srgbClr_bldr = an_srgbClr().with_val('123456')
        solidFill = (
            a_solidFill().with_nsdecls().with_child(srgbClr_bldr).element
        )
        color_format = ColorFormat.from_colorchoice_parent(solidFill)
        return color_format

    @pytest.fixture(params=['none', 'hsl', 'prst', 'scheme', 'scrgb', 'sys'])
    def rgb_raise_fixture_(self, request):
        mapping = {
            'none':   (None,        AttributeError),
            'hsl':    (an_hslClr,   AttributeError),
            'prst':   (a_prstClr,   AttributeError),
            'scheme': (a_schemeClr, AttributeError),
            'scrgb':  (an_scrgbClr, AttributeError),
            'sys':    (a_sysClr,    AttributeError),
        }
        xClr_bldr_fn, exception_type = mapping[request.param]
        solidFill_bldr = a_solidFill().with_nsdecls()
        if xClr_bldr_fn is not None:
            solidFill_bldr.with_child(xClr_bldr_fn())
        solidFill = solidFill_bldr.element
        color_format = ColorFormat.from_colorchoice_parent(solidFill)
        return color_format, exception_type

    @pytest.fixture(params=[
        '0 to 0', '0 to -0.4', '0.15 to 0.25', '0.15 to -0.15',
        '-0.25 to 0.4', '-0.3 to -0.4', '-0.4 to 0'
    ])
    def set_brightness_fixture_(self, request):
        mapping = {
            '0 to 0':        (an_srgbClr,  None,  None,   0,    None,  None),
            '0 to -0.4':     (an_hslClr,   None,  None,  -0.4,  60000, None),
            '0.15 to 0.25':  (a_prstClr,   85000, 15000,  0.25, 75000, 25000),
            '0.15 to -0.15': (a_schemeClr, 85000, 15000, -0.15, 85000, None),
            '-0.25 to 0.4':  (an_scrgbClr, 75000, None,   0.4,  60000, 40000),
            '-0.3 to -0.4':  (an_srgbClr,  70000, None,  -0.4,  60000, None),
            '-0.4 to 0':     (a_sysClr,    60000, None,   0,    None,  None),
        }
        xClr_bldr_fn, mod_in, off_in, brightness, mod_out, off_out = (
            mapping[request.param]
        )

        xClr_bldr = xClr_bldr_fn()
        if mod_in is not None:
            xClr_bldr.with_child(a_lumMod().with_val(mod_in))
        if off_in is not None:
            xClr_bldr.with_child(a_lumOff().with_val(off_in))
        solidFill = (
            a_solidFill().with_nsdecls().with_child(xClr_bldr).element
        )
        color_format = ColorFormat.from_colorchoice_parent(solidFill)

        xClr_bldr = xClr_bldr_fn()
        if mod_out is not None:
            xClr_bldr.with_child(a_lumMod().with_val(mod_out))
        if off_out is not None:
            xClr_bldr.with_child(a_lumOff().with_val(off_out))
        expected_xml = (
            a_solidFill().with_nsdecls().with_child(xClr_bldr).xml()
        )

        return color_format, brightness, expected_xml

    @pytest.fixture(params=[
        'none', 'hsl', 'prst', 'scheme', 'scrgb', 'srgb', 'sys'
    ])
    def set_rgb_fixture_(self, request):
        mapping = {
            'none':   None,
            'hsl':    an_hslClr,
            'prst':   a_prstClr,
            'scheme': a_schemeClr,
            'scrgb':  an_scrgbClr,
            'srgb':   an_srgbClr,
            'sys':    a_sysClr,
        }
        xClr_bldr_fn = mapping[request.param]
        solidFill_bldr = a_solidFill().with_nsdecls()
        if xClr_bldr_fn is not None:
            solidFill_bldr.with_child(xClr_bldr_fn())
        solidFill = solidFill_bldr.element
        color_format = ColorFormat.from_colorchoice_parent(solidFill)
        rgb_color = RGBColor(0x12, 0x34, 0x56)
        expected_xml = (
            a_solidFill()
            .with_nsdecls()
            .with_child(an_srgbClr().with_val('123456'))
            .xml()
        )
        return color_format, rgb_color, expected_xml

    @pytest.fixture(params=[
        'none', 'hsl', 'prst', 'scheme', 'scrgb', 'srgb', 'sys'
    ])
    def set_theme_color_fixture_(self, request):
        mapping = {
            'none':   None,
            'hsl':    an_hslClr,
            'prst':   a_prstClr,
            'scheme': a_schemeClr,
            'scrgb':  an_scrgbClr,
            'srgb':   an_srgbClr,
            'sys':    a_sysClr,
        }
        xClr_bldr_fn = mapping[request.param]
        solidFill_bldr = a_solidFill().with_nsdecls()
        if xClr_bldr_fn is not None:
            solidFill_bldr.with_child(xClr_bldr_fn())
        solidFill = solidFill_bldr.element
        color_format = ColorFormat.from_colorchoice_parent(solidFill)
        theme_color = MSO_THEME_COLOR.ACCENT_6
        expected_xml = (
            a_solidFill()
            .with_nsdecls()
            .with_child(a_schemeClr().with_val('accent6'))
            .xml()
        )
        return color_format, theme_color, expected_xml

    @pytest.fixture(params=['hsl', 'prst', 'scheme', 'scrgb', 'srgb', 'sys'])
    def get_theme_color_fixture_(self, request):
        mapping = {
            'hsl':    (an_hslClr,   MSO_THEME_COLOR.NOT_THEME_COLOR),
            'prst':   (a_prstClr,   MSO_THEME_COLOR.NOT_THEME_COLOR),
            'scheme': (a_schemeClr, MSO_THEME_COLOR.ACCENT_1),
            'scrgb':  (an_scrgbClr, MSO_THEME_COLOR.NOT_THEME_COLOR),
            'srgb':   (an_srgbClr,  MSO_THEME_COLOR.NOT_THEME_COLOR),
            'sys':    (a_sysClr,    MSO_THEME_COLOR.NOT_THEME_COLOR),
        }
        xClr_bldr_fn, theme_color = mapping[request.param]
        xClr_bldr = xClr_bldr_fn()
        if theme_color != MSO_THEME_COLOR.NOT_THEME_COLOR:
            xClr_bldr.with_val('accent1')
        solidFill = (
            a_solidFill().with_nsdecls()
                         .with_child(xClr_bldr)
                         .element
        )
        color_format = ColorFormat.from_colorchoice_parent(solidFill)
        return color_format, theme_color


class DescribeRGBColor(object):

    def it_is_natively_constructed_using_three_ints_0_to_255(self):
        RGBColor(0x12, 0x34, 0x56)
        with pytest.raises(ValueError):
            RGBColor('12', '34', '56')
        with pytest.raises(ValueError):
            RGBColor(-1, 34, 56)
        with pytest.raises(ValueError):
            RGBColor(12, 256, 56)

    def it_can_construct_from_a_hex_string_rgb_value(self):
        rgb = RGBColor.from_string('123456')
        assert rgb == RGBColor(0x12, 0x34, 0x56)

    def it_can_provide_a_hex_string_rgb_value(self):
        assert str(RGBColor(0x12, 0x34, 0x56)) == '123456'

########NEW FILE########
__FILENAME__ = test_fill
# encoding: utf-8

"""
Test suite for pptx.dml.fill module
"""

from __future__ import absolute_import

import pytest

from pptx.dml.color import ColorFormat
from pptx.dml.fill import FillFormat
from pptx.enum.dml import MSO_FILL

from ..oxml.unitdata.dml import (
    a_blipFill, a_gradFill, a_grpFill, a_noFill, a_pattFill, a_solidFill,
    an_spPr
)
from ..oxml.unitdata.table import a_tcPr
from ..oxml.unitdata.text import an_rPr
from ..unitutil import actual_xml


class DescribeFillFormat(object):

    def it_can_set_the_fill_type_to_no_fill(self, set_noFill_fixture_):
        fill_format, xPr_with_noFill_xml = set_noFill_fixture_
        fill_format.background()
        assert actual_xml(fill_format._xPr) == xPr_with_noFill_xml

    def it_can_set_the_fill_type_to_solid(self, set_solid_fixture_):
        fill_format, xPr_with_solidFill_xml = set_solid_fixture_
        fill_format.solid()
        assert actual_xml(fill_format._xPr) == xPr_with_solidFill_xml

    def it_knows_the_type_of_fill_it_is(self, fill_type_fixture_):
        fill_format, fill_type = fill_type_fixture_
        assert fill_format.type == fill_type

    def it_provides_access_to_the_foreground_color_object(
            self, fore_color_fixture_):
        fill_format, fore_color_type = fore_color_fixture_
        assert isinstance(fill_format.fore_color, fore_color_type)

    def it_raises_on_fore_color_get_for_fill_types_that_dont_have_one(
            self, fore_color_raise_fixture_):
        fill_format, exception_type = fore_color_raise_fixture_
        with pytest.raises(exception_type):
            fill_format.fore_color

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        'none', 'blip', 'grad', 'grp', 'no', 'patt', 'solid'
    ])
    def fill_type_fixture_(self, request, xPr_bldr):
        mapping = {
            'none':  None,
            'blip':  MSO_FILL.PICTURE,
            'grad':  MSO_FILL.GRADIENT,
            'grp':   MSO_FILL.GROUP,
            'no':    MSO_FILL.BACKGROUND,
            'patt':  MSO_FILL.PATTERNED,
            'solid': MSO_FILL.SOLID,
        }
        fill_type_str = request.param
        fill_type = mapping[fill_type_str]
        xFill_bldr = self._xFill_bldr(fill_type_str)
        if xFill_bldr is not None:
            xPr_bldr.with_child(xFill_bldr)
        xPr = xPr_bldr.element
        fill_format = FillFormat.from_fill_parent(xPr)
        return fill_format, fill_type

    @pytest.fixture(params=['solid'])
    def fore_color_fixture_(self, request, xPr_bldr):
        mapping = {
            'solid': ColorFormat,
        }
        fill_type_str = request.param
        fore_color_type = mapping[fill_type_str]
        xFill_bldr = self._xFill_bldr(fill_type_str)
        if xFill_bldr is not None:
            xPr_bldr.with_child(xFill_bldr)
        xPr = xPr_bldr.element
        fill_format = FillFormat.from_fill_parent(xPr)
        return fill_format, fore_color_type

    @pytest.fixture(params=['none', 'blip', 'grad', 'grp', 'no', 'patt'])
    def fore_color_raise_fixture_(self, request, xPr_bldr):
        mapping = {
            'none':  TypeError,
            'blip':  TypeError,
            'grad':  NotImplementedError,
            'grp':   TypeError,
            'no':    TypeError,
            'patt':  NotImplementedError,
        }
        fill_type_str = request.param
        exception_type = mapping[fill_type_str]
        xFill_bldr = self._xFill_bldr(fill_type_str)
        if xFill_bldr is not None:
            xPr_bldr.with_child(xFill_bldr)
        xPr = xPr_bldr.element
        fill_format = FillFormat.from_fill_parent(xPr)
        return fill_format, exception_type

    @pytest.fixture(
        params=['none', 'blip', 'grad', 'grp', 'no', 'patt', 'solid']
    )
    def set_noFill_fixture_(self, request, xPr_bldr):
        fill_type_str = request.param
        xFill_bldr = self._xFill_bldr(fill_type_str)
        if xFill_bldr is not None:
            xPr_bldr.with_child(xFill_bldr)
        xPr = xPr_bldr.element
        fill_format = FillFormat.from_fill_parent(xPr)
        xPr_with_noFill_xml = (
            xPr_bldr.clear()
                    .with_nsdecls()
                    .with_child(a_noFill())
                    .xml()
        )
        return fill_format, xPr_with_noFill_xml

    @pytest.fixture(
        params=['none', 'blip', 'grad', 'grp', 'no', 'patt', 'solid']
    )
    def set_solid_fixture_(self, request, xPr_bldr):
        fill_type_str = request.param
        xFill_bldr = self._xFill_bldr(fill_type_str)
        if xFill_bldr is not None:
            xPr_bldr.with_child(xFill_bldr)
        xPr = xPr_bldr.element
        fill_format = FillFormat.from_fill_parent(xPr)
        xPr_with_solidFill_xml = (
            xPr_bldr.clear()
                    .with_nsdecls()
                    .with_child(a_solidFill())
                    .xml()
        )
        return fill_format, xPr_with_solidFill_xml

    # fixture components ---------------------------------------------

    @pytest.fixture(params=['rPr', 'spPr', 'tcPr'])
    def xPr_bldr(self, request):
        mapping = {
            'rPr':  an_rPr,
            'spPr': an_spPr,
            'tcPr': a_tcPr,
        }
        xPr_bldr_fn = mapping[request.param]
        return xPr_bldr_fn().with_nsdecls()

    def _xFill_bldr(self, fill_type_str):
        mapping = {
            'none':  None,
            'blip':  a_blipFill,
            'grad':  a_gradFill,
            'grp':   a_grpFill,
            'no':    a_noFill,
            'solid': a_solidFill,
            'patt':  a_pattFill,
        }
        xFill_bldr_fn = mapping[fill_type_str]
        if xFill_bldr_fn is None:
            return None
        return xFill_bldr_fn()

########NEW FILE########
__FILENAME__ = test_line
# encoding: utf-8

"""
Test suite for pptx.dml.line module
"""

from __future__ import absolute_import, print_function, unicode_literals

import pytest

from pptx.dml.color import ColorFormat
from pptx.dml.fill import FillFormat
from pptx.dml.line import LineFormat
from pptx.enum.dml import MSO_FILL
from pptx.oxml.shapes.shared import CT_LineProperties
from pptx.shapes.autoshape import Shape

from ..oxml.unitdata.dml import an_ln
from ..unitutil import call, class_mock, instance_mock, property_mock


class DescribeLineFormat(object):

    def it_knows_the_line_width(self, width_get_fixture):
        line, expected_line_width = width_get_fixture
        assert line.width == expected_line_width

    def it_can_change_its_width(self, width_set_fixture):
        line, width, expected_xml = width_set_fixture
        line.width = width
        assert line._ln.xml == expected_xml

    def it_has_a_fill(self, fill_fixture):
        line, FillFormat_, ln_, fill_ = fill_fixture
        fill = line.fill
        FillFormat_.from_fill_parent.assert_called_once_with(ln_)
        assert fill is fill_

    def it_has_a_color(self, color_fixture):
        line, fill_, expected_solid_calls, color_ = color_fixture
        color = line.color
        assert fill_.solid.mock_calls == expected_solid_calls
        assert color is color_

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        (MSO_FILL.SOLID,      False),
        (MSO_FILL.BACKGROUND, True),
        (None,                True),
    ])
    def color_fixture(self, request, line, fill_prop_, fill_, color_):
        pre_call_fill_type, solid_call_expected = request.param
        fill_.type = pre_call_fill_type
        expected_solid_calls = [call()] if solid_call_expected else []
        return line, fill_, expected_solid_calls, color_

    @pytest.fixture
    def fill_fixture(self, line, FillFormat_, ln_, fill_):
        return line, FillFormat_, ln_, fill_

    @pytest.fixture(params=[None, 12700])
    def width_get_fixture(self, request, shape_):
        w = expected_line_width = request.param
        shape_.ln = self.ln_bldr(w).element
        line = LineFormat(shape_)
        return line, expected_line_width

    @pytest.fixture(params=[
        (None, None), (None, 12700), (12700, 12700), (12700, 25400),
        (25400, None),
    ])
    def width_set_fixture(self, request, shape_):
        initial_width, width = request.param
        shape_.ln = shape_.get_or_add_ln.return_value = (
            self.ln_bldr(initial_width).element
        )
        line = LineFormat(shape_)
        expected_xml = self.ln_bldr(width).xml()
        return line, width, expected_xml

    # fixture components ---------------------------------------------

    @pytest.fixture
    def color_(self, request):
        return instance_mock(request, ColorFormat)

    @pytest.fixture
    def fill_(self, request, color_):
        return instance_mock(request, FillFormat, fore_color=color_)

    @pytest.fixture
    def fill_prop_(self, request, fill_):
        return property_mock(request, LineFormat, 'fill', return_value=fill_)

    @pytest.fixture
    def FillFormat_(self, request, fill_):
        FillFormat_ = class_mock(request, 'pptx.dml.line.FillFormat')
        FillFormat_.from_fill_parent.return_value = fill_
        return FillFormat_

    @pytest.fixture
    def line(self, shape_):
        return LineFormat(shape_)

    @pytest.fixture
    def ln_(self, request):
        return instance_mock(request, CT_LineProperties)

    def ln_bldr(self, w):
        ln_bldr = an_ln().with_nsdecls()
        if w is not None:
            ln_bldr.with_w(w)
        return ln_bldr

    @pytest.fixture
    def shape_(self, request, ln_):
        shape_ = instance_mock(request, Shape)
        shape_.get_or_add_ln.return_value = ln_
        return shape_

########NEW FILE########
__FILENAME__ = test_oxml
# encoding: utf-8

"""
Test suite for opc.oxml module
"""

from pptx.opc.constants import RELATIONSHIP_TARGET_MODE as RTM
from pptx.opc.oxml import (
    CT_Default, CT_Override, CT_Relationship, CT_Relationships, CT_Types,
    oxml_tostring
)

from .unitdata.rels import (
    a_Default, an_Override, a_Relationship, a_Relationships, a_Types
)


class DescribeCT_Default(object):

    def it_provides_read_access_to_xml_values(self):
        default = a_Default().element
        assert default.extension == 'xml'
        assert default.content_type == 'application/xml'

    def it_can_construct_a_new_default_element(self):
        default = CT_Default.new('xml', 'application/xml')
        expected_xml = a_Default().xml
        assert default.xml == expected_xml


class DescribeCT_Override(object):

    def it_provides_read_access_to_xml_values(self):
        override = an_Override().element
        assert override.partname == '/part/name.xml'
        assert override.content_type == 'app/vnd.type'

    def it_can_construct_a_new_override_element(self):
        override = CT_Override.new('/part/name.xml', 'app/vnd.type')
        expected_xml = an_Override().xml
        assert override.xml == expected_xml


class DescribeCT_Relationship(object):

    def it_provides_read_access_to_xml_values(self):
        rel = a_Relationship().element
        assert rel.rId == 'rId9'
        assert rel.reltype == 'ReLtYpE'
        assert rel.target_ref == 'docProps/core.xml'
        assert rel.target_mode == RTM.INTERNAL

    def it_can_construct_from_attribute_values(self):
        cases = (
            ('rId9', 'ReLtYpE', 'foo/bar.xml',      None),
            ('rId9', 'ReLtYpE', 'bar/foo.xml',      RTM.INTERNAL),
            ('rId9', 'ReLtYpE', 'http://some/link', RTM.EXTERNAL),
        )
        for rId, reltype, target, target_mode in cases:
            if target_mode is None:
                rel = CT_Relationship.new(rId, reltype, target)
            else:
                rel = CT_Relationship.new(rId, reltype, target, target_mode)
            builder = a_Relationship().with_target(target)
            if target_mode == RTM.EXTERNAL:
                builder = builder.with_target_mode(RTM.EXTERNAL)
            expected_rel_xml = builder.xml
            assert rel.xml == expected_rel_xml


class DescribeCT_Relationships(object):

    def it_can_construct_a_new_relationships_element(self):
        rels = CT_Relationships.new()
        actual_xml = oxml_tostring(rels, encoding='unicode',
                                   pretty_print=True)
        expected_xml = (
            '<Relationships xmlns="http://schemas.openxmlformats.org/package'
            '/2006/relationships"/>\n'
        )
        assert actual_xml == expected_xml

    def it_can_build_rels_element_incrementally(self):
        # setup ------------------------
        rels = CT_Relationships.new()
        # exercise ---------------------
        rels.add_rel('rId1', 'http://reltype1', 'docProps/core.xml')
        rels.add_rel('rId2', 'http://linktype', 'http://some/link', True)
        rels.add_rel('rId3', 'http://reltype2', '../slides/slide1.xml')
        # verify -----------------------
        expected_rels_xml = a_Relationships().xml
        actual_xml = oxml_tostring(rels, encoding='unicode',
                                   pretty_print=True)
        assert actual_xml == expected_rels_xml

    def it_can_generate_rels_file_xml(self):
        expected_xml = (
            '<?xml version=\'1.0\' encoding=\'UTF-8\' standalone=\'yes\'?>\n'
            '<Relationships xmlns="http://schemas.openxmlformats.org/package'
            '/2006/relationships"/>'.encode('utf-8')
        )
        assert CT_Relationships.new().xml == expected_xml


class DescribeCT_Types(object):

    def it_provides_access_to_default_child_elements(self):
        types = a_Types().element
        assert len(types.defaults) == 2
        for default in types.defaults:
            assert isinstance(default, CT_Default)

    def it_provides_access_to_override_child_elements(self):
        types = a_Types().element
        assert len(types.overrides) == 3
        for override in types.overrides:
            assert isinstance(override, CT_Override)

    def it_should_have_empty_list_on_no_matching_elements(self):
        types = a_Types().empty().element
        assert types.defaults == []
        assert types.overrides == []

    def it_can_construct_a_new_types_element(self):
        types = CT_Types.new()
        expected_xml = a_Types().empty().xml
        assert types.xml == expected_xml

    def it_can_build_types_element_incrementally(self):
        types = CT_Types.new()
        types.add_default('xml', 'application/xml')
        types.add_default('jpeg', 'image/jpeg')
        types.add_override('/docProps/core.xml', 'app/vnd.type1')
        types.add_override('/ppt/presentation.xml', 'app/vnd.type2')
        types.add_override('/docProps/thumbnail.jpeg', 'image/jpeg')
        expected_types_xml = a_Types().xml
        assert types.xml == expected_types_xml

########NEW FILE########
__FILENAME__ = test_package
# encoding: utf-8

"""
Test suite for pptx.opc.package module
"""

from __future__ import absolute_import

import pytest

from mock import call, Mock, patch, PropertyMock

from pptx.opc.oxml import CT_Relationships
from pptx.opc.packuri import PACKAGE_URI, PackURI
from pptx.opc.package import (
    OpcPackage, Part, PartFactory, _Relationship, RelationshipCollection,
    Unmarshaller
)
from pptx.opc.pkgreader import PackageReader
from pptx.package import Package

from ..oxml.unitdata.text import an_hlinkClick, an_rPr
from ..unitutil import (
    cls_attr_mock, class_mock, instance_mock, loose_mock, method_mock
)


class DescribeOpcPackage(object):

    def it_can_open_a_pkg_file(self, PackageReader_, PartFactory_,
                               Unmarshaller_):
        # mockery ----------------------
        pkg_file = Mock(name='pkg_file')
        pkg_reader = PackageReader_.from_file.return_value
        # exercise ---------------------
        pkg = OpcPackage.open(pkg_file)
        # verify -----------------------
        PackageReader_.from_file.assert_called_once_with(pkg_file)
        Unmarshaller_.unmarshal.assert_called_once_with(pkg_reader, pkg,
                                                        PartFactory_)
        assert isinstance(pkg, OpcPackage)

    def it_initializes_its_rels_collection_on_first_reference(
            self, RelationshipCollection_):
        pkg = OpcPackage()
        rels = pkg.rels
        RelationshipCollection_.assert_called_once_with(PACKAGE_URI.baseURI)
        assert rels == RelationshipCollection_.return_value

    def it_can_add_a_relationship_to_a_part(self, pkg_with_rels_, rel_attrs_):
        reltype, target, rId = rel_attrs_
        pkg = pkg_with_rels_
        # exercise ---------------------
        pkg.load_rel(reltype, target, rId)
        # verify -----------------------
        pkg._rels.add_relationship.assert_called_once_with(
            reltype, target, rId, False
        )

    def it_can_establish_a_relationship_to_another_part(
            self, relate_to_part_fixture_):
        pkg, part_, reltype, rId = relate_to_part_fixture_
        _rId = pkg.relate_to(part_, reltype)
        pkg.rels.get_or_add.assert_called_once_with(reltype, part_)
        assert _rId == rId

    def it_can_provide_a_list_of_the_parts_it_contains(self):
        # mockery ----------------------
        parts = [Mock(name='part1'), Mock(name='part2')]
        pkg = OpcPackage()
        # verify -----------------------
        with patch.object(OpcPackage, 'iter_parts', return_value=parts):
            assert pkg.parts == [parts[0], parts[1]]

    def it_can_iterate_over_parts_by_walking_rels_graph(self):
        # +----------+       +--------+
        # | pkg_rels |-----> | part_1 |
        # +----------+       +--------+
        #      |               |    ^
        #      v               v    |
        #   external         +--------+
        #                    | part_2 |
        #                    +--------+
        part1, part2 = (Mock(name='part1'), Mock(name='part2'))
        part1.rels = {
            1: Mock(name='rel1', is_external=False, target_part=part2)
        }
        part2.rels = {
            1: Mock(name='rel2', is_external=False, target_part=part1)
        }
        pkg = OpcPackage()
        pkg._rels = {
            1: Mock(name='rel3', is_external=False, target_part=part1),
            2: Mock(name='rel4', is_external=True),
        }
        # verify -----------------------
        assert part1 in pkg.iter_parts()
        assert part2 in pkg.iter_parts()
        assert len([p for p in pkg.iter_parts()]) == 2

    def it_can_find_a_part_related_by_reltype(self, related_part_fixture_):
        pkg, reltype, related_part_ = related_part_fixture_
        related_part = pkg.part_related_by(reltype)
        pkg.rels.part_with_reltype.assert_called_once_with(reltype)
        assert related_part is related_part_

    def it_can_save_to_a_pkg_file(
            self, pkg_file_, PackageWriter_, parts, parts_):
        pkg = OpcPackage()
        pkg.save(pkg_file_)
        for part in parts_:
            part.before_marshal.assert_called_once_with()
        PackageWriter_.write.assert_called_once_with(
            pkg_file_, pkg._rels, parts_
        )

    # fixtures ---------------------------------------------

    @pytest.fixture
    def PackageReader_(self, request):
        return class_mock(request, 'pptx.opc.package.PackageReader')

    @pytest.fixture
    def PackageWriter_(self, request):
        return class_mock(request, 'pptx.opc.package.PackageWriter')

    @pytest.fixture
    def PartFactory_(self, request):
        return class_mock(request, 'pptx.opc.package.PartFactory')

    @pytest.fixture
    def parts(self, request, parts_):
        """
        Return a mock patching property OpcPackage.parts, reversing the
        patch after each use.
        """
        _patch = patch.object(
            OpcPackage, 'parts', new_callable=PropertyMock,
            return_value=parts_
        )
        request.addfinalizer(_patch.stop)
        return _patch.start()

    @pytest.fixture
    def parts_(self, request):
        part_ = instance_mock(request, Part, name='part_')
        part_2_ = instance_mock(request, Part, name='part_2_')
        return [part_, part_2_]

    @pytest.fixture
    def pkg(self, request):
        return OpcPackage()

    @pytest.fixture
    def pkg_file_(self, request):
        return loose_mock(request)

    @pytest.fixture
    def pkg_with_rels_(self, request, rels_):
        pkg = OpcPackage()
        pkg._rels = rels_
        return pkg

    @pytest.fixture
    def RelationshipCollection_(self, request):
        return class_mock(request, 'pptx.opc.package.RelationshipCollection')

    @pytest.fixture
    def rel_attrs_(self, request):
        reltype = 'http://rel/type'
        target_ = instance_mock(request, Part, name='target_')
        rId = 'rId99'
        return reltype, target_, rId

    @pytest.fixture
    def relate_to_part_fixture_(self, request, pkg, rels_, reltype):
        rId = 'rId99'
        rel_ = instance_mock(request, _Relationship, name='rel_', rId=rId)
        rels_.get_or_add.return_value = rel_
        pkg._rels = rels_
        part_ = instance_mock(request, Part, name='part_')
        return pkg, part_, reltype, rId

    @pytest.fixture
    def related_part_fixture_(self, request, rels_, reltype):
        related_part_ = instance_mock(request, Part, name='related_part_')
        rels_.part_with_reltype.return_value = related_part_
        pkg = OpcPackage()
        pkg._rels = rels_
        return pkg, reltype, related_part_

    @pytest.fixture
    def rels_(self, request):
        return instance_mock(request, RelationshipCollection)

    @pytest.fixture
    def reltype(self, request):
        return 'http://rel/type'

    @pytest.fixture
    def Unmarshaller_(self, request):
        return class_mock(request, 'pptx.opc.package.Unmarshaller')


class DescribePartLoadSaveInterface(object):

    def it_remembers_its_construction_state(self):
        partname, content_type, blob, element, package = (
            Mock(name='partname'), Mock(name='content_type'),
            Mock(name='blob'), None, Mock(name='package')
        )
        part = Part(partname, content_type, blob, element, package)
        assert part.partname == partname
        assert part.content_type == content_type
        assert part.blob == blob
        assert part.package == package

    def it_can_be_notified_after_unmarshalling_is_complete(self, part):
        part.after_unmarshal()

    def it_can_be_notified_before_marshalling_is_started(self, part):
        part.before_marshal()

    def it_allows_its_partname_to_be_changed(self, part):
        new_partname = PackURI('/ppt/presentation.xml')
        part.partname = new_partname
        assert part.partname == new_partname

    def it_can_load_a_relationship_during_package_open(
            self, part_with_rels_, rel_attrs_):
        # fixture ----------------------
        part, rels_ = part_with_rels_
        reltype, target, rId = rel_attrs_
        # exercise ---------------------
        part.load_rel(reltype, target, rId)
        # verify -----------------------
        rels_.add_relationship.assert_called_once_with(
            reltype, target, rId, False
        )

    # fixtures ---------------------------------------------

    @pytest.fixture
    def part(self):
        partname = PackURI('/foo/bar.xml')
        part = Part(partname, None, None)
        return part

    @pytest.fixture
    def part_with_rels_(self, request, part, rels_):
        part._rels = rels_
        return part, rels_

    @pytest.fixture
    def rel_attrs_(self, request):
        reltype = 'http://rel/type'
        target_ = instance_mock(request, Part, name='target_')
        rId = 'rId99'
        return reltype, target_, rId

    @pytest.fixture
    def rels_(self, request):
        return instance_mock(request, RelationshipCollection)


class DescribePartRelsProxyInterface(object):

    def it_has_a_rels_collection_initialized_on_first_reference(
            self, RelationshipCollection_):
        partname = PackURI('/foo/bar.xml')
        part = Part(partname, None, None)
        assert part.rels is RelationshipCollection_.return_value
        RelationshipCollection_.assert_called_once_with(partname.baseURI)

    def it_can_establish_a_relationship_to_another_part(
            self, relate_to_part_fixture_):
        # fixture ----------------------
        part, related_part_, reltype, rId = relate_to_part_fixture_
        # exercise ---------------------
        _rId = part.relate_to(related_part_, reltype)
        # verify -----------------------
        part.rels.get_or_add.assert_called_once_with(reltype, related_part_)
        assert _rId == rId

    def it_can_establish_an_external_relationship(
            self, relate_to_url_fixture_):
        part, url, reltype, rId = relate_to_url_fixture_
        _rId = part.relate_to(url, reltype, is_external=True)
        part.rels.get_or_add_ext_rel.assert_called_once_with(reltype, url)
        assert _rId == rId

    def it_can_drop_a_relationship(self, part_with_rels_to_drop_):
        part, rId, rId_2, rId_3 = part_with_rels_to_drop_
        part.drop_rel(rId)    # this one has ref count of 2, don't drop
        part.drop_rel(rId_2)  # this one has ref count of 1, drop
        part.drop_rel(rId_3)  # this one has ref count of 0, drop
        assert part.rels.__delitem__.call_args_list == [
            call(rId_2), call(rId_3)
        ]

    def it_can_find_a_part_related_by_reltype(self, related_part_fixture_):
        part, reltype, related_part_ = related_part_fixture_
        related_part = part.part_related_by(reltype)
        part.rels.part_with_reltype.assert_called_once_with(reltype)
        assert related_part is related_part_

    def it_can_find_the_target_ref_of_an_external_relationship(
            self, target_ref_fixture_):
        part, rId, url = target_ref_fixture_
        _url = part.target_ref(rId)
        assert _url == url

    # fixtures ---------------------------------------------

    @pytest.fixture
    def part(self):
        partname = PackURI('/foo/bar.xml')
        part = Part(partname, None, None)
        return part

    @pytest.fixture
    def part_with_rels_to_drop_(self, request, part, rels_):
        rId, rId_2, rId3 = 'rId1', 'rId2', 'rId3'
        _element = (
            an_rPr().with_nsdecls('a', 'r')
                    .with_child(an_hlinkClick().with_rId(rId))
                    .with_child(an_hlinkClick().with_rId(rId))
                    .with_child(an_hlinkClick().with_rId(rId_2))
                    .element
        )
        part._element = _element
        part._rels = rels_
        return part, rId, rId_2, rId3

    @pytest.fixture
    def RelationshipCollection_(self, request):
        return class_mock(request, 'pptx.opc.package.RelationshipCollection')

    @pytest.fixture
    def relate_to_part_fixture_(self, request, part, reltype):
        rId = 'rId99'
        related_part_ = instance_mock(request, Part, name='related_part_')
        rels_ = instance_mock(request, RelationshipCollection, name='rels_')
        rel_ = instance_mock(request, _Relationship, name='rel_', rId=rId)
        rels_.get_or_add.return_value = rel_
        part._rels = rels_
        return part, related_part_, reltype, rId

    @pytest.fixture
    def relate_to_url_fixture_(self, request, part, reltype):
        rId = 'rId21'
        url = 'https://github.com/scanny/python-pptx'
        rels_ = instance_mock(request, RelationshipCollection, name='rels_')
        rels_.get_or_add_ext_rel.return_value = rId
        part._rels = rels_
        return part, url, reltype, rId

    @pytest.fixture
    def related_part_fixture_(self, request, part, reltype):
        related_part_ = instance_mock(request, Part, name='related_part_')
        rels_ = instance_mock(request, RelationshipCollection, name='rels_')
        rels_.part_with_reltype.return_value = related_part_
        part._rels = rels_
        return part, reltype, related_part_

    @pytest.fixture
    def reltype(self):
        return 'http:/rel/type'

    @pytest.fixture
    def rels_(self, request):
        return instance_mock(request, RelationshipCollection)

    @pytest.fixture
    def target_ref_fixture_(self, request, part):
        rId = 'rId246'
        url = 'https://github.com/scanny/python-pptx'
        rels = RelationshipCollection(None)
        rels.add_relationship(None, url, rId, is_external=True)
        part._rels = rels
        return part, rId, url


class DescribePartFactory(object):

    def it_constructs_custom_part_type_for_registered_content_types(
            self, part_args_, CustomPartClass_, part_of_custom_type_):
        # fixture ----------------------
        partname, content_type, pkg, blob = part_args_
        # exercise ---------------------
        PartFactory.part_type_for[content_type] = CustomPartClass_
        part = PartFactory(partname, content_type, pkg, blob)
        # verify -----------------------
        CustomPartClass_.load.assert_called_once_with(
            partname, content_type, pkg, blob
        )
        assert part is part_of_custom_type_

    def it_constructs_part_using_default_class_when_no_custom_registered(
            self, part_args_2_, DefaultPartClass_, part_of_default_type_):
        partname, content_type, pkg, blob = part_args_2_
        part = PartFactory(partname, content_type, pkg, blob)
        DefaultPartClass_.load.assert_called_once_with(
            partname, content_type, pkg, blob
        )
        assert part is part_of_default_type_

    # fixtures ---------------------------------------------

    @pytest.fixture
    def part_of_custom_type_(self, request):
        return instance_mock(request, Part)

    @pytest.fixture
    def CustomPartClass_(self, request, part_of_custom_type_):
        CustomPartClass_ = Mock(name='CustomPartClass', spec=Part)
        CustomPartClass_.load.return_value = part_of_custom_type_
        return CustomPartClass_

    @pytest.fixture
    def part_of_default_type_(self, request):
        return instance_mock(request, Part)

    @pytest.fixture
    def DefaultPartClass_(self, request, part_of_default_type_):
        DefaultPartClass_ = cls_attr_mock(
            request, PartFactory, 'default_part_type'
        )
        DefaultPartClass_.load.return_value = part_of_default_type_
        return DefaultPartClass_

    @pytest.fixture
    def part_args_(self, request):
        partname_ = PackURI('/foo/bar.xml')
        content_type_ = 'content/type'
        pkg_ = instance_mock(request, Package, name="pkg_")
        blob_ = b'blob_'
        return partname_, content_type_, pkg_, blob_

    @pytest.fixture
    def part_args_2_(self, request):
        partname_2_ = PackURI('/bar/foo.xml')
        content_type_2_ = 'foobar/type'
        pkg_2_ = instance_mock(request, Package, name="pkg_2_")
        blob_2_ = b'blob_2_'
        return partname_2_, content_type_2_, pkg_2_, blob_2_


class Describe_Relationship(object):

    def it_remembers_construction_values(self):
        # test data --------------------
        rId = 'rId9'
        reltype = 'reltype'
        target = Mock(name='target_part')
        external = False
        # exercise ---------------------
        rel = _Relationship(rId, reltype, target, None, external)
        # verify -----------------------
        assert rel.rId == rId
        assert rel.reltype == reltype
        assert rel.target_part == target
        assert rel.is_external == external

    def it_should_raise_on_target_part_access_on_external_rel(self):
        rel = _Relationship(None, None, None, None, external=True)
        with pytest.raises(ValueError):
            rel.target_part

    def it_should_have_target_ref_for_external_rel(self):
        rel = _Relationship(None, None, 'target', None, external=True)
        assert rel.target_ref == 'target'

    def it_should_have_relative_ref_for_internal_rel(self):
        """
        Internal relationships (TargetMode == 'Internal' in the XML) should
        have a relative ref, e.g. '../slideLayouts/slideLayout1.xml', for
        the target_ref attribute.
        """
        part = Mock(name='part', partname=PackURI('/ppt/media/image1.png'))
        baseURI = '/ppt/slides'
        rel = _Relationship(None, None, part, baseURI)  # external=False
        assert rel.target_ref == '../media/image1.png'


class DescribeRelationshipCollection(object):

    def it_has_a_len(self):
        rels = RelationshipCollection(None)
        assert len(rels) == 0

    def it_has_dict_style_lookup_of_rel_by_rId(self):
        rel = Mock(name='rel', rId='foobar')
        rels = RelationshipCollection(None)
        rels['foobar'] = rel
        assert rels['foobar'] == rel

    def it_should_raise_on_failed_lookup_by_rId(self):
        rels = RelationshipCollection(None)
        with pytest.raises(KeyError):
            rels['barfoo']

    def it_can_add_a_relationship(self, _Relationship_):
        baseURI, rId, reltype, target, external = (
            'baseURI', 'rId9', 'reltype', 'target', False
        )
        rels = RelationshipCollection(baseURI)
        rel = rels.add_relationship(reltype, target, rId, external)
        _Relationship_.assert_called_once_with(
            rId, reltype, target, baseURI, external
        )
        assert rels[rId] == rel
        assert rel == _Relationship_.return_value

    def it_can_add_an_external_relationship(self, add_ext_rel_fixture_):
        rels, reltype, url = add_ext_rel_fixture_
        rId = rels.get_or_add_ext_rel(reltype, url)
        rel = rels[rId]
        assert rel.is_external
        assert rel.target_ref == url
        assert rel.reltype == reltype

    def it_should_return_an_existing_one_if_it_matches(
            self, add_matching_ext_rel_fixture_):
        rels, reltype, url, rId = add_matching_ext_rel_fixture_
        _rId = rels.get_or_add_ext_rel(reltype, url)
        assert _rId == rId
        assert len(rels) == 1

    def it_can_compose_rels_xml(self, rels, rels_elm):
        # exercise ---------------------
        rels.xml
        # verify -----------------------
        rels_elm.assert_has_calls(
            [
                call.add_rel(
                    'rId1', 'http://rt-hyperlink', 'http://some/link', True
                ),
                call.add_rel(
                    'rId2', 'http://rt-image', '../media/image1.png', False
                ),
                call.xml()
            ],
            any_order=True
        )

    # fixtures ---------------------------------------------

    @pytest.fixture
    def add_ext_rel_fixture_(self, reltype, url):
        rels = RelationshipCollection(None)
        return rels, reltype, url

    @pytest.fixture
    def add_matching_ext_rel_fixture_(self, request, reltype, url):
        rId = 'rId369'
        rels = RelationshipCollection(None)
        rels.add_relationship(reltype, url, rId, is_external=True)
        return rels, reltype, url, rId

    @pytest.fixture
    def _Relationship_(self, request):
        return class_mock(request, 'pptx.opc.package._Relationship')

    @pytest.fixture
    def rels(self):
        """
        Populated RelationshipCollection instance that will exercise the
        rels.xml property.
        """
        rels = RelationshipCollection('/baseURI')
        rels.add_relationship(
            reltype='http://rt-hyperlink', target='http://some/link',
            rId='rId1', is_external=True
        )
        part = Mock(name='part')
        part.partname.relative_ref.return_value = '../media/image1.png'
        rels.add_relationship(reltype='http://rt-image', target=part,
                              rId='rId2')
        return rels

    @pytest.fixture
    def rels_elm(self, request):
        """
        Return a rels_elm mock that will be returned from
        CT_Relationships.new()
        """
        # create rels_elm mock with a .xml property
        rels_elm = Mock(name='rels_elm')
        xml = PropertyMock(name='xml')
        type(rels_elm).xml = xml
        rels_elm.attach_mock(xml, 'xml')
        rels_elm.reset_mock()  # to clear attach_mock call
        # patch CT_Relationships to return that rels_elm
        patch_ = patch.object(CT_Relationships, 'new', return_value=rels_elm)
        patch_.start()
        request.addfinalizer(patch_.stop)
        return rels_elm

    @pytest.fixture
    def reltype(self):
        return 'http://rel/type'

    @pytest.fixture
    def url(self):
        return 'https://github.com/scanny/python-pptx'


class DescribeUnmarshaller(object):

    def it_can_unmarshal_from_a_pkg_reader(
            self, pkg_reader_, pkg_, part_factory_, _unmarshal_parts,
            _unmarshal_relationships, parts_dict_):
        # exercise ---------------------
        Unmarshaller.unmarshal(pkg_reader_, pkg_, part_factory_)
        # verify -----------------------
        _unmarshal_parts.assert_called_once_with(
            pkg_reader_, pkg_, part_factory_
        )
        _unmarshal_relationships.assert_called_once_with(
            pkg_reader_, pkg_, parts_dict_
        )
        for part in parts_dict_.values():
            part.after_unmarshal.assert_called_once_with()
        pkg_.after_unmarshal.assert_called_once_with()

    def it_can_unmarshal_parts(
            self, pkg_reader_, pkg_, part_factory_, parts_dict_, partnames_,
            content_types_, blobs_):
        # fixture ----------------------
        partname_, partname_2_ = partnames_
        content_type_, content_type_2_ = content_types_
        blob_, blob_2_ = blobs_
        # exercise ---------------------
        parts = Unmarshaller._unmarshal_parts(
            pkg_reader_, pkg_, part_factory_
        )
        # verify -----------------------
        assert (
            part_factory_.call_args_list == [
                call(partname_, content_type_, blob_, pkg_),
                call(partname_2_, content_type_2_, blob_2_, pkg_)
            ]
        )
        assert parts == parts_dict_

    def it_can_unmarshal_relationships(self):
        # test data --------------------
        reltype = 'http://reltype'
        # mockery ----------------------
        pkg_reader = Mock(name='pkg_reader')
        pkg_reader.iter_srels.return_value = (
            ('/',         Mock(name='srel1', rId='rId1', reltype=reltype,
             target_partname='partname1', is_external=False)),
            ('/',         Mock(name='srel2', rId='rId2', reltype=reltype,
             target_ref='target_ref_1',   is_external=True)),
            ('partname1', Mock(name='srel3', rId='rId3', reltype=reltype,
             target_partname='partname2', is_external=False)),
            ('partname2', Mock(name='srel4', rId='rId4', reltype=reltype,
             target_ref='target_ref_2',   is_external=True)),
        )
        pkg = Mock(name='pkg')
        parts = {}
        for num in range(1, 3):
            name = 'part%d' % num
            part = Mock(name=name)
            parts['partname%d' % num] = part
            pkg.attach_mock(part, name)
        # exercise ---------------------
        Unmarshaller._unmarshal_relationships(pkg_reader, pkg, parts)
        # verify -----------------------
        expected_pkg_calls = [
            call.load_rel(reltype, parts['partname1'], 'rId1', False),
            call.load_rel(reltype, 'target_ref_1', 'rId2', True),
            call.part1.load_rel(reltype, parts['partname2'], 'rId3', False),
            call.part2.load_rel(reltype, 'target_ref_2', 'rId4', True),
        ]
        assert pkg.mock_calls == expected_pkg_calls

    # fixtures ---------------------------------------------

    @pytest.fixture
    def blobs_(self, request):
        blob_ = loose_mock(request, spec=str, name='blob_')
        blob_2_ = loose_mock(request, spec=str, name='blob_2_')
        return blob_, blob_2_

    @pytest.fixture
    def content_types_(self, request):
        content_type_ = loose_mock(request, spec=str, name='content_type_')
        content_type_2_ = loose_mock(request, spec=str, name='content_type_2_')
        return content_type_, content_type_2_

    @pytest.fixture
    def part_factory_(self, request, parts_):
        part_factory_ = loose_mock(request, spec=Part)
        part_factory_.side_effect = parts_
        return part_factory_

    @pytest.fixture
    def partnames_(self, request):
        partname_ = loose_mock(request, spec=str, name='partname_')
        partname_2_ = loose_mock(request, spec=str, name='partname_2_')
        return partname_, partname_2_

    @pytest.fixture
    def parts_(self, request):
        part_ = instance_mock(request, Part, name='part_')
        part_2_ = instance_mock(request, Part, name='part_2')
        return part_, part_2_

    @pytest.fixture
    def parts_dict_(self, request, partnames_, parts_):
        partname_, partname_2_ = partnames_
        part_, part_2_ = parts_
        return {partname_: part_, partname_2_: part_2_}

    @pytest.fixture
    def pkg_(self, request):
        return instance_mock(request, Package)

    @pytest.fixture
    def pkg_reader_(self, request, partnames_, content_types_, blobs_):
        partname_, partname_2_ = partnames_
        content_type_, content_type_2_ = content_types_
        blob_, blob_2_ = blobs_
        spart_return_values = (
            (partname_, content_type_, blob_),
            (partname_2_, content_type_2_, blob_2_),
        )
        pkg_reader_ = instance_mock(request, PackageReader)
        pkg_reader_.iter_sparts.return_value = spart_return_values
        return pkg_reader_

    @pytest.fixture
    def _unmarshal_parts(self, request, parts_dict_):
        return method_mock(
            request, Unmarshaller, '_unmarshal_parts',
            return_value=parts_dict_
        )

    @pytest.fixture
    def _unmarshal_relationships(self, request):
        return method_mock(request, Unmarshaller, '_unmarshal_relationships')


# from ..unitutil import (
#     absjoin, class_mock, cls_attr_mock, instance_mock, loose_mock,
#     method_mock, test_file_dir
# )
# test_pptx_path = absjoin(test_file_dir, 'test.pptx')
# dir_pkg_path = absjoin(test_file_dir, 'expanded_pptx')
# zip_pkg_path = test_pptx_path

# def test_it_finds_default_case_insensitive(self, cti):
#     """_ContentTypesItem[partname] finds default case insensitive"""
#     # setup ------------------------
#     partname = '/ppt/media/image1.JPG'
#     content_type = 'image/jpeg'
#     cti._defaults = {'jpg': content_type}
#     # exercise ---------------------
#     val = cti[partname]
#     # verify -----------------------
#     assert val == content_type

# def test_it_finds_override_case_insensitive(self, cti):
#     """_ContentTypesItem[partname] finds override case insensitive"""
#     # setup ------------------------
#     partname = '/foo/bar.xml'
#     case_mangled_partname = '/FoO/bAr.XML'
#     content_type = 'application/vnd.content_type'
#     cti._overrides = {
#         partname: content_type
#     }
#     # exercise ---------------------
#     val = cti[case_mangled_partname]
#     # verify -----------------------
#     assert val == content_type

# def test_save_accepts_stream(self, tmp_pptx_path):
#     pkg = Package().open(dir_pkg_path)
#     stream = StringIO()
#     # exercise --------------------
#     pkg.save(stream)
#     # verify ----------------------
#     # can't use is_zipfile() directly on stream in Python 2.6
#     stream.seek(0)
#     with open(tmp_pptx_path, 'wb') as f:
#         f.write(stream.read())
#     msg = "Package.save(stream) did not create zipfile"
#     assert is_zipfile(tmp_pptx_path), msg


# @pytest.fixture
# def tmp_pptx_path(tmpdir):
#     return str(tmpdir.join('test_python-pptx.pptx'))

########NEW FILE########
__FILENAME__ = test_packuri
# encoding: utf-8

"""
Test suite for the pptx.opc.packuri module
"""

import pytest

from pptx.opc.packuri import PackURI


class DescribePackURI(object):

    def cases(self, expected_values):
        """
        Return list of tuples zipped from uri_str cases and
        *expected_values*. Raise if lengths don't match.
        """
        uri_str_cases = [
            '/',
            '/ppt/presentation.xml',
            '/ppt/slides/slide1.xml',
        ]
        if len(expected_values) != len(uri_str_cases):
            msg = "len(expected_values) differs from len(uri_str_cases)"
            raise AssertionError(msg)
        pack_uris = [PackURI(uri_str) for uri_str in uri_str_cases]
        return zip(pack_uris, expected_values)

    def it_can_construct_from_relative_ref(self):
        baseURI = '/ppt/slides'
        relative_ref = '../slideLayouts/slideLayout1.xml'
        pack_uri = PackURI.from_rel_ref(baseURI, relative_ref)
        assert pack_uri == '/ppt/slideLayouts/slideLayout1.xml'

    def it_should_raise_on_construct_with_bad_pack_uri_str(self):
        with pytest.raises(ValueError):
            PackURI('foobar')

    def it_can_calculate_baseURI(self):
        expected_values = ('/', '/ppt', '/ppt/slides')
        for pack_uri, expected_baseURI in self.cases(expected_values):
            assert pack_uri.baseURI == expected_baseURI

    def it_can_calculate_extension(self):
        expected_values = ('', 'xml', 'xml')
        for pack_uri, expected_ext in self.cases(expected_values):
            assert pack_uri.ext == expected_ext

    def it_can_calculate_filename(self):
        expected_values = ('', 'presentation.xml', 'slide1.xml')
        for pack_uri, expected_filename in self.cases(expected_values):
            assert pack_uri.filename == expected_filename

    def it_knows_the_filename_index(self):
        expected_values = (None, None, 1)
        for pack_uri, expected_idx in self.cases(expected_values):
            assert pack_uri.idx == expected_idx

    def it_can_calculate_membername(self):
        expected_values = (
            '',
            'ppt/presentation.xml',
            'ppt/slides/slide1.xml',
        )
        for pack_uri, expected_membername in self.cases(expected_values):
            assert pack_uri.membername == expected_membername

    def it_can_calculate_relative_ref_value(self):
        cases = (
            ('/', '/ppt/presentation.xml', 'ppt/presentation.xml'),
            ('/ppt', '/ppt/slideMasters/slideMaster1.xml',
             'slideMasters/slideMaster1.xml'),
            ('/ppt/slides', '/ppt/slideLayouts/slideLayout1.xml',
             '../slideLayouts/slideLayout1.xml'),
        )
        for baseURI, uri_str, expected_relative_ref in cases:
            pack_uri = PackURI(uri_str)
            assert pack_uri.relative_ref(baseURI) == expected_relative_ref

    def it_can_calculate_rels_uri(self):
        expected_values = (
            '/_rels/.rels',
            '/ppt/_rels/presentation.xml.rels',
            '/ppt/slides/_rels/slide1.xml.rels',
        )
        for pack_uri, expected_rels_uri in self.cases(expected_values):
            assert pack_uri.rels_uri == expected_rels_uri

########NEW FILE########
__FILENAME__ = test_phys_pkg
# encoding: utf-8

"""
Test suite for pptx.opc.packaging module
"""

from __future__ import absolute_import

try:
    from io import BytesIO  # Python 3
except ImportError:
    from StringIO import StringIO as BytesIO

import hashlib
import pytest

from mock import Mock
from zipfile import ZIP_DEFLATED, ZipFile

from pptx.exceptions import PackageNotFoundError
from pptx.opc.packuri import PACKAGE_URI, PackURI
from pptx.opc.phys_pkg import (
    _DirPkgReader, PhysPkgReader, PhysPkgWriter, _ZipPkgReader, _ZipPkgWriter
)

from ..unitutil import absjoin, class_mock, loose_mock, test_file_dir


test_pptx_path = absjoin(test_file_dir, 'test.pptx')
dir_pkg_path = absjoin(test_file_dir, 'expanded_pptx')
zip_pkg_path = test_pptx_path


class DescribeDirPkgReader(object):

    def it_is_used_by_PhysPkgReader_when_pkg_is_a_dir(self):
        phys_reader = PhysPkgReader(dir_pkg_path)
        assert isinstance(phys_reader, _DirPkgReader)

    def it_doesnt_mind_being_closed_even_though_it_doesnt_need_it(
            self, dir_reader):
        dir_reader.close()

    def it_can_retrieve_the_blob_for_a_pack_uri(self, dir_reader):
        pack_uri = PackURI('/ppt/presentation.xml')
        blob = dir_reader.blob_for(pack_uri)
        sha1 = hashlib.sha1(blob).hexdigest()
        assert sha1 == '51b78f4dabc0af2419d4e044ab73028c4bef53aa'

    def it_can_get_the_content_types_xml(self, dir_reader):
        sha1 = hashlib.sha1(dir_reader.content_types_xml).hexdigest()
        assert sha1 == 'a68cf138be3c4eb81e47e2550166f9949423c7df'

    def it_can_retrieve_the_rels_xml_for_a_source_uri(self, dir_reader):
        rels_xml = dir_reader.rels_xml_for(PACKAGE_URI)
        sha1 = hashlib.sha1(rels_xml).hexdigest()
        assert sha1 == '64ffe86bb2bbaad53c3c1976042b907f8e10c5a3'

    def it_returns_none_when_part_has_no_rels_xml(self, dir_reader):
        partname = PackURI('/ppt/viewProps.xml')
        rels_xml = dir_reader.rels_xml_for(partname)
        assert rels_xml is None

    # fixtures ---------------------------------------------

    @pytest.fixture
    def pkg_file_(self, request):
        return loose_mock(request)

    @pytest.fixture(scope='class')
    def dir_reader(self):
        return _DirPkgReader(dir_pkg_path)


class DescribePhysPkgReader(object):

    def it_raises_when_pkg_path_is_not_a_package(self):
        with pytest.raises(PackageNotFoundError):
            PhysPkgReader('foobar')


class DescribeZipPkgReader(object):

    def it_is_used_by_PhysPkgReader_when_pkg_is_a_zip(self):
        phys_reader = PhysPkgReader(zip_pkg_path)
        assert isinstance(phys_reader, _ZipPkgReader)

    def it_is_used_by_PhysPkgReader_when_pkg_is_a_stream(self):
        with open(zip_pkg_path, 'rb') as stream:
            phys_reader = PhysPkgReader(stream)
        assert isinstance(phys_reader, _ZipPkgReader)

    def it_opens_pkg_file_zip_on_construction(self, ZipFile_, pkg_file_):
        _ZipPkgReader(pkg_file_)
        ZipFile_.assert_called_once_with(pkg_file_, 'r')

    def it_can_be_closed(self, ZipFile_):
        # mockery ----------------------
        zipf = ZipFile_.return_value
        zip_pkg_reader = _ZipPkgReader(None)
        # exercise ---------------------
        zip_pkg_reader.close()
        # verify -----------------------
        zipf.close.assert_called_once_with()

    def it_can_retrieve_the_blob_for_a_pack_uri(self, phys_reader):
        pack_uri = PackURI('/ppt/presentation.xml')
        blob = phys_reader.blob_for(pack_uri)
        sha1 = hashlib.sha1(blob).hexdigest()
        assert sha1 == 'efa7bee0ac72464903a67a6744c1169035d52a54'

    def it_has_the_content_types_xml(self, phys_reader):
        sha1 = hashlib.sha1(phys_reader.content_types_xml).hexdigest()
        assert sha1 == 'ab762ac84414fce18893e18c3f53700c01db56c3'

    def it_can_retrieve_rels_xml_for_source_uri(self, phys_reader):
        rels_xml = phys_reader.rels_xml_for(PACKAGE_URI)
        sha1 = hashlib.sha1(rels_xml).hexdigest()
        assert sha1 == 'e31451d4bbe7d24adbe21454b8e9fdae92f50de5'

    def it_returns_none_when_part_has_no_rels_xml(self, phys_reader):
        partname = PackURI('/ppt/viewProps.xml')
        rels_xml = phys_reader.rels_xml_for(partname)
        assert rels_xml is None

    # fixtures ---------------------------------------------

    @pytest.fixture(scope='class')
    def phys_reader(self, request):
        phys_reader = _ZipPkgReader(zip_pkg_path)
        request.addfinalizer(phys_reader.close)
        return phys_reader

    @pytest.fixture
    def pkg_file_(self, request):
        return loose_mock(request)


class DescribeZipPkgWriter(object):

    def it_is_used_by_PhysPkgWriter_unconditionally(self, tmp_pptx_path):
        phys_writer = PhysPkgWriter(tmp_pptx_path)
        assert isinstance(phys_writer, _ZipPkgWriter)

    def it_opens_pkg_file_zip_on_construction(self, ZipFile_):
        pkg_file = Mock(name='pkg_file')
        _ZipPkgWriter(pkg_file)
        ZipFile_.assert_called_once_with(
            pkg_file, 'w', compression=ZIP_DEFLATED
        )

    def it_can_be_closed(self, ZipFile_):
        # mockery ----------------------
        zipf = ZipFile_.return_value
        zip_pkg_writer = _ZipPkgWriter(None)
        # exercise ---------------------
        zip_pkg_writer.close()
        # verify -----------------------
        zipf.close.assert_called_once_with()

    def it_can_write_a_blob(self, pkg_file):
        # setup ------------------------
        pack_uri = PackURI('/part/name.xml')
        blob = '<BlobbityFooBlob/>'.encode('utf-8')
        # exercise ---------------------
        pkg_writer = PhysPkgWriter(pkg_file)
        pkg_writer.write(pack_uri, blob)
        pkg_writer.close()
        # verify -----------------------
        written_blob_sha1 = hashlib.sha1(blob).hexdigest()
        zipf = ZipFile(pkg_file, 'r')
        retrieved_blob = zipf.read(pack_uri.membername)
        zipf.close()
        retrieved_blob_sha1 = hashlib.sha1(retrieved_blob).hexdigest()
        assert retrieved_blob_sha1 == written_blob_sha1

    # fixtures ---------------------------------------------

    @pytest.fixture
    def pkg_file(self, request):
        pkg_file = BytesIO()
        request.addfinalizer(pkg_file.close)
        return pkg_file


# fixtures -------------------------------------------------

@pytest.fixture
def tmp_pptx_path(tmpdir):
    return str(tmpdir.join('test_python-pptx.pptx'))


@pytest.fixture
def ZipFile_(request):
    return class_mock(request, 'pptx.opc.phys_pkg.ZipFile')

########NEW FILE########
__FILENAME__ = test_pkgreader
# encoding: utf-8

"""
Test suite for opc.pkgreader module
"""

from __future__ import absolute_import, print_function, unicode_literals

import pytest

from mock import call, Mock, patch

from pptx.opc.constants import (
    CONTENT_TYPE as CT, RELATIONSHIP_TARGET_MODE as RTM
)
from pptx.opc.packuri import PackURI
from pptx.opc.phys_pkg import _ZipPkgReader
from pptx.opc.pkgreader import (
    _ContentTypeMap, PackageReader, _SerializedPart, _SerializedRelationship,
    _SerializedRelationshipCollection
)

from .unitdata.types import a_Default, a_Types, an_Override
from ..unitutil import class_mock, initializer_mock, method_mock


class DescribePackageReader(object):

    @pytest.fixture
    def from_xml(self, request):
        return method_mock(request, _ContentTypeMap, 'from_xml')

    @pytest.fixture
    def init(self, request):
        return initializer_mock(request, PackageReader)

    @pytest.fixture
    def _load_serialized_parts(self, request):
        return method_mock(request, PackageReader, '_load_serialized_parts')

    @pytest.fixture
    def PhysPkgReader_(self, request):
        _patch = patch(
            'pptx.opc.pkgreader.PhysPkgReader', spec_set=_ZipPkgReader
        )
        request.addfinalizer(_patch.stop)
        return _patch.start()

    @pytest.fixture
    def _SerializedPart_(self, request):
        return class_mock(request, 'pptx.opc.pkgreader._SerializedPart')

    @pytest.fixture
    def _SerializedRelationshipCollection_(self, request):
        return class_mock(
            request, 'pptx.opc.pkgreader._SerializedRelationshipCollection'
        )

    @pytest.fixture
    def _srels_for(self, request):
        return method_mock(request, PackageReader, '_srels_for')

    @pytest.fixture
    def _walk_phys_parts(self, request):
        return method_mock(request, PackageReader, '_walk_phys_parts')

    def it_can_construct_from_pkg_file(self, init, PhysPkgReader_, from_xml,
                                       _srels_for, _load_serialized_parts):
        # mockery ----------------------
        phys_reader = PhysPkgReader_.return_value
        content_types = from_xml.return_value
        pkg_srels = _srels_for.return_value
        sparts = _load_serialized_parts.return_value
        pkg_file = Mock(name='pkg_file')
        # exercise ---------------------
        pkg_reader = PackageReader.from_file(pkg_file)
        # verify -----------------------
        PhysPkgReader_.assert_called_once_with(pkg_file)
        from_xml.assert_called_once_with(phys_reader.content_types_xml)
        _srels_for.assert_called_once_with(phys_reader, '/')
        _load_serialized_parts.assert_called_once_with(phys_reader, pkg_srels,
                                                       content_types)
        phys_reader.close.assert_called_once_with()
        init.assert_called_once_with(content_types, pkg_srels, sparts)
        assert isinstance(pkg_reader, PackageReader)

    def it_can_iterate_over_the_serialized_parts(self):
        # mockery ----------------------
        partname, content_type, blob = ('part/name.xml', 'app/vnd.type',
                                        '<Part_1/>')
        spart = Mock(name='spart', partname=partname,
                     content_type=content_type, blob=blob)
        pkg_reader = PackageReader(None, None, [spart])
        iter_count = 0
        # exercise ---------------------
        for retval in pkg_reader.iter_sparts():
            iter_count += 1
        # verify -----------------------
        assert retval == (partname, content_type, blob)
        assert iter_count == 1

    def it_can_iterate_over_all_the_srels(self):
        # mockery ----------------------
        pkg_srels = ['srel1', 'srel2']
        sparts = [
            Mock(name='spart1', partname='pn1', srels=['srel3', 'srel4']),
            Mock(name='spart2', partname='pn2', srels=['srel5', 'srel6']),
        ]
        pkg_reader = PackageReader(None, pkg_srels, sparts)
        # exercise ---------------------
        generated_tuples = [t for t in pkg_reader.iter_srels()]
        # verify -----------------------
        expected_tuples = [
            ('/',   'srel1'),
            ('/',   'srel2'),
            ('pn1', 'srel3'),
            ('pn1', 'srel4'),
            ('pn2', 'srel5'),
            ('pn2', 'srel6'),
        ]
        assert generated_tuples == expected_tuples

    def it_can_load_serialized_parts(self, _SerializedPart_, _walk_phys_parts):
        # test data --------------------
        test_data = (
            ('/part/name1.xml', 'app/vnd.type_1', '<Part_1/>', 'srels_1'),
            ('/part/name2.xml', 'app/vnd.type_2', '<Part_2/>', 'srels_2'),
        )
        iter_vals = [(t[0], t[2], t[3]) for t in test_data]
        content_types = dict((t[0], t[1]) for t in test_data)
        # mockery ----------------------
        phys_reader = Mock(name='phys_reader')
        pkg_srels = Mock(name='pkg_srels')
        _walk_phys_parts.return_value = iter_vals
        _SerializedPart_.side_effect = expected_sparts = (
            Mock(name='spart_1'), Mock(name='spart_2')
        )
        # exercise ---------------------
        retval = PackageReader._load_serialized_parts(phys_reader, pkg_srels,
                                                      content_types)
        # verify -----------------------
        expected_calls = [
            call('/part/name1.xml', 'app/vnd.type_1', '<Part_1/>', 'srels_1'),
            call('/part/name2.xml', 'app/vnd.type_2', '<Part_2/>', 'srels_2'),
        ]
        assert _SerializedPart_.call_args_list == expected_calls
        assert retval == expected_sparts

    def it_can_walk_phys_pkg_parts(self, _srels_for):
        # test data --------------------
        # +----------+       +--------+
        # | pkg_rels |-----> | part_1 |
        # +----------+       +--------+
        #      |               |    ^
        #      v               v    |
        #   external         +--------+     +--------+
        #                    | part_2 |---> | part_3 |
        #                    +--------+     +--------+
        partname_1, partname_2, partname_3 = (
            '/part/name1.xml', '/part/name2.xml', '/part/name3.xml'
        )
        part_1_blob, part_2_blob, part_3_blob = (
            '<Part_1/>', '<Part_2/>', '<Part_3/>'
        )
        srels = [
            Mock(name='rId1', is_external=True),
            Mock(name='rId2', is_external=False, target_partname=partname_1),
            Mock(name='rId3', is_external=False, target_partname=partname_2),
            Mock(name='rId4', is_external=False, target_partname=partname_1),
            Mock(name='rId5', is_external=False, target_partname=partname_3),
        ]
        pkg_srels = srels[:2]
        part_1_srels = srels[2:3]
        part_2_srels = srels[3:5]
        part_3_srels = []
        # mockery ----------------------
        phys_reader = Mock(name='phys_reader')
        _srels_for.side_effect = [part_1_srels, part_2_srels, part_3_srels]
        phys_reader.blob_for.side_effect = [
            part_1_blob, part_2_blob, part_3_blob
        ]
        # exercise ---------------------
        generated_tuples = [t for t in PackageReader._walk_phys_parts(
            phys_reader, pkg_srels)]
        # verify -----------------------
        expected_tuples = [
            (partname_1, part_1_blob, part_1_srels),
            (partname_2, part_2_blob, part_2_srels),
            (partname_3, part_3_blob, part_3_srels),
        ]
        assert generated_tuples == expected_tuples

    def it_can_retrieve_srels_for_a_source_uri(
            self, _SerializedRelationshipCollection_):
        # mockery ----------------------
        phys_reader = Mock(name='phys_reader')
        source_uri = Mock(name='source_uri')
        rels_xml = phys_reader.rels_xml_for.return_value
        load_from_xml = _SerializedRelationshipCollection_.load_from_xml
        srels = load_from_xml.return_value
        # exercise ---------------------
        retval = PackageReader._srels_for(phys_reader, source_uri)
        # verify -----------------------
        phys_reader.rels_xml_for.assert_called_once_with(source_uri)
        load_from_xml.assert_called_once_with(source_uri.baseURI, rels_xml)
        assert retval == srels


class Describe_ContentTypeMap(object):

    def it_can_construct_from_ct_item_xml(self, from_xml_fixture):
        content_types_xml, expected_defaults, expected_overrides = (
            from_xml_fixture
        )
        ct_map = _ContentTypeMap.from_xml(content_types_xml)
        assert ct_map._defaults == expected_defaults
        assert ct_map._overrides == expected_overrides

    def it_matches_an_override_on_case_insensitive_partname(
            self, match_override_fixture):
        ct_map, partname, content_type = match_override_fixture
        assert ct_map[partname] == content_type

    def it_falls_back_to_case_insensitive_extension_default_match(
            self, match_default_fixture):
        ct_map, partname, content_type = match_default_fixture
        assert ct_map[partname] == content_type

    def it_should_raise_on_partname_not_found(self):
        ct_map = _ContentTypeMap()
        with pytest.raises(KeyError):
            ct_map[PackURI('/!blat/rhumba.1x&')]

    def it_should_raise_on_key_not_instance_of_PackURI(self):
        ct_map = _ContentTypeMap()
        ct_map._add_override(PackURI('/part/name1.xml'), 'app/vnd.type1')
        with pytest.raises(KeyError):
            ct_map['/part/name1.xml']

    # fixtures ---------------------------------------------

    @pytest.fixture
    def from_xml_fixture(self):
        entries = (
            ('Default', 'xml', CT.XML),
            ('Default', 'PNG', CT.PNG),
            ('Override', '/ppt/presentation.xml', CT.PML_PRESENTATION_MAIN),
        )
        content_types_xml = self._xml_from(entries)
        expected_defaults = {}
        expected_overrides = {}
        for entry in entries:
            if entry[0] == 'Default':
                ext = entry[1].lower()
                content_type = entry[2]
                expected_defaults[ext] = content_type
            elif entry[0] == 'Override':
                partname, content_type = entry[1:]
                expected_overrides[partname] = content_type
        return content_types_xml, expected_defaults, expected_overrides

    @pytest.fixture(params=[
        ('/foo/bar.xml', 'xml', 'application/xml'),
        ('/foo/bar.PNG', 'png', 'image/png'),
        ('/foo/bar.jpg', 'JPG', 'image/jpeg'),
    ])
    def match_default_fixture(self, request):
        partname_str, ext, content_type = request.param
        partname = PackURI(partname_str)
        ct_map = _ContentTypeMap()
        ct_map._add_override(PackURI('/bar/foo.xyz'), 'application/xyz')
        ct_map._add_default(ext, content_type)
        return ct_map, partname, content_type

    @pytest.fixture(params=[
        ('/foo/bar.xml', '/foo/bar.xml'),
        ('/foo/bar.xml', '/FOO/Bar.XML'),
        ('/FoO/bAr.XmL', '/foo/bar.xml'),
    ])
    def match_override_fixture(self, request):
        partname_str, should_match_partname_str = request.param
        partname = PackURI(partname_str)
        should_match_partname = PackURI(should_match_partname_str)
        content_type = 'appl/vnd-foobar'
        ct_map = _ContentTypeMap()
        ct_map._add_override(partname, content_type)
        return ct_map, should_match_partname, content_type

    def _xml_from(self, entries):
        """
        Return XML for a [Content_Types].xml based on items in *entries*.
        """
        types_bldr = a_Types().with_nsdecls()
        for entry in entries:
            if entry[0] == 'Default':
                ext, content_type = entry[1:]
                default_bldr = a_Default()
                default_bldr.with_Extension(ext)
                default_bldr.with_ContentType(content_type)
                types_bldr.with_child(default_bldr)
            elif entry[0] == 'Override':
                partname, content_type = entry[1:]
                override_bldr = an_Override()
                override_bldr.with_PartName(partname)
                override_bldr.with_ContentType(content_type)
                types_bldr.with_child(override_bldr)
        return types_bldr.xml()


class Describe_SerializedPart(object):

    def it_remembers_construction_values(self):
        # test data --------------------
        partname = '/part/name.xml'
        content_type = 'app/vnd.type'
        blob = '<Part/>'
        srels = 'srels proxy'
        # exercise ---------------------
        spart = _SerializedPart(partname, content_type, blob, srels)
        # verify -----------------------
        assert spart.partname == partname
        assert spart.content_type == content_type
        assert spart.blob == blob
        assert spart.srels == srels


class Describe_SerializedRelationship(object):

    def it_remembers_construction_values(self):
        # test data --------------------
        rel_elm = Mock(
            name='rel_elm', rId='rId9', reltype='ReLtYpE',
            target_ref='docProps/core.xml', target_mode=RTM.INTERNAL
        )
        # exercise ---------------------
        srel = _SerializedRelationship('/', rel_elm)
        # verify -----------------------
        assert srel.rId == 'rId9'
        assert srel.reltype == 'ReLtYpE'
        assert srel.target_ref == 'docProps/core.xml'
        assert srel.target_mode == RTM.INTERNAL

    def it_knows_when_it_is_external(self):
        cases = (RTM.INTERNAL, RTM.EXTERNAL, 'FOOBAR')
        expected_values = (False, True, False)
        for target_mode, expected_value in zip(cases, expected_values):
            rel_elm = Mock(name='rel_elm', rId=None, reltype=None,
                           target_ref=None, target_mode=target_mode)
            srel = _SerializedRelationship(None, rel_elm)
            assert srel.is_external is expected_value

    def it_can_calculate_its_target_partname(self):
        # test data --------------------
        cases = (
            ('/', 'docProps/core.xml', '/docProps/core.xml'),
            ('/ppt', 'viewProps.xml', '/ppt/viewProps.xml'),
            ('/ppt/slides', '../slideLayouts/slideLayout1.xml',
             '/ppt/slideLayouts/slideLayout1.xml'),
        )
        for baseURI, target_ref, expected_partname in cases:
            # setup --------------------
            rel_elm = Mock(name='rel_elm', rId=None, reltype=None,
                           target_ref=target_ref, target_mode=RTM.INTERNAL)
            # exercise -----------------
            srel = _SerializedRelationship(baseURI, rel_elm)
            # verify -------------------
            assert srel.target_partname == expected_partname

    def it_raises_on_target_partname_when_external(self):
        rel_elm = Mock(
            name='rel_elm', rId='rId9', reltype='ReLtYpE',
            target_ref='docProps/core.xml', target_mode=RTM.EXTERNAL
        )
        srel = _SerializedRelationship('/', rel_elm)
        with pytest.raises(ValueError):
            srel.target_partname


class Describe_SerializedRelationshipCollection(object):

    @pytest.fixture
    def oxml_fromstring(self, request):
        _patch = patch('pptx.opc.pkgreader.oxml_fromstring')
        request.addfinalizer(_patch.stop)
        return _patch.start()

    @pytest.fixture
    def _SerializedRelationship_(self, request):
        return class_mock(
            request, 'pptx.opc.pkgreader._SerializedRelationship'
        )

    def it_can_load_from_xml(self, oxml_fromstring, _SerializedRelationship_):
        # mockery ----------------------
        baseURI, rels_item_xml, rel_elm_1, rel_elm_2 = (
            Mock(name='baseURI'), Mock(name='rels_item_xml'),
            Mock(name='rel_elm_1'), Mock(name='rel_elm_2'),
        )
        rels_elm = Mock(name='rels_elm', Relationship=[rel_elm_1, rel_elm_2])
        oxml_fromstring.return_value = rels_elm
        # exercise ---------------------
        srels = _SerializedRelationshipCollection.load_from_xml(
            baseURI, rels_item_xml)
        # verify -----------------------
        expected_calls = [
            call(baseURI, rel_elm_1),
            call(baseURI, rel_elm_2),
        ]
        oxml_fromstring.assert_called_once_with(rels_item_xml)
        assert _SerializedRelationship_.call_args_list == expected_calls
        assert isinstance(srels, _SerializedRelationshipCollection)

    def it_should_be_iterable(self):
        srels = _SerializedRelationshipCollection()
        try:
            for x in srels:
                pass
        except TypeError:
            msg = "_SerializedRelationshipCollection object is not iterable"
            pytest.fail(msg)

########NEW FILE########
__FILENAME__ = test_pkgwriter
# encoding: utf-8

"""
Test suite for opc.pkgwriter module
"""

import pytest

from mock import call, MagicMock, Mock, patch

from pptx.opc.constants import CONTENT_TYPE as CT
from pptx.opc.package import Part
from pptx.opc.packuri import PackURI
from pptx.opc.pkgwriter import _ContentTypesItem, PackageWriter

from .unitdata.types import a_Default, a_Types, an_Override
from ..unitutil import function_mock, instance_mock, method_mock


class DescribePackageWriter(object):

    def it_can_write_a_package(self, PhysPkgWriter_, _write_methods):
        # mockery ----------------------
        pkg_file = Mock(name='pkg_file')
        pkg_rels = Mock(name='pkg_rels')
        parts = Mock(name='parts')
        phys_writer = PhysPkgWriter_.return_value
        # exercise ---------------------
        PackageWriter.write(pkg_file, pkg_rels, parts)
        # verify -----------------------
        expected_calls = [
            call._write_content_types_stream(phys_writer, parts),
            call._write_pkg_rels(phys_writer, pkg_rels),
            call._write_parts(phys_writer, parts),
        ]
        PhysPkgWriter_.assert_called_once_with(pkg_file)
        assert _write_methods.mock_calls == expected_calls
        phys_writer.close.assert_called_once_with()

    def it_can_write_a_content_types_stream(
            self, xml_for, serialize_part_xml_):
        # mockery ----------------------
        phys_writer = Mock(name='phys_writer')
        parts = Mock(name='parts')
        # exercise ---------------------
        PackageWriter._write_content_types_stream(phys_writer, parts)
        # verify -----------------------
        xml_for.assert_called_once_with(parts)
        serialize_part_xml_.assert_called_once_with(xml_for.return_value)
        phys_writer.write.assert_called_once_with(
            '/[Content_Types].xml', serialize_part_xml_.return_value
        )

    def it_can_write_a_pkg_rels_item(self):
        # mockery ----------------------
        phys_writer = Mock(name='phys_writer')
        pkg_rels = Mock(name='pkg_rels')
        # exercise ---------------------
        PackageWriter._write_pkg_rels(phys_writer, pkg_rels)
        # verify -----------------------
        phys_writer.write.assert_called_once_with('/_rels/.rels',
                                                  pkg_rels.xml)

    def it_can_write_a_list_of_parts(self):
        # mockery ----------------------
        phys_writer = Mock(name='phys_writer')
        rels = MagicMock(name='rels')
        rels.__len__.return_value = 1
        part1 = Mock(name='part1', _rels=rels)
        part2 = Mock(name='part2', _rels=[])
        # exercise ---------------------
        PackageWriter._write_parts(phys_writer, [part1, part2])
        # verify -----------------------
        expected_calls = [
            call(part1.partname, part1.blob),
            call(part1.partname.rels_uri, part1._rels.xml),
            call(part2.partname, part2.blob),
        ]
        assert phys_writer.write.mock_calls == expected_calls

    # fixtures ---------------------------------------------

    @pytest.fixture
    def PhysPkgWriter_(self, request):
        _patch = patch('pptx.opc.pkgwriter.PhysPkgWriter')
        request.addfinalizer(_patch.stop)
        return _patch.start()

    @pytest.fixture
    def serialize_part_xml_(self, request):
        return function_mock(
            request, 'pptx.opc.pkgwriter.serialize_part_xml'
        )

    @pytest.fixture
    def _write_methods(self, request):
        """Mock that patches all the _write_* methods of PackageWriter"""
        root_mock = Mock(name='PackageWriter')
        patch1 = patch.object(PackageWriter, '_write_content_types_stream')
        patch2 = patch.object(PackageWriter, '_write_pkg_rels')
        patch3 = patch.object(PackageWriter, '_write_parts')
        root_mock.attach_mock(patch1.start(), '_write_content_types_stream')
        root_mock.attach_mock(patch2.start(), '_write_pkg_rels')
        root_mock.attach_mock(patch3.start(), '_write_parts')

        def fin():
            patch1.stop()
            patch2.stop()
            patch3.stop()

        request.addfinalizer(fin)
        return root_mock

    @pytest.fixture
    def xml_for(self, request):
        return method_mock(request, _ContentTypesItem, 'xml_for')


class Describe_ContentTypesItem(object):

    def it_can_compose_content_types_xml(self, xml_for_fixture):
        parts, expected_xml = xml_for_fixture
        types_elm = _ContentTypesItem.xml_for(parts)
        assert types_elm.xml == expected_xml

    # fixtures ---------------------------------------------

    def _mock_part(self, request, name, partname_str, content_type):
        partname = PackURI(partname_str)
        return instance_mock(
            request, Part, name=name, partname=partname,
            content_type=content_type
        )

    @pytest.fixture(params=[
        ('Default',  '/ppt/MEDIA/image.PNG',   CT.PNG),
        ('Default',  '/ppt/media/image.xml',   CT.XML),
        ('Default',  '/ppt/media/image.rels',  CT.OPC_RELATIONSHIPS),
        ('Default',  '/ppt/media/image.jpeg',  CT.JPEG),
        ('Override', '/docProps/core.xml',     'app/vnd.core'),
        ('Override', '/ppt/slides/slide1.xml', 'app/vnd.ct_sld'),
        ('Override', '/zebra/foo.bar',         'app/vnd.foobar'),
    ])
    def xml_for_fixture(self, request):
        elm_type, partname_str, content_type = request.param
        part_ = self._mock_part(request, 'part_', partname_str, content_type)
        # expected_xml -----------------
        types_bldr = a_Types().with_nsdecls()
        ext = partname_str.split('.')[-1].lower()
        if elm_type == 'Default' and ext not in ('rels', 'xml'):
            default_bldr = a_Default()
            default_bldr.with_Extension(ext)
            default_bldr.with_ContentType(content_type)
            types_bldr.with_child(default_bldr)

        types_bldr.with_child(
            a_Default().with_Extension('rels')
                       .with_ContentType(CT.OPC_RELATIONSHIPS)
        )
        types_bldr.with_child(
            a_Default().with_Extension('xml').with_ContentType(CT.XML)
        )

        if elm_type == 'Override':
            override_bldr = an_Override()
            override_bldr.with_PartName(partname_str)
            override_bldr.with_ContentType(content_type)
            types_bldr.with_child(override_bldr)

        expected_xml = types_bldr.xml()
        return [part_], expected_xml

########NEW FILE########
__FILENAME__ = test_rels
# encoding: utf-8

"""Test suite for pptx.part module."""

from __future__ import absolute_import

import pytest

from mock import call, Mock, patch, PropertyMock

from pptx.opc.constants import RELATIONSHIP_TYPE as RT
from pptx.opc.oxml import CT_Relationships
from pptx.opc.package import Part, _Relationship, RelationshipCollection
from pptx.opc.packuri import PackURI

from ..unitutil import class_mock, instance_mock, loose_mock


class Describe_Relationship(object):

    def it_remembers_construction_values(self):
        # test data --------------------
        rId = 'rId9'
        reltype = 'reltype'
        target = Mock(name='target_part')
        external = False
        # exercise ---------------------
        rel = _Relationship(rId, reltype, target, None, external)
        # verify -----------------------
        assert rel.rId == rId
        assert rel.reltype == reltype
        assert rel.target_part == target
        assert rel.is_external == external

    def it_should_raise_on_target_part_access_on_external_rel(self):
        rel = _Relationship(None, None, None, None, external=True)
        with pytest.raises(ValueError):
            rel.target_part

    def it_should_have_target_ref_for_external_rel(self):
        rel = _Relationship(None, None, 'target', None, external=True)
        assert rel.target_ref == 'target'

    def it_should_have_relative_ref_for_internal_rel(self):
        """
        Internal relationships (TargetMode == 'Internal' in the XML) should
        have a relative ref, e.g. '../slideLayouts/slideLayout1.xml', for
        the target_ref attribute.
        """
        part = Mock(name='part', partname=PackURI('/ppt/media/image1.png'))
        baseURI = '/ppt/slides'
        rel = _Relationship(None, None, part, baseURI)  # external=False
        assert rel.target_ref == '../media/image1.png'


class DescribeRelationshipCollection(object):

    def it_also_has_dict_style_get_rel_by_rId(self, rels_with_known_rel):
        rels, rId, known_rel = rels_with_known_rel
        assert rels[rId] == known_rel

    def it_should_raise_on_failed_lookup_by_rId(self, rels):
        with pytest.raises(KeyError):
            rels['rId666']

    def it_has_a_len(self, rels):
        assert len(rels) == 0

    def it_can_add_a_relationship(self, _Relationship_):
        baseURI, rId, reltype, target, is_external = (
            'baseURI', 'rId9', 'reltype', 'target', False
        )
        rels = RelationshipCollection(baseURI)
        rel = rels.add_relationship(reltype, target, rId, is_external)
        _Relationship_.assert_called_once_with(
            rId, reltype, target, baseURI, is_external
        )
        assert rels[rId] == rel
        assert rel == _Relationship_.return_value

    def it_can_add_a_relationship_if_not_found(
            self, rels_with_matching_rel_, rels_with_missing_rel_):

        rels, reltype, part, matching_rel = rels_with_matching_rel_
        assert rels.get_or_add(reltype, part) == matching_rel

        rels, reltype, part, new_rel = rels_with_missing_rel_
        assert rels.get_or_add(reltype, part) == new_rel

    def it_knows_the_next_available_rId(self, rels_with_rId_gap):
        rels, expected_next_rId = rels_with_rId_gap
        next_rId = rels._next_rId
        assert next_rId == expected_next_rId

    def it_can_find_a_related_part_by_reltype(
            self, rels_with_target_known_by_reltype):
        rels, reltype, known_target_part = rels_with_target_known_by_reltype
        part = rels.part_with_reltype(reltype)
        assert part is known_target_part

    def it_can_find_a_related_part_by_rId(self, rels_with_known_target_part):
        rels, rId, known_target_part = rels_with_known_target_part
        part = rels.related_parts[rId]
        assert part is known_target_part

    def it_raises_KeyError_on_part_with_rId_not_found(self, rels):
        with pytest.raises(KeyError):
            rels.related_parts['rId666']

    def it_can_compose_rels_xml(self, rels_with_known_rels, rels_elm):
        rels_with_known_rels.xml
        rels_elm.assert_has_calls(
            [
                call.add_rel(
                    'rId1', 'http://rt-hyperlink', 'http://some/link', True
                ),
                call.add_rel(
                    'rId2', 'http://rt-image', '../media/image1.png', False
                ),
                call.xml()
            ],
            any_order=True
        )

    # def it_raises_on_add_rel_with_duplicate_rId(self, rels, rel):
    #     with pytest.raises(ValueError):
    #         rels.add_rel(rel)

    # fixtures ---------------------------------------------

    @pytest.fixture
    def _Relationship_(self, request):
        return class_mock(request, 'pptx.opc.package._Relationship')

    @pytest.fixture
    def rel(self, _rId, _reltype, _target_part, _baseURI):
        return _Relationship(_rId, _reltype, _target_part, _baseURI)

    @pytest.fixture
    def rels(self, _baseURI):
        return RelationshipCollection(_baseURI)

    @pytest.fixture
    def rels_elm(self, request):
        """
        Return a rels_elm mock that will be returned from
        CT_Relationships.new()
        """
        # create rels_elm mock with a .xml property
        rels_elm = Mock(name='rels_elm')
        xml = PropertyMock(name='xml')
        type(rels_elm).xml = xml
        rels_elm.attach_mock(xml, 'xml')
        rels_elm.reset_mock()  # to clear attach_mock call
        # patch CT_Relationships to return that rels_elm
        patch_ = patch.object(CT_Relationships, 'new', return_value=rels_elm)
        patch_.start()
        request.addfinalizer(patch_.stop)
        return rels_elm

    @pytest.fixture
    def rels_with_known_rel(self, rels, _rId, rel):
        rels[_rId] = rel
        return rels, _rId, rel

    @pytest.fixture
    def rels_with_known_rels(self):
        """
        Populated RelationshipCollection instance that will exercise the
        rels.xml property.
        """
        rels = RelationshipCollection('/baseURI')
        rels.add_relationship(
            reltype='http://rt-hyperlink', target='http://some/link',
            rId='rId1', is_external=True
        )
        part = Mock(name='part')
        part.partname.relative_ref.return_value = '../media/image1.png'
        rels.add_relationship(reltype='http://rt-image', target=part,
                              rId='rId2')
        return rels

    @pytest.fixture
    def rels_with_known_target_part(self, rels, _rel_with_known_target_part):
        rel, rId, target_part = _rel_with_known_target_part
        rels.add_relationship(None, target_part, rId)
        return rels, rId, target_part

    @pytest.fixture
    def rels_with_matching_rel_(self, request, rels):
        matching_reltype_ = instance_mock(
            request, str, name='matching_reltype_'
        )
        matching_part_ = instance_mock(
            request, Part, name='matching_part_'
        )
        matching_rel_ = instance_mock(
            request, _Relationship, name='matching_rel_',
            reltype=matching_reltype_, target_part=matching_part_,
            is_external=False
        )
        rels[1] = matching_rel_
        return rels, matching_reltype_, matching_part_, matching_rel_

    @pytest.fixture
    def rels_with_missing_rel_(self, request, rels, _Relationship_):
        missing_reltype_ = instance_mock(
            request, str, name='missing_reltype_'
        )
        missing_part_ = instance_mock(
            request, Part, name='missing_part_'
        )
        new_rel_ = instance_mock(
            request, _Relationship, name='new_rel_',
            reltype=missing_reltype_, target_part=missing_part_,
            is_external=False
        )
        _Relationship_.return_value = new_rel_
        return rels, missing_reltype_, missing_part_, new_rel_

    @pytest.fixture
    def rels_with_rId_gap(self, request, rels):
        rel_with_rId1 = instance_mock(
            request, _Relationship, name='rel_with_rId1', rId='rId1'
        )
        rel_with_rId3 = instance_mock(
            request, _Relationship, name='rel_with_rId3', rId='rId3'
        )
        rels['rId1'] = rel_with_rId1
        rels['rId3'] = rel_with_rId3
        return rels, 'rId2'

    @pytest.fixture
    def rels_with_target_known_by_reltype(
            self, rels, _rel_with_target_known_by_reltype):
        rel, reltype, target_part = _rel_with_target_known_by_reltype
        rels[1] = rel
        return rels, reltype, target_part

    @pytest.fixture
    def _baseURI(self):
        return '/baseURI'

    @pytest.fixture
    def _rel_with_known_target_part(
            self, _rId, _reltype, _target_part, _baseURI):
        rel = _Relationship(_rId, _reltype, _target_part, _baseURI)
        return rel, _rId, _target_part

    @pytest.fixture
    def _rel_with_target_known_by_reltype(
            self, _rId, _reltype, _target_part, _baseURI):
        rel = _Relationship(_rId, _reltype, _target_part, _baseURI)
        return rel, _reltype, _target_part

    @pytest.fixture
    def _reltype(self):
        return RT.SLIDE

    @pytest.fixture
    def _rId(self):
        return 'rId6'

    @pytest.fixture
    def _target_part(self, request):
        return loose_mock(request)

########NEW FILE########
__FILENAME__ = rels
# encoding: utf-8

"""
Test data for relationship-related unit tests.
"""

from __future__ import absolute_import

from pptx.opc.constants import RELATIONSHIP_TYPE as RT
from pptx.opc.package import RelationshipCollection

from pptx.opc.constants import NAMESPACE as NS
from pptx.opc.oxml import oxml_fromstring


class BaseBuilder(object):
    """
    Provides common behavior for all data builders.
    """
    @property
    def element(self):
        """Return element based on XML generated by builder"""
        return oxml_fromstring(self.xml)

    def with_indent(self, indent):
        """Add integer *indent* spaces at beginning of element XML"""
        self._indent = indent
        return self


class RelationshipCollectionBuilder(object):
    """Builder class for test RelationshipCollections"""
    partname_tmpls = {
        RT.SLIDE_MASTER: '/ppt/slideMasters/slideMaster%d.xml',
        RT.SLIDE:        '/ppt/slides/slide%d.xml',
    }

    def __init__(self):
        self.relationships = []
        self.next_rel_num = 1
        self.next_partnums = {}

    def _next_partnum(self, reltype):
        if reltype not in self.next_partnums:
            self.next_partnums[reltype] = 1
        partnum = self.next_partnums[reltype]
        self.next_partnums[reltype] = partnum + 1
        return partnum

    @property
    def next_rId(self):
        rId = 'rId%d' % self.next_rel_num
        self.next_rel_num += 1
        return rId

    def _next_tuple_partname(self, reltype):
        partname_tmpl = self.partname_tmpls[reltype]
        partnum = self._next_partnum(reltype)
        return partname_tmpl % partnum

    def build(self):
        rels = RelationshipCollection()
        for rel in self.relationships:
            rels.add_rel(rel)
        return rels


class CT_DefaultBuilder(BaseBuilder):
    """
    Test data builder for CT_Default (Default) XML element that appears in
    `[Content_Types].xml`.
    """
    def __init__(self):
        """Establish instance variables with default values"""
        self._content_type = 'application/xml'
        self._extension = 'xml'
        self._indent = 0
        self._namespace = ' xmlns="%s"' % NS.OPC_CONTENT_TYPES

    def with_content_type(self, content_type):
        """Set ContentType attribute to *content_type*"""
        self._content_type = content_type
        return self

    def with_extension(self, extension):
        """Set Extension attribute to *extension*"""
        self._extension = extension
        return self

    def without_namespace(self):
        """Don't include an 'xmlns=' attribute"""
        self._namespace = ''
        return self

    @property
    def xml(self):
        """Return Default element"""
        tmpl = '%s<Default%s Extension="%s" ContentType="%s"/>\n'
        indent = ' ' * self._indent
        return tmpl % (indent, self._namespace, self._extension,
                       self._content_type)


class CT_OverrideBuilder(BaseBuilder):
    """
    Test data builder for CT_Override (Override) XML element that appears in
    `[Content_Types].xml`.
    """
    def __init__(self):
        """Establish instance variables with default values"""
        self._content_type = 'app/vnd.type'
        self._indent = 0
        self._namespace = ' xmlns="%s"' % NS.OPC_CONTENT_TYPES
        self._partname = '/part/name.xml'

    def with_content_type(self, content_type):
        """Set ContentType attribute to *content_type*"""
        self._content_type = content_type
        return self

    def with_partname(self, partname):
        """Set PartName attribute to *partname*"""
        self._partname = partname
        return self

    def without_namespace(self):
        """Don't include an 'xmlns=' attribute"""
        self._namespace = ''
        return self

    @property
    def xml(self):
        """Return Override element"""
        tmpl = '%s<Override%s PartName="%s" ContentType="%s"/>\n'
        indent = ' ' * self._indent
        return tmpl % (indent, self._namespace, self._partname,
                       self._content_type)


class CT_RelationshipBuilder(BaseBuilder):
    """
    Test data builder for CT_Relationship (Relationship) XML element that
    appears in .rels files
    """
    def __init__(self):
        """Establish instance variables with default values"""
        self._rId = 'rId9'
        self._reltype = 'ReLtYpE'
        self._target = 'docProps/core.xml'
        self._target_mode = None
        self._indent = 0
        self._namespace = ' xmlns="%s"' % NS.OPC_RELATIONSHIPS

    def with_rId(self, rId):
        """Set Id attribute to *rId*"""
        self._rId = rId
        return self

    def with_reltype(self, reltype):
        """Set Type attribute to *reltype*"""
        self._reltype = reltype
        return self

    def with_target(self, target):
        """Set XXX attribute to *target*"""
        self._target = target
        return self

    def with_target_mode(self, target_mode):
        """Set TargetMode attribute to *target_mode*"""
        self._target_mode = None if target_mode == 'Internal' else target_mode
        return self

    def without_namespace(self):
        """Don't include an 'xmlns=' attribute"""
        self._namespace = ''
        return self

    @property
    def target_mode(self):
        if self._target_mode is None:
            return ''
        return ' TargetMode="%s"' % self._target_mode

    @property
    def xml(self):
        """Return Relationship element"""
        tmpl = '%s<Relationship%s Id="%s" Type="%s" Target="%s"%s/>\n'
        indent = ' ' * self._indent
        return tmpl % (indent, self._namespace, self._rId, self._reltype,
                       self._target, self.target_mode)


class CT_RelationshipsBuilder(BaseBuilder):
    """
    Test data builder for CT_Relationships (Relationships) XML element, the
    root element in .rels files.
    """
    def __init__(self):
        """Establish instance variables with default values"""
        self._rels = (
            ('rId1', 'http://reltype1', 'docProps/core.xml',    'Internal'),
            ('rId2', 'http://linktype', 'http://some/link',     'External'),
            ('rId3', 'http://reltype2', '../slides/slide1.xml', 'Internal'),
        )

    @property
    def xml(self):
        """
        Return XML string based on settings accumulated via method calls.
        """
        xml = '<Relationships xmlns="%s">\n' % NS.OPC_RELATIONSHIPS
        for rId, reltype, target, target_mode in self._rels:
            xml += (a_Relationship().with_rId(rId)
                                    .with_reltype(reltype)
                                    .with_target(target)
                                    .with_target_mode(target_mode)
                                    .with_indent(2)
                                    .without_namespace()
                                    .xml)
        xml += '</Relationships>\n'
        return xml


class CT_TypesBuilder(BaseBuilder):
    """
    Test data builder for CT_Types (<Types>) XML element, the root element in
    [Content_Types].xml files
    """
    def __init__(self):
        """Establish instance variables with default values"""
        self._defaults = (
            ('xml', 'application/xml'),
            ('jpeg', 'image/jpeg'),
        )
        self._empty = False
        self._overrides = (
            ('/docProps/core.xml', 'app/vnd.type1'),
            ('/ppt/presentation.xml', 'app/vnd.type2'),
            ('/docProps/thumbnail.jpeg', 'image/jpeg'),
        )

    def empty(self):
        self._empty = True
        return self

    @property
    def xml(self):
        """
        Return XML string based on settings accumulated via method calls
        """
        if self._empty:
            return '<Types xmlns="%s"/>\n' % NS.OPC_CONTENT_TYPES

        xml = '<Types xmlns="%s">\n' % NS.OPC_CONTENT_TYPES
        for extension, content_type in self._defaults:
            xml += (a_Default().with_extension(extension)
                               .with_content_type(content_type)
                               .with_indent(2)
                               .without_namespace()
                               .xml)
        for partname, content_type in self._overrides:
            xml += (an_Override().with_partname(partname)
                                 .with_content_type(content_type)
                                 .with_indent(2)
                                 .without_namespace()
                                 .xml)
        xml += '</Types>\n'
        return xml


def a_Default():
    return CT_DefaultBuilder()


def a_Relationship():
    return CT_RelationshipBuilder()


def a_Relationships():
    return CT_RelationshipsBuilder()


def a_rels():
    return RelationshipCollectionBuilder()


def a_Types():
    return CT_TypesBuilder()


def an_Override():
    return CT_OverrideBuilder()

########NEW FILE########
__FILENAME__ = types
# encoding: utf-8

"""
XML test data builders for [Content_Types].xml elements
"""

from __future__ import absolute_import, print_function, unicode_literals

from pptx.opc.oxml import nsmap

from ...unitdata import BaseBuilder


class CT_DefaultBuilder(BaseBuilder):
    __tag__ = 'Default'
    __nspfxs__ = ('ct',)
    __attrs__ = ('Extension', 'ContentType')


class CT_OverrideBuilder(BaseBuilder):
    __tag__ = 'Override'
    __nspfxs__ = ('ct',)
    __attrs__ = ('PartName', 'ContentType')


class CT_TypesBuilder(BaseBuilder):
    __tag__ = 'Types'
    __nspfxs__ = ('ct',)
    __attrs__ = ()

    def with_nsdecls(self, *nspfxs):
        self._nsdecls = ' xmlns="%s"' % nsmap['ct']
        return self


def a_Default():
    return CT_DefaultBuilder()


def a_Types():
    return CT_TypesBuilder()


def an_Override():
    return CT_OverrideBuilder()

########NEW FILE########
__FILENAME__ = test_autoshape
# encoding: utf-8

"""Test suite for pptx.oxml.autoshape module."""

from __future__ import absolute_import

import pytest

from hamcrest import assert_that, equal_to, instance_of, is_, none

from pptx.oxml.ns import nsdecls
from pptx.oxml.shapes.autoshape import CT_PresetGeometry2D, CT_Shape
from pptx.oxml.shapes.shared import (
    CT_ShapeProperties, ST_Direction, ST_PlaceholderSize, ST_PlaceholderType
)

from ..unitdata.shape import (
    a_gd, a_prstGeom, an_avLst, an_spPr, test_shape_elements
)
from ...unitutil import actual_xml, TestCase


class DescribeCT_PresetGeometry2D(object):

    def it_can_get_the_list_of_gd_elms(self):
        # fixture ----------------------
        gd_1_bldr = a_gd().with_name('adj1').with_fmla('val 111')
        gd_2_bldr = a_gd().with_name('adj2').with_fmla('val 222')
        gd_3_bldr = a_gd().with_name('adj3').with_fmla('val 333')
        gd_4_bldr = a_gd().with_name('adj4').with_fmla('val 444')
        gd_5_bldr = a_gd().with_name('adj5').with_fmla('val 555')

        empty_prstGeom_bldr = a_prstGeom().with_nsdecls()

        single_gd_prstGeom_bldr = (
            a_prstGeom()
            .with_nsdecls()
            .with_child(
                an_avLst()
                .with_child(gd_1_bldr)
            )
        )

        long_prstGeom_bldr = (
            a_prstGeom()
            .with_nsdecls()
            .with_child(
                an_avLst()
                .with_child(gd_2_bldr)
                .with_child(gd_3_bldr)
                .with_child(gd_4_bldr)
                .with_child(gd_5_bldr)
            )
        )
        cases = (
            (empty_prstGeom_bldr, ()),
            (single_gd_prstGeom_bldr, ((111, 'adj1'),)),
            (long_prstGeom_bldr,
             ((222, 'adj2'), (333, 'adj3'), (444, 'adj4'), (555, 'adj5'))),
        )
        for prstGeom_builder, expected_vals in cases:
            prstGeom = prstGeom_builder.element
            # exercise -----------------
            gd_elms = prstGeom.gd
            # verify -------------------
            assert_that(isinstance(gd_elms, tuple))
            assert_that(len(gd_elms), is_(equal_to(len(expected_vals))))
            for idx, gd_elm in enumerate(gd_elms):
                val, name = expected_vals[idx]
                fmla = 'val %d' % val
                assert_that(gd_elm.get('name'), is_(equal_to(name)))
                assert_that(gd_elm.get('fmla'), is_(equal_to(fmla)))

    def it_can_rewrite_the_gd_elms(self, rewrite_guides_fixture_):
        prstGeom, guides, expected_xml = rewrite_guides_fixture_
        prstGeom.rewrite_guides(guides)
        assert actual_xml(prstGeom) == expected_xml

    # fixture --------------------------------------------------------

    def _rewrite_guides_cases():
        return [
            # all five guides for five adj shape
            ('circularArrow', 5),
            # empty guides for single adj shape
            ('chevron', 0),
            # one guide for single adj shape
            ('chevron', 1),
        ]

    @pytest.fixture(params=_rewrite_guides_cases())
    def rewrite_guides_fixture_(self, request):
        prst, gd_count = request.param

        avLst_before_bldr = an_avLst()
        avLst_after_bldr = an_avLst()
        guides = []

        for n in range(1, gd_count+1):
            name = 'adj%d' % n
            val_before = n * 111
            val_after = val_before + 100
            fmla_before = 'val %d' % val_before
            fmla_after = 'val %d' % val_after

            gd_before_bldr = a_gd().with_name(name).with_fmla(fmla_before)
            gd_after_bldr = a_gd().with_name(name).with_fmla(fmla_after)

            avLst_before_bldr.with_child(gd_before_bldr)
            avLst_after_bldr.with_child(gd_after_bldr)

            guides.append((name, val_after))

        prstGeom_before_bldr = (
            a_prstGeom().with_nsdecls()
                        .with_prst(prst)
                        .with_child(avLst_before_bldr)
        )
        prstGeom_after_bldr = (
            a_prstGeom().with_nsdecls()
                        .with_prst(prst)
                        .with_child(avLst_after_bldr)
        )

        prstGeom = prstGeom_before_bldr.element
        expected_xml = prstGeom_after_bldr.xml()

        return prstGeom, tuple(guides), expected_xml


class DescribeCT_ShapeProperties(object):

    def it_is_used_by_the_parser_for_an_spPr_element(self, spPr):
        assert isinstance(spPr, CT_ShapeProperties)

    # fixtures ---------------------------------------------

    @pytest.fixture
    def spPr(self):
        return an_spPr().with_nsdecls().element


class TestCT_Shape(TestCase):
    """Test CT_Shape"""
    def test_is_autoshape_distinguishes_auto_shape(self):
        """CT_Shape.is_autoshape distinguishes auto shape"""
        # setup ------------------------
        autoshape = test_shape_elements.autoshape
        placeholder = test_shape_elements.placeholder
        textbox = test_shape_elements.textbox
        # verify -----------------------
        assert_that(autoshape.is_autoshape, is_(True))
        assert_that(placeholder.is_autoshape, is_(False))
        assert_that(textbox.is_autoshape, is_(False))

    def test_is_placeholder_distinguishes_placeholder(self):
        """CT_Shape.is_autoshape distinguishes placeholder"""
        # setup ------------------------
        autoshape = test_shape_elements.autoshape
        placeholder = test_shape_elements.placeholder
        textbox = test_shape_elements.textbox
        # verify -----------------------
        assert_that(autoshape.is_autoshape, is_(True))
        assert_that(placeholder.is_autoshape, is_(False))
        assert_that(textbox.is_autoshape, is_(False))

    def test_is_textbox_distinguishes_text_box(self):
        """CT_Shape.is_textbox distinguishes text box"""
        # setup ------------------------
        autoshape = test_shape_elements.autoshape
        placeholder = test_shape_elements.placeholder
        textbox = test_shape_elements.textbox
        # verify -----------------------
        assert_that(autoshape.is_textbox, is_(False))
        assert_that(placeholder.is_textbox, is_(False))
        assert_that(textbox.is_textbox, is_(True))

    def test_new_autoshape_sp_generates_correct_xml(self):
        """CT_Shape._new_autoshape_sp() returns correct XML"""
        # setup ------------------------
        id_ = 9
        name = 'Rounded Rectangle 8'
        prst = 'roundRect'
        left, top, width, height = 111, 222, 333, 444
        xml = (
            '<p:sp %s>\n  <p:nvSpPr>\n    <p:cNvPr id="%d" name="%s"/>\n    <'
            'p:cNvSpPr/>\n    <p:nvPr/>\n  </p:nvSpPr>\n  <p:spPr>\n    <a:xf'
            'rm>\n      <a:off x="%d" y="%d"/>\n      <a:ext cx="%d" cy="%d"/'
            '>\n    </a:xfrm>\n    <a:prstGeom prst="%s">\n      <a:avLst/>\n'
            '    </a:prstGeom>\n  </p:spPr>\n  <p:style>\n    <a:lnRef idx="1'
            '">\n      <a:schemeClr val="accent1"/>\n    </a:lnRef>\n    <a:f'
            'illRef idx="3">\n      <a:schemeClr val="accent1"/>\n    </a:fil'
            'lRef>\n    <a:effectRef idx="2">\n      <a:schemeClr val="accent'
            '1"/>\n    </a:effectRef>\n    <a:fontRef idx="minor">\n      <a:'
            'schemeClr val="lt1"/>\n    </a:fontRef>\n  </p:style>\n  <p:txBo'
            'dy>\n    <a:bodyPr rtlCol="0" anchor="ctr"/>\n    <a:lstStyle/>'
            '\n    <a:p>\n      <a:pPr algn="ctr"/>\n    </a:p>\n  </p:txBody'
            '>\n</p:sp>\n' %
            (nsdecls('a', 'p'), id_, name, left, top, width, height, prst)
        )
        # exercise ---------------------
        sp = CT_Shape.new_autoshape_sp(id_, name, prst, left, top,
                                       width, height)
        # verify -----------------------
        self.assertEqualLineByLine(xml, sp)

    def test_new_placeholder_sp_generates_correct_xml(self):
        """CT_Shape._new_placeholder_sp() returns correct XML"""
        # setup ------------------------
        expected_xml_tmpl = (
            '<p:sp %s>\n  <p:nvSpPr>\n    <p:cNvPr id="%s" name="%s"/>\n    <'
            'p:cNvSpPr>\n      <a:spLocks noGrp="1"/>\n    </p:cNvSpPr>\n    '
            '<p:nvPr>\n      <p:ph%s/>\n    </p:nvPr>\n  </p:nvSpPr>\n  <p:sp'
            'Pr/>\n%s</p:sp>\n' % (nsdecls('a', 'p'), '%d', '%s', '%s', '%s')
        )
        txBody_snippet = (
            '  <p:txBody>\n    <a:bodyPr/>\n    <a:lstStyle/>\n    <a:p/>\n  '
            '</p:txBody>\n')
        test_cases = (
            (2, 'Title 1', ST_PlaceholderType.CTR_TITLE, ST_Direction.HORZ,
             ST_PlaceholderSize.FULL, 0),
            (3, 'Date Placeholder 2', ST_PlaceholderType.DT,
             ST_Direction.HORZ, ST_PlaceholderSize.HALF, 10),
            (4, 'Vertical Subtitle 3', ST_PlaceholderType.SUB_TITLE,
             ST_Direction.VERT, ST_PlaceholderSize.FULL, 1),
            (5, 'Table Placeholder 4', ST_PlaceholderType.TBL,
             ST_Direction.HORZ, ST_PlaceholderSize.QUARTER, 14),
            (6, 'Slide Number Placeholder 5', ST_PlaceholderType.SLD_NUM,
             ST_Direction.HORZ, ST_PlaceholderSize.QUARTER, 12),
            (7, 'Footer Placeholder 6', ST_PlaceholderType.FTR,
             ST_Direction.HORZ, ST_PlaceholderSize.QUARTER, 11),
            (8, 'Content Placeholder 7', ST_PlaceholderType.OBJ,
             ST_Direction.HORZ, ST_PlaceholderSize.FULL, 15)
        )
        expected_values = (
            (2, 'Title 1', ' type="%s"' % ST_PlaceholderType.CTR_TITLE,
             txBody_snippet),
            (3, 'Date Placeholder 2', ' type="%s" sz="half" idx="10"' %
             ST_PlaceholderType.DT, ''),
            (4, 'Vertical Subtitle 3', ' type="%s" orient="vert" idx="1"' %
             ST_PlaceholderType.SUB_TITLE, txBody_snippet),
            (5, 'Table Placeholder 4', ' type="%s" sz="quarter" idx="14"' %
             ST_PlaceholderType.TBL, ''),
            (6, 'Slide Number Placeholder 5', ' type="%s" sz="quarter" '
             'idx="12"' % ST_PlaceholderType.SLD_NUM, ''),
            (7, 'Footer Placeholder 6', ' type="%s" sz="quarter" idx="11"' %
             ST_PlaceholderType.FTR, ''),
            (8, 'Content Placeholder 7', ' idx="15"', txBody_snippet)
        )
        # exercise ---------------------
        for case_idx, argv in enumerate(test_cases):
            id_, name, ph_type, orient, sz, idx = argv
            sp = CT_Shape.new_placeholder_sp(id_, name, ph_type, orient, sz,
                                             idx)
            # verify ------------------
            expected_xml = expected_xml_tmpl % expected_values[case_idx]
            self.assertEqualLineByLine(expected_xml, sp)

    def test_new_textbox_sp_generates_correct_xml(self):
        """CT_Shape.new_textbox_sp() returns correct XML"""
        # setup ------------------------
        id_ = 9
        name = 'TextBox 8'
        left, top, width, height = 111, 222, 333, 444
        xml = (
            '<p:sp %s>\n  <p:nvSpPr>\n    <p:cNvPr id="%d" name="%s"/>\n    <'
            'p:cNvSpPr txBox="1"/>\n    <p:nvPr/>\n  </p:nvSpPr>\n  <p:spPr>'
            '\n    <a:xfrm>\n      <a:off x="%d" y="%d"/>\n      <a:ext cx="%'
            'd" cy="%d"/>\n    </a:xfrm>\n    <a:prstGeom prst="rect">\n     '
            ' <a:avLst/>\n    </a:prstGeom>\n    <a:noFill/>\n  </p:spPr>\n  '
            '<p:txBody>\n    <a:bodyPr wrap="none">\n      <a:spAutoFit/>\n  '
            '  </a:bodyPr>\n    <a:lstStyle/>\n    <a:p/>\n  </p:txBody>\n</p'
            ':sp>\n' %
            (nsdecls('a', 'p'), id_, name, left, top, width, height)
        )
        # exercise ---------------------
        sp = CT_Shape.new_textbox_sp(id_, name, left, top, width, height)
        # verify -----------------------
        self.assertEqualLineByLine(xml, sp)

    def test_prst_return_value(self):
        """CT_Shape.prst value is correct"""
        # setup ------------------------
        rounded_rect_sp = test_shape_elements.rounded_rectangle
        placeholder_sp = test_shape_elements.placeholder
        # verify -----------------------
        assert_that(rounded_rect_sp.prst, is_(equal_to('roundRect')))
        assert_that(placeholder_sp.prst, is_(equal_to(None)))

    def test_prstGeom_return_value(self):
        """CT_Shape.prstGeom value is correct"""
        # setup ------------------------
        rounded_rect_sp = test_shape_elements.rounded_rectangle
        placeholder_sp = test_shape_elements.placeholder
        # verify -----------------------
        assert_that(rounded_rect_sp.prstGeom,
                    instance_of(CT_PresetGeometry2D))
        assert_that(placeholder_sp.prstGeom, is_(none()))

########NEW FILE########
__FILENAME__ = test_graphfrm
# encoding: utf-8

"""Test suite for pptx.oxml.graphfrm module."""

from __future__ import absolute_import

from hamcrest import assert_that, equal_to, is_

from pptx.oxml.ns import nsdecls, qn
from pptx.oxml.shapes.graphfrm import CT_GraphicalObjectFrame

from ...unitutil import TestCase


class TestCT_GraphicalObjectFrame(TestCase):
    """Test CT_GraphicalObjectFrame"""
    def test_has_table_return_value(self):
        """CT_GraphicalObjectFrame.has_table property has correct value"""
        # setup ------------------------
        id_, name = 9, 'Table 8'
        left, top, width, height = 111, 222, 333, 444
        tbl_uri = 'http://schemas.openxmlformats.org/drawingml/2006/table'
        chart_uri = 'http://schemas.openxmlformats.org/drawingml/2006/chart'
        graphicFrame = CT_GraphicalObjectFrame.new_graphicFrame(
            id_, name, left, top, width, height)
        graphicData = graphicFrame[qn('a:graphic')].graphicData
        # verify -----------------------
        graphicData.set('uri', tbl_uri)
        assert_that(graphicFrame.has_table, is_(equal_to(True)))
        graphicData.set('uri', chart_uri)
        assert_that(graphicFrame.has_table, is_(equal_to(False)))

    def test_new_graphicFrame_generates_correct_xml(self):
        """CT_GraphicalObjectFrame.new_graphicFrame() returns correct XML"""
        # setup ------------------------
        id_, name = 9, 'Table 8'
        left, top, width, height = 111, 222, 333, 444
        xml = (
            '<p:graphicFrame %s>\n  <p:nvGraphicFramePr>\n    <p:cNvPr id="%d'
            '" name="%s"/>\n    <p:cNvGraphicFramePr>\n      <a:graphicFrameL'
            'ocks noGrp="1"/>\n    </p:cNvGraphicFramePr>\n    <p:nvPr/>\n  <'
            '/p:nvGraphicFramePr>\n  <p:xfrm>\n    <a:off x="%d" y="%d"/>\n  '
            '  <a:ext cx="%d" cy="%d"/>\n  </p:xfrm>\n  <a:graphic>\n    <a:g'
            'raphicData/>\n  </a:graphic>\n</p:graphicFrame>\n' %
            (nsdecls('a', 'p'), id_, name, left, top, width, height)
        )
        # exercise ---------------------
        graphicFrame = CT_GraphicalObjectFrame.new_graphicFrame(
            id_, name, left, top, width, height)
        # verify -----------------------
        self.assertEqualLineByLine(xml, graphicFrame)

    def test_new_table_generates_correct_xml(self):
        """CT_GraphicalObjectFrame.new_table() returns correct XML"""
        # setup ------------------------
        id_, name = 9, 'Table 8'
        rows, cols = 2, 3
        left, top, width, height = 111, 222, 334, 445
        xml = (
            '<p:graphicFrame %s>\n  <p:nvGraphicFramePr>\n    <p:cNvP''r id="'
            '%d" name="%s"/>\n    <p:cNvGraphicFramePr>\n      <a:graphicFram'
            'eLocks noGrp="1"/>\n    </p:cNvGraphicFramePr>\n    <p:nvPr/>\n '
            ' </p:nvGraphicFramePr>\n  <p:xfrm>\n    <a:off x="%d" y="%d"/>\n'
            '    <a:ext cx="%d" cy="%d"/>\n  </p:xfrm>\n  <a:graphic>\n    <a'
            ':graphicData uri="http://schemas.openxmlformats.org/drawingml/20'
            '06/table">\n      <a:tbl>\n        <a:tblPr firstRow="1" bandRow'
            '="1">\n          <a:tableStyleId>{5C22544A-7EE6-4342-B048-85BDC9'
            'FD1C3A}</a:tableStyleId>\n        </a:tblPr>\n        <a:tblGrid'
            '>\n          <a:gridCol w="111"/>\n          <a:gridCol w="111"/'
            '>\n          <a:gridCol w="112"/>\n        </a:tblGrid>\n       '
            ' <a:tr h="222">\n          <a:tc>\n            <a:txBody>\n     '
            '         <a:bodyPr/>\n              <a:lstStyle/>\n             '
            ' <a:p/>\n            </a:txBody>\n            <a:tcPr/>\n       '
            '   </a:tc>\n          <a:tc>\n            <a:txBody>\n          '
            '    <a:bodyPr/>\n              <a:lstStyle/>\n              <a:p'
            '/>\n            </a:txBody>\n            <a:tcPr/>\n          </'
            'a:tc>\n          <a:tc>\n            <a:txBody>\n              <'
            'a:bodyPr/>\n              <a:lstStyle/>\n              <a:p/>\n '
            '           </a:txBody>\n            <a:tcPr/>\n          </a:tc>'
            '\n        </a:tr>\n        <a:tr h="223">\n          <a:tc>\n   '
            '         <a:txBody>\n              <a:bodyPr/>\n              <a'
            ':lstStyle/>\n              <a:p/>\n            </a:txBody>\n    '
            '        <a:tcPr/>\n          </a:tc>\n          <a:tc>\n        '
            '    <a:txBody>\n              <a:bodyPr/>\n              <a:lstS'
            'tyle/>\n              <a:p/>\n            </a:txBody>\n         '
            '   <a:tcPr/>\n          </a:tc>\n          <a:tc>\n            <'
            'a:txBody>\n              <a:bodyPr/>\n              <a:lstStyle/'
            '>\n              <a:p/>\n            </a:txBody>\n            <a'
            ':tcPr/>\n          </a:tc>\n        </a:tr>\n      </a:tbl>\n   '
            ' </a:graphicData>\n  </a:graphic>\n</p:graphicFrame>\n' %
            (nsdecls('a', 'p'), id_, name, left, top, width, height)
        )
        # exercise ---------------------
        graphicFrame = CT_GraphicalObjectFrame.new_table(
            id_, name, rows, cols, left, top, width, height)
        # verify -----------------------
        self.assertEqualLineByLine(xml, graphicFrame)

########NEW FILE########
__FILENAME__ = test_groupshape
# encoding: utf-8

"""
Test suite for pptx.oxml.shapetree module
"""

from __future__ import absolute_import, print_function

import pytest

from pptx.oxml.shapes.autoshape import CT_Shape
from pptx.oxml.shapes.graphfrm import CT_GraphicalObjectFrame
from pptx.oxml.shapes.groupshape import CT_GroupShape
from pptx.oxml.shapes.picture import CT_Picture

from ..unitdata.shape import an_spTree
from ...unitutil import class_mock, instance_mock, method_mock


class DescribeCT_GroupShape(object):

    def it_can_add_a_graphicFrame_element_containing_a_table(
            self, add_table_fixt):
        spTree, id_, name, rows, cols, x, y, cx, cy = add_table_fixt[:9]
        CT_GraphicalObjectFrame_ = add_table_fixt[9]
        insert_element_before_, graphicFrame_ = add_table_fixt[10:]
        graphicFrame = spTree.add_table(id_, name, rows, cols, x, y, cx, cy)
        CT_GraphicalObjectFrame_.new_table.assert_called_once_with(
            id_, name, rows, cols, x, y, cx, cy
        )
        insert_element_before_.assert_called_once_with(
            graphicFrame_, 'p:extLst'
        )
        assert graphicFrame is graphicFrame_

    def it_can_add_a_pic_element_representing_a_picture(self, add_pic_fixt):
        spTree, id_, name, desc, rId, x, y, cx, cy = add_pic_fixt[:9]
        CT_Picture_, insert_element_before_, pic_ = add_pic_fixt[9:]
        pic = spTree.add_pic(id_, name, desc, rId, x, y, cx, cy)
        CT_Picture_.new_pic.assert_called_once_with(
            id_, name, desc, rId, x, y, cx, cy
        )
        insert_element_before_.assert_called_once_with(pic_, 'p:extLst')
        assert pic is pic_

    def it_can_add_an_sp_element_for_a_placeholder(
            self, add_placeholder_fixt):
        spTree, id_, name, ph_type, orient, sz, idx = add_placeholder_fixt[:7]
        CT_Shape_, insert_element_before_, sp_ = add_placeholder_fixt[7:]
        sp = spTree.add_placeholder(id_, name, ph_type, orient, sz, idx)
        CT_Shape_.new_placeholder_sp.assert_called_once_with(
            id_, name, ph_type, orient, sz, idx
        )
        insert_element_before_.assert_called_once_with(sp_, 'p:extLst')
        assert sp is sp_

    def it_can_add_an_sp_element_for_an_autoshape(self, add_autoshape_fixt):
        spTree, id_, name, prst, x, y, cx, cy = add_autoshape_fixt[:8]
        CT_Shape_, insert_element_before_, sp_ = add_autoshape_fixt[8:]
        sp = spTree.add_autoshape(id_, name, prst, x, y, cx, cy)
        CT_Shape_.new_autoshape_sp.assert_called_once_with(
            id_, name, prst, x, y, cx, cy
        )
        insert_element_before_.assert_called_once_with(sp_, 'p:extLst')
        assert sp is sp_

    def it_can_add_a_textbox_sp_element(self, add_textbox_fixt):
        spTree, id_, name, x, y, cx, cy, CT_Shape_ = add_textbox_fixt[:8]
        insert_element_before_, sp_ = add_textbox_fixt[8:]
        sp = spTree.add_textbox(id_, name, x, y, cx, cy)
        CT_Shape_.new_textbox_sp.assert_called_once_with(
            id_, name, x, y, cx, cy
        )
        insert_element_before_.assert_called_once_with(sp_, 'p:extLst')
        assert sp is sp_

    # fixtures ---------------------------------------------

    @pytest.fixture
    def add_autoshape_fixt(
            self, spTree, CT_Shape_, insert_element_before_, sp_):
        id_, name, prst = 42, 'name', 'prst'
        x, y, cx, cy = 9, 8, 7, 6
        return (
            spTree, id_, name, prst, x, y, cx, cy, CT_Shape_,
            insert_element_before_, sp_
        )

    @pytest.fixture
    def add_pic_fixt(
            self, spTree, CT_Picture_, insert_element_before_, pic_):
        id_, name, desc, rId = 42, 'name', 'desc', 'rId6'
        x, y, cx, cy = 6, 7, 8, 9
        return (
            spTree, id_, name, desc, rId, x, y, cx, cy, CT_Picture_,
            insert_element_before_, pic_
        )

    @pytest.fixture
    def add_placeholder_fixt(
            self, spTree, CT_Shape_, insert_element_before_, sp_):
        id_, name, ph_type = 42, 'name', 'type'
        orient, sz, idx = 'orient', 'sz', 24
        return (
            spTree, id_, name, ph_type, orient, sz, idx, CT_Shape_,
            insert_element_before_, sp_
        )

    @pytest.fixture
    def add_table_fixt(
            self, spTree, CT_GraphicalObjectFrame_,
            insert_element_before_, graphicFrame_):
        id_, name, rows, cols = 42, 'name', 12, 23
        x, y, cx, cy = 5, 4, 3, 2
        return (
            spTree, id_, name, rows, cols, x, y, cx, cy,
            CT_GraphicalObjectFrame_, insert_element_before_, graphicFrame_
        )

    @pytest.fixture
    def add_textbox_fixt(
            self, spTree, CT_Shape_, insert_element_before_, sp_):
        id_, name = 42, 'name'
        x, y, cx, cy = 3, 4, 5, 6
        return (
            spTree, id_, name, x, y, cx, cy, CT_Shape_,
            insert_element_before_, sp_
        )

    # fixture components -----------------------------------

    @pytest.fixture
    def CT_GraphicalObjectFrame_(self, request, graphicFrame_):
        CT_GraphicalObjectFrame_ = class_mock(
            request, 'pptx.oxml.shapes.groupshape.CT_GraphicalObjectFrame'
        )
        CT_GraphicalObjectFrame_.new_table.return_value = graphicFrame_
        return CT_GraphicalObjectFrame_

    @pytest.fixture
    def CT_Picture_(self, request, pic_):
        CT_Picture_ = class_mock(
            request, 'pptx.oxml.shapes.groupshape.CT_Picture'
        )
        CT_Picture_.new_pic.return_value = pic_
        return CT_Picture_

    @pytest.fixture
    def CT_Shape_(self, request, sp_):
        CT_Shape_ = class_mock(
            request, 'pptx.oxml.shapes.groupshape.CT_Shape'
        )
        CT_Shape_.new_autoshape_sp.return_value = sp_
        CT_Shape_.new_placeholder_sp.return_value = sp_
        CT_Shape_.new_textbox_sp.return_value = sp_
        return CT_Shape_

    @pytest.fixture
    def graphicFrame_(self, request):
        return instance_mock(request, CT_GraphicalObjectFrame)

    @pytest.fixture
    def insert_element_before_(self, request):
        return method_mock(request, CT_GroupShape, 'insert_element_before')

    @pytest.fixture
    def pic_(self, request):
        return instance_mock(request, CT_Picture)

    @pytest.fixture
    def sp_(self, request):
        return instance_mock(request, CT_Shape)

    @pytest.fixture
    def spTree(self):
        return an_spTree().with_nsdecls().element

########NEW FILE########
__FILENAME__ = test_picture
# encoding: utf-8

"""Test suite for pptx.oxml.picture module."""

from __future__ import absolute_import

from pptx.oxml.ns import nsdecls
from pptx.oxml.shapes.picture import CT_Picture

from ...unitutil import TestCase


class TestCT_Picture(TestCase):
    """Test CT_Picture"""
    def test_new_pic_generates_correct_xml(self):
        """CT_Picture.new_pic() returns correct XML"""
        # setup ------------------------
        id_, name, desc, rId = 9, 'Picture 8', 'test-image.png', 'rId7'
        left, top, width, height = 111, 222, 333, 444
        xml = (
            '<p:pic %s>\n  <p:nvPicPr>\n    <p:cNvPr id="%d" name="%s" descr='
            '"%s"/>\n    <p:cNvPicPr>\n      <a:picLocks noChangeAspect="1"/>'
            '\n    </p:cNvPicPr>\n    <p:nvPr/>\n  </p:nvPicPr>\n  <p:blipFil'
            'l>\n    <a:blip r:embed="%s"/>\n    <a:stretch>\n      <a:fillRe'
            'ct/>\n    </a:stretch>\n  </p:blipFill>\n  <p:spPr>\n    <a:xfrm'
            '>\n      <a:off x="%d" y="%d"/>\n      <a:ext cx="%d" cy="%d"/>'
            '\n    </a:xfrm>\n    <a:prstGeom prst="rect">\n      <a:avLst/>'
            '\n    </a:prstGeom>\n  </p:spPr>\n</p:pic>\n' %
            (nsdecls('a', 'p', 'r'), id_, name, desc, rId, left, top, width,
             height)
        )
        # exercise ---------------------
        pic = CT_Picture.new_pic(id_, name, desc, rId, left, top,
                                 width, height)
        # verify -----------------------
        self.assertEqualLineByLine(xml, pic)

########NEW FILE########
__FILENAME__ = test_table
# encoding: utf-8

"""Test suite for pptx.oxml.table module."""

from __future__ import absolute_import

from hamcrest import assert_that, equal_to, is_

from pptx.enum.text import MSO_ANCHOR
from pptx.oxml.ns import nsdecls
from pptx.oxml.shapes.table import CT_Table

from ...oxml.unitdata.table import a_tbl, test_table_elements, test_table_xml
from ...unitutil import TestCase


class TestCT_Table(TestCase):
    """Test CT_Table"""
    boolprops = ('bandRow', 'firstRow', 'lastRow',
                 'bandCol', 'firstCol', 'lastCol')

    def test_new_tbl_generates_correct_xml(self):
        """CT_Table._new_tbl() returns correct XML"""
        # setup ------------------------
        rows, cols = 2, 3
        width, height = 334, 445
        xml = (
            '<a:tbl %s>\n  <a:tblPr firstRow="1" bandRow="1">\n    <a:tableSt'
            'yleId>{5C22544A-7EE6-4342-B048-85BDC9FD1C3A}</a:tableStyleId>\n '
            ' </a:tblPr>\n  <a:tblGrid>\n    <a:gridCol w="111"/>\n    <a:gri'
            'dCol w="111"/>\n    <a:gridCol w="112"/>\n  </a:tblGrid>\n  <a:t'
            'r h="222">\n    <a:tc>\n      <a:txBody>\n        <a:bodyPr/>\n '
            '       <a:lstStyle/>\n        <a:p/>\n      </a:txBody>\n      <'
            'a:tcPr/>\n    </a:tc>\n    <a:tc>\n      <a:txBody>\n        <a:'
            'bodyPr/>\n        <a:lstStyle/>\n        <a:p/>\n      </a:txBod'
            'y>\n      <a:tcPr/>\n    </a:tc>\n    <a:tc>\n      <a:txBody>\n'
            '        <a:bodyPr/>\n        <a:lstStyle/>\n        <a:p/>\n    '
            '  </a:txBody>\n      <a:tcPr/>\n    </a:tc>\n  </a:tr>\n  <a:tr '
            'h="223">\n    <a:tc>\n      <a:txBody>\n        <a:bodyPr/>\n   '
            '     <a:lstStyle/>\n        <a:p/>\n      </a:txBody>\n      <a:'
            'tcPr/>\n    </a:tc>\n    <a:tc>\n      <a:txBody>\n        <a:bo'
            'dyPr/>\n        <a:lstStyle/>\n        <a:p/>\n      </a:txBody>'
            '\n      <a:tcPr/>\n    </a:tc>\n    <a:tc>\n      <a:txBody>\n  '
            '      <a:bodyPr/>\n        <a:lstStyle/>\n        <a:p/>\n      '
            '</a:txBody>\n      <a:tcPr/>\n    </a:tc>\n  </a:tr>\n</a:tbl>\n'
            % nsdecls('a')
        )
        # exercise ---------------------
        tbl = CT_Table.new_tbl(rows, cols, width, height)
        # verify -----------------------
        self.assertEqualLineByLine(xml, tbl)

    def test_boolean_property_value_is_correct(self):
        """CT_Table boolean property value is correct"""
        def getter_cases(propname):
            """Test cases for boolean property getter tests"""
            return (
                # defaults to False if no tblPr element present
                (a_tbl(), False),
                # defaults to False if tblPr element is empty
                (a_tbl().with_tblPr, False),
                # returns True if firstCol is valid truthy value
                (a_tbl().with_prop(propname, '1'), True),
                (a_tbl().with_prop(propname, 'true'), True),
                # returns False if firstCol has valid False value
                (a_tbl().with_prop(propname, '0'), False),
                (a_tbl().with_prop(propname, 'false'), False),
                # returns False if firstCol is not valid xsd:boolean value
                (a_tbl().with_prop(propname, 'foobar'), False),
            )
        for propname in self.boolprops:
            cases = getter_cases(propname)
            for tbl_builder, expected_property_value in cases:
                reason = (
                    'tbl.%s did not return %s for this XML:\n\n%s' %
                    (propname, expected_property_value, tbl_builder.xml)
                )
                assert_that(
                    getattr(tbl_builder.element, propname),
                    is_(equal_to(expected_property_value)),
                    reason
                )

    def test_assignment_to_boolean_property_produces_correct_xml(self):
        """Assignment to boolean property of CT_Table produces correct XML"""
        def xml_check_cases(propname):
            return (
                # => True: tblPr and attribute should be added
                (a_tbl(), True, a_tbl().with_prop(propname, '1')),
                # => False: attribute should be removed if false
                (a_tbl().with_prop(propname, '1'), False, a_tbl().with_tblPr),
                # => False: attribute should not be added if false
                (a_tbl(), False, a_tbl()),
            )
        for propname in self.boolprops:
            cases = xml_check_cases(propname)
            for tc_builder, assigned_value, expected_tc_builder in cases:
                tc = tc_builder.element
                setattr(tc, propname, assigned_value)
                self.assertEqualLineByLine(expected_tc_builder.xml, tc)


class TestCT_TableCell(TestCase):
    """Test CT_TableCell"""
    def test_anchor_property_value_is_correct(self):
        # setup ------------------------
        cases = (
            (test_table_elements.cell, None),
            (test_table_elements.top_aligned_cell, MSO_ANCHOR.TOP)
        )
        # verify -----------------------
        for tc, expected_text_anchoring_type in cases:
            assert_that(tc.anchor,
                        is_(equal_to(expected_text_anchoring_type)))

    def test_assignment_to_anchor_sets_anchor_value(self):
        """Assignment to CT_TableCell.anchor sets anchor value"""
        # setup ------------------------
        cases = (
            # something => something else
            (test_table_elements.top_aligned_cell, MSO_ANCHOR.MIDDLE),
            # something => None
            (test_table_elements.top_aligned_cell, None),
            # None => something
            (test_table_elements.cell, MSO_ANCHOR.BOTTOM),
            # None => None
            (test_table_elements.cell, None)
        )
        # verify -----------------------
        for tc, anchor in cases:
            tc.anchor = anchor
            assert_that(tc.anchor, is_(equal_to(anchor)))

    def test_assignment_to_anchor_produces_correct_xml(self):
        """Assigning value to CT_TableCell.anchor produces correct XML"""
        # setup ------------------------
        cases = (
            # None => something
            (test_table_elements.cell, MSO_ANCHOR.TOP,
             test_table_xml.top_aligned_cell),
            # something => None
            (test_table_elements.top_aligned_cell, None,
             test_table_xml.cell)
        )
        # verify -----------------------
        for tc, text_anchoring_type, expected_xml in cases:
            tc.anchor = text_anchoring_type
            self.assertEqualLineByLine(expected_xml, tc)

    def test_marX_property_values_are_correct(self):
        """CT_TableCell.marX property values are correct"""
        # setup ------------------------
        cases = (
            (test_table_elements.cell_with_margins, 12, 34, 56, 78),
            (test_table_elements.cell, 45720, 91440, 45720, 91440)
        )
        # verify -----------------------
        for tc, exp_marT, exp_marR, exp_marB, exp_marL in cases:
            assert_that(tc.marT, is_(equal_to(exp_marT)))
            assert_that(tc.marR, is_(equal_to(exp_marR)))
            assert_that(tc.marB, is_(equal_to(exp_marB)))
            assert_that(tc.marL, is_(equal_to(exp_marL)))

    def test_assignment_to_marX_sets_value(self):
        """Assignment to CT_TableCell.marX sets marX value"""
        # setup ------------------------
        cases = (
            # something => something else
            (
                test_table_elements.cell_with_margins,
                (98, 76, 54, 32),
                (98, 76, 54, 32)
            ),
            # something => None
            (
                test_table_elements.cell_with_margins,
                (None, None, None, None),
                (45720, 91440, 45720, 91440)
            ),
            # None => something
            (
                test_table_elements.cell,
                (98, 76, 54, 32),
                (98, 76, 54, 32)
            ),
            # None => None
            (
                test_table_elements.cell,
                (None, None, None, None),
                (45720, 91440, 45720, 91440)
            )
        )
        # verify -----------------------
        for tc, marX, expected_marX in cases:
            tc.marT, tc.marR, tc.marB, tc.marL = marX
            exp_marT, exp_marR, exp_marB, exp_marL = expected_marX
            assert_that(tc.marT, is_(equal_to(exp_marT)))
            assert_that(tc.marR, is_(equal_to(exp_marR)))
            assert_that(tc.marB, is_(equal_to(exp_marB)))
            assert_that(tc.marL, is_(equal_to(exp_marL)))

    def test_assignment_to_marX_produces_correct_xml(self):
        """Assigning value to CT_TableCell.marX produces correct XML"""
        # setup ------------------------
        cases = (
            # None => something
            (
                test_table_elements.cell,
                (12, 34, 56, 78),
                test_table_xml.cell_with_margins
            ),
            # something => None
            (
                test_table_elements.cell_with_margins,
                (None, None, None, None),
                test_table_xml.cell
            )
        )
        # verify -----------------------
        for tc, marX, expected_xml in cases:
            tc.marT, tc.marR, tc.marB, tc.marL = marX
            self.assertEqualLineByLine(expected_xml, tc)

########NEW FILE########
__FILENAME__ = test_coreprops
# encoding: utf-8

"""Test suite for pptx.oxml.coreprops module."""

from __future__ import absolute_import

from datetime import datetime

from hamcrest import assert_that, equal_to, is_

from pptx.oxml.coreprops import CT_CoreProperties

from .unitdata.coreprops import a_coreProperties
from ..unitutil import TestCase


class TestCT_CoreProperties(TestCase):
    """Test CT_CoreProperties"""
    _cases = (
        ('author',            'Creator'),
        ('category',          'Category'),
        ('comments',          'Description'),
        ('content_status',    'Content Status'),
        ('identifier',        'Identifier'),
        ('keywords',          'Key Words'),
        ('language',          'Language'),
        ('last_modified_by',  'Last Modified By'),
        ('subject',           'Subject'),
        ('title',             'Title'),
        ('version',           'Version'),
    )

    def test_str_getters_are_empty_string_for_missing_element(self):
        """CT_CoreProperties str props empty str ('') for missing element"""
        # setup ------------------------
        childless_core_prop_builder = a_coreProperties()
        # verify -----------------------
        for attr_name, value in self._cases:
            childless_coreProperties = childless_core_prop_builder.element
            attr_value = getattr(childless_coreProperties, attr_name)
            reason = ("attr '%s' did not return '' for this XML:\n\n%s" %
                      (attr_name, childless_core_prop_builder.xml))
            assert_that(attr_value, is_(equal_to('')), reason)

    def test_str_getter_values_match_xml(self):
        """CT_CoreProperties string property values match parsed XML"""
        # verify -----------------------
        for attr_name, value in self._cases:
            builder = a_coreProperties().with_child(attr_name, value)
            coreProperties = builder.element
            attr_value = getattr(coreProperties, attr_name)
            reason = ("failed for property '%s' with this XML:\n\n%s" %
                      (attr_name, builder.xml))
            assert_that(attr_value, is_(equal_to(value)), reason)

    def test_str_setters_produce_correct_xml(self):
        """Assignment to CT_CoreProperties str property yields correct XML"""
        for attr_name, value in self._cases:
            # setup --------------------
            coreProperties = a_coreProperties().element  # no child elements
            # exercise -----------------
            setattr(coreProperties, attr_name, value)
            # verify -------------------
            expected_xml = a_coreProperties().with_child(attr_name, value).xml
            self.assertEqualLineByLine(expected_xml, coreProperties)

    def test_str_setter_raises_on_str_longer_than_255_chars(self):
        """Raises on assign len(str) > 255 to CT_CoreProperties str prop"""
        # setup ------------------------
        coreProperties = a_coreProperties().element
        # verify -----------------------
        with self.assertRaises(ValueError):
            coreProperties.comments = 'foobar 123 ' * 50

    def test_date_parser_recognizes_W3CDTF_strings(self):
        """date parser recognizes W3CDTF formatted date strings"""
        # valid W3CDTF date cases:
        # yyyy e.g. '2003'
        # yyyy-mm e.g. '2003-12'
        # yyyy-mm-dd e.g. '2003-12-31'
        # UTC timezone e.g. '2003-12-31T10:14:55Z'
        # numeric timezone e.g. '2003-12-31T10:14:55-08:00'
        cases = (
            ('1999', datetime(1999, 1, 1, 0, 0, 0)),
            ('2000-02', datetime(2000, 2, 1, 0, 0, 0)),
            ('2001-03-04', datetime(2001, 3, 4, 0, 0, 0)),
            ('2002-05-06T01:23:45Z', datetime(2002, 5, 6, 1, 23, 45)),
            ('2013-06-16T22:34:56-07:00', datetime(2013, 6, 17, 5, 34, 56)),
        )
        for dt_str, expected_datetime in cases:
            # exercise -----------------
            dt = CT_CoreProperties._parse_W3CDTF_to_datetime(dt_str)
            # verify -------------------
            assert_that(dt, is_(expected_datetime))

    def test_date_getters_have_none_on_element_not_present(self):
        """CT_CoreProperties date props are None where element not present"""
        # setup ------------------------
        coreProperties = a_coreProperties().element
        # verify -----------------------
        assert_that(coreProperties.created, is_(None))

    def test_date_getter_value_matches_xml(self):
        """CT_CoreProperties date props match parsed XML"""
        # setup ------------------------
        date_str = '1999-01-23T12:34:56Z'
        coreProperties = a_coreProperties().with_date_prop(
            'created', date_str).element
        # verify -----------------------
        expected_date = datetime(1999, 01, 23, 12, 34, 56)
        assert_that(coreProperties.created, is_(expected_date))

    def test_date_getters_have_none_on_not_datetime(self):
        """CT_CoreProperties date props are None for unparseable elm text"""
        # setup ------------------------
        date_str = 'foobar'
        core_props = a_coreProperties().with_date_prop(
            'created', date_str).element
        # verify -----------------------
        assert_that(core_props.created, is_(None))

    def test_date_setters_produce_correct_xml(self):
        """Assignment to CT_CoreProperties date props yields correct XML"""
        # See CT_CorePropertiesBuilder for how this implicitly tests that
        # 'created' and 'modified' add 'xsi:type="dcterms:W3CDTF"' attribute
        # by adding that on .with_date_prop for those properties.
        # setup ------------------------
        cases = ('created', 'last_printed', 'modified')
        value = datetime(2013, 6, 16, 12, 34, 56)
        for propname in cases:
            coreProperties = a_coreProperties().element  # no child elements
            # exercise -----------------
            setattr(coreProperties, propname, value)
            # verify -------------------
            expected_xml = a_coreProperties().with_date_prop(
                propname, '2013-06-16T12:34:56Z').xml
            self.assertEqualLineByLine(expected_xml, coreProperties)

    def test_date_setter_raises_on_not_datetime(self):
        """Raises on assign non-datetime to CT_CoreProperties date prop"""
        # setup ------------------------
        coreProperties = a_coreProperties().element
        # verify -----------------------
        with self.assertRaises(ValueError):
            coreProperties.created = 'foobar'

    def test_revision_is_zero_on_element_not_present(self):
        """CT_CoreProperties.revision is zero when element not present"""
        # setup ------------------------
        coreProperties = a_coreProperties().element
        # verify -----------------------
        assert_that(coreProperties.revision, is_(0))

    def test_revision_value_matches_xml(self):
        """CT_CoreProperties revision matches parsed XML"""
        # setup ------------------------
        builder = a_coreProperties().with_revision('9')
        coreProperties = builder.element
        # verify -----------------------
        reason = ("wrong revision returned for this XML:\n\n%s" %
                  (builder.xml))
        assert_that(coreProperties.revision, is_(9), reason)

    def test_revision_is_zero_on_invalid_element_text(self):
        """CT_CoreProperties.revision is zero if XML value is invalid"""
        # setup ------------------------
        cases = ('foobar', '-666')
        for invalid_text in cases:
            builder = a_coreProperties().with_revision(invalid_text)
            coreProperties = builder.element
            # verify -----------------------
            reason = ("wrong revision returned for this XML:\n\n%s" %
                      (builder.xml))
            assert_that(coreProperties.revision, is_(0), reason)

    def test_assign_to_revision_produces_correct_xml(self):
        """Assignment to CT_CoreProperties.revision yields correct XML"""
        # setup ------------------------
        coreProperties = a_coreProperties().element  # no child elements
        # exercise ---------------------
        coreProperties.revision = 999
        # verify -----------------------
        expected_xml = a_coreProperties().with_revision('999').xml
        self.assertEqualLineByLine(expected_xml, coreProperties)

    def test_assign_to_revision_raises_on_not_positive_int(self):
        """Raises on assign invalid value to CT_CoreProperties.revision"""
        # setup ------------------------
        cases = ('foobar', -666)
        # verify -----------------------
        for invalid_value in cases:
            coreProperties = a_coreProperties().element
            with self.assertRaises(ValueError):
                coreProperties.revision = invalid_value

########NEW FILE########
__FILENAME__ = test_dml
# encoding: utf-8

"""
Test suite for pptx.oxml.dml module.
"""

from __future__ import absolute_import, print_function

import pytest

from pptx.enum.dml import MSO_THEME_COLOR
from pptx.oxml.dml.color import CT_Percentage, CT_SchemeColor, CT_SRgbColor
from pptx.oxml.dml.fill import CT_SolidColorFillProperties
from pptx.oxml.ns import qn

from .unitdata.dml import (
    a_lumMod, a_lumOff, a_prstClr, a_schemeClr, a_solidFill, an_srgbClr
)
from ..unitutil import actual_xml


class Describe_BaseColorElement(object):

    def it_can_get_the_lumMod_child_element_if_there_is_one(
            self, schemeClr, schemeClr_with_lumMod, lumMod):
        assert schemeClr.lumMod is None
        assert schemeClr_with_lumMod.lumMod is lumMod

    def it_can_get_the_lumOff_child_element_if_there_is_one(
            self, schemeClr, schemeClr_with_lumOff, lumOff):
        assert schemeClr.lumOff is None
        assert schemeClr_with_lumOff.lumOff is lumOff

    def it_can_remove_existing_lumMod_and_lumOff_child_elements(
            self, schemeClr_with_lumMod, schemeClr_with_lumOff,
            schemeClr_xml):
        schemeClr_with_lumMod.clear_lum()
        schemeClr_with_lumOff.clear_lum()
        assert actual_xml(schemeClr_with_lumMod) == schemeClr_xml
        assert actual_xml(schemeClr_with_lumOff) == schemeClr_xml

    def it_can_add_a_lumMod_child_element(
            self, schemeClr, schemeClr_with_lumMod_xml):
        lumMod = schemeClr.add_lumMod(75000)
        assert actual_xml(schemeClr) == schemeClr_with_lumMod_xml
        assert schemeClr.find(qn('a:lumMod')) == lumMod

    def it_can_add_a_lumOff_child_element(
            self, schemeClr, schemeClr_with_lumOff_xml):
        lumOff = schemeClr.add_lumOff(40000)
        assert actual_xml(schemeClr) == schemeClr_with_lumOff_xml
        assert schemeClr.find(qn('a:lumOff')) == lumOff

    # fixtures ---------------------------------------------

    @pytest.fixture
    def lumMod(self):
        return a_lumMod().with_nsdecls().element

    @pytest.fixture
    def lumOff(self):
        return a_lumOff().with_nsdecls().element

    @pytest.fixture
    def schemeClr(self):
        return a_schemeClr().with_nsdecls().element

    @pytest.fixture
    def schemeClr_xml(self):
        return a_schemeClr().with_nsdecls().xml()

    @pytest.fixture
    def schemeClr_with_lumMod(self, lumMod):
        schemeClr = a_schemeClr().with_nsdecls().element
        schemeClr.append(lumMod)
        return schemeClr

    @pytest.fixture
    def schemeClr_with_lumMod_xml(self):
        lumMod_bldr = a_lumMod().with_val(75000)
        return a_schemeClr().with_nsdecls().with_child(lumMod_bldr).xml()

    @pytest.fixture
    def schemeClr_with_lumOff_xml(self):
        lumOff_bldr = a_lumOff().with_val(40000)
        return a_schemeClr().with_nsdecls().with_child(lumOff_bldr).xml()

    @pytest.fixture
    def schemeClr_with_lumOff(self, lumOff):
        schemeClr = a_schemeClr().with_nsdecls().element
        schemeClr.append(lumOff)
        return schemeClr


class DescribeCT_Percentage(object):

    def it_is_used_by_the_parser_for_a_lumOff_element(self, lumOff):
        assert isinstance(lumOff, CT_Percentage)

    def it_is_used_by_the_parser_for_a_lumMod_element(self, lumMod):
        assert isinstance(lumMod, CT_Percentage)

    def it_knows_the_percentage_str_value(self, ct_percentage):
        assert ct_percentage.val == '99999'

    # fixtures ---------------------------------------------

    @pytest.fixture
    def ct_percentage(self):
        return a_lumMod().with_nsdecls().with_val('99999').element

    @pytest.fixture
    def lumMod(self):
        return a_lumMod().with_nsdecls().with_val('33333').element

    @pytest.fixture
    def lumOff(self):
        return a_lumOff().with_nsdecls().with_val('66666').element


class DescribeCT_SchemeColor(object):

    def it_is_used_by_the_parser_for_a_schemeClr_element(self, schemeClr):
        assert isinstance(schemeClr, CT_SchemeColor)

    def it_knows_the_theme_color_idx(self, schemeClr):
        assert schemeClr.val == MSO_THEME_COLOR.BACKGROUND_1

    def it_can_set_the_scheme_color_value(self, schemeClr, schemeClr_xml):
        schemeClr.val = MSO_THEME_COLOR.ACCENT_1
        assert actual_xml(schemeClr) == schemeClr_xml

    # fixtures ---------------------------------------------

    @pytest.fixture
    def schemeClr(self):
        return a_schemeClr().with_nsdecls().with_val('bg1').element

    @pytest.fixture
    def schemeClr_xml(self):
        return a_schemeClr().with_nsdecls().with_val('accent1').xml()


class DescribeCT_SRgbColor(object):

    def it_is_used_by_the_parser_for_an_srgbClr_element(self, srgbClr):
        assert isinstance(srgbClr, CT_SRgbColor)

    def it_knows_the_rgb_str_value(self, srgbClr):
        assert srgbClr.val == '123456'

    def it_can_set_the_rgb_str_value(self, srgbClr, srgbClr_xml):
        srgbClr.val = '987654'
        assert actual_xml(srgbClr) == srgbClr_xml

    # fixtures ---------------------------------------------

    @pytest.fixture
    def srgbClr(self):
        return an_srgbClr().with_nsdecls().with_val('123456').element

    @pytest.fixture
    def srgbClr_xml(self):
        return an_srgbClr().with_nsdecls().with_val('987654').xml()


class DescribeCT_SolidColorFillProperties(object):

    def it_is_used_by_the_parser_for_a_solidFill_element(self, solidFill):
        assert isinstance(solidFill, CT_SolidColorFillProperties)

    def it_can_get_the_schemeClr_child_element_or_None_if_there_isnt_one(
            self, solidFill, solidFill_with_schemeClr, schemeClr):
        assert solidFill.schemeClr is None
        assert solidFill_with_schemeClr.schemeClr is schemeClr

    def it_can_get_the_srgbClr_child_element_or_None_if_there_isnt_one(
            self, solidFill, solidFill_with_srgbClr, srgbClr):
        assert solidFill.srgbClr is None
        assert solidFill_with_srgbClr.srgbClr is srgbClr

    def it_gets_the_schemeClr_child_element_if_there_is_one(
            self, solidFill_with_schemeClr, schemeClr):
        _schemeClr = solidFill_with_schemeClr.get_or_change_to_schemeClr()
        assert _schemeClr is schemeClr

    def it_adds_an_schemeClr_child_element_if_there_isnt_one(
            self, solidFill, solidFill_with_schemeClr_xml):
        schemeClr = solidFill.get_or_change_to_schemeClr()
        assert actual_xml(solidFill) == solidFill_with_schemeClr_xml
        assert solidFill.find(qn('a:schemeClr')) == schemeClr

    def it_changes_the_color_choice_to_schemeClr_if_a_different_one_is_there(
            self, solidFill_with_srgbClr, solidFill_with_prstClr,
            solidFill_with_schemeClr_xml):
        for elm in (solidFill_with_srgbClr, solidFill_with_prstClr):
            elm.get_or_change_to_schemeClr()
            assert actual_xml(elm) == solidFill_with_schemeClr_xml

    def it_gets_the_srgbClr_child_element_if_there_is_one(
            self, solidFill_with_srgbClr, srgbClr):
        _srgbClr = solidFill_with_srgbClr.get_or_change_to_srgbClr()
        assert _srgbClr is srgbClr

    def it_adds_an_srgbClr_child_element_if_there_isnt_one(
            self, solidFill, solidFill_with_srgbClr_xml):
        srgbClr = solidFill.get_or_change_to_srgbClr()
        assert actual_xml(solidFill) == solidFill_with_srgbClr_xml
        assert solidFill.find(qn('a:srgbClr')) == srgbClr

    def it_changes_the_color_choice_to_srgbClr_if_a_different_one_is_there(
            self, solidFill_with_schemeClr, solidFill_with_prstClr,
            solidFill_with_srgbClr_xml):
        for elm in (solidFill_with_schemeClr, solidFill_with_prstClr):
            elm.get_or_change_to_srgbClr()
            assert actual_xml(elm) == solidFill_with_srgbClr_xml

    # fixtures ---------------------------------------------

    @pytest.fixture
    def schemeClr(self):
        return a_schemeClr().with_nsdecls().element

    @pytest.fixture
    def srgbClr(self):
        return an_srgbClr().with_nsdecls().element

    @pytest.fixture
    def solidFill(self):
        return a_solidFill().with_nsdecls().element

    @pytest.fixture
    def solidFill_with_prstClr(self):
        prstClr_bldr = a_prstClr()
        solidFill_bldr = a_solidFill().with_nsdecls().with_child(prstClr_bldr)
        return solidFill_bldr.element

    @pytest.fixture
    def solidFill_with_schemeClr(self, schemeClr):
        solidFill = a_solidFill().with_nsdecls().element
        solidFill.append(schemeClr)
        return solidFill

    @pytest.fixture
    def solidFill_with_srgbClr(self, srgbClr):
        solidFill = a_solidFill().with_nsdecls().element
        solidFill.append(srgbClr)
        return solidFill

    @pytest.fixture
    def solidFill_with_schemeClr_xml(self):
        schemeClr_bldr = a_schemeClr()
        return a_solidFill().with_nsdecls().with_child(schemeClr_bldr).xml()

    @pytest.fixture
    def solidFill_with_srgbClr_xml(self):
        srgbClr_bldr = an_srgbClr()
        return a_solidFill().with_nsdecls().with_child(srgbClr_bldr).xml()

########NEW FILE########
__FILENAME__ = test_ns
# encoding: utf-8

"""
Test suite for pptx.oxml.ns.py module.
"""

from __future__ import print_function, unicode_literals

import pytest

from pptx.oxml.ns import NamespacePrefixedTag, namespaces, nsdecls, nsuri, qn


class DescribeNamespacePrefixedTag(object):

    def it_behaves_like_a_string_when_you_want_it_to(self, nsptag):
        s = '- %s -' % nsptag
        assert s == '- a:foobar -'

    def it_knows_its_clark_name(self, nsptag, clark_name):
        assert nsptag.clark_name == clark_name

    def it_knows_its_local_part(self, nsptag, local_part):
        assert nsptag.local_part == local_part

    def it_can_compose_a_single_entry_nsmap_for_itself(
            self, nsptag, namespace_uri_a):
        expected_nsmap = {'a': namespace_uri_a}
        assert nsptag.nsmap == expected_nsmap

    def it_knows_its_namespace_prefix(self, nsptag):
        assert nsptag.nspfx == 'a'

    def it_knows_its_namespace_uri(self, nsptag, namespace_uri_a):
        assert nsptag.nsuri == namespace_uri_a


class DescribeNamespaces(object):

    def it_composes_a_dict_of_ns_uris_keyed_by_ns_pfx(self, nsmap):
        assert namespaces('a', 'p') == nsmap


class DescribeNsdecls(object):

    def it_formats_namespace_declarations_from_a_list_of_prefixes(
            self, nsdecls_str):
        assert nsdecls('a', 'p') == nsdecls_str


class DescribeNsuri(object):

    def it_finds_the_namespace_uri_corresponding_to_a_namespace_prefix(
            self, namespace_uri_a):
        assert nsuri('a') == namespace_uri_a


class DescribeQn(object):

    def it_calculates_the_clark_name_for_an_ns_prefixed_tag_string(
            self, nsptag_str, clark_name):
        assert qn(nsptag_str) == clark_name


# ===========================================================================
# fixtures
# ===========================================================================


@pytest.fixture
def clark_name(namespace_uri_a, local_part):
    return '{%s}%s' % (namespace_uri_a, local_part)


@pytest.fixture
def local_part():
    return 'foobar'


@pytest.fixture
def namespace_uri_a():
    return 'http://schemas.openxmlformats.org/drawingml/2006/main'


@pytest.fixture
def namespace_uri_p():
    return 'http://schemas.openxmlformats.org/presentationml/2006/main'


@pytest.fixture
def nsdecls_str(namespace_uri_a, namespace_uri_p):
    return 'xmlns:a="%s" xmlns:p="%s"' % (namespace_uri_a, namespace_uri_p)


@pytest.fixture
def nsmap(namespace_uri_a, namespace_uri_p):
    return {'a': namespace_uri_a, 'p': namespace_uri_p}


@pytest.fixture
def nsptag(nsptag_str):
    return NamespacePrefixedTag(nsptag_str)


@pytest.fixture
def nsptag_str(local_part):
    return 'a:%s' % local_part

########NEW FILE########
__FILENAME__ = test_presentation
# encoding: utf-8

"""
Test suite for pptx.oxml.presentation module
"""

from __future__ import absolute_import, print_function, unicode_literals

import pytest

from pptx.oxml.presentation import (
    CT_Presentation, CT_SlideId, CT_SlideIdList
)

from .unitdata.presentation import (
    a_notesSz, a_presentation, a_sldId, a_sldIdLst, a_sldSz
)
from ..unitutil import actual_xml


class DescribeCT_Presentation(object):

    def it_is_used_by_the_parser_for_a_presentation_element(self, prs_elm):
        assert isinstance(prs_elm, CT_Presentation)

    def it_can_get_the_sldIdLst_child_element(self, prs_with_sldIdLst):
        sldIdLst = prs_with_sldIdLst.get_or_add_sldIdLst()
        assert isinstance(sldIdLst, CT_SlideIdList)

    def it_can_add_a_sldIdLst_child_element(
            self, prs_with_sldSz, prs_with_sldIdLst_sldSz_xml):
        prs = prs_with_sldSz
        prs.get_or_add_sldIdLst()
        assert actual_xml(prs) == prs_with_sldIdLst_sldSz_xml

    def it_adds_sldIdLst_before_notesSz_if_no_sldSz_elm(
            self, prs_with_notesSz, prs_with_sldIdLst_notesSz_xml):
        prs = prs_with_notesSz
        prs.get_or_add_sldIdLst()
        assert actual_xml(prs) == prs_with_sldIdLst_notesSz_xml

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def prs_elm(self):
        return a_presentation().with_nsdecls().element

    @pytest.fixture
    def prs_with_notesSz(self):
        return (
            a_presentation().with_nsdecls()
                            .with_child(a_notesSz())
                            .element
        )

    @pytest.fixture
    def prs_with_sldIdLst(self):
        return (
            a_presentation().with_nsdecls()
                            .with_child(a_sldIdLst())
                            .element
        )

    @pytest.fixture
    def prs_with_sldIdLst_notesSz_xml(self):
        return (
            a_presentation().with_nsdecls()
                            .with_child(a_sldIdLst())
                            .with_child(a_notesSz())
                            .xml()
        )

    @pytest.fixture
    def prs_with_sldIdLst_sldSz_xml(self):
        return (
            a_presentation().with_nsdecls()
                            .with_child(a_sldIdLst())
                            .with_child(a_sldSz())
                            .xml()
        )

    @pytest.fixture
    def prs_with_sldSz(self):
        return (
            a_presentation().with_nsdecls()
                            .with_child(a_sldSz())
                            .element
        )


class DescribeCT_SlideId(object):

    def it_is_used_by_the_parser_for_a_sldId_element(self, sldId):
        assert isinstance(sldId, CT_SlideId)

    def it_knows_the_rId(self, sldId):
        assert sldId.rId == 'rId1'

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def sldId(self):
        return a_sldId().with_nsdecls('p', 'r').with_rId('rId1').element


class DescribeCT_SlideIdList(object):

    def it_is_used_by_the_parser_for_a_sldIdLst_element(self, sldIdLst):
        assert isinstance(sldIdLst, CT_SlideIdList)

    def it_provides_indexed_access_to_the_sldIds(self, sldIdLst_with_sldIds):
        sldIdLst, sldId_xml, sldId_2_xml = sldIdLst_with_sldIds
        assert actual_xml(sldIdLst[0]) == sldId_xml
        assert actual_xml(sldIdLst[1]) == sldId_2_xml

    def it_raises_IndexError_on_index_out_of_range(self, sldIdLst):
        with pytest.raises(IndexError):
            sldIdLst[0]

    def it_can_iterate_over_the_sldIds(self, sldIdLst_with_sldIds):
        sldIdLst, sldId_xml, sldId_2_xml = sldIdLst_with_sldIds
        sldIds = [s for s in sldIdLst]
        assert actual_xml(sldIds[0]) == sldId_xml
        assert actual_xml(sldIds[1]) == sldId_2_xml

    def it_knows_the_sldId_count(self):
        pass

    def it_returns_sldId_count_for_len(self, sldIdLst_with_sldIds):
        # objectify would return 1 if __len__ were not overridden
        sldIdLst = sldIdLst_with_sldIds[0]
        assert len(sldIdLst) == 2

    def it_can_add_a_sldId_element_as_a_child(
            self, sldIdLst, sldIdLst_with_sldId_xml):
        sldIdLst.add_sldId('rId1')
        assert actual_xml(sldIdLst) == sldIdLst_with_sldId_xml

    def it_knows_the_next_available_slide_id(self, next_id_fixture):
        sldIdLst, expected_id = next_id_fixture
        print(sldIdLst.xml)
        assert sldIdLst._next_id == expected_id

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        ((), '256'),
        ((256,), '257'), ((257,), '256'), ((300,), '256'), ((255,), '256'),
        ((257, 259), '256'), ((256, 258), '257'), ((256, 257), '258'),
        ((257, 258, 259), '256'), ((256, 258, 259), '257'),
        ((256, 257, 259), '258'), ((258, 256, 257), '259'),
    ])
    def next_id_fixture(self, request):
        existing_ids, expected_id = request.param
        sldIdLst_bldr = a_sldIdLst().with_nsdecls()
        for n in existing_ids:
            sldIdLst_bldr.with_child(a_sldId().with_id(n))
        sldIdLst = sldIdLst_bldr.element
        return sldIdLst, expected_id

    # fixture components ---------------------------------------------

    @pytest.fixture
    def sldIdLst(self):
        return a_sldIdLst().with_nsdecls().element

    @pytest.fixture
    def sldIdLst_with_sldId_xml(self):
        sldId_bldr = a_sldId().with_id(256).with_rId('rId1')
        return (
            a_sldIdLst().with_nsdecls('p', 'r')
                        .with_child(sldId_bldr)
                        .xml()
        )

    @pytest.fixture
    def sldIdLst_with_sldIds(self):
        sldId_bldr = a_sldId().with_id(256).with_rId('rId1')
        sldId_2_bldr = a_sldId().with_id(257).with_rId('rId2')
        sldIdLst = (
            a_sldIdLst().with_nsdecls('p', 'r')
                        .with_child(sldId_bldr)
                        .with_child(sldId_2_bldr)
                        .element
        )
        sldId_xml = sldId_bldr.with_nsdecls().xml()
        sldId_2_xml = sldId_2_bldr.with_nsdecls().xml()
        return sldIdLst, sldId_xml, sldId_2_xml

########NEW FILE########
__FILENAME__ = test_shared
# encoding: utf-8

"""
Test suite for pptx.oxml.core module.
"""

from __future__ import print_function, unicode_literals

import pytest

from lxml import objectify

from pptx.oxml import oxml_parser
from pptx.oxml.shared import (
    BaseOxmlElement, child, ChildTagnames, Element, get_or_add,
    serialize_part_xml, SubElement
)
from pptx.oxml.ns import nsdecls, qn
from pptx.oxml.text import CT_TextBody


class DescribeBaseOxmlElement(object):

    def it_knows_which_tagnames_follow_a_given_child_tagname(
            self, child_tagnames_fixture):
        ElementClass, tagname, tagnames_after = child_tagnames_fixture
        assert ElementClass.child_tagnames_after(tagname) == tagnames_after

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        (('foo', 'bar', 'baz'), 'foo', ('bar', 'baz')),
        ((('foo', 'bar'), 'baz'), 'foo', ('baz',)),
        (('foo', ('bar', 'baz')), 'bar', ()),
        (('1', '2', ('3', ('4', '5'), ('6', '7'))), '2',
         ('3', '4', '5', '6', '7')),
        (('1', '2', ('3', ('4', '5'), ('6', '7'))), '3', ()),
    ])
    def child_tagnames_fixture(self, request):
        nested_sequence, tagname, tagnames_after = request.param

        class ElementClass(BaseOxmlElement):
            child_tagnames = ChildTagnames.from_nested_sequence(
                *nested_sequence
            )

        return ElementClass, tagname, tagnames_after


class DescribeChild(object):

    def it_returns_a_matching_child_if_present(
            self, parent_elm, known_child_nsptag_str, known_child_elm):
        child_elm = child(parent_elm, known_child_nsptag_str)
        assert child_elm is known_child_elm

    def it_returns_none_if_no_matching_child_is_present(self, parent_elm):
        child_elm = child(parent_elm, 'p:baz')
        assert child_elm is None


class DescribeElement(object):

    def it_returns_an_element_with_the_specified_tag(self, nsptag_str):
        elm = Element(nsptag_str)
        assert elm.tag == qn(nsptag_str)

    def it_returns_custom_element_class_if_one_is_defined(self, nsptag_str):
        elm = Element(nsptag_str)
        assert type(elm) is CT_TextBody


class DescribeGetOrAddChild(object):

    def it_returns_a_matching_child_if_present(
            self, parent_elm, known_child_nsptag_str, known_child_elm):
        child_elm = get_or_add(parent_elm, known_child_nsptag_str)
        assert child_elm is known_child_elm

    def it_creates_a_new_child_if_one_is_not_present(self, parent_elm):
        child_elm = get_or_add(parent_elm, 'p:baz')
        assert child_elm.tag == qn('p:baz')
        assert child_elm.getparent() is parent_elm


class DescribeSerializePartXml(object):

    def it_produces_properly_formatted_xml_for_an_opc_part(
            self, part_elm, expected_part_xml):
        """
        Tested aspects:
        ---------------
        * [X] it generates an XML declaration
        * [X] it produces no whitespace between elements
        * [X] it removes any annotations
        * [X] it preserves unused namespaces
        * [X] it returns bytes ready to save to file (not unicode)
        """
        xml = serialize_part_xml(part_elm)
        assert xml == expected_part_xml
        # xml contains 188 chars, of which 3 are double-byte; it will have
        # len of 188 if it's unicode and 191 if it's bytes
        assert len(xml) == 191

    # fixtures -----------------------------------

    @pytest.fixture
    def part_elm(self, xml_bytes):
        return objectify.fromstring(xml_bytes)

    @pytest.fixture
    def expected_part_xml(self):
        return (
            '<?xml version=\'1.0\' encoding=\'UTF-8\' standalone=\'yes\'?>\n'
            '<f:foo xmlns:py="http://codespeak.net/lxml/objectify/pytype" xm'
            'lns:f="http://foo" xmlns:b="http://bar"><f:bar>fbr</f:bar></'
            'f:foo>'
        ).encode('utf-8')

    @pytest.fixture
    def xml_bytes(self):
        xml_unicode = (
            '<f:foo xmlns:py="http://codespeak.net/lxml/objectify/pytype" xm'
            'lns:f="http://foo" xmlns:b="http://bar">\n'
            '  <f:bar py:pytype="str">fbr</f:bar>\n'
            '</f:foo>\n'
        )
        xml_bytes = xml_unicode.encode('utf-8')
        return xml_bytes


class DescribeSubElement(object):

    def it_returns_a_child_of_the_passed_parent_elm(
            self, parent_elm, nsptag_str):
        elm = SubElement(parent_elm, nsptag_str)
        assert elm.getparent() is parent_elm

    def it_returns_an_element_with_the_specified_tag(
            self, parent_elm, nsptag_str):
        elm = SubElement(parent_elm, nsptag_str)
        assert elm.tag == qn(nsptag_str)

    def it_returns_custom_element_class_if_one_is_defined_for_tag(
            self, parent_elm, nsptag_str):
        # note this behavior depends on the parser of parent_elm being the
        # one on which the custom element class lookups are defined
        elm = SubElement(parent_elm, nsptag_str)
        assert type(elm) is CT_TextBody

    def it_can_set_element_attributes(self, parent_elm, nsptag_str):
        attr_dct = {'foo': 'f', 'bar': 'b'}
        elm = SubElement(parent_elm, nsptag_str, attrib=attr_dct, baz='1')
        assert elm.get('foo') == 'f'
        assert elm.get('bar') == 'b'
        assert elm.get('baz') == '1'


# ===========================================================================
# fixtures
# ===========================================================================

@pytest.fixture
def known_child_elm(parent_elm, known_child_nsptag_str):
    return parent_elm[qn(known_child_nsptag_str)]


@pytest.fixture
def known_child_nsptag_str():
    return 'a:bar'


@pytest.fixture
def nsptag_str():
    return 'p:txBody'


@pytest.fixture
def parent_elm():
    xml = '<p:foo %s><a:bar>foobar</a:bar></p:foo>' % nsdecls('p', 'a')
    return objectify.fromstring(xml, oxml_parser)

########NEW FILE########
__FILENAME__ = test_slidemaster
# encoding: utf-8

"""
Test suite for pptx.oxml.slidemaster module
"""

from __future__ import absolute_import, print_function, unicode_literals

import pytest

from pptx.oxml.slidemaster import CT_SlideMaster

from .unitdata.slides import a_sldMaster


class DescribeCT_SlideMaster(object):

    def it_is_used_by_the_parser_for_a_sldMaster_element(self, sldMaster_elm):
        assert isinstance(sldMaster_elm, CT_SlideMaster)

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def sldMaster_elm(self):
        return a_sldMaster().with_nsdecls().element

########NEW FILE########
__FILENAME__ = test_text
# encoding: utf-8

"""
Test suite for pptx.oxml.text module.
"""

from __future__ import absolute_import, print_function

import pytest

from pptx.oxml.ns import qn
from pptx.oxml.text import (
    CT_RegularTextRun, CT_TextBody, CT_TextBodyProperties,
    CT_TextCharacterProperties, CT_TextParagraph, CT_TextParagraphProperties
)

from ..oxml.unitdata.dml import a_gradFill, a_noFill, a_solidFill
from ..oxml.unitdata.text import (
    a_bodyPr, a_defRPr, a_p, a_pPr, a_t, a_txBody, an_endParaRPr, an_extLst,
    an_r, an_rPr
)
from ..unitutil import actual_xml


class DescribeCT_RegularTextRun(object):

    def it_is_used_by_the_parser_for_an_r_element(self, r):
        assert isinstance(r, CT_RegularTextRun)

    def it_can_get_the_rPr_child_element(self, r_with_rPr, rPr):
        _rPr = r_with_rPr.get_or_add_rPr()
        assert _rPr is rPr

    def it_adds_rPr_element_in_proper_sequence_if_r_doesnt_have_one(
            self, r, r_with_rPr_xml):
        r.get_or_add_rPr()
        assert actual_xml(r) == r_with_rPr_xml

    # fixtures ---------------------------------------------

    @pytest.fixture
    def r(self):
        return an_r().with_nsdecls().with_child(a_t()).element

    @pytest.fixture
    def rPr(self):
        return an_rPr().with_nsdecls().element

    @pytest.fixture
    def r_with_rPr(self, r, rPr):
        r.insert(0, rPr)
        return r

    @pytest.fixture
    def r_with_rPr_xml(self):
        rPr_bldr = an_rPr()
        t_bldr = a_t()
        r_bldr = an_r().with_nsdecls()
        r_bldr.with_child(rPr_bldr)
        r_bldr.with_child(t_bldr)
        return r_bldr.xml()


class DescribeCT_TextBody(object):

    def it_is_used_by_the_parser_for_a_txBody_element(self, txBody):
        assert isinstance(txBody, CT_TextBody)

    # fixtures ---------------------------------------------

    @pytest.fixture
    def txBody(self):
        return a_txBody().with_nsdecls().element


class DescribeCT_TextBodyProperties(object):

    def it_is_used_by_the_parser_for_a_bodyPr_element(self, bodyPr):
        assert isinstance(bodyPr, CT_TextBodyProperties)

    def it_can_get_its_xIns_attr_domain_values(self, bodyPr):
        assert bodyPr.lIns is None
        bodyPr.lIns = 123
        assert bodyPr.lIns == 123

        assert bodyPr.tIns is None
        bodyPr.tIns = 456
        assert bodyPr.tIns == 456

        assert bodyPr.rIns is None
        bodyPr.rIns = 789
        assert bodyPr.rIns == 789

        assert bodyPr.bIns is None
        bodyPr.bIns = 876
        assert bodyPr.bIns == 876

    def it_can_set_its_lIns_attribute(
            self, bodyPr, bodyPr_xml, bodyPr_with_lIns_xml,
            bodyPr_with_tIns_xml, bodyPr_with_rIns_xml,
            bodyPr_with_bIns_xml):
        assert actual_xml(bodyPr) == bodyPr_xml

        bodyPr.lIns = 987
        assert actual_xml(bodyPr) == bodyPr_with_lIns_xml
        bodyPr.lIns = None
        assert actual_xml(bodyPr) == bodyPr_xml

        bodyPr.tIns = 654
        assert actual_xml(bodyPr) == bodyPr_with_tIns_xml
        bodyPr.tIns = None
        assert actual_xml(bodyPr) == bodyPr_xml

        bodyPr.rIns = 321
        assert actual_xml(bodyPr) == bodyPr_with_rIns_xml
        bodyPr.rIns = None
        assert actual_xml(bodyPr) == bodyPr_xml

        bodyPr.bIns = 234
        assert actual_xml(bodyPr) == bodyPr_with_bIns_xml
        bodyPr.bIns = None
        assert actual_xml(bodyPr) == bodyPr_xml

    # fixtures ---------------------------------------------

    @pytest.fixture
    def bodyPr(self):
        return a_bodyPr().with_nsdecls().element

    @pytest.fixture
    def bodyPr_xml(self):
        return a_bodyPr().with_nsdecls().xml()

    @pytest.fixture
    def bodyPr_with_lIns_xml(self):
        return a_bodyPr().with_nsdecls().with_lIns(987).xml()

    @pytest.fixture
    def bodyPr_with_tIns_xml(self):
        return a_bodyPr().with_nsdecls().with_tIns(654).xml()

    @pytest.fixture
    def bodyPr_with_rIns_xml(self):
        return a_bodyPr().with_nsdecls().with_rIns(321).xml()

    @pytest.fixture
    def bodyPr_with_bIns_xml(self):
        return a_bodyPr().with_nsdecls().with_bIns(234).xml()


class DescribeCT_TextCharacterProperties(object):

    def it_is_used_by_the_parser_for_a_defRPr_element(self, defRPr):
        assert isinstance(defRPr, CT_TextCharacterProperties)

    def it_is_used_by_the_parser_for_an_endParaRPr_element(self, endParaRPr):
        assert isinstance(endParaRPr, CT_TextCharacterProperties)

    def it_is_used_by_the_parser_for_an_rPr_element(self, rPr):
        assert isinstance(rPr, CT_TextCharacterProperties)

    def it_knows_the_b_value(self, rPr_with_true_b, rPr_with_false_b, rPr):
        assert rPr_with_true_b.b is True
        assert rPr_with_false_b.b is False
        assert rPr.b is None

    def it_can_set_the_b_value(
            self, rPr, rPr_with_true_b_xml, rPr_with_false_b_xml, rPr_xml):
        rPr.b = True
        assert actual_xml(rPr) == rPr_with_true_b_xml
        rPr.b = False
        assert actual_xml(rPr) == rPr_with_false_b_xml
        rPr.b = None
        assert actual_xml(rPr) == rPr_xml

    def it_knows_the_i_value(self, rPr_with_true_i, rPr_with_false_i, rPr):
        assert rPr_with_true_i.i is True
        assert rPr_with_false_i.i is False
        assert rPr.i is None

    def it_can_set_the_i_value(
            self, rPr, rPr_with_true_i_xml, rPr_with_false_i_xml, rPr_xml):
        rPr.i = True
        assert actual_xml(rPr) == rPr_with_true_i_xml
        rPr.i = False
        assert actual_xml(rPr) == rPr_with_false_i_xml
        rPr.i = None
        assert actual_xml(rPr) == rPr_xml

    def it_can_get_the_solidFill_child_element_or_none_if_there_isnt_one(
            self, rPr, rPr_with_solidFill, solidFill):
        assert rPr.solidFill is None
        assert rPr_with_solidFill.solidFill is solidFill

    def it_gets_the_solidFill_child_element_if_there_is_one(
            self, rPr_with_solidFill, solidFill):
        _solidFill = rPr_with_solidFill.get_or_change_to_solidFill()
        assert _solidFill is solidFill

    def it_adds_a_solidFill_child_element_if_there_isnt_one(
            self, rPr, rPr_with_solidFill_xml):
        solidFill = rPr.get_or_change_to_solidFill()
        assert actual_xml(rPr) == rPr_with_solidFill_xml
        assert rPr.find(qn('a:solidFill')) == solidFill

    def it_changes_the_fill_type_to_solidFill_if_another_one_is_there(
            self, rPr_with_gradFill, rPr_with_noFill, rPr_with_solidFill_xml):
        rPr_with_gradFill.get_or_change_to_solidFill()
        assert actual_xml(rPr_with_gradFill) == rPr_with_solidFill_xml
        rPr_with_noFill.get_or_change_to_solidFill()
        assert actual_xml(rPr_with_noFill) == rPr_with_solidFill_xml

    # fixtures ---------------------------------------------

    @pytest.fixture
    def defRPr(self):
        return a_defRPr().with_nsdecls().element

    @pytest.fixture
    def endParaRPr(self):
        return an_endParaRPr().with_nsdecls().element

    @pytest.fixture
    def rPr(self):
        return an_rPr().with_nsdecls().element

    @pytest.fixture
    def rPr_xml(self):
        return an_rPr().with_nsdecls().xml()

    @pytest.fixture
    def rPr_with_false_b(self):
        return an_rPr().with_nsdecls().with_b('false').element

    @pytest.fixture
    def rPr_with_false_b_xml(self):
        return an_rPr().with_nsdecls().with_b(0).xml()

    @pytest.fixture
    def rPr_with_false_i(self):
        return an_rPr().with_nsdecls().with_i('false').element

    @pytest.fixture
    def rPr_with_false_i_xml(self):
        return an_rPr().with_nsdecls().with_i(0).xml()

    @pytest.fixture
    def rPr_with_gradFill(self):
        gradFill_bldr = a_gradFill()
        return an_rPr().with_nsdecls().with_child(gradFill_bldr).element

    @pytest.fixture
    def rPr_with_noFill(self):
        noFill_bldr = a_noFill()
        return an_rPr().with_nsdecls().with_child(noFill_bldr).element

    @pytest.fixture
    def rPr_with_solidFill(self, solidFill):
        rPr = an_rPr().with_nsdecls().element
        rPr.append(solidFill)
        return rPr

    @pytest.fixture
    def rPr_with_solidFill_xml(self):
        solidFill_bldr = a_solidFill()
        return an_rPr().with_nsdecls().with_child(solidFill_bldr).xml()

    @pytest.fixture
    def rPr_with_true_b(self):
        return an_rPr().with_nsdecls().with_b(1).element

    @pytest.fixture
    def rPr_with_true_b_xml(self):
        return an_rPr().with_nsdecls().with_b(1).xml()

    @pytest.fixture
    def rPr_with_true_i(self):
        return an_rPr().with_nsdecls().with_i(1).element

    @pytest.fixture
    def rPr_with_true_i_xml(self):
        return an_rPr().with_nsdecls().with_i(1).xml()

    @pytest.fixture
    def solidFill(self):
        return a_solidFill().with_nsdecls().element


class DescribeCT_TextParagraph(object):

    def it_is_used_by_the_parser_for_a_p_element(self, p):
        assert isinstance(p, CT_TextParagraph)

    def it_can_get_the_pPr_child_element(self, p_with_pPr, pPr):
        _pPr = p_with_pPr.get_or_add_pPr()
        assert _pPr is pPr

    def it_adds_a_pPr_if_p_doesnt_have_one(self, p, p_with_pPr_xml):
        p.get_or_add_pPr()
        assert actual_xml(p) == p_with_pPr_xml

    def it_can_add_a_new_r_element(self, p, p_with_r_xml):
        p.add_r()
        assert actual_xml(p) == p_with_r_xml

    def it_adds_r_element_in_correct_sequence(
            self, p_with_endParaRPr, p_with_r_with_endParaRPr_xml):
        p = p_with_endParaRPr
        p.add_r()
        assert actual_xml(p) == p_with_r_with_endParaRPr_xml

    def it_can_remove_all_its_r_child_elements(
            self, p_with_r_children, p_xml):
        p = p_with_r_children.remove_child_r_elms()
        assert actual_xml(p) == p_xml

    # fixtures ---------------------------------------------

    @pytest.fixture
    def p(self, p_bldr):
        return p_bldr.element

    @pytest.fixture
    def p_bldr(self):
        return a_p().with_nsdecls()

    @pytest.fixture
    def p_xml(self, p_bldr):
        return p_bldr.xml()

    @pytest.fixture
    def pPr(self):
        return a_pPr().with_nsdecls().element

    @pytest.fixture
    def p_with_r_xml(self):
        r_bldr = an_r().with_child(a_t())
        return a_p().with_nsdecls().with_child(r_bldr).xml()

    @pytest.fixture
    def p_with_endParaRPr(self):
        endParaRPr_bldr = an_endParaRPr()
        p_bldr = a_p().with_nsdecls().with_child(endParaRPr_bldr)
        return p_bldr.element

    @pytest.fixture
    def p_with_pPr(self, p, pPr):
        p.append(pPr)
        return p

    @pytest.fixture
    def p_with_pPr_xml(self):
        pPr_bldr = a_pPr()
        p_with_pPr_bldr = a_p().with_nsdecls().with_child(pPr_bldr)
        return p_with_pPr_bldr.xml()

    @pytest.fixture
    def p_with_r_children(self):
        r_bldr = an_r().with_child(a_t())
        p_bldr = a_p().with_nsdecls()
        p_bldr = p_bldr.with_child(r_bldr)
        p_bldr = p_bldr.with_child(r_bldr)
        return p_bldr.element

    @pytest.fixture
    def p_with_r_with_endParaRPr_xml(self):
        r_bldr = an_r().with_child(a_t())
        endParaRPr_bldr = an_endParaRPr()
        p_bldr = a_p().with_nsdecls()
        p_bldr = p_bldr.with_child(r_bldr)
        p_bldr = p_bldr.with_child(endParaRPr_bldr)
        return p_bldr.xml()


class DescribeCT_TextParagraphProperties(object):

    def it_is_used_by_the_parser_for_a_pPr_element(self, pPr):
        assert isinstance(pPr, CT_TextParagraphProperties)

    def it_knows_the_algn_value(self, pPr_with_algn):
        assert pPr_with_algn.algn == 'foobar'

    def it_maps_missing_algn_attribute_to_None(self, pPr):
        assert pPr.algn is None

    def it_can_set_the_algn_value(self, pPr, pPr_with_algn_xml, pPr_xml):
        pPr.algn = 'foobar'
        assert actual_xml(pPr) == pPr_with_algn_xml
        pPr.algn = None
        assert actual_xml(pPr) == pPr_xml

    def it_can_get_the_defRPr_child_element(self, pPr_with_defRPr, defRPr):
        _defRPr = pPr_with_defRPr.get_or_add_defRPr()
        assert _defRPr is defRPr

    def it_adds_a_defRPr_if_pPr_doesnt_have_one(
            self, pPr, pPr_with_defRPr_xml):
        pPr.get_or_add_defRPr()
        assert actual_xml(pPr) == pPr_with_defRPr_xml

    def it_adds_defRPr_element_in_correct_sequence(
            self, pPr_with_extLst, pPr_with_defRPr_with_extLst_xml):
        pPr = pPr_with_extLst
        pPr.get_or_add_defRPr()
        assert actual_xml(pPr) == pPr_with_defRPr_with_extLst_xml

    # fixtures ---------------------------------------------

    @pytest.fixture
    def defRPr(self):
        return a_defRPr().with_nsdecls().element

    @pytest.fixture
    def pPr(self, pPr_bldr):
        return pPr_bldr.element

    @pytest.fixture
    def pPr_bldr(self):
        return a_pPr().with_nsdecls()

    @pytest.fixture
    def pPr_xml(self, pPr_bldr):
        return pPr_bldr.xml()

    @pytest.fixture
    def pPr_with_algn(self, pPr_with_algn_bldr):
        return pPr_with_algn_bldr.element

    @pytest.fixture
    def pPr_with_algn_bldr(self):
        return a_pPr().with_nsdecls().with_algn('foobar')

    @pytest.fixture
    def pPr_with_algn_xml(self, pPr_with_algn_bldr):
        return pPr_with_algn_bldr.xml()

    @pytest.fixture
    def pPr_with_defRPr(self, pPr_bldr, defRPr):
        pPr = pPr_bldr.element
        pPr.append(defRPr)
        return pPr

    @pytest.fixture
    def pPr_with_defRPr_with_extLst_xml(self):
        defRPr_bldr = a_defRPr()
        extLst_bldr = an_extLst()
        pPr_bldr = a_pPr().with_nsdecls()
        pPr_bldr = pPr_bldr.with_child(defRPr_bldr)
        pPr_bldr = pPr_bldr.with_child(extLst_bldr)
        return pPr_bldr.xml()

    @pytest.fixture
    def pPr_with_defRPr_xml(self):
        defRPr_bldr = a_defRPr()
        pPr_bldr = a_pPr().with_nsdecls().with_child(defRPr_bldr)
        return pPr_bldr.xml()

    @pytest.fixture
    def pPr_with_extLst(self):
        extLst_bldr = an_extLst()
        pPr_bldr = a_pPr().with_nsdecls().with_child(extLst_bldr)
        return pPr_bldr.element

########NEW FILE########
__FILENAME__ = coreprops
# encoding: utf-8

"""
Test data for core properties unit tests.
"""

from __future__ import absolute_import

from pptx.oxml import parse_xml_bytes
from pptx.oxml.ns import nsdecls


class CT_CorePropertiesBuilder(object):
    """
    Test data builder for CT_CoreProperties (cp:coreProperties) XML element
    """
    properties = (
        ('author',           'dc:creator'),
        ('category',         'cp:category'),
        ('comments',         'dc:description'),
        ('content_status',   'cp:contentStatus'),
        ('created',          'dcterms:created'),
        ('identifier',       'dc:identifier'),
        ('keywords',         'cp:keywords'),
        ('language',         'dc:language'),
        ('last_modified_by', 'cp:lastModifiedBy'),
        ('last_printed',     'cp:lastPrinted'),
        ('modified',         'dcterms:modified'),
        ('revision',         'cp:revision'),
        ('subject',          'dc:subject'),
        ('title',            'dc:title'),
        ('version',          'cp:version'),
    )

    def __init__(self):
        """Establish instance variables with default values"""
        for propname, tag in self.properties:
            setattr(self, '_%s' % propname, None)

    @property
    def _ns_prefixes(self):
        ns_prefixes = ['cp', 'dc', 'dcterms']
        for propname, tag in self.properties:
            value = getattr(self, '_%s' % propname)
            if value is None:
                continue
            ns_prefix = tag.split(':')[0]
            if ns_prefix not in ns_prefixes:
                ns_prefixes.append(ns_prefix)
            if ns_prefix == 'dcterms' and 'xsi' not in ns_prefixes:
                ns_prefixes.append('xsi')
        return tuple(ns_prefixes)

    @property
    def props_xml(self):
        props_xml = ''
        for propname, tag in self.properties:
            value = getattr(self, '_%s' % propname)
            if value is None:
                continue
            if value == '':
                xml = '  <%s/>\n' % tag
            else:
                if tag.startswith('dcterms:'):
                    xml = ('  <%s xsi:type="dcterms:W3CDTF">%s</%s>\n' %
                           (tag, value, tag))
                else:
                    xml = '  <%s>%s</%s>\n' % (tag, value, tag)
            props_xml += xml
        return props_xml

    @property
    def coreProperties(self):
        if self.props_xml:
            coreProperties = (
                '<cp:coreProperties %s>\n%s</cp:coreProperties>\n' %
                (nsdecls(*self._ns_prefixes), self.props_xml)
            )
        else:
            coreProperties = (
                '<cp:coreProperties %s/>\n' % nsdecls('cp', 'dc', 'dcterms')
            )
        return coreProperties

    @property
    def element(self):
        """Return element based on XML generated by builder"""
        return parse_xml_bytes(self.xml)

    def with_child(self, name, value):
        """add property element for *name* set to *value*"""
        setattr(self, '_%s' % name, value)
        return self

    def with_date_prop(self, name, value):
        """add date property element for *name* set to *value*"""
        setattr(self, '_%s' % name, value)
        return self

    def with_revision(self, value):
        """add revision element set to *value*"""
        self._revision = value
        return self

    @property
    def xml(self):
        """
        Return XML string based on settings accumulated via method calls
        """
        return self.coreProperties


def a_coreProperties():
    """Syntactic sugar to construct a CT_CorePropertiesBuilder instance"""
    return CT_CorePropertiesBuilder()

########NEW FILE########
__FILENAME__ = dml
# encoding: utf-8

"""
XML test data builders for pptx.oxml.dml unit tests
"""

from __future__ import absolute_import, print_function

from ...unitdata import BaseBuilder


class CT_BlipFillPropertiesBuilder(BaseBuilder):
    __tag__ = 'a:blipFill'
    __nspfxs__ = ('a',)
    __attrs__ = ('dpi', 'rotWithShape')


class CT_GradientFillPropertiesBuilder(BaseBuilder):
    __tag__ = 'a:gradFill'
    __nspfxs__ = ('a',)
    __attrs__ = ('flip', 'rotWithShape')


class CT_GroupFillPropertiesBuilder(BaseBuilder):
    __tag__ = 'a:grpFill'
    __nspfxs__ = ('a',)
    __attrs__ = ()


class CT_HslColorBuilder(BaseBuilder):
    __tag__ = 'a:hslClr'
    __nspfxs__ = ('a',)
    __attrs__ = ('hue', 'sat', 'lum')


class CT_LinePropertiesBuilder(BaseBuilder):
    __tag__ = 'a:ln'
    __nspfxs__ = ('a',)
    __attrs__ = ('w', 'cap', 'cmpd', 'algn')


class CT_NoFillPropertiesBuilder(BaseBuilder):
    __tag__ = 'a:noFill'
    __nspfxs__ = ('a',)
    __attrs__ = ()


class CT_PatternFillPropertiesBuilder(BaseBuilder):
    __tag__ = 'a:pattFill'
    __nspfxs__ = ('a',)
    __attrs__ = ('prst',)


class CT_PercentageBuilder(BaseBuilder):
    __nspfxs__ = ('a',)
    __attrs__ = ('val',)

    def __init__(self, tag):
        self.__tag__ = tag
        super(CT_PercentageBuilder, self).__init__()


class CT_PresetColorBuilder(BaseBuilder):
    __tag__ = 'a:prstClr'
    __nspfxs__ = ('a',)
    __attrs__ = ('val',)


class CT_SolidColorFillPropertiesBuilder(BaseBuilder):
    __tag__ = 'a:solidFill'
    __nspfxs__ = ('a',)
    __attrs__ = ()


class CT_SchemeColorBuilder(BaseBuilder):
    __tag__ = 'a:schemeClr'
    __nspfxs__ = ('a',)
    __attrs__ = ('val',)


class CT_ScRgbColorBuilder(BaseBuilder):
    __tag__ = 'a:scrgbClr'
    __nspfxs__ = ('a',)
    __attrs__ = ('r', 'g', 'b')


class CT_ShapePropertiesBuilder(BaseBuilder):
    __tag__ = 'p:spPr'
    __nspfxs__ = ('p', 'a')
    __attrs__ = ('bwMode',)


class CT_SRgbColorBuilder(BaseBuilder):
    __tag__ = 'a:srgbClr'
    __nspfxs__ = ('a',)
    __attrs__ = ('val',)


class CT_SystemColorBuilder(BaseBuilder):
    __tag__ = 'a:sysClr'
    __nspfxs__ = ('a',)
    __attrs__ = ('val', 'lastClr')


def a_blipFill():
    return CT_BlipFillPropertiesBuilder()


def a_gradFill():
    return CT_GradientFillPropertiesBuilder()


def a_grpFill():
    return CT_GroupFillPropertiesBuilder()


def a_lumMod():
    return CT_PercentageBuilder('a:lumMod')


def a_lumOff():
    return CT_PercentageBuilder('a:lumOff')


def a_noFill():
    return CT_NoFillPropertiesBuilder()


def a_pattFill():
    return CT_PatternFillPropertiesBuilder()


def a_prstClr():
    return CT_PresetColorBuilder()


def a_schemeClr():
    return CT_SchemeColorBuilder()


def a_solidFill():
    return CT_SolidColorFillPropertiesBuilder()


def an_hslClr():
    return CT_HslColorBuilder()


def an_ln():
    return CT_LinePropertiesBuilder()


def an_spPr():
    return CT_ShapePropertiesBuilder()


def an_scrgbClr():
    return CT_ScRgbColorBuilder()


def an_srgbClr():
    return CT_SRgbColorBuilder()


def a_sysClr():
    return CT_SystemColorBuilder()

########NEW FILE########
__FILENAME__ = presentation
# encoding: utf-8

"""
Test data builders for presentation-related oxml elements
"""

from __future__ import absolute_import, print_function, unicode_literals

from ...unitdata import BaseBuilder


class CT_PositiveSize2DBuilder(BaseBuilder):
    __tag__ = 'p:notesSz'
    __nspfxs__ = ('p',)
    __attrs__ = ('cx', 'cy')


class CT_PresentationBuilder(BaseBuilder):
    __tag__ = 'p:presentation'
    __nspfxs__ = ('p',)
    __attrs__ = (
        'serverZoom', 'firstSlideNum', 'showSpecialPlsOnTitleSld', 'rtl',
        'removePersonalInfoOnSave', 'compatMode', 'strictFirstAndLastChars',
        'embedTrueTypeFonts', 'saveSubsetFonts', 'autoCompressPictures',
        'bookmarkIdSeed', 'conformance'
    )


class CT_SlideIdBuilder(BaseBuilder):
    __tag__ = 'p:sldId'
    __nspfxs__ = ('p', 'r')
    __attrs__ = ('id', 'r:id')

    def with_rId(self, rId):
        self._set_xmlattr('r:id', rId)
        return self


class CT_SlideIdListBuilder(BaseBuilder):
    __tag__ = 'p:sldIdLst'
    __nspfxs__ = ('p', 'r')
    __attrs__ = ()


class CT_SlideMasterIdBuilder(BaseBuilder):
    __tag__ = 'p:sldMasterId'
    __nspfxs__ = ('p',)
    __attrs__ = ('id', 'r:id')

    def with_rId(self, rId):
        self._set_xmlattr('r:id', rId)
        return self


class CT_SlideMasterIdListBuilder(BaseBuilder):
    __tag__ = 'p:sldMasterIdLst'
    __nspfxs__ = ('p',)
    __attrs__ = ()


class CT_SlideSizeBuilder(BaseBuilder):
    __tag__ = 'p:sldSz'
    __nspfxs__ = ('p',)
    __attrs__ = ('cx', 'cy', 'type')


def a_notesSz():
    return CT_PositiveSize2DBuilder()


def a_presentation():
    """Return a CT_PresentationBuilder instance"""
    return CT_PresentationBuilder()


def a_sldId():
    return CT_SlideIdBuilder()


def a_sldIdLst():
    return CT_SlideIdListBuilder()


def a_sldMasterId():
    return CT_SlideMasterIdBuilder()


def a_sldMasterIdLst():
    return CT_SlideMasterIdListBuilder()


def a_sldSz():
    return CT_SlideSizeBuilder()

########NEW FILE########
__FILENAME__ = shape
# encoding: utf-8

"""
Test data for autoshape-related unit tests.
"""

from __future__ import absolute_import

from ...unitdata import BaseBuilder

from pptx.oxml import parse_xml_bytes
from pptx.oxml.ns import nsdecls
from pptx.parts.slide import _SlideShapeTree


class CT_ApplicationNonVisualDrawingPropsBuilder(BaseBuilder):
    __tag__ = 'p:nvPr'
    __nspfxs__ = ('p',)
    __attrs__ = ('isPhoto', 'userDrawn')


class CT_ConnectorBuilder(BaseBuilder):
    __tag__ = 'p:cxnSp'
    __nspfxs__ = ('p', 'a')
    __attrs__ = ()


class CT_GeomGuideBuilder(BaseBuilder):
    __tag__ = 'a:gd'
    __nspfxs__ = ('a',)
    __attrs__ = ('name', 'fmla')


class CT_GeomGuideListBuilder(BaseBuilder):
    __tag__ = 'a:avLst'
    __nspfxs__ = ('a',)
    __attrs__ = ()


class CT_GraphicalObjectBuilder(BaseBuilder):
    __tag__ = 'a:graphic'
    __nspfxs__ = ('a',)
    __attrs__ = ()


class CT_GraphicalObjectDataBuilder(BaseBuilder):
    __tag__ = 'a:graphicData'
    __nspfxs__ = ('a',)
    __attrs__ = ('uri',)


class CT_GraphicalObjectFrameBuilder(BaseBuilder):
    __tag__ = 'p:graphicFrame'
    __nspfxs__ = ('p', 'a')
    __attrs__ = ('bwMode',)


class CT_GraphicalObjectFrameNonVisualBuilder(BaseBuilder):
    __tag__ = 'p:nvGraphicFramePr'
    __nspfxs__ = ('p',)
    __attrs__ = ()


class CT_GroupShapeBuilder(BaseBuilder):
    __nspfxs__ = ('p',)
    __attrs__ = ()

    def __init__(self, tag):
        self.__tag__ = tag
        super(CT_GroupShapeBuilder, self).__init__()


class CT_GroupShapePropertiesBuilder(BaseBuilder):
    __tag__ = 'p:grpSpPr'
    __nspfxs__ = ('p', 'a')
    __attrs__ = ('bwMode',)


class CT_NonVisualDrawingPropsBuilder(BaseBuilder):
    __tag__ = 'p:cNvPr'
    __nspfxs__ = ('p',)
    __attrs__ = ('id', 'name', 'descr', 'hidden', 'title')


class CT_PictureBuilder(BaseBuilder):
    __tag__ = 'p:pic'
    __nspfxs__ = ('p', 'a')
    __attrs__ = ()


class CT_PictureNonVisualBuilder(BaseBuilder):
    __tag__ = 'p:nvPicPr'
    __nspfxs__ = ('p',)
    __attrs__ = ()


class CT_PlaceholderBuilder(BaseBuilder):
    __tag__ = 'p:ph'
    __nspfxs__ = ('p',)
    __attrs__ = ('type', 'orient', 'sz', 'idx', 'hasCustomPropt')


class CT_Point2DBuilder(BaseBuilder):
    __tag__ = 'a:off'
    __nspfxs__ = ('a',)
    __attrs__ = ('x', 'y')


class CT_PositiveSize2DBuilder(BaseBuilder):
    __tag__ = 'a:ext'
    __nspfxs__ = ('a',)
    __attrs__ = ('cx', 'cy')


class CT_PresetGeometry2DBuilder(BaseBuilder):
    __tag__ = 'a:prstGeom'
    __nspfxs__ = ('a',)
    __attrs__ = ('prst',)


class CT_ShapeBuilder(BaseBuilder):
    __tag__ = 'p:sp'
    __nspfxs__ = ('p', 'a')
    __attrs__ = ('useBgFill',)


class CT_ShapeNonVisualBuilder(BaseBuilder):
    __tag__ = 'p:nvSpPr'
    __nspfxs__ = ('p',)
    __attrs__ = ()


class CT_ShapePropertiesBuilder(BaseBuilder):
    __tag__ = 'p:spPr'
    __nspfxs__ = ('p', 'a')
    __attrs__ = ('bwMode',)


class CT_Transform2DBuilder(BaseBuilder):
    __nspfxs__ = ('a',)
    __attrs__ = ('rot', 'flipH', 'flipV')

    def __init__(self, tag):
        self.__tag__ = tag
        super(CT_Transform2DBuilder, self).__init__()


def a_cNvPr():
    return CT_NonVisualDrawingPropsBuilder()


def a_cxnSp():
    return CT_ConnectorBuilder()


def a_gd():
    return CT_GeomGuideBuilder()


def a_graphic():
    return CT_GraphicalObjectBuilder()


def a_graphicData():
    return CT_GraphicalObjectDataBuilder()


def a_graphicFrame():
    return CT_GraphicalObjectFrameBuilder()


def a_grpSp():
    return CT_GroupShapeBuilder('p:grpSp')


def a_grpSpPr():
    return CT_GroupShapePropertiesBuilder()


def a_p_xfrm():
    return CT_Transform2DBuilder('p:xfrm')


def a_ph():
    return CT_PlaceholderBuilder()


def a_pic():
    return CT_PictureBuilder()


def a_prstGeom():
    return CT_PresetGeometry2DBuilder()


def an_avLst():
    return CT_GeomGuideListBuilder()


def an_ext():
    return CT_PositiveSize2DBuilder()


def an_nvGraphicFramePr():
    return CT_GraphicalObjectFrameNonVisualBuilder()


def an_nvPicPr():
    return CT_PictureNonVisualBuilder()


def an_nvPr():
    return CT_ApplicationNonVisualDrawingPropsBuilder()


def an_nvSpPr():
    return CT_ShapeNonVisualBuilder()


def an_off():
    return CT_Point2DBuilder()


def an_sp():
    return CT_ShapeBuilder()


def an_spPr():
    return CT_ShapePropertiesBuilder()


def an_spTree():
    return CT_GroupShapeBuilder('p:spTree')


def an_xfrm():
    return CT_Transform2DBuilder('a:xfrm')


class _TestShapeXml(object):
    """XML snippets of various shapes for use in unit tests"""
    @property
    def autoshape(self):
        """
        XML for an autoshape for unit testing purposes, a rounded rectangle in
        this case.
        """
        return (
            '<p:sp xmlns:p="http://schemas.openxmlformats.org/presentationml/'
            '2006/main" xmlns:a="http://schemas.openxmlformats.org/drawingml/'
            '2006/main"><p:nvSpPr><p:cNvPr id="3" name="Rounded Rectangle 2"/'
            '><p:cNvSpPr/><p:nvPr/></p:nvSpPr><p:spPr><a:xfrm><a:off x="76009'
            '6" y="562720"/><a:ext cx="2520824" cy="914400"/></a:xfrm><a:prst'
            'Geom prst="roundRect"><a:avLst><a:gd name="adj" fmla="val 30346"'
            '/></a:avLst></a:prstGeom></p:spPr><p:style><a:lnRef idx="1"><a:s'
            'chemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeCl'
            'r val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr v'
            'al="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr '
            'val="lt1"/></a:fontRef></p:style><p:txBody><a:bodyPr rtlCol="0" '
            'anchor="ctr"/><a:lstStyle/><a:p><a:pPr algn="ctr"/><a:r><a:rPr l'
            'ang="en-US" dirty="0" smtClean="0"/><a:t>This is text inside a r'
            'ounded rectangle</a:t></a:r><a:endParaRPr lang="en-US" dirty="0"'
            '/></a:p></p:txBody></p:sp>'
        )

    @property
    def empty_spTree(self):
        return (
            '<p:spTree %s>\n'
            '  <p:nvGrpSpPr>\n'
            '    <p:cNvPr id="1" name=""/>\n'
            '    <p:cNvGrpSpPr/>\n'
            '    <p:nvPr/>\n'
            '  </p:nvGrpSpPr>\n'
            '  <p:grpSpPr/>\n'
            '</p:spTree>\n' % nsdecls('p', 'a')
        )

    @property
    def placeholder(self):
        """Generic placeholder XML, a date placeholder in this case"""
        return (
            '<p:sp xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/'
            'main" xmlns:p="http://schemas.openxmlformats.org/presentationml/'
            '2006/main">\n'
            '  <p:nvSpPr>\n'
            '    <p:cNvPr id="9" name="Date Placeholder 8"/>\n'
            '    <p:cNvSpPr>\n'
            '      <a:spLocks noGrp="1"/>\n'
            '    </p:cNvSpPr>\n'
            '    <p:nvPr>\n'
            '      <p:ph type="dt" sz="half" idx="10"/>\n'
            '    </p:nvPr>\n'
            '  </p:nvSpPr>\n'
            '  <p:spPr/>\n'
            '</p:sp>\n'
        )

    @property
    def rounded_rectangle(self):
        """XML for a rounded rectangle auto shape"""
        return self.autoshape

    @property
    def textbox(self):
        """Generic text box XML"""
        return (
            '<p:sp %s>\n'
            '  <p:nvSpPr>\n'
            '    <p:cNvPr id="9" name="TextBox 8"/>\n'
            '    <p:cNvSpPr txBox="1"/>\n'
            '    <p:nvPr/>\n'
            '  </p:nvSpPr>\n'
            '  <p:spPr>\n'
            '    <a:xfrm>\n'
            '      <a:off x="111" y="222"/>\n'
            '      <a:ext cx="333" cy="444"/>\n'
            '    </a:xfrm>\n'
            '    <a:prstGeom prst="rect">\n'
            '      <a:avLst/>\n'
            '    </a:prstGeom>\n'
            '    <a:noFill/>\n'
            '  </p:spPr>\n'
            '  <p:txBody>\n'
            '    <a:bodyPr wrap="none">\n'
            '      <a:spAutoFit/>\n'
            '    </a:bodyPr>\n'
            '    <a:lstStyle/>\n'
            '    <a:p/>\n'
            '  </p:txBody>\n'
            '</p:sp>' % nsdecls('a', 'p')
        )


class _TestShapeElements(object):
    """Shape elements for use in unit tests"""
    @property
    def autoshape(self):
        return parse_xml_bytes(test_shape_xml.autoshape)

    @property
    def empty_spTree(self):
        return parse_xml_bytes(test_shape_xml.empty_spTree)

    @property
    def placeholder(self):
        return parse_xml_bytes(test_shape_xml.placeholder)

    @property
    def rounded_rectangle(self):
        return parse_xml_bytes(test_shape_xml.rounded_rectangle)

    @property
    def textbox(self):
        return parse_xml_bytes(test_shape_xml.textbox)


class _TestShapes(object):
    """Shape instances for use in unit tests"""
    @property
    def empty_shape_collection(self):
        class FakeSlide(object):
            pass
        slide = FakeSlide()
        slide.spTree = test_shape_elements.empty_spTree
        return _SlideShapeTree(slide)


test_shape_xml = _TestShapeXml()
test_shape_elements = _TestShapeElements()
test_shapes = _TestShapes()

########NEW FILE########
__FILENAME__ = slides
# encoding: utf-8

"""
Test data builders for presentation-related oxml elements
"""

from __future__ import absolute_import, print_function, unicode_literals

from ...unitdata import BaseBuilder


class CT_CommonSlideDataBuilder(BaseBuilder):
    __tag__ = 'p:cSld'
    __nspfxs__ = ('p',)
    __attrs__ = ('name',)


class CT_SlideBuilder(BaseBuilder):
    __tag__ = 'p:sld'
    __nspfxs__ = ('p',)
    __attrs__ = ('showMasterSp', 'showMasterPhAnim', 'show')


class CT_SlideLayoutIdBuilder(BaseBuilder):
    __tag__ = 'p:sldLayoutId'
    __nspfxs__ = ('p',)
    __attrs__ = ('id', 'r:id')

    def with_rId(self, rId):
        self._set_xmlattr('r:id', rId)
        return self


class CT_SlideLayoutIdListBuilder(BaseBuilder):
    __tag__ = 'p:sldLayoutIdLst'
    __nspfxs__ = ('p',)
    __attrs__ = ()


class CT_SlideMasterBuilder(BaseBuilder):
    __tag__ = 'p:sldMaster'
    __nspfxs__ = ('p',)
    __attrs__ = ('preserve',)


def a_cSld():
    return CT_CommonSlideDataBuilder()


def a_sld():
    return CT_SlideBuilder()


def a_sldLayoutId():
    return CT_SlideLayoutIdBuilder()


def a_sldLayoutIdLst():
    return CT_SlideLayoutIdListBuilder()


def a_sldMaster():
    return CT_SlideMasterBuilder()

########NEW FILE########
__FILENAME__ = table
# encoding: utf-8

"""
Test data for table-related unit tests.
"""

from __future__ import absolute_import

from pptx.oxml import parse_xml_bytes
from pptx.oxml.ns import nsdecls
from pptx.shapes.table import _Cell

from ...unitdata import BaseBuilder


class CT_TableBuilder(object):
    """Test data builder for CT_Table (tbl) XML element"""
    empty_tbl_tmpl = (
        '<a:tbl %s/>%s\n'
    )
    with_props_tmpl = (
        '<a:tbl %s>\n'
        '  <a:tblPr%s/>\n'
        '</a:tbl>\n'
    )

    def __init__(self):
        """Establish instance variables with default values"""
        self._tmpl = CT_TableBuilder.empty_tbl_tmpl
        self._properties = []

    @property
    def _tblPr_attrs_str(self):
        """String containing all attributes of tblPr element"""
        s = ''
        for prop in self._properties:
            s += ' %s="%s"' % prop
        return s

    @property
    def xml(self):
        """
        Return XML string based on settings accumulated via method calls
        """
        return self._tmpl % (nsdecls('a'), self._tblPr_attrs_str)

    @property
    def element(self):
        """Return element based on XML generated by builder"""
        return parse_xml_bytes(self.xml)

    @property
    def with_tblPr(self):
        """include tblPr element even if it's empty"""
        self._tmpl = CT_TableBuilder.with_props_tmpl
        return self

    def with_prop(self, name, value):
        """add property named *name* with specified *value*"""
        self._tmpl = CT_TableBuilder.with_props_tmpl
        self._properties.append((name, value))
        return self


class CT_TableCellBuilder(BaseBuilder):
    __tag__ = 'a:tc'
    __nspfxs__ = ('a',)
    __attrs__ = ('rowSpan', 'gridSpan', 'hMerge', 'vMerge', 'id')


class CT_TableCellPropertiesBuilder(BaseBuilder):
    __tag__ = 'a:tcPr'
    __nspfxs__ = ('a',)
    __attrs__ = (
        'marL', 'marR', 'marT', 'marB', 'vert', 'anchor', 'anchorCtr',
        'horzOverflow'
    )


class CT_TextBodyBuilder(BaseBuilder):
    __tag__ = 'a:txBody'
    __nspfxs__ = ('a',)
    __attrs__ = ()


def a_tbl():
    return CT_TableBuilder()


def a_tc():
    return CT_TableCellBuilder()


def a_tcPr():
    return CT_TableCellPropertiesBuilder()


def a_txBody():
    return CT_TextBodyBuilder()


class _TestTableXml(object):
    """XML snippets of table-related elements for use in unit tests"""
    @property
    def cell(self):
        """
        XML for empty default table cell
        """
        return (
            '<a:tc %s>\n'
            '  <a:txBody>\n'
            '    <a:bodyPr/>\n'
            '    <a:lstStyle/>\n'
            '    <a:p/>\n'
            '  </a:txBody>\n'
            '  <a:tcPr/>\n'
            '</a:tc>\n' % nsdecls('a')
        )

    @property
    def cell_with_margins(self):
        """
        XML for cell having top, left, right, and bottom margin settings
        """
        return (
            '<a:tc %s>\n'
            '  <a:txBody>\n'
            '    <a:bodyPr/>\n'
            '    <a:lstStyle/>\n'
            '    <a:p/>\n'
            '  </a:txBody>\n'
            '  <a:tcPr marT="12" marR="34" marB="56" marL="78"/>\n'
            '</a:tc>\n' % nsdecls('a')
        )

    @property
    def top_aligned_cell(self):
        """
        XML for empty top-aligned table cell
        """
        return (
            '<a:tc %s>\n'
            '  <a:txBody>\n'
            '    <a:bodyPr/>\n'
            '    <a:lstStyle/>\n'
            '    <a:p/>\n'
            '  </a:txBody>\n'
            '  <a:tcPr anchor="t"/>\n'
            '</a:tc>\n' % nsdecls('a')
        )


class _TestTableElements(object):
    """Table-related elements for use in unit tests"""
    @property
    def cell(self):
        return parse_xml_bytes(test_table_xml.cell)

    @property
    def cell_with_margins(self):
        return parse_xml_bytes(test_table_xml.cell_with_margins)

    @property
    def isolated_tbl(self):
        return parse_xml_bytes(test_table_xml.isolated_tbl)

    @property
    def isolated_tbl_with_true_props(self):
        return parse_xml_bytes(test_table_xml.isolated_tbl_with_true_props)

    @property
    def top_aligned_cell(self):
        return parse_xml_bytes(test_table_xml.top_aligned_cell)


class _TestTableObjects(object):
    """Table-related object instances for use in unit tests"""
    @property
    def cell(self):
        return _Cell(test_table_elements.cell, None)


test_table_xml = _TestTableXml()
test_table_elements = _TestTableElements()
test_table_objects = _TestTableObjects()

########NEW FILE########
__FILENAME__ = text
# encoding: utf-8

"""
XML test data builders for pptx.oxml.text unit tests
"""

from __future__ import absolute_import, print_function

from ...unitdata import BaseBuilder


class CT_Hyperlink(BaseBuilder):
    __tag__ = 'a:hlinkClick'
    __nspfxs__ = ('a', 'r')
    __attrs__ = (
        'r:id', 'invalidUrl', 'action', 'tgtFrame', 'tooltip', 'history',
        'highlightClick', 'endSnd'
    )

    def with_rId(self, rId):
        self._set_xmlattr('r:id', rId)
        return self


class CT_OfficeArtExtensionList(BaseBuilder):
    __tag__ = 'a:extLst'
    __nspfxs__ = ('a',)
    __attrs__ = ()


class CT_RegularTextRunBuilder(BaseBuilder):
    __tag__ = 'a:r'
    __nspfxs__ = ('a',)
    __attrs__ = ()


class CT_TextBodyBuilder(BaseBuilder):
    __tag__ = 'p:txBody'
    __nspfxs__ = ('p', 'a')
    __attrs__ = ()


class CT_TextBodyPropertiesBuilder(BaseBuilder):
    __tag__ = 'a:bodyPr'
    __nspfxs__ = ('a',)
    __attrs__ = (
        'rot', 'spcFirstLastPara', 'vertOverflow', 'horzOverflow', 'vert',
        'wrap', 'lIns', 'tIns', 'rIns', 'bIns', 'numCol', 'spcCol', 'rtlCol',
        'fromWordArt', 'anchor', 'anchorCtr', 'forceAA', 'upright',
        'compatLnSpc',
    )


class CT_TextCharacterPropertiesBuilder(BaseBuilder):
    """
    Test data builder for CT_TextCharacterProperties XML element that appears
    as <a:endParaRPr> child of <a:p> and <a:rPr> child of <a:r>.
    """
    __nspfxs__ = ('a',)
    __attrs__ = ('b', 'i', 'sz', 'u')

    def __init__(self, tag):
        self.__tag__ = tag
        super(CT_TextCharacterPropertiesBuilder, self).__init__()


class CT_TextFontBuilder(BaseBuilder):
    __tag__ = 'a:latin'
    __nspfxs__ = ('a',)
    __attrs__ = ('typeface', 'panose', 'pitchFamily', 'charset')


class CT_TextNoAutofitBuilder(BaseBuilder):
    __tag__ = 'a:noAutofit'
    __nspfxs__ = ('a',)
    __attrs__ = ()


class CT_TextNormalAutofitBuilder(BaseBuilder):
    __tag__ = 'a:normAutofit'
    __nspfxs__ = ('a',)
    __attrs__ = ('fontScale', 'lnSpcReduction')


class CT_TextParagraphBuilder(BaseBuilder):
    """
    Test data builder for CT_TextParagraph (<a:p>) XML element that appears
    as a child of <p:txBody>.
    """
    __tag__ = 'a:p'
    __nspfxs__ = ('a',)
    __attrs__ = ()


class CT_TextParagraphPropertiesBuilder(BaseBuilder):
    """
    Test data builder for CT_TextParagraphProperties (<a:pPr>) XML element
    that appears as a child of <a:p>.
    """
    __tag__ = 'a:pPr'
    __nspfxs__ = ('a',)
    __attrs__ = (
        'marL', 'marR', 'lvl', 'indent', 'algn', 'defTabSz', 'rtl',
        'eaLnBrk', 'fontAlgn', 'latinLnBrk', 'hangingPunct'
    )


class CT_TextShapeAutofitBuilder(BaseBuilder):
    __tag__ = 'a:spAutoFit'
    __nspfxs__ = ('a',)
    __attrs__ = ()


class XsdString(BaseBuilder):
    __attrs__ = ()

    def __init__(self, tag, nspfxs):
        self.__tag__ = tag
        self.__nspfxs__ = nspfxs
        super(XsdString, self).__init__()


def a_bodyPr():
    return CT_TextBodyPropertiesBuilder()


def a_defRPr():
    return CT_TextCharacterPropertiesBuilder('a:defRPr')


def a_latin():
    return CT_TextFontBuilder()


def a_noAutofit():
    return CT_TextNoAutofitBuilder()


def a_normAutofit():
    return CT_TextNormalAutofitBuilder()


def a_p():
    """Return a CT_TextParagraphBuilder instance"""
    return CT_TextParagraphBuilder()


def a_pPr():
    """Return a CT_TextParagraphPropertiesBuilder instance"""
    return CT_TextParagraphPropertiesBuilder()


def a_t():
    return XsdString('a:t', ('a',))


def a_txBody():
    return CT_TextBodyBuilder()


def an_endParaRPr():
    return CT_TextCharacterPropertiesBuilder('a:endParaRPr')


def an_extLst():
    return CT_OfficeArtExtensionList()


def an_hlinkClick():
    return CT_Hyperlink()


def an_r():
    return CT_RegularTextRunBuilder()


def an_rPr():
    return CT_TextCharacterPropertiesBuilder('a:rPr')


def an_spAutoFit():
    return CT_TextShapeAutofitBuilder()

########NEW FILE########
__FILENAME__ = test_coreprops
# encoding: utf-8

"""
Test suite for pptx.coreprops module
"""

from __future__ import absolute_import

from datetime import datetime, timedelta

from hamcrest import assert_that, instance_of, is_, less_than

from pptx.opc.constants import CONTENT_TYPE as CT
from pptx.oxml.coreprops import CT_CoreProperties
from pptx.parts.coreprops import CoreProperties

from ..unitutil import TestCase


class TestCoreProperties(TestCase):
    """Test CoreProperties"""
    def test_it_can_construct_default_core_props(self):
        core_props = CoreProperties.default()
        # verify -----------------------
        assert_that(core_props, is_(instance_of(CoreProperties)))
        assert_that(core_props.content_type, is_(CT.OPC_CORE_PROPERTIES))
        assert_that(core_props.partname, is_('/docProps/core.xml'))
        assert_that(core_props._element, is_(instance_of(CT_CoreProperties)))
        assert_that(core_props.title, is_('PowerPoint Presentation'))
        assert_that(core_props.last_modified_by, is_('python-pptx'))
        assert_that(core_props.revision, is_(1))
        # core_props.modified only stores time with seconds resolution, so
        # comparison needs to be a little loose (within two seconds)
        modified_timedelta = datetime.utcnow() - core_props.modified
        max_expected_timedelta = timedelta(seconds=2)
        assert_that(modified_timedelta, less_than(max_expected_timedelta))

########NEW FILE########
__FILENAME__ = test_image
# encoding: utf-8

"""Test suite for pptx.image module."""

from __future__ import absolute_import

from StringIO import StringIO

from hamcrest import assert_that, equal_to, is_

from pptx.opc.packuri import PackURI
from pptx.parts.image import Image
from pptx.package import Package
from pptx.util import Px

from ..unitutil import absjoin, TestCase, test_file_dir


images_pptx_path = absjoin(test_file_dir, 'with_images.pptx')

test_bmp_path = absjoin(test_file_dir, 'python.bmp')
test_image_path = absjoin(test_file_dir, 'python-icon.jpeg')
new_image_path = absjoin(test_file_dir, 'monty-truth.png')


class TestImage(TestCase):
    """Test Image"""
    def test_construction_from_file(self):
        """Image(path) constructor produces correct attribute values"""
        # exercise ---------------------
        partname = PackURI('/ppt/media/image1.jpeg')
        image = Image.new(partname, test_image_path)
        # verify -----------------------
        assert_that(image.ext, is_(equal_to('jpeg')))
        assert_that(image.content_type, is_(equal_to('image/jpeg')))
        assert_that(len(image._blob), is_(equal_to(3277)))
        assert_that(image._desc, is_(equal_to('python-icon.jpeg')))

    def test_construction_from_stream(self):
        """Image(stream) construction produces correct attribute values"""
        # exercise ---------------------
        partname = PackURI('/ppt/media/image1.jpeg')
        with open(test_image_path, 'rb') as f:
            stream = StringIO(f.read())
        image = Image.new(partname, stream)
        # verify -----------------------
        assert_that(image.ext, is_(equal_to('jpg')))
        assert_that(image.content_type, is_(equal_to('image/jpeg')))
        assert_that(len(image._blob), is_(equal_to(3277)))
        assert_that(image._desc, is_(equal_to('image.jpg')))

    def test_construction_from_file_raises_on_bad_path(self):
        """Image(path) constructor raises on bad path"""
        partname = PackURI('/ppt/media/image1.jpeg')
        with self.assertRaises(IOError):
            Image.new(partname, 'foobar27.png')

    def test__scale_calculates_correct_dimensions(self):
        """Image._scale() calculates correct dimensions"""
        # setup ------------------------
        test_cases = (
            ((None, None), (Px(204), Px(204))),
            ((1000, None), (1000, 1000)),
            ((None, 3000), (3000, 3000)),
            ((3337, 9999), (3337, 9999)))
        partname = PackURI('/ppt/media/image1.png')
        image = Image.new(partname, test_image_path)
        # verify -----------------------
        for params, expected in test_cases:
            width, height = params
            assert_that(image._scale(width, height), is_(equal_to(expected)))

    def test__size_returns_image_native_pixel_dimensions(self):
        """Image._size is width, height tuple of image pixel dimensions"""
        partname = PackURI('/ppt/media/image1.png')
        image = Image.new(partname, test_image_path)
        assert_that(image._size, is_(equal_to((204, 204))))

    def test__ext_from_image_stream_raises_on_incompatible_format(self):
        with self.assertRaises(ValueError):
            with open(test_bmp_path) as stream:
                Image._ext_from_image_stream(stream)

    def test__image_ext_content_type_known_type(self):
        """
        Image._image_ext_content_type() correct for known content type
        """
        # exercise ---------------------
        content_type = Image._image_ext_content_type('jPeG')
        # verify -----------------------
        expected = 'image/jpeg'
        actual = content_type
        msg = ("expected content type '%s', got '%s'" % (expected, actual))
        self.assertEqual(expected, actual, msg)

    def test__image_ext_content_type_raises_on_bad_ext(self):
        with self.assertRaises(ValueError):
            Image._image_ext_content_type('xj7')


class TestImageCollection(TestCase):
    """Test ImageCollection"""
    def test_add_image_returns_matching_image(self):
        pkg = Package.open(images_pptx_path)
        matching_idx = 4
        matching_image = pkg._images[matching_idx]
        # exercise ---------------------
        image = pkg._images.add_image(test_image_path)
        # verify -----------------------
        expected = matching_image
        actual = image
        msg = ("expected images[%d], got images[%d]"
               % (matching_idx, pkg._images.index(image)))
        self.assertEqual(expected, actual, msg)

    def test_add_image_adds_new_image(self):
        """ImageCollection.add_image() adds new image on no match"""
        # setup ------------------------
        pkg = Package.open(images_pptx_path)
        expected_partname = '/ppt/media/image8.png'
        expected_len = len(pkg._images) + 1
        expected_sha1 = '79769f1e202add2e963158b532e36c2c0f76a70c'
        # exercise ---------------------
        image = pkg._images.add_image(new_image_path)
        # verify -----------------------
        expected = (expected_partname, expected_len, expected_sha1)
        actual = (image.partname, len(pkg._images), image._sha1)
        msg = "\nExpected: %s\n     Got: %s" % (expected, actual)
        self.assertEqual(expected, actual, msg)

########NEW FILE########
__FILENAME__ = test_part
# encoding: utf-8

"""
Test suite for pptx.part module
"""

from __future__ import absolute_import

from mock import Mock

from pptx.opc.packuri import PackURI
from pptx.parts.part import PartCollection

from ..unitutil import TestCase


class TestPartCollection(TestCase):

    def test_add_part_preserves_sort_order(self):
        partname1 = PackURI('/ppt/slides/slide1.xml')
        partname2 = PackURI('/ppt/slides/slide2.xml')
        partname3 = PackURI('/ppt/slides/slide3.xml')
        part1 = Mock(name='part1')
        part1.partname = partname1
        part2 = Mock(name='part2')
        part2.partname = partname2
        part3 = Mock(name='part3')
        part3.partname = partname3
        parts = PartCollection()
        # exercise ---------------------
        parts.add_part(part2)
        parts.add_part(part3)
        parts.add_part(part1)
        # verify -----------------------
        expected = [partname1, partname2, partname3]
        actual = [part.partname for part in parts]
        msg = "expected %s, got %s" % (expected, actual)
        self.assertEqual(expected, actual, msg)

########NEW FILE########
__FILENAME__ = test_presentation
# encoding: utf-8

"""
Test suite for pptx.parts.presentation module
"""

from __future__ import absolute_import, print_function

import pytest

from pptx.opc.packuri import PackURI
from pptx.oxml.presentation import (
    CT_Presentation, CT_SlideIdList, CT_SlideMasterIdList
)
from pptx.parts.presentation import PresentationPart, _SlideMasters
from pptx.parts.slidemaster import SlideMaster
from pptx.parts.slide import SlideCollection

from ..oxml.unitdata.presentation import (
    a_presentation, a_sldMasterId, a_sldMasterIdLst, a_sldSz
)
from ..unitutil import class_mock, instance_mock, method_mock, property_mock


class DescribePresentationPart(object):

    def it_knows_the_width_of_its_slides(self, slide_width_get_fixture):
        prs_part, slide_width = slide_width_get_fixture
        assert prs_part.slide_width == slide_width

    def it_can_change_the_width_of_its_slides(self, slide_width_set_fixture):
        prs_part, slide_width, expected_xml = slide_width_set_fixture
        prs_part.slide_width = slide_width
        assert prs_part._element.xml == expected_xml

    def it_knows_the_height_of_its_slides(self, slide_height_get_fixture):
        prs_part, slide_height = slide_height_get_fixture
        assert prs_part.slide_height == slide_height

    def it_can_change_the_height_of_its_slides(self, slide_height_set_fixture):
        prs_part, slide_height, expected_xml = slide_height_set_fixture
        prs_part.slide_height = slide_height
        assert prs_part._element.xml == expected_xml

    def it_provides_access_to_its_slide_masters(self, masters_fixture):
        presentation_part = masters_fixture
        slide_masters = presentation_part.slide_masters
        assert isinstance(slide_masters, _SlideMasters)

    def it_provides_access_to_its_sldMasterIdLst(self, presentation_part):
        sldMasterIdLst = presentation_part.sldMasterIdLst
        assert isinstance(sldMasterIdLst, CT_SlideMasterIdList)

    def it_creates_slide_collection_on_first_reference(
            self, prs, SlideCollection_, sldIdLst_, slides_):
        slides = prs.slides
        # verify -----------------------
        prs._element.get_or_add_sldIdLst.assert_called_once_with()
        SlideCollection_.assert_called_once_with(sldIdLst_, prs)
        slides.rename_slides.assert_called_once_with()
        assert slides == slides_

    def it_reuses_slide_collection_instance_on_later_references(self, prs):
        slides_1 = prs.slides
        slides_2 = prs.slides
        assert slides_2 is slides_1

    # fixtures ---------------------------------------------

    @pytest.fixture
    def masters_fixture(self):
        presentation_part = PresentationPart(None, None, None, None)
        return presentation_part

    @pytest.fixture
    def slide_height_get_fixture(self):
        cy = 5432109
        presentation_elm = (
            a_presentation().with_nsdecls().with_child(
                a_sldSz().with_cy(cy))
        ).element
        prs_part = PresentationPart(None, None, presentation_elm, None)
        slide_height = cy
        return prs_part, slide_height

    @pytest.fixture
    def slide_height_set_fixture(self):
        cy = 5432109
        presentation_elm = (
            a_presentation().with_nsdecls().with_child(
                a_sldSz().with_cy(0))
        ).element
        prs_part = PresentationPart(None, None, presentation_elm, None)
        expected_xml = (
            a_presentation().with_nsdecls().with_child(
                a_sldSz().with_cy(cy))
        ).xml()
        slide_height = cy
        return prs_part, slide_height, expected_xml

    @pytest.fixture
    def slide_width_get_fixture(self):
        cx = 8765432
        presentation_elm = (
            a_presentation().with_nsdecls().with_child(
                a_sldSz().with_cx(cx))
        ).element
        prs_part = PresentationPart(None, None, presentation_elm, None)
        slide_width = cx
        return prs_part, slide_width

    @pytest.fixture
    def slide_width_set_fixture(self):
        cx = 8765432
        presentation_elm = (
            a_presentation().with_nsdecls().with_child(
                a_sldSz().with_cx(0))
        ).element
        prs_part = PresentationPart(None, None, presentation_elm, None)
        expected_xml = (
            a_presentation().with_nsdecls().with_child(
                a_sldSz().with_cx(cx))
        ).xml()
        slide_width = cx
        return prs_part, slide_width, expected_xml

    # fixture components -----------------------------------

    @pytest.fixture
    def ct_presentation_(self, request, sldIdLst_):
        ct_presentation_ = instance_mock(request, CT_Presentation)
        ct_presentation_.get_or_add_sldIdLst.return_value = sldIdLst_
        return ct_presentation_

    @pytest.fixture
    def presentation_part(self, presentation_elm):
        return PresentationPart(None, None, presentation_elm, None)

    @pytest.fixture(params=[True, False])
    def presentation_elm(self, request):
        has_sldMasterIdLst = request.param
        presentation_bldr = a_presentation().with_nsdecls()
        if has_sldMasterIdLst:
            presentation_bldr.with_child(a_sldMasterIdLst())
        return presentation_bldr.element

    @pytest.fixture
    def prs(self, ct_presentation_):
        partname = PackURI('/ppt/presentation.xml')
        prs = PresentationPart(partname, None, ct_presentation_, None)
        return prs

    @pytest.fixture
    def sldIdLst_(self, request):
        return instance_mock(request, CT_SlideIdList)

    @pytest.fixture
    def SlideCollection_(self, request, slides_):
        SlideCollection_ = class_mock(
            request, 'pptx.parts.presentation.SlideCollection'
        )
        SlideCollection_.return_value = slides_
        return SlideCollection_

    @pytest.fixture
    def slides_(self, request):
        return instance_mock(request, SlideCollection)


class DescribeSlideMasters(object):

    def it_knows_how_many_masters_it_contains(self, len_fixture):
        slide_masters, expected_count = len_fixture
        slide_master_count = len(slide_masters)
        assert slide_master_count == expected_count

    def it_can_iterate_over_the_slide_masters(self, iter_fixture):
        slide_masters, slide_master_, slide_master_2_ = iter_fixture
        assert [s for s in slide_masters] == [slide_master_, slide_master_2_]

    def it_iterates_over_rIds_to_help__iter__(self, iter_rIds_fixture):
        slide_masters, expected_rIds = iter_rIds_fixture
        assert [rId for rId in slide_masters._iter_rIds()] == expected_rIds

    def it_supports_indexed_access(self, getitem_fixture):
        slide_masters, idx, slide_master_ = getitem_fixture
        slide_master = slide_masters[idx]
        assert slide_master is slide_master_

    def it_raises_on_slide_master_index_out_of_range(self, getitem_fixture):
        slide_masters = getitem_fixture[0]
        with pytest.raises(IndexError):
            slide_masters[2]

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def getitem_fixture(
            self, presentation_part, related_parts_, slide_master_):
        slide_masters = _SlideMasters(presentation_part)
        related_parts_.return_value = {'rId1': None, 'rId2': slide_master_}
        idx = 1
        return slide_masters, idx, slide_master_

    @pytest.fixture
    def iter_fixture(
            self, presentation_, _iter_rIds_, slide_master_, slide_master_2_):
        presentation_.related_parts = {
            'rId1': slide_master_, 'rId2': slide_master_2_
        }
        slide_masters = _SlideMasters(presentation_)
        return slide_masters, slide_master_, slide_master_2_

    @pytest.fixture
    def iter_rIds_fixture(self, presentation_part):
        slide_masters = _SlideMasters(presentation_part)
        expected_rIds = ['rId1', 'rId2']
        return slide_masters, expected_rIds

    @pytest.fixture
    def len_fixture(self, presentation_):
        slide_masters = _SlideMasters(presentation_)
        presentation_.sldMasterIdLst = [1, 2]
        expected_count = 2
        return slide_masters, expected_count

    # fixture components -----------------------------------

    @pytest.fixture
    def _iter_rIds_(self, request):
        return method_mock(
            request, _SlideMasters, '_iter_rIds',
            return_value=iter(['rId1', 'rId2'])
        )

    @pytest.fixture
    def presentation_part(self, presentation_elm):
        return PresentationPart(None, None, presentation_elm, None)

    @pytest.fixture
    def presentation_(self, request):
        return instance_mock(request, PresentationPart)

    @pytest.fixture
    def presentation_elm(self, request):
        presentation_bldr = (
            a_presentation().with_nsdecls('p', 'r').with_child(
                a_sldMasterIdLst().with_child(
                    a_sldMasterId().with_rId('rId1')).with_child(
                    a_sldMasterId().with_rId('rId2'))
            )
        )
        return presentation_bldr.element

    @pytest.fixture
    def related_parts_(self, request):
        return property_mock(request, PresentationPart, 'related_parts')

    @pytest.fixture
    def slide_master_(self, request):
        return instance_mock(request, SlideMaster)

    @pytest.fixture
    def slide_master_2_(self, request):
        return instance_mock(request, SlideMaster)

########NEW FILE########
__FILENAME__ = test_slide
# encoding: utf-8

"""
Test suite for pptx.parts.slide module
"""

from __future__ import absolute_import

import pytest

from lxml import objectify
from mock import ANY, call, MagicMock

from pptx.opc.constants import CONTENT_TYPE as CT, RELATIONSHIP_TYPE as RT
from pptx.opc.packuri import PackURI
from pptx.opc.package import Part, _Relationship
from pptx.oxml.presentation import CT_SlideId, CT_SlideIdList
from pptx.oxml.shapes.autoshape import CT_Shape
from pptx.oxml.shapes.graphfrm import CT_GraphicalObjectFrame
from pptx.oxml.shapes.groupshape import CT_GroupShape
from pptx.oxml.shapes.picture import CT_Picture
from pptx.oxml.shapes.shared import ST_Direction, ST_PlaceholderType
from pptx.oxml.slide import CT_Slide
from pptx.package import Package
from pptx.parts.image import Image as ImagePart
from pptx.parts.presentation import PresentationPart
from pptx.parts.slide import (
    BaseSlide, Slide, SlideCollection, _SlidePlaceholder, _SlidePlaceholders,
    _SlideShapeFactory, _SlideShapeTree
)
from pptx.parts.slidelayout import _LayoutPlaceholder, SlideLayout
from pptx.shapes.autoshape import AutoShapeType, Shape
from pptx.shapes.picture import Picture
from pptx.shapes.placeholder import BasePlaceholder
from pptx.shapes.shape import BaseShape
from pptx.shapes.table import Table

from ..oxml.unitdata.shape import (
    a_cNvPr, a_ph, a_pic, an_ext, an_nvPr, an_nvSpPr, an_sp, an_spPr,
    an_spTree, an_xfrm
)
from ..oxml.unitdata.slides import a_sld, a_cSld
from ..unitutil import (
    absjoin, class_mock, function_mock, initializer_mock, instance_mock,
    loose_mock, method_mock, parse_xml_file, property_mock, serialize_xml,
    test_file_dir
)


def actual_xml(elm):
    objectify.deannotate(elm, cleanup_namespaces=True)
    return serialize_xml(elm, pretty_print=True)


def _sldLayout1():
    path = absjoin(test_file_dir, 'slideLayout1.xml')
    sldLayout = parse_xml_file(path).getroot()
    return sldLayout


def _sldLayout1_shapes():
    path = absjoin(test_file_dir, 'slideLayout1.xml')
    with open(path) as f:
        xml_bytes = f.read()
    slide_layout = SlideLayout.load(None, None, xml_bytes, None)
    return slide_layout.shapes


class DescribeBaseSlide(object):

    def it_provides_access_to_its_spTree_element_to_help_ShapeTree(
            self, slide):
        spTree = slide.spTree
        assert isinstance(spTree, CT_GroupShape)

    def it_knows_the_name_of_the_slide(self, base_slide):
        # setup ------------------------
        base_slide._element = _sldLayout1()
        # exercise ---------------------
        name = base_slide.name
        # verify -----------------------
        expected = 'Title Slide'
        actual = name
        msg = "expected '%s', got '%s'" % (expected, actual)
        assert actual == expected, msg

    def it_can_add_an_image_part_to_the_slide(self, base_slide_fixture):
        # fixture ----------------------
        base_slide, img_file_, image_, rId_ = base_slide_fixture
        # exercise ---------------------
        image, rId = base_slide._add_image(img_file_)
        # verify -----------------------
        base_slide._package._images.add_image.assert_called_once_with(
            img_file_)
        base_slide.relate_to.assert_called_once_with(image, RT.IMAGE)
        assert image is image_
        assert rId is rId_

    def it_knows_it_is_the_part_its_child_objects_belong_to(
            self, base_slide):
        assert base_slide.part is base_slide

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def base_slide_fixture(self, request, base_slide):
        # mock BaseSlide._package._images.add_image() train wreck
        img_file_ = loose_mock(request, name='img_file_')
        image_ = loose_mock(request, name='image_')
        pkg_ = loose_mock(request, name='_package', spec=Package)
        pkg_._images.add_image.return_value = image_
        base_slide._package = pkg_
        # mock BaseSlide.relate_to()
        rId_ = loose_mock(request, name='rId_')
        method_mock(request, BaseSlide, 'relate_to', return_value=rId_)
        return base_slide, img_file_, image_, rId_

    # fixture components ---------------------------------------------

    @pytest.fixture
    def base_slide(self):
        partname = PackURI('/foo/bar.xml')
        return BaseSlide(partname, None, None, None)

    @pytest.fixture
    def sld(self):
        sld_bldr = (
            a_sld().with_nsdecls().with_child(
                a_cSld().with_child(
                    an_spTree()))
        )
        return sld_bldr.element

    @pytest.fixture
    def slide(self, sld):
        return BaseSlide(None, None, sld, None)


class DescribeSlide(object):

    def it_provides_access_to_the_shapes_on_the_slide(self, shapes_fixture):
        slide, _SlideShapeTree_, slide_shape_tree_ = shapes_fixture
        shapes = slide.shapes
        _SlideShapeTree_.assert_called_once_with(slide)
        assert shapes is slide_shape_tree_

    def it_provides_access_to_its_placeholders(self, placeholders_fixture):
        slide, _SlidePlaceholders_, slide_placeholders_ = (
            placeholders_fixture
        )
        placeholders = slide.placeholders
        _SlidePlaceholders_.assert_called_once_with(slide)
        assert placeholders is slide_placeholders_

    def it_can_create_a_new_slide(self, new_fixture):
        slide_layout_, partname_, package_ = new_fixture[:3]
        Slide_init_, slide_elm_, shapes_, relate_to_ = new_fixture[3:]
        slide = Slide.new(slide_layout_, partname_, package_)
        Slide_init_.assert_called_once_with(
            partname_, CT.PML_SLIDE, slide_elm_, package_
        )
        shapes_.clone_layout_placeholders.assert_called_once_with(
            slide_layout_
        )
        relate_to_.assert_called_once_with(
            slide_layout_, RT.SLIDE_LAYOUT
        )
        assert isinstance(slide, Slide)

    def it_knows_the_slide_layout_it_inherits_from(self, layout_fixture):
        slide, slide_layout_ = layout_fixture
        slide_layout = slide.slide_layout
        slide.part_related_by.assert_called_once_with(RT.SLIDE_LAYOUT)
        assert slide_layout is slide_layout_

    def it_knows_the_minimal_element_xml_for_a_slide(self, slide):
        path = absjoin(test_file_dir, 'minimal_slide.xml')
        sld = slide._minimal_element()
        with open(path, 'r') as f:
            expected_xml = f.read()
        assert actual_xml(sld) == expected_xml

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def layout_fixture(self, slide_layout_, part_related_by_):
        slide = Slide(None, None, None, None)
        return slide, slide_layout_

    @pytest.fixture
    def placeholders_fixture(
            self, _SlidePlaceholders_, slide_placeholders_):
        slide = Slide(None, None, None, None)
        return slide, _SlidePlaceholders_, slide_placeholders_

    @pytest.fixture
    def shapes_fixture(self, _SlideShapeTree_, slide_shape_tree_):
        slide = Slide(None, None, None, None)
        return slide, _SlideShapeTree_, slide_shape_tree_

    @pytest.fixture
    def new_fixture(
            self, slide_layout_, partname_, package_, Slide_init_,
            _minimal_element_, slide_elm_, shapes_prop_, shapes_,
            relate_to_):
        return (
            slide_layout_, partname_, package_, Slide_init_, slide_elm_,
            shapes_, relate_to_
        )

    # fixture components -----------------------------------

    @pytest.fixture
    def _minimal_element_(self, request, slide_elm_):
        return method_mock(
            request, Slide, '_minimal_element', return_value=slide_elm_
        )

    @pytest.fixture
    def package_(self, request):
        return instance_mock(request, Package)

    @pytest.fixture
    def part_related_by_(self, request, slide_layout_):
        return method_mock(
            request, Slide, 'part_related_by',
            return_value=slide_layout_
        )

    @pytest.fixture
    def partname_(self, request):
        return instance_mock(request, PackURI)

    @pytest.fixture
    def relate_to_(self, request):
        return method_mock(request, Part, 'relate_to')

    @pytest.fixture
    def shapes_(self, request):
        return instance_mock(request, _SlideShapeTree)

    @pytest.fixture
    def shapes_prop_(self, request, shapes_):
        return property_mock(request, Slide, 'shapes', return_value=shapes_)

    @pytest.fixture
    def slide(self):
        return Slide(None, None, None, None)

    @pytest.fixture
    def _SlidePlaceholders_(self, request, slide_placeholders_):
        return class_mock(
            request, 'pptx.parts.slide._SlidePlaceholders',
            return_value=slide_placeholders_
        )

    @pytest.fixture
    def _SlideShapeTree_(self, request, slide_shape_tree_):
        return class_mock(
            request, 'pptx.parts.slide._SlideShapeTree',
            return_value=slide_shape_tree_
        )

    @pytest.fixture
    def slide_elm_(self, request):
        return instance_mock(request, CT_Slide)

    @pytest.fixture
    def Slide_init_(self, request):
        return initializer_mock(request, Slide)

    @pytest.fixture
    def slide_layout_(self, request):
        return instance_mock(request, SlideLayout)

    @pytest.fixture
    def slide_placeholders_(self, request):
        return instance_mock(request, _SlidePlaceholders)

    @pytest.fixture
    def slide_shape_tree_(self, request):
        return instance_mock(request, _SlideShapeTree)


class DescribeSlideCollection(object):

    def it_supports_indexed_access(self, slides_with_slide_parts_, rIds_):
        slides, slide_, slide_2_ = slides_with_slide_parts_
        rId_, rId_2_ = rIds_
        # verify -----------------------
        assert slides[0] is slide_
        assert slides[1] is slide_2_
        slides._sldIdLst.__getitem__.assert_has_calls(
            [call(0), call(1)]
        )
        slides._prs.related_parts.__getitem__.assert_has_calls(
            [call(rId_), call(rId_2_)]
        )

    def it_raises_on_slide_index_out_of_range(self, slides):
        with pytest.raises(IndexError):
            slides[2]

    def it_can_iterate_over_the_slides(self, slides, slide_, slide_2_):
        assert [s for s in slides] == [slide_, slide_2_]

    def it_supports_len(self, slides):
        assert len(slides) == 2

    def it_can_add_a_new_slide(self, slides, slidelayout_, Slide_, slide_):
        slide = slides.add_slide(slidelayout_)
        Slide_.new.assert_called_once_with(
            slidelayout_, PackURI('/ppt/slides/slide3.xml'),
            slides._prs.package
        )
        slides._prs.relate_to.assert_called_once_with(slide_, RT.SLIDE)
        slides._sldIdLst.add_sldId.assert_called_once_with(ANY)
        assert slide is slide_

    def it_knows_the_next_available_slide_partname(
            self, slides_with_slide_parts_):
        slides = slides_with_slide_parts_[0]
        expected_partname = PackURI('/ppt/slides/slide3.xml')
        partname = slides._next_partname
        assert isinstance(partname, PackURI)
        assert partname == expected_partname

    def it_can_assign_partnames_to_the_slides(
            self, slides, slide_, slide_2_):
        slides.rename_slides()
        assert slide_.partname == '/ppt/slides/slide1.xml'
        assert slide_2_.partname == '/ppt/slides/slide2.xml'

    # fixtures -------------------------------------------------------
    #
    #   slides
    #   |
    #   +- ._sldIdLst = [sldId_, sldId_2_]
    #   |                |       |
    #   |                |       +- .rId = rId_2_
    #   |                |
    #   |                +- .rId = rId_
    #   +- ._prs
    #       |
    #       +- .related_parts = {rId_: slide_, rId_2_: slide_2_}
    #
    # ----------------------------------------------------------------

    @pytest.fixture
    def prs_(self, request, rel_, related_parts_):
        prs_ = instance_mock(request, PresentationPart)
        prs_.load_rel.return_value = rel_
        prs_.related_parts = related_parts_
        return prs_

    @pytest.fixture
    def rel_(self, request, rId_):
        return instance_mock(request, _Relationship, rId=rId_)

    @pytest.fixture
    def related_parts_(self, request, rIds_, slide_parts_):
        """
        Return pass-thru mock dict that both operates as a dict an records
        calls to __getitem__ for call asserts.
        """
        rId_, rId_2_ = rIds_
        slide_, slide_2_ = slide_parts_
        slide_rId_map = {rId_: slide_, rId_2_: slide_2_}

        def getitem(key):
            return slide_rId_map[key]

        related_parts_ = MagicMock()
        related_parts_.__getitem__.side_effect = getitem
        return related_parts_

    @pytest.fixture
    def rename_slides_(self, request):
        return method_mock(request, SlideCollection, 'rename_slides')

    @pytest.fixture
    def rId_(self, request):
        return 'rId1'

    @pytest.fixture
    def rId_2_(self, request):
        return 'rId2'

    @pytest.fixture
    def rIds_(self, request, rId_, rId_2_):
        return rId_, rId_2_

    @pytest.fixture
    def Slide_(self, request, slide_):
        Slide_ = class_mock(request, 'pptx.parts.slide.Slide')
        Slide_.new.return_value = slide_
        return Slide_

    @pytest.fixture
    def sldId_(self, request, rId_):
        return instance_mock(request, CT_SlideId, rId=rId_)

    @pytest.fixture
    def sldId_2_(self, request, rId_2_):
        return instance_mock(request, CT_SlideId, rId=rId_2_)

    @pytest.fixture
    def sldIdLst_(self, request, sldId_, sldId_2_):
        sldIdLst_ = instance_mock(request, CT_SlideIdList)
        sldIdLst_.__getitem__.side_effect = [sldId_, sldId_2_]
        sldIdLst_.__iter__.return_value = iter([sldId_, sldId_2_])
        sldIdLst_.__len__.return_value = 2
        return sldIdLst_

    @pytest.fixture
    def slide_(self, request):
        return instance_mock(request, Slide)

    @pytest.fixture
    def slide_2_(self, request):
        return instance_mock(request, Slide)

    @pytest.fixture
    def slide_parts_(self, request, slide_, slide_2_):
        return slide_, slide_2_

    @pytest.fixture
    def slidelayout_(self, request):
        return instance_mock(request, SlideLayout)

    @pytest.fixture
    def slides(self, sldIdLst_, prs_):
        return SlideCollection(sldIdLst_, prs_)

    @pytest.fixture
    def slides_with_slide_parts_(self, sldIdLst_, prs_, slide_parts_):
        slide_, slide_2_ = slide_parts_
        slides = SlideCollection(sldIdLst_, prs_)
        return slides, slide_, slide_2_


class Describe_SlideShapeTree(object):

    def it_constructs_a_slide_placeholder_for_a_placeholder_shape(
            self, factory_fixture):
        shapes, ph_elm_, _SlideShapeFactory_, slide_placeholder_ = (
            factory_fixture
        )
        slide_placeholder = shapes._shape_factory(ph_elm_)
        _SlideShapeFactory_.assert_called_once_with(ph_elm_, shapes)
        assert slide_placeholder is slide_placeholder_

    def it_can_find_the_title_placeholder(self, title_fixture):
        shapes, _shape_factory_, sp_2_, title_placeholder_ = title_fixture
        title_placeholder = shapes.title
        _shape_factory_.assert_called_once_with(sp_2_)
        assert title_placeholder == title_placeholder_

    def it_returns_None_when_slide_has_no_title_ph(self, no_title_fixture):
        shapes = no_title_fixture
        title_placeholder = shapes.title
        assert title_placeholder is None

    def it_can_add_an_autoshape(self, autoshape_fixture):
        # fixture ----------------------
        shapes, autoshape_type_id_, x_, y_, cx_, cy_ = autoshape_fixture[:6]
        AutoShapeType_, _add_sp_from_autoshape_type_ = autoshape_fixture[6:8]
        autoshape_type_, _shape_factory_, sp_ = autoshape_fixture[8:11]
        shape_ = autoshape_fixture[11]
        # exercise ---------------------
        shape = shapes.add_shape(autoshape_type_id_, x_, y_, cx_, cy_)
        # verify -----------------------
        AutoShapeType_.assert_called_once_with(autoshape_type_id_)
        _add_sp_from_autoshape_type_.assert_called_once_with(
            autoshape_type_, x_, y_, cx_, cy_
        )
        _shape_factory_.assert_called_once_with(sp_)
        assert shape is shape_

    def it_can_add_a_picture_shape(self, picture_fixture):
        # fixture ----------------------
        shapes, image_file_, x_, y_, cx_, cy_ = picture_fixture[:6]
        _get_or_add_image_part_, image_part_, rId_ = picture_fixture[6:9]
        _add_pic_from_image_part_, pic_ = picture_fixture[9:11]
        _shape_factory_, picture_ = picture_fixture[11:13]
        # exercise ---------------------
        picture = shapes.add_picture(image_file_, x_, y_, cx_, cy_)
        # verify -----------------------
        _get_or_add_image_part_.assert_called_once_with(image_file_)
        _add_pic_from_image_part_.assert_called_once_with(
            image_part_, rId_, x_, y_, cx_, cy_
        )
        _shape_factory_.assert_called_once_with(pic_)
        assert picture is picture_

    def it_can_add_a_table(self, table_fixture):
        # fixture ----------------------
        shapes, rows_, cols_, x_, y_, cx_, cy_ = table_fixture[:7]
        _add_graphicFrame_containing_table_ = table_fixture[7]
        _shape_factory_, graphicFrame_, table_ = table_fixture[8:]
        # exercise ---------------------
        table = shapes.add_table(rows_, cols_, x_, y_, cx_, cy_)
        # verify -----------------------
        _add_graphicFrame_containing_table_.assert_called_once_with(
            rows_, cols_, x_, y_, cx_, cy_
        )
        _shape_factory_.assert_called_once_with(graphicFrame_)
        assert table is table_

    def it_can_add_a_textbox(self, textbox_fixture):
        shapes, x_, y_, cx_, cy_, _add_textbox_sp_ = textbox_fixture[:6]
        _shape_factory_, sp_, textbox_ = textbox_fixture[6:]
        textbox = shapes.add_textbox(x_, y_, cx_, cy_)
        _add_textbox_sp_.assert_called_once_with(x_, y_, cx_, cy_)
        _shape_factory_.assert_called_once_with(sp_)
        assert textbox is textbox_

    def it_can_clone_placeholder_shapes_from_a_layout(self, clone_fixture):
        shapes, slide_layout_, placeholder_, _clone_layout_placeholder_ = (
            clone_fixture
        )
        shapes.clone_layout_placeholders(slide_layout_)
        _clone_layout_placeholder_.assert_called_once_with(placeholder_)

    def it_knows_the_index_of_each_shape(self, index_fixture):
        shapes, shape_, expected_idx = index_fixture
        idx = shapes.index(shape_)
        assert idx == expected_idx

    def it_raises_on_index_where_shape_not_found(self, index_fixture):
        shapes, shape_, expected_idx = index_fixture
        shapes._spTree.iter_shape_elms.return_value = []
        with pytest.raises(ValueError):
            shapes.index(shape_)

    def it_adds_a_graphicFrame_to_help_add_table(self, graphicFrame_fixture):
        # fixture ----------------------
        shapes, rows_, cols_, x_, y_, cx_, cy_ = graphicFrame_fixture[:7]
        spTree_, id_, name, graphicFrame_ = graphicFrame_fixture[7:]
        # exercise ---------------------
        graphicFrame = shapes._add_graphicFrame_containing_table(
            rows_, cols_, x_, y_, cx_, cy_
        )
        # verify -----------------------
        spTree_.add_table.assert_called_once_with(
            id_, name, rows_, cols_, x_, y_, cx_, cy_
        )
        assert graphicFrame is graphicFrame_

    def it_adds_an_image_to_help_add_picture(self, image_part_fixture):
        shapes, image_file_, slide_, image_part_, rId_ = image_part_fixture
        image_part, rId = shapes._get_or_add_image_part(image_file_)
        slide_._add_image.assert_called_once_with(image_file_)
        assert image_part == image_part_
        assert rId == rId_

    def it_adds_a_pic_to_help_add_picture(self, pic_fixture):
        # fixture ----------------------
        shapes, image_part_, rId_, x_, y_, cx_, cy_ = pic_fixture[:7]
        spTree_, id_, name, desc_ = pic_fixture[7:11]
        scaled_cx_, scaled_cy_, pic_ = pic_fixture[11:]
        # exercise ---------------------
        pic = shapes._add_pic_from_image_part(
            image_part_, rId_, x_, y_, cx_, cy_
        )
        # verify -----------------------
        image_part_._scale.assert_called_once_with(cx_, cy_)
        spTree_.add_pic.assert_called_once_with(
            id_, name, desc_, rId_, x_, y_, scaled_cx_, scaled_cy_
        )
        assert pic is pic_

    def it_adds_an_sp_to_help_add_shape(self, sp_fixture):
        # fixture ----------------------
        shapes, autoshape_type_, x_, y_, cx_, cy_ = sp_fixture[:6]
        spTree_, id_, name, prst_, sp_ = sp_fixture[6:]
        # exercise ---------------------
        sp = shapes._add_sp_from_autoshape_type(
            autoshape_type_, x_, y_, cx_, cy_
        )
        # verify -----------------------
        spTree_.add_autoshape.assert_called_once_with(
            id_, name, prst_, x_, y_, cx_, cy_
        )
        assert sp is sp_

    def it_adds_an_sp_to_help_add_textbox(self, textbox_sp_fixture):
        shapes, x_, y_, cx_, cy_, spTree_, id_, name, sp_ = (
            textbox_sp_fixture
        )
        sp = shapes._add_textbox_sp(x_, y_, cx_, cy_)
        spTree_.add_textbox.assert_called_once_with(
            id_, name, x_, y_, cx_, cy_
        )
        assert sp is sp_

    def it_clones_a_placeholder_to_help_clone_placeholders(
            self, clone_ph_fixture):
        shapes, layout_placeholder_, spTree_ = clone_ph_fixture[:3]
        id_, name_, ph_type_, orient_, sz_, idx_ = clone_ph_fixture[3:]
        shapes._clone_layout_placeholder(layout_placeholder_)
        spTree_.add_placeholder.assert_called_once_with(
            id_, name_, ph_type_, orient_, sz_, idx_
        )

    def it_can_find_the_next_placeholder_name_to_help_clone_placeholder(
            self, ph_name_fixture):
        shapes, ph_type, id_, orient, expected_name = ph_name_fixture
        name = shapes._next_ph_name(ph_type, id_, orient)
        print(shapes._spTree.xml)
        assert name == expected_name

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def autoshape_fixture(
            self, autoshape_type_id_, x_, y_, cx_, cy_, AutoShapeType_,
            _add_sp_from_autoshape_type_, autoshape_type_, _shape_factory_,
            sp_, shape_):
        shapes = _SlideShapeTree(None)
        _shape_factory_.return_value = shape_
        return (
            shapes, autoshape_type_id_, x_, y_, cx_, cy_, AutoShapeType_,
            _add_sp_from_autoshape_type_, autoshape_type_, _shape_factory_,
            sp_, shape_
        )

    @pytest.fixture
    def clone_fixture(
            self, slide_layout_, placeholder_, _clone_layout_placeholder_):
        shapes = _SlideShapeTree(None)
        slide_layout_.iter_cloneable_placeholders.return_value = (
            iter([placeholder_])
        )
        return (
            shapes, slide_layout_, placeholder_, _clone_layout_placeholder_
        )

    @pytest.fixture
    def clone_ph_fixture(
            self, slide_, layout_placeholder_, spTree_, _next_shape_id_, id_,
            _next_ph_name_, name_, ph_type_, orient_, sz_, idx_):
        shapes = _SlideShapeTree(slide_)
        return (
            shapes, layout_placeholder_, spTree_, id_, name_, ph_type_,
            orient_, sz_, idx_
        )

    @pytest.fixture
    def factory_fixture(
            self, ph_elm_, _SlideShapeFactory_, slide_placeholder_):
        shapes = _SlideShapeTree(None)
        return shapes, ph_elm_, _SlideShapeFactory_, slide_placeholder_

    @pytest.fixture
    def graphicFrame_fixture(
            self, slide_, rows_, cols_, x_, y_, cx_, cy_, spTree_,
            _next_shape_id_, id_, graphicFrame_):
        shapes = _SlideShapeTree(slide_)
        name = 'Table 41'
        return (
            shapes, rows_, cols_, x_, y_, cx_, cy_, spTree_, id_, name,
            graphicFrame_
        )

    @pytest.fixture
    def image_part_fixture(self, slide_, image_file_, image_part_, rId_):
        shapes = _SlideShapeTree(slide_)
        return shapes, image_file_, slide_, image_part_, rId_

    @pytest.fixture
    def index_fixture(self, slide_, shape_):
        shapes = _SlideShapeTree(slide_)
        expected_idx = 1
        return shapes, shape_, expected_idx

    @pytest.fixture
    def no_title_fixture(self, slide_, spTree_, sp_):
        shapes = _SlideShapeTree(slide_)
        spTree_.iter_shape_elms.return_value = [sp_, sp_]
        return shapes

    @pytest.fixture(params=[
        (ST_PlaceholderType.OBJ,   3, ST_Direction.HORZ,
         'Content Placeholder 2'),
        (ST_PlaceholderType.TBL,   4, ST_Direction.HORZ,
         'Table Placeholder 4'),
        (ST_PlaceholderType.TBL,   7, ST_Direction.VERT,
         'Vertical Table Placeholder 6'),
        (ST_PlaceholderType.TITLE, 2, ST_Direction.HORZ,
         'Title 2'),
    ])
    def ph_name_fixture(self, request, slide_):
        ph_type, id_, orient, expected_name = request.param
        slide_.spTree = (
            an_spTree().with_nsdecls().with_child(
                a_cNvPr().with_name('Title 1')).with_child(
                a_cNvPr().with_name('Table Placeholder 3'))
        ).element
        shapes = _SlideShapeTree(slide_)
        return shapes, ph_type, id_, orient, expected_name

    @pytest.fixture
    def pic_fixture(
            self, slide_, image_part_, rId_, x_, y_, cx_, cy_, spTree_,
            _next_shape_id_, id_, name, desc_, scaled_cx_, scaled_cy_,
            pic_):
        shapes = _SlideShapeTree(slide_)
        return (
            shapes, image_part_, rId_, x_, y_, cx_, cy_, spTree_, id_,
            name, desc_, scaled_cx_, scaled_cy_, pic_
        )

    @pytest.fixture
    def picture_fixture(
            self, image_file_, x_, y_, cx_, cy_, _get_or_add_image_part_,
            image_part_, rId_,  _add_pic_from_image_part_, pic_,
            _shape_factory_, picture_):
        shapes = _SlideShapeTree(None)
        _shape_factory_.return_value = picture_
        return (
            shapes, image_file_, x_, y_, cx_, cy_, _get_or_add_image_part_,
            image_part_, rId_,  _add_pic_from_image_part_, pic_,
            _shape_factory_, picture_
        )

    @pytest.fixture
    def sp_fixture(
            self, slide_, autoshape_type_, x_, y_, cx_, cy_, spTree_,
            _next_shape_id_, id_, prst_, sp_):
        shapes = _SlideShapeTree(slide_)
        name = 'Foobar 41'
        return (
            shapes, autoshape_type_, x_, y_, cx_, cy_, spTree_, id_, name,
            prst_, sp_
        )

    @pytest.fixture
    def table_fixture(
            self, rows_, cols_, x_, y_, cx_, cy_,
            _add_graphicFrame_containing_table_, _shape_factory_,
            graphicFrame_, table_):
        shapes = _SlideShapeTree(None)
        _shape_factory_.return_value = table_
        return (
            shapes, rows_, cols_, x_, y_, cx_, cy_,
            _add_graphicFrame_containing_table_, _shape_factory_,
            graphicFrame_, table_
        )

    @pytest.fixture
    def textbox_fixture(
            self, x_, y_, cx_, cy_, _add_textbox_sp_, _shape_factory_,
            sp_, textbox_):
        shapes = _SlideShapeTree(None)
        _shape_factory_.return_value = textbox_
        return (
            shapes, x_, y_, cx_, cy_, _add_textbox_sp_, _shape_factory_,
            sp_, textbox_
        )

    @pytest.fixture
    def textbox_sp_fixture(
            self, slide_, x_, y_, cx_, cy_, spTree_, _next_shape_id_,
            id_, sp_):
        shapes = _SlideShapeTree(slide_)
        name = 'TextBox 41'
        return shapes, x_, y_, cx_, cy_, spTree_, id_, name, sp_

    @pytest.fixture
    def title_fixture(self, slide_, sp_2_, _shape_factory_, shape_):
        shapes = _SlideShapeTree(slide_)
        _shape_factory_.return_value = shape_
        title_placeholder_ = shape_
        return shapes, _shape_factory_, sp_2_, title_placeholder_

    # fixture components ---------------------------------------------

    @pytest.fixture
    def _add_graphicFrame_containing_table_(self, request, graphicFrame_):
        return method_mock(
            request, _SlideShapeTree, '_add_graphicFrame_containing_table',
            return_value=graphicFrame_
        )

    @pytest.fixture
    def _add_pic_from_image_part_(self, request, pic_):
        return method_mock(
            request, _SlideShapeTree, '_add_pic_from_image_part',
            return_value=pic_
        )

    @pytest.fixture
    def _add_sp_from_autoshape_type_(self, request, sp_):
        return method_mock(
            request, _SlideShapeTree, '_add_sp_from_autoshape_type',
            return_value=sp_
        )

    @pytest.fixture
    def _add_textbox_sp_(self, request, sp_):
        return method_mock(
            request, _SlideShapeTree, '_add_textbox_sp', return_value=sp_
        )

    @pytest.fixture
    def AutoShapeType_(self, request, autoshape_type_):
        return class_mock(
            request, 'pptx.parts.slide.AutoShapeType',
            return_value=autoshape_type_
        )

    @pytest.fixture
    def autoshape_type_(self, request, prst_):
        return instance_mock(
            request, AutoShapeType, basename='Foobar', prst=prst_
        )

    @pytest.fixture
    def autoshape_type_id_(self, request):
        return instance_mock(request, int)

    @pytest.fixture
    def _clone_layout_placeholder_(self, request):
        return method_mock(
            request, _SlideShapeTree, '_clone_layout_placeholder'
        )

    @pytest.fixture
    def cols_(self, request):
        return instance_mock(request, int)

    @pytest.fixture
    def cx_(self, request):
        return instance_mock(request, int)

    @pytest.fixture
    def cy_(self, request):
        return instance_mock(request, int)

    @pytest.fixture
    def desc_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def _get_or_add_image_part_(self, request, image_part_, rId_):
        return method_mock(
            request, _SlideShapeTree, '_get_or_add_image_part',
            return_value=(image_part_, rId_)
        )

    @pytest.fixture
    def graphicFrame_(self, request):
        return instance_mock(request, CT_GraphicalObjectFrame)

    @pytest.fixture
    def id_(self, request):
        return 42

    @pytest.fixture
    def idx_(self, request):
        return instance_mock(request, int)

    @pytest.fixture
    def image_part_(self, request, desc_, scaled_cx_, scaled_cy_):
        image_part_ = instance_mock(request, ImagePart)
        image_part_._desc = desc_
        image_part_._scale.return_value = scaled_cx_, scaled_cy_
        return image_part_

    @pytest.fixture
    def image_file_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def layout_placeholder_(self, request, ph_type_, orient_, sz_, idx_):
        return instance_mock(
            request, _LayoutPlaceholder, ph_type=ph_type_, orient=orient_,
            sz=sz_, idx=idx_
        )

    @pytest.fixture
    def name(self):
        return 'Picture 41'

    @pytest.fixture
    def name_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def _next_ph_name_(self, request, name_):
        return method_mock(
            request, _SlideShapeTree, '_next_ph_name', return_value=name_
        )

    @pytest.fixture
    def _next_shape_id_(self, request, id_):
        return property_mock(
            request, _SlideShapeTree, '_next_shape_id', return_value=id_
        )

    @pytest.fixture
    def orient_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def ph_elm_(self, request):
        return instance_mock(request, CT_Shape)

    @pytest.fixture
    def ph_type_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def pic_(self, request):
        return instance_mock(request, CT_Picture)

    @pytest.fixture
    def picture_(self, request):
        return instance_mock(request, Picture)

    @pytest.fixture
    def placeholder_(self, request):
        return instance_mock(request, BasePlaceholder)

    @pytest.fixture
    def prst_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def rId_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def rows_(self, request):
        return instance_mock(request, int)

    @pytest.fixture
    def scaled_cx_(self, request):
        return instance_mock(request, int)

    @pytest.fixture
    def scaled_cy_(self, request):
        return instance_mock(request, int)

    @pytest.fixture
    def shape_(self, request, sp_2_):
        return instance_mock(request, Shape, element=sp_2_)

    @pytest.fixture
    def _shape_factory_(self, request):
        return method_mock(request, _SlideShapeTree, '_shape_factory')

    @pytest.fixture
    def slide_(self, request, spTree_, image_part_, rId_):
        slide_ = instance_mock(request, Slide)
        slide_.spTree = spTree_
        slide_._add_image.return_value = image_part_, rId_
        return slide_

    @pytest.fixture
    def slide_layout_(self, request):
        return instance_mock(request, SlideLayout)

    @pytest.fixture
    def slide_placeholder_(self, request):
        return instance_mock(request, _SlidePlaceholder)

    @pytest.fixture
    def _SlideShapeFactory_(self, request, slide_placeholder_):
        return function_mock(
            request, 'pptx.parts.slide._SlideShapeFactory',
            return_value=slide_placeholder_
        )

    @pytest.fixture
    def sp_(self, request):
        return instance_mock(request, CT_Shape)

    @pytest.fixture
    def sp_2_(self, request):
        return instance_mock(request, CT_Shape, ph_idx=0)

    @pytest.fixture
    def spTree_(self, request, pic_, sp_, sp_2_, graphicFrame_):
        spTree_ = instance_mock(request, CT_GroupShape)
        spTree_.add_pic.return_value = pic_
        spTree_.add_autoshape.return_value = sp_
        spTree_.add_table.return_value = graphicFrame_
        spTree_.add_textbox.return_value = sp_
        spTree_.iter_shape_elms.return_value = [sp_, sp_2_]
        return spTree_

    @pytest.fixture
    def sz_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def table_(self, request):
        return instance_mock(request, Table)

    @pytest.fixture
    def textbox_(self, request):
        return instance_mock(request, Shape)

    @pytest.fixture
    def x_(self, request):
        return instance_mock(request, int)

    @pytest.fixture
    def y_(self, request):
        return instance_mock(request, int)


class Describe_SlideShapeFactory(object):

    def it_constructs_a_slide_placeholder_for_a_shape_element(
            self, factory_fixture):
        shape_elm, parent_, ShapeConstructor_, shape_ = factory_fixture
        shape = _SlideShapeFactory(shape_elm, parent_)
        ShapeConstructor_.assert_called_once_with(shape_elm, parent_)
        assert shape is shape_

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=['ph', 'sp', 'pic'])
    def factory_fixture(
            self, request, ph_bldr, slide_, _SlidePlaceholder_,
            slide_placeholder_, BaseShapeFactory_, base_shape_):
        shape_bldr, ShapeConstructor_, shape_mock = {
            'ph':  (ph_bldr, _SlidePlaceholder_, slide_placeholder_),
            'sp':  (an_sp(), BaseShapeFactory_,   base_shape_),
            'pic': (a_pic(), BaseShapeFactory_,   base_shape_),
        }[request.param]
        shape_elm = shape_bldr.with_nsdecls().element
        return shape_elm, slide_, ShapeConstructor_, shape_mock

    # fixture components -----------------------------------

    @pytest.fixture
    def BaseShapeFactory_(self, request, base_shape_):
        return function_mock(
            request, 'pptx.parts.slide.BaseShapeFactory',
            return_value=base_shape_
        )

    @pytest.fixture
    def base_shape_(self, request):
        return instance_mock(request, BaseShape)

    @pytest.fixture
    def _SlidePlaceholder_(self, request, slide_placeholder_):
        return class_mock(
            request, 'pptx.parts.slide._SlidePlaceholder',
            return_value=slide_placeholder_
        )

    @pytest.fixture
    def slide_placeholder_(self, request):
        return instance_mock(request, _SlidePlaceholder)

    @pytest.fixture
    def ph_bldr(self):
        return (
            an_sp().with_child(
                an_nvSpPr().with_child(
                    an_nvPr().with_child(
                        a_ph().with_idx(1))))
        )

    @pytest.fixture
    def slide_(self, request):
        return instance_mock(request, Slide)


class Describe_SlidePlaceholders(object):

    def it_constructs_a_slide_placeholder_for_a_placeholder_shape(
            self, factory_fixture):
        slide_placeholders, ph_elm_ = factory_fixture[:2]
        _SlideShapeFactory_, slide_placeholder_ = factory_fixture[2:]
        slide_placeholder = slide_placeholders._shape_factory(ph_elm_)
        _SlideShapeFactory_.assert_called_once_with(
            ph_elm_, slide_placeholders
        )
        assert slide_placeholder is slide_placeholder_

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def factory_fixture(
            self, ph_elm_, _SlideShapeFactory_, slide_placeholder_):
        slide_placeholders = _SlidePlaceholders(None)
        return (
            slide_placeholders, ph_elm_, _SlideShapeFactory_,
            slide_placeholder_
        )

    # fixture components ---------------------------------------------

    @pytest.fixture
    def slide_placeholder_(self, request):
        return instance_mock(request, _SlidePlaceholder)

    @pytest.fixture
    def _SlideShapeFactory_(self, request, slide_placeholder_):
        return function_mock(
            request, 'pptx.parts.slide._SlideShapeFactory',
            return_value=slide_placeholder_
        )

    @pytest.fixture
    def ph_elm_(self, request):
        return instance_mock(request, CT_Shape)


class Describe_SlidePlaceholder(object):

    def it_considers_inheritance_when_computing_pos_and_size(
            self, xfrm_fixture):
        slide_placeholder, _direct_or_inherited_value_ = xfrm_fixture[:2]
        attr_name, expected_value = xfrm_fixture[2:]
        value = getattr(slide_placeholder, attr_name)
        _direct_or_inherited_value_.assert_called_once_with(attr_name)
        assert value == expected_value

    def it_provides_direct_property_values_when_they_exist(
            self, direct_fixture):
        slide_placeholder, expected_width = direct_fixture
        width = slide_placeholder.width
        assert width == expected_width

    def it_provides_inherited_property_values_when_no_direct_value(
            self, inherited_fixture):
        slide_placeholder, _inherited_value_, inherited_left_ = (
            inherited_fixture
        )
        left = slide_placeholder.left
        _inherited_value_.assert_called_once_with('left')
        assert left == inherited_left_

    def it_knows_how_to_get_a_property_value_from_its_layout(
            self, layout_val_fixture):
        slide_placeholder, attr_name, expected_value = layout_val_fixture
        value = slide_placeholder._inherited_value(attr_name)
        assert value == expected_value

    def it_finds_its_corresponding_layout_placeholder_to_help_inherit(
            self, layout_ph_fixture):
        slide_placeholder, layout_, idx, layout_placeholder_ = (
            layout_ph_fixture
        )
        layout_placeholder = slide_placeholder._layout_placeholder
        layout_.placeholders.get.assert_called_once_with(idx=idx)
        assert layout_placeholder is layout_placeholder_

    def it_finds_its_slide_layout_to_help_inherit(
            self, slide_layout_fixture):
        slide_placeholder, slide_layout_ = slide_layout_fixture
        slide_layout = slide_placeholder._slide_layout
        assert slide_layout == slide_layout_

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def direct_fixture(self, sp, width):
        slide_placeholder = _SlidePlaceholder(sp, None)
        return slide_placeholder, width

    @pytest.fixture
    def inherited_fixture(self, sp, _inherited_value_, int_value_):
        slide_placeholder = _SlidePlaceholder(sp, None)
        return slide_placeholder, _inherited_value_, int_value_

    @pytest.fixture
    def layout_ph_fixture(
            self, request, idx_, int_value_, _slide_layout_, slide_layout_,
            layout_placeholder_):
        slide_placeholder = _SlidePlaceholder(None, None)
        idx_.return_value = int_value_
        slide_layout_.placeholders.get.return_value = layout_placeholder_
        return (
            slide_placeholder, slide_layout_, int_value_, layout_placeholder_
        )

    @pytest.fixture(params=[(True, 42), (False, None)])
    def layout_val_fixture(
            self, request, _layout_placeholder_, layout_placeholder_):
        has_layout_placeholder, expected_value = request.param
        slide_placeholder = _SlidePlaceholder(None, None)
        attr_name = 'width'
        if has_layout_placeholder:
            setattr(layout_placeholder_, attr_name, expected_value)
            _layout_placeholder_.return_value = layout_placeholder_
        else:
            _layout_placeholder_.return_value = None
        return slide_placeholder, attr_name, expected_value

    @pytest.fixture
    def slide_layout_fixture(self, parent_, slide_layout_):
        slide_placeholder = _SlidePlaceholder(None, parent_)
        return slide_placeholder, slide_layout_

    @pytest.fixture(params=['left', 'top', 'width', 'height'])
    def xfrm_fixture(self, request, _effective_value_, int_value_):
        attr_name = request.param
        slide_placeholder = _SlidePlaceholder(None, None)
        _effective_value_.return_value = int_value_
        return (
            slide_placeholder, _effective_value_, attr_name,
            int_value_
        )

    # fixture components ---------------------------------------------

    @pytest.fixture
    def _effective_value_(self, request):
        return method_mock(
            request, _SlidePlaceholder, '_effective_value'
        )

    @pytest.fixture
    def idx_(self, request):
        return property_mock(request, _SlidePlaceholder, 'idx')

    @pytest.fixture
    def _inherited_value_(self, request, int_value_):
        return method_mock(
            request, _SlidePlaceholder, '_inherited_value',
            return_value=int_value_
        )

    @pytest.fixture
    def int_value_(self, request):
        return instance_mock(request, int)

    @pytest.fixture
    def _layout_placeholder_(self, request):
        return property_mock(
            request, _SlidePlaceholder, '_layout_placeholder'
        )

    @pytest.fixture
    def layout_placeholder_(self, request):
        return instance_mock(request, _LayoutPlaceholder)

    @pytest.fixture
    def parent_(self, request, slide_):
        parent_ = instance_mock(request, _SlideShapeTree)
        parent_.part = slide_
        return parent_

    @pytest.fixture
    def slide_(self, request, slide_layout_):
        slide_ = instance_mock(request, Slide)
        slide_.slide_layout = slide_layout_
        return slide_

    @pytest.fixture
    def _slide_layout_(self, request, slide_layout_):
        return property_mock(
            request, _SlidePlaceholder, '_slide_layout',
            return_value=slide_layout_
        )

    @pytest.fixture
    def slide_layout_(self, request):
        return instance_mock(request, SlideLayout)

    @pytest.fixture
    def sp(self, width):
        return (
            an_sp().with_nsdecls('p', 'a').with_child(
                an_spPr().with_child(
                    an_xfrm().with_child(
                        an_ext().with_cx(width))))
        ).element

    @pytest.fixture
    def width(self):
        return 31416

########NEW FILE########
__FILENAME__ = test_slidelayout
# encoding: utf-8

"""
Test suite for pptx.parts.slidelayout module
"""

from __future__ import absolute_import

import pytest

from pptx.opc.constants import RELATIONSHIP_TYPE as RT
from pptx.oxml.shapes.autoshape import CT_Shape
from pptx.oxml.shapes.shared import ST_PlaceholderType
from pptx.parts.slidelayout import (
    _LayoutPlaceholder, _LayoutPlaceholders, _LayoutShapeFactory,
    _LayoutShapeTree, SlideLayout
)
from pptx.parts.slidemaster import _MasterPlaceholder, SlideMaster
from pptx.shapes.shape import BaseShape
from pptx.shapes.shapetree import BaseShapeTree

from ..oxml.unitdata.shape import (
    a_ph, a_pic, an_ext, an_nvPr, an_nvSpPr, an_sp, an_spPr, an_xfrm
)
from ..unitutil import (
    function_mock, class_mock, instance_mock, method_mock, property_mock
)


class DescribeSlideLayout(object):

    def it_knows_the_slide_master_it_inherits_from(self, master_fixture):
        slide_layout, slide_master_ = master_fixture
        slide_master = slide_layout.slide_master
        slide_layout.part_related_by.assert_called_once_with(RT.SLIDE_MASTER)
        assert slide_master is slide_master_

    def it_provides_access_to_its_shapes(self, shapes_fixture):
        slide_layout, _LayoutShapeTree_, layout_shape_tree_ = shapes_fixture
        shapes = slide_layout.shapes
        _LayoutShapeTree_.assert_called_once_with(slide_layout)
        assert shapes is layout_shape_tree_

    def it_provides_access_to_its_placeholders(self, placeholders_fixture):
        slide_layout, _LayoutPlaceholders_, layout_placeholders_ = (
            placeholders_fixture
        )
        placeholders = slide_layout.placeholders
        _LayoutPlaceholders_.assert_called_once_with(slide_layout)
        assert placeholders is layout_placeholders_

    def it_can_iterate_over_the_clonable_placeholders_it_contains(
            self, cloneable_fixture):
        slide_layout, expected_placeholders = cloneable_fixture
        cloneable_placeholders = (
            list(slide_layout.iter_cloneable_placeholders())
        )
        assert cloneable_placeholders == expected_placeholders

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        ((ST_PlaceholderType.TITLE, ST_PlaceholderType.BODY), (0, 1)),
        ((ST_PlaceholderType.TITLE, ST_PlaceholderType.DT),   (0,)),
        ((ST_PlaceholderType.DT,    ST_PlaceholderType.OBJ),  (1,)),
        ((ST_PlaceholderType.DT,    ST_PlaceholderType.FTR),  ()),
    ])
    def cloneable_fixture(
            self, request, placeholders_, placeholder_, placeholder_2_):
        ph_types, expected_indices = request.param
        slide_layout = SlideLayout(None, None, None, None)
        placeholder_.ph_type, placeholder_2_.ph_type = ph_types
        expected_placeholders = []
        for idx in expected_indices:
            expected_placeholders.append(placeholders_.return_value[idx])
        return slide_layout, expected_placeholders

    @pytest.fixture
    def master_fixture(self, slide_master_, part_related_by_):
        slide_layout = SlideLayout(None, None, None, None)
        return slide_layout, slide_master_

    @pytest.fixture
    def placeholders_fixture(
            self, _LayoutPlaceholders_, layout_placeholders_):
        slide_layout = SlideLayout(None, None, None, None)
        return slide_layout, _LayoutPlaceholders_, layout_placeholders_

    @pytest.fixture
    def shapes_fixture(self, _LayoutShapeTree_, layout_shape_tree_):
        slide_layout = SlideLayout(None, None, None, None)
        return slide_layout, _LayoutShapeTree_, layout_shape_tree_

    # fixture components -----------------------------------

    @pytest.fixture
    def _LayoutPlaceholders_(self, request, layout_placeholders_):
        return class_mock(
            request, 'pptx.parts.slidelayout._LayoutPlaceholders',
            return_value=layout_placeholders_
        )

    @pytest.fixture
    def _LayoutShapeTree_(self, request, layout_shape_tree_):
        return class_mock(
            request, 'pptx.parts.slidelayout._LayoutShapeTree',
            return_value=layout_shape_tree_
        )

    @pytest.fixture
    def layout_placeholders_(self, request):
        return instance_mock(request, _LayoutPlaceholders)

    @pytest.fixture
    def layout_shape_tree_(self, request):
        return instance_mock(request, _LayoutShapeTree)

    @pytest.fixture
    def part_related_by_(self, request, slide_master_):
        return method_mock(
            request, SlideLayout, 'part_related_by',
            return_value=slide_master_
        )

    @pytest.fixture
    def placeholder_(self, request):
        return instance_mock(request, _LayoutPlaceholder)

    @pytest.fixture
    def placeholder_2_(self, request):
        return instance_mock(request, _LayoutPlaceholder)

    @pytest.fixture
    def placeholders_(self, request, placeholder_, placeholder_2_):
        return property_mock(
            request, SlideLayout, 'placeholders',
            return_value=[placeholder_, placeholder_2_]
        )

    @pytest.fixture
    def slide_master_(self, request):
        return instance_mock(request, SlideMaster)


class Describe_LayoutShapeTree(object):

    def it_constructs_a_layout_placeholder_for_a_placeholder_shape(
            self, factory_fixture):
        layout_shapes, ph_elm_, _LayoutShapeFactory_, layout_placeholder_ = (
            factory_fixture
        )
        layout_placeholder = layout_shapes._shape_factory(ph_elm_)
        _LayoutShapeFactory_.assert_called_once_with(ph_elm_, layout_shapes)
        assert layout_placeholder is layout_placeholder_

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def factory_fixture(
            self, ph_elm_, _LayoutShapeFactory_, layout_placeholder_):
        layout_shapes = _LayoutShapeTree(None)
        return (
            layout_shapes, ph_elm_, _LayoutShapeFactory_, layout_placeholder_
        )

    # fixture components ---------------------------------------------

    @pytest.fixture
    def layout_placeholder_(self, request):
        return instance_mock(request, _LayoutPlaceholder)

    @pytest.fixture
    def _LayoutShapeFactory_(self, request, layout_placeholder_):
        return function_mock(
            request, 'pptx.parts.slidelayout._LayoutShapeFactory',
            return_value=layout_placeholder_
        )

    @pytest.fixture
    def ph_elm_(self, request):
        return instance_mock(request, CT_Shape)


class Describe_LayoutShapeFactory(object):

    def it_constructs_a_layout_placeholder_for_a_shape_element(
            self, factory_fixture):
        shape_elm, parent_, ShapeConstructor_, shape_ = factory_fixture
        shape = _LayoutShapeFactory(shape_elm, parent_)
        ShapeConstructor_.assert_called_once_with(shape_elm, parent_)
        assert shape is shape_

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=['ph', 'sp', 'pic'])
    def factory_fixture(
            self, request, ph_bldr, slide_layout_, _LayoutPlaceholder_,
            layout_placeholder_, BaseShapeFactory_, base_shape_):
        shape_bldr, ShapeConstructor_, shape_mock = {
            'ph':  (ph_bldr, _LayoutPlaceholder_, layout_placeholder_),
            'sp':  (an_sp(), BaseShapeFactory_,   base_shape_),
            'pic': (a_pic(), BaseShapeFactory_,   base_shape_),
        }[request.param]
        shape_elm = shape_bldr.with_nsdecls().element
        return shape_elm, slide_layout_, ShapeConstructor_, shape_mock

    # fixture components -----------------------------------

    @pytest.fixture
    def BaseShapeFactory_(self, request, base_shape_):
        return function_mock(
            request, 'pptx.parts.slidelayout.BaseShapeFactory',
            return_value=base_shape_
        )

    @pytest.fixture
    def base_shape_(self, request):
        return instance_mock(request, BaseShape)

    @pytest.fixture
    def _LayoutPlaceholder_(self, request, layout_placeholder_):
        return class_mock(
            request, 'pptx.parts.slidelayout._LayoutPlaceholder',
            return_value=layout_placeholder_
        )

    @pytest.fixture
    def layout_placeholder_(self, request):
        return instance_mock(request, _LayoutPlaceholder)

    @pytest.fixture
    def ph_bldr(self):
        return (
            an_sp().with_child(
                an_nvSpPr().with_child(
                    an_nvPr().with_child(
                        a_ph().with_idx(1))))
        )

    @pytest.fixture
    def slide_layout_(self, request):
        return instance_mock(request, SlideLayout)


class Describe_LayoutPlaceholders(object):

    def it_constructs_a_layout_placeholder_for_a_placeholder_shape(
            self, factory_fixture):
        layout_placeholders, ph_elm_ = factory_fixture[:2]
        _LayoutShapeFactory_, layout_placeholder_ = factory_fixture[2:]
        layout_placeholder = layout_placeholders._shape_factory(ph_elm_)
        _LayoutShapeFactory_.assert_called_once_with(
            ph_elm_, layout_placeholders
        )
        assert layout_placeholder is layout_placeholder_

    def it_can_find_a_placeholder_by_idx_value(self, get_fixture):
        layout_placeholders, ph_idx, placeholder_ = get_fixture
        placeholder = layout_placeholders.get(idx=ph_idx)
        assert placeholder is placeholder_

    def it_returns_default_if_placeholder_having_idx_not_found(
            self, default_fixture):
        layout_placeholders = default_fixture
        default = 'barfoo'
        placeholder = layout_placeholders.get('foobar', default)
        assert placeholder is default

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def default_fixture(self, _iter_):
        layout_placeholders = _LayoutPlaceholders(None)
        return layout_placeholders

    @pytest.fixture
    def factory_fixture(
            self, ph_elm_, _LayoutShapeFactory_, layout_placeholder_):
        layout_placeholders = _LayoutPlaceholders(None)
        return (
            layout_placeholders, ph_elm_, _LayoutShapeFactory_,
            layout_placeholder_
        )

    @pytest.fixture(params=[0, 1])
    def get_fixture(self, request, _iter_, placeholder_, placeholder_2_):
        layout_placeholders = _LayoutPlaceholders(None)
        ph_idx = request.param
        ph_shape_ = {0: placeholder_, 1: placeholder_2_}[request.param]
        return layout_placeholders, ph_idx, ph_shape_

    # fixture components ---------------------------------------------

    @pytest.fixture
    def _iter_(self, request, placeholder_, placeholder_2_):
        return method_mock(
            request, _LayoutPlaceholders, '__iter__',
            return_value=iter([placeholder_, placeholder_2_])
        )

    @pytest.fixture
    def layout_placeholder_(self, request):
        return instance_mock(request, _LayoutPlaceholder)

    @pytest.fixture
    def _LayoutShapeFactory_(self, request, layout_placeholder_):
        return function_mock(
            request, 'pptx.parts.slidelayout._LayoutShapeFactory',
            return_value=layout_placeholder_
        )

    @pytest.fixture
    def ph_elm_(self, request):
        return instance_mock(request, CT_Shape)

    @pytest.fixture
    def placeholder_(self, request):
        return instance_mock(request, _LayoutPlaceholder, idx=0)

    @pytest.fixture
    def placeholder_2_(self, request):
        return instance_mock(request, _LayoutPlaceholder, idx=1)


class Describe_LayoutPlaceholder(object):

    def it_considers_inheritance_when_computing_pos_and_size(
            self, xfrm_fixture):
        layout_placeholder, _direct_or_inherited_value_ = xfrm_fixture[:2]
        attr_name, expected_value = xfrm_fixture[2:]
        value = getattr(layout_placeholder, attr_name)
        _direct_or_inherited_value_.assert_called_once_with(attr_name)
        assert value == expected_value

    def it_provides_direct_property_values_when_they_exist(
            self, direct_fixture):
        layout_placeholder, expected_width = direct_fixture
        width = layout_placeholder.width
        assert width == expected_width

    def it_provides_inherited_property_values_when_no_direct_value(
            self, inherited_fixture):
        layout_placeholder, _inherited_value_, inherited_left_ = (
            inherited_fixture
        )
        left = layout_placeholder.left
        _inherited_value_.assert_called_once_with('left')
        assert left == inherited_left_

    def it_knows_how_to_get_a_property_value_from_its_master(
            self, mstr_val_fixture):
        layout_placeholder, attr_name, expected_value = mstr_val_fixture
        value = layout_placeholder._inherited_value(attr_name)
        assert value == expected_value

    def it_finds_its_corresponding_master_placeholder_to_help_inherit(
            self, mstr_ph_fixture):
        layout_placeholder, master_, mstr_ph_type, master_placeholder_ = (
            mstr_ph_fixture
        )
        master_placeholder = layout_placeholder._master_placeholder
        master_.placeholders.get.assert_called_once_with(mstr_ph_type, None)
        assert master_placeholder is master_placeholder_

    def it_finds_its_slide_master_to_help_inherit(self, slide_master_fixture):
        layout_placeholder, slide_master_ = slide_master_fixture
        slide_master = layout_placeholder._slide_master
        assert slide_master == slide_master_

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def direct_fixture(self, sp, width):
        layout_placeholder = _LayoutPlaceholder(sp, None)
        return layout_placeholder, width

    @pytest.fixture
    def inherited_fixture(self, sp, _inherited_value_, int_value_):
        layout_placeholder = _LayoutPlaceholder(sp, None)
        return layout_placeholder, _inherited_value_, int_value_

    @pytest.fixture(params=[
        ('tbl',  'body'),
        ('body', 'body'),
        ('obj',  'body'),
    ])
    def mstr_ph_fixture(
            self, request, ph_type_, _slide_master_, slide_master_,
            master_placeholder_):
        layout_placeholder = _LayoutPlaceholder(None, None)
        ph_type, mstr_ph_type = request.param
        ph_type_.return_value = ph_type
        slide_master_.placeholders.get.return_value = master_placeholder_
        return (
            layout_placeholder, slide_master_, mstr_ph_type,
            master_placeholder_
        )

    @pytest.fixture(params=[(True, 42), (False, None)])
    def mstr_val_fixture(
            self, request, _master_placeholder_, master_placeholder_):
        has_master_placeholder, expected_value = request.param
        layout_placeholder = _LayoutPlaceholder(None, None)
        attr_name = 'width'
        if has_master_placeholder:
            setattr(master_placeholder_, attr_name, expected_value)
            _master_placeholder_.return_value = master_placeholder_
        else:
            _master_placeholder_.return_value = None
        return layout_placeholder, attr_name, expected_value

    @pytest.fixture
    def slide_master_fixture(self, parent_, slide_master_):
        layout_placeholder = _LayoutPlaceholder(None, parent_)
        return layout_placeholder, slide_master_

    @pytest.fixture(params=['left', 'top', 'width', 'height'])
    def xfrm_fixture(self, request, _direct_or_inherited_value_, int_value_):
        attr_name = request.param
        layout_placeholder = _LayoutPlaceholder(None, None)
        _direct_or_inherited_value_.return_value = int_value_
        return (
            layout_placeholder, _direct_or_inherited_value_, attr_name,
            int_value_
        )

    # fixture components ---------------------------------------------

    @pytest.fixture
    def _direct_or_inherited_value_(self, request):
        return method_mock(
            request, _LayoutPlaceholder, '_direct_or_inherited_value'
        )

    @pytest.fixture
    def _inherited_value_(self, request, int_value_):
        return method_mock(
            request, _LayoutPlaceholder, '_inherited_value',
            return_value=int_value_
        )

    @pytest.fixture
    def int_value_(self, request):
        return instance_mock(request, int)

    @pytest.fixture
    def _master_placeholder_(self, request):
        return property_mock(
            request, _LayoutPlaceholder, '_master_placeholder'
        )

    @pytest.fixture
    def master_placeholder_(self, request):
        return instance_mock(request, _MasterPlaceholder)

    @pytest.fixture
    def parent_(self, request, slide_layout_):
        parent_ = instance_mock(request, BaseShapeTree)
        parent_.part = slide_layout_
        return parent_

    @pytest.fixture
    def ph_type_(self, request):
        return property_mock(request, _LayoutPlaceholder, 'ph_type')

    @pytest.fixture
    def slide_layout_(self, request, slide_master_):
        slide_layout_ = instance_mock(request, SlideLayout)
        slide_layout_.slide_master = slide_master_
        return slide_layout_

    @pytest.fixture
    def _slide_master_(self, request, slide_master_):
        return property_mock(
            request, _LayoutPlaceholder, '_slide_master',
            return_value=slide_master_
        )

    @pytest.fixture
    def slide_master_(self, request):
        return instance_mock(request, SlideMaster)

    @pytest.fixture
    def sp(self, width):
        return (
            an_sp().with_nsdecls('p', 'a').with_child(
                an_spPr().with_child(
                    an_xfrm().with_child(
                        an_ext().with_cx(width))))
        ).element

    @pytest.fixture
    def width(self):
        return 31416

########NEW FILE########
__FILENAME__ = test_slidemaster
# encoding: utf-8

"""
Test suite for pptx.parts.slidemaster module
"""

from __future__ import absolute_import, print_function

import pytest

from pptx.oxml.shapes.autoshape import CT_Shape
from pptx.oxml.slidemaster import CT_SlideLayoutIdList
from pptx.parts.slidelayout import SlideLayout
from pptx.parts.slidemaster import (
    _MasterPlaceholder, _MasterPlaceholders, _MasterShapeFactory,
    _MasterShapeTree, _SlideLayouts, SlideMaster
)
from pptx.shapes.shape import BaseShape

from ..oxml.unitdata.shape import a_ph, a_pic, an_nvPr, an_nvSpPr, an_sp
from ..oxml.unitdata.slides import (
    a_sldLayoutId, a_sldLayoutIdLst, a_sldMaster
)
from ..unitutil import (
    function_mock, class_mock, instance_mock, method_mock, property_mock
)


class DescribeSlideMaster(object):

    def it_provides_access_to_its_placeholders(self, slide_master):
        placeholders = slide_master.placeholders
        assert isinstance(placeholders, _MasterPlaceholders)
        assert placeholders._slide is slide_master

    def it_provides_access_to_its_shapes(self, slide_master):
        shapes = slide_master.shapes
        assert isinstance(shapes, _MasterShapeTree)
        assert shapes._slide is slide_master

    def it_provides_access_to_its_slide_layouts(self, slide_master):
        slide_layouts = slide_master.slide_layouts
        assert isinstance(slide_layouts, _SlideLayouts)

    def it_provides_access_to_its_sldLayoutIdLst(self, slide_master):
        sldLayoutIdLst = slide_master.sldLayoutIdLst
        assert isinstance(sldLayoutIdLst, CT_SlideLayoutIdList)

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[True, False])
    def sldMaster(self, request):
        has_sldLayoutIdLst = request.param
        sldMaster_bldr = a_sldMaster().with_nsdecls()
        if has_sldLayoutIdLst:
            sldMaster_bldr.with_child(a_sldLayoutIdLst())
        return sldMaster_bldr.element

    @pytest.fixture
    def slide_master(self, sldMaster):
        return SlideMaster(None, None, sldMaster, None)


class DescribeSlideLayouts(object):

    def it_knows_how_many_layouts_it_contains(self, len_fixture):
        slide_layouts, expected_count = len_fixture
        slide_layout_count = len(slide_layouts)
        assert slide_layout_count == expected_count

    def it_can_iterate_over_the_slide_layouts(self, iter_fixture):
        slide_layouts, slide_layout_, slide_layout_2_ = iter_fixture
        assert [s for s in slide_layouts] == [slide_layout_, slide_layout_2_]

    def it_iterates_over_rIds_to_help__iter__(self, iter_rIds_fixture):
        slide_layouts, expected_rIds = iter_rIds_fixture
        assert [rId for rId in slide_layouts._iter_rIds()] == expected_rIds

    def it_supports_indexed_access(self, getitem_fixture):
        slide_layouts, idx, slide_layout_ = getitem_fixture
        slide_layout = slide_layouts[idx]
        assert slide_layout is slide_layout_

    def it_raises_on_slide_layout_index_out_of_range(self, getitem_fixture):
        slide_layouts = getitem_fixture[0]
        with pytest.raises(IndexError):
            slide_layouts[2]

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def getitem_fixture(self, slide_master, related_parts_, slide_layout_):
        slide_layouts = _SlideLayouts(slide_master)
        related_parts_.return_value = {'rId1': None, 'rId2': slide_layout_}
        idx = 1
        return slide_layouts, idx, slide_layout_

    @pytest.fixture
    def iter_fixture(
            self, slide_master_, _iter_rIds_, slide_layout_, slide_layout_2_):
        slide_master_.related_parts = {
            'rId1': slide_layout_, 'rId2': slide_layout_2_
        }
        slide_layouts = _SlideLayouts(slide_master_)
        return slide_layouts, slide_layout_, slide_layout_2_

    @pytest.fixture
    def iter_rIds_fixture(self, slide_master):
        slide_layouts = _SlideLayouts(slide_master)
        expected_rIds = ['rId1', 'rId2']
        return slide_layouts, expected_rIds

    @pytest.fixture
    def len_fixture(self, slide_master_):
        slide_layouts = _SlideLayouts(slide_master_)
        slide_master_.sldLayoutIdLst = [1, 2]
        expected_count = 2
        return slide_layouts, expected_count

    # fixture components -----------------------------------

    @pytest.fixture
    def _iter_rIds_(self, request):
        return method_mock(
            request, _SlideLayouts, '_iter_rIds',
            return_value=iter(['rId1', 'rId2'])
        )

    @pytest.fixture
    def related_parts_(self, request):
        return property_mock(request, SlideMaster, 'related_parts')

    @pytest.fixture
    def sldMaster(self, request):
        sldMaster_bldr = (
            a_sldMaster().with_nsdecls('p', 'r').with_child(
                a_sldLayoutIdLst().with_child(
                    a_sldLayoutId().with_rId('rId1')).with_child(
                    a_sldLayoutId().with_rId('rId2'))
            )
        )
        return sldMaster_bldr.element

    @pytest.fixture
    def slide_layout_(self, request):
        return instance_mock(request, SlideLayout)

    @pytest.fixture
    def slide_layout_2_(self, request):
        return instance_mock(request, SlideLayout)

    @pytest.fixture
    def slide_master(self, sldMaster):
        return SlideMaster(None, None, sldMaster, None)

    @pytest.fixture
    def slide_master_(self, request):
        return instance_mock(request, SlideMaster)


class Describe_MasterShapeFactory(object):

    def it_constructs_a_master_placeholder_for_a_shape_element(
            self, factory_fixture):
        shape_elm, parent_, ShapeConstructor_, shape_ = factory_fixture
        shape = _MasterShapeFactory(shape_elm, parent_)
        ShapeConstructor_.assert_called_once_with(shape_elm, parent_)
        assert shape is shape_

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=['ph', 'sp', 'pic'])
    def factory_fixture(
            self, request, ph_bldr, slide_master_, _MasterPlaceholder_,
            master_placeholder_, BaseShapeFactory_, base_shape_):
        shape_bldr, ShapeConstructor_, shape_mock = {
            'ph':  (ph_bldr, _MasterPlaceholder_, master_placeholder_),
            'sp':  (an_sp(), BaseShapeFactory_,   base_shape_),
            'pic': (a_pic(), BaseShapeFactory_,   base_shape_),
        }[request.param]
        shape_elm = shape_bldr.with_nsdecls().element
        return shape_elm, slide_master_, ShapeConstructor_, shape_mock

    # fixture components -----------------------------------

    @pytest.fixture
    def BaseShapeFactory_(self, request, base_shape_):
        return function_mock(
            request, 'pptx.parts.slidemaster.BaseShapeFactory',
            return_value=base_shape_
        )

    @pytest.fixture
    def base_shape_(self, request):
        return instance_mock(request, BaseShape)

    @pytest.fixture
    def _MasterPlaceholder_(self, request, master_placeholder_):
        return class_mock(
            request, 'pptx.parts.slidemaster._MasterPlaceholder',
            return_value=master_placeholder_
        )

    @pytest.fixture
    def master_placeholder_(self, request):
        return instance_mock(request, _MasterPlaceholder)

    @pytest.fixture
    def ph_bldr(self):
        return (
            an_sp().with_child(
                an_nvSpPr().with_child(
                    an_nvPr().with_child(
                        a_ph().with_idx(1))))
        )

    @pytest.fixture
    def slide_master_(self, request):
        return instance_mock(request, SlideMaster)


class Describe_MasterShapeTree(object):

    def it_constructs_a_master_placeholder_for_a_placeholder_element(
            self, factory_fixture):
        master_shapes, ph_elm_, _MasterShapeFactory_, master_placeholder_ = (
            factory_fixture
        )
        master_placeholder = master_shapes._shape_factory(ph_elm_)
        _MasterShapeFactory_.assert_called_once_with(ph_elm_, master_shapes)
        assert master_placeholder is master_placeholder_

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def factory_fixture(
            self, ph_elm_, _MasterShapeFactory_, master_placeholder_):
        master_shapes = _MasterShapeTree(None)
        return (
            master_shapes, ph_elm_, _MasterShapeFactory_, master_placeholder_
        )

    # fixture components ---------------------------------------------

    @pytest.fixture
    def master_placeholder_(self, request):
        return instance_mock(request, _MasterPlaceholder)

    @pytest.fixture
    def _MasterShapeFactory_(self, request, master_placeholder_):
        return function_mock(
            request, 'pptx.parts.slidemaster._MasterShapeFactory',
            return_value=master_placeholder_
        )

    @pytest.fixture
    def ph_elm_(self, request):
        return instance_mock(request, CT_Shape)


class Describe_MasterPlaceholders(object):

    def it_uses_master_shape_factory_to_construct_placeholder_shapes(
            self, factory_fixture):
        master_placeholders, shape_elm_ = factory_fixture[:2]
        _MasterShapeFactory_, placeholder_ = factory_fixture[2:]
        placeholder = master_placeholders._shape_factory(shape_elm_)
        _MasterShapeFactory_.assert_called_once_with(
            shape_elm_, master_placeholders
        )
        assert placeholder is placeholder_

    def it_can_find_a_placeholder_by_type(self, get_fixture):
        master_placeholders, ph_type, placeholder_ = get_fixture
        placeholder = master_placeholders.get(ph_type)
        assert placeholder is placeholder_

    def it_returns_default_if_placeholder_of_type_not_found(
            self, default_fixture):
        master_placeholders = default_fixture
        default = 'barfoo'
        placeholder = master_placeholders.get('foobar', default)
        assert placeholder is default

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def default_fixture(self, _iter_):
        master_placeholders = _MasterPlaceholders(None)
        return master_placeholders

    @pytest.fixture
    def factory_fixture(
            self, ph_elm_, _MasterShapeFactory_, placeholder_):
        master_placeholders = _MasterPlaceholders(None)
        return (
            master_placeholders, ph_elm_, _MasterShapeFactory_, placeholder_
        )

    @pytest.fixture(params=['title', 'body'])
    def get_fixture(self, request, _iter_, placeholder_, placeholder_2_):
        master_placeholders = _MasterPlaceholders(None)
        ph_type = request.param
        ph_shape_ = {
            'title': placeholder_, 'body': placeholder_2_
        }[request.param]
        return master_placeholders, ph_type, ph_shape_

    # fixture components ---------------------------------------------

    @pytest.fixture
    def _iter_(self, request, placeholder_, placeholder_2_):
        return method_mock(
            request, _MasterPlaceholders, '__iter__',
            return_value=iter([placeholder_, placeholder_2_])
        )

    @pytest.fixture
    def _MasterShapeFactory_(self, request, placeholder_):
        return function_mock(
            request, 'pptx.parts.slidemaster._MasterShapeFactory',
            return_value=placeholder_
        )

    @pytest.fixture
    def ph_elm_(self, request):
        return instance_mock(request, CT_Shape)

    @pytest.fixture
    def placeholder_(self, request):
        return instance_mock(request, _MasterPlaceholder, ph_type='title')

    @pytest.fixture
    def placeholder_2_(self, request):
        return instance_mock(request, _MasterPlaceholder, ph_type='body')

########NEW FILE########
__FILENAME__ = test_autoshape
# encoding: utf-8

"""
Test suite for pptx.shapes.autoshape module
"""

from __future__ import absolute_import, print_function

import pytest

from pptx.dml.fill import FillFormat
from pptx.dml.line import LineFormat
from pptx.enum.shapes import MSO_SHAPE, MSO_SHAPE_TYPE
from pptx.shapes.autoshape import (
    Adjustment, AdjustmentCollection, AutoShapeType, Shape
)
from pptx.oxml import parse_xml_bytes
from pptx.oxml.shapes.autoshape import CT_PresetGeometry2D, CT_Shape

from ..oxml.unitdata.shape import a_gd, a_prstGeom, an_avLst
from ..unitutil import class_mock, instance_mock, property_mock


class DescribeAdjustment(object):

    def it_knows_its_effective_value(self, effective_val_fixture_):
        adjustment, expected_effective_value = effective_val_fixture_
        assert adjustment.effective_value == expected_effective_value

    # fixture --------------------------------------------------------

    def _effective_adj_val_cases():
        return [
            # no actual, effective should be determined by default value
            (50000, None, 0.5),
            # actual matches default
            (50000, 50000, 0.5),
            # actual is different than default
            (50000, 12500, 0.125),
            # actual is zero
            (50000, 0, 0.0),
            # negative default
            (-20833, None, -0.20833),
            # negative actual
            (-20833, -5678901, -56.78901),
        ]

    @pytest.fixture(params=_effective_adj_val_cases())
    def effective_val_fixture_(self, request):
        name = None
        def_val, actual, expected_effective_value = request.param
        adjustment = Adjustment(name, def_val, actual)
        return adjustment, expected_effective_value


class DescribeAdjustmentCollection(object):

    def it_should_load_default_adjustment_values(self, prstGeom_cases_):
        prstGeom, prst, expected = prstGeom_cases_
        adjustments = AdjustmentCollection(prstGeom)._adjustments
        actuals = tuple([(adj.name, adj.def_val) for adj in adjustments])
        assert len(adjustments) == len(expected)
        assert actuals == expected

    def it_should_load_adj_val_actuals_from_xml(
            self, load_adj_actuals_fixture_):
        prstGeom, expected_actuals, prstGeom_xml = load_adj_actuals_fixture_
        adjustments = AdjustmentCollection(prstGeom)._adjustments
        actual_actuals = dict([(a.name, a.actual) for a in adjustments])
        assert actual_actuals == expected_actuals

    def it_provides_normalized_effective_value_on_indexed_access(
            self, indexed_access_fixture_):
        prstGeom, prst, expected_values = indexed_access_fixture_
        adjustments = AdjustmentCollection(prstGeom)
        actual_values = [adjustments[idx] for idx in range(len(adjustments))]
        assert actual_values == expected_values

    def it_should_update_actual_value_on_indexed_assignment(
            self, indexed_assignment_fixture_):
        """
        Assignment to AdjustmentCollection[n] updates nth actual
        """
        adjs, idx, new_val, expected = indexed_assignment_fixture_
        adjs[idx] = new_val
        assert adjs._adjustments[idx].actual == expected

    def it_should_round_trip_indexed_assignment(self, adjustments):
        new_value = 0.375
        assert adjustments[0] != new_value
        # exercise ---------------------
        adjustments[0] = new_value
        # verify -----------------------
        assert adjustments[0] == new_value

    def it_should_raise_on_bad_index(self, adjustments):
        with pytest.raises(IndexError):
            adjustments[-6]
        with pytest.raises(IndexError):
            adjustments[6]
        with pytest.raises(TypeError):
            adjustments[0.0]
        with pytest.raises(TypeError):
            adjustments['0']
        with pytest.raises(IndexError):
            adjustments[-6] = 1.0
        with pytest.raises(IndexError):
            adjustments[6] = 1.0
        with pytest.raises(TypeError):
            adjustments[0.0] = 1.0
        with pytest.raises(TypeError):
            adjustments['0'] = 1.0

    def it_should_raise_on_assigned_bad_value(self, adjustments):
        """
        AdjustmentCollection[n] = val raises on val is not number
        """
        with pytest.raises(ValueError):
            adjustments[0] = '1.0'

    def it_writes_adj_vals_to_xml_on_assignment(
            self, adjustments_with_prstGeom_):
        adjs, guides = adjustments_with_prstGeom_
        adjs[0] = 0.999
        adjs._prstGeom.rewrite_guides.assert_called_once_with(guides)

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def adjustments(self):
        prstGeom = a_prstGeom().with_nsdecls().with_prst('chevron').element
        return AdjustmentCollection(prstGeom)

    @pytest.fixture
    def adjustments_with_prstGeom_(self, request):
        prstGeom = a_prstGeom().with_nsdecls().with_prst('chevron').element
        adjustments = AdjustmentCollection(prstGeom)
        prstGeom_ = instance_mock(
            request, CT_PresetGeometry2D, name='prstGeom_'
        )
        adjustments._prstGeom = prstGeom_
        guides = [('adj', 99900)]
        return adjustments, guides

    def _adj_actuals_cases():
        gd_bldr = a_gd().with_name('adj2').with_fmla('val 25000')
        avLst_bldr = an_avLst().with_child(gd_bldr)
        mathDivide_bldr = (
            a_prstGeom().with_nsdecls()
                        .with_prst('mathDivide')
                        .with_child(avLst_bldr)
        )

        gd_bldr = a_gd().with_name('adj').with_fmla('val 25000')
        avLst_bldr = an_avLst().with_child(gd_bldr)
        rect_bldr = (
            a_prstGeom().with_nsdecls()
                        .with_prst('rect')
                        .with_child(avLst_bldr)
        )

        gd_bldr_1 = a_gd().with_name('adj1').with_fmla('val 111')
        gd_bldr_2 = a_gd().with_name('adj2').with_fmla('val 222')
        gd_bldr_3 = a_gd().with_name('adj3').with_fmla('val 333')
        avLst_bldr = (
            an_avLst().with_child(gd_bldr_1)
                      .with_child(gd_bldr_2)
                      .with_child(gd_bldr_3)
        )
        wedgeRoundRectCallout_bldr = (
            a_prstGeom().with_nsdecls()
                        .with_prst('wedgeRoundRectCallout')
                        .with_child(avLst_bldr)
        )

        return [
            # no adjustment values in xml or spec
            (a_prstGeom().with_nsdecls()
                         .with_prst('rect')
                         .with_child(an_avLst()),
             ()),
            # no adjustment values in xml, but some in spec
            (a_prstGeom().with_nsdecls().with_prst('circularArrow'),
             (('adj1', None), ('adj2', None), ('adj3', None), ('adj4', None),
              ('adj5', None))),
            # adjustment value in xml but none in spec
            (rect_bldr, ()),
            # middle adjustment value in xml
            (mathDivide_bldr,
             (('adj1', None), ('adj2', 25000), ('adj3', None))),
            # all adjustment values in xml
            (wedgeRoundRectCallout_bldr,
             (('adj1', 111), ('adj2', 222), ('adj3', 333))),
        ]

    @pytest.fixture(params=_adj_actuals_cases())
    def load_adj_actuals_fixture_(self, request):
        prstGeom_bldr, adj_vals = request.param
        prstGeom = prstGeom_bldr.element
        expected = dict(adj_vals)
        prstGeom_xml = prstGeom_bldr.xml
        return prstGeom, expected, prstGeom_xml

    def _prstGeom_cases():
        return [
            # rect has no adjustments
            ('rect', ()),
            # chevron has one simple one
            ('chevron', (('adj', 50000),)),
            # one with several and some negative
            ('accentBorderCallout1',
             (('adj1', 18750), ('adj2', -8333), ('adj3', 112500),
              ('adj4', -38333))),
            # another one with some negative
            ('wedgeRoundRectCallout',
             (('adj1', -20833), ('adj2', 62500), ('adj3', 16667))),
            # one with values outside normal range
            ('circularArrow',
             (('adj1', 12500), ('adj2', 1142319), ('adj3', 20457681),
              ('adj4', 10800000), ('adj5', 12500))),
        ]

    @pytest.fixture(params=_prstGeom_cases())
    def prstGeom_cases_(self, request):
        prst, expected_values = request.param
        prstGeom = (
            a_prstGeom().with_nsdecls()
                        .with_prst(prst)
                        .with_child(an_avLst())
                        .element
        )
        return prstGeom, prst, expected_values

    def _effective_val_cases():
        return [
            ('rect', ()),
            ('chevron', (0.5,)),
            ('circularArrow', (0.125, 11.42319, 204.57681, 108.0, 0.125))
        ]

    @pytest.fixture(params=_effective_val_cases())
    def indexed_access_fixture_(self, request):
        prst, effective_values = request.param
        prstGeom = a_prstGeom().with_nsdecls().with_prst(prst).element
        return prstGeom, prst, list(effective_values)

    def _indexed_assignment_cases():
        return [
            ('chevron', 0, 0.5, 50000),
            ('circularArrow', 4, 99.99, 9999000),
        ]

    @pytest.fixture(params=_indexed_assignment_cases())
    def indexed_assignment_fixture_(self, request):
        prst, idx, new_val, expected = request.param
        prstGeom = a_prstGeom().with_nsdecls().with_prst(prst).element
        adjustments = AdjustmentCollection(prstGeom)
        return adjustments, idx, new_val, expected


class DescribeAutoShapeType(object):

    def it_knows_the_details_of_the_auto_shape_type_it_represents(self):
        autoshape_type = AutoShapeType(MSO_SHAPE.ROUNDED_RECTANGLE)
        assert autoshape_type.autoshape_type_id == MSO_SHAPE.ROUNDED_RECTANGLE
        assert autoshape_type.prst == 'roundRect'
        assert autoshape_type.basename == 'Rounded Rectangle'

    def it_knows_the_default_adj_vals_for_its_autoshape_type(
            self, default_adj_vals_fixture_):
        prst, default_adj_vals = default_adj_vals_fixture_
        _default_adj_vals = AutoShapeType.default_adjustment_values(prst)
        assert _default_adj_vals == default_adj_vals

    def it_knows_the_autoshape_type_id_for_each_prst_key(self):
        assert AutoShapeType.id_from_prst('rect') == MSO_SHAPE.RECTANGLE

    def it_raises_when_asked_for_autoshape_type_id_with_a_bad_prst(self):
        with pytest.raises(KeyError):
            AutoShapeType.id_from_prst('badPrst')

    def it_caches_autoshape_type_lookups(self):
        autoshape_type_id = MSO_SHAPE.ROUNDED_RECTANGLE
        autoshape_type_1 = AutoShapeType(autoshape_type_id)
        autoshape_type_2 = AutoShapeType(autoshape_type_id)
        assert autoshape_type_2 is autoshape_type_1

    def it_raises_on_construction_with_bad_autoshape_type_id(self):
        with pytest.raises(KeyError):
            AutoShapeType(9999)

    # fixtures -------------------------------------------------------

    def _default_adj_vals_cases():
        return [
            ('rect', ()),
            ('chevron', (('adj', 50000),)),
            ('leftCircularArrow', (('adj1', 12500), ('adj2', -1142319),
             ('adj3', 1142319), ('adj4', 10800000), ('adj5', 12500))),
        ]

    @pytest.fixture(params=_default_adj_vals_cases())
    def default_adj_vals_fixture_(self, request):
        prst, default_adj_vals = request.param
        return prst, default_adj_vals


class DescribeShape(object):

    def it_initializes_adjustments_on_first_ref(self, init_adjs_fixture_):
        shape, adjs_, AdjustmentCollection_, sp_ = init_adjs_fixture_
        assert shape.adjustments is adjs_
        AdjustmentCollection_.assert_called_once_with(sp_.prstGeom)

    def it_knows_its_autoshape_type(self, autoshape_type_fixture_):
        shape, autoshape_type, AutoShapeType_, prst = autoshape_type_fixture_
        assert shape.auto_shape_type == autoshape_type
        AutoShapeType_.id_from_prst.assert_called_once_with(prst)

    def it_raises_when_auto_shape_type_called_on_non_autoshape(
            self, non_autoshape_shape_):
        with pytest.raises(ValueError):
            non_autoshape_shape_.auto_shape_type

    def it_has_a_fill(self, shape):
        assert isinstance(shape.fill, FillFormat)

    def it_has_a_line(self, shape):
        assert isinstance(shape.line, LineFormat)

    def it_knows_its_shape_type_when_its_a_placeholder(
            self, placeholder_shape_):
        assert placeholder_shape_.shape_type == MSO_SHAPE_TYPE.PLACEHOLDER

    def it_knows_its_shape_type_when_its_not_a_placeholder(
            self, non_placeholder_shapes_):
        autoshape_shape_, textbox_shape_ = non_placeholder_shapes_
        assert autoshape_shape_.shape_type == MSO_SHAPE_TYPE.AUTO_SHAPE
        assert textbox_shape_.shape_type == MSO_SHAPE_TYPE.TEXT_BOX

    def it_raises_when_shape_type_called_on_unrecognized_shape(self):
        xml = (
            '<p:sp xmlns:p="http://schemas.openxmlformats.org/presentationml/'
            '2006/main" xmlns:a="http://schemas.openxmlformats.org/drawingml/'
            '2006/main"><p:nvSpPr><p:cNvPr id="9" name="Unknown Shape Type 8"'
            '/><p:cNvSpPr/><p:nvPr/></p:nvSpPr><p:spPr/></p:sp>'
        )
        sp = parse_xml_bytes(xml)
        shape = Shape(sp, None)
        # verify -----------------------
        with pytest.raises(NotImplementedError):
            shape.shape_type

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def autoshape_type_fixture_(
            self, request, shape, autoshape_type, AutoShapeType_, prst):
        return shape, autoshape_type, AutoShapeType_, prst

    @pytest.fixture
    def init_adjs_fixture_(
            self, request, shape, sp_, adjustments_, AdjustmentCollection_):
        return shape, adjustments_, AdjustmentCollection_, sp_

    # fixture components ---------------------------------------------

    @pytest.fixture
    def AdjustmentCollection_(self, request, adjustments_):
        return class_mock(
            request, 'pptx.shapes.autoshape.AdjustmentCollection',
            return_value=adjustments_
        )

    @pytest.fixture
    def adjustments_(self, request):
        return instance_mock(request, AdjustmentCollection)

    @pytest.fixture
    def AutoShapeType_(self, request, autoshape_type):
        AutoShapeType_ = class_mock(
            request, 'pptx.shapes.autoshape.AutoShapeType',
            return_value=autoshape_type
        )
        AutoShapeType_.id_from_prst.return_value = autoshape_type
        return AutoShapeType_

    @pytest.fixture
    def autoshape_type(self):
        return 66

    @pytest.fixture
    def non_autoshape_shape_(self, request, sp_):
        sp_.is_autoshape = False
        return Shape(sp_, None)

    @pytest.fixture
    def non_placeholder_shapes_(self, request):
        autoshape_sp_ = instance_mock(
            request, CT_Shape, name='autoshape_sp_', is_autoshape=True,
            is_textbox=False
        )
        autoshape_shape_ = Shape(autoshape_sp_, None)
        textbox_sp_ = instance_mock(
            request, CT_Shape, name='textbox_sp_', is_autoshape=False,
            is_textbox=True
        )
        textbox_shape_ = Shape(textbox_sp_, None)
        property_mock(request, Shape, 'is_placeholder', return_value=False)
        return autoshape_shape_, textbox_shape_

    @pytest.fixture
    def placeholder_shape_(self, request, sp_):
        placeholder_shape_ = Shape(sp_, None)
        property_mock(request, Shape, 'is_placeholder', return_value=True)
        return placeholder_shape_

    @pytest.fixture
    def prst(self):
        return 'foobar'

    @pytest.fixture
    def shape(self, request, sp_):
        return Shape(sp_, None)

    @pytest.fixture
    def sp_(self, request, prst):
        return instance_mock(request, CT_Shape, prst=prst, is_autoshape=True)

########NEW FILE########
__FILENAME__ = test_picture
# encoding: utf-8

"""
Test suite for pptx.shapes.picture module
"""

from __future__ import absolute_import, print_function, unicode_literals

import pytest

from pptx.dml.line import LineFormat
from pptx.enum.shapes import MSO_SHAPE_TYPE
from pptx.shapes.picture import Picture
from pptx.util import Pt

from ..oxml.unitdata.shape import a_pic, an_spPr


class Describe_Picture(object):

    def it_has_a_line(self, picture):
        assert isinstance(picture.line, LineFormat)
        # exercise line to test has_line interface, .ln and .get_or_add_ln()
        picture.line.width = Pt(1)
        assert picture.line.width == Pt(1)

    def it_knows_its_shape_type(self, picture):
        assert picture.shape_type == MSO_SHAPE_TYPE.PICTURE

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def picture(self):
        pic = a_pic().with_nsdecls().with_child(an_spPr()).element
        return Picture(pic, None)

########NEW FILE########
__FILENAME__ = test_placeholder
# encoding: utf-8

"""
Test suite for pptx.shapes.placeholder module
"""

from __future__ import absolute_import, print_function, unicode_literals

import pytest

from pptx.oxml.shapes.shared import (
    BaseShapeElement, ST_Direction, ST_PlaceholderSize
)
from pptx.shapes.placeholder import BasePlaceholder, BasePlaceholders

from ..oxml.unitdata.shape import (
    a_graphicFrame, a_ph, an_nvGraphicFramePr, an_nvPicPr, an_nvPr,
    an_nvSpPr, an_sp
)
from ..unitutil import instance_mock


class DescribeBasePlaceholders(object):

    def it_contains_only_placeholder_shapes(self, member_fixture):
        shape_elm_, is_ph_shape = member_fixture
        _is_ph_shape = BasePlaceholders._is_member_elm(shape_elm_)
        assert _is_ph_shape == is_ph_shape

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[True, False])
    def member_fixture(self, request, shape_elm_):
        is_ph_shape = request.param
        shape_elm_.has_ph_elm = is_ph_shape
        return shape_elm_, is_ph_shape

    # fixture components ---------------------------------------------

    @pytest.fixture
    def shape_elm_(self, request):
        return instance_mock(request, BaseShapeElement)


class DescribeBasePlaceholder(object):

    def it_knows_its_idx_value(self, idx_fixture):
        placeholder, idx = idx_fixture
        assert placeholder.idx == idx

    def it_knows_its_orient_value(self, orient_fixture):
        placeholder, orient = orient_fixture
        assert placeholder.orient == orient

    def it_knows_its_sz_value(self, sz_fixture):
        placeholder, sz = sz_fixture
        assert placeholder.sz == sz

    def it_knows_its_placeholder_type(self, type_fixture):
        placeholder, ph_type = type_fixture
        assert placeholder.ph_type == ph_type

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        ('sp',           None, 'title', 0),
        ('sp',           0,    'title', 0),
        ('sp',           3,    'body',  3),
        ('pic',          6,    'pic',   6),
        ('graphicFrame', 9,    'tbl',   9),
    ])
    def idx_fixture(self, request):
        tagname, idx, ph_type, expected_idx = request.param
        shape_elm = self.shape_elm_factory(tagname, ph_type, idx)
        placeholder = BasePlaceholder(shape_elm, None)
        return placeholder, expected_idx

    @pytest.fixture(params=[
        (False, None, None),
        (True,  None, ST_Direction.HORZ),
        (True,  ST_Direction.VERT, ST_Direction.VERT),
    ])
    def orient_fixture(self, request):
        has_ph_elm, orient, expected_orient = request.param
        ph_bldr = a_ph()
        if orient is not None:
            ph_bldr.with_orient(orient)
        nvPr_bldr = an_nvPr()
        if has_ph_elm:
            nvPr_bldr.with_child(ph_bldr)
        shape_elm = (
            an_sp().with_nsdecls('p').with_child(
                an_nvSpPr().with_child(
                    nvPr_bldr))
        ).element
        placeholder = BasePlaceholder(shape_elm, None)
        return placeholder, expected_orient

    @pytest.fixture(params=[
        (False, None, None),
        (True,  None, ST_PlaceholderSize.FULL),
        (True,  ST_PlaceholderSize.HALF, ST_PlaceholderSize.HALF),
    ])
    def sz_fixture(self, request):
        has_ph_elm, sz, expected_sz = request.param
        ph_bldr = a_ph()
        if sz is not None:
            ph_bldr.with_sz(sz)
        nvPr_bldr = an_nvPr()
        if has_ph_elm:
            nvPr_bldr.with_child(ph_bldr)
        shape_elm = (
            an_sp().with_nsdecls('p').with_child(
                an_nvSpPr().with_child(
                    nvPr_bldr))
        ).element
        placeholder = BasePlaceholder(shape_elm, None)
        return placeholder, expected_sz

    @pytest.fixture(params=[
        ('sp',           None,    1, 'obj'),
        ('sp',           'title', 0, 'title'),
        ('pic',          'pic',   6, 'pic'),
        ('graphicFrame', 'tbl',   9, 'tbl'),
    ])
    def type_fixture(self, request):
        tagname, ph_type, idx, expected_ph_type = request.param
        shape_elm = self.shape_elm_factory(tagname, ph_type, idx)
        placeholder = BasePlaceholder(shape_elm, None)
        return placeholder, expected_ph_type

    # fixture components ---------------------------------------------

    @staticmethod
    def shape_elm_factory(tagname, ph_type, idx):
        root_bldr, nvXxPr_bldr = {
            'sp':           (an_sp().with_nsdecls('p'), an_nvSpPr()),
            'pic':          (an_sp().with_nsdecls('p'), an_nvPicPr()),
            'graphicFrame': (a_graphicFrame().with_nsdecls('p'),
                             an_nvGraphicFramePr()),
        }[tagname]
        ph_bldr = {
            None:    a_ph().with_idx(idx),
            'obj':   a_ph().with_idx(idx),
            'title': a_ph().with_type('title'),
            'body':  a_ph().with_type('body').with_idx(idx),
            'pic':   a_ph().with_type('pic').with_idx(idx),
            'tbl':   a_ph().with_type('tbl').with_idx(idx),
        }[ph_type]
        return (
            root_bldr.with_child(
                nvXxPr_bldr.with_child(
                    an_nvPr().with_child(
                        ph_bldr)))
        ).element

########NEW FILE########
__FILENAME__ = test_shape
# encoding: utf-8

"""
Test suite for pptx.shapes.shape module
"""

from __future__ import absolute_import

import pytest

from pptx.oxml.shapes.shared import BaseShapeElement
from pptx.oxml.text import CT_TextBody
from pptx.parts.slide import _SlideShapeTree
from pptx.shapes import Subshape
from pptx.shapes.shape import BaseShape
from pptx.text import TextFrame

from ..oxml.unitdata.shape import (
    a_cxnSp, a_graphicFrame, a_grpSp, a_grpSpPr, a_p_xfrm, a_pic, an_ext,
    an_off, an_sp, an_spPr, an_xfrm
)
from ..unitutil import class_mock, instance_mock, loose_mock, property_mock


class DescribeBaseShape(object):

    def it_knows_its_shape_id(self, id_fixture):
        shape, shape_id = id_fixture
        assert shape.id == shape_id

    def it_knows_its_name(self, name_fixture):
        shape, name = name_fixture
        assert shape.name == name

    def it_has_a_position(self, position_get_fixture):
        shape, expected_left, expected_top = position_get_fixture
        assert shape.left == expected_left
        assert shape.top == expected_top

    def it_has_dimensions(self, dimensions_get_fixture):
        shape, expected_width, expected_height = dimensions_get_fixture
        assert shape.width == expected_width
        assert shape.height == expected_height

    def it_can_change_its_position(self, position_set_fixture):
        shape, left, top, expected_xml = position_set_fixture
        shape.left = left
        shape.top = top
        assert shape._element.xml == expected_xml

    def it_can_change_its_dimensions(self, dimensions_set_fixture):
        shape, width, height, expected_xml = dimensions_set_fixture
        shape.width = width
        shape.height = height
        assert shape._element.xml == expected_xml

    def it_knows_the_part_it_belongs_to(self, part_fixture):
        shape, parent_ = part_fixture
        part = shape.part
        assert part is parent_.part

    def it_knows_whether_it_can_contain_text(self, has_textframe_fixture):
        shape, has_textframe = has_textframe_fixture
        assert shape.has_textframe is has_textframe

    def it_knows_whether_it_is_a_placeholder(self, is_placeholder_fixture):
        shape, is_placeholder = is_placeholder_fixture
        assert shape.is_placeholder is is_placeholder

    def it_provides_access_to_its_textframe(self, textframe_fixture):
        shape, TextFrame_, txBody_, textframe_ = textframe_fixture
        textframe = shape.textframe
        TextFrame_.assert_called_once_with(txBody_, shape)
        assert textframe is textframe_

    def it_raises_when_no_textframe(self, no_textframe_fixture):
        shape = no_textframe_fixture
        with pytest.raises(ValueError):
            shape.textframe

    def it_can_set_the_shape_text_to_a_string(self, text_set_fixture):
        shape = text_set_fixture
        shape.text = 'fbr'
        assert shape.textframe.text == u'fbr'

    def it_raises_on_assign_text_where_no_textframe(
            self, no_textframe_fixture):
        shape = no_textframe_fixture
        with pytest.raises(TypeError):
            shape.text = 'foobar'

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        ('sp',           False), ('sp_with_ext',           True),
        ('pic',          False), ('pic_with_ext',          True),
        ('graphicFrame', False), ('graphicFrame_with_ext', True),
        ('grpSp',        False), ('grpSp_with_ext',        True),
        ('cxnSp',        False), ('cxnSp_with_ext',        True),
    ])
    def dimensions_get_fixture(self, request, width, height):
        shape_elm_fixt_name, expect_values = request.param
        shape_elm = request.getfuncargvalue(shape_elm_fixt_name)
        shape = BaseShape(shape_elm, None)
        if not expect_values:
            width = height = None
        return shape, width, height

    @pytest.fixture(params=[
        ('sp',           'sp_with_ext'),
        ('pic',          'pic_with_ext'),
        ('graphicFrame', 'graphicFrame_with_ext'),
        ('grpSp',        'grpSp_with_ext'),
        ('cxnSp',        'cxnSp_with_ext'),
    ])
    def dimensions_set_fixture(self, request, width, height):
        start_elm_fixt_name, expected_elm_fixt_name = request.param
        start_elm = request.getfuncargvalue(start_elm_fixt_name)
        shape = BaseShape(start_elm, None)
        expected_xml = request.getfuncargvalue(expected_elm_fixt_name).xml
        return shape, width, height, expected_xml

    @pytest.fixture
    def id_fixture(self, shape_elm_, shape_id):
        shape = BaseShape(shape_elm_, None)
        return shape, shape_id

    @pytest.fixture(params=[True, False])
    def has_textframe_fixture(self, request, shape_elm_, txBody_):
        has_textframe = request.param
        shape_elm_.txBody = txBody_ if has_textframe else None
        shape = BaseShape(shape_elm_, None)
        return shape, has_textframe

    @pytest.fixture(params=[True, False])
    def is_placeholder_fixture(self, request, shape_elm_, txBody_):
        is_placeholder = request.param
        shape_elm_.has_ph_elm = is_placeholder
        shape = BaseShape(shape_elm_, None)
        return shape, is_placeholder

    @pytest.fixture
    def name_fixture(self, shape_elm_, shape_name):
        shape = BaseShape(shape_elm_, None)
        return shape, shape_name

    @pytest.fixture
    def no_textframe_fixture(self, shape_elm_):
        shape_elm_.txBody = None
        shape = BaseShape(shape_elm_, None)
        return shape

    @pytest.fixture
    def part_fixture(self, shapes_):
        parent_ = shapes_
        shape = BaseShape(None, parent_)
        return shape, parent_

    @pytest.fixture(params=[
        ('sp',           False), ('sp_with_off',           True),
        ('pic',          False), ('pic_with_off',          True),
        ('graphicFrame', False), ('graphicFrame_with_off', True),
        ('grpSp',        False), ('grpSp_with_off',        True),
        ('cxnSp',        False), ('cxnSp_with_off',        True),
    ])
    def position_get_fixture(self, request, left, top):
        shape_elm_fixt_name, expect_values = request.param
        shape_elm = request.getfuncargvalue(shape_elm_fixt_name)
        shape = BaseShape(shape_elm, None)
        if not expect_values:
            left = top = None
        return shape, left, top

    @pytest.fixture(params=[
        ('sp',           'sp_with_off'),
        ('pic',          'pic_with_off'),
        ('graphicFrame', 'graphicFrame_with_off'),
        ('grpSp',        'grpSp_with_off'),
        ('cxnSp',        'cxnSp_with_off'),
    ])
    def position_set_fixture(self, request, left, top):
        start_elm_fixt_name, expected_elm_fixt_name = request.param
        start_elm = request.getfuncargvalue(start_elm_fixt_name)
        shape = BaseShape(start_elm, None)
        expected_xml = request.getfuncargvalue(expected_elm_fixt_name).xml
        return shape, left, top, expected_xml

    @pytest.fixture
    def textframe_fixture(self, shape_elm_, TextFrame_, txBody_, textframe_):
        shape = BaseShape(shape_elm_, None)
        return shape, TextFrame_, txBody_, textframe_

    @pytest.fixture
    def text_set_fixture(self, shape_elm_, shape_textframe_):
        shape = BaseShape(shape_elm_, None)
        return shape

    # fixture components ---------------------------------------------

    @pytest.fixture
    def cxnSp(self):
        return a_cxnSp().with_nsdecls().with_child(an_spPr()).element

    @pytest.fixture
    def cxnSp_with_ext(self, width, height):
        return (
            a_cxnSp().with_nsdecls().with_child(
                an_spPr().with_child(
                    an_xfrm().with_child(
                        an_ext().with_cx(width).with_cy(height))))
        ).element

    @pytest.fixture
    def cxnSp_with_off(self, left, top):
        return (
            a_cxnSp().with_nsdecls().with_child(
                an_spPr().with_child(
                    an_xfrm().with_child(
                        an_off().with_x(left).with_y(top))))
        ).element

    @pytest.fixture
    def graphicFrame(self):
        # Note that <p:xfrm> element is required on graphicFrame
        return a_graphicFrame().with_nsdecls().with_child(a_p_xfrm()).element

    @pytest.fixture
    def graphicFrame_with_ext(self, width, height):
        return (
            a_graphicFrame().with_nsdecls().with_child(
                a_p_xfrm().with_child(
                    an_ext().with_cx(width).with_cy(height)))
        ).element

    @pytest.fixture
    def graphicFrame_with_off(self, left, top):
        return (
            a_graphicFrame().with_nsdecls().with_child(
                a_p_xfrm().with_child(
                    an_off().with_x(left).with_y(top)))
        ).element

    @pytest.fixture
    def grpSp(self):
        return (
            a_grpSp().with_nsdecls('p', 'a').with_child(
                a_grpSpPr())
        ).element

    @pytest.fixture
    def grpSp_with_ext(self, width, height):
        return (
            a_grpSp().with_nsdecls('p', 'a').with_child(
                a_grpSpPr().with_child(
                    an_xfrm().with_child(
                        an_ext().with_cx(width).with_cy(height))))
        ).element

    @pytest.fixture
    def grpSp_with_off(self, left, top):
        return (
            a_grpSp().with_nsdecls('p', 'a').with_child(
                a_grpSpPr().with_child(
                    an_xfrm().with_child(
                        an_off().with_x(left).with_y(top))))
        ).element

    @pytest.fixture
    def height(self):
        return 654

    @pytest.fixture
    def left(self):
        return 123

    @pytest.fixture
    def pic(self):
        return a_pic().with_nsdecls().with_child(an_spPr()).element

    @pytest.fixture
    def pic_with_off(self, left, top):
        return (
            a_pic().with_nsdecls().with_child(
                an_spPr().with_child(
                    an_xfrm().with_child(
                        an_off().with_x(left).with_y(top))))
        ).element

    @pytest.fixture
    def pic_with_ext(self, width, height):
        return (
            a_pic().with_nsdecls().with_child(
                an_spPr().with_child(
                    an_xfrm().with_child(
                        an_ext().with_cx(width).with_cy(height))))
        ).element

    @pytest.fixture
    def shape_elm_(self, request, shape_id, shape_name, txBody_):
        return instance_mock(
            request, BaseShapeElement, shape_id=shape_id,
            shape_name=shape_name, txBody=txBody_
        )

    @pytest.fixture
    def shape_id(self):
        return 42

    @pytest.fixture
    def shape_name(self):
        return 'Foobar 41'

    @pytest.fixture
    def shape_textframe_(self, request):
        return property_mock(request, BaseShape, 'textframe')

    @pytest.fixture
    def shapes_(self, request):
        return instance_mock(request, _SlideShapeTree)

    @pytest.fixture
    def sp(self):
        return an_sp().with_nsdecls().with_child(an_spPr()).element

    @pytest.fixture
    def sp_with_ext(self, width, height):
        return (
            an_sp().with_nsdecls().with_child(
                an_spPr().with_child(
                    an_xfrm().with_child(
                        an_ext().with_cx(width).with_cy(height))))
        ).element

    @pytest.fixture
    def sp_with_off(self, left, top):
        return (
            an_sp().with_nsdecls().with_child(
                an_spPr().with_child(
                    an_xfrm().with_child(
                        an_off().with_x(left).with_y(top))))
        ).element

    @pytest.fixture
    def TextFrame_(self, request, textframe_):
        return class_mock(
            request, 'pptx.shapes.shape.TextFrame', return_value=textframe_
        )

    @pytest.fixture
    def textframe_(self, request):
        return instance_mock(request, TextFrame)

    @pytest.fixture
    def top(self):
        return 456

    @pytest.fixture
    def txBody_(self, request):
        return instance_mock(request, CT_TextBody)

    @pytest.fixture
    def width(self):
        return 321


class DescribeSubshape(object):

    def it_knows_the_part_it_belongs_to(self, subshape_with_parent_):
        subshape, parent_ = subshape_with_parent_
        part = subshape.part
        assert part is parent_.part

    # fixtures ---------------------------------------------

    @pytest.fixture
    def subshape_with_parent_(self, request):
        parent_ = loose_mock(request, name='parent_')
        subshape = Subshape(parent_)
        return subshape, parent_

########NEW FILE########
__FILENAME__ = test_shapetree
# encoding: utf-8

"""
Test suite for pptx.shapes.shapetree module
"""

from __future__ import absolute_import

import pytest

from pptx.oxml.shapes.autoshape import CT_Shape
from pptx.parts.slide import Slide
from pptx.shapes.autoshape import Shape
from pptx.shapes.shape import BaseShape
from pptx.shapes.picture import Picture
from pptx.shapes.table import Table
from pptx.shapes.shapetree import BaseShapeTree, BaseShapeFactory

from ..oxml.unitdata.shape import (
    a_cNvPr, a_graphic, a_graphicData, a_graphicFrame, a_grpSp, a_pic,
    an_nvSpPr, an_sp, an_spPr, an_spTree
)
from ..oxml.unitdata.slides import a_sld, a_cSld
from ..unitutil import (
    call, class_mock, function_mock, instance_mock, method_mock
)


class DescribeBaseShapeFactory(object):

    def it_constructs_the_appropriate_shape_instance_for_a_shape_element(
            self, factory_fixture):
        shape_elm, parent_, ShapeClass_, shape_ = factory_fixture
        shape = BaseShapeFactory(shape_elm, parent_)
        ShapeClass_.assert_called_once_with(shape_elm, parent_)
        assert shape is shape_

    def it_finds_an_unused_shape_id_to_help_add_shape(self, next_id_fixture):
        shapes, next_available_shape_id = next_id_fixture
        shape_id = shapes._next_shape_id
        assert shape_id == next_available_shape_id

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=['sp', 'pic', 'tbl', 'chart', 'grpSp'])
    def factory_fixture(
            self, request, slide_, Shape_, shape_, Picture_, picture_,
            tbl_bldr, Table_, table_, chart_bldr, BaseShape_, base_shape_):
        shape_bldr, ShapeClass_, shape_mock = {
            'sp':    (an_sp(),    Shape_,     shape_),
            'pic':   (a_pic(),    Picture_,   picture_),
            'tbl':   (tbl_bldr,   Table_,     table_),
            'chart': (chart_bldr, BaseShape_, base_shape_),
            'grpSp': (a_grpSp(),  BaseShape_, base_shape_),
        }[request.param]
        shape_elm = shape_bldr.with_nsdecls().element
        return shape_elm, slide_, ShapeClass_, shape_mock

    @pytest.fixture(params=[
        ((), 1), ((0,), 1), ((1,), 2), ((2,), 1), ((1, 3,), 2),
        (('foobar', 0, 1, 7), 2), (('1foo', 2, 2, 2), 1), ((1, 1, 1, 4), 2),
    ])
    def next_id_fixture(self, request, slide_):
        used_ids, next_available_shape_id = request.param
        nvSpPr_bldr = an_nvSpPr()
        for used_id in used_ids:
            nvSpPr_bldr.with_child(a_cNvPr().with_id(used_id))
        spTree = an_spTree().with_nsdecls().with_child(nvSpPr_bldr).element
        print(spTree.xml)
        slide_.spTree = spTree
        shapes = BaseShapeTree(slide_)
        return shapes, next_available_shape_id

    # fixture components -----------------------------------

    @pytest.fixture
    def BaseShape_(self, request, base_shape_):
        return class_mock(
            request, 'pptx.shapes.shapetree.BaseShape',
            return_value=base_shape_
        )

    @pytest.fixture
    def base_shape_(self, request):
        return instance_mock(request, BaseShape)

    @pytest.fixture
    def chart_bldr(self):
        chart_uri = 'http://schemas.openxmlformats.org/drawingml/2006/chart'
        return (
            a_graphicFrame().with_child(
                a_graphic().with_child(
                    a_graphicData().with_uri(chart_uri)))
        )

    @pytest.fixture
    def Picture_(self, request, picture_):
        return class_mock(
            request, 'pptx.shapes.shapetree.Picture', return_value=picture_
        )

    @pytest.fixture
    def picture_(self, request):
        return instance_mock(request, Picture)

    @pytest.fixture
    def Shape_(self, request, shape_):
        return class_mock(
            request, 'pptx.shapes.shapetree.Shape', return_value=shape_
        )

    @pytest.fixture
    def shape_(self, request):
        return instance_mock(request, Shape)

    @pytest.fixture
    def slide_(self, request):
        return instance_mock(request, Slide)

    @pytest.fixture
    def Table_(self, request, table_):
        return class_mock(
            request, 'pptx.shapes.shapetree.Table', return_value=table_
        )

    @pytest.fixture
    def table_(self, request):
        return instance_mock(request, Table)

    @pytest.fixture
    def tbl_bldr(self):
        tbl_uri = 'http://schemas.openxmlformats.org/drawingml/2006/table'
        return (
            a_graphicFrame().with_child(
                a_graphic().with_child(
                    a_graphicData().with_uri(tbl_uri)))
        )


class DescribeBaseShapeTree(object):

    def it_knows_how_many_shapes_it_contains(self, len_fixture):
        shapes, expected_count = len_fixture
        shape_count = len(shapes)
        assert shape_count == expected_count

    def it_can_iterate_over_the_shapes_it_contains(self, iter_fixture):
        shapes, BaseShapeFactory_, sp_, sp_2_, shape_, shape_2_ = (
            iter_fixture
        )
        iter_vals = [s for s in shapes]
        assert BaseShapeFactory_.call_args_list == [
            call(sp_, shapes),
            call(sp_2_, shapes)
        ]
        assert iter_vals == [shape_, shape_2_]

    def it_iterates_over_spTree_shape_elements_to_help__iter__(
            self, iter_elms_fixture):
        shapes, expected_elm_count = iter_elms_fixture
        shape_elms = [elm for elm in shapes._iter_member_elms()]
        assert len(shape_elms) == expected_elm_count
        for elm in shape_elms:
            assert isinstance(elm, CT_Shape)

    def it_supports_indexed_access(self, getitem_fixture):
        shapes, idx, BaseShapeFactory_, shape_elm_, shape_ = getitem_fixture
        shape = shapes[idx]
        BaseShapeFactory_.assert_called_once_with(shape_elm_, shapes)
        assert shape is shape_

    def it_raises_on_shape_index_out_of_range(self, getitem_fixture):
        shapes = getitem_fixture[0]
        with pytest.raises(IndexError):
            shapes[2]

    def it_knows_the_part_it_belongs_to(self, slide):
        shapes = BaseShapeTree(slide)
        assert shapes.part is slide

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def getitem_fixture(
            self, _iter_member_elms_, BaseShapeFactory_, sp_2_, shape_):
        shapes = BaseShapeTree(None)
        idx = 1
        return shapes, idx, BaseShapeFactory_, sp_2_, shape_

    @pytest.fixture
    def iter_fixture(
            self, _iter_member_elms_, BaseShapeFactory_, sp_, sp_2_,
            shape_, shape_2_):
        shapes = BaseShapeTree(None)
        return shapes, BaseShapeFactory_, sp_, sp_2_, shape_, shape_2_

    @pytest.fixture
    def iter_elms_fixture(self, slide):
        shapes = BaseShapeTree(slide)
        expected_elm_count = 2
        return shapes, expected_elm_count

    @pytest.fixture
    def len_fixture(self, slide):
        shapes = BaseShapeTree(slide)
        expected_count = 2
        return shapes, expected_count

    # fixture components ---------------------------------------------

    @pytest.fixture
    def _iter_member_elms_(self, request, sp_, sp_2_):
        return method_mock(
            request, BaseShapeTree, '_iter_member_elms',
            return_value=iter([sp_, sp_2_])
        )

    @pytest.fixture
    def BaseShapeFactory_(self, request, shape_, shape_2_):
        return function_mock(
            request, 'pptx.shapes.shapetree.BaseShapeFactory',
            side_effect=[shape_, shape_2_]
        )

    @pytest.fixture
    def shape_(self, request):
        return instance_mock(request, BaseShape)

    @pytest.fixture
    def shape_2_(self, request):
        return instance_mock(request, BaseShape)

    @pytest.fixture
    def sld(self):
        sld_bldr = (
            a_sld().with_nsdecls().with_child(
                a_cSld().with_child(
                    an_spTree().with_child(
                        an_spPr()).with_child(
                        an_sp()).with_child(
                        an_sp())))
        )
        return sld_bldr.element

    @pytest.fixture
    def slide(self, sld):
        return Slide(None, None, sld, None)

    @pytest.fixture
    def sp_(self, request):
        return instance_mock(request, CT_Shape)

    @pytest.fixture
    def sp_2_(self, request):
        return instance_mock(request, CT_Shape)

########NEW FILE########
__FILENAME__ = test_table
# encoding: utf-8

"""Test suite for pptx.table module."""

from __future__ import absolute_import

import pytest

from hamcrest import assert_that, equal_to, is_
from mock import MagicMock, Mock, PropertyMock

from pptx.dml.fill import FillFormat
from pptx.enum.text import MSO_ANCHOR
from pptx.oxml import parse_xml_bytes
from pptx.oxml.ns import nsdecls
from pptx.shapes.table import (
    _Cell, _CellCollection, _Column, _ColumnCollection, _Row, _RowCollection
)
from pptx.util import Inches

from ..oxml.unitdata.shape import test_shapes
from ..oxml.unitdata.table import a_tc, a_tcPr, a_txBody
from ..oxml.unitdata.text import a_bodyPr, a_p, an_r, a_t
from ..unitutil import actual_xml, TestCase


class Describe_Cell(object):

    def it_has_a_fill(self, cell):
        assert isinstance(cell.fill, FillFormat)

    def it_knows_its_margin_settings(self, margin_get_fixture):
        cell, margin_left, margin_right, margin_top, margin_bottom = (
            margin_get_fixture
        )
        assert cell.margin_left == margin_left
        assert cell.margin_right == margin_right
        assert cell.margin_top == margin_top
        assert cell.margin_bottom == margin_bottom

    def it_can_change_its_margin_settings(self, margin_set_fixture):
        cell, marL, marR, marT, marB, tc_with_marX_xml = margin_set_fixture
        cell.margin_left = marL
        cell.margin_right = marR
        cell.margin_top = marT
        cell.margin_bottom = marB
        assert actual_xml(cell._tc) == tc_with_marX_xml

    def it_raises_on_margin_assigned_other_than_int_or_None(
            self, margin_raises_fixture):
        cell, margin_attr_name, val_of_invalid_type = margin_raises_fixture
        with pytest.raises(TypeError):
            setattr(cell, margin_attr_name, val_of_invalid_type)

    def it_can_set_the_text_it_contains(self, text_set_fixture):
        cell, text, tc_with_text_xml = text_set_fixture
        cell.text = text
        assert actual_xml(cell._tc) == tc_with_text_xml

    def it_knows_its_vertical_anchor_setting(self, anchor_get_fixture):
        cell, vertical_anchor = anchor_get_fixture
        assert cell.vertical_anchor == vertical_anchor

    def it_can_change_its_vertical_anchor(self, anchor_set_fixture):
        cell, vertical_anchor, tc_with_anchor_xml = anchor_set_fixture
        cell.vertical_anchor = vertical_anchor
        assert actual_xml(cell._tc) == tc_with_anchor_xml

    # fixture --------------------------------------------------------

    @pytest.fixture(params=[
        (None,  None),
        ('t',   MSO_ANCHOR.TOP),
        ('ctr', MSO_ANCHOR.MIDDLE),
        ('b',   MSO_ANCHOR.BOTTOM),
    ])
    def anchor_get_fixture(self, request):
        anchor, mso_anchor_idx = request.param
        tc_bldr = a_tc().with_nsdecls()
        if anchor is not None:
            tcPr_bldr = a_tcPr().with_anchor(anchor)
            tc_bldr.with_child(tcPr_bldr)
        tc = tc_bldr.element
        cell = _Cell(tc, None)
        return cell, mso_anchor_idx

    @pytest.fixture(params=[
        (None,  None,              None),
        (None,  MSO_ANCHOR.TOP,    't'),
        ('t',   MSO_ANCHOR.MIDDLE, 'ctr'),
        ('ctr', MSO_ANCHOR.BOTTOM, 'b'),
        ('b',   None,              ''),
    ])
    def anchor_set_fixture(self, request):
        def tc_with_anchor_bldr(anchor):
            tc_bldr = a_tc().with_nsdecls()
            if anchor is not None:
                tcPr_bldr = a_tcPr()
                if anchor != '':
                    tcPr_bldr.with_anchor(anchor)
                tc_bldr.with_child(tcPr_bldr)
            return tc_bldr
        before_anchor, mso_anchor_idx, after_anchor = request.param
        tc = tc_with_anchor_bldr(before_anchor).element
        cell = _Cell(tc, None)
        tc_with_anchor_xml = tc_with_anchor_bldr(after_anchor).xml()
        return cell, mso_anchor_idx, tc_with_anchor_xml

    @pytest.fixture
    def cell(self):
        tc = a_tc().with_nsdecls().element
        return _Cell(tc, None)

    @pytest.fixture(params=[
        ((None, None, None, None), (91440, 91440, 45720, 45720)),
        ((1234, 2345, 3456, None), (1234,  2345,  3456,  45720)),
        ((2345, None, 3456, 1234), (2345,  91440, 3456,  1234)),
    ])
    def margin_get_fixture(self, request):
        mar_vals, expected_vals = request.param
        marL, marR, marT, marB = mar_vals
        margin_left, margin_right, margin_top, margin_bottom = expected_vals
        tcPr_bldr = a_tcPr()
        if marL is not None:
            tcPr_bldr.with_marL(marL)
        if marR is not None:
            tcPr_bldr.with_marR(marR)
        if marT is not None:
            tcPr_bldr.with_marT(marT)
        if marB is not None:
            tcPr_bldr.with_marB(marB)
        tc = a_tc().with_nsdecls().with_child(tcPr_bldr).element
        cell = _Cell(tc, None)
        return cell, margin_left, margin_right, margin_top, margin_bottom

    @pytest.fixture(params=[
        ((None, None, None, None), (91440, None,  None, None)),
        ((1234, 2345, 3456, None), (None,  4567,  None, None)),
        ((None, 2345, 3456, None), (None,  None,  6543, None)),
        ((1234, 2345, None, 4567), (None,  None,  None, 7654)),
        ((1234, 2345, 3456, 4567), (None,  None,  None, None)),
        ((None, None, None, None), (None,  None,  None, None)),
    ])
    def margin_set_fixture(self, request):

        def tc_bldr_with(marX):
            marL, marR, marT, marB = marX
            tcPr_bldr = a_tcPr()
            if marL is not None:
                tcPr_bldr.with_marL(marL)
            if marR is not None:
                tcPr_bldr.with_marR(marR)
            if marT is not None:
                tcPr_bldr.with_marT(marT)
            if marB is not None:
                tcPr_bldr.with_marB(marB)
            return a_tc().with_nsdecls().with_child(tcPr_bldr)

        before_vals, after_vals = request.param
        tc = tc_bldr_with(before_vals).element
        cell = _Cell(tc, None)

        marL, marR, marT, marB = after_vals

        tc_with_marX_xml = tc_bldr_with(after_vals).xml()

        return cell, marL, marR, marT, marB, tc_with_marX_xml

    @pytest.fixture(params=[
        'margin_left', 'margin_right', 'margin_top', 'margin_bottom'
    ])
    def margin_raises_fixture(self, request, cell):
        margin_attr_name = request.param
        val_of_invalid_type = 'foobar'
        return cell, margin_attr_name, val_of_invalid_type

    @pytest.fixture
    def text_set_fixture(self, cell):
        text = 'foobar'
        tc_with_text_xml = (
            a_tc().with_nsdecls().with_child(
                a_txBody().with_child(
                    a_bodyPr()).with_child(
                    a_p().with_child(
                        an_r().with_child(
                            a_t().with_text(text)))))
            .xml()
        )
        return cell, text, tc_with_text_xml


class Test_CellCollection(TestCase):
    """Test _CellCollection"""
    def setUp(self):
        tr_xml = (
            '<a:tr %s h="370840"><a:tc><a:txBody><a:p/></a:txBody></a:tc><a:t'
            'c><a:txBody><a:p/></a:txBody></a:tc></a:tr>' % nsdecls('a')
        )
        test_tr_elm = parse_xml_bytes(tr_xml)
        self.cells = _CellCollection(test_tr_elm, None)

    def test_is_indexable(self):
        """_CellCollection indexable (e.g. no TypeError on 'cells[0]')"""
        # verify -----------------------
        try:
            self.cells[0]
        except TypeError:
            msg = "'_CellCollection' object does not support indexing"
            self.fail(msg)
        except IndexError:
            pass

    def test_is_iterable(self):
        """_CellCollection is iterable (e.g. ``for cell in cells:``)"""
        # verify -----------------------
        count = 0
        try:
            for cell in self.cells:
                count += 1
        except TypeError:
            msg = "_CellCollection object is not iterable"
            self.fail(msg)
        assert_that(count, is_(equal_to(2)))

    def test_raises_on_idx_out_of_range(self):
        """_CellCollection raises on index out of range"""
        with self.assertRaises(IndexError):
            self.cells[9]

    def test_cell_count_correct(self):
        """len(_CellCollection) returns correct cell count"""
        # verify -----------------------
        assert_that(len(self.cells), is_(equal_to(2)))


class Test_Column(TestCase):
    """Test _Column"""
    def setUp(self):
        gridCol_xml = '<a:gridCol %s w="3048000"/>' % nsdecls('a')
        test_gridCol_elm = parse_xml_bytes(gridCol_xml)
        self.column = _Column(test_gridCol_elm, Mock(name='table'))

    def test_width_from_xml_correct(self):
        """_Column.width returns correct value from gridCol XML element"""
        # verify -----------------------
        assert_that(self.column.width, is_(equal_to(3048000)))

    def test_width_round_trips_intact(self):
        """_Column.width round-trips intact"""
        # setup ------------------------
        self.column.width = 999
        # verify -----------------------
        assert_that(self.column.width, is_(equal_to(999)))

    def test_set_width_raises_on_bad_value(self):
        """_Column.width raises on attempt to assign invalid value"""
        test_cases = ('abc', '1', -1)
        for value in test_cases:
            with self.assertRaises(ValueError):
                self.column.width = value


class Test_ColumnCollection(TestCase):
    """Test _ColumnCollection"""
    def setUp(self):
        tbl_xml = (
            '<a:tbl %s><a:tblGrid><a:gridCol w="3048000"/><a:gridCol w="30480'
            '00"/></a:tblGrid></a:tbl>' % nsdecls('a')
        )
        test_tbl_elm = parse_xml_bytes(tbl_xml)
        self.columns = _ColumnCollection(test_tbl_elm, Mock(name='table'))

    def test_is_indexable(self):
        """_ColumnCollection indexable (e.g. no TypeError on 'columns[0]')"""
        # verify -----------------------
        try:
            self.columns[0]
        except TypeError:
            msg = "'_ColumnCollection' object does not support indexing"
            self.fail(msg)
        except IndexError:
            pass

    def test_is_iterable(self):
        """_ColumnCollection is iterable (e.g. ``for col in columns:``)"""
        # verify -----------------------
        count = 0
        try:
            for col in self.columns:
                count += 1
        except TypeError:
            msg = "_ColumnCollection object is not iterable"
            self.fail(msg)
        assert_that(count, is_(equal_to(2)))

    def test_raises_on_idx_out_of_range(self):
        """_ColumnCollection raises on index out of range"""
        with self.assertRaises(IndexError):
            self.columns[9]

    def test_column_count_correct(self):
        """len(_ColumnCollection) returns correct column count"""
        # verify -----------------------
        assert_that(len(self.columns), is_(equal_to(2)))


class Test_Row(TestCase):
    """Test _Row"""
    def setUp(self):
        tr_xml = (
            '<a:tr %s h="370840"><a:tc><a:txBody><a:p/></a:txBody></a:tc><a:t'
            'c><a:txBody><a:p/></a:txBody></a:tc></a:tr>' % nsdecls('a')
        )
        test_tr_elm = parse_xml_bytes(tr_xml)
        self.row = _Row(test_tr_elm, Mock(name='table'))

    def test_height_from_xml_correct(self):
        """_Row.height returns correct value from tr XML element"""
        # verify -----------------------
        assert_that(self.row.height, is_(equal_to(370840)))

    def test_height_round_trips_intact(self):
        """_Row.height round-trips intact"""
        # setup ------------------------
        self.row.height = 999
        # verify -----------------------
        assert_that(self.row.height, is_(equal_to(999)))

    def test_set_height_raises_on_bad_value(self):
        """_Row.height raises on attempt to assign invalid value"""
        test_cases = ('abc', '1', -1)
        for value in test_cases:
            with self.assertRaises(ValueError):
                self.row.height = value


class Test_RowCollection(TestCase):
    """Test _RowCollection"""
    def setUp(self):
        tbl_xml = (
            '<a:tbl %s><a:tr h="370840"><a:tc><a:txBody><a:p/></a:txBody></a:'
            'tc><a:tc><a:txBody><a:p/></a:txBody></a:tc></a:tr><a:tr h="37084'
            '0"><a:tc><a:txBody><a:p/></a:txBody></a:tc><a:tc><a:txBody><a:p/'
            '></a:txBody></a:tc></a:tr></a:tbl>' % nsdecls('a')
        )
        test_tbl_elm = parse_xml_bytes(tbl_xml)
        self.rows = _RowCollection(test_tbl_elm, Mock(name='table'))

    def test_is_indexable(self):
        """_RowCollection indexable (e.g. no TypeError on 'rows[0]')"""
        # verify -----------------------
        try:
            self.rows[0]
        except TypeError:
            msg = "'_RowCollection' object does not support indexing"
            self.fail(msg)
        except IndexError:
            pass

    def test_is_iterable(self):
        """_RowCollection is iterable (e.g. ``for row in rows:``)"""
        # verify -----------------------
        count = 0
        try:
            for row in self.rows:
                count += 1
        except TypeError:
            msg = "_RowCollection object is not iterable"
            self.fail(msg)
        assert_that(count, is_(equal_to(2)))

    def test_raises_on_idx_out_of_range(self):
        """_RowCollection raises on index out of range"""
        with self.assertRaises(IndexError):
            self.rows[9]

    def test_row_count_correct(self):
        """len(_RowCollection) returns correct row count"""
        # verify -----------------------
        assert_that(len(self.rows), is_(equal_to(2)))


class TestTable(TestCase):
    """Test Table"""
    def test_initial_height_divided_evenly_between_rows(self):
        """Table creation height divided evenly between rows"""
        # constant values -------------
        rows = cols = 3
        left = top = Inches(1.0)
        width = Inches(2.0)
        height = 1000
        shapes = test_shapes.empty_shape_collection
        # exercise ---------------------
        table = shapes.add_table(rows, cols, left, top, width, height)
        # verify -----------------------
        assert_that(table.rows[0].height, is_(equal_to(333)))
        assert_that(table.rows[1].height, is_(equal_to(333)))
        assert_that(table.rows[2].height, is_(equal_to(334)))

    def test_initial_width_divided_evenly_between_columns(self):
        """Table creation width divided evenly between columns"""
        # constant values -------------
        rows = cols = 3
        left = top = Inches(1.0)
        width = 1000
        height = Inches(2.0)
        shapes = test_shapes.empty_shape_collection
        # exercise ---------------------
        table = shapes.add_table(rows, cols, left, top, width, height)
        # verify -----------------------
        assert_that(table.columns[0].width, is_(equal_to(333)))
        assert_that(table.columns[1].width, is_(equal_to(333)))
        assert_that(table.columns[2].width, is_(equal_to(334)))

    def test_height_sum_of_row_heights(self):
        """Table.height is sum of row heights"""
        # constant values -------------
        rows = cols = 2
        left = top = width = height = Inches(2.0)
        # setup ------------------------
        shapes = test_shapes.empty_shape_collection
        tbl = shapes.add_table(rows, cols, left, top, width, height)
        tbl.rows[0].height = 100
        tbl.rows[1].height = 200
        # verify -----------------------
        sum_of_row_heights = 300
        assert_that(tbl.height, is_(equal_to(sum_of_row_heights)))

    def test_width_sum_of_col_widths(self):
        """Table.width is sum of column widths"""
        # constant values -------------
        rows = cols = 2
        left = top = width = height = Inches(2.0)
        # setup ------------------------
        shapes = test_shapes.empty_shape_collection
        tbl = shapes.add_table(rows, cols, left, top, width, height)
        tbl.columns[0].width = 100
        tbl.columns[1].width = 200
        # verify -----------------------
        sum_of_col_widths = tbl.columns[0].width + tbl.columns[1].width
        assert_that(tbl.width, is_(equal_to(sum_of_col_widths)))


class TestTableBooleanProperties(TestCase):
    """Test Table"""
    def setUp(self):
        """Test fixture for Table boolean properties"""
        shapes = test_shapes.empty_shape_collection
        self.table = shapes.add_table(2, 2, 1000, 1000, 1000, 1000)
        self.assignment_cases = (
            (True,  True),
            (False, False),
            (0,     False),
            (1,     True),
            ('',    False),
            ('foo', True)
        )

    def mockery(self, property_name, property_return_value=None):
        """
        Return property of *property_name* on self.table with return value of
        *property_return_value*.
        """
        # mock <a:tbl> element of Table so we can mock its properties
        tbl = MagicMock()
        self.table._tbl_elm = tbl
        # create a suitable mock for the property
        property_ = PropertyMock()
        if property_return_value:
            property_.return_value = property_return_value
        # and attach it the the <a:tbl> element object (class actually)
        setattr(type(tbl), property_name, property_)
        return property_

    def test_first_col_property_value(self):
        """Table.first_col property value is calculated correctly"""
        # mockery ----------------------
        firstCol_val = True
        firstCol = self.mockery('firstCol', firstCol_val)
        # exercise ---------------------
        retval = self.table.first_col
        # verify -----------------------
        firstCol.assert_called_once_with()
        assert_that(retval, is_(equal_to(firstCol_val)))

    def test_first_row_property_value(self):
        """Table.first_row property value is calculated correctly"""
        # mockery ----------------------
        firstRow_val = True
        firstRow = self.mockery('firstRow', firstRow_val)
        # exercise ---------------------
        retval = self.table.first_row
        # verify -----------------------
        firstRow.assert_called_once_with()
        assert_that(retval, is_(equal_to(firstRow_val)))

    def test_horz_banding_property_value(self):
        """Table.horz_banding property value is calculated correctly"""
        # mockery ----------------------
        bandRow_val = True
        bandRow = self.mockery('bandRow', bandRow_val)
        # exercise ---------------------
        retval = self.table.horz_banding
        # verify -----------------------
        bandRow.assert_called_once_with()
        assert_that(retval, is_(equal_to(bandRow_val)))

    def test_last_col_property_value(self):
        """Table.last_col property value is calculated correctly"""
        # mockery ----------------------
        lastCol_val = True
        lastCol = self.mockery('lastCol', lastCol_val)
        # exercise ---------------------
        retval = self.table.last_col
        # verify -----------------------
        lastCol.assert_called_once_with()
        assert_that(retval, is_(equal_to(lastCol_val)))

    def test_last_row_property_value(self):
        """Table.last_row property value is calculated correctly"""
        # mockery ----------------------
        lastRow_val = True
        lastRow = self.mockery('lastRow', lastRow_val)
        # exercise ---------------------
        retval = self.table.last_row
        # verify -----------------------
        lastRow.assert_called_once_with()
        assert_that(retval, is_(equal_to(lastRow_val)))

    def test_vert_banding_property_value(self):
        """Table.vert_banding property value is calculated correctly"""
        # mockery ----------------------
        bandCol_val = True
        bandCol = self.mockery('bandCol', bandCol_val)
        # exercise ---------------------
        retval = self.table.vert_banding
        # verify -----------------------
        bandCol.assert_called_once_with()
        assert_that(retval, is_(equal_to(bandCol_val)))

    def test_first_col_assignment(self):
        """Assignment to Table.first_col sets attribute value"""
        # mockery ----------------------
        firstCol = self.mockery('firstCol')
        # verify -----------------------
        for assigned_value, called_with_value in self.assignment_cases:
            self.table.first_col = assigned_value
            firstCol.assert_called_once_with(called_with_value)
            firstCol.reset_mock()

    def test_first_row_assignment(self):
        """Assignment to Table.first_row sets attribute value"""
        # mockery ----------------------
        firstRow = self.mockery('firstRow')
        # verify -----------------------
        for assigned_value, called_with_value in self.assignment_cases:
            self.table.first_row = assigned_value
            firstRow.assert_called_once_with(called_with_value)
            firstRow.reset_mock()

    def test_horz_banding_assignment(self):
        """Assignment to Table.horz_banding sets attribute value"""
        # mockery ----------------------
        bandRow = self.mockery('bandRow')
        # verify -----------------------
        for assigned_value, called_with_value in self.assignment_cases:
            self.table.horz_banding = assigned_value
            bandRow.assert_called_once_with(called_with_value)
            bandRow.reset_mock()

    def test_last_col_assignment(self):
        """Assignment to Table.last_col sets attribute value"""
        # mockery ----------------------
        lastCol = self.mockery('lastCol')
        # verify -----------------------
        for assigned_value, called_with_value in self.assignment_cases:
            self.table.last_col = assigned_value
            lastCol.assert_called_once_with(called_with_value)
            lastCol.reset_mock()

    def test_last_row_assignment(self):
        """Assignment to Table.last_row sets attribute value"""
        # mockery ----------------------
        lastRow = self.mockery('lastRow')
        # verify -----------------------
        for assigned_value, called_with_value in self.assignment_cases:
            self.table.last_row = assigned_value
            lastRow.assert_called_once_with(called_with_value)
            lastRow.reset_mock()

    def test_vert_banding_assignment(self):
        """Assignment to Table.vert_banding sets attribute value"""
        # mockery ----------------------
        bandCol = self.mockery('bandCol')
        # verify -----------------------
        for assigned_value, called_with_value in self.assignment_cases:
            self.table.vert_banding = assigned_value
            bandCol.assert_called_once_with(called_with_value)
            bandCol.reset_mock()

########NEW FILE########
__FILENAME__ = test_api
# encoding: utf-8

"""
Test suite for pptx.api module
"""

from __future__ import absolute_import, print_function

import pytest

from pptx.api import Presentation
from pptx.parts.presentation import PresentationPart

from .unitutil import call, property_mock


class DescribePresentation(object):

    def it_knows_the_width_of_its_slides(self, slide_width_get_fixture):
        prs, slide_width = slide_width_get_fixture
        assert prs.slide_width == slide_width

    def it_can_change_the_width_of_its_slides(
            self, slide_width_set_fixture):
        prs, slide_width, part_slide_width_ = slide_width_set_fixture
        prs.slide_width = slide_width
        assert part_slide_width_.mock_calls == [call(slide_width)]

    def it_knows_the_height_of_its_slides(self, slide_height_get_fixture):
        prs, slide_height = slide_height_get_fixture
        assert prs.slide_height == slide_height

    def it_can_change_the_height_of_its_slides(
            self, slide_height_set_fixture):
        prs, slide_height, part_slide_height_ = slide_height_set_fixture
        prs.slide_height = slide_height
        assert part_slide_height_.mock_calls == [call(slide_height)]

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def slide_height_get_fixture(self, part_slide_height_, slide_height):
        prs = Presentation()
        part_slide_height_.return_value = slide_height
        return prs, slide_height

    @pytest.fixture
    def slide_height_set_fixture(self, part_slide_height_, slide_height):
        prs = Presentation()
        return prs, slide_height, part_slide_height_

    @pytest.fixture
    def slide_width_get_fixture(self, part_slide_width_, slide_width):
        prs = Presentation()
        part_slide_width_.return_value = slide_width
        return prs, slide_width

    @pytest.fixture
    def slide_width_set_fixture(self, part_slide_width_, slide_width):
        prs = Presentation()
        return prs, slide_width, part_slide_width_

    # fixtures components --------------------------------------------

    @pytest.fixture
    def part_slide_height_(self, request):
        return property_mock(request, PresentationPart, 'slide_height')

    @pytest.fixture
    def part_slide_width_(self, request):
        return property_mock(request, PresentationPart, 'slide_width')

    @pytest.fixture
    def slide_height(self):
        return 7654321

    @pytest.fixture
    def slide_width(self):
        return 9876543

########NEW FILE########
__FILENAME__ = test_enum
# encoding: utf-8

"""
Test suite for pptx.enum module, focused on base classes. Configured a little
differently because of the meta-programming, the two enumeration classes at
the top constitute the entire fixture and the tests themselves just make
assertions on those.
"""

from __future__ import absolute_import, print_function

import pytest

from pptx.enum.base import (
    alias, Enumeration, EnumMember, ReturnValueOnlyEnumMember,
    XmlEnumeration, XmlMappedEnumMember
)


@alias('BARFOO')
class FOOBAR(Enumeration):
    """
    Enumeration docstring
    """

    __ms_name__ = 'MsoFoobar'

    __url__ = 'http://msdn.microsoft.com/foobar.aspx'

    __members__ = (
        EnumMember(None, None, 'No setting/remove setting'),
        EnumMember('READ_WRITE', 1, 'Readable and settable'),
        ReturnValueOnlyEnumMember('READ_ONLY', -2, 'Return value only'),
    )


@alias('XML-FU')
class XMLFOO(XmlEnumeration):
    """
    XmlEnumeration docstring
    """

    __ms_name__ = 'MsoXmlFoobar'

    __url__ = 'http://msdn.microsoft.com/msoxmlfoobar.aspx'

    __members__ = (
        XmlMappedEnumMember(None, None, None, 'No setting'),
        XmlMappedEnumMember('XML_RW', 42, 'attrVal', 'Read/write setting'),
        ReturnValueOnlyEnumMember('RO', -2, 'Return value only;'),
    )


class DescribeEnumeration(object):

    def it_has_the_right_metaclass(self):
        assert type(FOOBAR).__name__ == 'MetaEnumeration'

    def it_provides_an_EnumValue_instance_for_each_named_member(self):
        with pytest.raises(AttributeError):
            FOOBAR.None
        for obj in (FOOBAR.READ_WRITE, FOOBAR.READ_ONLY):
            assert type(obj).__name__ == 'EnumValue'

    def it_provides_the_enumeration_value_for_each_named_member(self):
        assert FOOBAR.READ_WRITE == 1
        assert FOOBAR.READ_ONLY == -2

    def it_knows_if_a_setting_is_valid(self):
        assert FOOBAR.is_valid_setting(None)
        assert FOOBAR.is_valid_setting(FOOBAR.READ_WRITE)
        assert not FOOBAR.is_valid_setting('foobar')
        assert not FOOBAR.is_valid_setting(FOOBAR.READ_ONLY)

    def it_can_be_referred_to_by_a_convenience_alias_if_defined(self):
        assert BARFOO is FOOBAR  # noqa


class DescribeEnumValue(object):

    def it_provides_its_symbolic_name_as_its_string_value(self):
        assert ('%s' % FOOBAR.READ_WRITE) == 'READ_WRITE (1)'

    def it_provides_its_description_as_its_docstring(self):
        assert FOOBAR.READ_ONLY.__doc__ == 'Return value only'


class DescribeXmlEnumeration(object):

    def it_knows_the_XML_value_for_each_of_its_xml_members(self):
        assert XMLFOO.to_xml(XMLFOO.XML_RW) == 'attrVal'
        assert XMLFOO.to_xml(42) == 'attrVal'
        with pytest.raises(KeyError):
            XMLFOO.to_xml(XMLFOO.RO)

    def it_can_map_each_of_its_xml_members_from_the_XML_value(self):
        assert XMLFOO.from_xml(None) is None
        assert XMLFOO.from_xml('attrVal') == XMLFOO.XML_RW
        assert str(XMLFOO.from_xml('attrVal')) == 'XML_RW (42)'

########NEW FILE########
__FILENAME__ = test_package
# encoding: utf-8

"""
Test suite for pptx.package module
"""

from __future__ import absolute_import, print_function

import pytest

from pptx.package import Package
from pptx.parts.coreprops import CoreProperties
from pptx.parts.presentation import PresentationPart


from .unitutil import absjoin, test_file_dir


images_pptx_path = absjoin(test_file_dir, 'with_images.pptx')


class DescribePackage(object):

    def it_loads_default_template_when_opened_with_no_path(self):
        prs = Package.open().presentation
        assert prs is not None
        slide_masters = prs.slide_masters
        assert slide_masters is not None
        assert len(slide_masters) == 1
        slide_layouts = slide_masters[0].slide_layouts
        assert slide_layouts is not None
        assert len(slide_layouts) == 11

    def it_gathers_package_image_parts_on_open(self):
        pkg = Package.open(images_pptx_path)
        assert len(pkg._images) == 7

    def it_provides_ref_to_package_presentation_part(self):
        pkg = Package.open()
        assert isinstance(pkg.presentation, PresentationPart)

    def it_provides_ref_to_package_core_properties_part(self):
        pkg = Package.open()
        assert isinstance(pkg.core_properties, CoreProperties)

    def it_can_save_itself_to_a_pptx_file(self, temp_pptx_path):
        """
        Package.save produces a .pptx with plausible contents
        """
        # setup ------------------------
        pkg = Package.open()
        # exercise ---------------------
        pkg.save(temp_pptx_path)
        # verify -----------------------
        pkg = Package.open(temp_pptx_path)
        prs = pkg.presentation
        assert prs is not None
        slide_masters = prs.slide_masters
        assert slide_masters is not None
        assert len(slide_masters) == 1
        slide_layouts = slide_masters[0].slide_layouts
        assert slide_layouts is not None
        assert len(slide_layouts) == 11

    # fixtures ---------------------------------------------

    @pytest.fixture
    def temp_pptx_path(self, tmpdir):
        return absjoin(str(tmpdir), 'test-pptx.pptx')

########NEW FILE########
__FILENAME__ = test_text
# encoding: utf-8

"""
Test suite for pptx.text module
"""

from __future__ import absolute_import, print_function

import pytest

from pptx.dml.color import ColorFormat
from pptx.dml.fill import FillFormat
from pptx.enum.text import MSO_ANCHOR, MSO_AUTO_SIZE, PP_ALIGN
from pptx.opc.constants import RELATIONSHIP_TYPE as RT
from pptx.opc.package import Part
from pptx.oxml import parse_xml_bytes
from pptx.oxml.ns import nsdecls, _nsmap as nsmap
from pptx.oxml.text import (
    CT_RegularTextRun, CT_TextCharacterProperties, CT_TextParagraph
)
from pptx.text import _Font, _Hyperlink, _Paragraph, _Run, TextFrame
from pptx.util import Inches, Pt

from .oxml.unitdata.text import (
    a_bodyPr, a_latin, a_txBody, a_noAutofit, a_normAutofit, a_p, a_pPr, a_t,
    an_hlinkClick, an_r, an_rPr, an_spAutoFit
)
from .unitutil import (
    absjoin, actual_xml, class_mock, instance_mock, loose_mock,
    parse_xml_file, property_mock, test_file_dir
)


class DescribeTextFrame(object):

    def it_knows_its_autosize_setting(self, autosize_get_fixture):
        textframe, expected_value = autosize_get_fixture
        assert textframe.auto_size == expected_value

    def it_can_change_its_autosize_setting(self, autosize_set_fixture):
        textframe, value, expected_xml = autosize_set_fixture
        textframe.auto_size = value
        assert actual_xml(textframe._txBody) == expected_xml

    def it_knows_the_number_of_paragraphs_it_contains(
            self, txBody, txBody_with_2_paras):
        assert len(TextFrame(txBody, None).paragraphs) == 1
        assert len(TextFrame(txBody_with_2_paras, None).paragraphs) == 2

    def it_can_add_a_paragraph_to_the_text_it_contains(
            self, txBody, txBody_with_2_paras_xml):
        textframe = TextFrame(txBody, None)
        textframe.add_paragraph()
        assert actual_xml(textframe._txBody) == txBody_with_2_paras_xml

    def it_can_replace_the_text_it_contains(
            self, txBody, txBody_with_text_xml):
        textframe = TextFrame(txBody, None)
        textframe.text = 'foobar'
        assert actual_xml(txBody) == txBody_with_text_xml

    def it_can_get_its_margin_settings(
            self, txBody, txBody_with_lIns, txBody_with_tIns,
            txBody_with_rIns, txBody_with_bIns):

        textframe = TextFrame(txBody, None)
        assert textframe.margin_left is None
        assert textframe.margin_top is None
        assert textframe.margin_right is None
        assert textframe.margin_bottom is None

        textframe = TextFrame(txBody_with_lIns, None)
        assert textframe.margin_left == Inches(0.01)

        textframe = TextFrame(txBody_with_tIns, None)
        assert textframe.margin_top == Inches(0.02)

        textframe = TextFrame(txBody_with_rIns, None)
        assert textframe.margin_right == Inches(0.03)

        textframe = TextFrame(txBody_with_bIns, None)
        assert textframe.margin_bottom == Inches(0.04)

    def it_can_change_its_margin_settings(
            self, txBody_bldr, txBody_with_lIns_xml, txBody_with_tIns_xml,
            txBody_with_rIns_xml, txBody_with_bIns_xml):

        textframe = TextFrame(txBody_bldr.element, None)
        textframe.margin_left = Inches(0.01)
        assert actual_xml(textframe._txBody) == txBody_with_lIns_xml

        textframe = TextFrame(txBody_bldr.element, None)
        textframe.margin_top = Inches(0.02)
        assert actual_xml(textframe._txBody) == txBody_with_tIns_xml

        textframe = TextFrame(txBody_bldr.element, None)
        textframe.margin_right = Inches(0.03)
        assert actual_xml(textframe._txBody) == txBody_with_rIns_xml

        textframe = TextFrame(txBody_bldr.element, None)
        textframe.margin_bottom = Inches(0.04)
        assert actual_xml(textframe._txBody) == txBody_with_bIns_xml

    def it_raises_on_attempt_to_set_margin_to_non_int(self, textframe):
        with pytest.raises(ValueError):
            textframe.margin_bottom = '0.1'

    def it_can_change_its_vertical_anchor_setting(
            self, txBody, txBody_with_anchor_ctr_xml):
        textframe = TextFrame(txBody, None)
        textframe.vertical_anchor = MSO_ANCHOR.MIDDLE
        assert actual_xml(textframe._txBody) == txBody_with_anchor_ctr_xml

    def it_can_change_the_word_wrap_setting(
            self, txBody, txBody_with_wrap_on_xml, txBody_with_wrap_off_xml,
            txBody_xml):
        textframe = TextFrame(txBody, None)
        assert textframe.word_wrap is None

        textframe.word_wrap = True
        assert actual_xml(textframe._txBody) == txBody_with_wrap_on_xml
        assert textframe.word_wrap is True

        textframe.word_wrap = False
        assert actual_xml(textframe._txBody) == txBody_with_wrap_off_xml
        assert textframe.word_wrap is False

        textframe.word_wrap = None
        assert actual_xml(textframe._txBody) == txBody_xml
        assert textframe.word_wrap is None

    def it_knows_the_part_it_belongs_to(self, textframe_with_parent_):
        textframe, parent_ = textframe_with_parent_
        part = textframe.part
        assert part is parent_.part

    # fixtures ---------------------------------------------

    @pytest.fixture(params=[
        None,
        MSO_AUTO_SIZE.NONE,
        MSO_AUTO_SIZE.SHAPE_TO_FIT_TEXT,
        MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE,
    ])
    def autosize_get_fixture(self, request):
        auto_size = request.param
        bodyPr_bldr = self.bodyPr_bldr_with_autofit(auto_size)
        txBody = a_txBody().with_nsdecls().with_child(bodyPr_bldr).element
        textframe = TextFrame(txBody, None)
        expected_value = auto_size
        return textframe, expected_value

    @pytest.fixture(params=[
        None,
        MSO_AUTO_SIZE.NONE,
        MSO_AUTO_SIZE.SHAPE_TO_FIT_TEXT,
        MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE,
    ])
    def autosize_set_fixture(self, request):
        auto_size = request.param
        txBody = a_txBody().with_nsdecls().with_child(a_bodyPr()).element
        textframe = TextFrame(txBody, None)
        value = auto_size
        expected_xml = (
            a_txBody().with_nsdecls().with_child(
                self.bodyPr_bldr_with_autofit(auto_size))
        ).xml()
        return textframe, value, expected_xml

    # fixture components -----------------------------------

    def bodyPr_bldr_with_autofit(self, auto_size):
        bodyPr_bldr = a_bodyPr()
        if auto_size == MSO_AUTO_SIZE.NONE:
            bodyPr_bldr.with_child(a_noAutofit())
        elif auto_size == MSO_AUTO_SIZE.SHAPE_TO_FIT_TEXT:
            bodyPr_bldr.with_child(an_spAutoFit())
        elif auto_size == MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE:
            bodyPr_bldr.with_child(a_normAutofit())
        return bodyPr_bldr

    @pytest.fixture
    def textframe(self, txBody):
        return TextFrame(txBody, None)

    @pytest.fixture
    def textframe_with_parent_(self, request):
        parent_ = loose_mock(request, name='parent_')
        textframe = TextFrame(None, parent_)
        return textframe, parent_

    @pytest.fixture
    def txBody(self, txBody_bldr):
        return txBody_bldr.element

    @pytest.fixture
    def txBody_bldr(self):
        p_bldr = a_p()
        bodyPr_bldr = a_bodyPr()
        return (
            a_txBody().with_nsdecls()
                      .with_child(bodyPr_bldr)
                      .with_child(p_bldr)
        )

    @pytest.fixture
    def txBody_xml(self, txBody_bldr):
        return txBody_bldr.xml()

    @pytest.fixture
    def txBody_with_2_paras(self, _txBody_with_2_paras_bldr):
        return _txBody_with_2_paras_bldr.element

    @pytest.fixture
    def txBody_with_2_paras_xml(self, _txBody_with_2_paras_bldr):
        return _txBody_with_2_paras_bldr.xml()

    @pytest.fixture
    def txBody_with_anchor_ctr_xml(self):
        p_bldr = a_p()
        bodyPr_bldr = a_bodyPr().with_anchor('ctr')
        return (
            a_txBody().with_nsdecls()
                      .with_child(bodyPr_bldr)
                      .with_child(p_bldr)
                      .xml()
        )

    @pytest.fixture
    def txBody_with_bIns(self, _txBody_with_bIns_bldr):
        return _txBody_with_bIns_bldr.element

    @pytest.fixture
    def txBody_with_bIns_xml(self, _txBody_with_bIns_bldr):
        return _txBody_with_bIns_bldr.xml()

    @pytest.fixture
    def txBody_with_lIns(self, _txBody_with_lIns_bldr):
        return _txBody_with_lIns_bldr.element

    @pytest.fixture
    def txBody_with_lIns_xml(self, _txBody_with_lIns_bldr):
        return _txBody_with_lIns_bldr.xml()

    @pytest.fixture
    def txBody_with_rIns(self, _txBody_with_rIns_bldr):
        return _txBody_with_rIns_bldr.element

    @pytest.fixture
    def txBody_with_rIns_xml(self, _txBody_with_rIns_bldr):
        return _txBody_with_rIns_bldr.xml()

    @pytest.fixture
    def txBody_with_tIns(self, _txBody_with_tIns_bldr):
        return _txBody_with_tIns_bldr.element

    @pytest.fixture
    def txBody_with_tIns_xml(self, _txBody_with_tIns_bldr):
        return _txBody_with_tIns_bldr.xml()

    @pytest.fixture
    def txBody_with_text_xml(self):
        t_bldr = a_t().with_text('foobar')
        r_bldr = an_r().with_child(t_bldr)
        p_bldr = a_p().with_child(r_bldr)
        bodyPr_bldr = a_bodyPr()
        return (
            a_txBody().with_nsdecls()
                      .with_child(bodyPr_bldr)
                      .with_child(p_bldr)
                      .xml()
        )

    @pytest.fixture
    def txBody_with_wrap_off_xml(self):
        p_bldr = a_p()
        bodyPr_bldr = a_bodyPr().with_wrap('none')
        return (
            a_txBody().with_nsdecls()
                      .with_child(bodyPr_bldr)
                      .with_child(p_bldr)
                      .xml()
        )

    @pytest.fixture
    def txBody_with_wrap_on_xml(self):
        p_bldr = a_p()
        bodyPr_bldr = a_bodyPr().with_wrap('square')
        return (
            a_txBody().with_nsdecls()
                      .with_child(bodyPr_bldr)
                      .with_child(p_bldr)
                      .xml()
        )

    @pytest.fixture
    def _txBody_with_2_paras_bldr(self):
        p_bldr = a_p()
        bodyPr_bldr = a_bodyPr()
        return (
            a_txBody().with_nsdecls()
                      .with_child(bodyPr_bldr)
                      .with_child(p_bldr)
                      .with_child(p_bldr)
        )

    @pytest.fixture
    def _txBody_with_bIns_bldr(self):
        p_bldr = a_p()
        bodyPr_bldr = a_bodyPr().with_bIns(int(914400*0.04))
        return (
            a_txBody().with_nsdecls()
                      .with_child(bodyPr_bldr)
                      .with_child(p_bldr)
        )

    @pytest.fixture
    def _txBody_with_lIns_bldr(self):
        p_bldr = a_p()
        bodyPr_bldr = a_bodyPr().with_lIns(int(914400*0.01))
        return (
            a_txBody().with_nsdecls()
                      .with_child(bodyPr_bldr)
                      .with_child(p_bldr)
        )

    @pytest.fixture
    def _txBody_with_tIns_bldr(self):
        p_bldr = a_p()
        bodyPr_bldr = a_bodyPr().with_tIns(int(914400*0.02))
        return (
            a_txBody().with_nsdecls()
                      .with_child(bodyPr_bldr)
                      .with_child(p_bldr)
        )

    @pytest.fixture
    def _txBody_with_rIns_bldr(self):
        p_bldr = a_p()
        bodyPr_bldr = a_bodyPr().with_rIns(int(914400*0.03))
        return (
            a_txBody().with_nsdecls()
                      .with_child(bodyPr_bldr)
                      .with_child(p_bldr)
        )


class Describe_Font(object):

    def it_knows_the_bold_setting(self, font, bold_font, bold_off_font):
        assert font.bold is None
        assert bold_font.bold is True
        assert bold_off_font.bold is False

    def it_can_change_the_bold_setting(
            self, font, bold_rPr_xml, bold_off_rPr_xml, rPr_xml):
        assert actual_xml(font._rPr) == rPr_xml
        font.bold = None
        assert actual_xml(font._rPr) == rPr_xml
        font.bold = True
        assert actual_xml(font._rPr) == bold_rPr_xml
        font.bold = False
        assert actual_xml(font._rPr) == bold_off_rPr_xml
        font.bold = None
        assert actual_xml(font._rPr) == rPr_xml

    def it_has_a_color(self, font):
        assert isinstance(font.color, ColorFormat)

    def it_has_a_fill(self, font):
        assert isinstance(font.fill, FillFormat)

    def it_knows_the_italic_setting(self, font, italic_font, italic_off_font):
        assert font.italic is None
        assert italic_font.italic is True
        assert italic_off_font.italic is False

    def it_can_change_the_italic_setting(
            self, font, italic_rPr_xml, italic_off_rPr_xml, rPr_xml):
        assert actual_xml(font._rPr) == rPr_xml
        font.italic = None  # important to test None to None transition
        assert actual_xml(font._rPr) == rPr_xml
        font.italic = True
        assert actual_xml(font._rPr) == italic_rPr_xml
        font.italic = False
        assert actual_xml(font._rPr) == italic_off_rPr_xml
        font.italic = None
        assert actual_xml(font._rPr) == rPr_xml

    def it_knows_its_latin_typeface(self, typeface_get_fixture):
        font, typeface = typeface_get_fixture
        assert font.name == typeface

    def it_can_change_its_latin_typeface(self, typeface_set_fixture):
        font, typeface, rPr_with_latin_xml = typeface_set_fixture
        font.name = typeface
        assert actual_xml(font._rPr) == rPr_with_latin_xml

    def it_knows_the_font_size(self, size_get_fixture):
        font, expected_size = size_get_fixture
        assert font.size == expected_size

    def it_can_set_the_font_size(self, font):
        font.size = Pt(24)
        expected_xml = an_rPr().with_nsdecls().with_sz(2400).xml()
        assert actual_xml(font._rPr) == expected_xml

    # fixtures ---------------------------------------------

    @pytest.fixture(params=[
        (None, None),
        (2400, 304800),
    ])
    def size_get_fixture(self, request):
        sz_val, expected_size = request.param
        rPr_bldr = an_rPr().with_nsdecls()
        if sz_val is not None:
            rPr_bldr.with_sz(sz_val)
        font = _Font(rPr_bldr.element)
        return font, expected_size

    @pytest.fixture(params=[None, 'Foobar Light'])
    def typeface_get_fixture(self, request):
        typeface = request.param
        rPr_bldr = an_rPr().with_nsdecls()
        if typeface is not None:
            rPr_bldr.with_child(a_latin().with_typeface(typeface))
        rPr = rPr_bldr.element
        font = _Font(rPr)
        return font, typeface

    @pytest.fixture(params=[
        (None,            None),
        (None,            'Foobar Light'),
        ('Foobar Light',  'Foobar Medium'),
        ('Foobar Medium', None),
    ])
    def typeface_set_fixture(self, request):
        before_typeface, after_typeface = request.param
        # starting font
        rPr_bldr = an_rPr().with_nsdecls()
        if before_typeface is not None:
            rPr_bldr.with_child(a_latin().with_typeface(before_typeface))
        rPr = rPr_bldr.element
        font = _Font(rPr)
        # expected XML
        rPr_bldr = an_rPr().with_nsdecls()
        if after_typeface is not None:
            rPr_bldr.with_child(a_latin().with_typeface(after_typeface))
        rPr_with_latin_xml = rPr_bldr.xml()
        return font, after_typeface, rPr_with_latin_xml

    # fixture components ---------------------------------------------

    @pytest.fixture
    def bold_font(self):
        bold_rPr = an_rPr().with_nsdecls().with_b(1).element
        return _Font(bold_rPr)

    @pytest.fixture
    def bold_off_font(self):
        bold_off_rPr = an_rPr().with_nsdecls().with_b(0).element
        return _Font(bold_off_rPr)

    @pytest.fixture
    def bold_off_rPr_xml(self):
        return an_rPr().with_nsdecls().with_b(0).xml()

    @pytest.fixture
    def bold_rPr_xml(self):
        return an_rPr().with_nsdecls().with_b(1).xml()

    @pytest.fixture
    def font(self):
        rPr = an_rPr().with_nsdecls().element
        return _Font(rPr)

    @pytest.fixture
    def italic_font(self):
        italic_rPr = an_rPr().with_nsdecls().with_i(1).element
        return _Font(italic_rPr)

    @pytest.fixture
    def italic_off_font(self):
        italic_rPr = an_rPr().with_nsdecls().with_i(0).element
        return _Font(italic_rPr)

    @pytest.fixture
    def italic_off_rPr_xml(self):
        return an_rPr().with_nsdecls().with_i(0).xml()

    @pytest.fixture
    def italic_rPr_xml(self):
        return an_rPr().with_nsdecls().with_i(1).xml()

    @pytest.fixture
    def rPr_xml(self):
        return an_rPr().with_nsdecls().xml()


class Describe_Hyperlink(object):

    def it_knows_the_target_url_of_the_hyperlink(self, hlink_with_url_):
        hlink, rId, url = hlink_with_url_
        assert hlink.address == url
        hlink.part.target_ref.assert_called_once_with(rId)

    def it_has_None_for_address_when_no_hyperlink_is_present(self, hlink):
        assert hlink.address is None

    def it_can_set_the_target_url(
            self, hlink, rPr_with_hlinkClick_xml, url):
        hlink.address = url
        # verify -----------------------
        hlink.part.relate_to.assert_called_once_with(
            url, RT.HYPERLINK, is_external=True
        )
        assert actual_xml(hlink._rPr) == rPr_with_hlinkClick_xml
        assert hlink.address == url

    def it_can_remove_the_hyperlink(self, remove_hlink_fixture_):
        hlink, rPr_xml, rId = remove_hlink_fixture_
        hlink.address = None
        assert actual_xml(hlink._rPr) == rPr_xml
        hlink.part.drop_rel.assert_called_once_with(rId)

    def it_should_remove_the_hyperlink_when_url_set_to_empty_string(
            self, remove_hlink_fixture_):
        hlink, rPr_xml, rId = remove_hlink_fixture_
        hlink.address = ''
        assert actual_xml(hlink._rPr) == rPr_xml
        hlink.part.drop_rel.assert_called_once_with(rId)

    def it_can_change_the_target_url(self, change_hlink_fixture_):
        # fixture ----------------------
        hlink, rId_existing, new_url, new_rPr_xml = change_hlink_fixture_
        # exercise ---------------------
        hlink.address = new_url
        # verify -----------------------
        assert actual_xml(hlink._rPr) == new_rPr_xml
        hlink.part.drop_rel.assert_called_once_with(rId_existing)
        hlink.part.relate_to.assert_called_once_with(
            new_url, RT.HYPERLINK, is_external=True
        )

    # fixtures ---------------------------------------------

    @pytest.fixture
    def change_hlink_fixture_(
            self, request, hlink_with_hlinkClick, rId, rId_2, part_, url_2):
        hlinkClick_bldr = an_hlinkClick().with_rId(rId_2)
        new_rPr_xml = (
            an_rPr().with_nsdecls('a', 'r')
                    .with_child(hlinkClick_bldr)
                    .xml()
        )
        part_.relate_to.return_value = rId_2
        property_mock(request, _Hyperlink, 'part', return_value=part_)
        return hlink_with_hlinkClick, rId, url_2, new_rPr_xml

    @pytest.fixture
    def hlink(self, request, part_):
        rPr = an_rPr().with_nsdecls('a', 'r').element
        hlink = _Hyperlink(rPr, None)
        property_mock(request, _Hyperlink, 'part', return_value=part_)
        return hlink

    @pytest.fixture
    def hlink_with_hlinkClick(self, request, rPr_with_hlinkClick_bldr):
        rPr = rPr_with_hlinkClick_bldr.element
        return _Hyperlink(rPr, None)

    @pytest.fixture
    def hlink_with_url_(
            self, request, part_, hlink_with_hlinkClick, rId, url):
        property_mock(request, _Hyperlink, 'part', return_value=part_)
        return hlink_with_hlinkClick, rId, url

    @pytest.fixture
    def part_(self, request, url, rId):
        """
        Mock Part instance suitable for patching into _Hyperlink.part
        property. It returns url for target_ref() and rId for relate_to().
        """
        part_ = instance_mock(request, Part)
        part_.target_ref.return_value = url
        part_.relate_to.return_value = rId
        return part_

    @pytest.fixture
    def rId(self):
        return 'rId2'

    @pytest.fixture
    def rId_2(self):
        return 'rId6'

    @pytest.fixture
    def remove_hlink_fixture_(
            self, request, hlink_with_hlinkClick, rPr_xml, rId):
        property_mock(request, _Hyperlink, 'part')
        return hlink_with_hlinkClick, rPr_xml, rId

    @pytest.fixture
    def rPr_with_hlinkClick_bldr(self, rId):
        hlinkClick_bldr = an_hlinkClick().with_rId(rId)
        rPr_bldr = (
            an_rPr().with_nsdecls('a', 'r')
                    .with_child(hlinkClick_bldr)
        )
        return rPr_bldr

    @pytest.fixture
    def rPr_with_hlinkClick_xml(self, rPr_with_hlinkClick_bldr):
        return rPr_with_hlinkClick_bldr.xml()

    @pytest.fixture
    def rPr_xml(self):
        return an_rPr().with_nsdecls().xml()

    @pytest.fixture
    def url(self):
        return 'https://github.com/scanny/python-pptx'

    @pytest.fixture
    def url_2(self):
        return 'https://pypi.python.org/pypi/python-pptx'


class Describe_Paragraph(object):

    def it_can_add_a_run(self, paragraph, p_with_r_xml):
        run = paragraph.add_run()
        assert actual_xml(paragraph._p) == p_with_r_xml
        assert isinstance(run, _Run)

    def it_knows_the_alignment_setting_of_the_paragraph(
            self, paragraph, paragraph_with_algn):
        assert paragraph.alignment is None
        assert paragraph_with_algn.alignment == PP_ALIGN.CENTER

    def it_can_change_its_alignment_setting(self, paragraph):
        paragraph.alignment = PP_ALIGN.LEFT
        assert paragraph._pPr.algn == 'l'
        paragraph.alignment = None
        assert paragraph._pPr.algn is None

    def it_can_delete_the_text_it_contains(self, paragraph, p_):
        paragraph._p = p_
        paragraph.clear()
        p_.remove_child_r_elms.assert_called_once_with()

    def it_provides_access_to_the_default_paragraph_font(
            self, paragraph, Font_):
        font = paragraph.font
        Font_.assert_called_once_with(paragraph._defRPr)
        assert font == Font_.return_value

    def test_level_setter_generates_correct_xml(self, paragraph_with_text):
        """_Paragraph.level setter generates correct XML"""
        # setup ------------------------
        expected_xml = (
            '<a:p %s>\n  <a:pPr lvl="2"/>\n  <a:r>\n    <a:t>test text</a:t>'
            '\n  </a:r>\n</a:p>\n' % nsdecls('a')
        )
        # exercise ---------------------
        paragraph_with_text.level = 2
        # verify -----------------------
        assert actual_xml(paragraph_with_text._p) == expected_xml

    def test_level_default_is_zero(self, paragraph_with_text):
        """_Paragraph.level defaults to zero on no lvl attribute"""
        # verify -----------------------
        assert paragraph_with_text.level == 0

    def test_level_roundtrips_intact(self, paragraph_with_text):
        """_Paragraph.level property round-trips intact"""
        # exercise ---------------------
        paragraph_with_text.level = 5
        # verify -----------------------
        assert paragraph_with_text.level == 5

    def test_level_raises_on_bad_value(self, paragraph_with_text):
        """_Paragraph.level raises on attempt to assign invalid value"""
        test_cases = ('0', -1, 9)
        for value in test_cases:
            with pytest.raises(ValueError):
                paragraph_with_text.level = value

    def test_runs_size(self, pList):
        """_Paragraph.runs is expected size"""
        # setup ------------------------
        actual_lengths = []
        for p in pList:
            paragraph = _Paragraph(p, None)
            # exercise ----------------
            actual_lengths.append(len(paragraph.runs))
        # verify ------------------
        expected = [0, 0, 2, 1, 1, 1]
        actual = actual_lengths
        msg = "expected run count %s, got %s" % (expected, actual)
        assert actual == expected, msg

    def test_text_setter_sets_single_run_text(self, pList):
        """assignment to _Paragraph.text creates single run containing value"""
        # setup ------------------------
        test_text = 'python-pptx was here!!'
        p_elm = pList[2]
        paragraph = _Paragraph(p_elm, None)
        # exercise ---------------------
        paragraph.text = test_text
        # verify -----------------------
        assert len(paragraph.runs) == 1
        assert paragraph.runs[0].text == test_text

    def test_text_accepts_non_ascii_strings(self, paragraph_with_text):
        """assignment of non-ASCII string to text does not raise"""
        # setup ------------------------
        _7bit_string = 'String containing only 7-bit (ASCII) characters'
        _8bit_string = '8-bit string: Hr er texti me slenskum stfum.'
        _utf8_literal = u'unicode literal: Hr er texti me slenskum stfum.'
        _utf8_from_8bit = unicode('utf-8 unicode: Hr er texti', 'utf-8')
        # verify -----------------------
        try:
            text = _7bit_string
            paragraph_with_text.text = text
            text = _8bit_string
            paragraph_with_text.text = text
            text = _utf8_literal
            paragraph_with_text.text = text
            text = _utf8_from_8bit
            paragraph_with_text.text = text
        except ValueError:
            msg = "_Paragraph.text rejects valid text string '%s'" % text
            pytest.fail(msg)

    # fixtures ---------------------------------------------

    @pytest.fixture
    def Font_(self, request):
        return class_mock(request, 'pptx.text._Font')

    @pytest.fixture
    def pList(self, sld, xpath):
        return sld.xpath(xpath, namespaces=nsmap)

    @pytest.fixture
    def p_(self, request):
        return instance_mock(request, CT_TextParagraph)

    @pytest.fixture
    def p_bldr(self):
        return a_p().with_nsdecls()

    @pytest.fixture
    def p_with_r_xml(self):
        run_bldr = an_r().with_child(a_t())
        return a_p().with_nsdecls().with_child(run_bldr).xml()

    @pytest.fixture
    def p_with_text(self, p_with_text_xml):
        return parse_xml_bytes(p_with_text_xml)

    @pytest.fixture
    def p_with_text_xml(self, test_text):
        return ('<a:p %s><a:r><a:t>%s</a:t></a:r></a:p>' %
                (nsdecls('a'), test_text))

    @pytest.fixture
    def paragraph(self, p_bldr):
        return _Paragraph(p_bldr.element, None)

    @pytest.fixture
    def paragraph_with_algn(self):
        pPr_bldr = a_pPr().with_algn('ctr')
        p_bldr = a_p().with_nsdecls().with_child(pPr_bldr)
        return _Paragraph(p_bldr.element, None)

    @pytest.fixture
    def paragraph_with_text(self, p_with_text):
        return _Paragraph(p_with_text, None)

    @pytest.fixture
    def path(self):
        return absjoin(test_file_dir, 'slide1.xml')

    @pytest.fixture
    def sld(self, path):
        return parse_xml_file(path).getroot()

    @pytest.fixture
    def test_text(self):
        return 'test text'

    @pytest.fixture
    def xpath(self):
        return './p:cSld/p:spTree/p:sp/p:txBody/a:p'


class Describe_Run(object):

    def it_provides_access_to_the_font_of_the_run(
            self, r_, _Font_, rPr_, font_):
        run = _Run(r_, None)
        font = run.font
        r_.get_or_add_rPr.assert_called_once_with()
        _Font_.assert_called_once_with(rPr_)
        assert font == font_

    def it_provides_access_to_the_hyperlink_of_the_run(self, run):
        hlink = run.hyperlink
        assert isinstance(hlink, _Hyperlink)

    def it_can_get_the_text_of_the_run(self, run, test_text):
        assert run.text == test_text

    def it_can_change_the_text_of_the_run(self, run):
        run.text = 'new text'
        assert run.text == 'new text'

    # fixtures ---------------------------------------------

    @pytest.fixture
    def _Font_(self, request, font_):
        _Font_ = class_mock(request, 'pptx.text._Font')
        _Font_.return_value = font_
        return _Font_

    @pytest.fixture
    def font_(self, request):
        return instance_mock(request, 'pptx.text._Font')

    @pytest.fixture
    def r(self, r_xml):
        return parse_xml_bytes(r_xml)

    @pytest.fixture
    def rPr_(self, request):
        return instance_mock(request, CT_TextCharacterProperties)

    @pytest.fixture
    def r_(self, request, rPr_):
        r_ = instance_mock(request, CT_RegularTextRun)
        r_.get_or_add_rPr.return_value = rPr_
        return r_

    @pytest.fixture
    def r_xml(self, test_text):
        return ('<a:r %s><a:t>%s</a:t></a:r>' %
                (nsdecls('a'), test_text))

    @pytest.fixture
    def run(self, r):
        return _Run(r, None)

    @pytest.fixture
    def test_text(self):
        return 'test text'

########NEW FILE########
__FILENAME__ = test_util
# encoding: utf-8

"""Test suite for pptx.util module."""

from __future__ import absolute_import

import platform
import pytest

from pptx.util import (
    BaseLength, Centipoints, Cm, Collection, Emu, Inches, Mm, Pt, Px,
    to_unicode
)

from .unitutil import TestCase


def test_to_unicode_raises_on_non_string():
    """to_unicode(text) raises on *text* not a string"""
    with pytest.raises(TypeError):
        to_unicode(999)


class TestCollection(TestCase):
    """Test Collection"""
    def setUp(self):
        self.collection = Collection()

    def test_indexable(self):
        """Collection is indexable (e.g. no TypeError on 'collection[0]')"""
        # verify ----------------------
        try:
            self.collection[0]
        except TypeError:
            msg = "'Collection' object does not support indexing"
            self.fail(msg)
        except IndexError:
            pass

    def test_is_container(self):
        """Collection is container (e.g. 'x in collection' works)"""
        # verify ----------------------
        try:
            1 in self.collection
        except TypeError:
            msg = "'Collection' object is not container"
            self.fail(msg)

    def test_iterable(self):
        """Collection is iterable"""
        # verify ----------------------
        try:
            for x in self.collection:
                pass
        except TypeError:
            msg = "'Collection' object is not iterable"
            self.fail(msg)

    def test_sized(self):
        """Collection is sized (e.g. 'len(collection)' works)"""
        # verify ----------------------
        try:
            len(self.collection)
        except TypeError:
            msg = "object of type 'Collection' has no len()"
            self.fail(msg)

    def test__values_property_empty_on_construction(self):
        """Collection._values property empty on construction"""
        # verify ----------------------
        self.assertIsSizedProperty(self.collection, '_values', 0)


class DescribeLength(object):

    def it_can_construct_from_convenient_units(self, construct_fixture):
        UnitCls, units_val, emu = construct_fixture
        length = UnitCls(units_val)
        assert isinstance(length, BaseLength)
        assert length == emu

    def it_can_self_convert_to_convenient_units(self, units_fixture):
        emu, units_prop_name, expected_length_in_units = units_fixture
        length = BaseLength(emu)
        length_in_units = getattr(length, units_prop_name)
        assert length_in_units == expected_length_in_units

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        (BaseLength,  914400,  914400),
        (Inches,      1.1,    1005840),
        (Centipoints, 12.5,      1587),
        (Cm,          2.53,    910799),
        (Emu,         9144.9,    9144),
        (Mm,          13.8,    496800),
        (Pt,          24.5,    311150),
        (Px,          10,
         95250 if platform.system() == 'Windows' else 127000),
    ])
    def construct_fixture(self, request):
        UnitCls, units_val, emu = request.param
        return UnitCls, units_val, emu

    @pytest.fixture(params=[
        (914400, 'inches', 1.0),
        (914400, 'centipoints', 7200.0),
        (914400, 'cm', 2.54),
        (914400, 'emu', 914400),
        (914400, 'mm', 25.4),
        (914400, 'pt', 72.0),
        (914400, 'px', 96 if platform.system() == 'Windows' else 72),
    ])
    def units_fixture(self, request):
        emu, units_prop_name, expected_length_in_units = request.param
        return emu, units_prop_name, expected_length_in_units

########NEW FILE########
__FILENAME__ = test_xmlbldr
# encoding: utf-8

"""
Test suite for tests.xmlbldr module
"""

from __future__ import absolute_import, print_function, unicode_literals

from pptx.enum.text import PP_ALIGN

from .oxml.unitdata.text import a_p, a_pPr, an_rPr


class DescribeCT_TextParagraphBuilder(object):

    def it_can_build_an_empty_p_element(self):
        p_bldr = a_p()
        assert p_bldr.xml() == '<a:p/>\n'

    def it_can_include_a_pPr_child_element(self):
        pPr_bldr = a_pPr()
        p_bldr = a_p().with_child(pPr_bldr)
        expected_xml = (
            '<a:p>\n'
            '  <a:pPr/>\n'
            '</a:p>\n'
        )
        assert p_bldr.xml() == expected_xml


class DescribeCT_TextParagraphPropertiesBuilder(object):

    def it_can_build_an_empty_rPr_element(self):
        pPr_bldr = a_pPr()
        assert pPr_bldr.xml() == '<a:pPr/>\n'

    def it_can_add_an_algn_attribute(self):
        pPr_bldr = a_pPr().with_algn(PP_ALIGN.to_xml(PP_ALIGN.CENTER))
        assert pPr_bldr.xml() == '<a:pPr algn="ctr"/>\n'

    def it_can_add_a_lvl_attribute(self):
        pPr_bldr = a_pPr().with_lvl(2)
        assert pPr_bldr.xml() == '<a:pPr lvl="2"/>\n'


class DescribeCT_TextCharacterPropertiesBuilder(object):

    def it_can_format_xml_text_for_an_empty_rPr_element(self):
        rPr_bldr = an_rPr()
        assert rPr_bldr.xml() == '<a:rPr/>\n'

    def it_can_format_xml_text_for_an_rPr_element_with_nsdecls(self):
        rPr_bldr = an_rPr().with_nsdecls()
        expected_xml = (
            '<a:rPr xmlns:a="http://schemas.openxmlformats.org/drawingml/200'
            '6/main"/>\n'
        )
        assert rPr_bldr.xml() == expected_xml

    def it_can_format_an_rPr_element_with_a_b_attribute(self):
        rPr_bldr = an_rPr().with_b(1)
        assert rPr_bldr.xml() == '<a:rPr b="1"/>\n'

    def it_can_format_an_rPr_element_with_a_i_attribute(self):
        rPr_bldr = an_rPr().with_i(1)
        assert rPr_bldr.xml() == '<a:rPr i="1"/>\n'

    def it_can_format_xml_text_for_an_rPr_element_with_everything(self):
        rPr_bldr = an_rPr().with_nsdecls().with_b(0).with_i(1)
        expected_xml = (
            '<a:rPr xmlns:a="http://schemas.openxmlformats.org/drawingml/200'
            '6/main" b="0" i="1"/>\n'
        )
        assert rPr_bldr.xml() == expected_xml

########NEW FILE########
__FILENAME__ = unitdata
# encoding: utf-8

"""
Shared objects for unit data builder modules
"""

from __future__ import absolute_import, print_function, unicode_literals

from pptx.oxml import parse_xml_bytes
from pptx.oxml.ns import nsdecls


class BaseBuilder(object):
    """
    Provides common behavior for all data builders.
    """
    def __init__(self):
        self._empty = False
        self._nsdecls = ''
        self._text = ''
        self._xmlattrs = []
        self._xmlattr_method_map = {}
        for xmlattr_name in self.__attrs__:
            method_name = 'with_%s' % xmlattr_name
            self._xmlattr_method_map[method_name] = xmlattr_name
        self._child_bldrs = []

    def __getattr__(self, name):
        """
        Intercept attribute access to generalize "with_{xmlattr_name}()"
        methods.
        """
        if name in self._xmlattr_method_map:
            def with_xmlattr(value):
                xmlattr_name = self._xmlattr_method_map[name]
                self._set_xmlattr(xmlattr_name, value)
                return self
            return with_xmlattr
        else:
            tmpl = "'%s' object has no attribute '%s'"
            raise AttributeError(tmpl % (self.__class__.__name__, name))

    def clear(self):
        """
        Reset this builder back to initial state so it can be reused within
        a single test.
        """
        BaseBuilder.__init__(self)
        return self

    @property
    def element(self):
        """
        Element parsed from XML generated by builder in current state
        """
        elm = parse_xml_bytes(self.xml())
        return elm

    def with_child(self, child_bldr):
        """
        Cause new child element specified by *child_bldr* to be appended to
        the children of this element.
        """
        self._child_bldrs.append(child_bldr)
        return self

    def with_text(self, text):
        """
        Cause *text* to be placed between the start and end tags of this
        element. Not robust enough for mixed elements, intended only for
        elements having no child elements.
        """
        self._text = text
        return self

    def with_nsdecls(self, *nspfxs):
        """
        Cause the element to contain namespace declarations. By default, the
        namespace prefixes defined in the Builder class are used. These can
        be overridden by providing exlicit prefixes, e.g.
        ``with_nsdecls('a', 'r')``.
        """
        if not nspfxs:
            nspfxs = self.__nspfxs__
        self._nsdecls = ' %s' % nsdecls(*nspfxs)
        return self

    def xml(self, indent=0):
        """
        Return element XML based on attribute settings
        """
        indent_str = ' ' * indent
        if self._is_empty:
            xml = '%s%s\n' % (indent_str, self._empty_element_tag)
        else:
            xml = '%s\n' % self._non_empty_element_xml(indent)
        return xml

    def xml_bytes(self, indent=0):
        return self.xml(indent=indent).encode('utf-8')

    @property
    def _empty_element_tag(self):
        return '<%s%s%s/>' % (self.__tag__, self._nsdecls, self._xmlattrs_str)

    @property
    def _end_tag(self):
        return '</%s>' % self.__tag__

    @property
    def _is_empty(self):
        return len(self._child_bldrs) == 0 and len(self._text) == 0

    def _non_empty_element_xml(self, indent):
        indent_str = ' ' * indent
        if self._text:
            xml = ('%s%s%s%s' %
                   (indent_str, self._start_tag, self._text, self._end_tag))
        else:
            xml = '%s%s\n' % (indent_str, self._start_tag)
            for child_bldr in self._child_bldrs:
                xml += child_bldr.xml(indent+2)
            xml += '%s%s' % (indent_str, self._end_tag)
        return xml

    def _set_xmlattr(self, xmlattr_name, value):
        xmlattr_str = ' %s="%s"' % (xmlattr_name, str(value))
        self._xmlattrs.append(xmlattr_str)

    @property
    def _start_tag(self):
        return '<%s%s%s>' % (self.__tag__, self._nsdecls, self._xmlattrs_str)

    @property
    def _xmlattrs_str(self):
        """
        Return all element attributes as a string, like ' foo="bar" x="1"'.
        """
        return ''.join(self._xmlattrs)

########NEW FILE########
__FILENAME__ = unitutil
# encoding: utf-8

"""Testing utilities for python-pptx."""

import os
import unittest2

from lxml import etree, objectify
from mock import call  # noqa
from mock import create_autospec, Mock, patch, PropertyMock

from pptx.oxml import oxml_parser


_thisdir = os.path.split(__file__)[0]
test_file_dir = os.path.abspath(os.path.join(_thisdir, 'test_files'))


def absjoin(*paths):
    return os.path.abspath(os.path.join(*paths))


def actual_xml(elm):
    objectify.deannotate(elm, cleanup_namespaces=True)
    return serialize_xml(elm, pretty_print=True)


def parse_xml_file(file_):
    """
    Return ElementTree for XML contained in *file_*
    """
    return objectify.parse(file_, oxml_parser)


def relpath(relpath):
    thisdir = os.path.split(__file__)[0]
    return os.path.relpath(os.path.join(thisdir, relpath))


def serialize_xml(elm, pretty_print=False):
    objectify.deannotate(elm, xsi=False)
    xml = etree.tostring(elm, pretty_print=pretty_print)
    return xml


class TestCase(unittest2.TestCase):
    """Additional assert methods for python-pptx unit testing."""
    def assertEqualLineByLine(self, expected_xml, element):
        """
        Apply assertEqual() to each line of *expected_xml* and corresponding
        line of XML derived from *element*.
        """
        actual_xml = serialize_xml(element, pretty_print=True)
        actual_xml_lines = actual_xml.split('\n')
        expected_xml_lines = expected_xml.split('\n')
        for idx, line in enumerate(actual_xml_lines):
            msg = ("\n\nexpected:\n\n%s'\nbut got\n\n%s'" %
                   (expected_xml, actual_xml))
            self.assertEqual(line, expected_xml_lines[idx], msg)

    def assertIsInstance(self, obj, cls):
        """Raise AssertionError if *obj* is not instance of *cls*."""
        tmpl = "expected instance of '%s', got type '%s'"
        if not isinstance(obj, cls):
            raise AssertionError(tmpl % (cls.__name__, type(obj).__name__))

    def assertIsProperty(self, inst, propname, value, read_only=True):
        """
        Raise AssertionError if *propname* is not a property of *obj* having
        the specified characteristics. Will raise AssertionError if *propname*
        does not exist in *obj*, if its value is not equal to *value*, or if
        *read_only* is True and assignment does not raise AttributeError.
        """
        if not hasattr(inst, propname):
            tmpl = "expected %s to have attribute '%s'"
            raise AssertionError(tmpl % (inst, propname))
        expected = value
        actual = getattr(inst, propname)
        if actual != expected:
            tmpl = "expected '%s', got '%s'"
            raise AssertionError(tmpl % (expected, actual))
        if read_only:
            try:
                with self.assertRaises(AttributeError):
                    setattr(inst, propname, None)
            except AssertionError:
                tmpl = "property '%s' on class '%s' is not read-only"
                clsname = inst.__class__.__name__
                raise AssertionError(tmpl % (propname, clsname))

    def assertIsReadOnly(self, inst, propname):
        """
        Raise AssertionError if *propname* does not raise AttributeError when
        assignment is attempted.
        """
        try:
            with self.assertRaises(AttributeError):
                setattr(inst, propname, None)
        except AssertionError:
            tmpl = "%s.%s is not read-only"
            clsname = inst.__class__.__name__
            raise AssertionError(tmpl % (clsname, propname))

    def assertIsSizedProperty(self, inst, propname, length, read_only=True):
        """
        Raise AssertionError if *propname* is not a property of *obj* having
        the specified characteristics. Will raise AssertionError if *propname*
        does not exist in *obj*, if len(inst.propname) is not equal to
        *length*, or if *read_only* is True and assignment does not raise
        AttributeError.
        """
        if not hasattr(inst, propname):
            tmpl = "expected %s to have attribute '%s'"
            raise AssertionError(tmpl % (inst, propname))
        expected = length
        actual = len(getattr(inst, propname))
        if actual != expected:
            tmpl = "expected length %d, got %d"
            raise AssertionError(tmpl % (expected, actual))
        if read_only:
            try:
                with self.assertRaises(AttributeError):
                    setattr(inst, propname, None)
            except AssertionError:
                tmpl = "property '%s' on class '%s' is not read-only"
                clsname = inst.__class__.__name__
                raise AssertionError(tmpl % (propname, clsname))

    def assertLength(self, sized, length):
        """Raise AssertionError if len(*sized*) != *length*"""
        expected = length
        actual = len(sized)
        msg = "expected length %d, got %d" % (expected, actual)
        self.assertEqual(expected, actual, msg)


def class_mock(request, q_class_name, autospec=True, **kwargs):
    """
    Return a mock patching the class with qualified name *q_class_name*.
    The mock is autospec'ed based on the patched class unless the optional
    argument *autospec* is set to False. Any other keyword arguments are
    passed through to Mock(). Patch is reversed after calling test returns.
    """
    _patch = patch(q_class_name, autospec=autospec, **kwargs)
    request.addfinalizer(_patch.stop)
    return _patch.start()


def cls_attr_mock(request, cls, attr_name, name=None, **kwargs):
    """
    Return a mock for attribute *attr_name* on *cls* where the patch is
    reversed after pytest uses it.
    """
    name = request.fixturename if name is None else name
    _patch = patch.object(cls, attr_name, name=name, **kwargs)
    request.addfinalizer(_patch.stop)
    return _patch.start()


def function_mock(request, q_function_name, **kwargs):
    """
    Return a mock patching the function with qualified name
    *q_function_name*. Patch is reversed after calling test returns.
    """
    _patch = patch(q_function_name, **kwargs)
    request.addfinalizer(_patch.stop)
    return _patch.start()


def initializer_mock(request, cls):
    """
    Return a mock for the __init__ method on *cls* where the patch is
    reversed after pytest uses it.
    """
    _patch = patch.object(cls, '__init__', return_value=None)
    request.addfinalizer(_patch.stop)
    return _patch.start()


def instance_mock(request, cls, name=None, spec_set=True, **kwargs):
    """
    Return a mock for an instance of *cls* that draws its spec from the class
    and does not allow new attributes to be set on the instance. If *name* is
    missing or |None|, the name of the returned |Mock| instance is set to
    *request.fixturename*. Additional keyword arguments are passed through to
    the Mock() call that creates the mock.
    """
    name = name if name is not None else request.fixturename
    return create_autospec(
        cls, _name=name, spec_set=spec_set, instance=True, **kwargs
    )


def loose_mock(request, name=None, **kwargs):
    """
    Return a "loose" mock, meaning it has no spec to constrain calls on it.
    Additional keyword arguments are passed through to Mock(). If called
    without a name, it is assigned the name of the fixture.
    """
    if name is None:
        name = request.fixturename
    return Mock(name=name, **kwargs)


def method_mock(request, cls, method_name, **kwargs):
    """
    Return a mock for method *method_name* on *cls* where the patch is
    reversed after pytest uses it.
    """
    _patch = patch.object(cls, method_name, **kwargs)
    request.addfinalizer(_patch.stop)
    return _patch.start()


def property_mock(request, cls, prop_name, **kwargs):
    """
    Return a mock for property *prop_name* on class *cls* where the patch is
    reversed after pytest uses it.
    """
    _patch = patch.object(cls, prop_name, new_callable=PropertyMock, **kwargs)
    request.addfinalizer(_patch.stop)
    return _patch.start()


def var_mock(request, q_var_name, **kwargs):
    """
    Return a mock patching the variable with qualified name *q_var_name*.
    Patch is reversed after calling test returns.
    """
    _patch = patch(q_var_name, **kwargs)
    request.addfinalizer(_patch.stop)
    return _patch.start()

########NEW FILE########
